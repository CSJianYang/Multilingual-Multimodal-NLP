[
    {
        "title": "Binary Tree Inorder Traversal",
        "question_content": "Given the root of a binary tree, return the inorder traversal of its nodes' values.\n&nbsp;\nExample 1:\n\nInput: root = [1,null,2,3]\nOutput: [1,3,2]\n\nExample 2:\n\nInput: root = []\nOutput: []\n\nExample 3:\n\nInput: root = [1]\nOutput: [1]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [0, 100].\n\t-100 <= Node.val <= 100\n\n&nbsp;\nFollow up: Recursive solution is trivial, could you do it iteratively?",
        "solutions": [
            {
                "id": 283746,
                "title": "all-dfs-traversals-preorder-inorder-postorder-in-python-in-1-line",
                "content": "![image](https://assets.leetcode.com/users/andvary/image_1556551007.png)\\n\\n```\\ndef preorder(root):\\n  return [root.val] + preorder(root.left) + preorder(root.right) if root else []\\n```\\n\\n```\\ndef inorder(root):\\n  return  inorder(root.left) + [root.val] + inorder(root.right) if root else []\\n```\\n\\n```\\ndef postorder(root):\\n  return  postorder(root.left) + postorder(root.right) + [root.val] if root else []\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef preorder(root):\\n  return [root.val] + preorder(root.left) + preorder(root.right) if root else []\\n```\n```\\ndef inorder(root):\\n  return  inorder(root.left) + [root.val] + inorder(root.right) if root else []\\n```\n```\\ndef postorder(root):\\n  return  postorder(root.left) + postorder(root.right) + [root.val] if root else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31213,
                "title": "iterative-solution-in-java-simple-and-readable",
                "content": "    \\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode cur = root;\\n\\n        while(cur!=null || !stack.empty()){\\n            while(cur!=null){\\n                stack.add(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            list.add(cur.val);\\n            cur = cur.right;\\n        }\\n\\n        return list;\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "    \\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode cur = root;\\n\\n        while(cur!=null || !stack.empty()){\\n            while(cur!=null){\\n                stack.add(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            list.add(cur.val);\\n            cur = cur.right;\\n        }\\n\\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31381,
                "title": "python-recursive-and-iterative-solutions",
                "content": "        \\n    # recursively\\n    def inorderTraversal1(self, root):\\n        res = []\\n        self.helper(root, res)\\n        return res\\n        \\n    def helper(self, root, res):\\n        if root:\\n            self.helper(root.left, res)\\n            res.append(root.val)\\n            self.helper(root.right, res)\\n     \\n    # iteratively       \\n    def inorderTraversal(self, root):\\n        res, stack = [], []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                return res\\n            node = stack.pop()\\n            res.append(node.val)\\n            root = node.right",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    # recursively\\n    def inorderTraversal1(self, root):\\n        res = []\\n        self.helper(root, res)\\n        return res\\n        \\n    def helper(self, root, res):\\n        if root:\\n            self.helper(root.left, res)\\n            res.append(root.val)\\n            self.helper(root.right, res)\\n     \\n    # iteratively       \\n    def inorderTraversal(self, root):\\n        res, stack = [], []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                return res\\n            node = stack.pop()\\n            res.append(node.val)\\n            root = node.right",
                "codeTag": "Python3"
            },
            {
                "id": 3169549,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n    vector<int> ans;\\n    if (root == NULL) return ans;\\n    vector<int> left = inorderTraversal(root->left);\\n    ans.insert(ans.end(), left.begin(), left.end());\\n    ans.push_back(root->val);\\n    vector<int> right = inorderTraversal(root->right);\\n    ans.insert(ans.end(), right.begin(), right.end());\\n    return ans;\\n}\\n\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        st = []\\n        res = []\\n\\n        while root or st:\\n            while root:\\n                st.append(root)\\n                root = root.left\\n            \\n            root = st.pop()\\n            res.append(root.val)\\n\\n            root = root.right\\n        \\n        return res   \\n```\\n\\n```Java []\\nclass Solution {\\n    private List<Integer> res = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        traverse(root.left);\\n        res.add(root.val);\\n        traverse(root.right);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n    vector<int> ans;\\n    if (root == NULL) return ans;\\n    vector<int> left = inorderTraversal(root->left);\\n    ans.insert(ans.end(), left.begin(), left.end());\\n    ans.push_back(root->val);\\n    vector<int> right = inorderTraversal(root->right);\\n    ans.insert(ans.end(), right.begin(), right.end());\\n    return ans;\\n}\\n\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        st = []\\n        res = []\\n\\n        while root or st:\\n            while root:\\n                st.append(root)\\n                root = root.left\\n            \\n            root = st.pop()\\n            res.append(root.val)\\n\\n            root = root.right\\n        \\n        return res   \\n```\n```Java []\\nclass Solution {\\n    private List<Integer> res = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        traverse(root.left);\\n        res.add(root.val);\\n        traverse(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31231,
                "title": "c-iterative-recursive-and-morris",
                "content": "There are three solutions to this problem.\\n\\n 1. Iterative solution using stack: `O(n)` time and `O(n)` space;\\n 2. Recursive solution: `O(n)` time and `O(n)` space (function call stack);\\n 3. Morris traversal: `O(n)` time and `O(1)` space.\\n\\n**Iterative solution using stack**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            nodes.push_back(root -> val);\\n            root = root -> right;\\n        }\\n        return nodes;\\n    }\\n};\\n```\\n\\n**Recursive solution**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        inorder(root -> left, nodes);\\n        nodes.push_back(root -> val);\\n        inorder(root -> right, nodes);\\n    }\\n};\\n```\\n\\n**Morris traversal**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        while (root) {\\n            if (root -> left) {\\n                TreeNode* pre = root -> left;\\n                while (pre -> right && pre -> right != root) {\\n                    pre = pre -> right;\\n                }\\n                if (!pre -> right) {\\n                    pre -> right = root;\\n                    root = root -> left;\\n                } else {\\n                    pre -> right = NULL;\\n                    nodes.push_back(root -> val);\\n                    root = root -> right;\\n                }\\n            } else {\\n                nodes.push_back(root -> val);\\n                root = root -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```\\t\\t",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            nodes.push_back(root -> val);\\n            root = root -> right;\\n        }\\n        return nodes;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        inorder(root -> left, nodes);\\n        nodes.push_back(root -> val);\\n        inorder(root -> right, nodes);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        while (root) {\\n            if (root -> left) {\\n                TreeNode* pre = root -> left;\\n                while (pre -> right && pre -> right != root) {\\n                    pre = pre -> right;\\n                }\\n                if (!pre -> right) {\\n                    pre -> right = root;\\n                    root = root -> left;\\n                } else {\\n                    pre -> right = NULL;\\n                    nodes.push_back(root -> val);\\n                    root = root -> right;\\n                }\\n            } else {\\n                nodes.push_back(root -> val);\\n                root = root -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 713539,
                "title": "python-3-all-iterative-traversals-inorder-preorder-postorder-similar-solutions",
                "content": "[Python3] Pre, In, Post Iteratively Summarization\\nIn preorder, the order should be\\n\\nroot -> left -> right\\n\\nBut when we use stack, the order should be reversed:\\n\\nright -> left -> root\\n\\nPre\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:  \\n                    res.append(node.val)\\n                else:  # preorder: root -> left -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n                    stack.append((node, True))\\n        return res\\n```\\n\\n\\nIn inorder, the order should be\\nleft -> root -> right\\n\\nBut when we use stack, the order should be reversed:\\n\\nright -> root -> left\\n\\nIn\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # inorder: left -> root -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n        return res\\n```\\t\\n\\n\\nIn postorder, the order should be\\nleft -> right -> root\\n\\nBut when we use stack, the order should be reversed:\\n\\nroot -> right -> left\\n\\nPost\\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # postorder: left -> right -> root\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:  \\n                    res.append(node.val)\\n                else:  # preorder: root -> left -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n                    stack.append((node, True))\\n        return res\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # inorder: left -> root -> right\\n                    stack.append((node.right, False))\\n                    stack.append((node, True))\\n                    stack.append((node.left, False))\\n        return res\\n```\n```\\nclass Solution:\\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\\n        res, stack = [], [(root, False)]\\n        while stack:\\n            node, visited = stack.pop()  # the last element\\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  # postorder: left -> right -> root\\n                    stack.append((node, True))\\n                    stack.append((node.right, False))\\n                    stack.append((node.left, False))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328601,
                "title": "all-dfs-traversals-preorder-postorder-inorder-in-java-in-5-lines",
                "content": "![image](https://assets.leetcode.com/users/andvary/image_1556551007.png)\\n\\nPreorder: Node -> Left -> Right\\n\\n```\\npublic void preorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  nums.add(root.val);\\n  preorder(root.left, nums);\\n  preorder(root.right, nums);\\n}\\n```\\n\\nInorder : Left -> Node -> Right\\n\\n```\\npublic void inorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  inorder(root.left, nums);\\n  nums.add(root.val);\\n  inorder(root.right, nums);\\n}\\n```\\n\\nPostorder : Left -> Right -> Node\\n\\n```\\npublic void postorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  postorder(root.left, nums);\\n  postorder(root.right, nums);\\n  nums.add(root.val);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic void preorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  nums.add(root.val);\\n  preorder(root.left, nums);\\n  preorder(root.right, nums);\\n}\\n```\n```\\npublic void inorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  inorder(root.left, nums);\\n  nums.add(root.val);\\n  inorder(root.right, nums);\\n}\\n```\n```\\npublic void postorder(TreeNode root, List<Integer> nums) {\\n  if (root == null) return;\\n  postorder(root.left, nums);\\n  postorder(root.right, nums);\\n  nums.add(root.val);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31232,
                "title": "three-methods-to-solve-c",
                "content": "Method 1: Using one stack and the binary tree node will be changed. Easy ,not Practical\\n\\n    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            vector<int> vector;\\n            if(!root)\\n            return vector;\\n            stack<TreeNode *> stack;\\n            stack.push(root);\\n            while(!stack.empty())\\n            {\\n                TreeNode *pNode = stack.top();\\n                if(pNode->left)\\n                {\\n                    stack.push(pNode->left);\\n                    pNode->left = NULL;\\n                }\\n                else\\n                {\\n                    vector.push_back(pNode->val);\\n                    stack.pop();\\n                    if(pNode->right)\\n                    stack.push(pNode->right);\\n                }\\n            }\\n            return vector;\\n        }\\n    };\\n\\nMethod 2: Using one stack and one unordered_map, this will not changed the node. Better\\n\\n    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            vector<int> vector;\\n            if(!root)\\n            return vector;\\n            unordered_map<TreeNode *, bool> map;//left child has been visited:true.\\n            stack<TreeNode *> stack;\\n            stack.push(root);\\n            while(!stack.empty())\\n            {\\n                TreeNode *pNode = stack.top();\\n                if(pNode->left && !map[pNode])\\n                {\\n                    stack.push(pNode->left);\\n                    map[pNode] = true;\\n                }\\n                else\\n                {\\n                    vector.push_back(pNode->val);\\n                    stack.pop();\\n                    if(pNode->right)\\n                    stack.push(pNode->right);\\n                }\\n            }\\n            return vector;\\n        }\\n    };\\n\\nMethod 3: Using one stack  and will not changed the node. Best(at least in this three solutions)\\n\\n    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            vector<int> vector;\\n            stack<TreeNode *> stack;\\n            TreeNode *pCurrent = root;\\n            \\n            while(!stack.empty() || pCurrent)\\n            {\\n                if(pCurrent)\\n                {\\n                    stack.push(pCurrent);\\n                    pCurrent = pCurrent->left;\\n                }\\n                else\\n                {\\n                    TreeNode *pNode = stack.top();\\n                    vector.push_back(pNode->val);\\n                    stack.pop();\\n                    pCurrent = pNode->right;\\n                }\\n            }\\n            return vector;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            vector<int> vector;\\n            if(!root)\\n            return vector;\\n            stack<TreeNode *> stack;\\n            stack.push(root);\\n            while(!stack.empty())\\n            {\\n                TreeNode *pNode = stack.top();\\n                if(pNode->left)\\n                {\\n                    stack.push(pNode->left);\\n                    pNode->left = NULL;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 31228,
                "title": "simple-python-iterative-solution-by-using-a-visited-flag-o-n-56ms",
                "content": "    # Definition for a binary tree node.\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param {TreeNode} root\\n        # @return {integer[]}\\n        def inorderTraversal(self, root):\\n            result, stack = [], [(root, False)]\\n    \\n            while stack:\\n                cur, visited = stack.pop()\\n                if cur:\\n                    if visited:\\n                        result.append(cur.val)\\n                    else:\\n                        stack.append((cur.right, False))\\n                        stack.append((cur, True))\\n                        stack.append((cur.left, False))\\n    \\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 31394,
                "title": "javascript-solution-with-iteration",
                "content": "```js\\nfunction inorderTraversal(root) {\\n  const stack = [];\\n  const res = [];\\n\\n  while (root || stack.length) {\\n    if (root) {\\n      stack.push(root);\\n      root = root.left;\\n    } else {\\n      root = stack.pop();\\n      res.push(root.val);\\n      root = root.right;\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction inorderTraversal(root) {\\n  const stack = [];\\n  const res = [];\\n\\n  while (root || stack.length) {\\n    if (root) {\\n      stack.push(root);\\n      root = root.left;\\n    } else {\\n      root = stack.pop();\\n      res.push(root.val);\\n      root = root.right;\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1377500,
                "title": "3-solutions-1-recursive-2-iterative-o-1-space-complexity-morris-traversal-explained-code",
                "content": "We can solve this problem in three ways lets 1st talk about he recursive method :\\n\\n**1st approach recursive**\\n\\n```\\nvoid helper(TreeNode* root,vector<int>& ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        helper(root->left,ans);\\n        ans.push_back(root->val);\\n        helper(root->right,ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root,ans);\\n        return ans;\\n            \\n    }\\n```\\n\\n\\nthis approach is pretty self explanitory and i don\\'t think it needs any explanation. \\n\\n\\n**2nd approach**\\n\\n\\nJust use a stack\\n\\n```\\n vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        while(root||!s.empty()){\\n            if(root!=NULL){\\n                s.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                root=s.top();\\n                s.pop();\\n                v.push_back(root->val);\\n                root=root->right;\\n            }\\n          }\\n         return v;\\n    }\\n```\\n\\nand keep the nodes in the stack and just perform the left and the right operation and then just pop the stack.\\n\\n\\n**3rd approach and the most optimised approach with T.C. O(n) and S.C O(1)**\\n\\nI have just used the morris-traversal technique.\\nIn this approach we don\\'t need to make any stack or vector we can just manipulate the leaf node and get the desired result.\\n\\nAfter a successful Morris approach your tree will look something like this\\n\\n**Before morris algorithm**\\n![image](https://assets.leetcode.com/users/images/92e256e9-9f11-42a8-bec7-5cfd020a5b7a_1627858941.954608.jpeg)\\n\\n**After morris algorithm**\\n![image](https://assets.leetcode.com/users/images/c91d5981-e57e-4cac-8a38-b8278b447f82_1627858986.5674217.jpeg)\\n\\n\\nso now we can just iterate our root which is at **4** and go till we get a null.\\n\\n\\n```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* temp;\\n        while(root)\\n        {\\n            if(root->left)\\n            {\\n                temp=root->left;\\n                while(temp->right)\\n                {\\n                    temp=temp->right;\\n                }\\n                temp->right=root;\\n                temp=root->left;\\n                root->left=NULL;\\n                root=temp;\\n            }\\n            else\\n            {\\n                ans.push_back(root->val);\\n                root=root->right;\\n                \\n            }\\n        }\\n        return ans;\\n```\\n\\nThis is the code to implement this approach. Please comment down if you have any confusions.\\n\\n**Please consider upvoting if you liked my effort of explaining this problem this will give me motivation to upload more such solutions.**\\n\\n**#happy_coding**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvoid helper(TreeNode* root,vector<int>& ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        helper(root->left,ans);\\n        ans.push_back(root->val);\\n        helper(root->right,ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root,ans);\\n        return ans;\\n            \\n    }\\n```\n```\\n vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> s;\\n        while(root||!s.empty()){\\n            if(root!=NULL){\\n                s.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                root=s.top();\\n                s.pop();\\n                v.push_back(root->val);\\n                root=root->right;\\n            }\\n          }\\n         return v;\\n    }\\n```\n```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* temp;\\n        while(root)\\n        {\\n            if(root->left)\\n            {\\n                temp=root->left;\\n                while(temp->right)\\n                {\\n                    temp=temp->right;\\n                }\\n                temp->right=root;\\n                temp=root->left;\\n                root->left=NULL;\\n                root=temp;\\n            }\\n            else\\n            {\\n                ans.push_back(root->val);\\n                root=root->right;\\n                \\n            }\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 148939,
                "title": "cpp-morris-traversal",
                "content": "# Morris Traversal ( Using Threaded Tree for Inorder Traversal)\\n> O(n) Time | O(1) Space\\n\\n## Definition Threaded Tree\\n\"A binary tree is threaded by making all right child pointers that would normally be null point to the inorder successor of the node (if it exists), and all left child pointers that would normally be null point to the inorder predecessor of the node.\\n\\n![Img](https://upload.wikimedia.org/wikipedia/commons/7/7a/Threaded_tree.svg)\\n\\n\\n## Links\\nMorris Traversal : https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\nThreaded Binary Tree: https://en.wikipedia.org/wiki/Threaded_binary_tree\\n\\n## Note\\nWe are not caring about the predecessor link (C -> B in diagram) here to print inorder. Hence not entirely a threaded tree is made\\n\\n## Pseudo Code\\n```\\n1. Initialize current as root \\n2. While current is not NULL\\n   If current hs a left child\\n      ifa) Make current as right child of the rightmost \\n         node in current\\'s left subtree\\n      ifb) Go to this left child, i.e., current = current->left\\n   Else\\n      ea) Print current\\u2019s data\\n      eb) Go to the right, i.e., current = current->right\\n```\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode* curNode = root;\\n        vector<int> nodes;\\n        \\n        while (curNode != NULL) \\n        {\\n            if (curNode -> left) \\n            {\\n\\t\\t\\t\\t\\t\\t   //Find the inorder predecessor of current\\n               //ifa) Make current as right child of the rightmost node in current\\'s left subtree\\n                TreeNode* predecessor = curNode -> left;\\n                while (predecessor -> right && predecessor -> right != curNode) //second condition used when reverting\\n                    predecessor = predecessor -> right;\\n                \\n                if ((predecessor -> right)==NULL) \\n                {\\n                    predecessor -> right = curNode;\\n                    curNode = curNode -> left; //ifb) Go to this left child\\n                }\\n                else \\n                {\\n                    //Revert back the changes\\n                    predecessor -> right = NULL;\\n                    nodes.push_back(curNode -> val);\\n                    curNode = curNode -> right;\\n                }\\n            }\\n            else \\n            {\\n                nodes.push_back(curNode -> val);  //ea)\\n                curNode = curNode -> right;  //eb)\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n};\\n```\\n\\n## References \\nhttps://leetcode.com/problems/binary-tree-inorder-traversal/discuss/31231/Clear-C++-solutions-iterative-recursive-and-Morris-traversal-(3-different-solutions!)\\nhttps://leetcode.com/problems/binary-tree-inorder-traversal/discuss/31232/Three-Methods-to-Solve-(C++)\\n\\n\\n # Other Solutions\\n ## Recursive\\n \\n ```\\n class Solution {\\npublic:\\n    vector<int> v;\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        find(root);\\n        return v;\\n    }\\n    \\n    void find(TreeNode* root){\\n        if(!root) return;\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n    }\\n};\\n```\\n\\n## Stack Based Solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode *root) {\\n        vector<int> vector;\\n        if(!root)\\n        return vector;\\n        unordered_map<TreeNode *, bool> map;//left child has been visited:true.\\n        stack<TreeNode *> stack;\\n        stack.push(root);\\n        while(!stack.empty())\\n        {\\n            TreeNode *pNode = stack.top();\\n            if(pNode->left && !map[pNode])\\n            {\\n                stack.push(pNode->left);\\n                map[pNode] = true;\\n            }\\n            else\\n            {\\n                vector.push_back(pNode->val);\\n                stack.pop();\\n                if(pNode->right)\\n                stack.push(pNode->right);\\n            }\\n        }\\n        return vector;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n1. Initialize current as root \\n2. While current is not NULL\\n   If current hs a left child\\n      ifa) Make current as right child of the rightmost \\n         node in current\\'s left subtree\\n      ifb) Go to this left child, i.e., current = current->left\\n   Else\\n      ea) Print current\\u2019s data\\n      eb) Go to the right, i.e., current = current->right\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode* curNode = root;\\n        vector<int> nodes;\\n        \\n        while (curNode != NULL) \\n        {\\n            if (curNode -> left) \\n            {\\n\\t\\t\\t\\t\\t\\t   //Find the inorder predecessor of current\\n               //ifa) Make current as right child of the rightmost node in current\\'s left subtree\\n                TreeNode* predecessor = curNode -> left;\\n                while (predecessor -> right && predecessor -> right != curNode) //second condition used when reverting\\n                    predecessor = predecessor -> right;\\n                \\n                if ((predecessor -> right)==NULL) \\n                {\\n                    predecessor -> right = curNode;\\n                    curNode = curNode -> left; //ifb) Go to this left child\\n                }\\n                else \\n                {\\n                    //Revert back the changes\\n                    predecessor -> right = NULL;\\n                    nodes.push_back(curNode -> val);\\n                    curNode = curNode -> right;\\n                }\\n            }\\n            else \\n            {\\n                nodes.push_back(curNode -> val);  //ea)\\n                curNode = curNode -> right;  //eb)\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n};\\n```\n```\\n class Solution {\\npublic:\\n    vector<int> v;\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        find(root);\\n        return v;\\n    }\\n    \\n    void find(TreeNode* root){\\n        if(!root) return;\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode *root) {\\n        vector<int> vector;\\n        if(!root)\\n        return vector;\\n        unordered_map<TreeNode *, bool> map;//left child has been visited:true.\\n        stack<TreeNode *> stack;\\n        stack.push(root);\\n        while(!stack.empty())\\n        {\\n            TreeNode *pNode = stack.top();\\n            if(pNode->left && !map[pNode])\\n            {\\n                stack.push(pNode->left);\\n                map[pNode] = true;\\n            }\\n            else\\n            {\\n                vector.push_back(pNode->val);\\n                stack.pop();\\n                if(pNode->right)\\n                stack.push(pNode->right);\\n            }\\n        }\\n        return vector;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31404,
                "title": "concise-java-solution-based-on-stack",
                "content": "**Explanation**\\n\\nThe basic idea is referred from [here][1]: using stack to simulate the recursion procedure: for each node, travel to its left child until it's left leaf, then pop to left leaf's higher level node A, and switch to A's right branch. Keep the above steps until cur is null and stack is empty. As the following:\\n\\n**Runtime = O(n)**: As each node is visited once\\n\\n**Space = O(n)**\\n\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n    \\tList<Integer> res = new LinkedList<Integer>();\\n    \\tif (root == null) return res;\\n    \\t\\n    \\tStack<TreeNode> stack = new Stack<TreeNode>();\\n    \\tTreeNode cur = root;\\n    \\twhile (cur != null || !stack.isEmpty()) { \\n    \\t\\twhile (cur != null) {// Travel to each node's left child, till reach the left leaf\\n    \\t\\t\\tstack.push(cur);\\n    \\t\\t\\tcur = cur.left;\\t\\t\\t\\t\\n    \\t\\t}\\t\\t \\n    \\t\\tcur = stack.pop(); // Backtrack to higher level node A\\n    \\t\\tres.add(cur.val);  // Add the node to the result list\\n    \\t\\tcur = cur.right;   // Switch to A'right branch\\n    \\t}\\n    \\treturn res;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/19765/iterative-solution-in-java-simple-and-readable",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nThe basic idea is referred from [here][1]: using stack to simulate the recursion procedure: for each node, travel to its left child until it's left leaf, then pop to left leaf's higher level node A, and switch to A's right branch. Keep the above steps until cur is null and stack is empty. As the following:\\n\\n**Runtime = O(n)**: As each node is visited once\\n\\n**Space = O(n)**\\n\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n    \\tList<Integer> res = new LinkedList<Integer>();\\n    \\tif (root == null) return res;\\n    \\t\\n    \\tStack<TreeNode> stack = new Stack<TreeNode>();\\n    \\tTreeNode cur = root;\\n    \\twhile (cur != null || !stack.isEmpty()) { \\n    \\t\\twhile (cur != null) {// Travel to each node's left child, till reach the left leaf\\n    \\t\\t\\tstack.push(cur);\\n    \\t\\t\\tcur = cur.left;\\t\\t\\t\\t\\n    \\t\\t}\\t\\t \\n    \\t\\tcur = stack.pop(); // Backtrack to higher level node A\\n    \\t\\tres.add(cur.val);  // Add the node to the result list\\n    \\t\\tcur = cur.right;   // Switch to A'right branch\\n    \\t}\\n    \\treturn res;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/19765/iterative-solution-in-java-simple-and-readable",
                "codeTag": "Unknown"
            },
            {
                "id": 1374069,
                "title": "iterative-solution-stack-in-python-easy-and-fast-99-89",
                "content": "The rule of Inorder Traversal is simple : For each sub tree, you need **visit left child** of current root, then **save root value**, then **visit right child** of current root, for example:\\n![image](https://assets.leetcode.com/users/images/18b11daa-0a08-4215-9713-c59e5e507abb_1627725926.9611049.png)\\n\\nand you MUST always follow this order\\n\\nWhen you visit each children node (here is node 2 or node 4), \\n* if it\\'s a parent of others children, then apply our rule again\\n* if it\\'s empty- which mean it\\'s a leaf- then add it to the Result_list\\n\\nSo, when the tree is bigger, we can notice the pattern of the job and using Stack for our job:\\n* We always visit until the end of left tree, each time visit, you append children to stack. Why ? Imagine we are saving a checkpoint for later to visit the right part of each root\\n```\\n while root:\\n      stack.append(root)\\n      root = root.left\\n```\\n* Each time finish the loop,  comeback and visit parent value, which is the last value of the stack. So just pop it and add value to the Result_list \\n```\\nroot = stack.pop()\\nresult.append(root.val)\\n```\\nNow the last thing in our rule is visit the right \\n```\\nroot = root.right\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c602e413-e193-4710-9127-10c91c86f7e4_1627726325.61519.png)\\nSo here is the code:\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = []\\n        result = []\\n        \\n        while root or stack:\\n          while root:\\n            stack.append(root)\\n            root = root.left\\n          root = stack.pop()\\n          result.append(root.val)\\n          root = root.right\\n        return result\\n```\\nUpvote if you find it useful =))",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n while root:\\n      stack.append(root)\\n      root = root.left\\n```\n```\\nroot = stack.pop()\\nresult.append(root.val)\\n```\n```\\nroot = root.right\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack = []\\n        result = []\\n        \\n        while root or stack:\\n          while root:\\n            stack.append(root)\\n            root = root.left\\n          root = stack.pop()\\n          result.append(root.val)\\n          root = root.right\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31467,
                "title": "morris-traversal-no-recursion-no-stack",
                "content": "\\tpublic class TreeNode {\\n\\t    int val;\\n\\t    TreeNode left;\\n\\t    TreeNode right;\\n\\t    TreeNode(int x) { val = x; }\\n\\t}\\n\\t\\n\\tpublic class Solution {\\n\\t    public List<Integer> inorderTraversal(TreeNode root) {\\n\\t        if(root == null) return new ArrayList<Integer>();\\n\\t        List<Integer> res = new ArrayList<Integer>();\\n\\t        TreeNode pre = null;\\n\\t        while(root != null){\\n\\t        \\tif(root.left == null){\\n\\t        \\t\\tres.add(root.val);\\n\\t        \\t\\troot = root.right;\\n\\t        \\t}else{\\n\\t        \\t\\tpre = root.left;\\n\\t        \\t\\twhile(pre.right != null && pre.right != root){\\n\\t        \\t\\t\\tpre = pre.right;\\n\\t        \\t\\t}\\n\\t        \\t\\tif(pre.right == null){\\n\\t        \\t\\t\\tpre.right = root;\\n\\t        \\t\\t\\troot = root.left;\\n\\t        \\t\\t}else{\\n\\t        \\t\\t\\tpre.right = null;\\n\\t        \\t\\t\\tres.add(root.val);\\n\\t        \\t\\t\\troot = root.right;\\n\\t        \\t\\t}\\n\\t        \\t}\\n\\t        }\\n\\t        return res;\\n\\t    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t    public List<Integer> inorderTraversal(TreeNode root) {\\n\\t        if(root == null) return new ArrayList<Integer>();\\n\\t        List<Integer> res = new ArrayList<Integer>();\\n\\t        TreeNode pre = null;\\n\\t        while(root != null){\\n\\t        \\tif(root.left == null){\\n\\t        \\t\\tres.add(root.val);\\n\\t        \\t\\troot = root.right;\\n\\t        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 31372,
                "title": "java-solution-both-recursion-and-iteration",
                "content": "\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        // method 1: recursion\\n\\n        helper(root, res);\\n        return res;\\n\\n        //helper function for method 1\\n        private void helper(TreeNode root, List<Integer> res) {\\n            if (root != null) {\\n                if (root.left != null) {\\n                    helper(root.left, res);\\n                }\\n                res.add(root.val);\\n                if (root.right != null) {\\n                    helper(root.right, res);\\n               }\\n           }\\n       }\\n\\n\\n----------\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        // method 2: iteration\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode cur = root;\\n        while (cur != null || !stack.isEmpty()) {\\n            while (cur != null) {\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            res.add(cur.val);\\n            cur = cur.right;\\n        }\\n        return res;        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        // method 1: recursion\\n\\n        helper(root, res);\\n        return res;\\n\\n        //helper function for method 1\\n        private void helper(TreeNode root, List<Integer> res) {\\n            if (root != null) {\\n                if (root.left != null) {\\n                    helper(root.left, res);\\n                }\\n                res.add(root.val);\\n                if (root.right != null) {\\n                    helper(root.right, res);\\n               }\\n           }\\n       }\\n\\n\\n----------\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        // method 2: iteration\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode cur = root;\\n        while (cur != null || !stack.isEmpty()) {\\n            while (cur != null) {\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            res.add(cur.val);\\n            cur = cur.right;\\n        }\\n        return res;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 603442,
                "title": "intuitive-javascript-solution-with-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n  const output = [];\\n  \\n  if (root === null) {\\n    return output;\\n  }\\n  \\n  /**\\n   * The goal is to maintain a stack of nodes to visit as we traverse \\n   * down the tree. As we traverse down, We go left and push all the \\n   * left nodes first in the stack. Once we reach to the bottom, we \\n   * store the node value and traverse right.\\n   *           1\\n   *         /   \\\\\\n   *        2     3    preorder traversal: 4 -> 2 -> 5 -> 1 -> 6 -> 3\\n   *       / \\\\   /     (left -> root -> right)\\n   *      4   5 6\\n   */\\n  const stack = [];\\n  let curr = root;\\n  \\n  while (curr !== null || stack.length !== 0) {\\n    if (curr !== null) {\\n      stack.push(curr);\\n      curr = curr.left;\\n    } else {\\n      curr = stack.pop();\\n      output.push(curr.val);\\n      curr = curr.right;  \\n    }  \\n  }\\n  \\n  return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n  const output = [];\\n  \\n  if (root === null) {\\n    return output;\\n  }\\n  \\n  /**\\n   * The goal is to maintain a stack of nodes to visit as we traverse \\n   * down the tree. As we traverse down, We go left and push all the \\n   * left nodes first in the stack. Once we reach to the bottom, we \\n   * store the node value and traverse right.\\n   *           1\\n   *         /   \\\\\\n   *        2     3    preorder traversal: 4 -> 2 -> 5 -> 1 -> 6 -> 3\\n   *       / \\\\   /     (left -> root -> right)\\n   *      4   5 6\\n   */\\n  const stack = [];\\n  let curr = root;\\n  \\n  while (curr !== null || stack.length !== 0) {\\n    if (curr !== null) {\\n      stack.push(curr);\\n      curr = curr.left;\\n    } else {\\n      curr = stack.pop();\\n      output.push(curr.val);\\n      curr = curr.right;  \\n    }  \\n  }\\n  \\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 691488,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar inorderTraversal = function(root) {\\n    const result = [];\\n    \\n    function traverse(node) {\\n        if(!node) return;\\n        \\n        traverse(node.left);\\n        result.push(node.val);\\n        traverse(node.right);\\n    }\\n    traverse(root);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar inorderTraversal = function(root) {\\n    const result = [];\\n    \\n    function traverse(node) {\\n        if(!node) return;\\n        \\n        traverse(node.left);\\n        result.push(node.val);\\n        traverse(node.right);\\n    }\\n    traverse(root);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 332283,
                "title": "python-recursive-and-iterative-solutions",
                "content": "Please see and vote for my solutions for these similar problems.\\n[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/332283/Python-recursive-and-iterative-solutions)\\n[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/332277/Python-recursive-and-iterative-solutions)\\n[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/332286/Python-recursive-and-iterative-solutions)\\n\\nRecursive solution:\\n```\\n    def inorderTraversal(self, root):\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            in_order.append(node.val)\\n            dfs(node.right)\\n        \\n        in_order = []\\n        dfs(root)\\n        return in_order\\n```\\n\\nIterative solution 1: use a stack and a hashset visited\\n```\\n    def inorderTraversal(self, root):\\n        if not root:\\n            return []\\n        in_order = []\\n        stack = [root]\\n        visited = {root}\\n        while stack:\\n            top = stack[-1]\\n            no_left = True\\n            if top.left and top.left not in visited:\\n                stack.append(top.left)\\n                visited.add(top.left)\\n                no_left = False\\n            if no_left:\\n                stack.pop()\\n                in_order.append(top.val)\\n                if top.right and top.right not in visited:\\n                    stack.append(top.right)\\n                    visited.add(top.right)\\n        return in_order\\n```\\n\\nIterative solution 2: use a stack and a pointer\\n```\\n    def inorderTraversal(self, root):\\n        in_order = []\\n        stack, p = [], root\\n        while stack or p:\\n            if p:\\n                stack.append(p)\\n                p = p.left\\n            else:\\n                p = stack.pop()\\n                in_order.append(p.val)\\n                p = p.right\\n        return in_order\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def inorderTraversal(self, root):\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            in_order.append(node.val)\\n            dfs(node.right)\\n        \\n        in_order = []\\n        dfs(root)\\n        return in_order\\n```\n```\\n    def inorderTraversal(self, root):\\n        if not root:\\n            return []\\n        in_order = []\\n        stack = [root]\\n        visited = {root}\\n        while stack:\\n            top = stack[-1]\\n            no_left = True\\n            if top.left and top.left not in visited:\\n                stack.append(top.left)\\n                visited.add(top.left)\\n                no_left = False\\n            if no_left:\\n                stack.pop()\\n                in_order.append(top.val)\\n                if top.right and top.right not in visited:\\n                    stack.append(top.right)\\n                    visited.add(top.right)\\n        return in_order\\n```\n```\\n    def inorderTraversal(self, root):\\n        in_order = []\\n        stack, p = [], root\\n        while stack or p:\\n            if p:\\n                stack.append(p)\\n                p = p.left\\n            else:\\n                p = stack.pop()\\n                in_order.append(p.val)\\n                p = p.right\\n        return in_order\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1319978,
                "title": "c-clean-concise-code-recursive-faster-than-100-0ms-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void in(TreeNode* root, vector<int> &v){\\n        if(root==NULL){\\n            return;\\n        }\\n        else{\\n            in(root->left,v);\\n            v.push_back(root->val);\\n            in(root->right,v);\\n        }\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        in(root,v);\\n        return v;\\n    }\\n};\\n```\\n**Please help to UPVOTE if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\nHAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void in(TreeNode* root, vector<int> &v){\\n        if(root==NULL){\\n            return;\\n        }\\n        else{\\n            in(root->left,v);\\n            v.push_back(root->val);\\n            in(root->right,v);\\n        }\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        in(root,v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702291,
                "title": "python-iterative-recursive-and-morris-traversal-o-1-space-and-o-n-time-complexity",
                "content": "**Iterative :**\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        output, stack =[],[]\\n        while(stack or root):\\n            if root:\\n                # Go to the left most and push the parent into the stack\\n                # We need this parent node once we are done with left child and need to go to the right child\\n                stack.append(root)\\n                root = root.left\\n            elif stack and root == None:\\n                #We are done with left , so pop out the parent\\n                root = stack.pop()\\n                output.append(root.val)\\n                # Go to the right child\\n                root = root.right\\n        return output\\n```\\nSpace : O(n) , Time : O(n)\\n\\n**Recursive**: \\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        output =[]\\n        def inorderTraversalHelper(root):\\n            if not root:\\n                return None\\n            inorderTraversalHelper(root.left)\\n            output.append(root.val)\\n            inorderTraversalHelper(root.right)\\n        inorderTraversalHelper(root)\\n        return output\\n```\\n\\n**Morris Traversal** : This can be done in constant space using Morris Traversal. Main aim of using a stack is to be able to go to right child of node once you have traverse the left child of a node. Instead of using a stack for that we can create a link between the inorder predecessor of the node and the node. Inorder predecessor of a node is the rightmost child of a left subtree and when you do a inorder traversal the node will come immediately after its inorder predecessor. \\n![image](https://assets.leetcode.com/users/images/9586323c-3a72-4e7a-a23c-27aa97795520_1592941100.20095.png)\\n\\nIf not using stack , create a link between 5 and 1. Now we don\\'t need a stack , we can go to 1 directly via 5. \\n![image](https://assets.leetcode.com/users/images/1793fa7e-e90f-4c74-8a60-7cc04bef6788_1592941130.8812513.png)\\n\\n![image](https://assets.leetcode.com/users/images/daad333c-010d-4a23-a998-1eb1c1102a08_1593026461.844386.png)\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        # Morris Traversal\\n        curr = root\\n        output =[]\\n        while(curr):\\n            #if no left child, we can directly go the right child\\n            if not curr.left:\\n                output.append(curr.val)\\n                curr = curr.right\\n            else:\\n            # find the inorder predecessor of the current node\\n                predecessor = curr.left\\n                # predecessor.right = curr will occur when we have already explored the left subtree of current \\n                # and reached the curr via its predecessor link and now again checking this else condition.\\n                # We have to break out of this loop.\\n                while predecessor.right !=None and predecessor.right != curr:\\n                    predecessor = predecessor.right # go as right as possible\\n\\n                # Now check which out of 2 above condition it reached\\n                if predecessor.right == None:\\n                    # No link created till now, so create one and go to the left child of current.\\n                    predecessor.right = curr\\n                    curr = curr.left\\n                else:\\n                    # left subtree is already visited , so delete the link and then go to right subtree\\n                    predecessor.right = None\\n                    output.append(curr.val)\\n                    curr = curr.right\\n        return output \\n```\\n\\nCode Walk through with the example :\\n1. Curr is 1 and before moving to its left , you have to create a link between 1 and its predecessor.\\n2. Predecessor is 5. Before creating the link , check if the predecessor already contains the link or not. Create a link between 5 and 1 and go to the left of 1 . **It is like putting the curr value to the stack and going to its left.**\\n3. Repeat the same process for curr node 2.  Before moving to its left , create a link between 2 and its predecessor \"4\"\\n![image](https://assets.leetcode.com/users/images/8867ccd2-686b-4ba4-a88e-9de48e65089b_1593704192.85518.png)\\n4. Now there is no curr.left. Add it to the output. Usually in inorder traversal with stack => you pop out from the stack , get the parent , add it to the output and go to left.Here to get the parent , you go to the right and followed the parent using the link created before.\\n![image](https://assets.leetcode.com/users/images/1e30590a-4c94-4d1b-b0ca-5d79d9428e81_1593704211.958061.png)\\n5. Now you are at 2 and **you don\\'t know if you are coming to this 2 for the first time or you have already explored its left**. One way to find it out is to check its predecessor and if link already exist , it means you have already explored the left of 2 and have utlised the link created before to come to 2. Now you can safely delete this link as you will not need it again . Now go to the curr.right. ( Left is done , parent is done)\\n![image](https://assets.leetcode.com/users/images/7ad9a3e5-5a8c-4761-9d23-488b2989d88b_1593704218.4761784.png)\\n6. Now you are at 5. There is no left so append it to the output and go to its right. 5.right = 1(the link we created before). Now repeat the same process of deleting the link as we did before and go to curr right which is 3. ( left is explored , parent is explored)\\n![image](https://assets.leetcode.com/users/images/9c63e1ae-7d79-4f21-af05-4c385bd55443_1593704224.371424.png)\\n7. You are at 3 and there is no left , so add it to the output.\\n![image](https://assets.leetcode.com/users/images/e89a7026-4060-4d7c-a922-70c3f30dafc2_1593704228.9838285.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        output, stack =[],[]\\n        while(stack or root):\\n            if root:\\n                # Go to the left most and push the parent into the stack\\n                # We need this parent node once we are done with left child and need to go to the right child\\n                stack.append(root)\\n                root = root.left\\n            elif stack and root == None:\\n                #We are done with left , so pop out the parent\\n                root = stack.pop()\\n                output.append(root.val)\\n                # Go to the right child\\n                root = root.right\\n        return output\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        output =[]\\n        def inorderTraversalHelper(root):\\n            if not root:\\n                return None\\n            inorderTraversalHelper(root.left)\\n            output.append(root.val)\\n            inorderTraversalHelper(root.right)\\n        inorderTraversalHelper(root)\\n        return output\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        # Morris Traversal\\n        curr = root\\n        output =[]\\n        while(curr):\\n            #if no left child, we can directly go the right child\\n            if not curr.left:\\n                output.append(curr.val)\\n                curr = curr.right\\n            else:\\n            # find the inorder predecessor of the current node\\n                predecessor = curr.left\\n                # predecessor.right = curr will occur when we have already explored the left subtree of current \\n                # and reached the curr via its predecessor link and now again checking this else condition.\\n                # We have to break out of this loop.\\n                while predecessor.right !=None and predecessor.right != curr:\\n                    predecessor = predecessor.right # go as right as possible\\n\\n                # Now check which out of 2 above condition it reached\\n                if predecessor.right == None:\\n                    # No link created till now, so create one and go to the left child of current.\\n                    predecessor.right = curr\\n                    curr = curr.left\\n                else:\\n                    # left subtree is already visited , so delete the link and then go to right subtree\\n                    predecessor.right = None\\n                    output.append(curr.val)\\n                    curr = curr.right\\n        return output \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724058,
                "title": "recursive-and-iterative-approach",
                "content": "# 1. Recursive Approach\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        def inorder(root,ans):\\n            if not root:\\n                return None\\n            inorder(root.left,ans)\\n            ans.append(root.val)\\n            inorder(root.right,ans)\\n        inorder(root,ans)\\n        return ans\\n```\\n# 2. Iterative Approach\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        stack=[]\\n        cur=root\\n        while stack or cur:\\n            if cur:\\n                stack.append(cur)\\n                cur=cur.left\\n            else:\\n                cur=stack.pop()\\n                ans.append(cur.val)\\n                cur=cur.right\\n        return ans\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        def inorder(root,ans):\\n            if not root:\\n                return None\\n            inorder(root.left,ans)\\n            ans.append(root.val)\\n            inorder(root.right,ans)\\n        inorder(root,ans)\\n        return ans\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        stack=[]\\n        cur=root\\n        while stack or cur:\\n            if cur:\\n                stack.append(cur)\\n                cur=cur.left\\n            else:\\n                cur=stack.pop()\\n                ans.append(cur.val)\\n                cur=cur.right\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31463,
                "title": "non-recursive-python-solution",
                "content": "Simple, understandable solution. In the loop: If we get a node with flag false, we add children in correct order and set them to false. because they have to be processed (for their children). And we set flag of current node to true. \\n\\nIf we get node with flag set to true we simply print its value (add to acc).\\nCan be modified to do post and pre order too.\\n\\n    class Solution:\\n        def inorderTraversal(self, root):\\n            stack = [ (False, root) ]\\n            acc = []\\n            \\n            while stack:\\n                flag, val = stack.pop()\\n                if val:\\n                    if not flag:\\n                        stack.append( (False, val.right) )\\n                        stack.append( (True, val) )\\n                        stack.append( (False, val.left) )\\n                    else:\\n                        acc.append( val.val )\\n            return acc",
                "solutionTags": [
                    "Python"
                ],
                "code": "Simple, understandable solution. In the loop: If we get a node with flag false, we add children in correct order and set them to false. because they have to be processed (for their children). And we set flag of current node to true. \\n\\nIf we get node with flag set to true we simply print its value (add to acc).\\nCan be modified to do post and pre order too.\\n\\n    class Solution:\\n        def inorderTraversal(self, root):\\n            stack = [ (False, root) ]\\n            acc = []\\n            \\n            while stack:\\n                flag, val = stack.pop()\\n                if val:\\n                    if not flag:\\n                        stack.append( (False, val.right) )\\n                        stack.append( (True, val) )\\n                        stack.append( (False, val.left) )\\n                    else:\\n                        acc.append( val.val )\\n            return acc",
                "codeTag": "Java"
            },
            {
                "id": 1860290,
                "title": "tree-traversal-algorithms-preorder-inorder-and-postorder-traverse-algorithms-all-in-one",
                "content": "[Leetcode](https://leetcode.com/) [94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/).\\n\\n\\n***By Frank Luo***\\n\\nThe **Tree Traversal Algorithms** are used to traversal the tree including **Binary Tree** and **N-ary Tree**. \\n\\n1. Binary Tree Traversal\\n\\n[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)\\n[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)\\n[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)\\n\\n2. N-ary Tree Traversal\\n\\n[589. N-ary Tree Preorder Traversal](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)\\n[590. N-ary Tree Postorder Traversal](https://leetcode.com/problems/n-ary-tree-postorder-traversal/)\\n\\n\\n# Binary Tree\\n\\n## PreOrder\\n\\nAlgorithm Preorder(tree)\\n1. Visit the root;\\n2. Traverse the left subtree, i.e., call Preorder(left-subtree);\\n3. Traverse the right subtree, i.e., call Preorder(right-subtree). \\n\\n### Recursive\\n\\n```java\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        preOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void preOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        list.add(root.val);\\n        preOrder(root.left, list);\\n        preOrder(root.right, list);\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                ans.add(root.val);\\n                root = root.left;\\n            }\\n            \\n            root = stack.pop();\\n            root = root.right;\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n<!-- more -->\\n\\n## InOrder\\n\\nAlgorithm Inorder(tree)\\n\\n1. Traverse the left subtree, i.e., call Inorder(left-subtree);\\n2. Visit the root;\\n3. Traverse the right subtree, i.e., call Inorder(right-subtree).\\n\\n### Recursive\\n\\n```java\\n    public List<Integer> inorderTraversal_rec(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        inOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void inOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (root.left != null) {\\n            inOrder(root.left, list);\\n        }\\n        list.add(root.val);\\n        if (root.right != null) {\\n            inOrder(root.right, list);\\n        }\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            \\n            root = stack.pop();\\n            ans.add(root.val);\\n            root = root.right;\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n## PostOrder\\n\\nAlgorithm Postorder(tree)\\n1. Traverse the left subtree, i.e., call Postorder(left-subtree);\\n2. Traverse the right subtree, i.e., call Postorder(right-subtree);\\n3. Visit the root.\\n\\n\\n### Recursive\\n\\n```java\\n    public List<Integer> postorderTraversal_rec(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        postOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void postOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        postOrder(root.left, list);\\n        postOrder(root.right, list);\\n        list.add(root.val);\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        TreeNode prev = null;\\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n\\n            root = stack.pop();\\n            if (root.right == null || root.right == prev) {\\n                ans.add(root.val);\\n                prev = root;\\n                root = null;\\n            } else {\\n                stack.push(root);\\n                root = root.right;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n# N-ary Tree Traversal\\n\\n## PreOrder\\n\\n### Recursive\\n\\n```java\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        preOrderTraversal(root, ans);\\n        return ans;\\n    }\\n    \\n    public void preOrderTraversal(Node root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        list.add(root.val);\\n        List<Node> children = root.children;\\n        for (Node child : children) {\\n            preOrderTraversal(child, list);\\n        }\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node node = stack.pop();\\n            ans.add(node.val);\\n            List<Node> children = node.children;\\n            int size = children.size();\\n            for (int i = size - 1; i >= 0; i--) {\\n                stack.push(children.get(i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n## PostOrder\\n\\n### Recursive\\n\\n```java\\n    public List<Integer> postorder_rec(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        postOrderTraversal(root, ans);\\n        return ans;\\n    }\\n    \\n    public void postOrderTraversal(Node root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        List<Node> children = root.children;\\n        for (Node child : children) {\\n            postOrderTraversal(child, list);\\n        }\\n        list.add(root.val);\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n\\n### Iteration\\n\\n```java\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node node = stack.pop();\\n            ans.add(node.val);\\n            List<Node> children = node.children;\\n            int size = children.size();\\n            for (int i = 0; i < size; i++) {\\n                stack.push(children.get(i));\\n            }\\n        }\\n        \\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n```\\n\\n#### Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(n)$\\n\\n-------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```java\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        preOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void preOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        list.add(root.val);\\n        preOrder(root.left, list);\\n        preOrder(root.right, list);\\n    }\\n```\n```java\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                ans.add(root.val);\\n                root = root.left;\\n            }\\n            \\n            root = stack.pop();\\n            root = root.right;\\n        }\\n        \\n        return ans;\\n    }\\n```\n```java\\n    public List<Integer> inorderTraversal_rec(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        inOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void inOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (root.left != null) {\\n            inOrder(root.left, list);\\n        }\\n        list.add(root.val);\\n        if (root.right != null) {\\n            inOrder(root.right, list);\\n        }\\n    }\\n```\n```java\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            \\n            root = stack.pop();\\n            ans.add(root.val);\\n            root = root.right;\\n        }\\n        \\n        return ans;\\n    }\\n```\n```java\\n    public List<Integer> postorderTraversal_rec(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        postOrder(root, ans);\\n        return ans;\\n    }\\n    \\n    public void postOrder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        postOrder(root.left, list);\\n        postOrder(root.right, list);\\n        list.add(root.val);\\n    }\\n```\n```java\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        TreeNode prev = null;\\n        while (root != null || !stack.empty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n\\n            root = stack.pop();\\n            if (root.right == null || root.right == prev) {\\n                ans.add(root.val);\\n                prev = root;\\n                root = null;\\n            } else {\\n                stack.push(root);\\n                root = root.right;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\n```java\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        preOrderTraversal(root, ans);\\n        return ans;\\n    }\\n    \\n    public void preOrderTraversal(Node root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        list.add(root.val);\\n        List<Node> children = root.children;\\n        for (Node child : children) {\\n            preOrderTraversal(child, list);\\n        }\\n    }\\n```\n```java\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node node = stack.pop();\\n            ans.add(node.val);\\n            List<Node> children = node.children;\\n            int size = children.size();\\n            for (int i = size - 1; i >= 0; i--) {\\n                stack.push(children.get(i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\n```java\\n    public List<Integer> postorder_rec(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        postOrderTraversal(root, ans);\\n        return ans;\\n    }\\n    \\n    public void postOrderTraversal(Node root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        List<Node> children = root.children;\\n        for (Node child : children) {\\n            postOrderTraversal(child, list);\\n        }\\n        list.add(root.val);\\n    }\\n```\n```java\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.empty()) {\\n            Node node = stack.pop();\\n            ans.add(node.val);\\n            List<Node> children = node.children;\\n            int size = children.size();\\n            for (int i = 0; i < size; i++) {\\n                stack.push(children.get(i));\\n            }\\n        }\\n        \\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31407,
                "title": "my-3-solutions-in-c",
                "content": "\\n    // recursive, it's trivial...\\n    vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(!root) return v;\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return v;\\n    }\\n    \\n    \\n    // iterate, use stack\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root;\\n        stack<TreeNode*> s;\\n        while(true){\\n            while(temp){\\n                s.push(temp);\\n                temp = temp->left;\\n            }\\n            if(s.empty()) break;\\n            temp = s.top();\\n            s.pop();\\n            v.push_back(temp->val);\\n            temp = temp->right;\\n        }\\n        return v;\\n    }\\n    \\n    \\n    // iterate, morris traversal, without stack\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root, *prev;\\n        while(temp){\\n            if(!temp->left){\\n                v.push_back(temp->val);\\n                temp = temp->right;\\n            }else{\\n                prev = temp->left;\\n                while(prev->right&&(prev->right != temp))\\n                    prev = prev->right;\\n                if(!prev->right){\\n                    prev->right = temp;\\n                    temp = temp->left;\\n                }else{\\n                    v.push_back(temp->val);\\n                    prev->right = NULL;\\n                    temp = temp->right;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    // recursive, it's trivial...\\n    vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(!root) return v;\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return v;\\n    }\\n    \\n    \\n    // iterate, use stack\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root;\\n        stack<TreeNode*> s;\\n        while(true){\\n            while(temp){\\n                s.push(temp);\\n                temp = temp->left;\\n            }\\n            if(s.empty()) break;\\n            temp = s.top();\\n            s.pop();\\n            v.push_back(temp->val);\\n            temp = temp->right;\\n        }\\n        return v;\\n    }\\n    \\n    \\n    // iterate, morris traversal, without stack\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root, *prev;\\n        while(temp){\\n            if(!temp->left){\\n                v.push_back(temp->val);\\n                temp = temp->right;\\n            }else{\\n                prev = temp->left;\\n                while(prev->right&&(prev->right != temp))\\n                    prev = prev->right;\\n                if(!prev->right){\\n                    prev->right = temp;\\n                    temp = temp->left;\\n                }else{\\n                    v.push_back(temp->val);\\n                    prev->right = NULL;\\n                    temp = temp->right;\\n                }\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 434091,
                "title": "js-recursive-clean-code",
                "content": "```\\nconst inorderTraversal = root => {\\n    if (!root) {\\n        return []\\n    }\\n    \\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst inorderTraversal = root => {\\n    if (!root) {\\n        return []\\n    }\\n    \\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3348653,
                "title": "java-fastest-dfs-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(H) h is height of the tree\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/4501697a-bbba-4d67-89cb-f285873536ec_1679937247.5252385.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        \\n        // Check if the root is null\\n        if(root == null){\\n            // If the root is null, return an empty ArrayList\\n            return new ArrayList<Integer>();\\n        }\\n\\n        // Create a new ArrayList to store the values obtained in an in-order traversal\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        // Recursively perform an in-order traversal on the left subtree and add the obtained values to the ArrayList\\n        ans.addAll(inorderTraversal(root.left));\\n\\n        // Add the value of the root to the ArrayList\\n        ans.add(root.val);\\n\\n        // Recursively perform an in-order traversal on the right subtree and add the obtained values to the ArrayList\\n        ans.addAll(inorderTraversal(root.right));\\n\\n        // Return the ArrayList containing all the values obtained in the in-order traversal\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        \\n        // Check if the root is null\\n        if(root == null){\\n            // If the root is null, return an empty ArrayList\\n            return new ArrayList<Integer>();\\n        }\\n\\n        // Create a new ArrayList to store the values obtained in an in-order traversal\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        // Recursively perform an in-order traversal on the left subtree and add the obtained values to the ArrayList\\n        ans.addAll(inorderTraversal(root.left));\\n\\n        // Add the value of the root to the ArrayList\\n        ans.add(root.val);\\n\\n        // Recursively perform an in-order traversal on the right subtree and add the obtained values to the ArrayList\\n        ans.addAll(inorderTraversal(root.right));\\n\\n        // Return the ArrayList containing all the values obtained in the in-order traversal\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019265,
                "title": "stack-c-inorder-beginner-friendly",
                "content": "**Runtime: 0 ms, faster than 100.00% of C++ online submissions \\nMemory Usage: 9.4 MB, less than 11.18% of C++ online submissions**\\n```\\nclass Solution {\\npublic:\\n    vector<int> vec;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==nullptr) return {};\\n        inorderTraversal(root->left);\\n        vec.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\\n**Runtime: 0 ms, faster than 100.00% of C++ online submissions \\nMemory Usage: 8.6 MB, less than 11.18% of C++ online submissions**\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root){ \\n        if(root==NULL)\\n           return {};\\n        vector<int> vec;\\n        stack<TreeNode*> s;\\n        while(true){\\n            if(root!=NULL){\\n               s.push(root);\\n               root=root->left; \\n            }\\n            else{\\n                if(s.empty())\\n                    break;\\n                root=s.top();\\n                s.pop();\\n                vec.push_back(root->val);\\n                root=root->right;\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vec;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==nullptr) return {};\\n        inorderTraversal(root->left);\\n        vec.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root){ \\n        if(root==NULL)\\n           return {};\\n        vector<int> vec;\\n        stack<TreeNode*> s;\\n        while(true){\\n            if(root!=NULL){\\n               s.push(root);\\n               root=root->left; \\n            }\\n            else{\\n                if(s.empty())\\n                    break;\\n                root=s.top();\\n                s.pop();\\n                vec.push_back(root->val);\\n                root=root->right;\\n            }\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158278,
                "title": "python-stack-dfs",
                "content": "### 94. Binary Tree Inorder Traversal\\n```\\n> \\u7C7B\\u578B\\uFF1A\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\\n\\n#### DFS Recursive\\n```python\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        self.res = []\\n        self.dfs(root)\\n        return self.res\\n        \\n    def dfs(self, root):\\n        if not root:\\n            return\\n        self.dfs(root.left)\\n        self.res.append(root.val)\\n        self.dfs(root.right)\\n```\\n\\n#### Stack\\n\\n\\u5148\\u628A\\u8FED\\u4EE3\\u5230\\u6700\\u5DE6\\u8FB9\\u7684\\u53F6\\u5B50\\u8282\\u70B9\\uFF0C\\u628A\\u6240\\u6709\\u9014\\u4E2D\\u7684`root`\\u653E\\u8FDBstack\\uFF0C\\u5F53\\u5DE6\\u8FB9\\u8D70\\u4E0D\\u901A\\u4E86\\uFF0C\\u5F00\\u59CB\\u5F80`res`\\u91CC\\u9762\\u5B58\\u6570\\uFF0C\\u5E76\\u5F80\\u53F3\\u8FB9\\u8D70\\u3002\\n\\n```python\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        res, stack = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                res.append(node.val)\\n                root = node.right\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1A\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\n```python\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        self.res = []\\n        self.dfs(root)\\n        return self.res\\n        \\n    def dfs(self, root):\\n        if not root:\\n            return\\n        self.dfs(root.left)\\n        self.res.append(root.val)\\n        self.dfs(root.right)\\n```\n```python\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        res, stack = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                res.append(node.val)\\n                root = node.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073216,
                "title": "python-3-solutions-recursive-iterative",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        #\\n        ## recursive\\n        if not root: return []\\n        else: return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)\\n```\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        #\\n        ## iteration\\n        stack,res = [],[]\\n        node = root\\n        # why we need to judge the node or the stack at the same time?\\n        # Because we will stop the first while loop when it reach the far-right leaf.\\n        # However, the stack will be empty when the node reaches the root.\\n        # And the node will be None when we reach the left leaf.\\n        # To make sure the node reaches the far-right leaf, we need to check the node and stack\\n        # in the first while loop.\\n        while node or stack:\\n            while node: # put all left nodes in the stack\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            res.append(node.val)\\n            # change the direction to the right direction after the left.children\\n            # and parent are taken care of, which the inorder means.\\n            node = node.right\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        #\\n        ## recursive\\n        if not root: return []\\n        else: return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        #\\n        ## iteration\\n        stack,res = [],[]\\n        node = root\\n        # why we need to judge the node or the stack at the same time?\\n        # Because we will stop the first while loop when it reach the far-right leaf.\\n        # However, the stack will be empty when the node reaches the root.\\n        # And the node will be None when we reach the left leaf.\\n        # To make sure the node reaches the far-right leaf, we need to check the node and stack\\n        # in the first while loop.\\n        while node or stack:\\n            while node: # put all left nodes in the stack\\n                stack.append(node)\\n                node = node.left\\n            node = stack.pop()\\n            res.append(node.val)\\n            # change the direction to the right direction after the left.children\\n            # and parent are taken care of, which the inorder means.\\n            node = node.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338663,
                "title": "python-inorder-iterative-stack-t-f-explanation",
                "content": "InOrder Traversal:\\n\\t- Traverse the left side\\n\\t- hit the root\\n\\t- traverse the right side \\n\\nW/ recursive go -> left,root,right\\nW/iterative stack go -> right,root,left\\n\\t - stack follows LIFO(last-in-first-out)\\n\\t - so you\\'ll iterate through the right side first, but you\\'ll pop OUT the left side first\\n\\t - aka its backwards traversal to get the proper answer \\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res = []\\n        # root starts out False because you haven\\'t visited it yet\\n        stack = [(root, False)]\\n        \\n        while stack:\\n            # pop the last element\\n            node, visited = stack.pop() \\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  \\n                    # inorder: left -> root -> right\\n                    # switch because stacks work backwards\\n                    stack.append((node.right, False)) # has not been visited before\\n                    stack.append((node, True)) # has been visited before\\n                    stack.append((node.left, False)) # has not been visited before \\n        return res\\n```\\n\\nNow to the fun part... True or False?\\n- False = you have appended to stack once\\n- True = you have popped the False, second appending is True\\n\\n```\\n# True vs. False\\n\\n         1\\n        / \\\\\\n       2   3\\n      / \\\\\\n     4   5\\n\\nroot  = 1\\nstack = [(root,False)]\\nFalse = not yet visited \\n\\n\\n# While stack:\\n    node, visited = stack.pop([(1,False)])\\n    \\n    if node: node = (1)\\n        if visited: FALSE\\n        \\n        else:   stack.append(node = 3, False) # hasn\\'t been visited yet \\n                stack.append(node = 1, True) # has been visited once before\\n                stack.append(node = 2, False) # hasn\\'t been visited yet\\nstack = [(3,False),(1, True),(2,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(2,False)\\n    \\n    if node: node = 2\\n        if visited: FALSE\\n        \\n        else:   stack.append(node = 5, False) # hasn\\'t been visited yet   \\n                stack.append(node = 2, True) # has been visited once before\\n                stack.append(node = 4, False) # hasn\\'t been visited yet         \\nstack = [(3,False),(1, True),(5,False),(2,True),(4,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(4,False)\\n    \\n    if node: node = 4\\n        if visited: False\\n\\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 4, True) # has been visited once before\\n                stack.append(NA) # leaf         \\nstack = [(3,False),(1, True),(5,False),(2,True),(4,True)]\\n\\n# while stack:\\n    node, visited = stack.pop(4,True)\\n    \\n    if node: node = 4\\n        if visited: True\\n            res.append(node.4)\\nres = [4]\\nstack = [(3,False),(1, True),(5,False),(2,True)]\\n\\n# while stack:\\n    node, visited = stack.pop(2,True)\\n    \\n    if node: node = 2\\n        if visited: True \\n            res.append(node.2)\\nres = [4,2]\\nstack = [(3,False),(1, True),(5,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(5,False)\\n    \\n    if node: node = 5\\n        if visited: False\\n            \\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 5, True) # has been visited once before\\n                stack.append(NA) # leaf              \\nres = [4,2]\\nstack = [(3,False),(1, True),(5,True)]        \\n\\n# while stack:\\n    node, visited = stack.pop(5,True)\\n    \\n    if node: node = 5\\n        if visited: True \\n            res.append(node.5)\\nres = [4,2,5]\\nstack = [(3,False),(1, True)]  \\n\\n# while stack:\\n    node, visited = stack.pop(1,True)\\n    \\n    if node: node = 1\\n        if visited: True \\n            res.append(node.1)\\nres = [4,2,5,1]\\nstack = [(3,False)]  \\n\\n# while stack:\\n    node, visited = stack.pop(3,False)\\n    \\n    if node: node = 3\\n        if visited: False\\n\\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 3, True) # has been visited once before\\n                stack.append(NA) # leaf   \\nres = [4,2,5,1]\\nstack = [(3,True)] \\n\\n# while stack:\\n    node, visited = stack.pop(3,True)\\n    if node: node = 3\\n        if visited: True \\n            res.append(node.3)\\nres = [4,2,5,1,3]\\nstack = []  \\n```\\n\\nHope that helps :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res = []\\n        # root starts out False because you haven\\'t visited it yet\\n        stack = [(root, False)]\\n        \\n        while stack:\\n            # pop the last element\\n            node, visited = stack.pop() \\n            if node:\\n                if visited:\\n                    res.append(node.val)\\n                else:  \\n                    # inorder: left -> root -> right\\n                    # switch because stacks work backwards\\n                    stack.append((node.right, False)) # has not been visited before\\n                    stack.append((node, True)) # has been visited before\\n                    stack.append((node.left, False)) # has not been visited before \\n        return res\\n```\n```\\n# True vs. False\\n\\n         1\\n        / \\\\\\n       2   3\\n      / \\\\\\n     4   5\\n\\nroot  = 1\\nstack = [(root,False)]\\nFalse = not yet visited \\n\\n\\n# While stack:\\n    node, visited = stack.pop([(1,False)])\\n    \\n    if node: node = (1)\\n        if visited: FALSE\\n        \\n        else:   stack.append(node = 3, False) # hasn\\'t been visited yet \\n                stack.append(node = 1, True) # has been visited once before\\n                stack.append(node = 2, False) # hasn\\'t been visited yet\\nstack = [(3,False),(1, True),(2,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(2,False)\\n    \\n    if node: node = 2\\n        if visited: FALSE\\n        \\n        else:   stack.append(node = 5, False) # hasn\\'t been visited yet   \\n                stack.append(node = 2, True) # has been visited once before\\n                stack.append(node = 4, False) # hasn\\'t been visited yet         \\nstack = [(3,False),(1, True),(5,False),(2,True),(4,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(4,False)\\n    \\n    if node: node = 4\\n        if visited: False\\n\\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 4, True) # has been visited once before\\n                stack.append(NA) # leaf         \\nstack = [(3,False),(1, True),(5,False),(2,True),(4,True)]\\n\\n# while stack:\\n    node, visited = stack.pop(4,True)\\n    \\n    if node: node = 4\\n        if visited: True\\n            res.append(node.4)\\nres = [4]\\nstack = [(3,False),(1, True),(5,False),(2,True)]\\n\\n# while stack:\\n    node, visited = stack.pop(2,True)\\n    \\n    if node: node = 2\\n        if visited: True \\n            res.append(node.2)\\nres = [4,2]\\nstack = [(3,False),(1, True),(5,False)]\\n\\n# while stack:\\n    node, visited = stack.pop(5,False)\\n    \\n    if node: node = 5\\n        if visited: False\\n            \\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 5, True) # has been visited once before\\n                stack.append(NA) # leaf              \\nres = [4,2]\\nstack = [(3,False),(1, True),(5,True)]        \\n\\n# while stack:\\n    node, visited = stack.pop(5,True)\\n    \\n    if node: node = 5\\n        if visited: True \\n            res.append(node.5)\\nres = [4,2,5]\\nstack = [(3,False),(1, True)]  \\n\\n# while stack:\\n    node, visited = stack.pop(1,True)\\n    \\n    if node: node = 1\\n        if visited: True \\n            res.append(node.1)\\nres = [4,2,5,1]\\nstack = [(3,False)]  \\n\\n# while stack:\\n    node, visited = stack.pop(3,False)\\n    \\n    if node: node = 3\\n        if visited: False\\n\\n        else:   stack.append(NA) # leaf   \\n                stack.append(node = 3, True) # has been visited once before\\n                stack.append(NA) # leaf   \\nres = [4,2,5,1]\\nstack = [(3,True)] \\n\\n# while stack:\\n    node, visited = stack.pop(3,True)\\n    if node: node = 3\\n        if visited: True \\n            res.append(node.3)\\nres = [4,2,5,1,3]\\nstack = []  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287690,
                "title": "c-solution-100-faster-iterative-and-recursive-version",
                "content": "Both iterative and recursive solutions are equally fast(0ms, 100% faster).\\n\\n```\\n//iterative solution using stack\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    int*ans=malloc(100*sizeof(int));\\n    *returnSize=0;\\n    struct TreeNode**stack=malloc(100*sizeof(struct TreeNode*));\\n    int top=0;\\n    while(top||root){\\n        if(root){\\n            stack[top++]=root;\\n            root=root->left;\\n        }\\n        else{\\n            root=stack[--top];\\n            ans[(*returnSize)++]=root->val;\\n            root=root->right;\\n        }\\n    }\\n    free(stack);\\n    ans=realloc(ans,(*returnSize)*sizeof(int));\\n    return ans;\\n}\\n```\\n\\n```\\n//recursive solution\\nvoid traverse(struct TreeNode* root, int* arr, int* returnSize){\\n    if(root->left)\\n        traverse(root->left,arr,returnSize);\\n    arr[(*returnSize)++]=root->val;\\n    if(root->right)\\n        traverse(root->right,arr,returnSize);\\n}\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    int*arr=malloc(100*sizeof(int));\\n    *returnSize=0;\\n    if(root)\\n        traverse(root,arr,returnSize);\\n    arr=realloc(arr,(*returnSize)*sizeof(int));\\n    return arr;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//iterative solution using stack\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    int*ans=malloc(100*sizeof(int));\\n    *returnSize=0;\\n    struct TreeNode**stack=malloc(100*sizeof(struct TreeNode*));\\n    int top=0;\\n    while(top||root){\\n        if(root){\\n            stack[top++]=root;\\n            root=root->left;\\n        }\\n        else{\\n            root=stack[--top];\\n            ans[(*returnSize)++]=root->val;\\n            root=root->right;\\n        }\\n    }\\n    free(stack);\\n    ans=realloc(ans,(*returnSize)*sizeof(int));\\n    return ans;\\n}\\n```\n```\\n//recursive solution\\nvoid traverse(struct TreeNode* root, int* arr, int* returnSize){\\n    if(root->left)\\n        traverse(root->left,arr,returnSize);\\n    arr[(*returnSize)++]=root->val;\\n    if(root->right)\\n        traverse(root->right,arr,returnSize);\\n}\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    int*arr=malloc(100*sizeof(int));\\n    *returnSize=0;\\n    if(root)\\n        traverse(root,arr,returnSize);\\n    arr=realloc(arr,(*returnSize)*sizeof(int));\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2547065,
                "title": "leetcode-the-hard-way-dfs-in-order-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\nYou may also check out my recent DFS solutions on other tree problems.\\n\\n- [987. Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/discuss/2527028/leetcode-the-hard-way-easy-dfs-explained-line-by-line)\\n- [1448. Count Good Nodes in Binary Tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/discuss/2511705/leetcode-the-hard-way-dfs-explained-line-by-line)\\n- [814. Binary Tree Pruning](https://leetcode.com/problems/binary-tree-pruning/discuss/2537510/leetcode-the-hard-way-easy-dfs-explained-line-by-line)\\n- [606. Construct String from Binary Tree](https://leetcode.com/problems/construct-string-from-binary-tree/discuss/2542523/leetcode-the-hard-way-dfs-5-cases-explained-line-by-line)\\n\\nThe steps for in-order is \\n- traverse left subtree \\n- do something with root value\\n-  traverse right sub tree. \\n\\nFor example 1, starting the root node 1.\\n \\n- At node 1 now, traverse left node first, however, there is no left node, hence return.\\n- At node 1 now, add root value which is 1. answer = [1]\\n- At node 1 now, traverse right node.\\n- At node 2 now, traverse left node first.\\n- At node 3 now,  traverse left node first, however, there is no left node, hence return.\\n- At node 3 now, add root value which is 3. answer = [1, 3]\\n- At node 3 now,  traverse right node, however, there is no right node, hence return.\\n- At node 2 now, add root value which is 2. answer = [1, 3, 2]\\n- At node 2 now, traverse right node, however, there is no right node, hence return.\\n\\n**C++**\\n\\n```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\n\\n// This is a standard in-order traversal problem, I\\'d suggest to learn pre-order and post-order as well.\\n// Here\\'s a short tutorial if you\\'re interested.\\n// https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n// then you may try the following problems \\n// 144. Binary Tree Preorder Traversal: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n// 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void inorder(TreeNode* node) {\\n        if (node == NULL) return;\\n        // traverse the left node\\n        inorder(node->left);\\n        // do something with node value here\\n        ans.push_back(node->val);\\n        // traverse the right node\\n        inorder(node->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# This is a standard in-order traversal problem, I\\'d suggest to learn pre-order and post-order as well.\\n# Here\\'s a short tutorial if you\\'re interested.\\n# https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n# then you may try the following problems \\n# 144. Binary Tree Preorder Traversal: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n# 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\t# left -> root -> right\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\n\\n// This is a standard in-order traversal problem, I\\'d suggest to learn pre-order and post-order as well.\\n// Here\\'s a short tutorial if you\\'re interested.\\n// https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n// then you may try the following problems \\n// 144. Binary Tree Preorder Traversal: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n// 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void inorder(TreeNode* node) {\\n        if (node == NULL) return;\\n        // traverse the left node\\n        inorder(node->left);\\n        // do something with node value here\\n        ans.push_back(node->val);\\n        // traverse the right node\\n        inorder(node->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root);\\n        return ans;\\n    }\\n};\\n```\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# This is a standard in-order traversal problem, I\\'d suggest to learn pre-order and post-order as well.\\n# Here\\'s a short tutorial if you\\'re interested.\\n# https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n# then you may try the following problems \\n# 144. Binary Tree Preorder Traversal: https://leetcode.com/problems/binary-tree-preorder-traversal/\\n# 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\t# left -> root -> right\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508286,
                "title": "c-simple-recursive-solution",
                "content": "**C++ :**\\n\\n```\\nvoid inorderTraversalHelper(TreeNode* root, vector<int> &res) {\\n\\tif(root)\\n\\t{\\n\\t\\tif(root -> left)\\n\\t\\t\\tinorderTraversalHelper(root -> left, res);\\n\\n\\t\\tres.push_back(root -> val);\\n\\n\\t\\tif(root -> right)\\n\\t\\t\\tinorderTraversalHelper(root -> right, res);\\n\\t}\\n\\n\\treturn;\\n}\\n\\n\\nvector<int> inorderTraversal(TreeNode* root) \\n{   \\n\\tvector<int> res;\\n\\tinorderTraversalHelper(root, res) ;\\n\\treturn res;\\n}\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvoid inorderTraversalHelper(TreeNode* root, vector<int> &res) {\\n\\tif(root)\\n\\t{\\n\\t\\tif(root -> left)\\n\\t\\t\\tinorderTraversalHelper(root -> left, res);\\n\\n\\t\\tres.push_back(root -> val);\\n\\n\\t\\tif(root -> right)\\n\\t\\t\\tinorderTraversalHelper(root -> right, res);\\n\\t}\\n\\n\\treturn;\\n}\\n\\n\\nvector<int> inorderTraversal(TreeNode* root) \\n{   \\n\\tvector<int> res;\\n\\tinorderTraversalHelper(root, res) ;\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31313,
                "title": "three-ways-of-iterative-inorder-traversing-easy-explanation",
                "content": "Three types of Iterative Inorder Traversals. \\n\\n1) **Using 1 Stack.** O(n) Time & O(n) Space\\n\\t* Push all `left` nodes into the `stack` till it hits `NULL`.\\n\\t* Then `Pop` the top element from the stack, print it and make the `root` point to its `right`.\\n\\t* Keep iterating till `both` the below conditions are met -\\n\\t\\t* Stack is empty `and`\\n        * Root is NULL.\\n\\t\\n```\\n \\npublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root==null)\\n\\t\\t\\treturn out;\\n\\t\\tStack<TreeNode> s = new Stack();      \\n\\t\\twhile(root!=null || !s.empty()){\\n\\t\\t\\tif(root!=null){\\t\\t\\t\\t\\n\\t\\t\\t\\ts.push(root);\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot = s.pop();\\n\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\\n\\n2) **Using 2 Stacks.** O(n) Time & O(n) Space\\nWe use two stacks. Stack `s` is used to find and traverse the child nodes, and `path` stack keeps track of the path from the `root` to the current node. (This is usefull in certain problems like [Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/) and [Path Sum](https://leetcode.com/problems/path-sum/) ). \\nThe logic is similar to [Preorder using 2 Stacks](https://discuss.leetcode.com/topic/64675/three-ways-of-iterative-preorder-traversing-easy-explanation) . The difference is on every iteration we first pop `s`. Then push it back in when we push the children. Make sure the order of pushing is right child -> root -> left child. Also, we print the element only on our way back.\\n    * Initially we push the `root` into `s`.\\n\\t* Keep iterating with below logic till `s` is `empty`.\\n\\t\\t* `root` = `s.pop()`\\n\\t\\t* If the top elements of both the stacks are not the same :\\t\\t\\n\\t\\t\\t* Push `root` into `path`.\\n\\t\\t\\t* Push `right child` into `s` if it exists.\\n\\t\\t\\t* Push `root` back into `s`.\\n\\t\\t\\t* Now, push `left child` into `s` if it exists.\\n\\t\\t* When top elements of both stacks are equal. (Which means we hit a deadend, and need to turn back)\\n\\t\\t\\t* Pop from `path`.\\n\\t\\t\\t* Print the root.\\n\\t\\n```\\n\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n        if(root == null)\\n            return out; \\n        Stack<TreeNode> s = new Stack(), path = new Stack();\\n        s.push(root);\\n        while(!s.empty()){\\n            root = s.pop();\\n            if(!path.empty() && path.peek()==root){                \\n                path.pop();\\n\\t\\t    out.add(root.val);\\n            }\\n            else{                \\n                path.push(root);\\n                if(root.right != null)\\n                    s.push(root.right);\\n\\t\\t    s.push(root);\\n                if(root.left != null)\\n                    s.push(root.left);\\n            }\\n        }\\n\\t    return out;\\n    }\\n\\t\\n```\\n\\n3) **Using No Stacks (Morris Traversal).** O(n) Time & O(1) Space\\nInstead of using stacks to remember our way back up the tree, we are going to modify the tree to create upwards links. The idea is based on [Threaded Binary Tree](https://en.wikipedia.org/wiki/Threaded_binary_tree). \\n\\t* Iterate till `root` is null.\\n\\t\\t* If `root` has a left child.\\n\\t\\t\\t* Find the `inorder predecessor`. (Inorder predecessor of root is the right most child of its left child)\\n\\t\\t\\t\\t* Make it point to root.\\n\\t\\t\\t\\t* `root` = `root.left`.\\n\\t\\t\\t* If its already pointing to root (which means we have traversed it already and are on our way up.)\\n\\t\\t\\t\\t* Make the `inorder predecessor` point to `null` (Reverting our structural changes)\\n\\t\\t\\t\\t* `root` = `root.right`.\\n\\t\\t* If left child is `null`\\n\\t\\t\\t* `root` = `root.right`. (We are climbing up our link.)\\n\\t\\t\\t\\n```\\n\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\t\\tif(root == null)\\n\\t\\t\\t\\treturn out;\\n\\t\\t\\tTreeNode pre = null;\\n\\t\\t\\twhile(root!=null){\\n\\t\\t\\t\\tif(root.left !=null){\\n\\t\\t\\t\\t\\tpre = root.left;\\n\\t\\t\\t\\t\\twhile(pre.right!=null && pre.right!=root)\\n\\t\\t\\t\\t\\t\\tpre=pre.right;\\n\\t\\t\\t\\t\\tif(pre.right==null){\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tpre.right=root;\\n\\t\\t\\t\\t\\t\\troot=root.left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t    out.add(root.val);\\n\\t\\t\\t\\t\\t\\tpre.right=null;\\n\\t\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t\\t}                   \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn out;\\n\\t\\t}\\n\\t\\t\\n```\\n\\nAlso checkout [PostOrder](https://discuss.leetcode.com/topic/64689/three-ways-of-iterative-postorder-traversing-easy-explanation)  & [PreOrder](https://discuss.leetcode.com/topic/64675/three-ways-of-iterative-preorder-traversing-easy-explanation)  :))",
                "solutionTags": [],
                "code": "```\\n \\npublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root==null)\\n\\t\\t\\treturn out;\\n\\t\\tStack<TreeNode> s = new Stack();      \\n\\t\\twhile(root!=null || !s.empty()){\\n\\t\\t\\tif(root!=null){\\t\\t\\t\\t\\n\\t\\t\\t\\ts.push(root);\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot = s.pop();\\n\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\n```\\n\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n        if(root == null)\\n            return out; \\n        Stack<TreeNode> s = new Stack(), path = new Stack();\\n        s.push(root);\\n        while(!s.empty()){\\n            root = s.pop();\\n            if(!path.empty() && path.peek()==root){                \\n                path.pop();\\n\\t\\t    out.add(root.val);\\n            }\\n            else{                \\n                path.push(root);\\n                if(root.right != null)\\n                    s.push(root.right);\\n\\t\\t    s.push(root);\\n                if(root.left != null)\\n                    s.push(root.left);\\n            }\\n        }\\n\\t    return out;\\n    }\\n\\t\\n```\n```\\n\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\t\\tif(root == null)\\n\\t\\t\\t\\treturn out;\\n\\t\\t\\tTreeNode pre = null;\\n\\t\\t\\twhile(root!=null){\\n\\t\\t\\t\\tif(root.left !=null){\\n\\t\\t\\t\\t\\tpre = root.left;\\n\\t\\t\\t\\t\\twhile(pre.right!=null && pre.right!=root)\\n\\t\\t\\t\\t\\t\\tpre=pre.right;\\n\\t\\t\\t\\t\\tif(pre.right==null){\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tpre.right=root;\\n\\t\\t\\t\\t\\t\\troot=root.left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t    out.add(root.val);\\n\\t\\t\\t\\t\\t\\tpre.right=null;\\n\\t\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t\\t}                   \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn out;\\n\\t\\t}\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 890237,
                "title": "go-solution",
                "content": "```go\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc inorderTraversal(root *TreeNode) []int {\\n    \\n    ans := []int{}\\n    \\n    var inorder func(*TreeNode) \\n    \\n    inorder = func(root *TreeNode) {\\n        if root == nil {return}\\n        \\n        inorder(root.Left)\\n        ans = append(ans, root.Val)\\n        inorder(root.Right)\\n        \\n    }\\n    inorder(root)\\n    \\n    return ans;   \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc inorderTraversal(root *TreeNode) []int {\\n    \\n    ans := []int{}\\n    \\n    var inorder func(*TreeNode) \\n    \\n    inorder = func(root *TreeNode) {\\n        if root == nil {return}\\n        \\n        inorder(root.Left)\\n        ans = append(ans, root.Val)\\n        inorder(root.Right)\\n        \\n    }\\n    inorder(root)\\n    \\n    return ans;   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31409,
                "title": "share-my-solution-in-c",
                "content": "///// iterative solution\\n\\n    int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    *returnSize = 0;\\n    \\n    struct TreeNode **stack = (struct TreeNode **)malloc(sizeof(struct TreeNode *));\\n    struct TreeNode *pop;\\n    int length = 0, state = 1;\\n    //stack[length++] = root;\\n    \\n    while (length>0 || root != NULL) {\\n        if (root) {\\n            stack = (struct TreeNode **)realloc(stack, sizeof(struct TreeNode *)*length+1);\\n            stack[length++] = root;\\n            root = root->left;\\n        }\\n        else {\\n            root = stack[--length];\\n            result = (int *)realloc(result, sizeof(int)*(*returnSize+1));\\n            result[*returnSize] = root->val;\\n            *returnSize += 1;\\n            root = root->right;\\n        }\\n    }\\n    \\n    return result;\\n}\\n\\n//// recursive solution\\n\\n    int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    if (!root)\\n        return result;\\n    \\n    int *leftarr=NULL, *rightarr=NULL, leftsize=0, rightsize=0;\\n    if (root->left)\\n        leftarr = inorderTraversal(root->left, &leftsize);\\n    if (root->right)\\n        rightarr = inorderTraversal(root->right, &rightsize);\\n    \\n    *returnSize = 1 + leftsize + rightsize;\\n    result = (int *)malloc(sizeof(int)*(*returnSize));\\n    \\n    int i, j;\\n    for (i=0; i<leftsize; i++)\\n        result[i] = leftarr[i];\\n    result[i++] = root->val;\\n    for (j=0; j<rightsize; j++)\\n        result[i+j] = rightarr[j];\\n    free(leftarr); free(rightarr);\\n    \\n    return result;\\n}",
                "solutionTags": [],
                "code": "///// iterative solution\\n\\n    int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    *returnSize = 0;\\n    \\n    struct TreeNode **stack = (struct TreeNode **)malloc(sizeof(struct TreeNode *));\\n    struct TreeNode *pop;\\n    int length = 0, state = 1;\\n    //stack[length++] = root;\\n    \\n    while (length>0 || root != NULL) {\\n        if (root) {\\n            stack = (struct TreeNode **)realloc(stack, sizeof(struct TreeNode *)*length+1);\\n            stack[length++] = root;\\n            root = root->left;\\n        }\\n        else {\\n            root = stack[--length];\\n            result = (int *)realloc(result, sizeof(int)*(*returnSize+1));\\n            result[*returnSize] = root->val;\\n            *returnSize += 1;\\n            root = root->right;\\n        }\\n    }\\n    \\n    return result;\\n}\\n\\n//// recursive solution\\n\\n    int* inorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    if (!root)\\n        return result;\\n    \\n    int *leftarr=NULL, *rightarr=NULL, leftsize=0, rightsize=0;\\n    if (root->left)\\n        leftarr = inorderTraversal(root->left, &leftsize);\\n    if (root->right)\\n        rightarr = inorderTraversal(root->right, &rightsize);\\n    \\n    *returnSize = 1 + leftsize + rightsize;\\n    result = (int *)malloc(sizeof(int)*(*returnSize));\\n    \\n    int i, j;\\n    for (i=0; i<leftsize; i++)\\n        result[i] = leftarr[i];\\n    result[i++] = root->val;\\n    for (j=0; j<rightsize; j++)\\n        result[i+j] = rightarr[j];\\n    free(leftarr); free(rightarr);\\n    \\n    return result;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 160386,
                "title": "python-solution",
                "content": "Recursive:\\n```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```\\nIterative:\\n```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        trav = root\\n        res = []\\n        stack = []\\n        while stack or trav:\\n            while trav:\\n                stack.append(trav)\\n                trav = trav.left\\n            u = stack.pop()\\n            res.append(u.val)\\n            trav = u.right\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```\n```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        trav = root\\n        res = []\\n        stack = []\\n        while stack or trav:\\n            while trav:\\n                stack.append(trav)\\n                trav = trav.left\\n            u = stack.pop()\\n            res.append(u.val)\\n            trav = u.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107203,
                "title": "java-recursive-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS in order traversal\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    private List<Integer> res = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        traverse(root.left);\\n        res.add(root.val);\\n        traverse(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    private List<Integer> res = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        traverse(root.left);\\n        res.add(root.val);\\n        traverse(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547003,
                "title": "easy-python-3-line-solution",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418125,
                "title": "simple-python-solution-recursive",
                "content": "```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        else:\\n            return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        else:\\n            return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307460,
                "title": "c-simple-solution",
                "content": "```\\nvoid travel(struct TreeNode* root,int *ret,int *size)\\n{\\n    if(root==NULL)return;\\n    travel(root->left,ret,size);\\n    ret[(*size)++]=root->val;\\n    travel(root->right,ret,size);\\n}\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *ret=malloc(sizeof(int)*100);\\n    travel(root,ret,returnSize);\\n    return ret;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvoid travel(struct TreeNode* root,int *ret,int *size)\\n{\\n    if(root==NULL)return;\\n    travel(root->left,ret,size);\\n    ret[(*size)++]=root->val;\\n    travel(root->right,ret,size);\\n}\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *ret=malloc(sizeof(int)*100);\\n    travel(root,ret,returnSize);\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31375,
                "title": "java-two-solutions-recursive-1-ms-and-non-recursive-2-ms",
                "content": "Recursive:`\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list =new ArrayList();\\n        addNode(list,root);\\n        return list;\\n    }\\n    public void addNode(List<Integer> list,TreeNode root){\\n        if(root==null) return;\\n        addNode(list,root.left);\\n        list.add(root.val);\\n        addNode(list,root.right); \\n    }\\n\\nNon-recursive :`\\n\\n        List<Integer> list =new ArrayList();\\n        Stack<TreeNode> stack=new Stack();\\n        if(root==null) return list;\\n        while(root!=null){\\n            stack.push(root);\\n            root=root.left;\\n            while(root==null){\\n                if(stack.empty()) return list;\\n                root=stack.pop();\\n                list.add(root.val);\\n                root=root.right;\\n            }\\n        }\\n        return list;\\n `",
                "solutionTags": [],
                "code": "Recursive:`\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list =new ArrayList();\\n        addNode(list,root);\\n        return list;\\n    }\\n    public void addNode(List<Integer> list,TreeNode root){\\n        if(root==null) return;\\n        addNode(list,root.left);\\n        list.add(root.val);\\n        addNode(list,root.right); \\n    }\\n\\nNon-recursive :`\\n\\n        List<Integer> list =new ArrayList();\\n        Stack<TreeNode> stack=new Stack();\\n        if(root==null) return list;\\n        while(root!=null){\\n            stack.push(root);\\n            root=root.left;\\n            while(root==null){\\n                if(stack.empty()) return list;\\n                root=stack.pop();\\n                list.add(root.val);\\n                root=root.right;\\n            }\\n        }\\n        return list;\\n `",
                "codeTag": "Unknown"
            },
            {
                "id": 31464,
                "title": "4ms-iterative-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            stack<TreeNode*> s;\\n            pushAllLeft(s, root);\\n            vector<int> result;\\n            while(!s.empty()) {\\n                TreeNode* p = s.top();\\n                s.pop();\\n                result.push_back(p->val);\\n                pushAllLeft(s,p->right);\\n            }\\n            return result;\\n        }\\n        \\n        void pushAllLeft(stack<TreeNode*>& s, TreeNode* root) {\\n            while(root) {\\n                s.push(root);\\n                root = root->left;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode *root) {\\n            stack<TreeNode*> s;\\n            pushAllLeft(s, root);\\n            vector<int> result;\\n            while(!s.empty()) {\\n                TreeNode* p = s.top();\\n                s.pop();\\n                result.push_back(p->val);\\n                pushAllLeft(s,p->right);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3673822,
                "title": "simplest-3-line-sol-with-explaination",
                "content": "# Intuition\\nThis code performs a inorder traversal on a binary tree and returns a list of integers containing the values of the nodes visited in the traversal.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create an instance variable `ans` of type `List<Integer>` to store the values of the nodes in the inorder traversal.\\n2. Define the `inorderTraversal` function that takes a `TreeNode` called `root` as input and returns a list of integers.\\n3. Check if the `root` is null. If it is, return the `ans` list.\\n4. Recursively call the `inorderTraversal` function on the left child of the current `root` node.\\n5. Add the value of the current `root` node to the `ans` list using the `add` method.\\n6. Recursively call the `inorderTraversal` function on the right child of the current `root` node.\\n7. Finally, return the `ans` list containing the values of the nodes visited in the inorder traversal.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    List<Integer> ans = new ArrayList<>();\\n\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n   if (root == null) return ans;\\n   inorderTraversal(root.left);\\n   ans.add(root.val);\\n   inorderTraversal(root.right);\\n   return ans;\\n}\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/34562f78-5f5b-4e2e-a154-2df98ad56ee8_1687528905.3259234.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    List<Integer> ans = new ArrayList<>();\\n\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n   if (root == null) return ans;\\n   inorderTraversal(root.left);\\n   ans.add(root.val);\\n   inorderTraversal(root.right);\\n   return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926144,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the tree.\\n    //   - space: O(n), where n is the number of nodes in the tree.\\n    \\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var ans = [Int]()\\n        var stack = [TreeNode?]()\\n        var curr = root\\n\\n        while curr != nil || !stack.isEmpty {\\n            while curr != nil {\\n                stack.append(curr)\\n                curr = curr?.left\\n            }\\n            curr = stack.removeLast()\\n            if let val = curr?.val {\\n                ans.append(val)\\n            }\\n            curr = curr?.right\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the tree.\\n    //   - space: O(n), where n is the number of nodes in the tree.\\n    \\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var ans = [Int]()\\n        var stack = [TreeNode?]()\\n        var curr = root\\n\\n        while curr != nil || !stack.isEmpty {\\n            while curr != nil {\\n                stack.append(curr)\\n                curr = curr?.left\\n            }\\n            curr = stack.removeLast()\\n            if let val = curr?.val {\\n                ans.append(val)\\n            }\\n            curr = curr?.right\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533303,
                "title": "iterative-inorder-traversal-with-full-explanation",
                "content": "**Inorder tree traversal** is a type of *depth first search* (DFS) where we explore tree nodes in a particular order: left, root, right. \\n\\nTypically DFS is done recursively but I could also implement it with a *stack* (an abstract data type). To solve this problem, I\\'m going to implement a stack with a Python `list`.\\n\\nA more thorough explanation can be found on my [GitHub](https://github.com/sanoke/leetcode/blob/master/tree%20traversal/0094-binary-tree-inorder-traversal.ipynb), where I also do an inorder traversal of an example tree to demonstrate some intuition behind the process.\\n\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode):\\n        # initialize the stack\\n        stack = []\\n        # initialize the traveral list\\n        traversal = []\\n        \\n        # while we\\'re at a valid node or there are\\n        # still nodes to traverse... \\n        while stack or root:\\n            \\n            if root:\\n                # if we\\'re at a valid node,\\n                # remember where we\\'ve been and keep moving left\\n                stack.append(root)\\n                root = root.left\\n            \\n            else:\\n                # otherwise we\\'ve hit a dead end so\\n                # -- pop the most recent value\\n                # -- report out\\n                # -- move right\\n                root = stack.pop()\\n                traversal.append(root.val)\\n                root = root.right\\n        \\n        return traversal\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode):\\n        # initialize the stack\\n        stack = []\\n        # initialize the traveral list\\n        traversal = []\\n        \\n        # while we\\'re at a valid node or there are\\n        # still nodes to traverse... \\n        while stack or root:\\n            \\n            if root:\\n                # if we\\'re at a valid node,\\n                # remember where we\\'ve been and keep moving left\\n                stack.append(root)\\n                root = root.left\\n            \\n            else:\\n                # otherwise we\\'ve hit a dead end so\\n                # -- pop the most recent value\\n                # -- report out\\n                # -- move right\\n                root = stack.pop()\\n                traversal.append(root.val)\\n                root = root.right\\n        \\n        return traversal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527791,
                "title": "javascript-10-lines-iterative-and-recursive",
                "content": "### Iterative In-order Traverse\\n- Time Complexity: O(N)\\n- Space Complexity: O(H)\\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    let curr = root,  res = [], stack = [];\\n    while (curr || stack.length) {\\n        while (curr) {\\n            stack.push(curr);\\n            curr = curr.left;\\n        }\\n        curr = stack.pop();\\n        res.push(curr.val);\\n        curr = curr.right;\\n    }\\n    return res;\\n};\\n```\\n### Recursive In-order Traverse\\n\\n- Time Complexity: O(N)\\n- Space Complexity: O(H)\\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    const res = [];\\n    traverse(root);\\n    return res;\\n    \\n    function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        res.push(node.val);\\n        traverse(node.right);\\n    }\\n};\\n```\\n\\n- Time Complexity:\\n    - `an spread syntax takes linear time and it takes T(n/2) in this implementation`\\n    - average: O(N log N)\\n    - worst: O(N^2) `unbalanced tree`\\n- Space Complexity: O(H)\\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    if (!root) return [];\\n    const res = [];\\n    res.push(...inorderTraversal(root.left));\\n    res.push(root.val);\\n    res.push(...inorderTraversal(root.right));\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    let curr = root,  res = [], stack = [];\\n    while (curr || stack.length) {\\n        while (curr) {\\n            stack.push(curr);\\n            curr = curr.left;\\n        }\\n        curr = stack.pop();\\n        res.push(curr.val);\\n        curr = curr.right;\\n    }\\n    return res;\\n};\\n```\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    const res = [];\\n    traverse(root);\\n    return res;\\n    \\n    function traverse(node) {\\n        if (!node) return;\\n        traverse(node.left);\\n        res.push(node.val);\\n        traverse(node.right);\\n    }\\n};\\n```\n```JavaScript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst inorderTraversal = (root) => {\\n    if (!root) return [];\\n    const res = [];\\n    res.push(...inorderTraversal(root.left));\\n    res.push(root.val);\\n    res.push(...inorderTraversal(root.right));\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31364,
                "title": "java-recursive-and-iterative-solutions",
                "content": "        \\n    // recursively\\n    public List<Integer> inorderTraversal1(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        dfs(root, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode node, List<Integer> ret) {\\n        if (node != null) {\\n            dfs(node.left, ret);\\n            ret.add(node.val);\\n            dfs(node.right, ret);\\n        }\\n    }\\n    \\n    // iteratively\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n       Stack<TreeNode> stack = new Stack<>();\\n       List<Integer> ret = new ArrayList<>();\\n       while (true) {\\n           while (root != null) {\\n               stack.push(root);\\n               root = root.left;\\n           }\\n           if (stack.isEmpty()) {\\n               break;  // no node left\\n           }\\n           TreeNode node = stack.pop();\\n           ret.add(node.val);\\n           root = node.right;\\n       }\\n       return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // recursively\\n    public List<Integer> inorderTraversal1(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        dfs(root, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode node, List<Integer> ret) {\\n        if (node != null) {\\n            dfs(node.left, ret);\\n            ret.add(node.val);\\n            dfs(node.right, ret);\\n        }\\n    }\\n    \\n    // iteratively\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n       Stack<TreeNode> stack = new Stack<>();\\n       List<Integer> ret = new ArrayList<>();\\n       while (true) {\\n           while (root != null) {\\n               stack.push(root);\\n               root = root.left;\\n           }\\n           if (stack.isEmpty()) {\\n               break;  // no node left\\n           }\\n           TreeNode node = stack.pop();\\n           ret.add(node.val);\\n           root = node.right;\\n       }\\n       return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2967362,
                "title": "javascript-recursive-and-iterative-explained",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    let result = [];\\n\\n    /*\\n    RECURSIVE SOLUTION\\n\\n    function inorder(root) {\\n        // if node null, return back to the prenode (works like that with recursive functions)\\n        if (!root) {\\n            return;\\n        }\\n\\n        inorder(root.left);    // recursive call for left nodes\\n        result.push(root.val); // push to result   \\n        inorder(root.right);   // when its done with left, start right\\n\\n    }\\n    // call recursive function\\n    inorder(root);\\n    return result;\\n    */\\n\\n\\n    // ITERATIVE SOLUTION \\n\\n    // The call stack, which we can return to the parent node and decide if there is something to do left\\n    let stack = [];\\n    // The pointer on the current node\\n    let currentNode = root;\\n\\n    while (currentNode || stack.length) {\\n        // this loop is going down the left nodes and exits if there is no left node anymore. Also adds all nodes to Stack\\n        if(currentNode) {\\n            stack.push(currentNode);\\n            currentNode = currentNode.left;\\n        } else {\\n// finishing the above loop, it means we are at the deepest left node we could get and all ar added, so now we need to point the currentNode to the parentNode. We do this by popping the last item in our callstack, which was the parentNode. pop returns the last item, currentNode is now the last Item (Parent)\\n        currentNode = stack.pop()\\n// We add currentNode to the result, because inorder traversal is \"\"left-root-right\"-order\", so we always add the most left node which is left (and has no left children)\\n        result.push(currentNode.val);\\n// then we point the pointer to the right node (even if its null)\\n        currentNode = currentNode.right;\\n        \\n// After we were at the deepest left, a new outer while loop is started, where is checked if currentNode exists, if yes, add to stack, move left. if not, set currentNode/pointer to parent, push it to result and set to right child node.\\n        }\\n            \\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    let result = [];\\n\\n    /*\\n    RECURSIVE SOLUTION\\n\\n    function inorder(root) {\\n        // if node null, return back to the prenode (works like that with recursive functions)\\n        if (!root) {\\n            return;\\n        }\\n\\n        inorder(root.left);    // recursive call for left nodes\\n        result.push(root.val); // push to result   \\n        inorder(root.right);   // when its done with left, start right\\n\\n    }\\n    // call recursive function\\n    inorder(root);\\n    return result;\\n    */\\n\\n\\n    // ITERATIVE SOLUTION \\n\\n    // The call stack, which we can return to the parent node and decide if there is something to do left\\n    let stack = [];\\n    // The pointer on the current node\\n    let currentNode = root;\\n\\n    while (currentNode || stack.length) {\\n        // this loop is going down the left nodes and exits if there is no left node anymore. Also adds all nodes to Stack\\n        if(currentNode) {\\n            stack.push(currentNode);\\n            currentNode = currentNode.left;\\n        } else {\\n// finishing the above loop, it means we are at the deepest left node we could get and all ar added, so now we need to point the currentNode to the parentNode. We do this by popping the last item in our callstack, which was the parentNode. pop returns the last item, currentNode is now the last Item (Parent)\\n        currentNode = stack.pop()\\n// We add currentNode to the result, because inorder traversal is \"\"left-root-right\"-order\", so we always add the most left node which is left (and has no left children)\\n        result.push(currentNode.val);\\n// then we point the pointer to the right node (even if its null)\\n        currentNode = currentNode.right;\\n        \\n// After we were at the deepest left, a new outer while loop is started, where is checked if currentNode exists, if yes, add to stack, move left. if not, set currentNode/pointer to parent, push it to result and set to right child node.\\n        }\\n            \\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555429,
                "title": "binary-tree-inorder-traversal",
                "content": "1. ITERATIVE APPROACH\\nIn iterative approach, the stack data structure is used. We need to store the current or parent node so that after processing the left subtree we can process the node so we push the node in the stack data structure. After processing the node, we pop that respective node.\\n\\n```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        stack<TreeNode*>st;\\n        while(1){\\n            if(root!=NULL){\\n                st.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                if(st.empty()==true) break;\\n                root=st.top();\\n                st.pop();\\n                ans.push_back(root->val);\\n                root=root->right;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\t\\n2. RECURSIVE APPROACH\\nThe first call recursively left child node until getting NULL value then get node value and then call recursively right child node until getting NULL. So now print the value of all nodes inorder traversing.\\n\\n```\\n\\tclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        inorder(root -> left, nodes);\\n        nodes.push_back(root -> val);\\n        inorder(root -> right, nodes);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        stack<TreeNode*>st;\\n        while(1){\\n            if(root!=NULL){\\n                st.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                if(st.empty()==true) break;\\n                root=st.top();\\n                st.pop();\\n                ans.push_back(root->val);\\n                root=root->right;\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\n\\tclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        inorder(root -> left, nodes);\\n        nodes.push_back(root -> val);\\n        inorder(root -> right, nodes);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547292,
                "title": "c-recursive-morris-traversal-approach",
                "content": "**Please upvote if you like the post :)**\\n\\n**Intuition:**\\nSeeing tree problems, first thing that hit\\'s your brain is? what is it? Yessss its **Recursion.**\\n\\n**Approach: (DFS Traversal)**\\n* **Inorder** Traversal follows - **Left Root Right**\\n* If `root==NULL` we can simply return `{}`;\\n* we declare a vector **vec** and simply push all the `root->val` after every **left** traversal and after that **right** traversal happens.\\n \\n**Visualization: (DFS)**\\n![image](https://assets.leetcode.com/users/images/910dc845-947f-4f49-806c-dec5f90fd9f4_1662608198.1349866.gif)\\n\\n\\n\\n\\n\\n**C++:(DFS Traversal)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> vec; \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        inorderTraversal(root->left);\\n        vec.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(N)**, where N is the number of nodes in the Binary Tree.\\n**Space Complexity:** **O(N)**, where N is the number of node in the Binary Tree (Recursion stack space)\\n****\\n**Approach 2: (Optimized - Morris Traversal)**\\n* So the idea is that at a `node` whether we have to move `left` or `right` is determined whether the node has a **left** subtree. \\n* If it doesn\\u2019t we move to the **right**. \\n* If there is a `left` subtree then we see its `rightmost` child. If the `rightmost` child is pointing to `NULL`, we move the **current** node to its **left**. \\n* If the **rightmost** child is already pointing towards the **current** node, we remove that link and move to the **right** of the **current** node. \\n* We will **stop** the execution when the **current** points to `null` and we have traversed the whole tree.\\n \\n**Visualization: (Optimized - Morris Traversal)**\\n![image](https://assets.leetcode.com/users/images/27affd71-dfea-4a3f-9755-d5648c86ccf5_1662608543.0316582.png)\\n\\n\\n\\n**C++:(Optimized - Morris Traversal)** \\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> inOrder;\\n        TreeNode* cur = root;\\n        while(cur!=NULL){\\n            if(cur->left==NULL){\\n                inOrder.push_back(cur->val);\\n                cur=cur->right;\\n            }\\n            else{\\n                TreeNode* prev = cur->left;\\n                while(prev->right!=NULL && prev->right!=cur){\\n                    prev=prev->right;\\n                }\\n                if(prev->right==NULL){\\n                    prev->right=cur;\\n                    cur=cur->left;\\n                }\\n                else if(prev->right==cur){\\n                    prev->right=NULL;\\n                    inOrder.push_back(cur->val);\\n                    cur=cur->right;\\n                }\\n            }\\n        }\\n        return inOrder;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(N)**, where N is the number of nodes in the Binary Tree.\\n**Space Complexity:** **O(1)**, constant space\\n****",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vec; \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        inorderTraversal(root->left);\\n        vec.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> inOrder;\\n        TreeNode* cur = root;\\n        while(cur!=NULL){\\n            if(cur->left==NULL){\\n                inOrder.push_back(cur->val);\\n                cur=cur->right;\\n            }\\n            else{\\n                TreeNode* prev = cur->left;\\n                while(prev->right!=NULL && prev->right!=cur){\\n                    prev=prev->right;\\n                }\\n                if(prev->right==NULL){\\n                    prev->right=cur;\\n                    cur=cur->left;\\n                }\\n                else if(prev->right==cur){\\n                    prev->right=NULL;\\n                    inOrder.push_back(cur->val);\\n                    cur=cur->right;\\n                }\\n            }\\n        }\\n        return inOrder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385969,
                "title": "easiest-traversal-without-stack-queue-100-inorder",
                "content": "##  **Using This Solution We Can Make Inorder Traversal In Binary Tree Without Using Stack And Queue.**\\n\\n##### Global Declaration Of Ans Vector.\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return v;\\n        }\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return v;\\n    }\\n};\\n```\\n\\n\\n##### Pass By Reference Ans Vector.\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root, vector<int> &ans){\\n        if(root == NULL) return ;\\n        helper(root->left,ans);\\n        ans.push_back(root->val);\\n        helper(root->right,ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans; helper(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n**Like & UpVote If You Get My Intuition Also Comment If You Have Any Query..**\\n\\n",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return v;\\n        }\\n        inorderTraversal(root->left);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root, vector<int> &ans){\\n        if(root == NULL) return ;\\n        helper(root->left,ans);\\n        ans.push_back(root->val);\\n        helper(root->right,ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans; helper(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294202,
                "title": "golang-recursive-100-faster-0-ms",
                "content": "```\\nfunc inorderTraversal(root *TreeNode) []int {\\n    var nums = []int{}\\n    if root == nil {\\n        return nums\\n    }\\n    \\n    nums = append(nums, inorderTraversal(root.Left)...)\\n    nums = append(nums, root.Val)\\n    nums = append(nums, inorderTraversal(root.Right)...)\\n    return nums\\n}\\nPlease upvote if you like\\n```",
                "solutionTags": [
                    "Go",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nfunc inorderTraversal(root *TreeNode) []int {\\n    var nums = []int{}\\n    if root == nil {\\n        return nums\\n    }\\n    \\n    nums = append(nums, inorderTraversal(root.Left)...)\\n    nums = append(nums, root.Val)\\n    nums = append(nums, inorderTraversal(root.Right)...)\\n    return nums\\n}\\nPlease upvote if you like\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1251231,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        inorderTraversal(root->left);\\n        ans.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root==NULL)\\n            return {};\\n        inorderTraversal(root->left);\\n        ans.push_back(root->val);\\n        inorderTraversal(root->right);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668448,
                "title": "morris-traversal",
                "content": "I wanted to share an example of in-place Morris traversal. Didn\\'t see many Python examples out there. This example is based off Tushar\\'s morris traversal video: https://youtu.be/wGXB9OWhPTg and various sources I found: \\n\\nhttps://www.***.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\nhttps://leetcode.com/problems/binary-tree-inorder-traversal/discuss/148939/CPP-Morris-Traversal\\n\\n```python\\n\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res = []\\n\\n        while root:\\n            if not root.left: # if we don\\'t have a left, this is our best in-order value at the moment. add it to the list and move right.\\n                res.append(root.val)\\n                root = root.right\\n            else:\\n                pred = self.findPredecessor(root) # find the predecessor for the given node. This is the farthest right of the first left we see.\\n\\n\\t\\t\\t\\t# if we have a right we have move on to explore this sub tree. The pred.right != root check is to ensure that we\\'re not ex\\n                if pred.right != root:\\n                    pred.right = root\\n                    root = root.left\\n                else: \\n\\t\\t\\t\\t# otherwise, we have found a pointer back to the current root and we need to rewrite the tree structure. This is basically a form of \"have we seen this before?\".\\n                    root.left = None\\n\\n        return res\\n\\n    def findPredecessor(self, root: TreeNode) -> TreeNode:\\n        curr = root.left\\n\\n        while curr.right and curr.right != root:\\n            curr = curr.right\\n\\n        return curr\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        res = []\\n\\n        while root:\\n            if not root.left: # if we don\\'t have a left, this is our best in-order value at the moment. add it to the list and move right.\\n                res.append(root.val)\\n                root = root.right\\n            else:\\n                pred = self.findPredecessor(root) # find the predecessor for the given node. This is the farthest right of the first left we see.\\n\\n\\t\\t\\t\\t# if we have a right we have move on to explore this sub tree. The pred.right != root check is to ensure that we\\'re not ex\\n                if pred.right != root:\\n                    pred.right = root\\n                    root = root.left\\n                else: \\n\\t\\t\\t\\t# otherwise, we have found a pointer back to the current root and we need to rewrite the tree structure. This is basically a form of \"have we seen this before?\".\\n                    root.left = None\\n\\n        return res\\n\\n    def findPredecessor(self, root: TreeNode) -> TreeNode:\\n        curr = root.left\\n\\n        while curr.right and curr.right != root:\\n            curr = curr.right\\n\\n        return curr\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31261,
                "title": "c-solution",
                "content": "```\\n    public IList<int> InorderTraversal(TreeNode root) {\\n        List<int> result = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode currentNode = root;\\n\\n        while (currentNode != null || stack.Count != 0)\\n        {\\n            while (currentNode != null)\\n            {\\n                stack.Push(currentNode);\\n                currentNode = currentNode.left;\\n            }\\n            \\n            if (stack.Count != 0)\\n            {\\n                currentNode = stack.Pop();\\n                result.Add(currentNode.val);\\n                currentNode = currentNode.right;\\n            }\\n        }\\n            \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public IList<int> InorderTraversal(TreeNode root) {\\n        List<int> result = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode currentNode = root;\\n\\n        while (currentNode != null || stack.Count != 0)\\n        {\\n            while (currentNode != null)\\n            {\\n                stack.Push(currentNode);\\n                currentNode = currentNode.left;\\n            }\\n            \\n            if (stack.Count != 0)\\n            {\\n                currentNode = stack.Pop();\\n                result.Add(currentNode.val);\\n                currentNode = currentNode.right;\\n            }\\n        }\\n            \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31422,
                "title": "java-simple-and-clean",
                "content": "No1:\\n\\n     List<Integer> ans = new ArrayList<>();\\n    \\n    public List<Integer> inorderTraversal(TreeNode root) {\\n       if (root == null) return ans;\\n       inorderTraversal(root.left);\\n       ans.add(root.val);\\n       return inorderTraversal(root.right);\\n    }\\n\\n\\nNo2:\\n\\n       public List<Integer> inorderTraversal(TreeNode root) {\\n    \\tStack<TreeNode> stack = new Stack<>();\\n    \\tTreeNode cur = root;\\n    \\twhile (!stack.isEmpty() || cur != null) {\\n    \\t\\twhile (cur != null) {\\n        \\t\\tstack.push(cur);\\n        \\t\\tcur = cur.left;\\n        \\t}\\n    \\t\\tcur = stack.pop();\\n    \\t\\tans.add(cur.val);\\n    \\t\\tcur = cur.right;\\n     \\t}\\n    \\treturn ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "No1:\\n\\n     List<Integer> ans = new ArrayList<>();\\n    \\n    public List<Integer> inorderTraversal(TreeNode root) {\\n       if (root == null) return ans;\\n       inorderTraversal(root.left);\\n       ans.add(root.val);\\n       return inorderTraversal(root.right);\\n    }\\n\\n\\nNo2:\\n\\n       public List<Integer> inorderTraversal(TreeNode root) {\\n    \\tStack<TreeNode> stack = new Stack<>();\\n    \\tTreeNode cur = root;\\n    \\twhile (!stack.isEmpty() || cur != null) {\\n    \\t\\twhile (cur != null) {\\n        \\t\\tstack.push(cur);\\n        \\t\\tcur = cur.left;\\n        \\t}\\n    \\t\\tcur = stack.pop();\\n    \\t\\tans.add(cur.val);\\n    \\t\\tcur = cur.right;\\n     \\t}\\n    \\treturn ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31411,
                "title": "iterative-0ms-c-solution-with-o-1-space",
                "content": "    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n    \\tTreeNode *buf;\\n    \\twhile (root) {\\n    \\t\\tif (root->left) {\\n    \\t\\t\\tbuf = root->left;\\n    \\t\\t\\twhile (buf->right){\\n    \\t\\t\\t\\tbuf = buf->right;\\n    \\t\\t\\t}\\n    \\t\\t\\tbuf->right = root;\\n    \\t\\t\\tbuf = root->left;\\n    \\t\\t\\troot->left = NULL;\\n    \\t\\t\\troot = buf;\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\tans.push_back(root->val);\\n    \\t\\t\\troot = root->right;\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n    \\tTreeNode *buf;\\n    \\twhile (root) {\\n    \\t\\tif (root->left) {\\n    \\t\\t\\tbuf = root->left;\\n    \\t\\t\\twhile (buf->right){\\n    \\t\\t\\t\\tbuf = buf->right;\\n    \\t\\t\\t}\\n    \\t\\t\\tbuf->right = root;\\n    \\t\\t\\tbuf = root->left;\\n    \\t\\t\\troot->left = NULL;\\n    \\t\\t\\troot = buf;\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\tans.push_back(root->val);\\n    \\t\\t\\troot = root->right;\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3198212,
                "title": "c-recursive-iterative-all",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple three steps in Inorder Traversal :\\n- Left Traversal\\n- Push The ROOT \\n- Right Traversal\\n<--------**LPR**------->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Recusrive : Do left recursion then push  then Do right recursion\\n- Iterative : Use a stack (just like recursion stack is internally used ,same is here) .So just start from root and go left upto left !=null and keep pushing them in stack and then  store the topof stack  in answer vector and pop that  and then  for that top go for its right . (L->P->R strategy)\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Recusrive INorder**\\n```\\nvector<int>ans;\\n    void Inorder(TreeNode * root){\\n        if(!root)return;\\n        Inorder(root->left);\\n        ans.push_back(root->val);\\n        Inorder(root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        Inorder(root);\\n        return ans;\\n    }\\n```\\n**Iterative Inorder**\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        if(!root)return {};\\n         stack<TreeNode*>st;\\n         TreeNode* temp=root;\\n         while(!st.empty() or temp){\\n             while(temp){\\n                 st.push(temp);\\n                 temp=temp->left;\\n             }\\n             temp=st.top();\\n             ans.push_back(st.top()->val);\\n             st.pop();\\n             temp=temp->right;\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int>ans;\\n    void Inorder(TreeNode * root){\\n        if(!root)return;\\n        Inorder(root->left);\\n        ans.push_back(root->val);\\n        Inorder(root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        Inorder(root);\\n        return ans;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        if(!root)return {};\\n         stack<TreeNode*>st;\\n         TreeNode* temp=root;\\n         while(!st.empty() or temp){\\n             while(temp){\\n                 st.push(temp);\\n                 temp=temp->left;\\n             }\\n             temp=st.top();\\n             ans.push_back(st.top()->val);\\n             st.pop();\\n             temp=temp->right;\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547358,
                "title": "java-easy-solution-100-faster-code-minimum-lines-codes",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n    List<Integer> res = new ArrayList<Integer>();\\n    in(root,res);\\n    return res;\\n}\\n\\npublic void in(TreeNode root,List<Integer> res){\\n    if(root==null)\\n        return;\\n    in(root.left,res);\\n    res.add(root.val);\\n    in(root.right,res);\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n    List<Integer> res = new ArrayList<Integer>();\\n    in(root,res);\\n    return res;\\n}\\n\\npublic void in(TreeNode root,List<Integer> res){\\n    if(root==null)\\n        return;\\n    in(root.left,res);\\n    res.add(root.val);\\n    in(root.right,res);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414598,
                "title": "rust-solution",
                "content": "```Rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn inorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n        let mut res = vec![];\\n        \\n        fn traversal(node: Option<Rc<RefCell<TreeNode>>>, res: &mut Vec<i32>) {\\n            if let Some(n) = node {\\n                traversal(n.borrow().left.clone(), res);\\n                res.push(n.borrow().val);\\n                traversal(n.borrow().right.clone(), res);\\n            }\\n        }\\n        \\n        traversal(root, &mut res);\\n        \\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```Rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn inorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n        let mut res = vec![];\\n        \\n        fn traversal(node: Option<Rc<RefCell<TreeNode>>>, res: &mut Vec<i32>) {\\n            if let Some(n) = node {\\n                traversal(n.borrow().left.clone(), res);\\n                res.push(n.borrow().val);\\n                traversal(n.borrow().right.clone(), res);\\n            }\\n        }\\n        \\n        traversal(root, &mut res);\\n        \\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1329494,
                "title": "0-ms-swift-binary-tree-inorder-traversal-test-cases",
                "content": "```swift\\nclass Solution {\\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var result = [Int](), array = [TreeNode](), head = root\\n        while head != nil || !(array.isEmpty) {\\n            switch head {\\n            case .some(let node):\\n                array.append(node)\\n                head = node.left\\n            default:\\n                let prev = array.removeLast()\\n                result.append(prev.val)\\n                head = prev.right\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.046 (0.048) seconds\\n\\nclass Tests: XCTestCase {\\n    let s = Solution()\\n    func test0() {\\n        let res = s.inorderTraversal(.init([1,nil,2,3]))\\n        XCTAssertEqual(res, [1,3,2])\\n    }\\n    func test1() {\\n        let res = s.inorderTraversal(.init([]))\\n        XCTAssertEqual(res, [])\\n    }\\n    func test2() {\\n        let res = s.inorderTraversal(.init([1]))\\n        XCTAssertEqual(res, [1])\\n    }\\n    func test3() {\\n        let res = s.inorderTraversal(.init([1,2]))\\n        XCTAssertEqual(res, [2,1])\\n    }\\n    func test4() {\\n        let res = s.inorderTraversal(.init([1,nil,2]))\\n        XCTAssertEqual(res, [1,2])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        val = head; left = nil; right = nil\\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var result = [Int](), array = [TreeNode](), head = root\\n        while head != nil || !(array.isEmpty) {\\n            switch head {\\n            case .some(let node):\\n                array.append(node)\\n                head = node.left\\n            default:\\n                let prev = array.removeLast()\\n                result.append(prev.val)\\n                head = prev.right\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.046 (0.048) seconds\\n\\nclass Tests: XCTestCase {\\n    let s = Solution()\\n    func test0() {\\n        let res = s.inorderTraversal(.init([1,nil,2,3]))\\n        XCTAssertEqual(res, [1,3,2])\\n    }\\n    func test1() {\\n        let res = s.inorderTraversal(.init([]))\\n        XCTAssertEqual(res, [])\\n    }\\n    func test2() {\\n        let res = s.inorderTraversal(.init([1]))\\n        XCTAssertEqual(res, [1])\\n    }\\n    func test3() {\\n        let res = s.inorderTraversal(.init([1,2]))\\n        XCTAssertEqual(res, [2,1])\\n    }\\n    func test4() {\\n        let res = s.inorderTraversal(.init([1,nil,2]))\\n        XCTAssertEqual(res, [1,2])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        val = head; left = nil; right = nil\\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197245,
                "title": "python3-31ms-easy-explanation",
                "content": "# Approach\\n- first traverse till last node in left branch of every next node.\\n- now return when None node found\\n- append current element to inorder list\\n- at this point this means we traversed all left possible nodes.\\n- now go to right branch and do the same.\\n- return inord.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        inord = []\\n        def inorder(curr=root):\\n            nonlocal inord\\n            if curr:\\n                inorder(curr.left)\\n                inord.append(curr.val)\\n                inorder(curr.right)\\n            return\\n        inorder()\\n        return inord\\n```\\n# Please like and comment below.\\n# ( \\u0361\\u1D54\\u202F\\u035C\\u0296 \\u0361\\u1D54)\\u270C",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        inord = []\\n        def inorder(curr=root):\\n            nonlocal inord\\n            if curr:\\n                inorder(curr.left)\\n                inord.append(curr.val)\\n                inorder(curr.right)\\n            return\\n        inorder()\\n        return inord\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830795,
                "title": "c-easy-solution-100-fast",
                "content": "```\\nint i=0;\\nint arr[101]={0};\\nvoid inorder(struct TreeNode* s)\\n{\\n    if(s!=NULL)\\n    {\\n        inorder(s->left);\\n        arr[i++]=s->val;\\n        inorder(s->right);\\n    }\\n}\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    inorder(root);\\n    int* ans=malloc(i*sizeof(int));\\n    for(int j=0;j<i;j++) ans[j]=arr[j];\\n    *(returnSize)=i;\\n    i=0;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint i=0;\\nint arr[101]={0};\\nvoid inorder(struct TreeNode* s)\\n{\\n    if(s!=NULL)\\n    {\\n        inorder(s->left);\\n        arr[i++]=s->val;\\n        inorder(s->right);\\n    }\\n}\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    inorder(root);\\n    int* ans=malloc(i*sizeof(int));\\n    for(int j=0;j<i;j++) ans[j]=arr[j];\\n    *(returnSize)=i;\\n    i=0;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803478,
                "title": "python-simple-python-solution-using-recursion-faster-than-90-84",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 33 ms, faster than 90.84% of Python3 online submissions for Binary Tree Inorder Traversal.\\n# Memory Usage: 13.8 MB, less than 60.15% of Python3 online submissions for Binary Tree Inorder Traversal.\\n\\n\\tclass Solution:\\n\\t\\tdef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\n\\t\\t\\tself.result = []\\n\\n\\t\\t\\tdef InOrderTraversal(node):\\n\\n\\t\\t\\t\\tif node == None:\\n\\t\\t\\t\\t\\treturn None\\n\\n\\t\\t\\t\\tInOrderTraversal(node.left)\\n\\t\\t\\t\\tself.result.append(node.val)\\n\\t\\t\\t\\tInOrderTraversal(node.right)\\n\\n\\t\\t\\tInOrderTraversal(root)\\n\\n\\t\\t\\treturn self.result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 33 ms, faster than 90.84% of Python3 online submissions for Binary Tree Inorder Traversal.\\n# Memory Usage: 13.8 MB, less than 60.15% of Python3 online submissions for Binary Tree Inorder Traversal.\\n\\n\\tclass Solution:\\n\\t\\tdef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\n\\t\\t\\tself.result = []\\n\\n\\t\\t\\tdef InOrderTraversal(node):\\n\\n\\t\\t\\t\\tif node == None:\\n\\t\\t\\t\\t\\treturn None\\n\\n\\t\\t\\t\\tInOrderTraversal(node.left)\\n\\t\\t\\t\\tself.result.append(node.val)\\n\\t\\t\\t\\tInOrderTraversal(node.right)\\n\\n\\t\\t\\tInOrderTraversal(root)\\n\\n\\t\\t\\treturn self.result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 1743165,
                "title": "javascript-typescript-simple-2-line-recursive-solution-time-97-faster-memory-5-less",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction inorderTraversal(root: TreeNode | null): number[] {\\n    if (root === null) return [];\\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction inorderTraversal(root: TreeNode | null): number[] {\\n    if (root === null) return [];\\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486984,
                "title": "single-iterative-solution-for-preorder-inorder-and-postorder-traversals-in-one-go",
                "content": "```\\nclass Solution:\\n\\tdef inorderTraversal(self, root):\\n\\n\\t\\tpreo,ino,posto,stack=[],[],[],[[root,1]]\\n\\t\\tif not root:\\n\\t\\t\\treturn\\n\\t\\twhile stack:\\n\\t\\t\\tn=stack.pop()\\n\\n\\t\\t\\t#Preorder Traversal\\n\\t\\t\\tif n[1]==1:\\n\\t\\t\\t\\tpreo.append(n[0].val)\\n\\t\\t\\t\\tn[1]+=1\\n\\t\\t\\t\\tstack.append(n)\\n\\t\\t\\t\\tif n[0].left:\\n\\t\\t\\t\\t\\tstack.append([n[0].left,1])\\n\\n\\t\\t\\t#Inorder Traversal\\n\\t\\t\\telif n[1]==2:\\n\\t\\t\\t\\tino.append(n[0].val)\\n\\t\\t\\t\\tn[1]+=1\\n\\t\\t\\t\\tstack.append(n)\\n\\t\\t\\t\\tif n[0].right:\\n\\t\\t\\t\\t\\tstack.append([n[0].right,1])\\n\\n\\t\\t\\t#Postorder Traversal\\n\\t\\t\\telse:\\n\\t\\t\\t\\tposto.append(n[0].val)\\n\\t\\treturn ino",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef inorderTraversal(self, root):\\n\\n\\t\\tpreo,ino,posto,stack=[],[],[],[[root,1]]\\n\\t\\tif not root:\\n\\t\\t\\treturn\\n\\t\\twhile stack:\\n\\t\\t\\tn=stack.pop()\\n\\n\\t\\t\\t#Preorder Traversal\\n\\t\\t\\tif n[1]==1:\\n\\t\\t\\t\\tpreo.append(n[0].val)\\n\\t\\t\\t\\tn[1]+=1\\n\\t\\t\\t\\tstack.append(n)\\n\\t\\t\\t\\tif n[0].left:\\n\\t\\t\\t\\t\\tstack.append([n[0].left,1])\\n\\n\\t\\t\\t#Inorder Traversal\\n\\t\\t\\telif n[1]==2:\\n\\t\\t\\t\\tino.append(n[0].val)\\n\\t\\t\\t\\tn[1]+=1\\n\\t\\t\\t\\tstack.append(n)\\n\\t\\t\\t\\tif n[0].right:\\n\\t\\t\\t\\t\\tstack.append([n[0].right,1])\\n\\n\\t\\t\\t#Postorder Traversal\\n\\t\\t\\telse:\\n\\t\\t\\t\\tposto.append(n[0].val)\\n\\t\\treturn ino",
                "codeTag": "Java"
            },
            {
                "id": 286620,
                "title": "java-morris-traversal-with-detailed-explanation",
                "content": "```\\nclass Solution {\\n\\t/**\\n\\t * Morris inorder traversal\\n\\t * \\n\\t * @param root\\n\\t * @return\\n\\t * @see <a href=\\n\\t *      \"https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\">Inorder\\n\\t *      Tree Traversal without recursion and without stack</a>\\n\\t * @see <a href=\"https://en.wikipedia.org/wiki/Threaded_binary_tree\">Threaded\\n\\t *      binary tree</a>\\n\\t */\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> r = new ArrayList<>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn r;\\n\\n\\t\\t// Start from root\\n\\t\\tTreeNode cur = root;\\n\\n\\t\\t// Define a cursor that will be used to find predecessor, link and unlink nodes\\n\\t\\tTreeNode traverseCursor = null;\\n\\t\\twhile (cur != null) {\\n\\t\\t\\t/*\\n\\t\\t\\t * Check current node\\'s left child, if the left child node exist, then traverse\\n\\t\\t\\t * through left child\\'s right branch to the bottom, the rightmost leaf node will\\n\\t\\t\\t * be the predecessor of current node, once we find it, we \\'link\\' the\\n\\t\\t\\t * predecessor to current node, i.e., we make current node the right child of\\n\\t\\t\\t * the predecessor\\n\\t\\t\\t */\\n\\t\\t\\tif (cur.left != null) {\\n\\t\\t\\t\\ttraverseCursor = cur.left;\\n\\t\\t\\t\\twhile (traverseCursor.right != null && traverseCursor.right != cur) {\\n\\t\\t\\t\\t\\ttraverseCursor = traverseCursor.right;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (traverseCursor.right == null) {\\n\\t\\t\\t\\t\\t// We found the leaf node, now create the link\\n\\t\\t\\t\\t\\ttraverseCursor.right = cur;\\n\\t\\t\\t\\t\\t// Now move the cursor of current node to its left child\\n\\t\\t\\t\\t\\tcur = cur.left;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (traverseCursor.right == cur) {\\n\\t\\t\\t\\t\\t// This case is indicating we have already visited current node\\'s predecessor by\\n\\t\\t\\t\\t\\t// linking, we need to unlink the nodes to restore the original tree\\n\\t\\t\\t\\t\\ttraverseCursor.right = null;\\n\\t\\t\\t\\t\\t// This case is also indicating we are visiting the successor of the predecessor\\n\\t\\t\\t\\t\\t// i.e., the root\\n\\t\\t\\t\\t\\tr.add(cur.val);\\n\\t\\t\\t\\t\\t// Now visit the right branch\\n\\t\\t\\t\\t\\tcur = cur.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// We reached the node we want to visit\\n\\t\\t\\t\\tr.add(cur.val);\\n\\t\\t\\t\\t// Now we move the cursor to its \\'right\\' child, which was linked to its\\n\\t\\t\\t\\t// successor\\n\\t\\t\\t\\t// by traverseCursor\\n\\t\\t\\t\\tcur = cur.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t/**\\n\\t * Morris inorder traversal\\n\\t * \\n\\t * @param root\\n\\t * @return\\n\\t * @see <a href=\\n\\t *      \"https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\">Inorder\\n\\t *      Tree Traversal without recursion and without stack</a>\\n\\t * @see <a href=\"https://en.wikipedia.org/wiki/Threaded_binary_tree\">Threaded\\n\\t *      binary tree</a>\\n\\t */\\n\\tpublic List<Integer> inorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> r = new ArrayList<>();\\n\\t\\tif (root == null)\\n\\t\\t\\treturn r;\\n\\n\\t\\t// Start from root\\n\\t\\tTreeNode cur = root;\\n\\n\\t\\t// Define a cursor that will be used to find predecessor, link and unlink nodes\\n\\t\\tTreeNode traverseCursor = null;\\n\\t\\twhile (cur != null) {\\n\\t\\t\\t/*\\n\\t\\t\\t * Check current node\\'s left child, if the left child node exist, then traverse\\n\\t\\t\\t * through left child\\'s right branch to the bottom, the rightmost leaf node will\\n\\t\\t\\t * be the predecessor of current node, once we find it, we \\'link\\' the\\n\\t\\t\\t * predecessor to current node, i.e., we make current node the right child of\\n\\t\\t\\t * the predecessor\\n\\t\\t\\t */\\n\\t\\t\\tif (cur.left != null) {\\n\\t\\t\\t\\ttraverseCursor = cur.left;\\n\\t\\t\\t\\twhile (traverseCursor.right != null && traverseCursor.right != cur) {\\n\\t\\t\\t\\t\\ttraverseCursor = traverseCursor.right;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (traverseCursor.right == null) {\\n\\t\\t\\t\\t\\t// We found the leaf node, now create the link\\n\\t\\t\\t\\t\\ttraverseCursor.right = cur;\\n\\t\\t\\t\\t\\t// Now move the cursor of current node to its left child\\n\\t\\t\\t\\t\\tcur = cur.left;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (traverseCursor.right == cur) {\\n\\t\\t\\t\\t\\t// This case is indicating we have already visited current node\\'s predecessor by\\n\\t\\t\\t\\t\\t// linking, we need to unlink the nodes to restore the original tree\\n\\t\\t\\t\\t\\ttraverseCursor.right = null;\\n\\t\\t\\t\\t\\t// This case is also indicating we are visiting the successor of the predecessor\\n\\t\\t\\t\\t\\t// i.e., the root\\n\\t\\t\\t\\t\\tr.add(cur.val);\\n\\t\\t\\t\\t\\t// Now visit the right branch\\n\\t\\t\\t\\t\\tcur = cur.right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// We reached the node we want to visit\\n\\t\\t\\t\\tr.add(cur.val);\\n\\t\\t\\t\\t// Now we move the cursor to its \\'right\\' child, which was linked to its\\n\\t\\t\\t\\t// successor\\n\\t\\t\\t\\t// by traverseCursor\\n\\t\\t\\t\\tcur = cur.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548362,
                "title": "python-recursive-and-iterative-solutions",
                "content": "# Recursive Solution\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        A = []\\n        def inorder(node):\\n            if not node: return\\n            inorder(node.left)\\n            A.append(node.val)\\n            inorder(node.right)\\n        inorder(root)\\n        return A\\n```\\n\\n# Iterative solution\\nSame idea, exhaust left sub trees, then pop the current, add to the answer and repeat the logic for right subtree (in order)\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        A = []\\n        stack = []\\n        cur_node = root\\n        \\n        while stack or cur_node:\\n            \\n            # Exhausted left nodes. Pop current and go right\\n            if not cur_node:\\n                node = stack.pop()\\n                A.append(node.val)\\n                cur_node = node.right\\n            \\n            # Otherwise go left\\n            else:\\n                stack.append(cur_node)\\n                cur_node = cur_node.left\\n        \\n        return A\\n```\\n\\n# Generator function\\nNote that you can turn the iterative solution into a generator function by yielding the result.\\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        stack = []\\n        cur_node = root\\n        \\n        while stack or cur_node:\\n            # Exhausted left nodes. Pop current and go right\\n            if not cur_node:\\n                node = stack.pop()\\n                yield node.val\\n                cur_node = node.right\\n            \\n            # Otherwise go left\\n            else:\\n                stack.append(cur_node)\\n                cur_node = cur_node.left\\n```\\n\\n# Appendix\\nOne could solve the problem in constant space O(1) using morris traversal.\\nRefer to this link for more info: https://stackoverflow.com/questions/5502916/explain-morris-inorder-tree-traversal-without-using-stacks-or-recursion",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        A = []\\n        def inorder(node):\\n            if not node: return\\n            inorder(node.left)\\n            A.append(node.val)\\n            inorder(node.right)\\n        inorder(root)\\n        return A\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        A = []\\n        stack = []\\n        cur_node = root\\n        \\n        while stack or cur_node:\\n            \\n            # Exhausted left nodes. Pop current and go right\\n            if not cur_node:\\n                node = stack.pop()\\n                A.append(node.val)\\n                cur_node = node.right\\n            \\n            # Otherwise go left\\n            else:\\n                stack.append(cur_node)\\n                cur_node = cur_node.left\\n        \\n        return A\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        stack = []\\n        cur_node = root\\n        \\n        while stack or cur_node:\\n            # Exhausted left nodes. Pop current and go right\\n            if not cur_node:\\n                node = stack.pop()\\n                yield node.val\\n                cur_node = node.right\\n            \\n            # Otherwise go left\\n            else:\\n                stack.append(cur_node)\\n                cur_node = cur_node.left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547698,
                "title": "2-ways-of-0ms-java-solution",
                "content": "**Recursion**\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        solve(res,root);\\n        return res;\\n    }\\n    \\n    private void solve(List<Integer> res, TreeNode root){\\n        if(root == null) return;\\n        \\n\\t\\t// Traverse left node\\n        solve(res, root.left);\\n\\t\\t\\n\\t\\t// Traverse parent node\\n        res.add(root.val);\\n\\t\\t\\n\\t\\t// Traverse right node\\n        solve(res, root.right);\\n    }\\n}\\n```\\n\\n**Using Stack**\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        TreeNode curr = root;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(curr != null || stack.size() != 0){\\n            \\n            // Move to the left-most node of the tree and push them in stack for future traversal\\n            while(curr != null){\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // Left node\\n            curr = stack.pop();\\n            \\n            // Parent node\\n            res.add(curr.val);\\n            \\n            // Right node\\n            curr = curr.right;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n<br/>\\n\\n**Kotlin Version**\\n\\n```\\nclass Solution {\\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n        val res = mutableListOf<Int>()\\n        inorder(root,res)\\n        return res\\n    }\\n    \\n    private fun inorder(node:TreeNode?, res : MutableList<Int>){\\n        node?.let{\\n            inorder(node.left,res)\\n            res.add(node.`val`)\\n            inorder(node.right,res)\\n        }\\n    }\\n}\\n```\\n\\n**Using Stack**\\n```\\nclass Solution {\\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n        val res = mutableListOf<Int>()\\n        \\n        var curr = root\\n        val stack = Stack<TreeNode>()\\n        \\n        while(curr != null || stack.size != 0){\\n            while(curr!=null){\\n                stack.push(curr)\\n                curr = curr.left\\n            }\\n            curr = stack.pop()\\n            res.add(curr.`val`)\\n            curr = curr.right\\n        }   \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        solve(res,root);\\n        return res;\\n    }\\n    \\n    private void solve(List<Integer> res, TreeNode root){\\n        if(root == null) return;\\n        \\n\\t\\t// Traverse left node\\n        solve(res, root.left);\\n\\t\\t\\n\\t\\t// Traverse parent node\\n        res.add(root.val);\\n\\t\\t\\n\\t\\t// Traverse right node\\n        solve(res, root.right);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        TreeNode curr = root;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(curr != null || stack.size() != 0){\\n            \\n            // Move to the left-most node of the tree and push them in stack for future traversal\\n            while(curr != null){\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // Left node\\n            curr = stack.pop();\\n            \\n            // Parent node\\n            res.add(curr.val);\\n            \\n            // Right node\\n            curr = curr.right;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n        val res = mutableListOf<Int>()\\n        inorder(root,res)\\n        return res\\n    }\\n    \\n    private fun inorder(node:TreeNode?, res : MutableList<Int>){\\n        node?.let{\\n            inorder(node.left,res)\\n            res.add(node.`val`)\\n            inorder(node.right,res)\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n        val res = mutableListOf<Int>()\\n        \\n        var curr = root\\n        val stack = Stack<TreeNode>()\\n        \\n        while(curr != null || stack.size != 0){\\n            while(curr!=null){\\n                stack.push(curr)\\n                curr = curr.left\\n            }\\n            curr = stack.pop()\\n            res.add(curr.`val`)\\n            curr = curr.right\\n        }   \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986517,
                "title": "swift-0-ms-2-lines-recursive",
                "content": "```\\nclass Solution {\\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        guard let root = root else { return [] }\\n        return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func inorderTraversal(_ root: TreeNode?) -> [Int] {\\n        guard let root = root else { return [] }\\n        return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969561,
                "title": "c-3-method-recursive-iterative-using-stack-morris-traversal-threaded-binary-tree",
                "content": "Recall: Inorder= Left, Root Node, Right\\n\\n**1st Approach:** Using recursion\\nWe use a helper function to traverse recursively \\n\\n```\\nclass Solution {\\npublic:\\n        void inorder(TreeNode* root, vector<int>& res){\\n        if (root){\\n            inorder (root->left, res);\\n            res.push_back(root->val);\\n            inorder (root->right, res);\\n        }\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> p;\\n        inorder (root, p);\\n        return p;\\n    }\\n};\\n```\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n**2nd Approach:** Iteratively using Stack\\nUnlike recursively which used the internal stack, we would explicitly use a stack to keep a track of nodes\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector < int > inOrder;\\n        stack < TreeNode* > s;\\n        TreeNode* curr = root;\\n        while (true) {\\n            if (curr != NULL) {\\n                s.push(curr);\\n                curr = curr -> left;\\n            } else\\n            {\\n                if (s.empty()) break;\\n                curr = s.top();\\n                inOrder.push_back(curr -> val);\\n                s.pop();\\n                curr = curr -> right;\\n            }\\n        }\\n        return inOrder;\\n    }\\n};\\n```\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n**3rd Approach:** Using morris traversal i.e, applying the concept of threaded binary tree.\\n\\nExplanation: Here we are wisely creating a thread between the current node and its inorder predecessor so that we can visit back the current node, as there are no parent pointer in the binary tree strucure nor recursion stack which did this task in previous approaches.\\n\\n![image](https://assets.leetcode.com/users/images/0f962cd3-ceb9-43ef-91ec-b79acbe9394d_1650542250.3279028.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode *cur = root;\\n        vector<int> inorder;\\n        while (cur != NULL)\\n        {\\n            if (cur->left == NULL)//no left node then directly push in inorder and go right\\n            {\\n                inorder.push_back(cur->val);\\n                cur = cur->right;\\n            }\\n            else//there is a left node\\n            {\\n                //find inorder predecessor\\n                TreeNode* predecessor = cur->left;//predecessor will be the rightmost of left until it reaches null or back to the current node (as we might have already created thread from it.\\n                while (predecessor->right != cur && predecessor->right != NULL)\\n                    predecessor = predecessor->right;\\n                if (predecessor->right == NULL)//thread creation as visiting first time\\n                {\\n                    predecessor->right = cur;\\n                    cur = cur-> left;\\n                }\\n                else//thread deletion to avoid cycle and pushing node in inorder\\n                {\\n                    predecessor->right = NULL;\\n                    inorder.push_back(cur->val);\\n                    cur = cur->right;\\n                }\\n            }\\n        }\\n        return inorder;\\n    }\\n};\\n```\\nTime Complexity: O(N)\\nSpace Complexity: **O(1)**\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        void inorder(TreeNode* root, vector<int>& res){\\n        if (root){\\n            inorder (root->left, res);\\n            res.push_back(root->val);\\n            inorder (root->right, res);\\n        }\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> p;\\n        inorder (root, p);\\n        return p;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector < int > inOrder;\\n        stack < TreeNode* > s;\\n        TreeNode* curr = root;\\n        while (true) {\\n            if (curr != NULL) {\\n                s.push(curr);\\n                curr = curr -> left;\\n            } else\\n            {\\n                if (s.empty()) break;\\n                curr = s.top();\\n                inOrder.push_back(curr -> val);\\n                s.pop();\\n                curr = curr -> right;\\n            }\\n        }\\n        return inOrder;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode *cur = root;\\n        vector<int> inorder;\\n        while (cur != NULL)\\n        {\\n            if (cur->left == NULL)//no left node then directly push in inorder and go right\\n            {\\n                inorder.push_back(cur->val);\\n                cur = cur->right;\\n            }\\n            else//there is a left node\\n            {\\n                //find inorder predecessor\\n                TreeNode* predecessor = cur->left;//predecessor will be the rightmost of left until it reaches null or back to the current node (as we might have already created thread from it.\\n                while (predecessor->right != cur && predecessor->right != NULL)\\n                    predecessor = predecessor->right;\\n                if (predecessor->right == NULL)//thread creation as visiting first time\\n                {\\n                    predecessor->right = cur;\\n                    cur = cur-> left;\\n                }\\n                else//thread deletion to avoid cycle and pushing node in inorder\\n                {\\n                    predecessor->right = NULL;\\n                    inorder.push_back(cur->val);\\n                    cur = cur->right;\\n                }\\n            }\\n        }\\n        return inorder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548841,
                "title": "c-solution",
                "content": "****Runtime: 0 ms, faster than 100.00% of C online submissions for Binary Tree Inorder Traversal.\\nMemory Usage: 5.9 MB, less than 68.48% of C online submissions for Binary Tree Inorder Traversal.\\n```\\nvoid travel(struct TreeNode* root,int*ret,int*size){\\n    if(root==NULL)\\n        return 0 ;\\n    travel(root->left,ret,size);\\n    ret[(*size)++]=root->val;\\n    travel(root->right,ret,size);\\n}\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *ret=malloc(sizeof(int)*100);\\n    travel(root,ret,returnSize);\\n        return ret;\\n\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvoid travel(struct TreeNode* root,int*ret,int*size){\\n    if(root==NULL)\\n        return 0 ;\\n    travel(root->left,ret,size);\\n    ret[(*size)++]=root->val;\\n    travel(root->right,ret,size);\\n}\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *ret=malloc(sizeof(int)*100);\\n    travel(root,ret,returnSize);\\n        return ret;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359114,
                "title": "recursive-python-3-lines-of-code",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not(root):\\n            return []\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not(root):\\n            return []\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259828,
                "title": "2-line-javascript-solution-faster-than-81",
                "content": "```\\nvar inorderTraversal = function(root) {\\n    if (!root) return []\\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar inorderTraversal = function(root) {\\n    if (!root) return []\\n    return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 960715,
                "title": "python-iterative",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        traversal = []\\n\\n        node = root\\n        stack = []\\n        while node or stack:\\n            if node:\\n                stack.append(node)\\n                node = node.left\\n            else:\\n                node = stack.pop()\\n                traversal.append(node.val)\\n                node = node.right\\n                \\n        return traversal\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        traversal = []\\n\\n        node = root\\n        stack = []\\n        while node or stack:\\n            if node:\\n                stack.append(node)\\n                node = node.left\\n            else:\\n                node = stack.pop()\\n                traversal.append(node.val)\\n                node = node.right\\n                \\n        return traversal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31380,
                "title": "recommend-by-rainbow-morris-traversal-and-time-complexity-analysis-why-o-n",
                "content": "**Update : 2016/02/26**\\n\\nabout why the time complexity of the Morris traversal is O(n) maybe confusing !\\n\\nHere is the details you need to understand the time complexity is O(N) as each edge is traversed for 3 times at most.\\n\\n       Each edge is traversed at most 3 times and there are n-1 edges in a tree,\\n       hence the O(n).\\n\\nI think the part that is confusing you is the predecessor finding loop because it goes down the tree following the rightmost node.\\n\\n            /* Find the inorder predecessor of current */\\n          pre = current->left;\\n          while (pre->right != NULL && pre->right != current)\\n          pre = pre->right;\\n\\n\\nThis full path is only processed twice: \\nwhen the current pointer reaches the node\\nwhen we have processed its left subtree\\n\\nAlso, the key is that this path is not processed again while we're on the left subtree.\\n\\nYou can see a simple example here .\\n\\n[https://www.quora.com/Why-does-the-Morris-in-order-traversal-algorithm-have-O-n-time-complexity][1]\\n\\nMorris traversal is a cheap way to do the traversal of the tree with no Space cost and non-recursive way.\\n\\nBut at first, it may seem hard for you to understand.\\n\\nThe key idea is to traversal as in-order, when meet the node with left child, then we will\\n\\ntraverse to find the pre-node of the current node and link it to the current node. \\n\\nSo after push back the in-order first node,  it will back track by the previous setting \"right link\"!\\n\\nSo when we meet the \"right link\"  for the next time, we will reset it and push back the value.\\n\\nSo we link the tree value and get the final vector result.\\n\\n         1. Initialize current as root \\n         2. While current is not NULL\\n                   If current does not have left child\\n                         a) Print current\\u2019s data\\n                         b) Go to the right, i.e., current = current->right\\n                   Else\\n                         a) Make current as right child of the rightmost node in current's left subtree\\n                         b) Go to this left child, i.e., current = current->left\\n\\nAC C++  implementation .\\n\\n\\n    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode* root) {\\n            TreeNode* cur, *pre;\\n            vector<int> result;\\n            if(!root)  return  result;\\n            \\n            cur=root;\\n            while(cur){\\n                /** move left **/\\n                if(cur->left){\\n                    /** find the previous node of the cur **/\\n                   pre=cur->left;\\n                   while(pre->right && pre->right!=cur)  pre=pre->right;\\n                   /** if not set, keep traversal **/\\n                   if(!pre->right){\\n                       pre->right=cur;\\n                       cur=cur->left;\\n                   }\\n                   /** if set, push back the value, and keep traversal **/\\n                   else{\\n                       pre->right=NULL;\\n                       result.push_back(cur->val);\\n                       cur=cur->right;\\n                   }\\n                }\\n                /** push_back the root value move right (previous set right link will point \\n                    to the in-order-next node)**/\\n                else{\\n                    result.push_back(cur->val);\\n                    cur=cur->right;\\n                }\\n            }\\n        }\\n    };\\n\\n\\n  [1]: https://www.quora.com/Why-does-the-Morris-in-order-traversal-algorithm-have-O-n-time-complexity",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode* root) {\\n            TreeNode* cur, *pre;\\n            vector<int> result;\\n            if(!root)  return  result;\\n            \\n            cur=root;\\n            while(cur){\\n                /** move left **/\\n                if(cur->left){\\n                    /** find the previous node of the cur **/\\n                   pre=cur->left;\\n                   while(pre->right && pre->right!=cur)  pre=pre->right;\\n                   /** if not set, keep traversal **/\\n                   if(!pre->right){\\n                       pre->right=cur;\\n                       cur=cur->left;\\n                   }",
                "codeTag": "Java"
            },
            {
                "id": 3931235,
                "title": "easy-c-solution-dfs-bfs-and-morris-traversal-beats-100",
                "content": "# Code\\n```\\n// Recursive approach\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &ans){\\n        //base case\\n        if(root == NULL)\\n            return;\\n\\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n        return ans;\\n    }\\n};\\n\\n// Iterative approach\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        stack<TreeNode*> s;\\n        TreeNode *curr = root;\\n\\n        while(true){\\n            if(curr != NULL){\\n                s.push(curr);\\n                curr = curr->left;\\n            }\\n            else if(s.empty())\\n                break;\\n            else{\\n                ans.push_back(s.top()->val);\\n                curr = s.top()->right;\\n                s.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Morris traversal - Space O(1)\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root == NULL)\\n            return {};\\n        \\n        vector<int> ans;\\n        TreeNode *curr = root, *pre;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                ans.push_back(curr->val);\\n                curr = curr->right;\\n            }\\n            else{\\n                pre = curr->left;\\n                while(pre->right != NULL && pre->right != curr)\\n                    pre = pre->right;\\n                \\n                if(pre->right == NULL){\\n                    pre->right = curr;\\n                    curr = curr->left;\\n                }\\n                else{   // pre->right == curr\\n                    pre->right = NULL;\\n                    ans.push_back(curr->val);\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive approach\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &ans){\\n        //base case\\n        if(root == NULL)\\n            return;\\n\\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n        return ans;\\n    }\\n};\\n\\n// Iterative approach\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        stack<TreeNode*> s;\\n        TreeNode *curr = root;\\n\\n        while(true){\\n            if(curr != NULL){\\n                s.push(curr);\\n                curr = curr->left;\\n            }\\n            else if(s.empty())\\n                break;\\n            else{\\n                ans.push_back(s.top()->val);\\n                curr = s.top()->right;\\n                s.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Morris traversal - Space O(1)\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if(root == NULL)\\n            return {};\\n        \\n        vector<int> ans;\\n        TreeNode *curr = root, *pre;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                ans.push_back(curr->val);\\n                curr = curr->right;\\n            }\\n            else{\\n                pre = curr->left;\\n                while(pre->right != NULL && pre->right != curr)\\n                    pre = pre->right;\\n                \\n                if(pre->right == NULL){\\n                    pre->right = curr;\\n                    curr = curr->left;\\n                }\\n                else{   // pre->right == curr\\n                    pre->right = NULL;\\n                    ans.push_back(curr->val);\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431301,
                "title": "in-order-traversing-in-python-python3",
                "content": "# Approach\\nAs Inorder traversing a Binary tree, first we have to travse the left tree nodes than root node and than at the last right tree nodes.\\nUsing recursive model for this solution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053456,
                "title": "c-short-simple-recursion",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==nullptr){return;}\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root);\\n        return v;    \\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==nullptr){return;}\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root);\\n        return v;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827145,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035548,
                "title": "java-script-solution-using-recursion",
                "content": "```\\nvar inorderTraversal = function(root) {\\n    if(root === null) return [];\\n    return [...inorderTraversal(root.left),root.val,...inorderTraversal(root.right)];\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar inorderTraversal = function(root) {\\n    if(root === null) return [];\\n    return [...inorderTraversal(root.left),root.val,...inorderTraversal(root.right)];\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1778180,
                "title": "python-recursive-one-liner",
                "content": "```\\nclass Solution:\\n  def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n    return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n  def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n    return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437870,
                "title": "js-heavily-commented-recursive-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    // In-Order Traversal ->\\n    //  1. Recursively traverse through the left subtree\\n    //  2. Visit current node\\n    //  3. Recursively traverse through the right subtree\\n    \\n    // Initialize array of values\\n    let result = [];\\n    \\n    // Recursive function to traverse through subtrees\\n    inorder(root, result);\\n    \\n    return result;\\n};\\n\\nconst inorder = (node, result) => {\\n    if (!node) return null;\\n    inorder(node.left, result); // Traverse through left subtree\\n    result.push(node.val); // Visit node\\n    inorder(node.right, result); // Traverse through right subtree\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    // In-Order Traversal ->\\n    //  1. Recursively traverse through the left subtree\\n    //  2. Visit current node\\n    //  3. Recursively traverse through the right subtree\\n    \\n    // Initialize array of values\\n    let result = [];\\n    \\n    // Recursive function to traverse through subtrees\\n    inorder(root, result);\\n    \\n    return result;\\n};\\n\\nconst inorder = (node, result) => {\\n    if (!node) return null;\\n    inorder(node.left, result); // Traverse through left subtree\\n    result.push(node.val); // Visit node\\n    inorder(node.right, result); // Traverse through right subtree\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 706892,
                "title": "python-morris-traversal",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        curr = root\\n        res = []\\n        while curr:\\n            if curr.left:\\n                pre = curr.left\\n                while pre.right and pre.right!=curr:\\n                    pre = pre.right\\n                if pre.right == curr:\\n                    pre.right = None\\n                    res.append(curr.val)\\n                    curr = curr.right\\n                else:\\n                    pre.right = curr\\n                    curr = curr.left\\n            else:\\n                res.append(curr.val)\\n                curr = curr.right\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        curr = root\\n        res = []\\n        while curr:\\n            if curr.left:\\n                pre = curr.left\\n                while pre.right and pre.right!=curr:\\n                    pre = pre.right\\n                if pre.right == curr:\\n                    pre.right = None\\n                    res.append(curr.val)\\n                    curr = curr.right\\n                else:\\n                    pre.right = curr\\n                    curr = curr.left\\n            else:\\n                res.append(curr.val)\\n                curr = curr.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546002,
                "title": "easy-to-understand-iterative-and-recursive-faster-simple-python-solution",
                "content": "```\\ndef iterative(self, root):\\n        out = []\\n        stack = []\\n        top = root\\n        while top or len(stack):\\n            while top:\\n                stack.append(top)\\n                top = top.left\\n            top = stack.pop()\\n            out.append(top.val)\\n            top = top.right\\n        return out\\n    \\n    def recursive(self, root):\\n        def rec(root):\\n            if root:\\n                rec(root.left)\\n                out.append(root.val)\\n                rec(root.right)\\n        \\n        out = []\\n        rec(root)\\n        return out\\n```\\n\\n**I hope that you\\'ve found them useful.**\\n\\t*In that case, please do upvote. It motivates me to write more such post\\uD83D\\uDE03*",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef iterative(self, root):\\n        out = []\\n        stack = []\\n        top = root\\n        while top or len(stack):\\n            while top:\\n                stack.append(top)\\n                top = top.left\\n            top = stack.pop()\\n            out.append(top.val)\\n            top = top.right\\n        return out\\n    \\n    def recursive(self, root):\\n        def rec(root):\\n            if root:\\n                rec(root.left)\\n                out.append(root.val)\\n                rec(root.right)\\n        \\n        out = []\\n        rec(root)\\n        return out\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31386,
                "title": "c-0ms-stack-based-solution",
                "content": "    class Solution {\\n    public:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        vector<TreeNode*> stack;\\n        TreeNode *cur=root;\\n        while (cur!=NULL || !stack.empty()){\\n            if (cur){\\n                stack.push_back(cur);\\n                cur = cur->left;\\n            }\\n            else {\\n                cur = stack.back();\\n                stack.pop_back();\\n                res.push_back(cur->val);\\n                cur = cur->right;\\n            }\\n        }\\n        return res;\\n    } \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        vector<TreeNode*> stack;\\n        TreeNode *cur=root;\\n        while (cur!=NULL || !stack.empty()){\\n            if (cur){\\n                stack.push_back(cur);\\n                cur = cur->left;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 31402,
                "title": "java-1ms-both-iterative-and-recursive",
                "content": "The recursive solution is trivial, yet the iterative solution with an explicit stack helps us better understand what is going on with the stack in the recursive solution.\\n\\n    public class Solution {\\n        public List<Integer> inorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            inorderTraversalRecursive(root, result);\\n            //inorderTraversalIterative(root, result);\\n            return result;\\n        }\\n        \\n        private void inorderTraversalIterative(TreeNode root, List<Integer> result) {\\n            LinkedList<TreeNode> stack = new LinkedList<TreeNode>();\\n            TreeNode curr = root;\\n            while (curr != null || !stack.isEmpty()) {\\n                if (curr != null) {\\n                    stack.offerLast(curr);\\n                    curr = curr.left;\\n                } else {\\n                    result.add(stack.getLast().val);\\n                    curr = stack.getLast().right;\\n                    stack.pollLast();\\n                }\\n            }\\n        }\\n        \\n        private void inorderTraversalRecursive(TreeNode root, List<Integer> result) {\\n            if (root == null) {\\n                return;\\n            }\\n            inorderTraversalRecursive(root.left, result);\\n            result.add(root.val);\\n            inorderTraversalRecursive(root.right, result);        \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> inorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            inorderTraversalRecursive(root, result);\\n            //inorderTraversalIterative(root, result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 31478,
                "title": "my-accepted-solution-in-python",
                "content": "    class Solution:\\n        def inorderTraversal(self, root):\\n            stack = []\\n            output = []\\n            while True:\\n                while root:\\n                    stack.append(root)\\n                    root = root.left\\n                if stack == []:\\n                    break\\n                node = stack.pop()\\n                output.append(node.val)\\n                root = node.right\\n            return output",
                "solutionTags": [],
                "code": "    class Solution:\\n        def inorderTraversal(self, root):\\n            stack = []\\n            output = []\\n            while True:\\n                while root:\\n                    stack.append(root)\\n                    root = root.left\\n                if stack == []:\\n                    break\\n                node = stack.pop()\\n                output.append(node.val)\\n                root = node.right\\n            return output",
                "codeTag": "Java"
            },
            {
                "id": 3202461,
                "title": "c-recursive-easy-solution-beats-100",
                "content": "# Intuition\\nRecursive Solution\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &vct){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        inorder(root->left,vct);\\n        vct.push_back(root->val);\\n        inorder(root->right,vct);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> vct;\\n        inorder(root,vct);\\n        return vct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &vct){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        inorder(root->left,vct);\\n        vct.push_back(root->val);\\n        inorder(root->right,vct);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> vct;\\n        inorder(root,vct);\\n        return vct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187656,
                "title": "91-35-binary-tree-inorder-traversal-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe idea is to traverse the binary tree in an inorder fashion using a stack. We start with the root node and keep going to the left child until we reach a leaf node. Then, we backtrack and process the node by popping it from the stack, appending its value to the result, and moving to its right child. We repeat this process until the stack is empty and we have processed all the nodes in the tree.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n91.35%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        # Initialize an empty stack to store the nodes\\n        stack = []\\n        # Initialize an empty list to store the result\\n        result = []\\n        # Start with the root node\\n        curr = root\\n        # Loop until the stack is empty or curr is None\\n        while stack or curr:\\n            # If curr is not None, push it onto the stack and move to its left child\\n            if curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            # If curr is None, pop a node from the stack, append its value to the result, and move to its right child\\n            else:\\n                curr = stack.pop()\\n                result.append(curr.val)\\n                curr = curr.right\\n        # Return the result\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        # Initialize an empty stack to store the nodes\\n        stack = []\\n        # Initialize an empty list to store the result\\n        result = []\\n        # Start with the root node\\n        curr = root\\n        # Loop until the stack is empty or curr is None\\n        while stack or curr:\\n            # If curr is not None, push it onto the stack and move to its left child\\n            if curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            # If curr is None, pop a node from the stack, append its value to the result, and move to its right child\\n            else:\\n                curr = stack.pop()\\n                result.append(curr.val)\\n                curr = curr.right\\n        # Return the result\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185647,
                "title": "c-easy-solution-using-recursion-explained",
                "content": "# Intuition\\nIn-Order Traversal is a Depth First Search Algorithm of traversal in Binary Trees. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# DFS Traversal Algorithms \\n- [In-Order Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/post-solution/3185647/) \\n- [Post-Order Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/solutions/3185653/c-easy-solution-using-recursion-explained/)\\n- [Pre-Order Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3185665/c-easy-solution-using-recursion-explained/)\\n\\n# Approach\\nIn-Order Traversal -> L N R\\n1. Traverse the left subtree\\n2. Print/Store the node \\n3. Traverse the right subtree\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// InOrder Traversal -> L N R \\n// Traverse the left subtree till NULL (Base Case), print/store the node, traverse the right subtree(till NULL - Base Case)\\n    void inOrder (TreeNode *node, vector<int> &result)\\n    {\\n        if (node == NULL)\\n        {\\n            return ;\\n        }\\n\\n        inOrder (node -> left, result) ; \\n        result.push_back(node -> val) ; \\n        inOrder (node -> right, result) ;\\n\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> result ; \\n\\n        inOrder (root, result) ; \\n        return result ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/a558e75a-a201-4602-887b-3d5314b6875f_1676391339.7404554.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// InOrder Traversal -> L N R \\n// Traverse the left subtree till NULL (Base Case), print/store the node, traverse the right subtree(till NULL - Base Case)\\n    void inOrder (TreeNode *node, vector<int> &result)\\n    {\\n        if (node == NULL)\\n        {\\n            return ;\\n        }\\n\\n        inOrder (node -> left, result) ; \\n        result.push_back(node -> val) ; \\n        inOrder (node -> right, result) ;\\n\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> result ; \\n\\n        inOrder (root, result) ; \\n        return result ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163094,
                "title": "simple-java-100-easy-comments-readable-beginners-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = root;\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            res.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = root;\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = stack.pop();\\n            res.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976367,
                "title": "best-c-code-out-there-memory-100-optimized",
                "content": "class Solution {\\n     private : vector<int>res;\\n    void inorder(TreeNode *root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n        return;\\n    }\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        inorder(root,res);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n     private : vector<int>res;\\n    void inorder(TreeNode *root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n        return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1724132,
                "title": "python-3-25ms-perfect-pythonic-recursive-one-liner-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return  self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return  self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588635,
                "title": "javascript-one-liner",
                "content": "```javascript\\nvar inorderTraversal = function(root) {\\n    return !root ? [] : [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\nvar inorderTraversal = function(root) {\\n    return !root ? [] : [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348586,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300339,
                "title": "c-recursive-solution-in-o-n-time",
                "content": "#Trees - **Binary Tree Inorder Traversal**\\n\\n\\uD83D\\uDC49 Recursive solution: `O(n)` time and `O(n)` space (function call stack);\\n\\nHere, We just traverse in such a way that after making left call we push the value at that point in the the vector and then make the right call. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void traverse(TreeNode* root, vector<int> &ans)\\n    {\\n        if(!root)\\n            return;\\n        \\n        if(root->left) \\n            traverse(root->left, ans);\\n        \\n        ans.push_back(root->val);  \\n        \\n        if(root->right)\\n            traverse(root->right, ans);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        \\n            traverse(root, ans);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\u2728 Alternate Approach : Try solving Iteratively using stack: `O(n)` time and `O(n)` space",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void traverse(TreeNode* root, vector<int> &ans)\\n    {\\n        if(!root)\\n            return;\\n        \\n        if(root->left) \\n            traverse(root->left, ans);\\n        \\n        ans.push_back(root->val);  \\n        \\n        if(root->right)\\n            traverse(root->right, ans);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        \\n            traverse(root, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048556,
                "title": "java-3-solutions-with-explanation-recursive-iterative-using-stack-iterative-without-stack",
                "content": "The idea is simple for in-order traversal -\\n1. traverse the left sub-tree\\n2. visit the node\\n3. traverse the right sub-tree\\n\\nThis process is done recursively for each node in the tree.\\n\\n#### Recursive\\n\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> inOrderList = new ArrayList<>();\\n        inOrder(root, inOrderList);\\n        return inOrderList;\\n    }\\n    \\n    private void inOrder(TreeNode node, List<Integer> list){\\n        if(node != null){\\n            inOrder(node.left, list);\\n            list.add(node.val);\\n            inOrder(node.right, list);\\n        }\\n    }\\n}\\n```\\n\\nThe same idea of recursion can be implemented using stack as well.\\n\\n#### Iterative using Stack\\n\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> listInOrder = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = root;\\n        \\n        while(curr != null || !stack.isEmpty()){\\n            if(curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            } else{\\n                curr = stack.pop();\\n                listInOrder.add(curr.val);\\n                curr = curr.right;                    \\n            }\\n        }\\n        return listInOrder;\\n    }\\n}\\n```\\n\\n#### Iterative (Without Stack) - Morris Traversal in Threaded BST\\n\\nThis idea is slightly different than the other two but is relatively simple. Instead of using a stack (or recursion) for revisiting the current node again to traverse the right subtree, we update the right pointer of the in-order predecessor to point to the current node even before we start doing the in-order traversal on a node. Later we get rid of this pointer when all nodes of the left sub-tree is completely visited to leave the tree back in its original state.\\n\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        TreeNode curr = root;\\n        \\n        while(curr != null){\\n            if(curr.left == null){\\n                list.add(curr.val);\\n                curr = curr.right;\\n            } else {\\n                TreeNode predecessor = curr.left;\\n                while(predecessor.right != null && predecessor.right != curr)\\n                    predecessor = predecessor.right;\\n                if(predecessor.right == null){\\n                    predecessor.right = curr;\\n                    curr = curr.left;\\n                } else {\\n                    predecessor.right = null;\\n                    list.add(curr.val);\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> inOrderList = new ArrayList<>();\\n        inOrder(root, inOrderList);\\n        return inOrderList;\\n    }\\n    \\n    private void inOrder(TreeNode node, List<Integer> list){\\n        if(node != null){\\n            inOrder(node.left, list);\\n            list.add(node.val);\\n            inOrder(node.right, list);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> listInOrder = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = root;\\n        \\n        while(curr != null || !stack.isEmpty()){\\n            if(curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            } else{\\n                curr = stack.pop();\\n                listInOrder.add(curr.val);\\n                curr = curr.right;                    \\n            }\\n        }\\n        return listInOrder;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        TreeNode curr = root;\\n        \\n        while(curr != null){\\n            if(curr.left == null){\\n                list.add(curr.val);\\n                curr = curr.right;\\n            } else {\\n                TreeNode predecessor = curr.left;\\n                while(predecessor.right != null && predecessor.right != curr)\\n                    predecessor = predecessor.right;\\n                if(predecessor.right == null){\\n                    predecessor.right = curr;\\n                    curr = curr.left;\\n                } else {\\n                    predecessor.right = null;\\n                    list.add(curr.val);\\n                    curr = curr.right;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847780,
                "title": "c-recursive",
                "content": "```\\nint cnt(struct TreeNode* root)\\n{\\n    if(root)\\n        return 1 + cnt(root->left) + cnt(root->right);\\n    return 0;\\n}\\n\\nvoid inorder(struct TreeNode* root, int** res)\\n{\\n    if(root)\\n    {\\n        inorder(root->left, res);\\n        *((*res)++) = root->val;\\n        inorder(root->right, res);\\n    }\\n}\\n\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    \\n    *returnSize = cnt(root);\\n    int* res = (int*)malloc(((*returnSize)) * sizeof(int));\\n    memset(res, 0, (*returnSize) * sizeof(int));   \\n    int *cpy = res;\\n    inorder(root, &cpy);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cnt(struct TreeNode* root)\\n{\\n    if(root)\\n        return 1 + cnt(root->left) + cnt(root->right);\\n    return 0;\\n}\\n\\nvoid inorder(struct TreeNode* root, int** res)\\n{\\n    if(root)\\n    {\\n        inorder(root->left, res);\\n        *((*res)++) = root->val;\\n        inorder(root->right, res);\\n    }\\n}\\n\\n\\nint* inorderTraversal(struct TreeNode* root, int* returnSize)\\n{\\n    \\n    *returnSize = cnt(root);\\n    int* res = (int*)malloc(((*returnSize)) * sizeof(int));\\n    memset(res, 0, (*returnSize) * sizeof(int));   \\n    int *cpy = res;\\n    inorder(root, &cpy);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 632114,
                "title": "c-easy-iterative-and-recurive-solution-with-explanation",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // Recursive Method\\n    \\n    vector <int> ans;\\n    void inorder(TreeNode *root)\\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        inorder(root);\\n        return ans;\\n    }\\n    \\n    \\n    // Iterative method\\n    \\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        TreeNode *ptr = root;\\n        vector <int> ans;\\n        stack <TreeNode*> address;\\n        \\n        if(root == NULL)\\n            return ans;\\n        \\n        // until address stack is empty and ptr points to NULL i.e. Traversal is over\\n        while( !address.empty() || ptr != NULL )\\n        {\\n            // if ptr points to a child\\n            if(ptr != NULL)\\n            {\\n                // pushing the address to the stack\\n                address.push(ptr);\\n                // moving left\\n                ptr = ptr->left;                    // LEFT\\n            }\\n            else\\n            {\\n                // popping the address and making ptr point to it, kinda backtrack a step\\n                ptr = address.top();\\n                address.pop();\\n                // printing or pushing the value of node to array\\n                ans.push_back(ptr->val);            // PRINT\\n                // movinf left\\n                ptr= ptr->right;                    // RIGHT\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // Recursive Method\\n    \\n    vector <int> ans;\\n    void inorder(TreeNode *root)\\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        inorder(root);\\n        return ans;\\n    }\\n    \\n    \\n    // Iterative method\\n    \\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        TreeNode *ptr = root;\\n        vector <int> ans;\\n        stack <TreeNode*> address;\\n        \\n        if(root == NULL)\\n            return ans;\\n        \\n        // until address stack is empty and ptr points to NULL i.e. Traversal is over\\n        while( !address.empty() || ptr != NULL )\\n        {\\n            // if ptr points to a child\\n            if(ptr != NULL)\\n            {\\n                // pushing the address to the stack\\n                address.push(ptr);\\n                // moving left\\n                ptr = ptr->left;                    // LEFT\\n            }\\n            else\\n            {\\n                // popping the address and making ptr point to it, kinda backtrack a step\\n                ptr = address.top();\\n                address.pop();\\n                // printing or pushing the value of node to array\\n                ans.push_back(ptr->val);            // PRINT\\n                // movinf left\\n                ptr= ptr->right;                    // RIGHT\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467789,
                "title": "one-code-pattern-for-3-leetcode-questions-c",
                "content": "**The In-Order code pattern below can be used to solve three different Leetcode problems. The othe**r **questions also require In-Order Traversal**\\n\\n**IN-ORDER TRAVERSAL - USING STACKS**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        vector<int> ans;\\n        if(root==NULL) return ans;\\n        stack<TreeNode*> s;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top();\\n            s.pop();\\n            ans.push_back(root->val);\\n            root=root->right;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n*TIME = O(N) \\nSPACE = O(N)*\\n\\n**VALIDATE A BINARY TREE**\\n\\n```class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root)\\n    {\\n        if(root==NULL) return true;\\n        stack<TreeNode*> s;\\n        TreeNode *prev=NULL;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top();  s.pop();\\n            if(prev!=NULL && root->val <= prev->val) \\n                return false;\\n            prev=root;\\n            root=root->right;\\n        }\\n        return true;\\n    }\\n};\\n```\\n*TIME = O(N)\\nWhen bad element is in the rightmost leaf*\\n*SPACE = O(N)*\\n\\n**FIND THE K-th SMALLEST ELEMENT IN A BT**\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) \\n    {\\n        stack<TreeNode*> s;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top(); s.pop();\\n            if(--k ==0) \\n                break;\\n            root=root->right;\\n        }        \\n        return root->val;\\n    }\\n};\\n```\\n\\n*TIME = O(H+k)*\\n*where H is a tree height. This complexity is defined by the stack, which contains at least H + k elements, since* *before starting to pop out one has to go down to a leaf. This results in O(logN+k) for the balanced tree and O(N+k) for completely unbalanced tree with all the nodes in the left subtree.*\\n\\n*SPACE = O(H+k)\\nworst case (space) = O(N+k)\\nAverage case (space)= O(logn +k)*\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root)\\n    {\\n        vector<int> ans;\\n        if(root==NULL) return ans;\\n        stack<TreeNode*> s;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top();\\n            s.pop();\\n            ans.push_back(root->val);\\n            root=root->right;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root)\\n    {\\n        if(root==NULL) return true;\\n        stack<TreeNode*> s;\\n        TreeNode *prev=NULL;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top();  s.pop();\\n            if(prev!=NULL && root->val <= prev->val) \\n                return false;\\n            prev=root;\\n            root=root->right;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) \\n    {\\n        stack<TreeNode*> s;\\n        while(root!=NULL || !s.empty())\\n        {\\n            while(root!=NULL)\\n            {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top(); s.pop();\\n            if(--k ==0) \\n                break;\\n            root=root->right;\\n        }        \\n        return root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234471,
                "title": "python3-100-using-iteration-readable",
                "content": "```\\nclass Solution:\\n    def inorderTraversal(self, root: \\'TreeNode\\') -> \\'List[int]\\':\\n        if not root:\\n            return []\\n        stack = list()\\n        output = list()\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                output.append(node.val)\\n                root = node.right\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: \\'TreeNode\\') -> \\'List[int]\\':\\n        if not root:\\n            return []\\n        stack = list()\\n        output = list()\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                output.append(node.val)\\n                root = node.right\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31332,
                "title": "why-every-solution-is-using-2-while-loops-the-standard-iterative-solution-shoule-only-has-one-while-loop",
                "content": "```\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<Integer> ();\\n        if (root == null) return res;\\n        \\n        Stack<TreeNode> s = new Stack<TreeNode>();\\n        TreeNode n = root;\\n        \\n        while (n != null || !s.isEmpty()) {\\n            if  (n != null) {\\n                s.push(n);\\n                n = n.left;\\n            }\\n            else {\\n                TreeNode l = s.pop();\\n                res.add(l.val);\\n                n = l.right;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<Integer> ();\\n        if (root == null) return res;\\n        \\n        Stack<TreeNode> s = new Stack<TreeNode>();\\n        TreeNode n = root;\\n        \\n        while (n != null || !s.isEmpty()) {\\n            if  (n != null) {\\n                s.push(n);\\n                n = n.left;\\n            }\\n            else {\\n                TreeNode l = s.pop();\\n                res.add(l.val);\\n                n = l.right;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31344,
                "title": "javascript-solution",
                "content": "`````\\nvar inorderTraversal = function(root) {\\n    var stack = [],\\n        res = [];\\n    \\n    while(true){\\n        if(root !== null){\\n            stack.push(root);\\n            root = root.left;\\n        }else{\\n            if(stack.length === 0) break;\\n            root = stack.pop();\\n            res.push(root.val);\\n            root = root.right;\\n        }\\n    }\\n    \\n    return res;\\n};",
                "solutionTags": [],
                "code": "`````\\nvar inorderTraversal = function(root) {\\n    var stack = [],\\n        res = [];\\n    \\n    while(true){\\n        if(root !== null){\\n            stack.push(root);\\n            root = root.left;\\n        }else{\\n            if(stack.length === 0) break;\\n            root = stack.pop();\\n            res.push(root.val);\\n            root = root.right;\\n        }\\n    }\\n    \\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3626483,
                "title": "1-line-solution-python",
                "content": "# Approach\\n1. The function begins with a base case check: `[] if not root`. If the `root` node is `None` (i.e., there is no tree), an empty list `[]` is returned.\\n\\n2. If the `root` node is not `None`, the function recursively calls itself to perform an inorder traversal on the left subtree: `self.inorderTraversal(root.left)`. This step visits all the nodes in the left subtree in the inorder sequence.\\n\\n3. After the recursive call for the left subtree, the value of the `root` node is appended to the result list using `[root.val]`.\\n\\n4. Finally, the function recursively calls itself to perform an inorder traversal on the right subtree: `self.inorderTraversal(root.right)`. This step visits all the nodes in the right subtree in the inorder sequence.\\n\\n5. The function returns the concatenation of the left subtree traversal, the `root` value, and the right subtree traversal: `self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)`.\\n\\nThis approach utilizes the recursive nature of the inorder traversal. It recursively traverses the left subtree, visits the current node, and then recursively traverses the right subtree. The base case handles the empty tree, and the concatenation of the traversal results builds the final inorder traversal list.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        return [] if not root else self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)                       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        return [] if not root else self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)                       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436598,
                "title": "simple-c-solution",
                "content": "# Inorder -> Left Node Right\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n```\\n# Iterative\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        stack<TreeNode *> st;\\n        while(true){\\n            if(root!=NULL){\\n                st.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                if(st.empty()){\\n                    break;\\n                }\\n                root=st.top();\\n                res.push_back(root->val);\\n                st.pop();\\n                root=root->right;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Recursive\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int> &res, TreeNode *root){\\n        if(root==NULL){\\n            return ;\\n        }\\n        helper(res,root->left);\\n        res.push_back(root->val);\\n        helper(res,root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        helper(res,root);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        stack<TreeNode *> st;\\n        while(true){\\n            if(root!=NULL){\\n                st.push(root);\\n                root=root->left;\\n            }\\n            else{\\n                if(st.empty()){\\n                    break;\\n                }\\n                root=st.top();\\n                res.push_back(root->val);\\n                st.pop();\\n                root=root->right;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<int> &res, TreeNode *root){\\n        if(root==NULL){\\n            return ;\\n        }\\n        helper(res,root->left);\\n        res.push_back(root->val);\\n        helper(res,root->right);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        helper(res,root);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300936,
                "title": "easiest-solution-out-there-in-5-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlsssss Up vote -> \\uD83D\\uDE2D\\n# Code\\n```\\n\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        if (root!=null) {\\n            inorderTraversal(root.left);\\n            list.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        if (root!=null) {\\n            inorderTraversal(root.left);\\n            list.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268031,
                "title": "beats-100-use-of-recursion-in-java",
                "content": "\\n\\n# Approach\\nThis is a Java program that solves the problem of traversing a binary tree in an inorder manner. The input to the program is a binary tree, represented using the TreeNode class. The TreeNode class has three fields: val, left, and right. The val field stores the value of the node, while the left and right fields store references to the left and right subtrees, respectively. The program returns a list of integers representing the inorder traversal of the binary tree.\\n\\nThe solution implements the inorder traversal recursively using the helper function func. The function takes two arguments: the current node being traversed (root) and the list to which the values are to be added (ans). The traversal is done as follows:\\n\\n1. If the current node is null, return.\\n2. Recursively traverse the left subtree.\\n3. Add the value of the current node to the list.\\n4. Recursively traverse the right subtree.\\n\\n\\n\\nThe main function, inorderTraversal, initializes an empty list ans and calls the helper function func with the root node and the list. Finally, the function returns the list containing the inorder traversal of the binary tree.\\n\\nOverall, the program is an implementation of the classic inorder traversal algorithm for binary trees\\n# Complexity\\n- Time complexity: \\nO(N), where N is the number of nodes in the binary tree. This is because the function visits each node exactly once.\\n\\n\\n- Space complexity:\\nO(N), where N is the number of nodes in the binary tree. This is because the maximum depth of the recursion is equal to the height of the binary tree, and in the worst case, the binary tree can be a degenerate tree, which means that it has N nodes and a height of N. In this case, the recursion would use O(N) space.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        func(root,ans);\\n        return ans;\\n    }\\n    public void func(TreeNode root,List<Integer> ans){\\n        if(root==null){\\n            return;\\n        }\\n        func(root.left,ans);\\n        ans.add(root.val);\\n        func(root.right,ans);\\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/2c79ad82-a411-4e0d-9b03-481e726b3c16_1678181469.338393.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        func(root,ans);\\n        return ans;\\n    }\\n    public void func(TreeNode root,List<Integer> ans){\\n        if(root==null){\\n            return;\\n        }\\n        func(root.left,ans);\\n        ans.add(root.val);\\n        func(root.right,ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168608,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nRecurive Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL) \\n            return;\\n        inorder(root->left, nodes);\\n        nodes.push_back(root->val);\\n        inorder(root->right, nodes);    \\n    }    \\n};\\n```\\n\\n# Approach 2\\nIterative Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> inorder;\\n        if (root == NULL)\\n            return inorder;\\n        stack <TreeNode* > st;\\n        TreeNode* curr = root;\\n        while (true) {\\n            if (curr != NULL) {\\n                st.push(curr);\\n                curr = curr->left;\\n            } else {\\n                if (st.empty() == true)\\n                    break;\\n                curr = st.top();\\n                st.pop();\\n                inorder.push_back(curr->val);\\n                curr = curr->right;    \\n            }\\n        }    \\n        return inorder;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> nodes;\\n        inorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void inorder(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL) \\n            return;\\n        inorder(root->left, nodes);\\n        nodes.push_back(root->val);\\n        inorder(root->right, nodes);    \\n    }    \\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> inorder;\\n        if (root == NULL)\\n            return inorder;\\n        stack <TreeNode* > st;\\n        TreeNode* curr = root;\\n        while (true) {\\n            if (curr != NULL) {\\n                st.push(curr);\\n                curr = curr->left;\\n            } else {\\n                if (st.empty() == true)\\n                    break;\\n                curr = st.top();\\n                st.pop();\\n                inorder.push_back(curr->val);\\n                curr = curr->right;    \\n            }\\n        }    \\n        return inorder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070108,
                "title": "morris-inorder-traversal",
                "content": "My Python approach for Morris Inorder Traversal.\\nBased on [this](https://www.youtube.com/watch?v=80Zug6D1_r4) video.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        cur = root\\n        while cur != None:\\n            #printing the leftmost node\\n            if not cur.left:\\n                ans.append(cur.val)\\n                cur = cur.right\\n            else:\\n                temp = cur\\n                temp = temp.left\\n                #going to the rightmost node in the left subtree (lets call it temp)\\n                while temp.right and temp.right != cur:\\n                    temp = temp.right\\n                \\n                #2 conditions arise:\\n                \\n                #i. the right child of temp doesn\\'t exist (The thread to the cur node has not been made)\\n                #in this case, point the right child of temp to cur and move cur to its left child\\n                if not temp.right:\\n                    temp.right = cur\\n                    cur = cur.left\\n\\n                #ii. the thread has already been created so we break the thread\\n                #(pointing the temp\\'s right child back to None)and print cur.\\n                #Finally, move cur to its right child      \\n                else:\\n                    ans.append(cur.val)\\n                    temp.right = None\\n                    cur = cur.right\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        cur = root\\n        while cur != None:\\n            #printing the leftmost node\\n            if not cur.left:\\n                ans.append(cur.val)\\n                cur = cur.right\\n            else:\\n                temp = cur\\n                temp = temp.left\\n                #going to the rightmost node in the left subtree (lets call it temp)\\n                while temp.right and temp.right != cur:\\n                    temp = temp.right\\n                \\n                #2 conditions arise:\\n                \\n                #i. the right child of temp doesn\\'t exist (The thread to the cur node has not been made)\\n                #in this case, point the right child of temp to cur and move cur to its left child\\n                if not temp.right:\\n                    temp.right = cur\\n                    cur = cur.left\\n\\n                #ii. the thread has already been created so we break the thread\\n                #(pointing the temp\\'s right child back to None)and print cur.\\n                #Finally, move cur to its right child      \\n                else:\\n                    ans.append(cur.val)\\n                    temp.right = None\\n                    cur = cur.right\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550488,
                "title": "96-05-senior-developer-javascript-js-2022",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    let res = [];\\n    \\n    const fn = (node) => {\\n        if (!node) return;\\n        fn(node.left);  \\n        res.push(node.val)\\n        fn(node.right);\\n    }\\n    \\n    fn(root);\\n    \\n    return res;\\n    \\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function(root) {\\n    let res = [];\\n    \\n    const fn = (node) => {\\n        if (!node) return;\\n        fn(node.left);  \\n        res.push(node.val)\\n        fn(node.right);\\n    }\\n    \\n    fn(root);\\n    \\n    return res;\\n    \\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2549705,
                "title": "simplest-approach-c-9ms-iterative-inorder-traversal",
                "content": "Just move to the left most node and then go on pushing the node values. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void dfs(TreeNode* node){\\n        if(!node)\\n            return;\\n        dfs(node->left);\\n        ans.push_back(node->val);\\n        dfs(node->right);        \\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void dfs(TreeNode* node){\\n        if(!node)\\n            return;\\n        dfs(node->left);\\n        ans.push_back(node->val);\\n        dfs(node->right);        \\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546965,
                "title": "daily-leetcoding-challenge-september-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-inorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterating method using Stack\n\n  \n**Approach 3:** Morris Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-inorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2286560,
                "title": "3-approach-in-c-recursive-iterative-morris-traversal",
                "content": "**Recursive Approach:**\\n````\\n void inordert(TreeNode* root, vector<int>& ans)\\n    {\\n        if(root == NULL) return;\\n        inordert(root->left, ans);\\n        ans.push_back(root->val);\\n        inordert(root->right, ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inordert(root, ans);\\n        return ans;\\n    }\\n````\\n\\n-------------------------------------------------------------------------------------------------------\\n**Iterative Approach:**\\n````\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* node = root;\\n        stack<TreeNode*> st;\\n        while(true)\\n        {\\n            if(node != NULL)\\n            {\\n                st.push(node);\\n                node = node->left;\\n            }\\n            else\\n            {\\n                if(st.empty() == true) break;\\n                else\\n                {\\n                    node = st.top();\\n                    st.pop();\\n                    ans.push_back(node->val);\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n````\\n\\n-------------------------------------------------------------------------------------------------------\\n**Morris Traversal:**\\n````\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode *node = root;\\n        while(node != NULL)\\n        {\\n            if(node->left == NULL) \\n            {\\n                ans.push_back(node->val);\\n                node = node->right;\\n            }\\n            else\\n            {\\n                TreeNode *prev = node->left;\\n                while(prev->right && prev->right != node)\\n                {\\n                    prev = prev->right;\\n                }\\n                if(prev->right == NULL)\\n                {\\n                    prev->right = node;\\n                    node = node->left;\\n                }\\n                else\\n                {\\n                    prev->right = NULL;\\n                    ans.push_back(node->val);\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n````\\n\\n**One Request: Please do upvote if you found these approaches helpful, as it motivates me to post such useful content to help our leetcode community. Thanks in Advance!**",
                "solutionTags": [],
                "code": "````\\n void inordert(TreeNode* root, vector<int>& ans)\\n    {\\n        if(root == NULL) return;\\n        inordert(root->left, ans);\\n        ans.push_back(root->val);\\n        inordert(root->right, ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inordert(root, ans);\\n        return ans;\\n    }\\n```\n````\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* node = root;\\n        stack<TreeNode*> st;\\n        while(true)\\n        {\\n            if(node != NULL)\\n            {\\n                st.push(node);\\n                node = node->left;\\n            }\\n            else\\n            {\\n                if(st.empty() == true) break;\\n                else\\n                {\\n                    node = st.top();\\n                    st.pop();\\n                    ans.push_back(node->val);\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n````\\nvector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode *node = root;\\n        while(node != NULL)\\n        {\\n            if(node->left == NULL) \\n            {\\n                ans.push_back(node->val);\\n                node = node->right;\\n            }\\n            else\\n            {\\n                TreeNode *prev = node->left;\\n                while(prev->right && prev->right != node)\\n                {\\n                    prev = prev->right;\\n                }\\n                if(prev->right == NULL)\\n                {\\n                    prev->right = node;\\n                    node = node->left;\\n                }\\n                else\\n                {\\n                    prev->right = NULL;\\n                    ans.push_back(node->val);\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2248076,
                "title": "java-easy-standard-solution-0ms",
                "content": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n      \\n       ArrayList<Integer> ans = new ArrayList<Integer>();\\n      if(root == null) return ans; // base condition\\n      \\n      Stack<TreeNode> st = new Stack<>();\\n      \\n      TreeNode cur = root;\\n        while(cur != null || !st.isEmpty()) {\\n          while(cur != null) {\\n            st.add(cur);\\n            cur = cur.left;\\n          }\\n          cur = st.pop();\\n          ans.add(cur.val);\\n          cur = cur.right;\\n        }\\n      return ans;\\n    }\\n}\\n```\\n# KINDLY UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n      \\n       ArrayList<Integer> ans = new ArrayList<Integer>();\\n      if(root == null) return ans; // base condition\\n      \\n      Stack<TreeNode> st = new Stack<>();\\n      \\n      TreeNode cur = root;\\n        while(cur != null || !st.isEmpty()) {\\n          while(cur != null) {\\n            st.add(cur);\\n            cur = cur.left;\\n          }\\n          cur = st.pop();\\n          ans.add(cur.val);\\n          cur = cur.right;\\n        }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161133,
                "title": "python-simple-and-easy-solution-using-recursion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        #Approach - Using Recursion\\n        in_list=[]\\n        if not root:\\n            return\\n        if root.left:\\n            in_list+=self.inorderTraversal(root.left)\\n        in_list.append(root.val)\\n        if root.right:\\n            in_list+=self.inorderTraversal(root.right)\\n        return in_list\\n        \\n```\\n**Please Upvote if it was Helpful. :)**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        #Approach - Using Recursion\\n        in_list=[]\\n        if not root:\\n            return\\n        if root.left:\\n            in_list+=self.inorderTraversal(root.left)\\n        in_list.append(root.val)\\n        if root.right:\\n            in_list+=self.inorderTraversal(root.right)\\n        return in_list\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663643,
                "title": "c-iterative-and-recursive",
                "content": "Both recursive and iterative solutions use stack.\\nFor iterative solution it uses a user defined stack.\\n\\nIterative Solution\\n\\n1) Intitialize a stack.\\n2) While loop with OR conditions if stack is empty or node is null\\n3) First we traverse through all the left child. Push all the left child nodes in the stack to refer again.\\n4) If node is null, Pop the last element, print the value and visit its right child.\\n\\n```\\n\\t\\tstack <TreeNode*> S;\\n        vector <int> res;\\n        TreeNode* temp = root;\\n        \\n        while((!S.empty())||(temp != NULL)){\\n            if(temp != NULL){\\n                S.push(temp);\\n                temp = temp->left;                \\n            }\\n            else{\\n                temp = S.top();\\n                S.pop();\\n                res.push_back(temp->val);\\n                temp = temp->right;\\n            }\\n        }\\n        return res;        \\n```\\n\\n\\nIterative Solution\\n1) Visit and store All left child\\n2) Print the value\\n3) Visit all Right child\\n```\\n\\tvoid inorder(TreeNode* root,vector <int> &res){\\n        if(root){\\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n        }\\n        //return res\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> res;\\n        inorder(root,res);\\n        return res;\\n    }\\n```\\n\\nHope it helps!\\nPlease up vote.\\nFor more detailed explanation please refer https://www.techiedelight.com/inorder-tree-traversal-iterative-recursive/",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\t\\tstack <TreeNode*> S;\\n        vector <int> res;\\n        TreeNode* temp = root;\\n        \\n        while((!S.empty())||(temp != NULL)){\\n            if(temp != NULL){\\n                S.push(temp);\\n                temp = temp->left;                \\n            }\\n            else{\\n                temp = S.top();\\n                S.pop();\\n                res.push_back(temp->val);\\n                temp = temp->right;\\n            }\\n        }\\n        return res;        \\n```\n```\\n\\tvoid inorder(TreeNode* root,vector <int> &res){\\n        if(root){\\n        inorder(root->left,res);\\n        res.push_back(root->val);\\n        inorder(root->right,res);\\n        }\\n        //return res\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> res;\\n        inorder(root,res);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1570071,
                "title": "recursion-time-complexity-space-complexity-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> nodeVec;\\n        doTraversal(nodeVec,root);\\n        return nodeVec;\\n    }\\n\\t\\n    void doTraversal(vector<int> &nodeVec, TreeNode* temp)\\n    {\\n        if(temp==nullptr)\\n            return;\\n        doTraversal(nodeVec,temp->left);\\n        nodeVec.push_back(temp->val);\\n        doTraversal(nodeVec,temp->right);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector <int> nodeVec;\\n        doTraversal(nodeVec,root);\\n        return nodeVec;\\n    }\\n\\t\\n    void doTraversal(vector<int> &nodeVec, TreeNode* temp)\\n    {\\n        if(temp==nullptr)\\n            return;\\n        doTraversal(nodeVec,temp->left);\\n        nodeVec.push_back(temp->val);\\n        doTraversal(nodeVec,temp->right);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540039,
                "title": "c-inorder-preorder-postorder-all-3-solution-0ms-faster-than-100",
                "content": "You can observe there is just a minimal diffrence in all 3 ,i.e, it\\'s just the way of filling vector while calling fill function.  \\n***Inorder Traversal :*** \\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        ans.push_back(root->val);  // Inorder\\n        fill(root->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Preorder Traversal :***\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        ans.push_back(root->val);  // Preoder\\n        fill(root->left);\\n        fill(root->right);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Postorder Traversal :***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        fill(root->right);\\n        ans.push_back(root->val);  /// Postorder\\n    }\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\nHope you liked it , kindly upvote !!\\n\\nHappy Coding \\uD83E\\uDD17",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        ans.push_back(root->val);  // Inorder\\n        fill(root->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        ans.push_back(root->val);  // Preoder\\n        fill(root->left);\\n        fill(root->right);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        fill(root->right);\\n        ans.push_back(root->val);  /// Postorder\\n    }\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907247,
                "title": "simple-javascript-solution-recursive",
                "content": "Simple Javascript solution using spread operator:\\n\\n```javascript \\nvar inorderTraversal = function(root) {\\n    if (!root) {\\n      return [];\\n    }\\n    let left = inorderTraversal(root.left);\\n    let mid = root.val;\\n    let right = inorderTraversal(root.right);\\n    return [...left, mid, ...right];\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```javascript \\nvar inorderTraversal = function(root) {\\n    if (!root) {\\n      return [];\\n    }\\n    let left = inorderTraversal(root.left);\\n    let mid = root.val;\\n    let right = inorderTraversal(root.right);\\n    return [...left, mid, ...right];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 600732,
                "title": "javascript-iterative-solution-stack-93-56",
                "content": "Very simpe iterative solution which uses stack.\\n\\nRuntime: 48 ms, faster than 93.31% of JavaScript online submissions for Binary Tree Inorder Traversal.\\nMemory Usage: 33.8 MB, less than 56.25% of JavaScript online submissions for Binary Tree Inorder Traversal.\\n\\n```\\nfunction inorderTraversal(root) {\\n  const stack = [], ret = [];\\n  root && stack.push(root);\\n  while (stack.length) {\\n    const item = stack.pop();\\n    if (item.left) {\\n      stack.push(item);\\n      stack.push(item.left);\\n      item.left = null;\\n    }\\n    else {\\n      ret.push(item.val);\\n      item.right && stack.push(item.right);\\n    }\\n  }\\n  return ret;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nfunction inorderTraversal(root) {\\n  const stack = [], ret = [];\\n  root && stack.push(root);\\n  while (stack.length) {\\n    const item = stack.pop();\\n    if (item.left) {\\n      stack.push(item);\\n      stack.push(item.left);\\n      item.left = null;\\n    }\\n    else {\\n      ret.push(item.val);\\n      item.right && stack.push(item.right);\\n    }\\n  }\\n  return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516768,
                "title": "c-iterative-lnr-using-stack",
                "content": "```\\npublic class Solution {\\n    public IList<int> InorderTraversal(TreeNode root) {\\n        List<int> result = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        while (stack.Count != 0 || root != null) {\\n            if (root != null) {\\n                stack.Push(root);\\n                root = root.left;\\n            } else {\\n                root = stack.Pop();\\n                result.Add(root.val);\\n                root = root.right;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> InorderTraversal(TreeNode root) {\\n        List<int> result = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        while (stack.Count != 0 || root != null) {\\n            if (root != null) {\\n                stack.Push(root);\\n                root = root.left;\\n            } else {\\n                root = stack.Pop();\\n                result.Add(root.val);\\n                root = root.right;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458464,
                "title": "python-simple-iterative-and-recursive-solutions-98-faster-100-less-memory",
                "content": "```\\n\\n#recursive\\nclass Solution:\\n    def __init__(self):\\n        self.return_list = []\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        \\n        if root:\\n            self.inorderTraversal(root.left)\\n            \\n            self.return_list.append(root.val)\\n            \\n            self.inorderTraversal(root.right)\\n            \\n        return self.return_list\\n```\\n```\\n#ITERATIVE\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:        \\n        return_list = []\\n        stack = []\\n        node = root\\n        \\n        while True:\\n            \\n            if node is not None:\\n                stack.append(node)\\n                node = node.left\\n                \\n            elif(stack):\\n                node = stack.pop()\\n                return_list.append(node.val)\\n                node = node.right\\n            else:\\n                break\\n        return return_list",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\n#recursive\\nclass Solution:\\n    def __init__(self):\\n        self.return_list = []\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        \\n        if root:\\n            self.inorderTraversal(root.left)\\n            \\n            self.return_list.append(root.val)\\n            \\n            self.inorderTraversal(root.right)\\n            \\n        return self.return_list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455535,
                "title": "javascript-1-line-solution",
                "content": "```js\\nconst inorderTraversal = root => root ? [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)] : [];",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst inorderTraversal = root => root ? [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)] : [];",
                "codeTag": "Unknown"
            },
            {
                "id": 180116,
                "title": "javascript",
                "content": "```\\nvar inorderTraversal = function(root) {\\n    let result = [];\\n    dfs(root);\\n    \\n    function dfs(root) {\\n        if(root != null) {\\n            dfs(root.left);\\n            result.push(root.val);\\n            dfs(root.right);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar inorderTraversal = function(root) {\\n    let result = [];\\n    dfs(root);\\n    \\n    function dfs(root) {\\n        if(root != null) {\\n            dfs(root.left);\\n            result.push(root.val);\\n            dfs(root.right);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166659,
                "title": "javascript-100-iterative-and-recursive",
                "content": "Recursive:\\n\\n```js\\nconst inorderTraversal = root => {\\n  if (!root) return [];\\n  \\n  return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n};\\n```\\n\\nIterative (using a stack):\\n```js\\nconst inorderTraversal = root => {\\n  const traversed = [];\\n  \\n  if (!root) {\\n    return traversed;\\n  }\\n  \\n  const nodes = [root];\\n  let currentNode = root.left;\\n  \\n  while (currentNode || nodes.length) {\\n    while (currentNode) {\\n      nodes.push(currentNode);\\n      currentNode = currentNode.left;\\n    }\\n    \\n    currentNode = nodes.pop();\\n    traversed.push(currentNode.val);\\n    currentNode = currentNode.right;\\n  }\\n  \\n  return traversed;\\n}\\n```\\n\\nBoth have 52ms runtime.",
                "solutionTags": [],
                "code": "```js\\nconst inorderTraversal = root => {\\n  if (!root) return [];\\n  \\n  return [...inorderTraversal(root.left), root.val, ...inorderTraversal(root.right)]\\n};\\n```\n```js\\nconst inorderTraversal = root => {\\n  const traversed = [];\\n  \\n  if (!root) {\\n    return traversed;\\n  }\\n  \\n  const nodes = [root];\\n  let currentNode = root.left;\\n  \\n  while (currentNode || nodes.length) {\\n    while (currentNode) {\\n      nodes.push(currentNode);\\n      currentNode = currentNode.left;\\n    }\\n    \\n    currentNode = nodes.pop();\\n    traversed.push(currentNode.val);\\n    currentNode = currentNode.right;\\n  }\\n  \\n  return traversed;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 152061,
                "title": "recursive-and-iterative-approaches-using-ruby",
                "content": "### Recursive approach\\n```ruby\\ndef inorder_traversal_recursive(root)\\n  response = []\\n  traverse(root, response)\\n  return response\\nend\\n\\ndef traverse(node, response)\\n  return if node.nil?\\n  \\n  traverse(node.left, response) if node.left\\n  response << node.val\\n  traverse(node.right, response) if node.right\\nend\\n```\\n\\n### Iterative approach\\n```ruby\\ndef inorder_traversal(root)\\n  curr = root\\n  stack, res = [], []\\n  \\n  while !(curr.nil? and stack.empty?)\\n    while curr\\n      stack.push(curr)\\n      curr = curr.left\\n    end\\n    curr = stack.pop\\n    res << curr.val\\n    curr = curr.right\\n  end\\n  \\n  return res\\nend\\n````\\n",
                "solutionTags": [],
                "code": "```ruby\\ndef inorder_traversal_recursive(root)\\n  response = []\\n  traverse(root, response)\\n  return response\\nend\\n\\ndef traverse(node, response)\\n  return if node.nil?\\n  \\n  traverse(node.left, response) if node.left\\n  response << node.val\\n  traverse(node.right, response) if node.right\\nend\\n```\n```ruby\\ndef inorder_traversal(root)\\n  curr = root\\n  stack, res = [], []\\n  \\n  while !(curr.nil? and stack.empty?)\\n    while curr\\n      stack.push(curr)\\n      curr = curr.left\\n    end\\n    curr = stack.pop\\n    res << curr.val\\n    curr = curr.right\\n  end\\n  \\n  return res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 31378,
                "title": "share-my-c-solution-very-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode* root) {\\n            vector<int> ret;\\n            stack<TreeNode *> s;\\n            TreeNode *temp = root;\\n            \\n            while (!s.empty() || temp != NULL)\\n            {\\n                while (temp != NULL)\\n                {\\n                    s.push(temp);\\n                    temp = temp->left;\\n                }\\n                \\n                temp = s.top();\\n                ret.push_back(temp->val);\\n                s.pop();\\n                temp = temp->right;\\n            }\\n            \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> inorderTraversal(TreeNode* root) {\\n            vector<int> ret;\\n            stack<TreeNode *> s;\\n            TreeNode *temp = root;\\n            \\n            while (!s.empty() || temp != NULL)\\n            {\\n                while (temp != NULL)\\n                {\\n                    s.push(temp);\\n                    temp = temp->left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3509959,
                "title": "python-easy-recursive-iterative-both-solutions",
                "content": "**Iterative Solution:**\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return\\n        t=root\\n        a=[]\\n        ans=[]\\n        while True:\\n            if t:\\n                a.append(t)\\n                t=t.left\\n            else:\\n                if len(a)==0:\\n                    break\\n                t=a.pop()\\n                ans.append(t.val)\\n                t=t.right \\n        return ans\\n```\\n**Recursive Solution:**\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.ans=[]\\n        self.Traversal(root)\\n        return self.ans\\n    def Traversal(self,root):\\n        if root is None:\\n            return\\n        self.Traversal(root.left)\\n        self.ans.append(root.val)\\n        self.Traversal(root.right)\\n```\\n**An  upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return\\n        t=root\\n        a=[]\\n        ans=[]\\n        while True:\\n            if t:\\n                a.append(t)\\n                t=t.left\\n            else:\\n                if len(a)==0:\\n                    break\\n                t=a.pop()\\n                ans.append(t.val)\\n                t=t.right \\n        return ans\\n```\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.ans=[]\\n        self.Traversal(root)\\n        return self.ans\\n    def Traversal(self,root):\\n        if root is None:\\n            return\\n        self.Traversal(root.left)\\n        self.ans.append(root.val)\\n        self.Traversal(root.right)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3408869,
                "title": "very-easy-o-n-intutive-recursive-code-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nVery Easy and understandable c++ code\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root,vector<int>&v){\\n        if(!root)\\n        return;\\n\\n        solve(root->left,v);\\n        v.push_back(root->val);\\n        solve(root->right,v);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        \\n        solve(root,v);\\n        return v;\\n        \\n    }\\n};         \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root,vector<int>&v){\\n        if(!root)\\n        return;\\n\\n        solve(root->left,v);\\n        v.push_back(root->val);\\n        solve(root->right,v);\\n    }\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        \\n        solve(root,v);\\n        return v;\\n        \\n    }\\n};         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399456,
                "title": "simple-go-solution",
                "content": "\\n```\\n\\nfunc inorderTraversal(root *TreeNode) []int {\\n\\tres := make([]int, 0, 101)\\n\\tif root != nil {\\n\\t\\tres = help(root, res)\\n\\t}\\n\\t\\n\\treturn res\\n}\\n\\nfunc help(root *TreeNode, res []int) []int {\\n\\tif root.Left != nil {\\n\\t\\tres = help(root.Left, res)\\n\\t}\\n\\tres = append(res, root.Val)\\n\\tif root.Right != nil {\\n\\t\\tres = help(root.Right, res)\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc inorderTraversal(root *TreeNode) []int {\\n\\tres := make([]int, 0, 101)\\n\\tif root != nil {\\n\\t\\tres = help(root, res)\\n\\t}\\n\\t\\n\\treturn res\\n}\\n\\nfunc help(root *TreeNode, res []int) []int {\\n\\tif root.Left != nil {\\n\\t\\tres = help(root.Left, res)\\n\\t}\\n\\tres = append(res, root.Val)\\n\\tif root.Right != nil {\\n\\t\\tres = help(root.Right, res)\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203062,
                "title": "java-easy-iterative-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root==null)  return list;\\n        TreeNode curr = root;\\n        Stack<TreeNode> st = new Stack<>();\\n        while(!st.isEmpty() || curr!=null){\\n            while(curr!=null){\\n                st.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = st.pop();\\n            list.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root==null)  return list;\\n        TreeNode curr = root;\\n        Stack<TreeNode> st = new Stack<>();\\n        while(!st.isEmpty() || curr!=null){\\n            while(curr!=null){\\n                st.push(curr);\\n                curr = curr.left;\\n            }\\n            curr = st.pop();\\n            list.add(curr.val);\\n            curr = curr.right;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195780,
                "title": "python-4-solutions-dfs-bfs-morris-1-morris-2",
                "content": "# Approach 1: DFS.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            yield from chain(inorder(root.left), (root,), inorder(root.right)) if root else tuple()\\n        \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\\n\\n---\\n\\n# Approach 2: BFS.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            stack = [root] if root else []\\n            \\n            while stack:\\n                node = stack.pop()\\n                if not node.left and not node.right: yield node; continue\\n                \\n                if node.right: stack.append(node.right)\\n                stack.append(TreeNode(node.val))\\n                if node.left: stack.append(node.left)\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\\n\\n---\\n\\n# Approach 3: Morris traversal. (Destroys the tree.)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys the tree)\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            node = root\\n            while node:\\n                if node.left:\\n                    last = node.left\\n                    while last.right: last = last.right\\n                    \\n                    last.right = node\\n                    node = node.left\\n                    last.right.left = None\\n                else:\\n                    yield node\\n                    node = node.right\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\\n\\n---\\n\\n# Approach 4: Morris traversal. (Destroys and recovers the tree.)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys and recovers the tree)\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            node = root\\n            while node:\\n                if node.left:\\n                    last = node.left\\n                    while last.right and last.right != node:\\n                        last = last.right\\n                    \\n                    if last.right:\\n                        last.right = None\\n                        yield node\\n                        node = node.right\\n                    else:\\n                        last.right = node\\n                        node = node.left\\n                else:\\n                    yield node\\n                    node = node.right\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            yield from chain(inorder(root.left), (root,), inorder(root.right)) if root else tuple()\\n        \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            stack = [root] if root else []\\n            \\n            while stack:\\n                node = stack.pop()\\n                if not node.left and not node.right: yield node; continue\\n                \\n                if node.right: stack.append(node.right)\\n                stack.append(TreeNode(node.val))\\n                if node.left: stack.append(node.left)\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys the tree)\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            node = root\\n            while node:\\n                if node.left:\\n                    last = node.left\\n                    while last.right: last = last.right\\n                    \\n                    last.right = node\\n                    node = node.left\\n                    last.right.left = None\\n                else:\\n                    yield node\\n                    node = node.right\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```\n```python\\nclass Solution:\\n    def inorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys and recovers the tree)\\n        def inorder(root: TreeNode | None) -> Iterator[TreeNode]:\\n            node = root\\n            while node:\\n                if node.left:\\n                    last = node.left\\n                    while last.right and last.right != node:\\n                        last = last.right\\n                    \\n                    if last.right:\\n                        last.right = None\\n                        yield node\\n                        node = node.right\\n                    else:\\n                        last.right = node\\n                        node = node.left\\n                else:\\n                    yield node\\n                    node = node.right\\n                \\n        return [node.val for node in inorder(root_)]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087159,
                "title": "java-recursive-way-easy-solution-with-comments",
                "content": "# Approach\\nUsing recursive way, travsere the tree and keep adding the value to the list. Another way is by using the stack\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution \\n{\\n    //creating an instance\\n    List<Integer> list = new ArrayList<Integer>();\\n\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        //if empty tree\\n        if(root == null)\\n            return list;\\n\\n        TreeNode ptr = root;\\n\\n        traversal(ptr);\\n\\n        return list;\\n    }\\n\\n    //inorder traversal\\n    public void traversal (TreeNode root)\\n    {\\n        //return on reaching end\\n        if(root == null)\\n            return;\\n\\n        // recur on the left node\\n        traversal(root.left);\\n\\n        //get the data of the node\\n        list.add(root.val);\\n\\n        //now recur on the right node\\n        traversal(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution \\n{\\n    //creating an instance\\n    List<Integer> list = new ArrayList<Integer>();\\n\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        //if empty tree\\n        if(root == null)\\n            return list;\\n\\n        TreeNode ptr = root;\\n\\n        traversal(ptr);\\n\\n        return list;\\n    }\\n\\n    //inorder traversal\\n    public void traversal (TreeNode root)\\n    {\\n        //return on reaching end\\n        if(root == null)\\n            return;\\n\\n        // recur on the left node\\n        traversal(root.left);\\n\\n        //get the data of the node\\n        list.add(root.val);\\n\\n        //now recur on the right node\\n        traversal(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026386,
                "title": "beats-100-3-methods-morris-iterative-recursion-c-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Using simple recursion.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) (recursive call stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void inorderHelper(TreeNode* root, vector<int>& ans){\\n        if(root==NULL)return;\\n        inorderHelper(root->left,ans); \\n        ans.push_back(root->val);\\n        inorderHelper(root->right,ans);      \\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inorderHelper(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n---\\n# Method #2 : Morris Traversal\\n\\n# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf current does not have left child\\n\\n    a. Add current\\u2019s value\\n\\n    b. Go to the right, i.e., current = current.right\\n\\nElse\\n\\n    a. In current\\'s left subtree, make current the right child of the rightmost node\\n\\n    b. Go to this left child, i.e., current = current.left\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode* curNode = root;\\n        vector<int> nodes;\\n        \\n        while (curNode != NULL) \\n        {\\n            if (curNode -> left) \\n            {\\n\\t\\t\\t\\t//Find the inorder predecessor of current\\n               //ifa) Make current as right child of the rightmost node in current\\'s left subtree\\n                TreeNode* predecessor = curNode -> left;\\n                while (predecessor -> right && predecessor -> right != curNode) //second condition used when reverting\\n                    predecessor = predecessor -> right;\\n                \\n                if ((predecessor -> right)==NULL) \\n                {\\n                    predecessor -> right = curNode;\\n                    curNode = curNode -> left; //ifb) Go to this left child\\n                }\\n                else \\n                {\\n                    //Revert back the changes\\n                    predecessor -> right = NULL;\\n                    nodes.push_back(curNode -> val);\\n                    curNode = curNode -> right;\\n                }\\n            }\\n            else \\n            {\\n                nodes.push_back(curNode -> val);  //ea)\\n                curNode = curNode -> right;  //eb)\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n};\\n```\\n---\\n# Method #3 : Iterative(Important)\\n\\n# Intution \\n- we\\'ll use a stack for that , to store addresses of elements and there state.\\n- state 0 = inorder(root->left);\\n- state 1 = cout<<data;\\n- state 2 = inorder(root->right);\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) (stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<pair<TreeNode*,int>> st;\\n        vector<int> v;\\n        if(root == NULL) return {};\\n        st.push({root,0});\\n        while(!st.empty()){\\n            TreeNode* cur = st.top().first;\\n            int state = st.top().second;\\n            st.pop();\\n            \\n            if(cur == NULL){\\n                continue;\\n            }\\n            if(state == 0){\\n                st.push({cur,1});\\n                st.push({cur->left,0});\\n            }else if(state == 1){\\n                v.push_back(cur->val);\\n                st.push({cur,2});\\n            }else{\\n                st.push({cur->right,0});\\n            }\\n        }\\n        return v;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void inorderHelper(TreeNode* root, vector<int>& ans){\\n        if(root==NULL)return;\\n        inorderHelper(root->left,ans); \\n        ans.push_back(root->val);\\n        inorderHelper(root->right,ans);      \\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        inorderHelper(root,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        TreeNode* curNode = root;\\n        vector<int> nodes;\\n        \\n        while (curNode != NULL) \\n        {\\n            if (curNode -> left) \\n            {\\n\\t\\t\\t\\t//Find the inorder predecessor of current\\n               //ifa) Make current as right child of the rightmost node in current\\'s left subtree\\n                TreeNode* predecessor = curNode -> left;\\n                while (predecessor -> right && predecessor -> right != curNode) //second condition used when reverting\\n                    predecessor = predecessor -> right;\\n                \\n                if ((predecessor -> right)==NULL) \\n                {\\n                    predecessor -> right = curNode;\\n                    curNode = curNode -> left; //ifb) Go to this left child\\n                }\\n                else \\n                {\\n                    //Revert back the changes\\n                    predecessor -> right = NULL;\\n                    nodes.push_back(curNode -> val);\\n                    curNode = curNode -> right;\\n                }\\n            }\\n            else \\n            {\\n                nodes.push_back(curNode -> val);  //ea)\\n                curNode = curNode -> right;  //eb)\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<pair<TreeNode*,int>> st;\\n        vector<int> v;\\n        if(root == NULL) return {};\\n        st.push({root,0});\\n        while(!st.empty()){\\n            TreeNode* cur = st.top().first;\\n            int state = st.top().second;\\n            st.pop();\\n            \\n            if(cur == NULL){\\n                continue;\\n            }\\n            if(state == 0){\\n                st.push({cur,1});\\n                st.push({cur->left,0});\\n            }else if(state == 1){\\n                v.push_back(cur->val);\\n                st.push({cur,2});\\n            }else{\\n                st.push({cur->right,0});\\n            }\\n        }\\n        return v;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024178,
                "title": "94-fast-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ll=[]\\n        def tr(root):\\n            if root==None:\\n                return \\n            \\n            tr(root.left)\\n            ll.append(root.val)\\n            tr(root.right)\\n            return ll\\n        return tr(root)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ll=[]\\n        def tr(root):\\n            if root==None:\\n                return \\n            \\n            tr(root.left)\\n            ll.append(root.val)\\n            tr(root.right)\\n            return ll\\n        return tr(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006595,
                "title": "beats-100-golang",
                "content": "\\n\\n# Code\\n```\\nfunc inorderTraversal(root *TreeNode) []int {\\n\\tif root == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tvar values []int\\n\\tvalues = append(values, inorderTraversal(root.Left)...)\\n\\tvalues = append(values, root.Val)\\n\\tvalues = append(values, inorderTraversal(root.Right)...)\\n\\n\\treturn values\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc inorderTraversal(root *TreeNode) []int {\\n\\tif root == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tvar values []int\\n\\tvalues = append(values, inorderTraversal(root.Left)...)\\n\\tvalues = append(values, root.Val)\\n\\tvalues = append(values, inorderTraversal(root.Right)...)\\n\\n\\treturn values\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2927089,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void f(TreeNode* root, vector<int> &ans)\\n    {\\n        if(root==NULL)\\n            return;\\n        f(root->left, ans);\\n        ans.push_back(root->val);\\n        f(root->right, ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void f(TreeNode* root, vector<int> &ans)\\n    {\\n        if(root==NULL)\\n            return;\\n        f(root->left, ans);\\n        ans.push_back(root->val);\\n        f(root->right, ans);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765181,
                "title": "c-traversal",
                "content": "```\\npublic:\\n    bool is_same(TreeNode *root1, TreeNode *root2){\\n        if(!root1 && !root2) return true;\\n        if((!root1 && root2) || (root1 && !root2)) return false;\\n        \\n        if(root1->val == root2->val) return is_same(root1->left , root2->right) && is_same(root1->right , root2->left);\\n        else return false;\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        return is_same(root->left, root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    bool is_same(TreeNode *root1, TreeNode *root2){\\n        if(!root1 && !root2) return true;\\n        if((!root1 && root2) || (root1 && !root2)) return false;\\n        \\n        if(root1->val == root2->val) return is_same(root1->left , root2->right) && is_same(root1->right , root2->left);\\n        else return false;\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        return is_same(root->left, root->right);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2628733,
                "title": "typescript-javascript-solution-that-doesn-t-push-arrays-around",
                "content": "If you simply use an array outer to the function, subsequent test cases will fail, because Leetcode will run your function repeatedly but won\\'t clear the array. So the array needs to be cleared on the first invocation of the function, but the function is called recursively, so you don\\'t know when the first invocation is.\\nOne solution would be to return the arrays of numbers and concatenate them, but that needlessly moved data in the stack.\\nA faster solution is to use a closure, and initialize the array in it.\\n```\\nfunction inorderTraversal(root: TreeNode | null): number[] {\\n    const result = [];\\n    function traverse(root: TreeNode | null): number[] {\\n        if (root) {\\n            traverse(root.left);\\n            result.push(root.val);\\n            traverse(root.right);\\n        }\\n        return result;\\n    }\\n    return traverse(root);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction inorderTraversal(root: TreeNode | null): number[] {\\n    const result = [];\\n    function traverse(root: TreeNode | null): number[] {\\n        if (root) {\\n            traverse(root.left);\\n            result.push(root.val);\\n            traverse(root.right);\\n        }\\n        return result;\\n    }\\n    return traverse(root);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2564385,
                "title": "python-all-in-one-morris-with-notes-iterative-recursive-solutions",
                "content": "**Morris Traversal**\\nEven Recursive takes Auxiliary stack space so Time O(n) and sapce O(n) , But Morris takes O(n) and O(1)\\nMorris Uses treaded BT (Contains predecessor and successor information in NULL pointers)\\n**Algorithm Cases:**\\n\\t1. If left null, print curr and move right\\n\\t2. before going left, make right most node on left subtree connected to current node, then go left\\n\\t3. if thread is already pointed to current node, then remove the thread\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tres = []\\n\\t\\t\\tcurr = root\\n\\n\\t\\t\\twhile curr:\\n\\t\\t\\t\\t# If left null, print curr and move right\\n\\t\\t\\t\\tif not curr.left:\\n\\t\\t\\t\\t\\tres.append(curr.val)\\n\\t\\t\\t\\t\\tcurr = curr.right\\n\\t\\t\\t\\t# before going left, make right most node on left subtree connected to current node, then go left\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tprev = curr.left\\n\\t\\t\\t\\t\\twhile prev.right and prev.right!=curr:\\n\\t\\t\\t\\t\\t\\tprev = prev.right\\n\\t\\t\\t\\t\\t# make thread\\n\\t\\t\\t\\t\\tif not prev.right:\\n\\t\\t\\t\\t\\t\\tprev.right = curr\\n\\t\\t\\t\\t\\t\\tcurr = curr.left\\n\\t\\t\\t\\t\\t# if thread is already pointed to current node, means You have visited the node, cut the thread, print the root and  move to the right\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tprev.right = None\\n\\t\\t\\t\\t\\t\\tres.append(curr.val)\\n\\t\\t\\t\\t\\t\\tcurr = curr.right\\n\\t\\t\\treturn res\\n```\\n\\n**Iterative**\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tstack, res = [], []      \\n        while True:\\n            while root:\\n                stack.append(root)\\n                root=root.left\\n            if not stack: return res\\n            node = stack.pop()\\n            res.append(node.val)\\n            root=node.right\\n```\\n**Recursive**\\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\treturn self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right) if root else []\\n```\\n\\n**PLEASE UPVOTE IF YOU LIKED!**\\n",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tres = []\\n\\t\\t\\tcurr = root\\n\\n\\t\\t\\twhile curr:\\n\\t\\t\\t\\t# If left null, print curr and move right\\n\\t\\t\\t\\tif not curr.left:\\n\\t\\t\\t\\t\\tres.append(curr.val)\\n\\t\\t\\t\\t\\tcurr = curr.right\\n\\t\\t\\t\\t# before going left, make right most node on left subtree connected to current node, then go left\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tprev = curr.left\\n\\t\\t\\t\\t\\twhile prev.right and prev.right!=curr:\\n\\t\\t\\t\\t\\t\\tprev = prev.right\\n\\t\\t\\t\\t\\t# make thread\\n\\t\\t\\t\\t\\tif not prev.right:\\n\\t\\t\\t\\t\\t\\tprev.right = curr\\n\\t\\t\\t\\t\\t\\tcurr = curr.left\\n\\t\\t\\t\\t\\t# if thread is already pointed to current node, means You have visited the node, cut the thread, print the root and  move to the right\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tprev.right = None\\n\\t\\t\\t\\t\\t\\tres.append(curr.val)\\n\\t\\t\\t\\t\\t\\tcurr = curr.right\\n\\t\\t\\treturn res\\n```\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\tstack, res = [], []      \\n        while True:\\n            while root:\\n                stack.append(root)\\n                root=root.left\\n            if not stack: return res\\n            node = stack.pop()\\n            res.append(node.val)\\n            root=node.right\\n```\n```\\ndef inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\treturn self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2547396,
                "title": "c-0ms-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n**TC** = O(N)\\n\\t\\n\\tvoid solve(TreeNode *root, vector<int>&v){\\n        if(!root) return;\\n        \\n        solve(root->left,v);         //root->left\\n        v.push_back(root->val);      //store root->val\\n        solve(root->right,v);        //root->right\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        solve(root,v);\\n        return v;\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n**TC** = O(N)\\n\\t\\n\\tvoid solve(TreeNode *root, vector<int>&v){\\n        if(!root) return;\\n        \\n        solve(root->left,v);         //root->left\\n        v.push_back(root->val);      //store root->val\\n        solve(root->right,v);        //root->right\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        solve(root,v);\\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2229713,
                "title": "c-solution-faster-than-100-solutions-currently",
                "content": "**The below code is faster than 100% of the solutions currently on LeetCode. Happy Leetcoding !!\\nDo Upvote \\u270C\\uD83C\\uDFFB**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> inorder (TreeNode* root,vector<int>&v)\\n    {\\n       if(root!=NULL)\\n       {\\n            inorder(root->left,v);\\n            v.push_back(root->val);\\n            inorder(root->right,v);\\n       }\\n        return v;\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        \\n        inorder(root,v);\\n        \\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Tree",
                    "Recursion",
                    "Binary Tree",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> inorder (TreeNode* root,vector<int>&v)\\n    {\\n       if(root!=NULL)\\n       {\\n            inorder(root->left,v);\\n            v.push_back(root->val);\\n            inorder(root->right,v);\\n       }\\n        return v;\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        \\n        inorder(root,v);\\n        \\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147819,
                "title": "two-lines-solution-in-kotlin",
                "content": "Simple solution using recursion in Kotlin\\n\\n```\\nclass Solution {\\n    \\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n       root ?: return listOf<Int>()\\n       return  inorderTraversal(root.left) + listOf(root.`val`) + inorderTraversal(root.right)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    \\n    fun inorderTraversal(root: TreeNode?): List<Int> {\\n       root ?: return listOf<Int>()\\n       return  inorderTraversal(root.left) + listOf(root.`val`) + inorderTraversal(root.right)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050074,
                "title": "python-100-easy-solution",
                "content": "\\n\\tresult = []\\n        return self.dfs(root, result)\\n    \\n    def dfs(self, node, res):\\n        if node is not None:\\n            self.dfs(node.left, res)\\n            res.append(node.val)\\n            self.dfs(node.right, res)\\n        return res",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "\\n\\tresult = []\\n        return self.dfs(root, result)\\n    \\n    def dfs(self, node, res):\\n        if node is not None:\\n            self.dfs(node.left, res)\\n            res.append(node.val)\\n            self.dfs(node.right, res)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1978409,
                "title": "c-iterative-solution-stack-with-comments",
                "content": "```\\nclass Solution {\\n\\t// Inorder - Left Subtree -> Root -> Right Subtree\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        vector<int> ans;\\n        \\n\\t\\t// 1. Make root as the starting node, that is currNode\\n        TreeNode* currNode = root;\\n        while (currNode or !st.empty()) {\\n\\t\\t// 2. Now add all the left subtree nodes to the stack\\n            while (currNode) {\\n                st.push(currNode);\\n                currNode = currNode->left;\\n            }   \\n        // 3. Pick out the top node, put it in answer array\\n            currNode = st.top();\\n            st.pop();\\n            \\n            ans.push_back(currNode->val);\\n\\t\\t// 4. Update currNode as below, this will take care of the right subtree\\n            currNode = currNode->right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n\\t// Inorder - Left Subtree -> Root -> Right Subtree\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        vector<int> ans;\\n        \\n\\t\\t// 1. Make root as the starting node, that is currNode\\n        TreeNode* currNode = root;\\n        while (currNode or !st.empty()) {\\n\\t\\t// 2. Now add all the left subtree nodes to the stack\\n            while (currNode) {\\n                st.push(currNode);\\n                currNode = currNode->left;\\n            }   \\n        // 3. Pick out the top node, put it in answer array\\n            currNode = st.top();\\n            st.pop();\\n            \\n            ans.push_back(currNode->val);\\n\\t\\t// 4. Update currNode as below, this will take care of the right subtree\\n            currNode = currNode->right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958957,
                "title": "scala-solution",
                "content": "```\\nobject Solution {\\n    def inorderTraversal(root: TreeNode): List[Int] = {\\n        if(root == null) List()\\n        else inorderTraversal(root.left) ++ List(root.value) ++ inorderTraversal(root.right)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def inorderTraversal(root: TreeNode): List[Int] = {\\n        if(root == null) List()\\n        else inorderTraversal(root.left) ++ List(root.value) ++ inorderTraversal(root.right)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1777345,
                "title": "python-solution-iterative-recursive-easy-to-understand",
                "content": "```python\\n# Recursive and Iterative Solutions to inOrder, preOrder, and postOrder traversal\\n# ------------------------------------------- recursive\\n# recursive\\ndef BSTTraversal(root):\\n    res = []\\n    def inOrder(root):\\n        if root:\\n            inOrder(root.left)\\n            res.append(root.val)\\n            inOrder(root.right)\\n    \\n    def preOrder(root):\\n        if root:\\n            res.append(root.val)\\n            inOrder(root.left)\\n            inOrder(root.right)\\n    \\n    def postOrder(root):\\n        if root:\\n            inOrder(root.left)\\n            inOrder(root.right)\\n            res.append(root.val)\\n    \\n    inOrder(root)\\n    return res\\n\\n# one-liner recursive\\ndef traverse(root):\\n    return self.postorderTraversal(root.left)+self.postorderTraversal(root.right)+[root.val] if root else [] #post order\\n    # return self.postorderTraversal(root.left)+[root.val]+self.postorderTraversal(root.right) if root else [] #in order\\n    # return [root.val]+self.postorderTraversal(root.left)+self.postorderTraversal(root.right) if root else [] #pre order\\n\\n# ------------------------------------------- Iterative\\ndef inorderTraversal(self, root):\\n    stack, result = [], []   \\n    curr = root\\n    while curr or stack:\\n        while curr:\\n            stack.append(curr)\\n            curr = curr.left\\n        node = stack.pop()\\n        result.append(node.val)\\n        curr = node.right\\n        \\n    return result\\n\\ndef preorderTraversal(self, root):\\n    stack, result = [root], []   \\n    while stack:\\n        curr = stack.pop()\\n        if curr:\\n            result.append(curr.val)\\n            stack.append(curr.right)\\n            stack.append(curr.left)\\n        \\n    return result\\n\\ndef postorderTraversal(root):\\n    stack, result = [root], []   \\n    while stack:\\n        curr = stack.pop()\\n        if curr:\\n            result.append(curr.val)\\n            stack.append(curr.left)\\n            stack.append(curr.right)\\n    return result[::-1]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```python\\n# Recursive and Iterative Solutions to inOrder, preOrder, and postOrder traversal\\n# ------------------------------------------- recursive\\n# recursive\\ndef BSTTraversal(root):\\n    res = []\\n    def inOrder(root):\\n        if root:\\n            inOrder(root.left)\\n            res.append(root.val)\\n            inOrder(root.right)\\n    \\n    def preOrder(root):\\n        if root:\\n            res.append(root.val)\\n            inOrder(root.left)\\n            inOrder(root.right)\\n    \\n    def postOrder(root):\\n        if root:\\n            inOrder(root.left)\\n            inOrder(root.right)\\n            res.append(root.val)\\n    \\n    inOrder(root)\\n    return res\\n\\n# one-liner recursive\\ndef traverse(root):\\n    return self.postorderTraversal(root.left)+self.postorderTraversal(root.right)+[root.val] if root else [] #post order\\n    # return self.postorderTraversal(root.left)+[root.val]+self.postorderTraversal(root.right) if root else [] #in order\\n    # return [root.val]+self.postorderTraversal(root.left)+self.postorderTraversal(root.right) if root else [] #pre order\\n\\n# ------------------------------------------- Iterative\\ndef inorderTraversal(self, root):\\n    stack, result = [], []   \\n    curr = root\\n    while curr or stack:\\n        while curr:\\n            stack.append(curr)\\n            curr = curr.left\\n        node = stack.pop()\\n        result.append(node.val)\\n        curr = node.right\\n        \\n    return result\\n\\ndef preorderTraversal(self, root):\\n    stack, result = [root], []   \\n    while stack:\\n        curr = stack.pop()\\n        if curr:\\n            result.append(curr.val)\\n            stack.append(curr.right)\\n            stack.append(curr.left)\\n        \\n    return result\\n\\ndef postorderTraversal(root):\\n    stack, result = [root], []   \\n    while stack:\\n        curr = stack.pop()\\n        if curr:\\n            result.append(curr.val)\\n            stack.append(curr.left)\\n            stack.append(curr.right)\\n    return result[::-1]",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1567642,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1567706,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1576752,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1571206,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1862741,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1750273,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1820685,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1566744,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1569462,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1565404,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1567642,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1567706,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1576752,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1571206,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1862741,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1750273,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1820685,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1566744,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1569462,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1565404,
                "content": [
                    {
                        "username": "adityagarg96",
                        "content": "Since this is one of the very fundamental questions about trees (and its marked easy) I expect it to have 5-6 interesting tree examples so beginners can get an intuitive feel for how inorder traversal works. \\n\\nOtherwise they can come up with a solution that passes the test cases and be confused why their solution is not correct"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/678e24d1-7af3-46c5-a8b9-dd25d0822b96_1640017044.592134.png)\\n\\n![image](https://assets.leetcode.com/users/images/84d5fb66-232e-4a03-aa40-ba777a3bca21_1640017047.873514.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a1f31f6-467f-4e29-80ed-dddc8b22edc9_1640017080.0739079.png)\\n\\n\\nMorris algo\\n\\n![image](https://assets.leetcode.com/users/images/38991f8a-7928-4a8c-b608-db0a32a280d6_1640017101.475473.png)\\n\\n![image](https://assets.leetcode.com/users/images/a0d91bcd-fc74-4e62-846a-9e304ee13203_1640017112.6816013.png)\\n\\n![image](https://assets.leetcode.com/users/images/604dc0ef-bb21-4df0-9c18-6997eab983ae_1640017128.7286797.png)\\n"
                    },
                    {
                        "username": "mvalpha",
                        "content": "You\\'re really helpful, thanks for the explanation."
                    },
                    {
                        "username": "dimitryku",
                        "content": "there should not be any solutions, but thank you for graphs"
                    },
                    {
                        "username": "binarybeauty45",
                        "content": "Thankyou for explaining it properly\\uD83D\\uDE0A"
                    },
                    {
                        "username": "raj73",
                        "content": "I wish this get\\'s easier for me someday. I am working on it, putting in my honest efforts every single day. Hope this hardwork pays off. :( :)"
                    },
                    {
                        "username": "aaryan9",
                        "content": "us momint\\n"
                    },
                    {
                        "username": "psy-duck",
                        "content": "[@jimmy-lemon](/jimmy-lemon) about a year ago I struggled with easies. Now I can get through mediums in a decent amount of time and I have not even been too consistent with practice. You got this!"
                    },
                    {
                        "username": "nupuriya",
                        "content": "you got this brother"
                    },
                    {
                        "username": "eaglered00",
                        "content": "Difficulty levels are all over the place on this site. This problem isn\\'t very intuitive to people without exposure to recursion (or if they got rusty)."
                    },
                    {
                        "username": "mgrand94",
                        "content": "Same here! dont you ever give up!"
                    },
                    {
                        "username": "TYork",
                        "content": "[@JuanQP](/JuanQP)  LOL it is just sweat and tears :)"
                    },
                    {
                        "username": "jimmy-lemon",
                        "content": "Has it? I\\'m in the same boat right now. Each new question I try feels like a foreign language."
                    },
                    {
                        "username": "JuanQP",
                        "content": "Don\\'t worry, it will. Everybody has to study it and learn it someday. No one is born knowing"
                    },
                    {
                        "username": "nickthekey",
                        "content": "I've spent a few hours trying to understand what \"inorder\" traversal means, and I can't figure it out!\\n\\nDoes it mean from left most to right most? \\nDoes it mean from least to greatest?\\nDoes it mean the order they were added?\\nI can't figure it out."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@diakonovm](/diakonovm) True. This is an easy level code but the binary traversal is not a beginner level concept, should be explained in the description."
                    },
                    {
                        "username": "diakonovm",
                        "content": "[@pktk001](/pktk001) This should be in the description of the problem. A beginner will not understand this concept, especially as this is an easy level problem."
                    },
                    {
                        "username": "pktk001",
                        "content": "Inorder-traversal means processing\"(left subtree)->(root)->(right subtree)\".\\nNote:- left subtree is recursively a binary tree and same order should be followed again recursively."
                    },
                    {
                        "username": "monray969",
                        "content": " -    :\n\n   ,           (inorder traversal)       .\n\nInorder traversal -       .       ,   ,     .  ,      ,   inorder traversal        .\n\n,    :\n    1\n   / \\\\\n  2   3\n / \\\\     / \\\\\n.      .   4    5\ninorder traversal   [2, 1, 4, 3, 5],         2,     1,     4,     3 , ,    5.\n\n  -  ,                  ."
                    },
                    {
                        "username": "sergey-emelyanov",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0414\\u043E\\u0431\\u0440\\u044B\\u0439 \\u0427\\u0435\\u043B\\u043E\\u0432\\u0435\\u043A! \\u0410 \\u0442\\u043E \\u044F \\u043D\\u0435 \\u043F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043B \\u043E\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \"\\u0441\\u043E\\u0432\\u0441\\u0435\\u043C\" \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0442\\u044C=("
                    },
                    {
                        "username": "serhiy116",
                        "content": "\\u0421\\u043F\\u0430\\u0441\\u0438\\u0431\\u043E, \\u0430 \\u0442\\u043E \\u044F \\u0434\\u0443\\u043C\\u0430\\u043B \\u0442\\u043E \\u043B\\u0438 \\u043D\\u0430\\u0434\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A-\\u0442\\u043E \\u0438\\u0445 \\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u044B\\u0447\\u0438\\u0432\\u0430\\u0442\\u044C."
                    },
                    {
                        "username": "Gnash_crazy_rat",
                        "content": "thanks this helped me actually understand why it was that order. I suggest others use translate on this comment"
                    },
                    {
                        "username": "wegocove",
                        "content": "\\u0442\\u0430\\u043A - 1 3 4 5 6"
                    },
                    {
                        "username": "ba1ram",
                        "content": "\\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0435\\u0441\\u043B\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0434\\u0435\\u0440\\u0435\\u0432\\u043E:\\n      4\\n     /  \\\\\\n    1    6\\n     \\\\   /\\n     3  5 \\n\\u0422\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u043E\\u043C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u044D\\u0442\\u043E:\\n1 5 4 3 6\\n\\n\\u0438\\u043B\\u0438 \\u043A\\u0430\\u043A?\\n"
                    },
                    {
                        "username": "dLENS",
                        "content": "I don\\'t even get the example. Why is root = [1, null, 2, 3]? There is nothing in the given tree diagram that translates into an array of  [1, null, 2, 3]? Why isn\\'t it just [1, 2, 3]? Where does the null come from and why is it just thrown in randomly between the 1 and the 2???"
                    },
                    {
                        "username": "gaurav_begin1",
                        "content": "[@dyakant](/dyakant) so why not to include path termination for 2 ans 3"
                    },
                    {
                        "username": "hardworkpaysoff",
                        "content": "the root = [1,null, 2, 3] means that when traversing the subtree \"inorder\", your algorithm should visit root->left all the way down until its hits a null before backtracking with root->value then root->right. root = [1 , null, 2 , 3] just helps you visualize that this particular example starts from the root where you will call the function passing root->left which is still active. Then you will pass its subtree on its left side but is NULL so you reach the base case and back tracks to the following line of code from the previous function call. "
                    },
                    {
                        "username": "dyakant",
                        "content": "The answer is in the testcase question \"How to create binary tree testcase\":\\n*\"The input [1,null,2,3] represents the serialized format of a binary tree using level order traversal, where null signifies a path terminator where no node exists below.\"*"
                    },
                    {
                        "username": "dyakant",
                        "content": "I suppose it\\'s because of the Array representation Method, where the root is placed on the zero position and positions of children are calculated as: the left child will be placed at \\'2n+1\\' and the right child will place at \\'2n+2\\' (\"n\" is the index of the parent Node). But in this case the represantation should be the following: [1, null, 2, null, null, 3]."
                    },
                    {
                        "username": "bwpge",
                        "content": "The examples are not helpful for beginners. I already know the different traversal methods so I don\\'t really care for myself. However, having the same single branch be the only visual example for preorder, inorder, and postorder traversals is just pure laziness. Changing the trees and adding enough branches with arrows to follow so a beginner can visualize what is happening would be the minimum effort I expect."
                    },
                    {
                        "username": "shingcao",
                        "content": "Can anyone explain why this problem have a hash table tag?"
                    },
                    {
                        "username": "Dirk41",
                        "content": "Why root value is visited first in the test case ? If the root value is visisted first, I believe that\\'s preorder traversial. \\nPlease enlight me !"
                    },
                    {
                        "username": "palakgarg07",
                        "content": "In inorder traversal we first traverse \\nleft subtree --> root --> right subtree\\n\\nIn the given test case, root has no left child. Therefore, we visit root and then accordingly we traverse the right subtree. So, the inorder traversal is [1,3,2].\\n\\nIn preorder traversal we first visit\\nroot --> left subtree --> right subtree\\nSo, for the same test case the preorder traversal would be [1,2,3]."
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "in inorder rootValue is visited 1st in only case when its left child is null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Case 1 is `[1,null,2,3]`.\\nThis represents a Binary Tree with a Root node of 1, with no Left Child, and only a Right Child.\\nSince In-Order Traversal means doing Left Child, Current, Right Child, and there is no Left Child, the solution should start with the Root node value, or 1."
                    },
                    {
                        "username": "zelgit",
                        "content": "I\\'m trying to use the remove() function in ArrayUtils (ArrayUtils.remove(container, element) but it seems that LeetCode is not recognizing it. So I\\'m unable to use the function with or without importing import org.apache.commons.lang3.ArrayUtils; (which it didn\\'t recognize). Pls help! :)"
                    }
                ]
            },
            {
                "id": 1570174,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1905416,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1816158,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1574193,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1572684,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1869599,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1869367,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1570515,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 2026019,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1949066,
                "content": [
                    {
                        "username": "user7277Op",
                        "content": "Take a look at my screen shot:\\n\\n![image](https://assets.leetcode.com/users/images/e05e7857-c795-4382-abbc-3abb991abe14_1600663307.1254942.png)\\n"
                    },
                    {
                        "username": "mehtapreet404",
                        "content": "Hi. So this issue is due to the usage of a common class variable `ll`.\\nAll the test cases are run in a sequence. \\nHence, the output of the first test case (then the value of `ll` after running the first test case) becomes the starting state in the second test case."
                    },
                    {
                        "username": "KensaySato",
                        "content": "did you figure out why this is happening? having the same issue"
                    },
                    {
                        "username": "b27022602",
                        "content": "Am I the only one who cant not even understand the description of the question?\\nI feel the problem is easy, but some concept are not. "
                    },
                    {
                        "username": "strmrdr123",
                        "content": "Why are the examples for this question so bad...? Maybe give a larger example so people can understand what is required?"
                    },
                    {
                        "username": "yopyop1007",
                        "content": "Hey everyone,\\nI was confused what the question means by \"inorder travel\"? The example shown, and its respective output do not really get the question across. Sorry if this is answered in one of the solutions, I would like to understand and try it out before checking out a solution. Thanks"
                    },
                    {
                        "username": "RamakantB",
                        "content": "About test cases - Why would an input with root = null, expect an output of [] (basically new ArrayList<Integer>()) & not null?\\n"
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "function should return a value of the same type, so it would be strange to expect it to return null"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "A Tree with no nodes does not imply there is no Traversal. There is a Traversal with no nodes."
                    },
                    {
                        "username": "mokotozett",
                        "content": "Concepts needed to answer this question:\\nBinary Tree\\nRoot\\nNodes\\nInorder Traversal\\n\\nI recommend go brush up on these and come back to this problem later."
                    },
                    {
                        "username": "mokotozett",
                        "content": "This one requires some knowledge about trees and nodes. \\nWith that knowledge, the logic of the problem becomes clear. Check each Node, if it has a subtree under, check the left and then the right subrtee nodes. If the right or left have subtrees themselves, check the left and then the right of their nodes, and so on.\\n\\nIn the given sample problem: [1, 2, 3]\\nBefore you put \"1\" down, does it have a subtree? Yeah, no left, but it has a right \"2\" subtree. Since there is no left, clear \"1\"  and we put \"1\" down. [1].\\nBefore you put subtree \"2\" down, does \"2\" have a subtree? Yes, it has a left but no right subtree. So we go to the left subtree of \"2\" which is \"3\". \\nBefore we put \"3\" down, does it have a subtree? No left or right. Clear \"3\" and put it down. [1, 3]\\nWe are back in \"2\". We cleared its left node. There is no right node for \"2\" so now we put down \"2\". [1, 3, 2]\\nIf \"2\" had 2 nodes, once we cleared the left, we put down \"2\" and we go to the right node of \"2\", Does the right node of \"2\" have a subtree? If it does? Is it a left or right node? And so on...\\nSummary: Start at a node, check for subtrees. Check the left node of the subtree for other nodes under it. Clear the left nodes. Then put down the parent node and move to start clearing the right nodes. Something like that.\\n"
                    },
                    {
                        "username": "DanielQiao",
                        "content": "BST traversals are apprantly very important topics and I find most times the recursion or iteration + stack approach is enough to tackle most questions I\\'ve see. However, is the morris traversal method applied a good range of questions/asked in interviews? I find it a bit trickey to understand."
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "Need more examples"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "If you\\'re able to solve it using recursion/stack then try to do it using Morris traversal algorithm. It uses O(1) space and amortized O(n) time"
                    }
                ]
            },
            {
                "id": 1809614,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1751467,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1574233,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1572593,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1574123,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 1573707,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2068958,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2049898,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2033340,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2013454,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I love how in leetcode testcases are the edge cases.\\nLike what is this [] and [1] testcase..  I am assuming now that 1 3 2. Is root - left leave and going back up.\\nI mean this question is for beginners, no need to make it difficult for no reason. Hard and Medium questions can be as twisted as you want since they come close to that 100k salary, if you can solve them"
                    },
                    {
                        "username": "zkerner1",
                        "content": "why is their such an insistence - across leetcode - of giving trivial test cases. frankly I find this infuriating. Each problem should come with 3 - 4 non-trivial test cases."
                    },
                    {
                        "username": "fancypantsbob",
                        "content": "How could the average case be O(log(n))? Since the solution maintains an output list of each value from each node it should always be O(n) shouldn\\'t it?"
                    },
                    {
                        "username": "cannellajs2",
                        "content": "Oddly if I don\\'t make any modifications to my solution and repeatedly submit the memory usage will change while the speed remains the same. Maybe different test conditions on each submission?"
                    },
                    {
                        "username": "GeraldRyan",
                        "content": "I learned what Inorder traversal is, but how do they map an array/list into a tree? It doesn\\'t seem from the graphic representation that it\\'s doing an in-order or it would hit the node in the middle after hitting the leftmost. I-e. 123 not 132"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Is it just me or is an iterative inorder traversal algorithm substantially harder than an iterative preorder traversal?\\n\\nI was hoping I could find a template, like you get for recursive solutions, to do dfs + stack. However, this doesnt seem like the case. Am I right?"
                    },
                    {
                        "username": "bashyal",
                        "content": "whoever wrote these testcases can go ft"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "Easiest C++ solution ::\\n\\nvoid solution(TreeNode*root,vector<int>&v){\\n    if(root==NULL)\\n    return ;\\n    solution(root->left,v);\\n    v.push_back(root->val);\\n    solution(root->right,v);\\n}\\n    vector<int> inorderTraversal(TreeNode* root) {\\n       vector<int>v;\\n       solution(root,v);\\n       return v;\\n\\n        \\n    }"
                    },
                    {
                        "username": "peregudov",
                        "content": "Am I the only one who finds example tree confusing? Why is 3 on the left side of the 2. 3>2, shouldn\\'t 3 be on the right of 2?"
                    },
                    {
                        "username": "0x49D1",
                        "content": "I have not studied programming in the university, so the description of the problem was not enough for me. Took some time to find the explanation elsewhere and applied the recursive traversal solution after that. I think that would have been beneficial for the problem to add more wide explanation for people without specific background, because this is not \"rocket science\", but from 1 sentence it was not clear, sorry.   "
                    }
                ]
            },
            {
                "id": 2007717,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1997329,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1977346,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1940711,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1919780,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1886680,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1879007,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1873868,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1863953,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1833518,
                "content": [
                    {
                        "username": "lucasan2300",
                        "content": "in the example 1:\\nthe array for Input: root = [1,null,2,3]\\nis wrong or not well defined\\n\\nIts supposed that is by levels\\nthen the precise and correct input.root is:\\n[1,null,2, null, null, 3]"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This challenge is a good opportunity to practice recursive calls and understand binary trees."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I have solved this problem in Python, Typescript and C++ using stack. Every time I visit it, it feels like a new problem."
                    },
                    {
                        "username": "THINKIT",
                        "content": "vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        TreeNode *curr=root;\\n        while(curr!=NULL)\\n        {\\n            //1st case\\n            if(curr->left==NULL)\\n            {\\n                v.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode *node=curr->left;\\n                //second case go to right most node then make thread to current node \\n                // if it not already made\\n                while(node->right && node->right!=curr)\\n                node=node->right;\\n               //make thread\\n                if(node->right==NULL)\\n                {\\n                    node->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    //remove thread;\\n                    node->right=NULL;\\n                    v.push_back(curr->val);\\n                    curr=curr->right;\\n                }    \\n            }\\n        }\\n        return v;\\n    }"
                    },
                    {
                        "username": "abdmohsen333",
                        "content": "i don\\'t understand.. i know binary trees so well but how am i supposed to assign an array (root = [1,null,2,3] )  to a TreeNode? \\n i expected more attention to be put in the question description when it is marked as \"easy\"..."
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "You wont get array as input. you will the root node you need to return the inorder traversal in form of array."
                    },
                    {
                        "username": "thewickeffect",
                        "content": "I think that the diagram in example one misrepresents how a binary tree works. the node with .val of 3 should be to the right of the second node. "
                    },
                    {
                        "username": "drgIv",
                        "content": "Oh,this examples la classic usles"
                    },
                    {
                        "username": "peterroth124",
                        "content": "If this is meant to test our coding/problem solving ability it should tell us what inorder traversal is. I looked it up: \\nleft node, node, right node: so the the farthest down to the left will be the first in the result list."
                    },
                    {
                        "username": "leonid-lovsky",
                        "content": "Testcase:\\nInput: root = [6,2,7,1,4,null,9,null,null,3,5,8]\\nOutput: [1,2,3,4,5,6,7,8,9]"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "\n` class Solution(object):\n\n    def inorderTraversal(self, root):\n        results = []\n        def traverse(root):\n            if root.left is not None:\n                traverse(root.left)\n            results.append(root.val)\n            if root.right is not None:\n                traverse(root.right)\n        traverse(root)\n        return results`\n\nI get \"NoneType\" object has no attribute \"left\". Why?\n"
                    }
                ]
            },
            {
                "id": 1799574,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1783048,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1767924,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1767523,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1762359,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1758368,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1757633,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1739648,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1735530,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1733493,
                "content": [
                    {
                        "username": "abhiabhishek9347",
                        "content": "What\\'s wrong on this?\\nWhy can\\'t we create List in function.\\npublic List<Integer> inorderTraversal(TreeNode root) {\\n        private List<Integer> l = new ArrayList<>();\\n        if(root!=NULL)\\n        {\\n            inorderTraversal(root.left);\\n            l.add(root.val);\\n            inorderTraversal(root.right);\\n        }\\n        return l;\\n    }"
                    },
                    {
                        "username": "shubhamjha025",
                        "content": "Traversal is one of the first topic you start with for TREE data structure, which is very easy considering recursion . Here I would like to focus on Morris Inorder Traversal.\n      \n    `vector<int> inorderTraversal(TreeNode* root) {\n\n        vector<int> ans;\n        \n        while(root != NULL){\n                    if(root->left == NULL){\n                        ans.push_back(root->val);\n                        root= root->right;\n                    }\n                    else{\n                        TreeNode* temp = root;\n                        temp= temp->left;\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                        while(temp->right != NULL && temp->right != root) {\n                            temp= temp->right;\n                        }\n\n                         if(temp->right == NULL){\n                         temp->right = root;\n                         root= root->left;\n                         }\n                         else {\n                         temp->right = NULL;\n                         ans.push_back(root->val);\n                         root= root->right;\n                         }\n        }.  return ans;    }`\n\nWhat are we doing we are using iterative method without stack. Now, benifits is time is slightly more than O(n) but can be compared to O(n*h) only in general terms{h is height of binary tree) . Talking of space complexity it is O(1)\n\nWe are making the rightmost node in left subtree to point the root "
                    },
                    {
                        "username": "21tushar",
                        "content": " public List<Integer> inorderTraversal(TreeNode root) {\\n List<Integer> result = new ArrayList<>();\\n        inorderTraversal(root, result);\\n        return result;\\n    }\\n    private void inorderTraversal(TreeNode root, List<Integer> result) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorderTraversal(root.left, result);\\n        result.add(root.val);\\n        inorderTraversal(root.right, result);\\n    }"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/94_binary_tree_inorder_treversal.cpp"
                    },
                    {
                        "username": "Nikita22panwar",
                        "content": "Tips:\\nInorder Traversal \\n(Left Root Right)"
                    },
                    {
                        "username": "Voralagas",
                        "content": "why is [1,null,2,3] expecting [1, 3, 2] should not it be [1, 3, 2] ?\\n"
                    },
                    {
                        "username": "TobyLeet",
                        "content": "because it is expecting the left most result first, not necessarily the smallest number. Imagine you are reaching the leftmost pointing branch first, working your way to the rightmost facing branch. So technically the parent node is to the right of the left child node, and to the left of it\\'s right child node."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Why the tree in the Example 1 is described as Input: root = [1,null,2,3]?\nShouldn't it be like this:\nInput: root = [1,null,2, null, null, 3] ? (as it is shown in internet resourses about binary tree array representation)\nAnd how can we traverse the tree if 2k, 2k + 1 formulas doesn't work?\nPlease, help me with this."
                    },
                    {
                        "username": "MaxKur",
                        "content": "Got it. After debugging, actual representation of root for [1, null, 2, 3] is:\\n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\\nSo, this object passed in inorderTraversal function as the argument, not the array."
                    },
                    {
                        "username": "noneal",
                        "content": "What is returnSize supposed to be? I assumed that if I dereferenced it, I would get the size of the array to be returned, but I got -1"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-inorder-traversal-leet-code-94/"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the solution to perform an inorder traversal of a binary tree in Swift is O(n), where n is the number of nodes in the tree. This is because the function visits each node exactly once.\\n\\nThe space complexity of the solution is O(n), because the function stores the recursive calls on the call stack. The space complexity is not affected by the structure of the tree, only by the number of nodes.\\n\\nNote that this solution uses a recursive approach, which has an additional space complexity of O(m) on the call stack, where m is the depth of the recursion. In the worst case, when the tree is a linked list, the depth of the recursion is O(n), resulting in a space complexity of O(n). However, in most cases, the depth of the recursion will be much smaller than n, resulting in a smaller space complexity."
                    }
                ]
            },
            {
                "id": 1728201,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1725903,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1719384,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1708956,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1706983,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1691789,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1691788,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1691142,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1672383,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1669371,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user3422UL",
                        "content": "https://algotree.org/algorithms/tree_graph_traversal/pre_in_post_order/\\n\\nHope this helps anyone else who may be having a hard time with some of these concepts.\\nVery helpful website"
                    },
                    {
                        "username": "Mayank_Sardana",
                        "content": "Hope u find it easy to understand  \\n\\n\\n\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list  = new ArrayList<>();\\n        if(root==null)\\n        {\\n            return list;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        TreeNode curr = root;\\n        while(stack.size()!=0)\\n        {\\n              if(curr!=null && curr.left!=null)\\n              {\\n                  stack.push(curr.left);\\n                  curr = stack.peek();\\n              }\\n              else \\n              {\\n                  list.add(stack.peek().val);\\n                  curr = null;\\n                  TreeNode pp = stack.pop();\\n                  if(pp.right!=null)\\n                  {\\n                       stack.push(pp.right);\\n                       curr = pp.right;\\n                  }\\n              }\\n        }\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "i am facing problem like --error: non-void function \\'inorderTraversal\\' should return a value i.e, i m not able to use return keyword...any soln\\n"
                    },
                    {
                        "username": "jingchizhang001",
                        "content": "Can anyone help explain why I cannot do root.val or root.left? \nIt says:\nAttributeError: 'NoneType' object has no attribute 'val'\n    print(root.val)\nLine 13 in inorderTraversal (Solution.py)\n    ret = Solution().inorderTraversal(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)"
                    },
                    {
                        "username": "marxmaler",
                        "content": "Oh, that\\'s because test case2\\'s root is actually \"None\" -  try print(root) if you still don\\'t get it. So you should handle that exception separately. Sorry if you figured it out already."
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "is there any approach with complexity O(nlogn) ??"
                    },
                    {
                        "username": "VivekSingh05",
                        "content": "Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "I'm having a hard time getting LeetCode's inorder variant, with root, followed by inorder. The first problem is figuring out why the hell it says `root` is null.\n\nTestcase: `[1,null,2,3]`\n\n```\nTypeError: Cannot read properties of null (reading 'val')\n```\n\n```\nfunction inorderTraversal(root, result = []) {\n    console.log(\"root = \\n\"+JSON.stringify(root))\n    result.push(root.val);\n\n};\n```\n\nStdout:\n```\nroot = \n{\"val\":1,\"left\":null,\"right\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":null}}\nnull\n```"
                    },
                    {
                        "username": "rahulranjancusb",
                        "content": "// We can solve this using 2 ways: Recursive and Iterative.\\n //Approach 1: Recursive\\nclass Solution {\\npublic:\\n    vector<int> inOrder;\\n    vector<int> inorderTraversal(TreeNode* root) {  \\n        //Approach 1: Recursive\\n        // if(root)\\n        // {\\n        //     inorderTraversal(root->left);\\n        //     inOrder.push_back(root->val);\\n        //     inorderTraversal(root->right);\\n        // }\\n        // return inOrder;\\n\\n        //Approach 2: Iterative\\n        stack<TreeNode*> st;\\n        while(root != nullptr || !(st.empty()))\\n        {\\n            if(root != nullptr){\\n                st.push(root);\\n                root = root->left;\\n            }\\n            else\\n            {\\n                root = st.top(); st.pop();\\n                inOrder.push_back(root->val);\\n                root = root->right;   \\n            }\\n        }\\n        return inOrder;\\n    }\\n};"
                    },
                    {
                        "username": "bhaghatsingh",
                        "content": " `your inline code...your inline code...`\\n  void inordT(TreeNode *root,vector<int> &v1)\\n    {\\n        if(root==NULL)return ;\\n        inord(root->left,v1);\\n        v1.push_back(root->val);\\n        inord(root->right,v1);\\n    }\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>v1;\\n        inordT(root,v1);\\n        return v1;\\n        \\n    }"
                    }
                ]
            }
        ]
    }
]