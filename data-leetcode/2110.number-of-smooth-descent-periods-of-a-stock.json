[
    {
        "title": "Number of Smooth Descent Periods of a Stock",
        "question_content": "You are given an integer array prices representing the daily price history of a stock, where prices[i] is the stock price on the ith day.\nA smooth descent period of a stock consists of one or more contiguous days such that the price on each day is lower than the price on the preceding day by exactly 1. The first day of the period is exempted from this rule.\nReturn the number of smooth descent periods.\n&nbsp;\nExample 1:\n\nInput: prices = [3,2,1,4]\nOutput: 7\nExplanation: There are 7 smooth descent periods:\n[3], [2], [1], [4], [3,2], [2,1], and [3,2,1]\nNote that a period with one day is a smooth descent period by the definition.\n\nExample 2:\n\nInput: prices = [8,6,7,7]\nOutput: 4\nExplanation: There are 4 smooth descent periods: [8], [6], [7], and [7]\nNote that [8,6] is not a smooth descent period as 8 - 6 &ne; 1.\n\nExample 3:\n\nInput: prices = [1]\nOutput: 1\nExplanation: There is 1 smooth descent period: [1]\n\n&nbsp;\nConstraints:\n\n\t1 <= prices.length <= 105\n\t1 <= prices[i] <= 105",
        "solutions": [
            {
                "id": 1635083,
                "title": "python-c-java-one-pass-dp-o-n-detailed-explanation-clean-and-easy-to-understand",
                "content": "**Please UPVOTE if you LIKE!** \\uD83D\\uDE01\\n\\n* `dp[i]` is defined as the number of smooth descent periods **ended at i**.\\n\\t* obviously `dp[0] = 1`\\n\\t* if `prices[i]== prices[i - 1]` then `dp[i] = dp[i - 1] + 1` else `dp[i] = 1`\\n* for example: `prices = [3, 2, 1, 4]`\\n\\t* `dp[0] = 1`, [**3**] is a smooth descent period\\n\\t* `dp[1] = 2`, because `2 == 3 - 1`, that is [**2**], [3, **2**] are smooth descent periods\\n\\t* `dp[2] = 3`, because `1 == 2 - 1`, that is [**1**], [2, **1**], [3, 2, **1**]are smooth descent periods\\n\\t* `dp[3] = 1`, because `4 != 1 - 0`, that is only [**4**] is a smooth descent period\\n\\t* Note that the end of smooth descent periods are all **marked in bold**.\\n\\t* so the return value is `sum(dp) = 7`, because the answer needs the **total count** of smooth descent periods **ended at any index of prices**.\\n* Furthmore since `dp[i]` is only dependent on `dp[i - 1]`, the **Space Complexity can be reduced to O(1)**, and **we can redefine dp as the number of smooth descent periods ended at the previous index**\\n\\n**O(N) Space**\\n<iframe src=\"https://leetcode.com/playground/G5BGudUz/shared\" frameBorder=\"0\" width=\"100%\" height=\"340\"></iframe>\\n\\n**O(1) Space**\\n<iframe src=\"https://leetcode.com/playground/BJ3299Gg/shared\" frameBorder=\"0\" width=\"100%\" height=\"320\"></iframe>\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**",
                "solutionTags": [],
                "code": "**Please UPVOTE if you LIKE!** \\uD83D\\uDE01\\n\\n* `dp[i]` is defined as the number of smooth descent periods **ended at i**.\\n\\t* obviously `dp[0] = 1`\\n\\t* if `prices[i]== prices[i - 1]` then `dp[i] = dp[i - 1] + 1` else `dp[i] = 1`\\n* for example: `prices = [3, 2, 1, 4]`\\n\\t* `dp[0] = 1`, [**3**] is a smooth descent period\\n\\t* `dp[1] = 2`, because `2 == 3 - 1`, that is [**2**], [3, **2**] are smooth descent periods\\n\\t* `dp[2] = 3`, because `1 == 2 - 1`, that is [**1**], [2, **1**], [3, 2, **1**]are smooth descent periods\\n\\t* `dp[3] = 1`, because `4 != 1 - 0`, that is only [**4**] is a smooth descent period\\n\\t* Note that the end of smooth descent periods are all **marked in bold**.\\n\\t* so the return value is `sum(dp) = 7`, because the answer needs the **total count** of smooth descent periods **ended at any index of prices**.\\n* Furthmore since `dp[i]` is only dependent on `dp[i - 1]`, the **Space Complexity can be reduced to O(1)**, and **we can redefine dp as the number of smooth descent periods ended at the previous index**\\n\\n**O(N) Space**\\n<iframe src=\"https://leetcode.com/playground/G5BGudUz/shared\" frameBorder=\"0\" width=\"100%\" height=\"340\"></iframe>\\n\\n**O(1) Space**\\n<iframe src=\"https://leetcode.com/playground/BJ3299Gg/shared\" frameBorder=\"0\" width=\"100%\" height=\"320\"></iframe>\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**",
                "codeTag": "Unknown"
            },
            {
                "id": 1635010,
                "title": "simple-aggregation",
                "content": "We count descending prices in `cnt`. If the next price is not descending, we reset `cnt` to `1`.\\n\\nFirst price adds 1 smooth period. Second descending price adds two periods, third - three periods, and so on.\\n\\nSo, we just need to add `cnt` to our result `res`.\\n\\n**C++**\\n```cpp\\nlong long getDescentPeriods(vector<int>& prices) {\\n    long long res = 1, cnt = 1;\\n    for (int i = 1; i < prices.size(); ++i) {\\n       if (prices[i - 1] == prices[i] + 1)\\n           ++cnt;\\n        else\\n           cnt = 1;\\n        res += cnt;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong long getDescentPeriods(vector<int>& prices) {\\n    long long res = 1, cnt = 1;\\n    for (int i = 1; i < prices.size(); ++i) {\\n       if (prices[i - 1] == prices[i] + 1)\\n           ++cnt;\\n        else\\n           cnt = 1;\\n        res += cnt;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635000,
                "title": "python-short-dp-explained",
                "content": "Define by `dp[i]` the longest smooth decreasing subarray ending with index `i`. Then we have:\\n1. if `P[i] = P[i-1] + 1` then `dp[i] = 1 + dp[i-1]`.\\n2. Else we have `dp[i] = 1`.\\n\\n#### Complexity\\nIt is `O(n)` for time and space. Space can be made `O(1)`.\\n\\n#### Solution\\n```python\\nclass Solution:\\n    def getDescentPeriods(self, P):\\n        n = len(P)\\n        dp = [1]*n\\n        for i in range(1, n):\\n            if P[i] == P[i-1] - 1:\\n                dp[i] = 1 + dp[i-1]\\n                \\n        return sum(dp)\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def getDescentPeriods(self, P):\\n        n = len(P)\\n        dp = [1]*n\\n        for i in range(1, n):\\n            if P[i] == P[i-1] - 1:\\n                dp[i] = 1 + dp[i-1]\\n                \\n        return sum(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635033,
                "title": "c-o-n-time-one-pass",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\nGet the length of each segment that `A[i] == A[i-1] - 1`. If a segment is of length `len`, then it contributes `1 + 2 + 3 + ... + len = (1 + len) * len / 2` subarrays into the answer. For example `[3,2,1]` has `[3,2,1]` (1 array of length 3), `[3,2]`, `[2,1]` (2 arrays of length 2), `[3]`, `[2]`, `[1]` (3 arrays of length 1), in total `1 + 2 + 3 = 6` valid subarrays.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& A) {\\n        long long ans = 0, N = A.size();\\n        for (long long i = 0; i < N; ) {\\n            long long len = 1;\\n            ++i;\\n            while (i < N && A[i] == A[i - 1] - 1) ++i, ++len;\\n            ans += (1 + len) * len / 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& A) {\\n        long long ans = 0, N = A.size();\\n        for (long long i = 0; i < N; ) {\\n            long long len = 1;\\n            ++i;\\n            while (i < N && A[i] == A[i - 1] - 1) ++i, ++len;\\n            ans += (1 + len) * len / 2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635064,
                "title": "java-python-3-time-o-n-space-o-1-code",
                "content": "For each descent periods ending at `i`, use `cnt` to count the # of the the periods and add to the output variable `ans`.\\n```java\\n    public long getDescentPeriods(int[] prices) {\\n        long ans = 0;\\n        int cnt = 0, prev = -1;\\n        for (int cur : prices) {\\n            if (prev - cur == 1) {\\n                ++cnt; \\n            }else {\\n                cnt = 1;\\n            }\\n            ans += cnt;\\n            prev = cur;\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        ans = cnt = 0\\n        prev = -math.inf\\n        for cur in prices:\\n            if prev - cur == 1:\\n                cnt += 1\\n            else:\\n                cnt = 1\\n            ans += cnt\\n            prev = cur\\n        return ans\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long getDescentPeriods(int[] prices) {\\n        long ans = 0;\\n        int cnt = 0, prev = -1;\\n        for (int cur : prices) {\\n            if (prev - cur == 1) {\\n                ++cnt; \\n            }else {\\n                cnt = 1;\\n            }\\n            ans += cnt;\\n            prev = cur;\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        ans = cnt = 0\\n        prev = -math.inf\\n        for cur in prices:\\n            if prev - cur == 1:\\n                cnt += 1\\n            else:\\n                cnt = 1\\n            ans += cnt\\n            prev = cur\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1635014,
                "title": "java-sliding-window-o-n-explanation-similar-questions",
                "content": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int i=0;\\n        int j=1;\\n        long ans=1;\\n        while(j<prices.length){\\n            if( prices[j-1]-prices[j]==1){\\n\\t\\t\\t//It means that j(current element) can be part of previous subarrays (j-i) \\n\\t\\t\\t//and can also start a subarray from me (+1). So add (j-i+1) in total Subarrays\\n                int count=j-i+1;\\n                ans+=count;\\n            }else{\\n\\t\\t\\t//It means that j cannot be part of previous subarrays but can start subarray from me. So, ans+=1\\n                i=j;\\n                ans+=1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\nFor more practice, you can try Leetcode 795 and 713 question, which is a somewhat similar problem to this.\\nSimilar Questions-\\n[Number of Subarrays with Bounded Maximum](http://leetcode.com/problems/number-of-subarrays-with-bounded-maximum/)\\n[Subarray Product Less Than K](http://leetcode.com/problems/subarray-product-less-than-k/)",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int i=0;\\n        int j=1;\\n        long ans=1;\\n        while(j<prices.length){\\n            if( prices[j-1]-prices[j]==1){\\n\\t\\t\\t//It means that j(current element) can be part of previous subarrays (j-i) \\n\\t\\t\\t//and can also start a subarray from me (+1). So add (j-i+1) in total Subarrays\\n                int count=j-i+1;\\n                ans+=count;\\n            }else{\\n\\t\\t\\t//It means that j cannot be part of previous subarrays but can start subarray from me. So, ans+=1\\n                i=j;\\n                ans+=1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635006,
                "title": "c-easy-o-n-one-pass-solution-beats-100-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long ans = 0;\\n        long long temp = 0;\\n        for(int i=1; i<prices.size(); i++){\\n            if(prices[i - 1] - prices[i] == 1){\\n                temp++;\\n                ans += temp;\\n            }\\n            else{\\n                temp = 0;\\n            }\\n        }\\n        ans += prices.size();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long ans = 0;\\n        long long temp = 0;\\n        for(int i=1; i<prices.size(); i++){\\n            if(prices[i - 1] - prices[i] == 1){\\n                temp++;\\n                ans += temp;\\n            }\\n            else{\\n                temp = 0;\\n            }\\n        }\\n        ans += prices.size();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634973,
                "title": "java-two-pointers-o-n-with-explanation",
                "content": "Let array = [3,2,1,4]\\nwhen start=0,end=1\\nthen valid subarray = [3] (already counted),[2],[3,2] which is basically window size extra\\nso count += end-start+1 (window size)\\nwhen start=0,end=2 \\nthen valid subarray = ( [3],[2],[3,2] ) = already counted  and [3,2,1],[2,1],[1] more \\n\\t\\t\\twhich is basically window size extra = 3\\n\\t\\t\\tso count+= end-start+1 (window size)\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int start=0,end=0;\\n        long count=1;\\n        for(end=1;end<prices.length;end++){\\n            if(prices[end] == prices[end-1]-1){\\n                count += end-start+1;\\n            }else{\\n                start = end;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int start=0,end=0;\\n        long count=1;\\n        for(end=1;end<prices.length;end++){\\n            if(prices[end] == prices[end-1]-1){\\n                count += end-start+1;\\n            }else{\\n                start = end;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635103,
                "title": "python3-counting",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/55c6a88797eef9ac745a3dbbff821a2aac735a70) for solutions of weekly 272. \\n\\n```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        ans = 0 \\n        for i, x in enumerate(prices): \\n            if i == 0 or prices[i-1] != x + 1: cnt = 0\\n            cnt += 1\\n            ans += cnt \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        ans = 0 \\n        for i, x in enumerate(prices): \\n            if i == 0 or prices[i-1] != x + 1: cnt = 0\\n            cnt += 1\\n            ans += cnt \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164279,
                "title": "c-two-pointers-sliding-window-easy-algorithm-fully-explained",
                "content": "# Algorithm :\\n****   using the concept of sliding window:\\n              --------ALGORITHM----------\\n    1. we are maintaining two ptrs: start and end\\n    2. for each index, we are checking if price[end] == price[end-1] - 1\\n    3. if, it is true, then we have found a valid descent period from (start to end)\\n    4. so, update ans += end - start + 1, which accounts for total no. of \"descent periods\"\\n       that we can make till end index.\\n    5. else, we update our pointers for a new window.\\n**\\n# C++ Code:\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n=prices.size();\\n        int start=0;\\n        int end  =0;\\n        long long ans=1;//since, we will be starting our iteration from ist index\\n        \\n        for(end=1 ; end<n; end++){\\n            \\n            if(prices[end] == prices[end-1] - 1){\\n                ans += end - start + 1;\\n            }\\n            \\n            else{\\n                start=end;\\n                ans += end - start + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Please Please consider Upvoting the solution, if it\\'s been any help to you!\\nHappy Coding!!**",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n=prices.size();\\n        int start=0;\\n        int end  =0;\\n        long long ans=1;//since, we will be starting our iteration from ist index\\n        \\n        for(end=1 ; end<n; end++){\\n            \\n            if(prices[end] == prices[end-1] - 1){\\n                ans += end - start + 1;\\n            }\\n            \\n            else{\\n                start=end;\\n                ans += end - start + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635104,
                "title": "cpp-java-python-explanation-with-pictures",
                "content": "Group prices based on the given rule. The continuous prices in each group have a decrement of 1.\\n![image](https://assets.leetcode.com/users/images/b4396543-b237-4f49-879c-0ef90e2af23a_1639886723.2854674.png)\\n\\nFor a group of length **n**, the number of decent periods is **n * (n + 1) / 2**. \\n![image](https://assets.leetcode.com/users/images/78aea39d-4b30-4072-8db4-7593a3035f6f_1639886723.3079367.png)\\n\\n\\n**python**\\n```\\ndef getDescentPeriods(self, A: List[int]) -> int:\\n        n = len(A)\\n        ans, cur = 0, 1\\n\\n        for i in range(1, n):\\n            if A[i] == A[i - 1] - 1:\\n                cur += 1\\n            else:\\n                ans += cur * (cur + 1) // 2\\n                cur = 1\\n        return ans + cur * (cur + 1) // 2\\n```\\n\\n**CPP**\\n```\\npublic:\\n    long long getDescentPeriods(vector<int>& A) {\\n        int n = A.size();\\n        long long ans = 0, cur = 1;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] == A[i - 1] - 1)\\n                cur += 1;\\n            else {\\n                ans += cur * (cur + 1) / 2;\\n                cur = 1;\\n            }\\n        }\\n        \\n        return ans + cur * (cur + 1) / 2;\\n    }\\n```\\n\\n**JAVA**\\n```\\npublic long getDescentPeriods(int[] A) {\\n        int n = A.length;\\n        long ans = 0, cur = 1;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] == A[i - 1] - 1)\\n                cur += 1;\\n            else {\\n                ans += cur * (cur + 1) / 2;\\n                cur = 1;\\n            }\\n        }\\n        \\n        return ans + cur * (cur + 1) / 2;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\ndef getDescentPeriods(self, A: List[int]) -> int:\\n        n = len(A)\\n        ans, cur = 0, 1\\n\\n        for i in range(1, n):\\n            if A[i] == A[i - 1] - 1:\\n                cur += 1\\n            else:\\n                ans += cur * (cur + 1) // 2\\n                cur = 1\\n        return ans + cur * (cur + 1) // 2\\n```\n```\\npublic:\\n    long long getDescentPeriods(vector<int>& A) {\\n        int n = A.size();\\n        long long ans = 0, cur = 1;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] == A[i - 1] - 1)\\n                cur += 1;\\n            else {\\n                ans += cur * (cur + 1) / 2;\\n                cur = 1;\\n            }\\n        }\\n        \\n        return ans + cur * (cur + 1) / 2;\\n    }\\n```\n```\\npublic long getDescentPeriods(int[] A) {\\n        int n = A.length;\\n        long ans = 0, cur = 1;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] == A[i - 1] - 1)\\n                cur += 1;\\n            else {\\n                ans += cur * (cur + 1) / 2;\\n                cur = 1;\\n            }\\n        }\\n        \\n        return ans + cur * (cur + 1) / 2;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1635102,
                "title": "little-maths-little-sliding-window-without-dp",
                "content": "In order to solve this problem I would prefer you take a pen and paper and make few testcases of your own.\\nDuring that youll find some similarities\\nLet me illustrate:\\n[3,2,1] -  [3,2] , [2,1] , [3,2,1] and singular values\\n3+3 = 6\\nNow when we have 4 numbers\\n[4,3,2,1] \\nwhen we take two numbers at once\\n[4,3] ,[3,2] ,[2,1]  3 cases-.\\nwhen we take 3 numbers at once\\n[4,3,2] , [3,2,1] - 2 cases\\nwhen we take 4 numbers at once\\n[4,3,2,1] - 1 cases\\n\\nTo add we sum it i.e **sum of natural numbers **\\n**(N*(N+1))//2**\\nHere N is size of the **(contiguous valid array - 1)**\\nAlso we will add all singualar values as they also satisfy the condition\\nThus **ans+=len(arr)**.\\n\\n**So all different contiguous arrays which satisfy + size of array** \\nIn the code we keep track of contiguous array using the value of k \\nAnd calculate the value using the sum of natural numbers.\\n\\n```\\nimport sys\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int: \\n        def calculate(k,ans):\\n            if k>1:\\n                ans+=((k-1)*(k))//2 \\n\\t\\t\\t\\t#Sum of Natural Numbers\\n                return ans\\n            else:\\n                return ans\\n        end = 0\\n        start = 0\\n        prev= sys.maxsize\\n        k= 0\\n        ans = 0\\n        while end<len(prices):     \\n            if prev- prices[end]==1 or prev == sys.maxsize:\\n                k+=1\\n                prev = prices[end]\\n                end+=1    \\n            else:             \\n                ans = calculate(k,ans)\\n                start = end\\n                if end<len(prices):\\n                    prev = sys.maxsize\\n                k=0\\n        if k>1:\\n            ans = calculate(k,ans)\\n\\t\\t\\t\\n        return ans+len(prices)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Sliding Window"
                ],
                "code": "```\\nimport sys\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int: \\n        def calculate(k,ans):\\n            if k>1:\\n                ans+=((k-1)*(k))//2 \\n\\t\\t\\t\\t#Sum of Natural Numbers\\n                return ans\\n            else:\\n                return ans\\n        end = 0\\n        start = 0\\n        prev= sys.maxsize\\n        k= 0\\n        ans = 0\\n        while end<len(prices):     \\n            if prev- prices[end]==1 or prev == sys.maxsize:\\n                k+=1\\n                prev = prices[end]\\n                end+=1    \\n            else:             \\n                ans = calculate(k,ans)\\n                start = end\\n                if end<len(prices):\\n                    prev = sys.maxsize\\n                k=0\\n        if k>1:\\n            ans = calculate(k,ans)\\n\\t\\t\\t\\n        return ans+len(prices)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944556,
                "title": "100-faster-java-soln-with-o-1",
                "content": "Please UPVOTE if you LIKE! \\uD83D\\uDE01\\n\\nNote that the end of smooth descent periods are all marked in bold.\\nso the return value is sum(dp) = 7, because the answer needs the total count of smooth descent periods ended at any index of prices.\\nFurthmore since dp[i] is only dependent on dp[i - 1], the Space Complexity can be reduced to O(1), and we can redefine dp as the number of smooth descent periods ended at the previous index\\n# Code\\n```\\nclass Solution {\\n    public static long getDescentPeriods(int[] prices) {\\n        long dp=1;\\n        long ans=1;\\n        for(int i=1;i<prices.length;i++)\\n        {\\n            if(prices[i-1]-1==prices[i])\\n                dp++;\\n            else\\n                dp=1;\\n            ans+=dp;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static long getDescentPeriods(int[] prices) {\\n        long dp=1;\\n        long ans=1;\\n        for(int i=1;i<prices.length;i++)\\n        {\\n            if(prices[i-1]-1==prices[i])\\n                dp++;\\n            else\\n                dp=1;\\n            ans+=dp;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817402,
                "title": "java-o-n-solution-using-dp-array",
                "content": "class Solution {\\n\\n    public long getDescentPeriods(int[] arr) {\\n        int n=arr.length;\\n        int dp[] = new int[n];\\n        long res=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=(arr[i-1]-arr[i]==1)?dp[i-1]+1 : 0;\\n            res+=dp[i];\\n        }\\n        return res+n;\\n    }\\n\\t\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\n    public long getDescentPeriods(int[] arr) {\\n        int n=arr.length;\\n        int dp[] = new int[n];\\n        long res=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=(arr[i-1]-arr[i]==1)?dp[i-1]+1 : 0;\\n            res+=dp[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3401664,
                "title": "easy-approach-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        dp=[]\\n        for i in range(1,len(prices)):\\n            if(prices[i]-prices[i-1]==-1):\\n                dp.append(1)\\n            else:\\n                dp.append(0)\\n        c=[]\\n        res=0\\n        count=0\\n        for i in range(len(dp)):\\n            if(dp[i]==1):\\n                count+=1\\n            else:\\n                c.append(count)\\n                count=0\\n        c.append(count)\\n        for i in c:\\n            if(i==1):\\n                res+=1\\n            else:\\n                res+=(i*(i+1))//2\\n        res+=len(prices)\\n        return(res)\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        dp=[]\\n        for i in range(1,len(prices)):\\n            if(prices[i]-prices[i-1]==-1):\\n                dp.append(1)\\n            else:\\n                dp.append(0)\\n        c=[]\\n        res=0\\n        count=0\\n        for i in range(len(dp)):\\n            if(dp[i]==1):\\n                count+=1\\n            else:\\n                c.append(count)\\n                count=0\\n        c.append(count)\\n        for i in c:\\n            if(i==1):\\n                res+=1\\n            else:\\n                res+=(i*(i+1))//2\\n        res+=len(prices)\\n        return(res)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123010,
                "title": "tc-o-n-sc-o-1-sliding-window-approach-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n    long long getDescentPeriods(vector<int>& p) {\\n  int i=0,j=1;\\n        long long ans=1;\\n      \\n\\n        for(j;j<p.size();j++){\\n    \\n         if(p[j-1]-p[j]!=1)i=j;\\n            ans+=j-i+1;\\n         \\n      \\n        }\\n        return ans;\\n     }\\n };\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n public:\\n    long long getDescentPeriods(vector<int>& p) {\\n  int i=0,j=1;\\n        long long ans=1;\\n      \\n\\n        for(j;j<p.size();j++){\\n    \\n         if(p[j-1]-p[j]!=1)i=j;\\n            ans+=j-i+1;\\n         \\n      \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2009649,
                "title": "python-solution-o-n-dynamic-programming",
                "content": "The approach of this question is to find  contigous substring of decreasing order (i.e. 5,4,3,2,1).\\nStep1 :- every element of array is a contigous substring, so this is why we initialized a dp with values 1\\nStep 2 :- Check if the difference between previous and current value is 1 dp[current_value] will become whatever the dp[curr_value]+dp[prev_value]\\nStep 3 :- Return the sum of values in dp (I have calculated it while updating dp values, I have initialized the s with one to include first valu)\\n```\\nn=len(prices)\\n\\n        dp=[1]*n\\n        s=1\\n        for i in range(1,n):\\n            if prices[i-1]-prices[i]==1:\\n                dp[i]=dp[i-1]+1\\n            s+=dp[i]\\n\\t return s\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nn=len(prices)\\n\\n        dp=[1]*n\\n        s=1\\n        for i in range(1,n):\\n            if prices[i-1]-prices[i]==1:\\n                dp[i]=dp[i-1]+1\\n            s+=dp[i]\\n\\t return s\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635184,
                "title": "c-one-pass-simple-readable-solution-with-explanation-without-using-extra-memory",
                "content": "```\\n//  when arr[i]-arr[i-1 ]==1 to make a chain of \\n// numbers that are decreasing by 1 count++\\n// add the count to ans\\n// and when our chain breaks arr[i]-arr[i-1] !=1\\n// then reset the count\\n\\n long long getDescentPeriods(vector<int>& prices) \\n    {\\n        long long int ans=prices.size();\\n        long long int count=0;\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(prices[i-1]-prices[i]==1)\\n                count++;\\n            else\\n                count=0;\\n            ans=ans+count;\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n//  when arr[i]-arr[i-1 ]==1 to make a chain of \\n// numbers that are decreasing by 1 count++\\n// add the count to ans\\n// and when our chain breaks arr[i]-arr[i-1] !=1\\n// then reset the count\\n\\n long long getDescentPeriods(vector<int>& prices) \\n    {\\n        long long int ans=prices.size();\\n        long long int count=0;\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(prices[i-1]-prices[i]==1)\\n                count++;\\n            else\\n                count=0;\\n            ans=ans+count;\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635073,
                "title": "c-o-n-dp",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n\\n    long long getDescentPeriods(vector<int>& a) {\\n        int n=a.size();\\n        \\n        long long int dp[n], ans=1;\\n        dp[0]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            dp[i]=1; // consdering sub-array formed by individual element\\n            if(a[i]+1==a[i-1]) dp[i]+=dp[i-1]; // new sub-arrays when current element combines with previous sub-arrays\\n            \\n            ans+=dp[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long getDescentPeriods(vector<int>& a) {\\n        int n=a.size();\\n        \\n        long long int dp[n], ans=1;\\n        dp[0]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            dp[i]=1; // consdering sub-array formed by individual element\\n            if(a[i]+1==a[i-1]) dp[i]+=dp[i-1]; // new sub-arrays when current element combines with previous sub-arrays\\n            \\n            ans+=dp[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634977,
                "title": "c-easy-dp-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long result=0;\\n        int n=prices.size();\\n        vector<long long> dp(n,1);\\n        result+=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(prices[i]==prices[i-1]-1)\\n                dp[i]+=dp[i-1];\\n            result+=dp[i];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long result=0;\\n        int n=prices.size();\\n        vector<long long> dp(n,1);\\n        result+=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(prices[i]==prices[i-1]-1)\\n                dp[i]+=dp[i-1];\\n            result+=dp[i];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628978,
                "title": "very-simple-c-beats-90",
                "content": "# if it Helps You, Please Upvote me...!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is Very Simple, Find out **Number of Possible Subarray** + **Find out Break points** According to Problem Statement.\\n\\n**Break Points : Array[i]+1 != Array[i-1]**\\n\\n***Possible SubArray: N*(N+1)/2 , N = size of the whole Array.**\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& p) {\\n\\n        int n  = p.size(),start = 0;\\n        long long ans = 0,x = 0;\\n\\n        for(int i = 1;i<n;i++)\\n        {\\n           if(p[i]+1!=p[i-1])\\n           {\\n              x = i-start;\\n              x = x*(x+1)/2;\\n              ans+=x;\\n              start = i;\\n           }\\n        }\\n        x = n-start;\\n        x = x*(x+1)/2;\\n        ans+=x;\\n\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/5f00c5d6-d539-41ab-a08d-d78397cd6baa_1686566257.8348484.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& p) {\\n\\n        int n  = p.size(),start = 0;\\n        long long ans = 0,x = 0;\\n\\n        for(int i = 1;i<n;i++)\\n        {\\n           if(p[i]+1!=p[i-1])\\n           {\\n              x = i-start;\\n              x = x*(x+1)/2;\\n              ans+=x;\\n              start = i;\\n           }\\n        }\\n        x = n-start;\\n        x = x*(x+1)/2;\\n        ans+=x;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325241,
                "title": "easy-solution-cpp-without-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int cnt=1;\\n        long long ans=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]-1==prices[i+1]){\\n                cnt++;\\n            }\\n            else{\\n                if(cnt>1){\\n                    ans+=(long long)cnt*(cnt+1)/2;\\n                    cnt=1;\\n                }\\n                else{\\n                    ans+=cnt;\\n                }\\n            }\\n        }\\n\\n<!-- considered condition if last elements of an array are descent periods -->\\n        if(cnt>1){\\n            ans+=(long long)cnt*(cnt+1)/2;\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int cnt=1;\\n        long long ans=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]-1==prices[i+1]){\\n                cnt++;\\n            }\\n            else{\\n                if(cnt>1){\\n                    ans+=(long long)cnt*(cnt+1)/2;\\n                    cnt=1;\\n                }\\n                else{\\n                    ans+=cnt;\\n                }\\n            }\\n        }\\n\\n<!-- considered condition if last elements of an array are descent periods -->\\n        if(cnt>1){\\n            ans+=(long long)cnt*(cnt+1)/2;\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2537737,
                "title": "2110-python",
                "content": "\\tclass Solution:\\n\\t\\tdef getDescentPeriods(self, prices: List[int]) -> int:\\n\\t\\t\\tn =  len(prices)\\n\\t\\t\\tdp = [1]*n\\n\\n\\t\\t\\tfor i in range(1,n):\\n\\t\\t\\t\\tif prices[i] +1 == prices[i-1]:\\n\\t\\t\\t\\t\\tdp[i] += dp[i-1]\\n\\n\\t\\t\\treturn sum(dp)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef getDescentPeriods(self, prices: List[int]) -> int:\\n\\t\\t\\tn =  len(prices)\\n\\t\\t\\tdp = [1]*n\\n\\n\\t\\t\\tfor i in range(1,n):\\n\\t\\t\\t\\tif prices[i] +1 == prices[i-1]:\\n\\t\\t\\t\\t\\tdp[i] += dp[i-1]\\n\\n\\t\\t\\treturn sum(dp)",
                "codeTag": "Java"
            },
            {
                "id": 2521086,
                "title": "optimized-java-solution-easy-to-understand",
                "content": "```\\n public long getDescentPeriods(int[] prices) {\\n        long count = prices.length;        //  why length? - becoz each element in given array is counted individually in output.\\n        int start = 0, end = 1;\\n        while(end < prices.length){\\n            \\n            if(prices[end-1] - prices[end] == 1){ \\n                count += end-start;\\n            }\\n            else{\\n                start = end;\\n            }\\n            end++;\\n        }\\n        return count;\\n    }\\n}\\n```\\nTime complexity - O(n).\\nSpace complexity - O(1) - no extra space is used.",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n public long getDescentPeriods(int[] prices) {\\n        long count = prices.length;        //  why length? - becoz each element in given array is counted individually in output.\\n        int start = 0, end = 1;\\n        while(end < prices.length){\\n            \\n            if(prices[end-1] - prices[end] == 1){ \\n                count += end-start;\\n            }\\n            else{\\n                start = end;\\n            }\\n            end++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2430587,
                "title": "4-line-two-pointers-c-o-n-time-o-1-space",
                "content": "\\t\\t\\t\\tlong long getDescentPeriods(vector<int>& prices) {\\n\\t\\t\\t\\t\\tlong long j=0,i=1,cnt=1;\\n\\t\\t\\t\\t\\twhile(i<prices.size()){\\n\\t\\t\\t\\t\\t\\tif(prices[i-1]-prices[i]!=1) j=i;   //if this case is true then reset the value of j to i, so that previous value from prices_array gets excluded from current subarrays count;\\n\\t\\t\\t\\t\\t\\tcnt+=i-j+1; //simply counts number of subarrays\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn cnt;\\n\\t\\t\\t}",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "\\t\\t\\t\\tlong long getDescentPeriods(vector<int>& prices) {\\n\\t\\t\\t\\t\\tlong long j=0,i=1,cnt=1;\\n\\t\\t\\t\\t\\twhile(i<prices.size()){\\n\\t\\t\\t\\t\\t\\tif(prices[i-1]-prices[i]!=1) j=i;   //if this case is true then reset the value of j to i, so that previous value from prices_array gets excluded from current subarrays count;\\n\\t\\t\\t\\t\\t\\tcnt+=i-j+1; //simply counts number of subarrays\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn cnt;\\n\\t\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1987869,
                "title": "java-cleanest-dp-solution",
                "content": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long res = 0;\\n        long pre =1;\\n        for(int i =0;i<prices.length;i++){\\n            long cur = 1;\\n            if(i!=0&&prices[i]==prices[i-1]-1) cur+=pre;\\n            res+=cur;\\n            pre=cur;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long res = 0;\\n        long pre =1;\\n        for(int i =0;i<prices.length;i++){\\n            long cur = 1;\\n            if(i!=0&&prices[i]==prices[i-1]-1) cur+=pre;\\n            res+=cur;\\n            pre=cur;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640854,
                "title": "2110-number-of-smooth-descent-periods-of-a-stock",
                "content": "2110. Number of Smooth Descent Periods of a Stock\\nA smooth descent period of a stock consists of one or more contiguous days such that the price on each day is lower than the price on the preceding day by exactly 1. The first day of the period is exempted from this rule.\\n\\nGiven Example - > [3,2,1,4] == answer is 7\\n\\n1. Simple Oservation is you need to find the longest subarray- that follows the rule\\n     every prices[i+1] - prices[i] == -1 [IN THIS given ex-> 2-3 == -1 and 1-2 == -1]\\n\\t \\n2. I find the longest subarray in this case this is [3,2,1].\\n3. Now from [3,2,1] you generate 3,2 or 2,1 \\n4. simple math if array size n How many subarray you can make n*(n+1)/2\\n\\n**NOW LOOK**\\n**Suppose your array is [7,6,5,4,3,10]**\\nHere [7,6,5,4,3] is a subarray and an [10] single element is always a decreasing subarray\\nfrom [7,6,5,4,3] how many subarray can be make \\n---->for 1 lenght THE NUMBER OF SUBARRAY IS  n(number of element in the array) count of subarray is == 5\\n---->for 2 lenght THE NUMBER OF SUBARRAY IS n-1 ([7,6] , [6,5] , [5,4], [4,3])  Count = 4\\n---->for 3 lenght THE NUMBER OF SUBARRAY IS n-2 ([7,6 , 5] , [6,5 ,4] , [5,4 ,3]) Count = 3\\nand so on till n lenght subarray\\nTOTAL NUMBER OF SUBARRAY IS - > 5+4+3+2+1 FOR 5  LENGTH\\n**NOW the number of total subarray for n length is n*(n+1)/2 **\\n\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        int i = 0 ;\\n        long long ans = 0;\\n         while(i<n){\\n           long long len = 1;\\n           while(i+1 < n && (prices[i+1] - prices[i]) == -1){\\n             i++;\\n             len++;\\n           }\\n           ans+= (len*(len+1))/2;\\n           i++;\\n         }\\n      return ans;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        int i = 0 ;\\n        long long ans = 0;\\n         while(i<n){\\n           long long len = 1;\\n           while(i+1 < n && (prices[i+1] - prices[i]) == -1){\\n             i++;\\n             len++;\\n           }\\n           ans+= (len*(len+1))/2;\\n           i++;\\n         }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637155,
                "title": "c-simplest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        \\n        long long res = n;\\n        int startInd = 0;\\n        \\n        for(int i=1;i<n;i++) {\\n            if(prices[i-1]-prices[i] == 1) res += i - startInd;\\n            else startInd = i;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        \\n        long long res = n;\\n        int startInd = 0;\\n        \\n        for(int i=1;i<n;i++) {\\n            if(prices[i-1]-prices[i] == 1) res += i - startInd;\\n            else startInd = i;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635377,
                "title": "java-dp-simple-and-easy-with-explanation-for-dp-o-n",
                "content": "First we need to understand the following:\\n\\t1. First element can\\'t be compared to previous element, so lets make it as zero\\n\\t2. For the rest of the element we can compare it with the previous element to check if the difference is 1\\n\\t3. we are using DP to see if this pattern continues the we add the previous element value +1 to this DP\\n\\nSo we are maintaining a dp array for this purpose to store whether the number differance with previous number is 1 and if that continues then add that number with previous dp value. Result will be sum of all the values in DP.\\n\\nHope its easy to understand.. Happy learning\\n\\n```\\n    public long getDescentPeriods(int[] prices) {\\n        int len = prices.length;\\n    \\tlong res = len;\\n        int dp[] = new int[len];\\n        dp[0] = 0;\\n        for(int i=1; i<len; i++){\\n        \\tif(prices[i]==prices[i-1]-1)\\n        \\t\\tdp[i]=1;\\n        \\tif(dp[i-1]>0 && dp[i]==1){\\n        \\t\\tdp[i]=dp[i-1]+1;\\n        \\t}\\n        \\tres = res + dp[i];\\n        }\\n    \\treturn res;\\n    }\\n\\t\\n\\t\\n\\t",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "First we need to understand the following:\\n\\t1. First element can\\'t be compared to previous element, so lets make it as zero\\n\\t2. For the rest of the element we can compare it with the previous element to check if the difference is 1\\n\\t3. we are using DP to see if this pattern continues the we add the previous element value +1 to this DP\\n\\nSo we are maintaining a dp array for this purpose to store whether the number differance with previous number is 1 and if that continues then add that number with previous dp value. Result will be sum of all the values in DP.\\n\\nHope its easy to understand.. Happy learning\\n\\n```\\n    public long getDescentPeriods(int[] prices) {\\n        int len = prices.length;\\n    \\tlong res = len;\\n        int dp[] = new int[len];\\n        dp[0] = 0;\\n        for(int i=1; i<len; i++){\\n        \\tif(prices[i]==prices[i-1]-1)\\n        \\t\\tdp[i]=1;\\n        \\tif(dp[i-1]>0 && dp[i]==1){\\n        \\t\\tdp[i]=dp[i-1]+1;\\n        \\t}\\n        \\tres = res + dp[i];\\n        }\\n    \\treturn res;\\n    }\\n\\t\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1635041,
                "title": "java-stack-solution-o-n",
                "content": "```\\npublic long getDescentPeriods(int[] prices) {\\n        Stack<Integer> st = new Stack();\\n        long ans = prices.length;\\n        for(int i = 0; i < prices.length; i++){\\n            if(!st.isEmpty() && st.peek() - 1 == prices[i]){\\n                ans += st.size();\\n            }\\n            else if(!st.isEmpty() && st.peek() - 1 != prices[i]){\\n                while(!st.isEmpty()){\\n                    st.pop();\\n                }\\n            }\\n            st.push(prices[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic long getDescentPeriods(int[] prices) {\\n        Stack<Integer> st = new Stack();\\n        long ans = prices.length;\\n        for(int i = 0; i < prices.length; i++){\\n            if(!st.isEmpty() && st.peek() - 1 == prices[i]){\\n                ans += st.size();\\n            }\\n            else if(!st.isEmpty() && st.peek() - 1 != prices[i]){\\n                while(!st.isEmpty()){\\n                    st.pop();\\n                }\\n            }\\n            st.push(prices[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635032,
                "title": "java-o-n-time-complexity-one-pass-with-short-explanation",
                "content": "```\\nShort idea:\\nWe will find continuous sequence (subarray ) from given array\\nlets say we found [3,2,1]\\ntotal possible combination: [3] [2] [1] [3,2] [2,1] [3,2,1]=6\\nwhich is nothing but (count*(count+1))/2; (here n is 3)\\ncount is lenght of continuous subarray satisfying given condition\\n\\nwhere condition fails we will resent count to 1\\n\\nhere I have not used formula (count*(count+1))/2\\ninstead i added count each time both are accepted\\n```\\n\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] p) {\\n        int n=p.length;\\n        long ans=0;\\n        long count=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(p[i]+1==p[i-1])\\n                count++;\\n            else\\n            {\\n                ans+=(count*(count+1))/2;\\n                count=1;\\n            }\\n        }\\n        ans+=(count*(count+1))/2;\\n        return ans;\\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] p) {\\n        int n=p.length;\\n        long ans=1;\\n        long count=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(p[i]+1==p[i-1])\\n                count++;\\n            else\\n                count=1;\\n            ans+=count;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nShort idea:\\nWe will find continuous sequence (subarray ) from given array\\nlets say we found [3,2,1]\\ntotal possible combination: [3] [2] [1] [3,2] [2,1] [3,2,1]=6\\nwhich is nothing but (count*(count+1))/2; (here n is 3)\\ncount is lenght of continuous subarray satisfying given condition\\n\\nwhere condition fails we will resent count to 1\\n\\nhere I have not used formula (count*(count+1))/2\\ninstead i added count each time both are accepted\\n```\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] p) {\\n        int n=p.length;\\n        long ans=0;\\n        long count=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(p[i]+1==p[i-1])\\n                count++;\\n            else\\n            {\\n                ans+=(count*(count+1))/2;\\n                count=1;\\n            }\\n        }\\n        ans+=(count*(count+1))/2;\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] p) {\\n        int n=p.length;\\n        long ans=1;\\n        long count=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(p[i]+1==p[i-1])\\n                count++;\\n            else\\n                count=1;\\n            ans+=count;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634972,
                "title": "java-o-n-with-explanation",
                "content": "```\\n//Time Complexity: O(n)\\n//Space Complexity: O(n) -> but I believe it can be O(1), because the current dp[i] only have relationship with dp[i - 1]\\n                            //so we only need two variable to store it\\n//where n is length of prices\\n\\nclass Solution {\\n    //We should always check what return type it is first, or you will waste lots of time to find the bug like me....\\n    public long getDescentPeriods(int[] prices) {\\n        //let dp[i] be the number of smooth descent periods end in ith day\\n        long[] dp = new long[prices.length];\\n        long retval = 0;\\n        \\n        for(int i = 0; i < prices.length; i++){ \\n            //all elements themself is smooth descent periods.\\n            dp[i] = 1;\\n            \\n            //if current price is lower than the price on the preceding day by exactly 1\\n            //then we add it(dp[i]) with preceding day dp[i - 1]\\n            //why? Take prices = [5, 4, 3, 2] as an example\\n            //one element itself (5) is smooth descent periods -> 1(itself) -> [5]\\n            //if two elements (5, 4) are smooth descent periods -> 1(itself) + 1(previous) -> [4] + ([5, 4])\\n            //if three elements (5, 4, 3) are smooth descent periods -> 1(itself) + 2(previous) -> [3] + ([4, 3] [5, 4, 3])\\n            //if four elements (5, 4, 3, 2) are smooth descent periods -> 1(itself) + 3(previous) -> [2] + ([3, 2] [4, 3, 2] [5, 4, 3, 2])\\n            //we observe that if it is smooth descent with previous preceding day, we can append current price with previous result\\n            \\n            //if current price is not lower than the preceding day by exactly 1, we will not go into this if condition\\n            //then the current will not have any relationship with previous days anymore\\n            if(i > 0 && (prices[i - 1] - prices[i] == 1)){\\n                dp[i] += dp[i - 1];\\n            }\\n            \\n            //Therefore, retval = 1 + 2 + 3 + 4 = 10\\n            retval += dp[i];\\n        }\\n        \\n        return retval;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Time Complexity: O(n)\\n//Space Complexity: O(n) -> but I believe it can be O(1), because the current dp[i] only have relationship with dp[i - 1]\\n                            //so we only need two variable to store it\\n//where n is length of prices\\n\\nclass Solution {\\n    //We should always check what return type it is first, or you will waste lots of time to find the bug like me....\\n    public long getDescentPeriods(int[] prices) {\\n        //let dp[i] be the number of smooth descent periods end in ith day\\n        long[] dp = new long[prices.length];\\n        long retval = 0;\\n        \\n        for(int i = 0; i < prices.length; i++){ \\n            //all elements themself is smooth descent periods.\\n            dp[i] = 1;\\n            \\n            //if current price is lower than the price on the preceding day by exactly 1\\n            //then we add it(dp[i]) with preceding day dp[i - 1]\\n            //why? Take prices = [5, 4, 3, 2] as an example\\n            //one element itself (5) is smooth descent periods -> 1(itself) -> [5]\\n            //if two elements (5, 4) are smooth descent periods -> 1(itself) + 1(previous) -> [4] + ([5, 4])\\n            //if three elements (5, 4, 3) are smooth descent periods -> 1(itself) + 2(previous) -> [3] + ([4, 3] [5, 4, 3])\\n            //if four elements (5, 4, 3, 2) are smooth descent periods -> 1(itself) + 3(previous) -> [2] + ([3, 2] [4, 3, 2] [5, 4, 3, 2])\\n            //we observe that if it is smooth descent with previous preceding day, we can append current price with previous result\\n            \\n            //if current price is not lower than the preceding day by exactly 1, we will not go into this if condition\\n            //then the current will not have any relationship with previous days anymore\\n            if(i > 0 && (prices[i - 1] - prices[i] == 1)){\\n                dp[i] += dp[i - 1];\\n            }\\n            \\n            //Therefore, retval = 1 + 2 + 3 + 4 = 10\\n            retval += dp[i];\\n        }\\n        \\n        return retval;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009927,
                "title": "c-o-n-solution-simple-intuitive",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) \\n    {\\n        long long ans = 0, num = 1;\\n\\n        for(int i=1; i<prices.size(); i++)\\n        {\\n            if(prices[i] - prices[i-1] == -1) ++num;\\n            else\\n            {\\n                ans += num * (num+1) / 2;\\n                num = 1;\\n            }\\n        }\\n\\n        ans += num * (num+1) / 2;\\n\\n        return ans == 0 ? 1: ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) \\n    {\\n        long long ans = 0, num = 1;\\n\\n        for(int i=1; i<prices.size(); i++)\\n        {\\n            if(prices[i] - prices[i-1] == -1) ++num;\\n            else\\n            {\\n                ans += num * (num+1) / 2;\\n                num = 1;\\n            }\\n        }\\n\\n        ans += num * (num+1) / 2;\\n\\n        return ans == 0 ? 1: ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926472,
                "title": "most-easy-to-understand-solution-just-do-a-dry-runp",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSlidingwindow +twopointer\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<int> diff(n, 0);\\n\\n        // Calculate the price differences between consecutive days\\n        for (int i = 1; i < n; i++) {\\n            diff[i] = prices[i - 1] - prices[i];\\n        }\\n\\n        int i = 0, j = 0;\\n        long long count = 0, ans = 0;\\n\\n        // Iterate through the price differences\\n        while (j < n) {\\n            if (diff[j] != 1) {\\n                // If the difference is not 1, it breaks the smooth descent period\\n                count = 0;          // Reset the count for the new period\\n                ans += 1;           // Increment the answer for this non-smooth day\\n                i = j;              // Set i to the current position as the start of a new potential period\\n            } else {\\n                // If the difference is 1, it continues a smooth descent period\\n                count = j - i + 1;  // Increment the count for the current smooth period\\n                ans += count;       // Add the count to the answer\\n            }\\n            j++;                    // Move to the next day\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<int> diff(n, 0);\\n\\n        // Calculate the price differences between consecutive days\\n        for (int i = 1; i < n; i++) {\\n            diff[i] = prices[i - 1] - prices[i];\\n        }\\n\\n        int i = 0, j = 0;\\n        long long count = 0, ans = 0;\\n\\n        // Iterate through the price differences\\n        while (j < n) {\\n            if (diff[j] != 1) {\\n                // If the difference is not 1, it breaks the smooth descent period\\n                count = 0;          // Reset the count for the new period\\n                ans += 1;           // Increment the answer for this non-smooth day\\n                i = j;              // Set i to the current position as the start of a new potential period\\n            } else {\\n                // If the difference is 1, it continues a smooth descent period\\n                count = j - i + 1;  // Increment the count for the current smooth period\\n                ans += count;       // Add the count to the answer\\n            }\\n            j++;                    // Move to the next day\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914551,
                "title": "c-super-easy-clean-code-simulation-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int i=0;\\n        int n = prices.size();\\n        long long ans = 0;\\n        while(i < n){\\n            int len = 1;\\n            while(i+1 < n && prices[i]-prices[i+1] == 1){\\n                len++;\\n                i++;\\n            }\\n            ans += 1LL*(len+1)*len/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int i=0;\\n        int n = prices.size();\\n        long long ans = 0;\\n        while(i < n){\\n            int len = 1;\\n            while(i+1 < n && prices[i]-prices[i+1] == 1){\\n                len++;\\n                i++;\\n            }\\n            ans += 1LL*(len+1)*len/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790998,
                "title": "c-using-two-pointers-sliding-window-t-c-o-n-s-c-o-1",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(1)\\n    */\\n    \\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long res = 0, start = 0, end = 0;\\n        \\n        while(end < prices.size()){\\n            if(end > 0 && prices[end-1]-1 != prices[end]){\\n                start = end;\\n            }\\n            \\n            res += (end-start+1);\\n            end++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(1)\\n    */\\n    \\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long res = 0, start = 0, end = 0;\\n        \\n        while(end < prices.size()){\\n            if(end > 0 && prices[end-1]-1 != prices[end]){\\n                start = end;\\n            }\\n            \\n            res += (end-start+1);\\n            end++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327810,
                "title": "simple-sliding-window-c-tc-o-n-sc-o-1",
                "content": "\\n# Approach\\nTwo variables i,j (namely) to track the size of the window , whenever a difference of 1 is found while checking the current value ( j ) and its previous value ( j-1 ) , the window size is added to the answer (  ans+= j-i+1  ) . Else we make our window size equal to the current j ( i = j ) and add 1 to our answer (since size 1 is also included) . \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using ll  = long long ; \\n    long long getDescentPeriods(vector<int>& prices) {\\n        ll diff=0;\\n        ll n = prices.size();\\n        ll i=0,j=0,ans=0;\\n\\n        while(j<n)\\n        {\\n\\n            ll diff = 1;\\n            if(j>=1)diff= prices[j-1]-prices[j];\\n\\n            if(diff==1)\\n            {\\n               ans+=(j-i+1);\\n            }\\n            else \\n            {\\n                i=j;\\n                ans+=1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll  = long long ; \\n    long long getDescentPeriods(vector<int>& prices) {\\n        ll diff=0;\\n        ll n = prices.size();\\n        ll i=0,j=0,ans=0;\\n\\n        while(j<n)\\n        {\\n\\n            ll diff = 1;\\n            if(j>=1)diff= prices[j-1]-prices[j];\\n\\n            if(diff==1)\\n            {\\n               ans+=(j-i+1);\\n            }\\n            else \\n            {\\n                i=j;\\n                ans+=1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294358,
                "title": "11-lines-java-no-dp-no-extra-space-easy-to-understand-simple",
                "content": "**Self Explanatory code below with comments :) \\nconsidering upvoting if you liked the approach!!**\\n# Code\\n```\\nclass Solution {\\n    public long myWay(int[] prices)\\n    {\\n        //simply take the length of each smooth descent period and get the number of subarrays from it\\n        //added into the count of the total number of smooth periods...and take length = 1 in case we don\\'t\\n        //have 2 value such that prev > next.... so that the current (prev) is counted at least because a single\\n        //element is considered as a smooth period too\\n        long count = 0;\\n        int n = prices.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            int len = 1;//for current index\\n            int j = i;\\n            while(j+1<n && prices[j]-prices[j+1] == 1) j++;\\n            if(j!=i)\\n            {\\n                 len = j-i+1;\\n                 i = j;\\n            }\\n            // System.out.println(len+\" and \"+j);\\n            count += 1l*len*(len*1l+1)/2*1l;\\n        }\\n        return count;\\n    }\\n    public long getDescentPeriods(int[] prices) {\\n        return myWay(prices);//Tc->o(n) and s->o(1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public long myWay(int[] prices)\\n    {\\n        //simply take the length of each smooth descent period and get the number of subarrays from it\\n        //added into the count of the total number of smooth periods...and take length = 1 in case we don\\'t\\n        //have 2 value such that prev > next.... so that the current (prev) is counted at least because a single\\n        //element is considered as a smooth period too\\n        long count = 0;\\n        int n = prices.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            int len = 1;//for current index\\n            int j = i;\\n            while(j+1<n && prices[j]-prices[j+1] == 1) j++;\\n            if(j!=i)\\n            {\\n                 len = j-i+1;\\n                 i = j;\\n            }\\n            // System.out.println(len+\" and \"+j);\\n            count += 1l*len*(len*1l+1)/2*1l;\\n        }\\n        return count;\\n    }\\n    public long getDescentPeriods(int[] prices) {\\n        return myWay(prices);//Tc->o(n) and s->o(1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232865,
                "title": "c-simple-o-n-time-one-pass",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    long long getDescentPeriods(vector<int> &nums)\\n    {\\n        long long count = 1;\\n        int l = 0;\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            if (nums[i] + 1 != nums[i - 1])\\n            {\\n                l = i;\\n                count++;\\n            }\\n            else count += i - l + 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    long long getDescentPeriods(vector<int> &nums)\\n    {\\n        long long count = 1;\\n        int l = 0;\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            if (nums[i] + 1 != nums[i - 1])\\n            {\\n                l = i;\\n                count++;\\n            }\\n            else count += i - l + 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139698,
                "title": "easy-cpp-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long ans=0;\\n        long long ct=1;\\n        int prev=prices[0];\\n\\n        for(int i=1;i<prices.size();i++){\\n            if(prices[i]-prev!=-1){\\n               \\n                long long sum=0;\\n                if(ct%2==0){\\n                    sum=ct/2;\\n                    sum=sum*(ct+1);\\n                }\\n\\n                else{\\n                    sum=(ct+1)/2;\\n                    sum=sum*ct;\\n                }\\n                ans+=sum;\\n\\n                ct=0;\\n            }\\n\\n            prev=prices[i];\\n            ct++;\\n        }\\n\\n        \\n            long long sum=0;\\n                if(ct%2==0){\\n                    sum=ct/2;\\n                    sum=sum*(ct+1);\\n                }\\n\\n                else{\\n                    sum=(ct+1)/2;\\n                    sum=sum*ct;\\n                }\\n                ans+=sum;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long ans=0;\\n        long long ct=1;\\n        int prev=prices[0];\\n\\n        for(int i=1;i<prices.size();i++){\\n            if(prices[i]-prev!=-1){\\n               \\n                long long sum=0;\\n                if(ct%2==0){\\n                    sum=ct/2;\\n                    sum=sum*(ct+1);\\n                }\\n\\n                else{\\n                    sum=(ct+1)/2;\\n                    sum=sum*ct;\\n                }\\n                ans+=sum;\\n\\n                ct=0;\\n            }\\n\\n            prev=prices[i];\\n            ct++;\\n        }\\n\\n        \\n            long long sum=0;\\n                if(ct%2==0){\\n                    sum=ct/2;\\n                    sum=sum*(ct+1);\\n                }\\n\\n                else{\\n                    sum=(ct+1)/2;\\n                    sum=sum*ct;\\n                }\\n                ans+=sum;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877810,
                "title": "80-faster-linear-solution-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long int ans = 1, cnt = 1;\\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] == prices[i-1]-1){\\n                cnt++;\\n            }else{\\n                cnt = 1;\\n            }\\n            ans += cnt;\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long int ans = 1, cnt = 1;\\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] == prices[i-1]-1){\\n                cnt++;\\n            }else{\\n                cnt = 1;\\n            }\\n            ans += cnt;\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2856015,
                "title": "java-solution-o-n-time-o-1-space-3ms-runtime-faster-than-92",
                "content": "```java \\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long c=1;\\n        int i=0;\\n        for(int j=1;j<prices.length;j++)\\n        {\\n            if(prices[j]!=prices[j-1]-1)\\n                i=j;\\n            c+=j-i+1;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long c=1;\\n        int i=0;\\n        for(int j=1;j<prices.length;j++)\\n        {\\n            if(prices[j]!=prices[j-1]-1)\\n                i=j;\\n            c+=j-i+1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2644813,
                "title": "simple-solution-using-arithmethic-progression-o-n-time-and-o-1-space",
                "content": "Approach:\\n1) The answer is initialized to 0.\\n2) Traverse the array while keeping track of the smooth descent so far (stock 1 less than the previous day).\\n3) Suppose the smooth descent is <b>n</b> at some point we add (1 + 2 + ... + <b>n</b>) to the ans.\\n\\nIntuition:\\n* Lets say we have the numbers <b>[4, 3, 2, 1, 5]</b> as input.\\n* We traverse the array and at index 3 we have the smooth descent value = 4 i.e. the first four numbers - <b>4, 3, 2, 1</b>\\n* The ans till this point should include:\\n<b>\\n[4, 3, 2, 1], \\n[4, 3, 2], [3, 2, 1], \\n[4, 3], [3, 2], [2, 1]\\n[4], [3], [2], [1]\\n</b><br>\\n* Essentially, 1 of size(4), 2 of size(3), 3 of size(2) and 4 of size(1) i.e.  answer += <b>1 + 2 + 3 + 4</b>\\n* Finally the last value 5 has smooth descent of 1, which will add another <b>1</b> to the answer.\\n\\nHelper:\\n* To calculate the sum for <b>n</b> natural numbers we can use the following arithmetic formula.\\n\\n\\t<b>1 + 2 + ... + n = <sup>n * (n+1)</sup>&frasl;<sub>2</sub> \\n\\n```\\nclass Solution(object):\\n\\t#sum of n natural numbers\\n    def ap(self, n):\\n        return n * (n+1) // 2\\n    \\n    def getDescentPeriods(self, prices):\\n        count = 1 \\n        n = len(prices)\\n        ans = 0\\n        for i in range(1, n):\\n            if prices[i] - prices[i-1] == -1:\\n                count += 1\\n            else:\\n                ans += self.ap(count)\\n                count = 1\\n        ans += self.ap(count)\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "Approach:\\n1) The answer is initialized to 0.\\n2) Traverse the array while keeping track of the smooth descent so far (stock 1 less than the previous day).\\n3) Suppose the smooth descent is <b>n</b> at some point we add (1 + 2 + ... + <b>n</b>) to the ans.\\n\\nIntuition:\\n* Lets say we have the numbers <b>[4, 3, 2, 1, 5]</b> as input.\\n* We traverse the array and at index 3 we have the smooth descent value = 4 i.e. the first four numbers - <b>4, 3, 2, 1</b>\\n* The ans till this point should include:\\n<b>\\n[4, 3, 2, 1], \\n[4, 3, 2], [3, 2, 1], \\n[4, 3], [3, 2], [2, 1]\\n[4], [3], [2], [1]\\n</b><br>\\n* Essentially, 1 of size(4), 2 of size(3), 3 of size(2) and 4 of size(1) i.e.  answer += <b>1 + 2 + 3 + 4</b>\\n* Finally the last value 5 has smooth descent of 1, which will add another <b>1</b> to the answer.\\n\\nHelper:\\n* To calculate the sum for <b>n</b> natural numbers we can use the following arithmetic formula.\\n\\n\\t<b>1 + 2 + ... + n = <sup>n * (n+1)</sup>&frasl;<sub>2</sub> \\n\\n```\\nclass Solution(object):\\n\\t#sum of n natural numbers\\n    def ap(self, n):\\n        return n * (n+1) // 2\\n    \\n    def getDescentPeriods(self, prices):\\n        count = 1 \\n        n = len(prices)\\n        ans = 0\\n        for i in range(1, n):\\n            if prices[i] - prices[i-1] == -1:\\n                count += 1\\n            else:\\n                ans += self.ap(count)\\n                count = 1\\n        ans += self.ap(count)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2550704,
                "title": "c-o-n-solution-without-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {//vector of int\\n        if(prices.size()==1) return 1;\\n        long long ans=0,len=1;int temp=prices[0];\\n        for(int i=1;i<prices.size();i++){\\n            if(prices[i]==temp-1) len++;\\n            else{ ans+=((len*(len+1))/2);  len=1;}\\n            temp=prices[i];\\n        }\\n         ans+=((len*(len+1))/2);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {//vector of int\\n        if(prices.size()==1) return 1;\\n        long long ans=0,len=1;int temp=prices[0];\\n        for(int i=1;i<prices.size();i++){\\n            if(prices[i]==temp-1) len++;\\n            else{ ans+=((len*(len+1))/2);  len=1;}",
                "codeTag": "Java"
            },
            {
                "id": 2366436,
                "title": "c-simple-solution-two-pointer-approach-in-o-n-time-o-1-space",
                "content": "**Idea:**\\nUse a 2-pointer approach to traverse the array and find each longest possible period.let the longest possible period is k. then add **(k(k+1))/2**  to the ans.\\n\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n=prices.size();\\n        long long ans=0;\\n        int i=0;\\n        long long int k=1;\\n        for(int j=1; j<n; j++)\\n        {\\n            if(prices[j]==prices[i]-1)\\n                k++;\\n            else\\n            {\\n                ans+=(k*(k+1))/2;\\n                k=1;  \\n            }\\n            i++;\\n        }\\n        ans+=(k*(k+1))/2;// add the last longest possible period.\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n=prices.size();\\n        long long ans=0;\\n        int i=0;\\n        long long int k=1;\\n        for(int j=1; j<n; j++)\\n        {\\n            if(prices[j]==prices[i]-1)\\n                k++;\\n            else\\n            {\\n                ans+=(k*(k+1))/2;\\n                k=1;  \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2340132,
                "title": "c-easy-iteration",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long res=0;\\n        int t=1;\\n        for(int i=0;i<prices.size();i++)\\n        {\\n            while(i<prices.size()-1 && prices[i]==prices[i+1]+1)\\n            {\\n                t++;\\n                i++;\\n            }\\n            res+=fun(t);\\n            t=1;\\n        }\\n        return res;\\n    }\\n    long long fun(int t)\\n    {\\n        long long res=t;\\n        res=res*(res+1)/2;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long res=0;\\n        int t=1;\\n        for(int i=0;i<prices.size();i++)\\n        {\\n            while(i<prices.size()-1 && prices[i]==prices[i+1]+1)\\n            {\\n                t++;\\n                i++;\\n            }\\n            res+=fun(t);\\n            t=1;\\n        }\\n        return res;\\n    }\\n    long long fun(int t)\\n    {\\n        long long res=t;\\n        res=res*(res+1)/2;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296898,
                "title": "c-easy-understanding-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices)\\n    {\\n        int n=prices.size();\\n        vector<long long>dp(n,1);\\n        long long ans=0;\\n        ans+=dp[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(prices[i]==prices[i-1]-1)\\n            {\\n                dp[i]=dp[i]+dp[i-1];\\n            }\\n            ans+=dp[i];\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices)\\n    {\\n        int n=prices.size();\\n        vector<long long>dp(n,1);\\n        long long ans=0;\\n        ans+=dp[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(prices[i]==prices[i-1]-1)\\n            {\\n                dp[i]=dp[i]+dp[i-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2290320,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        int j = 1;\\n        long long res = 1, ans = 1;\\n       for(int j = 1; j < n; j++){\\n            if(prices[j-1] - prices[j] == 1)\\n                res++;\\n            else res = 1;\\n            ans += res;\\n        }\\n        return ans;\\n    }\\n};\\n```\\napproach:\\n3 2 1 4\\nj = 1 (0 based indexing)\\nres = 1\\nans = 1\\nwhen the condition satisfies, then\\n3-2 == 1\\nres = 2 ==> 2, [3,2]\\n\\nans = 3 ==>[3],[2],[3,2]\\n\\nthen the condtion for (2-1) == 1 also satisfies\\nres = 3==> [1],[2,1],[3,2,1]\\n\\nans = 6 ==> [3],[2],[3,2],[1],[2,1],[3,2,1]\\n\\nthen 4 does not satisfy so the descent breaks and res = 1.\\n\\nans = 7 [3],[2],[3,2],[1],[2,1],[3,2,1],[4]\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        int j = 1;\\n        long long res = 1, ans = 1;\\n       for(int j = 1; j < n; j++){\\n            if(prices[j-1] - prices[j] == 1)\\n                res++;\\n            else res = 1;\\n            ans += res;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281969,
                "title": "java-sliding-window-straightforward",
                "content": "Thanks for dropping-by...\\n\\nPls upvote if it\\'s useful to you ! :-)\\n\\n\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int windowStart=0;\\n        int n=prices.length;\\n        long count=0;\\n        \\n        for(int windowEnd=0; windowEnd<n; windowEnd++) {\\n            \\n            if(windowEnd > 0 && prices[windowEnd-1] != prices[windowEnd]+1) //shrink window\\n                windowStart=windowEnd;\\n            \\n            count += windowEnd-windowStart+1; //continue counting\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int windowStart=0;\\n        int n=prices.length;\\n        long count=0;\\n        \\n        for(int windowEnd=0; windowEnd<n; windowEnd++) {\\n            \\n            if(windowEnd > 0 && prices[windowEnd-1] != prices[windowEnd]+1) //shrink window\\n                windowStart=windowEnd;\\n            \\n            count += windowEnd-windowStart+1; //continue counting\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280250,
                "title": "best-solution-for-this-question",
                "content": "class Solution {\\n    public long getDescentPeriods(int[] prices) {\\n         long dp[]=new long[prices.length];\\n        dp[0]=0;\\n        int n=prices.length;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(i==1&&(prices[i-1]-prices[i])==1)\\n            {\\n                 dp[i]=1;\\n            }\\n           else if((prices[i-1]-prices[i])==1&&i>=2)\\n            {\\n                if(prices[i-2]-prices[i-1]==1)\\n                  dp[i]=1+2*dp[i-1]-dp[i-2];\\n               else\\n                    dp[i]=1+2*dp[i-1];\\n            }\\n            else if((prices[i-1]-prices[i])!=1)\\n            {\\n                dp[i]=0;\\n            }\\n        }\\n        int flag=1;\\n        long s=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(flag==1&&dp[i]>0)\\n            {\\n                flag=0;\\n                s=s+dp[i];\\n            }\\n            else if(dp[i]==0)\\n            {\\n                flag=1;\\n            }\\n        }\\n        System.out.println(s);\\n        return s+n;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public long getDescentPeriods(int[] prices) {\\n         long dp[]=new long[prices.length];\\n        dp[0]=0;\\n        int n=prices.length;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(i==1&&(prices[i-1]-prices[i])==1)\\n            {\\n                 dp[i]=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2188319,
                "title": "c-easy-solution-o-n-in-o-1-space-sliding-window",
                "content": "long long getDescentPeriods(vector<int>& p) {\\n        \\n        long long res=0;\\n        \\n        \\n        int i=0,j=1;\\n        while(j<p.size())\\n        {\\n            if(p[j-1]-p[j]==1)\\n            {\\n                res+=(j-i);\\n                ++j;\\n            }\\n            else\\n            {\\n                i=j;\\n                ++j;\\n            }\\n        }\\n        res+=p.size();\\n        return res;\\n}",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "long long getDescentPeriods(vector<int>& p) {\\n        \\n        long long res=0;\\n        \\n        \\n        int i=0,j=1;\\n        while(j<p.size())\\n        {\\n            if(p[j-1]-p[j]==1)\\n            {\\n                res+=(j-i);\\n                ++j;\\n            }\\n            else\\n            {\\n                i=j;\\n                ++j;\\n            }\\n        }\\n        res+=p.size();\\n        return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2161875,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def getDescentPeriods(self, A):\\n        res = count = 1\\n        for i in range(1,len(A)):\\n            if A[i] == A[i-1] - 1: count += 1\\n            else: count = 1\\n            res += count\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getDescentPeriods(self, A):\\n        res = count = 1\\n        for i in range(1,len(A)):\\n            if A[i] == A[i-1] - 1: count += 1\\n            else: count = 1\\n            res += count\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157128,
                "title": "c-east-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int i, l = prices.size();\\n        long long s=l,c;\\n        for(int i=0; i<l-1; ++i){\\n            c=0;\\n            while(i+1<l && prices[i]-prices[i+1]==1){\\n                c++;\\n                i++;\\n            }\\n            s += (c+1)*c/2;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int i, l = prices.size();\\n        long long s=l,c;\\n        for(int i=0; i<l-1; ++i){\\n            c=0;\\n            while(i+1<l && prices[i]-prices[i+1]==1){\\n                c++;\\n                i++;\\n            }\\n            s += (c+1)*c/2;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925904,
                "title": "c-3-liner-solution-o-n",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long getDescentPeriods(vector<int>& prices) {\\n\\t\\t\\tlong long result = 0;\\n\\t\\t\\tfor(int start=1,prev = 0;i<size(prices);start++) \\n\\t\\t\\t\\tprices[start-1]-prices[start]==1? result+=(start-prev):prev = start;\\n\\t\\t\\treturn result + prices.size();\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long getDescentPeriods(vector<int>& prices) {\\n\\t\\t\\tlong long result = 0;\\n\\t\\t\\tfor(int start=1,prev = 0;i<size(prices);start++) \\n\\t\\t\\t\\tprices[start-1]-prices[start]==1? result+=(start-prev):prev = start;\\n\\t\\t\\treturn result + prices.size();\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1914560,
                "title": "top-down-and-bottom-up-approach-o-n",
                "content": "### Approach 1: Recursion with Memoization (Top-Down DP)\\n```\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        def dp(i):\\n            if i == 0:\\n                return 1, 1, prices[0]\\n            count, prev_descent_len, prev_price = dp(i-1)\\n            if prices[i] == prev_price - 1:\\n                descent_len = prev_descent_len + 1\\n            else:\\n                descent_len = 1\\n            return count + descent_len, descent_len, prices[i]\\n        return dp( len(prices)-1 )[0]\\n```\\n***Time-Complexity : O(N)\\nSpace-Complexity : O(N)***\\n\\n### Approach 2: Tabulation (Bottom-Up DP)\\n```\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        dp = [1] * len(prices)\\n        for i in range(len(prices)-2,-1,-1):\\n            if prices[i] == prices[i+1]+1:\\n                dp[i] = dp[i+1] + 1\\n        return sum(dp)\\n```\\n***Time-Complexity : O(N)\\nSpace-Complexity : O(N)***\\n\\n### Approach 3:  Without extra space (Bottom-Up DP)\\n```\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        res = dp = 1\\n        for i in range(len(prices)-2,-1,-1):\\n            if prices[i] == prices[i+1]+1: dp+=1\\n            else: dp=1\\n            res+=dp\\n        return res\\n```\\n***Time-Complexity : O(N)\\nSpace-Complexity : O(1)***\\n\\n\\n\\nIf you have any question, feel free to ask. If you like the explanations, please Upvote!! \\uD83D\\uDE01",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        def dp(i):\\n            if i == 0:\\n                return 1, 1, prices[0]\\n            count, prev_descent_len, prev_price = dp(i-1)\\n            if prices[i] == prev_price - 1:\\n                descent_len = prev_descent_len + 1\\n            else:\\n                descent_len = 1\\n            return count + descent_len, descent_len, prices[i]\\n        return dp( len(prices)-1 )[0]\\n```\n```\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        dp = [1] * len(prices)\\n        for i in range(len(prices)-2,-1,-1):\\n            if prices[i] == prices[i+1]+1:\\n                dp[i] = dp[i+1] + 1\\n        return sum(dp)\\n```\n```\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        res = dp = 1\\n        for i in range(len(prices)-2,-1,-1):\\n            if prices[i] == prices[i+1]+1: dp+=1\\n            else: dp=1\\n            res+=dp\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1903845,
                "title": "python-simple-and-faster-than-86",
                "content": "Two pointers solution\\n\\n```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        cnt = len(prices)\\n        start = 0\\n        while start < len(prices):\\n            end = start + 1\\n            while end < len(prices) and prices[end] == prices[end-1] - 1:\\n                end = end + 1\\n                \\n            cnt = cnt +(end - start) *(end-start -1) // 2\\n            start = end\\n            \\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        cnt = len(prices)\\n        start = 0\\n        while start < len(prices):\\n            end = start + 1\\n            while end < len(prices) and prices[end] == prices[end-1] - 1:\\n                end = end + 1\\n                \\n            cnt = cnt +(end - start) *(end-start -1) // 2\\n            start = end\\n            \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818626,
                "title": "simple-python-linear-tc-sc-o-1-easy-to-understand",
                "content": "\\t #class Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        total_count=0\\n        \\n        \\n        long_descent=0 # it store current descent period length\\n        \\n        for i in range(1,len(prices)):\\n            if prices[i]+1==prices[i-1]:\\n                long_descent+=1\\n            else:\\n                sub_array=long_descent*(long_descent+1)//2 # calculating total subarray possible\\n                total_count+=sub_array\\n                long_descent=0\\n        \\n        if long_descent!=0:\\n            sub_array=long_descent*(long_descent+1)//2\\n            total_count+=sub_array\\n        \\n        return total_count+len(prices) # including array of length 1\\n            \\n",
                "solutionTags": [],
                "code": "\\t #class Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        total_count=0\\n        \\n        \\n        long_descent=0 # it store current descent period length\\n        \\n        for i in range(1,len(prices)):\\n            if prices[i]+1==prices[i-1]:\\n                long_descent+=1\\n            else:\\n                sub_array=long_descent*(long_descent+1)//2 # calculating total subarray possible\\n                total_count+=sub_array\\n                long_descent=0\\n        \\n        if long_descent!=0:\\n            sub_array=long_descent*(long_descent+1)//2\\n            total_count+=sub_array\\n        \\n        return total_count+len(prices) # including array of length 1\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1764575,
                "title": "dp-c-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<int64> dp(n, 1L);\\n        dp[0] = 1;\\n        // dp[i] = no. of smooth descent ending at index i\\n        for(int i = 1; i < n; i++) {\\n            if(prices[i] == prices[i - 1] - 1) {\\n                dp[i] += dp[i - 1];\\n            }\\n        }\\n        int64 ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            ans += dp[i];\\n        }\\n        return ans;;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<int64> dp(n, 1L);\\n        dp[0] = 1;\\n        // dp[i] = no. of smooth descent ending at index i\\n        for(int i = 1; i < n; i++) {\\n            if(prices[i] == prices[i - 1] - 1) {\\n                dp[i] += dp[i - 1];\\n            }\\n        }\\n        int64 ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            ans += dp[i];\\n        }\\n        return ans;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722154,
                "title": "javascript-easy-fast-o-n",
                "content": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar getDescentPeriods = function (prices) {\\n\\tlet result = 0\\n\\tlet n = 1\\n\\tfor (let i = 0; i < prices.length; i++) {\\n\\t\\tif (prices[i] === prices[i + 1] + 1) n++\\n\\t\\telse {\\n\\t\\t\\tresult += (n * (n + 1)) / 2\\n\\t\\t\\tn = 1\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar getDescentPeriods = function (prices) {\\n\\tlet result = 0\\n\\tlet n = 1\\n\\tfor (let i = 0; i < prices.length; i++) {\\n\\t\\tif (prices[i] === prices[i + 1] + 1) n++\\n\\t\\telse {\\n\\t\\t\\tresult += (n * (n + 1)) / 2\\n\\t\\t\\tn = 1\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1708668,
                "title": "python-sliding-window-o-n-simple",
                "content": "```python\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        start, end = 0, 0\\n        \\n        smooth = 0\\n        while end < len(prices):\\n            if end > 0 and prices[end-1] - prices[end] != 1:\\n                start = end\\n            smooth += end - start + 1\\n            end += 1\\n        return smooth\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        start, end = 0, 0\\n        \\n        smooth = 0\\n        while end < len(prices):\\n            if end > 0 and prices[end-1] - prices[end] != 1:\\n                start = end\\n            smooth += end - start + 1\\n            end += 1\\n        return smooth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691807,
                "title": "java-solution-o-n",
                "content": "```\\n\\nclass Solution {\\n  public  long getDescentPeriods(int[] prices) {\\n        long count = 1;\\n        long k = 1;\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i] == prices[i - 1] - 1) {\\n                k++;\\n                count += k;\\n            } else {\\n                ++count;\\n                k = 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n  public  long getDescentPeriods(int[] prices) {\\n        long count = 1;\\n        long k = 1;\\n\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i] == prices[i - 1] - 1) {\\n                k++;\\n                count += k;\\n            } else {\\n                ++count;\\n                k = 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650184,
                "title": "sliding-window-o-n-best-solution",
                "content": "```\\nint n=p.size();\\n        long long count=n,i=0,j=1;\\n        while(j<n){\\n            if(p[j-1]-p[j]==1) count+=j-i;\\n            else i=j;\\n            j++;\\n        }\\n        return count;\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nint n=p.size();\\n        long long count=n,i=0,j=1;\\n        while(j<n){\\n            if(p[j-1]-p[j]==1) count+=j-i;\\n            else i=j;\\n            j++;\\n        }\\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1644148,
                "title": "simple-o-n-solution-maths-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        vector<long long> vp;\\n        long long n = prices.size();\\n\\t    for(int i=0;i<n-1;i++){\\n\\t\\t    if(prices[i]==prices[i+1]+1){\\n\\t\\t\\t    int count = 1; \\n\\t\\t\\t    while(i<n-1&&prices[i]==prices[i+1]+1){\\n\\t\\t\\t\\t    count++;\\n\\t\\t\\t\\t    i++;\\n\\t\\t\\t    }   vp.push_back(count);\\n\\t\\t    }\\n\\t    }\\n\\t    long long sm = n;\\n\\t    for(auto e:vp) sm+= (e*(e+1))/2 - e;\\n\\t    return sm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        vector<long long> vp;\\n        long long n = prices.size();\\n\\t    for(int i=0;i<n-1;i++){\\n\\t\\t    if(prices[i]==prices[i+1]+1){\\n\\t\\t\\t    int count = 1; \\n\\t\\t\\t    while(i<n-1&&prices[i]==prices[i+1]+1){\\n\\t\\t\\t\\t    count++;\\n\\t\\t\\t\\t    i++;\\n\\t\\t\\t    }   vp.push_back(count);\\n\\t\\t    }\\n\\t    }\\n\\t    long long sm = n;\\n\\t    for(auto e:vp) sm+= (e*(e+1))/2 - e;\\n\\t    return sm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641154,
                "title": "python-easy-o-1-space-and-o-n-time-explained",
                "content": "***Explaination:***\\n1. All the prices individually will follow the criteria, So we will start our answer with the length of the array.\\n2. Now traverse the **prices** and find the length of the subarray that is strictly decreasing by **1unit** ie (prices[i] - prices[i+1] == 1)\\n3. When the above condition fails we simply calculate the number of subarray that can be formed with that length. We can use **c * (c+1) // 2** formula to calculate the number of subarrays. But we have already included all the individuals at the start, so we have to remove individuals from the formula, So our resultant formula will be **(c * (c+1)) // 2 - c**\\n4. when we traversed all the prices, we will again find the subarray, because their might be a subarray that was continously decreasing till the end.\\n\\n***Hope I am able to explain it well***\\n\\n```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        \\n        \\n        def count_subarrays(c):\\n            return (c * (c+1)) // 2 - c\\n            \\n        ans = n = len(prices)\\n        c = 1\\n        \\n        for i in range(n-1):\\n            if prices[i] - prices[i+1] == 1: c += 1\\n            else:\\n                ans += count_subarrays(c)\\n                c = 1\\n        ans += count_subarrays(c)\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        \\n        \\n        def count_subarrays(c):\\n            return (c * (c+1)) // 2 - c\\n            \\n        ans = n = len(prices)\\n        c = 1\\n        \\n        for i in range(n-1):\\n            if prices[i] - prices[i+1] == 1: c += 1\\n            else:\\n                ans += count_subarrays(c)\\n                c = 1\\n        ans += count_subarrays(c)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641078,
                "title": "o-n-java-simple-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int l = prices.length;\\n        long[] count = new long[l]; //count[i] is the number of periods ending at index i.\\n        Arrays.fill(count,1l); // a single index by its own is a valid period\\n\\t\\t\\n        //count[i] is the number of periods ending at index i.\\n\\t\\t\\n        for(int i = 1;i<l;i++){\\n            if(prices[i-1]-prices[i]==1) // if condition is met, there are count[i-1] possible periods ending at index i. hence add them all into count[i]\\n                count[i]+=count[i-1];\\n        }\\n        \\n\\t\\t\\n\\t\\t// aggregate and return.\\n        long ans = 0;\\n        for(int i =0;i<l;i++){\\n            ans+=count[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int l = prices.length;\\n        long[] count = new long[l]; //count[i] is the number of periods ending at index i.\\n        Arrays.fill(count,1l); // a single index by its own is a valid period\\n\\t\\t\\n        //count[i] is the number of periods ending at index i.\\n\\t\\t\\n        for(int i = 1;i<l;i++){\\n            if(prices[i-1]-prices[i]==1) // if condition is met, there are count[i-1] possible periods ending at index i. hence add them all into count[i]\\n                count[i]+=count[i-1];\\n        }\\n        \\n\\t\\t\\n\\t\\t// aggregate and return.\\n        long ans = 0;\\n        for(int i =0;i<l;i++){\\n            ans+=count[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639525,
                "title": "c-o-n-o-1-space-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long ans=0,cnt=0;\\n        \\n        int n=prices.size();\\n        for(int i=0; i<n-1; i++)\\n        {\\n            if(prices[i]-prices[i+1]==1)\\n                cnt++;\\n            else\\n            {\\n                ans+=cnt*(cnt+1)/2;\\n                cnt=0;\\n            }\\n        }\\n        \\n        if(cnt!=0)\\n            ans+=cnt*(cnt+1)/2;\\n        \\n        ans+=n;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long ans=0,cnt=0;\\n        \\n        int n=prices.size();\\n        for(int i=0; i<n-1; i++)\\n        {\\n            if(prices[i]-prices[i+1]==1)\\n                cnt++;\\n            else\\n            {\\n                ans+=cnt*(cnt+1)/2;\\n                cnt=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1638770,
                "title": "very-easy-to-understand-o-n",
                "content": "long long getDescentPeriods(vector<int>& prices) {\\n\\n        //Creating a vector to hold all the lengths of descent periods\\n\\t\\t//for example for prices = [3,2,1,4], vector is going to be v = [3,1]\\n\\t\\t//for example for prices = [8,6,7,7], vector is going to be v = [1,1,1,1]\\n\\t\\t\\n        vector<long long int>v;\\n        int length=1;\\n        long long int count=0;\\n        for(int i=0;i<prices.size();i++)\\n        {\\n            if(i+1<prices.size() && prices[i+1]==prices[i]-1)\\n            {\\n                length++;\\n            }\\n            else\\n            {\\n                v.push_back(length);\\n                length=1;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Now we are iterating through the vector and if v[i] is \\'1\\' then we increment count \\n\\t\\t//else if v[i] is greater than \\'1\\' then we are using formula \\'sum of n numbers\\'\\t\\t\\n\\t\\t\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i]==1)\\n                count++;\\n            else\\n               count=count+(v[i]*(v[i]+1))/2;\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "long long getDescentPeriods(vector<int>& prices) {\\n\\n        //Creating a vector to hold all the lengths of descent periods\\n\\t\\t//for example for prices = [3,2,1,4], vector is going to be v = [3,1]\\n\\t\\t//for example for prices = [8,6,7,7], vector is going to be v = [1,1,1,1]\\n\\t\\t\\n        vector<long long int>v;\\n        int length=1;\\n        long long int count=0;\\n        for(int i=0;i<prices.size();i++)\\n        {\\n            if(i+1<prices.size() && prices[i+1]==prices[i]-1)\\n            {\\n                length++;\\n            }\\n            else\\n            {\\n                v.push_back(length);\\n                length=1;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Now we are iterating through the vector and if v[i] is \\'1\\' then we increment count \\n\\t\\t//else if v[i] is greater than \\'1\\' then we are using formula \\'sum of n numbers\\'\\t\\t\\n\\t\\t\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i]==1)\\n                count++;\\n            else\\n               count=count+(v[i]*(v[i]+1))/2;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1638205,
                "title": "java-o-n-time-o-1-space-simple-solution-with-comments",
                "content": "We traverse the array and keep counting the descending values, and add each value in our final ans.\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long ans = 1; // 1 because array has atleast one value\\n        int countTillNow = 1; // single value is also considered\\n        \\n        for(int i=1; i<prices.length; i++) {\\n            if(prices[i] == prices[i-1]-1) countTillNow++; // if descending, i.e. current value one less than previous value, increment the count\\n            else countTillNow = 1;\\n            \\n            ans += countTillNow;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long ans = 1; // 1 because array has atleast one value\\n        int countTillNow = 1; // single value is also considered\\n        \\n        for(int i=1; i<prices.length; i++) {\\n            if(prices[i] == prices[i-1]-1) countTillNow++; // if descending, i.e. current value one less than previous value, increment the count\\n            else countTillNow = 1;\\n            \\n            ans += countTillNow;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637579,
                "title": "c-100-100",
                "content": "```\\npublic long GetDescentPeriods(int[] prices) {\\n\\tvar list = GetDescentPeriodLengths(prices);\\n\\tvar rs = (long)prices.Length;\\n\\tfor (int i = 0; i < list.Count; i++)\\n\\t{\\n\\t\\trs += (list[i] * (long)(list[i] - 1)) / 2;\\n\\t}\\n\\treturn rs;\\n}\\nprivate List<int> GetDescentPeriodLengths(int[] prices)\\n{\\n\\tvar rs = new List<int>{1};\\n\\tfor (var i = 1; i < prices.Length; i++)\\n\\t{\\n\\t\\tif (prices[i - 1] - prices[i] != 1)\\n\\t\\t{\\n\\t\\t\\tif (rs[rs.Count - 1] != 1) rs.Add(1);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\trs[rs.Count - 1]++;\\n\\t\\t}\\n\\t}\\n\\treturn rs;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic long GetDescentPeriods(int[] prices) {\\n\\tvar list = GetDescentPeriodLengths(prices);\\n\\tvar rs = (long)prices.Length;\\n\\tfor (int i = 0; i < list.Count; i++)\\n\\t{\\n\\t\\trs += (list[i] * (long)(list[i] - 1)) / 2;\\n\\t}\\n\\treturn rs;\\n}\\nprivate List<int> GetDescentPeriodLengths(int[] prices)\\n{\\n\\tvar rs = new List<int>{1};\\n\\tfor (var i = 1; i < prices.Length; i++)\\n\\t{\\n\\t\\tif (prices[i - 1] - prices[i] != 1)\\n\\t\\t{\\n\\t\\t\\tif (rs[rs.Count - 1] != 1) rs.Add(1);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\trs[rs.Count - 1]++;\\n\\t\\t}\\n\\t}\\n\\treturn rs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1637172,
                "title": "c-cpp-solution-easy-to-understand",
                "content": "```\\nExplained approach in comments \\n\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) \\n    {\\n        // Base case\\n        if(prices.size() == 1)return 1;\\n        \\n        // getting difference of alternative prices\\n        vector<int>diff;\\n        for(int i = 0;i<prices.size()-1;i++)\\n        {\\n            diff.push_back(prices[i]-prices[i+1]);\\n        }\\n        \\n        // By observing answer would be >= size of prices\\n        long long ans = prices.size();\\n        long long one = 0;\\n        \\n        /* as well as we are calculating maximum occurenece of 1\\'s before any difference occurs\\n            \\n            by observing the smooth descent period of maximum 1\\'s is (n*(n+1))/2\\n        */\\n        for(auto i:diff)\\n        {\\n            // if diff is not 1 then update ans and set count of one = 0\\n            if(i != 1)\\n            {\\n                ans += (one*(one+1))/2;\\n                one = 0;\\n            }\\n            else one++;\\n        }\\n        \\n        // if loop ends and still count of one > 0 then add it in ans.\\n        if(one > 0)\\n            ans += (one*(one+1))/2;\\n        return ans;\\n    }\\n};\\n\\nIf you like the solution please share and upvote :)\\n```",
                "solutionTags": [],
                "code": "```\\nExplained approach in comments \\n\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) \\n    {\\n        // Base case\\n        if(prices.size() == 1)return 1;\\n        \\n        // getting difference of alternative prices\\n        vector<int>diff;\\n        for(int i = 0;i<prices.size()-1;i++)\\n        {\\n            diff.push_back(prices[i]-prices[i+1]);\\n        }\\n        \\n        // By observing answer would be >= size of prices\\n        long long ans = prices.size();\\n        long long one = 0;\\n        \\n        /* as well as we are calculating maximum occurenece of 1\\'s before any difference occurs\\n            \\n            by observing the smooth descent period of maximum 1\\'s is (n*(n+1))/2\\n        */\\n        for(auto i:diff)\\n        {\\n            // if diff is not 1 then update ans and set count of one = 0\\n            if(i != 1)\\n            {\\n                ans += (one*(one+1))/2;\\n                one = 0;\\n            }\\n            else one++;\\n        }\\n        \\n        // if loop ends and still count of one > 0 then add it in ans.\\n        if(one > 0)\\n            ans += (one*(one+1))/2;\\n        return ans;\\n    }\\n};\\n\\nIf you like the solution please share and upvote :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636013,
                "title": "c-two-pointers-o-1-s-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long  ans = 1LL * prices.size();\\n        long long i = 0,j=1;\\n        for(; j<prices.size(); j++){\\n            if(prices[j-1]-prices[j] == 1) continue;\\n            else{\\n                long long x = j - i;\\n                x = (long long) (x * (x - 1)) / 2;\\n                ans += x;\\n                i = j;\\n            }\\n        }\\n          if(i != prices.size() - 1) {\\n               long long  x = j - i;\\n                x = (long long) (x * (x - 1)) / 2;\\n                ans += x;\\n          }\\n        \\n          return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long  ans = 1LL * prices.size();\\n        long long i = 0,j=1;\\n        for(; j<prices.size(); j++){\\n            if(prices[j-1]-prices[j] == 1) continue;\\n            else{\\n                long long x = j - i;\\n                x = (long long) (x * (x - 1)) / 2;\\n                ans += x;\\n                i = j;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1635470,
                "title": "java-1ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int n = prices.length;\\n        int len = 1;\\n        long ans = 1;\\n        for(int i = 1;i < n;i++){\\n            if(prices[i-1] - prices[i] == 1){\\n                len++;\\n            }else{\\n                len = 1;\\n            }\\n            ans += len;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int n = prices.length;\\n        int len = 1;\\n        long ans = 1;\\n        for(int i = 1;i < n;i++){\\n            if(prices[i-1] - prices[i] == 1){\\n                len++;\\n            }else{\\n                len = 1;\\n            }\\n            ans += len;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635421,
                "title": "c-o-n-solution-using-the-idea-of-stacks",
                "content": "Basically we are trying to create a stack in decreasing order (where the difference is ==1).\\nIf any time we encounter an element which violates this property, we count the number of combinations possible i.e \\n\\n```\\nint n = st.size();\\nans+=n*(n-1)/2;\\n```\\n\\nSince we cannot clear all elements of a stack in O(1) time, I used a vector to stimulate the same functionalities as a stack.\\n\\nCODE:\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        vector<int>s;\\n        \\n        long long ans=prices.size();\\n        s.push_back(prices[0]);\\n        for(int i=1;i<prices.size();i++){\\n            if((prices[i-1]-prices[i])==1){\\n                s.push_back(prices[i]);\\n            }\\n            else{\\n                long long n=s.size();\\n                ans+=n*(n-1)/2;\\n                s.clear();\\n                s.push_back(prices[i]);\\n            }\\n        }\\n        long long n=s.size();\\n        ans+=n*(n-1)/2;\\n        return ans;\\n    }\\n};\\n```\\nHope this helps!",
                "solutionTags": [],
                "code": "```\\nint n = st.size();\\nans+=n*(n-1)/2;\\n```\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        vector<int>s;\\n        \\n        long long ans=prices.size();\\n        s.push_back(prices[0]);\\n        for(int i=1;i<prices.size();i++){\\n            if((prices[i-1]-prices[i])==1){\\n                s.push_back(prices[i]);\\n            }\\n            else{\\n                long long n=s.size();\\n                ans+=n*(n-1)/2;\\n                s.clear();\\n                s.push_back(prices[i]);\\n            }\\n        }\\n        long long n=s.size();\\n        ans+=n*(n-1)/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635297,
                "title": "java-easy-dp",
                "content": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int n = prices.length;\\n        long count = 1; //total count\\n        long pc = 1; //previous count of longest continous decreasing series\\n        for(int i = 1; i < n ; i++){\\n            long nc; //new count\\n          \\n            if(prices[i - 1] - prices[i] == 1){\\n               nc = pc + 1; \\n            }\\n            else{\\n              nc = 1;\\n            }\\n           count += nc;\\n           pc = nc;\\n        }\\n       return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int n = prices.length;\\n        long count = 1; //total count\\n        long pc = 1; //previous count of longest continous decreasing series\\n        for(int i = 1; i < n ; i++){\\n            long nc; //new count\\n          \\n            if(prices[i - 1] - prices[i] == 1){\\n               nc = pc + 1; \\n            }\\n            else{\\n              nc = 1;\\n            }\\n           count += nc;\\n           pc = nc;\\n        }\\n       return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635211,
                "title": "c-two-pointer-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int i=1,j=0;\\n        long long count = 1; // the min length of array can be 1\\n        while(i<prices.size() && j<prices.size()){\\n            if(prices[i-1]-prices[i]==1){  //if condition satisfies\\n                count+=i-j+1;\\n            }\\n            else{  //else we have to start again\\n                j=i;\\n                count+=i-j+1;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int i=1,j=0;\\n        long long count = 1; // the min length of array can be 1\\n        while(i<prices.size() && j<prices.size()){\\n            if(prices[i-1]-prices[i]==1){  //if condition satisfies\\n                count+=i-j+1;\\n            }\\n            else{  //else we have to start again\\n                j=i;\\n                count+=i-j+1;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635167,
                "title": "o-n-java-approach",
                "content": "\\n    class Solution {\\n\\tpublic long getDescentPeriods(int[] prices) {\\n        //creating an array for storing the diferences of adjacent elements\\n        int arr[]=new int[prices.length-1];\\n        long c=prices.length;long d=0;\\n        // storing the diferences of adjacent elements\\n        for(int i=0;i<arr.length;i++){\\n            arr[i]=prices[i]-prices[i+1];\\n        }\\n       \\n        for(int i=0;i<arr.length;i++){\\n            //counting the numbers of 1\\'s consecutive\\n            if(arr[i]==1){\\n                d++;\\n            }\\n             \\n            //when 1 is not found initializing d=0,adding possible no of descent periods\\n            else if(arr[i]!=1){\\n              \\n                c+=(long)(d*(d+1))/2;\\n                d=0;\\n            }   \\n        }\\n      \\n        return c+(long)(d*(d+1))/2;\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic long getDescentPeriods(int[] prices) {\\n        //creating an array for storing the diferences of adjacent elements\\n        int arr[]=new int[prices.length-1];\\n        long c=prices.length;long d=0;\\n        // storing the diferences of adjacent elements\\n        for(int i=0;i<arr.length;i++){\\n            arr[i]=prices[i]-prices[i+1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1635140,
                "title": "c-2110-number-of-smooth-descent-periods-of-a-stock",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long ans = 0; \\n        for (int i = 0, cnt = 0; i < prices.size(); ++i) {\\n            if (i && prices[i-1] != prices[i]+1) cnt = 0; \\n            ans += ++cnt; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long ans = 0; \\n        for (int i = 0, cnt = 0; i < prices.size(); ++i) {\\n            if (i && prices[i-1] != prices[i]+1) cnt = 0; \\n            ans += ++cnt; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635126,
                "title": "python-sliding-window-two-pointers",
                "content": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        left = 0\\n        right = 1\\n        res = 1\\n        \\n        while right < len(prices):\\n            \\n            while left < right and prices[right-1] - prices[right] != 1:\\n                left += 1\\n            \\n            res += right - left + 1\\n            right += 1\\n            \\n        return res",
                "solutionTags": [
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        left = 0\\n        right = 1\\n        res = 1\\n        \\n        while right < len(prices):\\n            \\n            while left < right and prices[right-1] - prices[right] != 1:\\n                left += 1\\n            \\n            res += right - left + 1\\n            right += 1\\n            \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1635091,
                "title": "python-solution",
                "content": "**Time: O(n)\\nSpace: O(n)**\\n```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        result,count = 0,1\\n        for i in range(1,len(prices)):\\n            if prices[i] + 1 == prices[i-1]:\\n                count += 1\\n            else:\\n                result += (count * (count+1))//2\\n                count = 1\\n        result += (count * (count+1))//2\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        result,count = 0,1\\n        for i in range(1,len(prices)):\\n            if prices[i] + 1 == prices[i-1]:\\n                count += 1\\n            else:\\n                result += (count * (count+1))//2\\n                count = 1\\n        result += (count * (count+1))//2\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635057,
                "title": "c-very-simple-approach",
                "content": "idea:- count all  the smooth descent periods as:-\\ntc-O(n)\\nsc-O(n)\\n\\n    long long getDescentPeriods(vector<int>& p) {\\n        vector<int>temp(p.size(),1);\\n        for(int i=1;i<p.size();i++)\\n        {\\n            if(p[i]+1==p[i-1])//if cuurent index price is just greater than 1 of its previous price.then assign previous temp value +1 in the current temp value.\\n            temp[i]=temp[i-1]+1;\\n        }\\n        \\n      //then find sum of all temp value and that will be our ans.by this approach all the smooth descent periods will be counted.\\n        long long sum=0;\\n        for(int i=0;i<temp.size();i++)\\n            sum+=temp[i];\\n        \\n        return sum;     \\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "idea:- count all  the smooth descent periods as:-\\ntc-O(n)\\nsc-O(n)\\n\\n    long long getDescentPeriods(vector<int>& p) {\\n        vector<int>temp(p.size(),1);\\n        for(int i=1;i<p.size();i++)\\n        {\\n            if(p[i]+1==p[i-1])//if cuurent index price is just greater than 1 of its previous price.then assign previous temp value +1 in the current temp value.\\n            temp[i]=temp[i-1]+1;\\n        }\\n        \\n      //then find sum of all temp value and that will be our ans.by this approach all the smooth descent periods will be counted.\\n        long long sum=0;\\n        for(int i=0;i<temp.size();i++)\\n            sum+=temp[i];\\n        \\n        return sum;     \\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1635009,
                "title": "java-sc-o-1-tc-o-n-simple-dp",
                "content": "Solution: \\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int len = prices.length;\\n        long output = 1, prev = 1;\\n        \\n        for (int i = len - 2; i >= 0; -- i) {\\n            if (prices[i] - prices[i + 1] == 1) {\\n                ++ prev;\\n            } else {\\n                prev = 1;\\n            }\\n            output += prev;\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int len = prices.length;\\n        long output = 1, prev = 1;\\n        \\n        for (int i = len - 2; i >= 0; -- i) {\\n            if (prices[i] - prices[i + 1] == 1) {\\n                ++ prev;\\n            } else {\\n                prev = 1;\\n            }\\n            output += prev;\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634994,
                "title": "easy-to-understand-python-solution",
                "content": "The idea is : \\n* Iterate and find the maximum length upto the position i where the stock prices are in the smooth descent period (i.e. prices[i - 1] - prices[i] == 1).\\n* Find the number of combinations possible with that length.\\n* Add it to the result.\\n* Continue iteration.\\n\\n\\n```\\nresult += (decreasing_length * (decreasing_length + 1)) // 2\\n```\\n\\nThe idea behind this line is that:\\nLet\\'s say the maximum length for a smooth descent period is 4 - [4, 3, 2, 1]:\\nThen the number of possible combinations are:\\n1 of length 4 - [4, 3, 2, 1]\\n2 of length 3 - [4, 3, 2], [3, 2, 1]\\n3 of length 2 - [4, 3], [3, 2], [2, 1]\\n4 of length 1 - [4], [3], [2], [1]\\n\\n1 + 2 + 3 + 4 = 10 = (4 * (4 + 1)) / 2. Which is exactly what is happening in the above code.\\n\\n```\\ndef getDescentPeriods(self, prices):\\n\\t\\t\\n        result = 0\\n        decreasing_length = 1\\n\\t\\t\\n        for i in range(1, len(prices)):\\n            if prices[i - 1] - prices[i] == 1:\\n                decreasing_length += 1\\n\\n            else:\\n                result += (decreasing_length * (decreasing_length + 1)) // 2\\n\\t\\t\\t\\tdecreasing_length = 1\\n\\t\\n\\t\\t# To handle the case where the else was not entered into. For example - [3, 2, 1]\\n\\t\\t# Or to add the last iteration. For example - [3, 2, 1, 4]\\n        result += (decreasing_length * (decreasing_length + 1)) // 2\\n            \\n        return result\\n```\\n",
                "solutionTags": [],
                "code": "```\\nresult += (decreasing_length * (decreasing_length + 1)) // 2\\n```\n```\\ndef getDescentPeriods(self, prices):\\n\\t\\t\\n        result = 0\\n        decreasing_length = 1\\n\\t\\t\\n        for i in range(1, len(prices)):\\n            if prices[i - 1] - prices[i] == 1:\\n                decreasing_length += 1\\n\\n            else:\\n                result += (decreasing_length * (decreasing_length + 1)) // 2\\n\\t\\t\\t\\tdecreasing_length = 1\\n\\t\\n\\t\\t# To handle the case where the else was not entered into. For example - [3, 2, 1]\\n\\t\\t# Or to add the last iteration. For example - [3, 2, 1, 4]\\n        result += (decreasing_length * (decreasing_length + 1)) // 2\\n            \\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1634993,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/the-art-of-dynamic-programming-an-intuitive-approach-from-apprentice-to-master/) similar to [Kadane\\'s algorithm](https://en.wikipedia.org/wiki/Maximum_subarray_problem) we can track each optimal subproblem solution ending at each `i`<sup>th</sup> index.\\n\\n1. Every element of the input array `A` is a \"run\" of length `1` which can be extended into longer \"run\" lengths when there exists a smooth descent period per the recurrence relation `dp[i] = 1 + dp[i - 1]`, ie. the count of \"runs\" ending at `i` is equal to one plus the previous count of \"runs\" ending at `i - 1`.  Return the accumulated total count of \"runs\" ending at each `i`<sup>th</sup> index.\\n\\n2. Memory optimization: we don\\'t need to track the entire `dp` array, instead we only need the previous `i - 1`<sup>th</sup> optimal solution to formulate the current `i`<sup>th</sup> optimal solution.  Let `a`, `b` denote `dp[i - 1]` and `dp[i]` correspondingly, ie. we can use a sliding window and accumulate the total `t` count of \"runs\" ending at each `i`<sup>th</sup> index during the linear scan from `i = 1..N-1`.\\n\\n3. Finally we can simplify the code logic by \"transforming\" the concepts of two variables: (`a` and `b`) into a single variable: (`k`), ie. each \"run\" of length `k` has the sum-of-series for `k` = 1 + 2 + 3 + ... + (k - 2) + (k - 1) + k as its count of descent periods.\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n*Kotlin O(N) memory with DP array*\\n```\\nclass Solution {\\n    fun getDescentPeriods(A: IntArray): Long {\\n        var N = A.size\\n        var dp = LongArray(N) { 1 }\\n        for (i in 1 until N)\\n            if (A[i - 1] - 1 == A[i])\\n                dp[i] = 1 + dp[i - 1]\\n        return dp.sum()!!\\n    }\\n}\\n```\\n\\n*Kotlin O(1) memory with sliding window, ie. a, b == dp[i - 1], dp[i]*\\n```\\nclass Solution {\\n    fun getDescentPeriods(A: IntArray): Long {\\n        var t = 1L\\n        var N = A.size\\n        var (a, b) = Pair(1, 1)\\n        for (i in 1 until N) {\\n            if (A[i - 1] - 1 == A[i])\\n                b = 1 + a\\n            else\\n                b = 1\\n            t += b\\n            a = b  // \\uD83D\\uDC48 slide window\\n        }\\n        return t\\n    }\\n}\\n```\\n\\n*Kotlin O(1) memory transforming a and b into k*\\n```\\nclass Solution {\\n    fun getDescentPeriods(A: IntArray): Long {\\n        var (k, t) = Pair(1, 1L)\\n        for (i in 1 until A.size) {\\n            if (A[i - 1] - 1 == A[i])\\n                ++k\\n            else\\n                k = 1\\n            t += k\\n        }\\n        return t\\n    }\\n}\\n```\\n\\n**Javascript Solutions:**\\n\\n*Javascript O(N) memory with DP array*\\n```\\nlet getDescentPeriods = A => {\\n    let N = A.length;\\n    let dp = Array(N).fill(1);\\n    for (let i = 1; i < N; ++i)\\n        if (A[i - 1] - 1 == A[i])\\n            dp[i] = 1 + dp[i - 1];\\n    return _.sum(dp);\\n};\\n```\\n\\n*Javascript O(1) memory with sliding window, ie. a, b == dp[i - 1], dp[i]*\\n```\\nlet getDescentPeriods = (A, t = 1) => {\\n    let N = A.length;\\n    let [a, b] = [1, 1];\\n    for (let i = 1; i < N; ++i) {\\n        if (A[i - 1] - 1 == A[i])\\n            b = 1 + a;\\n        else\\n            b = 1;\\n        t += b;\\n        a = b;  // \\uD83D\\uDC48 slide window\\n    }\\n    return t;\\n};\\n```\\n\\n*Javascript O(1) memory transforming a and b into k*\\n```\\nlet getDescentPeriods = (A, k = 1, t = 1) => {\\n    let N = A.length;\\n    for (let i = 1; i < N; ++i) {\\n        if (A[i - 1] - 1 == A[i])\\n            ++k;\\n        else\\n            k = 1;\\n        t += k;\\n    }\\n    return t;\\n};\\n```\\n\\n**Python3 Solutions:**\\n\\n*Python3 O(N) memory with DP array*\\n```\\nclass Solution:\\n    def getDescentPeriods(self, A: List[int]) -> int:\\n        N = len(A)\\n        dp = [1] * N\\n        for i in range(1, N):\\n            if A[i - 1] - 1 == A[i]:\\n                dp[i] = 1 + dp[i - 1]\\n        return sum(dp)\\n```\\n\\n*Python3 O(1) memory with sliding window, ie. a, b == dp[i - 1], dp[i]*\\n```\\nclass Solution:\\n    def getDescentPeriods(self, A: List[int], t = 1) -> int:\\n        N = len(A)\\n        a, b = 1, 1\\n        for i in range(1, N):\\n            if A[i - 1] - 1 == A[i]:\\n                b = 1 + a\\n            else:\\n                b = 1\\n            t += b\\n            a = b  # \\uD83D\\uDC48 slide window\\n        return t\\n```\\n\\n*Python3 O(1) memory transforming a and b into k*\\n```\\nclass Solution:\\n    def getDescentPeriods(self, A: List[int], k = 1, t = 1) -> int:\\n        N = len(A)\\n        for i in range(1, N):\\n            if A[i - 1] - 1 == A[i]:\\n                k += 1\\n            else:\\n                k = 1\\n            t += k\\n        return t\\n```\\n\\n**C++ Solutions:**\\n\\n*C++ O(N) memory with DP array*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VI = vector<int>;\\n    LL getDescentPeriods(VI& A) {\\n        int N = A.size();\\n        VL dp(N, 1);\\n        for (auto i{ 1 }; i < N; ++i)\\n            if (A[i - 1] - 1 == A[i])\\n                dp[i] = 1 + dp[i - 1];\\n        return accumulate(dp.begin(), dp.end(), 0LL);\\n    }\\n};\\n```\\n\\n*C++ O(1) memory with sliding window, ie. a, b == dp[i - 1], dp[i]*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VI = vector<int>;\\n    LL getDescentPeriods(VI& A, LL t = 1) {\\n        int N = A.size();\\n        auto [a, b] = make_tuple(1, 1);\\n        for (auto i{ 1 }; i < N; ++i) {\\n            if (A[i - 1] - 1 == A[i])\\n                b = 1 + a;\\n            else\\n                b = 1;\\n            t += b;\\n            a = b;  // \\uD83D\\uDC48 slide window\\n        }\\n        return t;\\n    }\\n};\\n```\\n\\n*C++ O(1) memory transforming a and b into k*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    LL getDescentPeriods(VI& A, int k = 1, LL t = 1) {\\n        for (auto i{ 1 }; i < A.size(); ++i) {\\n            if (A[i - 1] - 1 == A[i])\\n                ++k;\\n            else\\n                k = 1;\\n            t += k;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun getDescentPeriods(A: IntArray): Long {\\n        var N = A.size\\n        var dp = LongArray(N) { 1 }\\n        for (i in 1 until N)\\n            if (A[i - 1] - 1 == A[i])\\n                dp[i] = 1 + dp[i - 1]\\n        return dp.sum()!!\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun getDescentPeriods(A: IntArray): Long {\\n        var t = 1L\\n        var N = A.size\\n        var (a, b) = Pair(1, 1)\\n        for (i in 1 until N) {\\n            if (A[i - 1] - 1 == A[i])\\n                b = 1 + a\\n            else\\n                b = 1\\n            t += b\\n            a = b  // \\uD83D\\uDC48 slide window\\n        }\\n        return t\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun getDescentPeriods(A: IntArray): Long {\\n        var (k, t) = Pair(1, 1L)\\n        for (i in 1 until A.size) {\\n            if (A[i - 1] - 1 == A[i])\\n                ++k\\n            else\\n                k = 1\\n            t += k\\n        }\\n        return t\\n    }\\n}\\n```\n```\\nlet getDescentPeriods = A => {\\n    let N = A.length;\\n    let dp = Array(N).fill(1);\\n    for (let i = 1; i < N; ++i)\\n        if (A[i - 1] - 1 == A[i])\\n            dp[i] = 1 + dp[i - 1];\\n    return _.sum(dp);\\n};\\n```\n```\\nlet getDescentPeriods = (A, t = 1) => {\\n    let N = A.length;\\n    let [a, b] = [1, 1];\\n    for (let i = 1; i < N; ++i) {\\n        if (A[i - 1] - 1 == A[i])\\n            b = 1 + a;\\n        else\\n            b = 1;\\n        t += b;\\n        a = b;  // \\uD83D\\uDC48 slide window\\n    }\\n    return t;\\n};\\n```\n```\\nlet getDescentPeriods = (A, k = 1, t = 1) => {\\n    let N = A.length;\\n    for (let i = 1; i < N; ++i) {\\n        if (A[i - 1] - 1 == A[i])\\n            ++k;\\n        else\\n            k = 1;\\n        t += k;\\n    }\\n    return t;\\n};\\n```\n```\\nclass Solution:\\n    def getDescentPeriods(self, A: List[int]) -> int:\\n        N = len(A)\\n        dp = [1] * N\\n        for i in range(1, N):\\n            if A[i - 1] - 1 == A[i]:\\n                dp[i] = 1 + dp[i - 1]\\n        return sum(dp)\\n```\n```\\nclass Solution:\\n    def getDescentPeriods(self, A: List[int], t = 1) -> int:\\n        N = len(A)\\n        a, b = 1, 1\\n        for i in range(1, N):\\n            if A[i - 1] - 1 == A[i]:\\n                b = 1 + a\\n            else:\\n                b = 1\\n            t += b\\n            a = b  # \\uD83D\\uDC48 slide window\\n        return t\\n```\n```\\nclass Solution:\\n    def getDescentPeriods(self, A: List[int], k = 1, t = 1) -> int:\\n        N = len(A)\\n        for i in range(1, N):\\n            if A[i - 1] - 1 == A[i]:\\n                k += 1\\n            else:\\n                k = 1\\n            t += k\\n        return t\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VI = vector<int>;\\n    LL getDescentPeriods(VI& A) {\\n        int N = A.size();\\n        VL dp(N, 1);\\n        for (auto i{ 1 }; i < N; ++i)\\n            if (A[i - 1] - 1 == A[i])\\n                dp[i] = 1 + dp[i - 1];\\n        return accumulate(dp.begin(), dp.end(), 0LL);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VI = vector<int>;\\n    LL getDescentPeriods(VI& A, LL t = 1) {\\n        int N = A.size();\\n        auto [a, b] = make_tuple(1, 1);\\n        for (auto i{ 1 }; i < N; ++i) {\\n            if (A[i - 1] - 1 == A[i])\\n                b = 1 + a;\\n            else\\n                b = 1;\\n            t += b;\\n            a = b;  // \\uD83D\\uDC48 slide window\\n        }\\n        return t;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    LL getDescentPeriods(VI& A, int k = 1, LL t = 1) {\\n        for (auto i{ 1 }; i < A.size(); ++i) {\\n            if (A[i - 1] - 1 == A[i])\\n                ++k;\\n            else\\n                k = 1;\\n            t += k;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081819,
                "title": "o-n-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long ans = 1 ;\\n        int left = 0 ;\\n        for(int right=1;right<prices.size();right++){\\n            if(prices[right-1]==prices[right]+1){\\n                ans+=right-left+1;\\n            }\\n            else{\\n                left = right;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long ans = 1 ;\\n        int left = 0 ;\\n        for(int right=1;right<prices.size();right++){\\n            if(prices[right-1]==prices[right]+1){\\n                ans+=right-left+1;\\n            }\\n            else{\\n                left = right;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060581,
                "title": "c-easy-and-intuitive",
                "content": "# Intuition\\nJust we think how many possible ways we can have if we have :-\\n1) 3 elements (a1, a2, a3) - We can have [(a1), (a2), (a3), (a1, a2), (a2, a3), (a1, a2, a3)] \\n\\n2) 4 elements (a1, a2, a3, a4) - We can have [(a1), (a2), (a3), (a4), (a1, a2), (a2, a3), (a3, a4), (a1, a2, a3), (a2, a3, a4), (a1, a2, a3, a4)]\\nObservations :- We can have (n*(n+1))/2 combinations.\\nUse this observation and single pass is enough for finding the answer!\\n\\n\\n\\n## Please Upvote if you are able to understand this solution!\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        int long long sum = 0;\\n        int curr = 0;\\n        int prev = prices[0]+1;\\n        for(int i=0;i<n;i++) {\\n            if((prev - 1) == prices[i]) {\\n                curr++;\\n            }\\n            else {\\n                sum += (((curr+1)*1ll*curr)/2);\\n                curr = 1; \\n            }\\n            prev = prices[i];\\n        }\\n        sum += ((curr*1ll*(curr+1))/2);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        int long long sum = 0;\\n        int curr = 0;\\n        int prev = prices[0]+1;\\n        for(int i=0;i<n;i++) {\\n            if((prev - 1) == prices[i]) {\\n                curr++;\\n            }\\n            else {\\n                sum += (((curr+1)*1ll*curr)/2);\\n                curr = 1; \\n            }\\n            prev = prices[i];\\n        }\\n        sum += ((curr*1ll*(curr+1))/2);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048731,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long ans = 1, n = prices.size(), dp[n];\\n        dp[0] = 1;\\n        for(int i=1;i<n;i++) {\\n            dp[i] = 1;\\n            if(prices[i] == prices[i-1] - 1) {\\n                dp[i] += dp[i-1];\\n            }\\n            ans += dp[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long ans = 1, n = prices.size(), dp[n];\\n        dp[0] = 1;\\n        for(int i=1;i<n;i++) {\\n            dp[i] = 1;\\n            if(prices[i] == prices[i-1] - 1) {\\n                dp[i] += dp[i-1];\\n            }\\n            ans += dp[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047683,
                "title": "python-simple-solution-with-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach single point is a day by itself, but then you have to check all the older version, and see for how long there has been a decreasing streak. \\n\\nNow we need to ask, a streak how many unique case does it brings? \\n- `n` for each single item\\n- `n-1` for each pair\\n- `n-2` for each triplets \\n- And so on\\n\\nSo, we can accumulate the length, and in the end, summ the number that we end up computing. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can initialize an array all to ones, so if there is no streak, only the single ones will be used. Then, with a linear pass, we look if the precedent was a value higher than one unit, and if it was, the streak starts and we add 1 to the value of the precedent value. Then we summ everything we get in the array, and we have our solution.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        values = [1 for i in range(len(prices))]\\n\\n        for i in range(1, len(prices)):\\n            if prices[i] == prices[i-1] - 1:\\n                values[i] = values[i-1] + 1\\n\\n        return sum(values)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        values = [1 for i in range(len(prices))]\\n\\n        for i in range(1, len(prices)):\\n            if prices[i] == prices[i-1] - 1:\\n                values[i] = values[i-1] + 1\\n\\n        return sum(values)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029632,
                "title": "cpp-simple-and-unique-solution-o-n",
                "content": "# Intuition\\nJust Analyse the custom test cases and think of making a temporary array and return the sum of that array.\\n\\n# Approach\\nUse a prefix array to store results till every index.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<int> pre(n, 1);\\n        long long ans = 0;\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(prices[i] == prices[i - 1] - 1) // Check Whether difference is exactly 1.\\n            {\\n                pre[i] = pre[i - 1] + 1;\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            ans += pre[i];\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<int> pre(n, 1);\\n        long long ans = 0;\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(prices[i] == prices[i - 1] - 1) // Check Whether difference is exactly 1.\\n            {\\n                pre[i] = pre[i - 1] + 1;\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            ans += pre[i];\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017477,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long currIndex=1;\\n        long result=1;\\n        for(int i=1;i<prices.length;i++)\\n        {\\n            if(prices[i]!=prices[i-1]-1)\\n            currIndex=1;\\n            else\\n           { currIndex+=1;}\\n            \\n            result+=currIndex;\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long currIndex=1;\\n        long result=1;\\n        for(int i=1;i<prices.length;i++)\\n        {\\n            if(prices[i]!=prices[i-1]-1)\\n            currIndex=1;\\n            else\\n           { currIndex+=1;}\\n            \\n            result+=currIndex;\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016633,
                "title": "two-pointer-prefix-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int start=0, i=0;\\n        long count=0;\\n        for(i=1; i<prices.length; i++){\\n            if(prices[i]==prices[i-1]-1){\\n                count+=(i-start+1);\\n            } else{\\n                start=i;\\n                count++;\\n            }\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int start=0, i=0;\\n        long count=0;\\n        for(i=1; i<prices.length; i++){\\n            if(prices[i]==prices[i-1]-1){\\n                count+=(i-start+1);\\n            } else{\\n                start=i;\\n                count++;\\n            }\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014200,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long getDescentPeriods(vector<int>& prices) \\n{\\n        int i,n=prices.size();\\n        int c=1;\\n        long long ans=0;\\n        vector<int> v;\\n        for(i=1;i<n;i++)\\n        {\\n        if(prices[i-1]-prices[i]==1)\\n        {\\n        c++;\\n        }\\n        else\\n        {\\n        v.push_back(c);\\n        c=1;\\n        }\\n        }\\n        v.push_back(c);\\n        // for(auto x:v)\\n        // {\\n        //     cout<<x<<\" \";\\n        // }\\n        // cout<<endl;\\n        for(i=0;i<v.size();i++)\\n        {\\n            ans+=((long long)((long long)v[i]*(long long)(v[i]+1)/2));\\n        }\\n        return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long getDescentPeriods(vector<int>& prices) \\n{\\n        int i,n=prices.size();\\n        int c=1;\\n        long long ans=0;\\n        vector<int> v;\\n        for(i=1;i<n;i++)\\n        {\\n        if(prices[i-1]-prices[i]==1)\\n        {\\n        c++;\\n        }\\n        else\\n        {\\n        v.push_back(c);\\n        c=1;\\n        }\\n        }\\n        v.push_back(c);\\n        // for(auto x:v)\\n        // {\\n        //     cout<<x<<\" \";\\n        // }\\n        // cout<<endl;\\n        for(i=0;i<v.size();i++)\\n        {\\n            ans+=((long long)((long long)v[i]*(long long)(v[i]+1)/2));\\n        }\\n        return ans;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3998514,
                "title": "faster-than-100-easiest-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] arr) {\\n\\n        long ans=1;\\n        int st=0;\\n        for(int i=1;i<arr.length;i++){\\n            if(arr[i-1]-arr[i]!=1)st=i;\\n            ans+=i-st+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] arr) {\\n\\n        long ans=1;\\n        int st=0;\\n        for(int i=1;i<arr.length;i++){\\n            if(arr[i-1]-arr[i]!=1)st=i;\\n            ans+=i-st+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981989,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n     int length = prices.length;\\n     if(length==1){\\n         return 1L;\\n     }   \\n     else{\\n         long sum=0;\\n         long sumOfNatural=1;\\n         \\n         for(int i=1;i<length;i++){\\n             if(prices[i]-prices[i-1]==-1){\\n                 sumOfNatural++;\\n             }\\n             else{\\n                 long total=(sumOfNatural*(sumOfNatural+1))/2;\\n                 sumOfNatural=1;\\n                 sum+=total;\\n                \\n             }\\n         }\\n     \\n             long total=(sumOfNatural*(sumOfNatural+1))/2;\\n                 \\n            sum+=total;\\n         \\n         return sum;\\n     }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n     int length = prices.length;\\n     if(length==1){\\n         return 1L;\\n     }   \\n     else{\\n         long sum=0;\\n         long sumOfNatural=1;\\n         \\n         for(int i=1;i<length;i++){\\n             if(prices[i]-prices[i-1]==-1){\\n                 sumOfNatural++;\\n             }\\n             else{\\n                 long total=(sumOfNatural*(sumOfNatural+1))/2;\\n                 sumOfNatural=1;\\n                 sum+=total;\\n                \\n             }\\n         }\\n     \\n             long total=(sumOfNatural*(sumOfNatural+1))/2;\\n                 \\n            sum+=total;\\n         \\n         return sum;\\n     }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964232,
                "title": "simple-solution-using-stack-no-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n\\n        ans = 0\\n        stack = []\\n        nums = prices\\n        for i in range(len(prices)):\\n            if stack and stack[-1] - nums[i] == 1:\\n                    stack.append(nums[i])\\n            else:\\n                zz = len(stack)\\n                ans += zz*(zz+1)//2\\n                stack = [nums[i]]\\n        zz = len(stack)\\n        ans += zz*(zz+1)//2\\n        stack = [nums[i]]\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n\\n        ans = 0\\n        stack = []\\n        nums = prices\\n        for i in range(len(prices)):\\n            if stack and stack[-1] - nums[i] == 1:\\n                    stack.append(nums[i])\\n            else:\\n                zz = len(stack)\\n                ans += zz*(zz+1)//2\\n                stack = [nums[i]]\\n        zz = len(stack)\\n        ans += zz*(zz+1)//2\\n        stack = [nums[i]]\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953147,
                "title": "python-beats-99-14",
                "content": "![\\u672A\\u547D\\u540D.png](https://assets.leetcode.com/users/images/65e861a7-5ddc-4078-8a07-6e2a2260786c_1692860591.0669694.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        Output = len(prices)\\n        temp = 1\\n\\n        for i in range(1,len(prices)):\\n            if prices[i-1] - prices[i] == 1:\\n                temp = temp + 1\\n            elif prices[i-1] - prices[i] != 1:\\n                if temp >= 2:\\n                    Output = Output + ( ( temp * ( temp - 1 ) // 2 ) )\\n                    temp = 1\\n        \\n        if temp >= 2:\\n            Output = Output + ( ( temp * ( temp - 1 ) // 2 ) )\\n            temp = 1\\n\\n        return Output\\n\\n        # 20230824\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        Output = len(prices)\\n        temp = 1\\n\\n        for i in range(1,len(prices)):\\n            if prices[i-1] - prices[i] == 1:\\n                temp = temp + 1\\n            elif prices[i-1] - prices[i] != 1:\\n                if temp >= 2:\\n                    Output = Output + ( ( temp * ( temp - 1 ) // 2 ) )\\n                    temp = 1\\n        \\n        if temp >= 2:\\n            Output = Output + ( ( temp * ( temp - 1 ) // 2 ) )\\n            temp = 1\\n\\n        return Output\\n\\n        # 20230824\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950016,
                "title": "o-n-time-complexity",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& nums) {\\n        long long    int count=0,m=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i+1]-nums[i]!=-1)\\n            {\\n                count+=(m+1)*(m+2)/2;\\n                m=0;\\n            }\\n            else\\n            m++;\\n        }\\n        return count+((m+2)*(m+1)/2);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& nums) {\\n        long long    int count=0,m=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i+1]-nums[i]!=-1)\\n            {\\n                count+=(m+1)*(m+2)/2;\\n                m=0;\\n            }\\n            else\\n            m++;\\n        }\\n        return count+((m+2)*(m+1)/2);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946558,
                "title": "javascript-simple-for-loop-o-n-tc-and-o-1-s-c",
                "content": "/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar getDescentPeriods = function(prices) {\\n    \\n    \\n    let left=0\\n    let ans = 1\\n    \\n    for(let right=1; right<prices.length; right++){\\n        \\n        \\n        if(prices[right]-prices[right-1] ==-1){\\n            ans+= right-left+1\\n        }\\n        else{\\n            ans += 1\\n            left = right //put left pointer in right place\\n        }\\n        \\n      \\n        \\n    }\\n    \\n    return ans\\n};",
                "solutionTags": [],
                "code": "/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar getDescentPeriods = function(prices) {\\n    \\n    \\n    let left=0\\n    let ans = 1\\n    \\n    for(let right=1; right<prices.length; right++){\\n        \\n        \\n        if(prices[right]-prices[right-1] ==-1){\\n            ans+= right-left+1\\n        }\\n        else{\\n            ans += 1\\n            left = right //put left pointer in right place\\n        }\\n        \\n      \\n        \\n    }\\n    \\n    return ans\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3930932,
                "title": "c-solution-with-t-c-o-n-and-s-c-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size(),i = 0,j = 1;\\n        long long ans = 0;\\n        while(j < n){\\n            while(j < n && prices[j-1]-prices[j] == 1)\\n                ans += (j++) - i;\\n            i = j++;\\n        }\\n        return ans + n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size(),i = 0,j = 1;\\n        long long ans = 0;\\n        while(j < n){\\n            while(j < n && prices[j-1]-prices[j] == 1)\\n                ans += (j++) - i;\\n            i = j++;\\n        }\\n        return ans + n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915294,
                "title": "c-easiest-of-all",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    long long GET(long long n){\\n        return (n * (n + 1)) / 2;\\n    }\\n\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        // Intution\\n        // The idea in here is really very simple. What we will do is from current index we will check if the condition is satisfied or not. If the condition is satisfied then we will continue checking and then add the result to the answer\\n\\n        long long answer = 0;\\n\\n        int prev;\\n\\n        int size = prices.size();\\n\\n        int i = 0;\\n\\n        while(i < size){\\n            int current = i;\\n            prev = -1;\\n            while(i < size and (prev == -1 or prev - prices[i] == 1)){\\n                prev = prices[i];\\n                i += 1;\\n            }\\n            answer += GET(i - current);\\n            if(current == i) i++;\\n        }\\n\\n        return answer;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long GET(long long n){\\n        return (n * (n + 1)) / 2;\\n    }\\n\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        // Intution\\n        // The idea in here is really very simple. What we will do is from current index we will check if the condition is satisfied or not. If the condition is satisfied then we will continue checking and then add the result to the answer\\n\\n        long long answer = 0;\\n\\n        int prev;\\n\\n        int size = prices.size();\\n\\n        int i = 0;\\n\\n        while(i < size){\\n            int current = i;\\n            prev = -1;\\n            while(i < size and (prev == -1 or prev - prices[i] == 1)){\\n                prev = prices[i];\\n                i += 1;\\n            }\\n            answer += GET(i - current);\\n            if(current == i) i++;\\n        }\\n\\n        return answer;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887465,
                "title": "simple-c-code-by-fun2s",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        int start = 0;\\n        int end = 0;\\n        int j = 0;\\n        long long cnt = 1;\\n        long long sum = 0;\\n        for(int i=1;i<n;i++){\\n            if(prices[i]+1==prices[i-1]){\\n                cnt++;\\n            }\\n            else{\\n                sum+=(cnt*(cnt+1)/2)-cnt;\\n                cnt=1;\\n            }\\n        }\\n        if(cnt!=1){\\n                sum+=(cnt*(cnt+1)/2)-cnt;\\n\\n        }\\n        return sum+n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        int start = 0;\\n        int end = 0;\\n        int j = 0;\\n        long long cnt = 1;\\n        long long sum = 0;\\n        for(int i=1;i<n;i++){\\n            if(prices[i]+1==prices[i-1]){\\n                cnt++;\\n            }\\n            else{\\n                sum+=(cnt*(cnt+1)/2)-cnt;\\n                cnt=1;\\n            }\\n        }\\n        if(cnt!=1){\\n                sum+=(cnt*(cnt+1)/2)-cnt;\\n\\n        }\\n        return sum+n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864239,
                "title": "java-easy-100-time",
                "content": "# Code\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long total = 0;\\n        int lengthOfDescentBehindMe = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            if (i > 0 && (prices[i-1]-prices[i] ==1)) {\\n                lengthOfDescentBehindMe++;\\n            } else {\\n                lengthOfDescentBehindMe = 0;\\n            }\\n\\n            total = total + 1 + lengthOfDescentBehindMe;\\n        }\\n\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long total = 0;\\n        int lengthOfDescentBehindMe = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            if (i > 0 && (prices[i-1]-prices[i] ==1)) {\\n                lengthOfDescentBehindMe++;\\n            } else {\\n                lengthOfDescentBehindMe = 0;\\n            }\\n\\n            total = total + 1 + lengthOfDescentBehindMe;\\n        }\\n\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855192,
                "title": "python3-summation-o-n-time-beats-98-5-o-1-space-beats-99-5",
                "content": "# Intuition\\nThe array of stock prices can be split up into distinct complete descent periods, i.e. periods where the stock is strictly decreasing by 1. From there, we observe that for each complete descent period, each subarray of the period is also a valid descent period.\\n\\nFor example, the descent period of `[3, 2, 1]` contains within it descent periods of `[3, 2]`, `[2, 1]`, `[3]`, `[2]`, and `[1]`. The descent period of `[4, 3, 2, 1]` contains descent periods of `[4, 3, 2]`, `[3, 2, 1]`, `[4, 3]`, `[3, 2]`, `[2, 1]`, `[3]`, `[2]`, and `[1]`.\\n\\nWe can start to see that each complete descent period of size `n` has a total of the sum of integers from 1 to `n`. Since we don\\'t need to worry about what the exact descent periods are, we can simply sum them up using the classic summation formula `n * (n + 1) / 2`.\\n\\n\\n# Approach\\nIterate through the list of prices and count up the number of elements in the current descent period. When we reach a stock that is no longer a part of the current descent period (not exactly 1 less than the previous stock), we have obtained a complete descent period. Add the summation of 1 to `n` to the total number of descent periods and reset the length of the current descent period.\\n\\n# Complexity\\n- Time complexity: O(n). We pass through the list of prices once\\n- Space complexity: O(1). We only need to keep track of the total number of descent periods and the current descent period\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        descent_periods = 0\\n\\n        current_descent = 1\\n        for i in range(1, len(prices)):\\n            if prices[i] == prices[i - 1] - 1:\\n                current_descent += 1\\n            else:\\n                descent_periods += current_descent * (current_descent + 1) // 2\\n                current_descent = 1\\n\\n        descent_periods += current_descent * (current_descent + 1) // 2\\n        return descent_periods\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        descent_periods = 0\\n\\n        current_descent = 1\\n        for i in range(1, len(prices)):\\n            if prices[i] == prices[i - 1] - 1:\\n                current_descent += 1\\n            else:\\n                descent_periods += current_descent * (current_descent + 1) // 2\\n                current_descent = 1\\n\\n        descent_periods += current_descent * (current_descent + 1) // 2\\n        return descent_periods\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832459,
                "title": "java-sliding-window-easiest-solution-o-n",
                "content": "# Intuition : \\n###### This question can be solved using sliding window approach .... this approach is better than dp as we are doing this with O(1) SC but if we try DP approach then we may go to O(N) SC .\\n###### We will use two pointers i and j .. [3,2,1] in this array all values satisfies the given condition of preceding element greater then current element..... so if elements keep on satisfying the contd then for the array [7,6,5,4,3,2,1] the total smooth descent at val=1 will be [7,6,5,4,3,2,1],[6,5,4,3,2,1],[5,4,3,2,1],[4,3,2,1],[3,2,1],[2,1],[1] total 7 subarrays and we need to count this total subarray count.....j-i+1 is 6-0+1 i.e 7 we got out answer  \\n###### if contd doesnt satisfies then just change the vlaue of i to j even for one idx value j-i+1 gives 1 subarray at index =4 if j-i+1 = 4-4+1 =1 so if contd became false then i=j; or else continue the two pointer subarray\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long ans=1;\\n        int i=0;\\n        int j=1;\\n        while(j<prices.length){\\n            if(prices[j]+1!=prices[j-1]){\\n                i=j;\\n            }\\n            ans+=(j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long ans=1;\\n        int i=0;\\n        int j=1;\\n        while(j<prices.length){\\n            if(prices[j]+1!=prices[j-1]){\\n                i=j;\\n            }\\n            ans+=(j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828668,
                "title": "beats-100-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        ret = len(prices)\\n        k=0\\n        if ret<2:\\n            return ret\\n        i=1\\n        while(i<len(prices)):\\n            if (prices[i] == (prices[i-1]-1)):\\n                k = k+1\\n                ret +=k\\n            else:\\n                k=0\\n            i = i+1\\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        ret = len(prices)\\n        k=0\\n        if ret<2:\\n            return ret\\n        i=1\\n        while(i<len(prices)):\\n            if (prices[i] == (prices[i-1]-1)):\\n                k = k+1\\n                ret +=k\\n            else:\\n                k=0\\n            i = i+1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790425,
                "title": "python3-easy-logical-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        prices.append(-1)\\n        l = len(prices)\\n        lst = []\\n        count = 0\\n        for i in range(l-1):\\n            if prices[i] - 1 == prices[i+1]:\\n                count+=1\\n            else:\\n                lst.append(count)\\n                count = 0\\n        res = 0\\n        for i in lst:\\n            temp = i*(i+1)//2\\n            res+=temp\\n        return res + l - 1\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        prices.append(-1)\\n        l = len(prices)\\n        lst = []\\n        count = 0\\n        for i in range(l-1):\\n            if prices[i] - 1 == prices[i+1]:\\n                count+=1\\n            else:\\n                lst.append(count)\\n                count = 0\\n        res = 0\\n        for i in lst:\\n            temp = i*(i+1)//2\\n            res+=temp\\n        return res + l - 1\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763068,
                "title": "easy-sol-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple and self explaining solution.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& p) {\\n        int n=p.size();\\n        long long sol=0, j=0;\\n        for(int i=1;i<n;++i){\\n            if(p[i-1] - p[i] != 1) j = i;\\n            sol += i-j+1;\\n        }\\n        return sol+1;\\n    }\\n};\\n```\\n\\n![please upvote.png](https://assets.leetcode.com/users/images/cec5b4c0-f10c-4954-974f-2a8fbb0beece_1689322203.8573625.png)\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& p) {\\n        int n=p.size();\\n        long long sol=0, j=0;\\n        for(int i=1;i<n;++i){\\n            if(p[i-1] - p[i] != 1) j = i;\\n            sol += i-j+1;\\n        }\\n        return sol+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761349,
                "title": "linear-solution-with-caching-intermediate-results",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsider what should be happening at each index. Can it utilize the answer of the previous index? \\nEach index contributes 1 to the global answer for a subarray of size 1. \\nAnd if its value is 1 less than the value at previous index, it can extend the answer of the previous index by 1 and contribute that to the overall answer as well.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(len(prices))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n  def getDescentPeriods(self, prices: List[int]) -> int:\\n    total_smooth_descent_periods = 1\\n    prev_smooth_descent_periods = 0\\n\\n    for i in range(1, len(prices)):\\n      smooth_descent_periods_upto_me = 0\\n      if prices[i] + 1 == prices[i-1]:\\n        smooth_descent_periods_upto_me = prev_smooth_descent_periods + 1\\n      \\n      prev_smooth_descent_periods = smooth_descent_periods_upto_me\\n      total_smooth_descent_periods = total_smooth_descent_periods + smooth_descent_periods_upto_me + 1\\n\\n    return total_smooth_descent_periods\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def getDescentPeriods(self, prices: List[int]) -> int:\\n    total_smooth_descent_periods = 1\\n    prev_smooth_descent_periods = 0\\n\\n    for i in range(1, len(prices)):\\n      smooth_descent_periods_upto_me = 0\\n      if prices[i] + 1 == prices[i-1]:\\n        smooth_descent_periods_upto_me = prev_smooth_descent_periods + 1\\n      \\n      prev_smooth_descent_periods = smooth_descent_periods_upto_me\\n      total_smooth_descent_periods = total_smooth_descent_periods + smooth_descent_periods_upto_me + 1\\n\\n    return total_smooth_descent_periods\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756852,
                "title": "easy-and-single-pass-c-2-pointer-approach-o-n-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long sum(long long x){\\n        return (x*(x+1))/2;\\n    }\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long ans=0;\\n        if(prices.size()==1)return 1;\\n        long long i=0,j=1;\\n        while(i<prices.size()){\\n            while(j<prices.size()&&prices[j]==prices[j-1]-1){\\n                j++;\\n            }\\n            if(i+1==j){\\n                ans++;\\n            }else{\\n                ans+=sum(j-i);\\n            }i=j;j++;\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sum(long long x){\\n        return (x*(x+1))/2;\\n    }\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long ans=0;\\n        if(prices.size()==1)return 1;\\n        long long i=0,j=1;\\n        while(i<prices.size()){\\n            while(j<prices.size()&&prices[j]==prices[j-1]-1){\\n                j++;\\n            }\\n            if(i+1==j){\\n                ans++;\\n            }else{\\n                ans+=sum(j-i);\\n            }i=j;j++;\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754290,
                "title": "simple-dp-solution-math-c-solution",
                "content": "# Intuition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        long long ans = 1,temp=1;\\n        for(int i=1;i<n;i++){\\n            if(prices[i-1]-1==prices[i]){\\n                temp += 1;\\n            }else{\\n                temp = 1;\\n            }\\n            ans += temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        long long ans = 1,temp=1;\\n        for(int i=1;i<n;i++){\\n            if(prices[i-1]-1==prices[i]){\\n                temp += 1;\\n            }else{\\n                temp = 1;\\n            }\\n            ans += temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722017,
                "title": "simple-c-easy-linear-o-n-without-dp",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long l = 1, ans = 0;\\n        int n = prices.size();\\n\\n        for(int i=1; i<n; i++){\\n            if(prices[i-1] == prices[i]+1){\\n                l++;\\n            }\\n            else{\\n                ans += (l*(l+1))/2;\\n                l = 1;\\n            }\\n        }\\n        ans += (l*(l+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long l = 1, ans = 0;\\n        int n = prices.size();\\n\\n        for(int i=1; i<n; i++){\\n            if(prices[i-1] == prices[i]+1){\\n                l++;\\n            }\\n            else{\\n                ans += (l*(l+1))/2;\\n                l = 1;\\n            }\\n        }\\n        ans += (l*(l+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712184,
                "title": "easy-c-solution-no-data-structure-basic-for-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int i=0,j=0;\\n        int n=prices.size();\\n        long long int ans=0;\\n        long long int ct=0;\\n       for(int i=0;i<n-1;i++){\\n           if(prices[i]-prices[i+1]==1){\\n               ct++;\\n           }\\n           else{\\n               ct+=1;\\n               ans+=(ct)*(ct+1)/2;\\n               ct=0;\\n           }\\n       }\\n        if(ct!=0){\\n            ct+=1;\\n              ans+=(ct)*(ct+1)/2;\\n        }\\n        else ans+=1;\\n      \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int i=0,j=0;\\n        int n=prices.size();\\n        long long int ans=0;\\n        long long int ct=0;\\n       for(int i=0;i<n-1;i++){\\n           if(prices[i]-prices[i+1]==1){\\n               ct++;\\n           }\\n           else{\\n               ct+=1;\\n               ans+=(ct)*(ct+1)/2;\\n               ct=0;\\n           }\\n       }\\n        if(ct!=0){\\n            ct+=1;\\n              ans+=(ct)*(ct+1)/2;\\n        }\\n        else ans+=1;\\n      \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708687,
                "title": "n-n-1-2",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        ll ans=0;\\n        ll cnt=0;\\n        ll prev = prices[0];\\n        ll n=prices.size();\\n        \\n        for(int i=1; i<n; i++){\\n            ll curr = prices[i];\\n            if(curr == prev-1) cnt++;\\n            \\n            else{\\n                //cout<<cnt<<endl;\\n                ans += (cnt*(cnt+1))/2;\\n                cnt=0;\\n            }\\n            prev=curr;\\n        }\\n        \\n        ans += (cnt*(cnt+1))/2;\\n        return ans+n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        ll ans=0;\\n        ll cnt=0;\\n        ll prev = prices[0];\\n        ll n=prices.size();\\n        \\n        for(int i=1; i<n; i++){\\n            ll curr = prices[i];\\n            if(curr == prev-1) cnt++;\\n            \\n            else{\\n                //cout<<cnt<<endl;\\n                ans += (cnt*(cnt+1))/2;\\n                cnt=0;\\n            }\\n            prev=curr;\\n        }\\n        \\n        ans += (cnt*(cnt+1))/2;\\n        return ans+n;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3705594,
                "title": "must-see-solution-beats-100-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//     long long getDescentPeriods(vector<int>& prices) {\\n//         int i=0;\\n//         long long res=1;\\n//         int cnt=1; //1ST POINTER CASE WILL BE  HANDLED BY THIS\\n//         int n=prices.size();\\n//         while(i<n-1){\\n//             //res+=cnt;\\n// //OUR POINTER WILL NOT GO UPTO LAST ELEMENT IF CONDTION AND ELSE CASE WILL TELL AND HANDLE LAST CASE\\n//             if(prices[i+1]==prices[i]-1)cnt++;\\n//              else cnt=1;\\n//             res+=cnt;\\n//             i++;\\n//         }\\n//         return res;\\n//     }\\n       long long getDescentPeriods(vector<int>& prices) {\\n        int i=0,j=0;\\n        long long res=1;\\n        int cnt=0; \\n        int n=prices.size();\\n        while(i<n-1){\\n        \\n            if(prices[i+1]!=prices[i]-1)j=i+1;\\n            i++; //WE HAVE KEPT IT BEFORE TO HANDLE 1STR ELEMENT CASE AS WE ARE COMPARING WITH I+1\\n            res+=i-j+1;\\n            //i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//     long long getDescentPeriods(vector<int>& prices) {\\n//         int i=0;\\n//         long long res=1;\\n//         int cnt=1; //1ST POINTER CASE WILL BE  HANDLED BY THIS\\n//         int n=prices.size();\\n//         while(i<n-1){\\n//             //res+=cnt;\\n// //OUR POINTER WILL NOT GO UPTO LAST ELEMENT IF CONDTION AND ELSE CASE WILL TELL AND HANDLE LAST CASE\\n//             if(prices[i+1]==prices[i]-1)cnt++;\\n//              else cnt=1;\\n//             res+=cnt;\\n//             i++;\\n//         }\\n//         return res;\\n//     }\\n       long long getDescentPeriods(vector<int>& prices) {\\n        int i=0,j=0;\\n        long long res=1;\\n        int cnt=0; \\n        int n=prices.size();\\n        while(i<n-1){\\n        \\n            if(prices[i+1]!=prices[i]-1)j=i+1;\\n            i++; //WE HAVE KEPT IT BEFORE TO HANDLE 1STR ELEMENT CASE AS WE ARE COMPARING WITH I+1\\n            res+=i-j+1;\\n            //i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674592,
                "title": "simple-intuitive-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& nums) {\\n        long long ans=0;\\n        long long cnt=1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]+1==nums[i-1]){\\n                cnt++;\\n            }else{\\n                ans+=(cnt*(cnt+1))/2;\\n                cnt=1;\\n            }\\n        }\\n        ans+=(cnt*(cnt+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& nums) {\\n        long long ans=0;\\n        long long cnt=1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]+1==nums[i-1]){\\n                cnt++;\\n            }else{\\n                ans+=(cnt*(cnt+1))/2;\\n                cnt=1;\\n            }\\n        }\\n        ans+=(cnt*(cnt+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659912,
                "title": "simple-java-code-just-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long result = 1;\\n        int len = prices.length;\\n        int countSub = 1;\\n        for(int i = 0; i < len - 1; i++){\\n            if(prices[i] - prices[i + 1] == 1)\\n                countSub++;\\n            else {\\n                countSub = 1;\\n            }\\n            result += countSub;             \\n        }\\n        return result;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long result = 1;\\n        int len = prices.length;\\n        int countSub = 1;\\n        for(int i = 0; i < len - 1; i++){\\n            if(prices[i] - prices[i + 1] == 1)\\n                countSub++;\\n            else {\\n                countSub = 1;\\n            }\\n            result += countSub;             \\n        }\\n        return result;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659729,
                "title": "simple-c-sliding-window-solution",
                "content": "# Intuition\\nmove j pointer until the difference between comnsecutive prices is 1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n) solution\\n\\n- Space complexity:\\nO(1) complexity\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n       long long s=0;\\n       for(int i=0;i<prices.size();i++){\\n           int j=i;\\n           while(j+1<prices.size()&&prices[j]-prices[j+1]==1)s+=j-i+1,j++;\\n           s+=j-i+1;\\n           i=j;\\n       }\\n       return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n       long long s=0;\\n       for(int i=0;i<prices.size();i++){\\n           int j=i;\\n           while(j+1<prices.size()&&prices[j]-prices[j+1]==1)s+=j-i+1,j++;\\n           s+=j-i+1;\\n           i=j;\\n       }\\n       return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656423,
                "title": "dp-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long res = 0;\\n        int n = prices.size();\\n        vector<int>dp(n,1);\\n        res = dp[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(prices[i] + 1 == prices[i-1])\\n            dp[i] += dp[i-1];\\n            res += dp[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long res = 0;\\n        int n = prices.size();\\n        vector<int>dp(n,1);\\n        res = dp[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(prices[i] + 1 == prices[i-1])\\n            dp[i] += dp[i-1];\\n            res += dp[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645614,
                "title": "java-2ms-100-and-clean-code",
                "content": "# Approach\\n1. Iterate from second to last price, determining if it\\'s a secretse of 1.\\n    - If yes, increase the length of consecutive decreases, Else reset it to 1\\n2. Add the length of consecutive decreases to the answer.\\n3. Return the answer.  \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long periods = 1;\\n        int length = 1;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i] - prices[i-1] != -1) {\\n                length = 1;\\n            } else {\\n                length++;\\n            }\\n            periods += length;\\n        }\\n        return periods;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long periods = 1;\\n        int length = 1;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (prices[i] - prices[i-1] != -1) {\\n                length = 1;\\n            } else {\\n                length++;\\n            }\\n            periods += length;\\n        }\\n        return periods;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625727,
                "title": "best-explanation-of-c-solution-with-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->( i ) for length = 1 , no of smooth periods = size of prices[]\\n( ii ) for  length >1 , i have defined rally_days that for what no of days the rally would lasts,\\n   e.g. rally is like [4,3,2,1] no of rally days is 4\\nand  we have to find all the smooth periods from this rally \\n( iii ) for finding these periods i have created a map \\nmap [ rally_days] = rally_days - 1 +map[ rally_days - 1]\\nin this way i have calculated all the smooth periods\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N) + O(N) - for creating a map and  for traversal of prices\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1) only\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n\\n        int size = prices.size() ;\\n\\n        long long ans = 0 ;\\n\\n        unordered_map<long long , long long >smooth_periods ;\\n\\n        smooth_periods[ 2 ] = 1;\\n\\n        for( int i = 3 ; i <= size  ; i++ ){\\n\\n            smooth_periods[ i ] =  i - 1  +  smooth_periods[ i - 1 ] ;\\n        }\\n\\n        int prev_price = -1 ;\\n        int rally_days = 1 ;\\n\\n        for( int i = 0 ; i < size ; i++ ){\\n\\n            if( prev_price - prices[ i ] == 1 )\\n               rally_days++ ;\\n                              \\n            else{\\n\\n              if( rally_days > 1 ){\\n\\n                ans = ans +  smooth_periods[ rally_days ] ;\\n                rally_days = 1 ;    \\n\\n                }           \\n            }  \\n\\n            prev_price = prices[ i ] ;\\n\\n        }\\n\\n        if( rally_days != 1 )\\n            ans = ans + smooth_periods[ rally_days ] ;\\n\\n         \\n        long long  finalAns = ans + size ;  \\n\\n         return finalAns ;\\n\\n\\n     \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n\\n        int size = prices.size() ;\\n\\n        long long ans = 0 ;\\n\\n        unordered_map<long long , long long >smooth_periods ;\\n\\n        smooth_periods[ 2 ] = 1;\\n\\n        for( int i = 3 ; i <= size  ; i++ ){\\n\\n            smooth_periods[ i ] =  i - 1  +  smooth_periods[ i - 1 ] ;\\n        }\\n\\n        int prev_price = -1 ;\\n        int rally_days = 1 ;\\n\\n        for( int i = 0 ; i < size ; i++ ){\\n\\n            if( prev_price - prices[ i ] == 1 )\\n               rally_days++ ;\\n                              \\n            else{\\n\\n              if( rally_days > 1 ){\\n\\n                ans = ans +  smooth_periods[ rally_days ] ;\\n                rally_days = 1 ;    \\n\\n                }           \\n            }  \\n\\n            prev_price = prices[ i ] ;\\n\\n        }\\n\\n        if( rally_days != 1 )\\n            ans = ans + smooth_periods[ rally_days ] ;\\n\\n         \\n        long long  finalAns = ans + size ;  \\n\\n         return finalAns ;\\n\\n\\n     \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611966,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe number of sub arrays from ith index to jth index is i-j+1.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int i=0;\\n        int j=1;\\n        long ans=1;\\n        while(j<prices.length){\\n            if( prices[j-1]-prices[j]==1){\\n\\t\\t\\t//It means that j(current element) can be part of previous subarrays (j-i) \\n\\t\\t\\t//and can also start a subarray from me (+1). So add (j-i+1) in total Subarrays\\n                int count=j-i+1;\\n                ans+=count;\\n            }else{\\n\\t\\t\\t//It means that j cannot be part of previous subarrays but can start subarray from me. So, ans+=1\\n                i=j;\\n                ans+=1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int i=0;\\n        int j=1;\\n        long ans=1;\\n        while(j<prices.length){\\n            if( prices[j-1]-prices[j]==1){\\n\\t\\t\\t//It means that j(current element) can be part of previous subarrays (j-i) \\n\\t\\t\\t//and can also start a subarray from me (+1). So add (j-i+1) in total Subarrays\\n                int count=j-i+1;\\n                ans+=count;\\n            }else{\\n\\t\\t\\t//It means that j cannot be part of previous subarrays but can start subarray from me. So, ans+=1\\n                i=j;\\n                ans+=1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608615,
                "title": "beats-100-in-time-runs-in-o-1-space",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the maximum length of smooth descent periods of a stock if the day under consideration is the ending day\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long sum=1;\\n        long pre=1;\\n        long curr=0;\\n        for (int i=1;i<prices.length;i++)\\n        {\\n            curr=(prices[i-1]-prices[i]==1)? pre+1:1;\\n            sum+=curr;\\n            pre=curr;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long sum=1;\\n        long pre=1;\\n        long curr=0;\\n        for (int i=1;i<prices.length;i++)\\n        {\\n            curr=(prices[i-1]-prices[i]==1)? pre+1:1;\\n            sum+=curr;\\n            pre=curr;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594654,
                "title": "easiest-solution-one-pass-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long result=1,cnt=1;//since our loop start from 1st index\\n        int n=prices.size();\\n        for(int i=1;i<n;i++){\\n            if(prices[i-1]==prices[i]+1)cnt++;\\n            else cnt=1;\\n            result+=cnt;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long result=1,cnt=1;//since our loop start from 1st index\\n        int n=prices.size();\\n        for(int i=1;i<n;i++){\\n            if(prices[i-1]==prices[i]+1)cnt++;\\n            else cnt=1;\\n            result+=cnt;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563045,
                "title": "python-sliding-window-dp-counting",
                "content": "**Sliding window**\\n```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:      \\n        \"\"\"\\n        [1+] d[i - 1]/3/ - 1 = d[i]/2/\\n        \\n        3 2 1 4\\n       +3 -> + 1\\n       +3 2 -> +2\\n       +3 2 1 -> +3\\n       +4 -> +1\\n        sliding windows + number of subarrays ending at right\\n        \"\"\"\\n        count = 0\\n        left = 0\\n        for right in range(len(prices)):\\n            if right and prices[right - 1] - 1 != prices[right]:\\n                left = right\\n            count += right - left + 1 # number of valid subarrays ending at \\'right\\'\\n        return count\\n```\\n\\n**DP**\\n`dp[i]` - the longest smooth descent period ending at **i**\\n```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        \"\"\"\\n        dp[i] = 1\\n        if d[i - 1]/3/ - 1 == d[i]/2/:\\n          dp[1] += dp[i - 1]\\n        \"\"\"\\n        N = len(prices)\\n        dp = [1] * N\\n        for i in range(N):\\n            if i and prices[i - 1] - 1 == prices[i]:\\n                dp[i] += dp[i - 1] # as dp[i] depends only on dp[i - 1] we can replace the state with 2 variables: current and prev and then sum at the same time\\n        return sum(dp)\\n```\\nCan be optimized to `O(1)` space.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:      \\n        \"\"\"\\n        [1+] d[i - 1]/3/ - 1 = d[i]/2/\\n        \\n        3 2 1 4\\n       +3 -> + 1\\n       +3 2 -> +2\\n       +3 2 1 -> +3\\n       +4 -> +1\\n        sliding windows + number of subarrays ending at right\\n        \"\"\"\\n        count = 0\\n        left = 0\\n        for right in range(len(prices)):\\n            if right and prices[right - 1] - 1 != prices[right]:\\n                left = right\\n            count += right - left + 1 # number of valid subarrays ending at \\'right\\'\\n        return count\\n```\n```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        \"\"\"\\n        dp[i] = 1\\n        if d[i - 1]/3/ - 1 == d[i]/2/:\\n          dp[1] += dp[i - 1]\\n        \"\"\"\\n        N = len(prices)\\n        dp = [1] * N\\n        for i in range(N):\\n            if i and prices[i - 1] - 1 == prices[i]:\\n                dp[i] += dp[i - 1] # as dp[i] depends only on dp[i - 1] we can replace the state with 2 variables: current and prev and then sum at the same time\\n        return sum(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554784,
                "title": "java-easy-one-pass-solution-with-explanation",
                "content": "We will find a continuosly decresing sequence and all permutations of it using formula for sum on n natural number. n*(n-1)/2\\n```\\npublic long getDescentPeriods(int[] prices) {\\n        int n = prices.length;\\n        long res = n;\\n        \\n        for(int i = 0 ; i < n;){\\n            \\n            long k = 0;\\n            while(i < n-1 && prices[i]-prices[i+1] == 1 ){\\n                i++;\\n                k++;\\n            }\\n            \\n            k++; // range is inclusive\\n            res += (long)(k*(k-1)/2);\\n            i++;\\n        }\\n                \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic long getDescentPeriods(int[] prices) {\\n        int n = prices.length;\\n        long res = n;\\n        \\n        for(int i = 0 ; i < n;){\\n            \\n            long k = 0;\\n            while(i < n-1 && prices[i]-prices[i+1] == 1 ){\\n                i++;\\n                k++;\\n            }\\n            \\n            k++; // range is inclusive\\n            res += (long)(k*(k-1)/2);\\n            i++;\\n        }\\n                \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528035,
                "title": "one-pass-simple-solution-c",
                "content": "\\n# Approach\\nWe use a counter variable to indicate the number of consequent gradualt descents(The difference between current and next element is 1) in the list and when there is a change, we calculate the value based on the current count (the sum of \"count\" numbers) and then re initate the count to 1. \\n\\n# Complexity\\n- Time complexity:\\nO(n) - Since this is a one pass solution to the problem\\n\\n- Space complexity:\\nThe Space Complexity is O(1) as we do not use any other datastructure.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int sz = prices.size();\\n        long long count = 1;\\n        long long finCount = 0;\\n\\n        if( sz==1 ) return 1;\\n\\n        for( int i=0 ; i<sz-1 ; i++ ){\\n            if( prices[i] - prices[i+1] == 1 ){\\n                count++;\\n            }else{\\n                finCount += count * (count+1) / 2;\\n                count = 1;\\n            }\\n\\n            if( i==sz-2 ){\\n                finCount += count * (count+1) / 2;\\n            }\\n        }\\n\\n        return finCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int sz = prices.size();\\n        long long count = 1;\\n        long long finCount = 0;\\n\\n        if( sz==1 ) return 1;\\n\\n        for( int i=0 ; i<sz-1 ; i++ ){\\n            if( prices[i] - prices[i+1] == 1 ){\\n                count++;\\n            }else{\\n                finCount += count * (count+1) / 2;\\n                count = 1;\\n            }\\n\\n            if( i==sz-2 ){\\n                finCount += count * (count+1) / 2;\\n            }\\n        }\\n\\n        return finCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521453,
                "title": "two-pointers-formula",
                "content": "# Intuition\\nUse two pointers i and j and calculate number of sub-arrays between those 2 pointers\\n\\n# Approach\\n Calculating a formula\\n The sum of descent period\\n 1+2+3+4+5+6\\n we form pairs like\\n 1+6 = 2+5 = 3+7 i.e (1+N) = (2+N-1) = (3+N-2)\\n there are 3 pairs, for N elements it should be N/2 pairs \\n i.e (1+N)*N/2 \\n (n)=> (n+1)*Math(n/2)\\n subsCount(2)=3, subsCount(3)=6\\n\\n Then we track 2 pointers and calculating a distance\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar getDescentPeriods = function(prices) {\\n    const subsCount=(n)=> (Math.trunc(n*(n+1)/2));\\n    \\n    let periods=0;\\n    for(let i=0;i<prices.length;i++){\\n        let j=i;\\n        while(j+1<prices.length && prices[j]-prices[j+1]===1) j++;\\n        const dist = j-i+1;\\n        periods+=subsCount(dist);\\n        i=j;\\n    }\\n    return periods;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getDescentPeriods = function(prices) {\\n    const subsCount=(n)=> (Math.trunc(n*(n+1)/2));\\n    \\n    let periods=0;\\n    for(let i=0;i<prices.length;i++){\\n        let j=i;\\n        while(j+1<prices.length && prices[j]-prices[j+1]===1) j++;\\n        const dist = j-i+1;\\n        periods+=subsCount(dist);\\n        i=j;\\n    }\\n    return periods;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494808,
                "title": "java-sliding-window-like-leetcode-413-with-comments",
                "content": "// b <=============2110. Number of Smooth Descent Periods of a Stock====>\\n    // https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/description/\\n\\n    // Logic is same as using sliding window.\\n    // Dry run ans you will get the answer.\\n\\n```\\npublic long getDescentPeriods(int[] prices) {\\n\\n        int n = prices.length;\\n        if (n == 1)\\n            return 1;\\n\\n        int si = 0, ei = 0;\\n        long totalArrays = 0;\\n\\n        while (ei < n - 1) {\\n            int currVal = prices[ei], nextVal = prices[ei + 1];\\n            if (currVal - nextVal != 1) { // Shrinking the window.\\n                while (si <= ei) {\\n                    int count = ei - si + 1;\\n                    totalArrays += count;\\n                    si++;\\n                }\\n            }\\n            ei++; // Increasing the window.\\n        }\\n        while (si <= ei) { // After the termination of the above loop, a window might still be left. So\\n                           // shrinking the window again to get all the remaining subarrays.\\n            int count = ei - si + 1;\\n            totalArrays += count;\\n            si++;\\n        }\\n        return totalArrays;\\n    }\\n```\\n\\n// b <=========413. Arithmetic Slices ============>\\n    // https://leetcode.com/problems/arithmetic-slices/description/\\n\\n    // We will increase the window till the difference is same.\\n    // When the difference is not same, we will start shrinking the window till the\\n    // ` both ei and si come to same position.\\n\\n    // # [1,2,3,4,5,7,9,11] , [7,7,7,7,7,7] Test case to dry run.\\n\\n```\\npublic int numberOfArithmeticSlices_subarray(int[] nums) {\\n\\n        int n = nums.length;\\n\\n        if (n < 3)\\n            return 0;\\n\\n        int si = 0, ei = 0, d = 5000, totalSlices = 0;\\n\\n        while (ei < n - 1) {\\n            int currVal = nums[ei], nextVal = nums[ei + 1];\\n            if (nextVal - currVal != d) {\\n                while (si != ei) { // Shrinking the window.\\n                    int count = ei - si - 1; // This will be -ve if the length of the subarray is less than 3.\\n                    totalSlices += count >= 0 ? count : 0;\\n                    si++;\\n                }\\n                d = nextVal - currVal;\\n            }\\n            ei++;\\n        }\\n        // It may happen that after the above loop has been terminated, there is still a\\n        // window left. Hence shrinking the window again to get all the subarrays.\\n        while (si != ei) {\\n            int count = ei - si - 1;\\n            totalSlices += count >= 0 ? count : 0;\\n            si++;\\n        }\\n\\n        return totalSlices;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic long getDescentPeriods(int[] prices) {\\n\\n        int n = prices.length;\\n        if (n == 1)\\n            return 1;\\n\\n        int si = 0, ei = 0;\\n        long totalArrays = 0;\\n\\n        while (ei < n - 1) {\\n            int currVal = prices[ei], nextVal = prices[ei + 1];\\n            if (currVal - nextVal != 1) { // Shrinking the window.\\n                while (si <= ei) {\\n                    int count = ei - si + 1;\\n                    totalArrays += count;\\n                    si++;\\n                }\\n            }\\n            ei++; // Increasing the window.\\n        }\\n        while (si <= ei) { // After the termination of the above loop, a window might still be left. So\\n                           // shrinking the window again to get all the remaining subarrays.\\n            int count = ei - si + 1;\\n            totalArrays += count;\\n            si++;\\n        }\\n        return totalArrays;\\n    }\\n```\n```\\npublic int numberOfArithmeticSlices_subarray(int[] nums) {\\n\\n        int n = nums.length;\\n\\n        if (n < 3)\\n            return 0;\\n\\n        int si = 0, ei = 0, d = 5000, totalSlices = 0;\\n\\n        while (ei < n - 1) {\\n            int currVal = nums[ei], nextVal = nums[ei + 1];\\n            if (nextVal - currVal != d) {\\n                while (si != ei) { // Shrinking the window.\\n                    int count = ei - si - 1; // This will be -ve if the length of the subarray is less than 3.\\n                    totalSlices += count >= 0 ? count : 0;\\n                    si++;\\n                }\\n                d = nextVal - currVal;\\n            }\\n            ei++;\\n        }\\n        // It may happen that after the above loop has been terminated, there is still a\\n        // window left. Hence shrinking the window again to get all the subarrays.\\n        while (si != ei) {\\n            int count = ei - si - 1;\\n            totalSlices += count >= 0 ? count : 0;\\n            si++;\\n        }\\n\\n        return totalSlices;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3493980,
                "title": "python3-dp-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        \\n        n=len(prices)\\n        dp=[1]*n\\n        \\n        for i in range(1,n):\\n            if prices[i]+1==prices[i-1]:\\n                dp[i]=dp[i-1]+1\\n        \\n        return sum(dp)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        \\n        n=len(prices)\\n        dp=[1]*n\\n        \\n        for i in range(1,n):\\n            if prices[i]+1==prices[i-1]:\\n                dp[i]=dp[i-1]+1\\n        \\n        return sum(dp)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479389,
                "title": "o-n-solution-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& p) {\\n        long long cnt=0;\\n        long long ans=p.size();\\n      \\n        for(int i=0;i<p.size()-1;i++){\\n            if(p[i]-p[i+1]==1){\\n                cnt++;\\n                ans+=cnt;\\n            }\\n            else{\\n                cnt=0;\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& p) {\\n        long long cnt=0;\\n        long long ans=p.size();\\n      \\n        for(int i=0;i<p.size()-1;i++){\\n            if(p[i]-p[i+1]==1){\\n                cnt++;\\n                ans+=cnt;\\n            }\\n            else{\\n                cnt=0;\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463087,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        dp = [0] * (n + 1)\\n\\n        countDescents = 0\\n        for i in range(n):\\n            if i > 0 and prices[i - 1] - prices[i] == 1:\\n                countDescents += 1\\n            else:\\n                countDescents = 0\\n            dp[i + 1] = 1 + dp[i] + countDescents\\n        return dp[n]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        dp = [0] * (n + 1)\\n\\n        countDescents = 0\\n        for i in range(n):\\n            if i > 0 and prices[i - 1] - prices[i] == 1:\\n                countDescents += 1\\n            else:\\n                countDescents = 0\\n            dp[i + 1] = 1 + dp[i] + countDescents\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449161,
                "title": "simple-c-solution-easy",
                "content": "\\n# Time complexity \\n- O(n) where n is length of the price array\\n# Space complexity\\n- O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) \\n    {\\n        long long ans=0;  // to store final answer\\n        long long cnt=1;  // to cnt length of the period \\n        int curr=prices[0]; // to compare with preceding price\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(curr-prices[i]==1)  // if condition is satisfied increase the cnt\\n            {\\n             ++cnt;\\n             curr=prices[i];\\n            }\\n            else                  // condition not satisfied\\n            {\\n                cnt*=(cnt+1);    // no of smooth periods in length n => (n*(n+1))/2\\n                cnt/=2;\\n                ans+=cnt;\\n                curr=prices[i];  // update the curr_price\\n                cnt=1;           // update cnt\\n            }\\n        }\\n\\n             cnt*=(cnt+1); // for last window \\n                cnt/=2;\\n                ans+=cnt;\\n                return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) \\n    {\\n        long long ans=0;  // to store final answer\\n        long long cnt=1;  // to cnt length of the period \\n        int curr=prices[0]; // to compare with preceding price\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(curr-prices[i]==1)  // if condition is satisfied increase the cnt\\n            {\\n             ++cnt;\\n             curr=prices[i];\\n            }\\n            else                  // condition not satisfied\\n            {\\n                cnt*=(cnt+1);    // no of smooth periods in length n => (n*(n+1))/2\\n                cnt/=2;\\n                ans+=cnt;\\n                curr=prices[i];  // update the curr_price\\n                cnt=1;           // update cnt\\n            }\\n        }\\n\\n             cnt*=(cnt+1); // for last window \\n                cnt/=2;\\n                ans+=cnt;\\n                return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441592,
                "title": "sliding-window-o-n-constant-space",
                "content": "# Intuition\\nSliding window type\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int i=0,j=1, l=prices.length;\\n        long ans=1;\\n        while(j<l){\\n            if(prices[j]+1 == prices[j-1]){\\n                ans+=j-i+1;\\n            }\\n            else{\\n                ans+=1;\\n                i=j;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        int i=0,j=1, l=prices.length;\\n        long ans=1;\\n        while(j<l){\\n            if(prices[j]+1 == prices[j-1]){\\n                ans+=j-i+1;\\n            }\\n            else{\\n                ans+=1;\\n                i=j;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394018,
                "title": "simple-1-d-dp-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n=prices.size();\\n\\n        //Initializing to 1 as every index would contribute\\n        vector<long long> dp(n,1);\\n\\n        //It the difference beetween ith and i-1th element is 1 then  the no of elements in the sequence of ith element would be 1 + no of elements in sequence of (i+1)th element\\n        for(int i=n-2;i>=0;i--) {\\n            if(prices[i] == prices[i+1]+1) {\\n                dp[i]=1+dp[i+1];\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++) {\\n            ans+=dp[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n=prices.size();\\n\\n        //Initializing to 1 as every index would contribute\\n        vector<long long> dp(n,1);\\n\\n        //It the difference beetween ith and i-1th element is 1 then  the no of elements in the sequence of ith element would be 1 + no of elements in sequence of (i+1)th element\\n        for(int i=n-2;i>=0;i--) {\\n            if(prices[i] == prices[i+1]+1) {\\n                dp[i]=1+dp[i+1];\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++) {\\n            ans+=dp[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386810,
                "title": "python-easy-to-read-and-understand",
                "content": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        cnt, res = 1, 0\\n        i = 1\\n        while i < n:\\n            while i < n and prices[i-1]-prices[i] == 1:\\n                cnt += 1\\n                i += 1\\n            res += cnt*(cnt+1)//2\\n            if i == n:\\n                return res\\n            cnt = 1\\n            i += 1\\n        res += cnt\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDescentPeriods(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        cnt, res = 1, 0\\n        i = 1\\n        while i < n:\\n            while i < n and prices[i-1]-prices[i] == 1:\\n                cnt += 1\\n                i += 1\\n            res += cnt*(cnt+1)//2\\n            if i == n:\\n                return res\\n            cnt = 1\\n            i += 1\\n        res += cnt\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3382641,
                "title": "greedy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& vec) {\\n        long long ans = 0;\\n        int n = vec.size();\\n        long long cnt = 1;\\n\\n        for(int i = 1;i<n;i++){\\n            if(vec[i-1]==vec[i]+1){\\n                cnt++;\\n            }\\n            else{\\n                ans = ans + cnt*(cnt+1)/2;\\n                cnt = 1;\\n            }\\n        }\\n\\n        if(cnt!=0) ans = ans + cnt*(cnt+1)/2;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& vec) {\\n        long long ans = 0;\\n        int n = vec.size();\\n        long long cnt = 1;\\n\\n        for(int i = 1;i<n;i++){\\n            if(vec[i-1]==vec[i]+1){\\n                cnt++;\\n            }\\n            else{\\n                ans = ans + cnt*(cnt+1)/2;\\n                cnt = 1;\\n            }\\n        }\\n\\n        if(cnt!=0) ans = ans + cnt*(cnt+1)/2;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379681,
                "title": "classic-sliding-window-wild",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def getDescentPeriods(self, nums):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        ans = 0\\n        l = 0\\n        for r in range(1,len(nums)):\\n            if nums[r-1]-nums[r] !=1:\\n                l = r\\n            ans+=r-l+1\\n\\n        return ans+1\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def getDescentPeriods(self, nums):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        ans = 0\\n        l = 0\\n        for r in range(1,len(nums)):\\n            if nums[r-1]-nums[r] !=1:\\n                l = r\\n            ans+=r-l+1\\n\\n        return ans+1\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379404,
                "title": "ver-easy-easy-to-understand-straight-forward-o-n-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long int ans=prices.size();\\n        long long int n=0;\\n        for(int i=1;i<prices.size();i++){\\n            if(prices[i-1]-prices[i]==1){\\n                n= 1+ n++;\\n                ans=ans+n;\\n            }\\n            else{\\n              n=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long int ans=prices.size();\\n        long long int n=0;\\n        for(int i=1;i<prices.size();i++){\\n            if(prices[i-1]-prices[i]==1){\\n                n= 1+ n++;\\n                ans=ans+n;\\n            }\\n            else{\\n              n=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367737,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func getDescentPeriods(_ prices: [Int]) -> Int {\\n        \\n        var cnt = [Int: Int]()\\n        var cur = 0\\n        var prv = -1\\n\\n        for p in prices {\\n            if p == prv - 1 {\\n                cur += 1\\n            }\\n            else {\\n                if cur > 1 { cnt[cur, default: 0] += 1 }\\n                cur = 1\\n            }\\n            prv = p\\n        }\\n\\n        if cur > 1 { cnt[cur, default: 0] += 1 }\\n\\n        return prices.count + cnt\\n            .map { $0.value * (1..<$0.key).reduce(0, +) }\\n            .reduce(0, +)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getDescentPeriods(_ prices: [Int]) -> Int {\\n        \\n        var cnt = [Int: Int]()\\n        var cur = 0\\n        var prv = -1\\n\\n        for p in prices {\\n            if p == prv - 1 {\\n                cur += 1\\n            }\\n            else {\\n                if cur > 1 { cnt[cur, default: 0] += 1 }\\n                cur = 1\\n            }\\n            prv = p\\n        }\\n\\n        if cur > 1 { cnt[cur, default: 0] += 1 }\\n\\n        return prices.count + cnt\\n            .map { $0.value * (1..<$0.key).reduce(0, +) }\\n            .reduce(0, +)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359310,
                "title": "c-simple-solution-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        long long int ans = 0;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int temp = 1;\\n            ans += temp;\\n            while(i < n-1 && prices[i+1] == prices[i]-1)\\n            {\\n                temp++;\\n                ans += temp;\\n                i++;\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        long long int ans = 0;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int temp = 1;\\n            ans += temp;\\n            while(i < n-1 && prices[i+1] == prices[i]-1)\\n            {\\n                temp++;\\n                ans += temp;\\n                i++;\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358637,
                "title": "java-simple-solution-o-n-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCounting all the consecutive and reduce the consecutive pairs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long sum=0;\\n        if(prices.length==0) return sum;\\n        sum+=prices.length;\\n        long consecutive=0;\\n        for(int i=0;i<prices.length;i++){\\n            if(i+1<prices.length&&prices[i]-prices[i+1]==1){\\n                sum++;\\n                consecutive++;\\n            } else{\\n                if(consecutive>=2){\\n                    sum+=sumConsecutive(consecutive-1);\\n                }\\n                    consecutive=0;\\n            }\\n        }\\n        if(consecutive>=2) sum+=sumConsecutive(consecutive-1);\\n\\n        return sum;\\n\\n    }\\n\\n    public long sumConsecutive(long num){\\n        return (1+num)*num/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] prices) {\\n        long sum=0;\\n        if(prices.length==0) return sum;\\n        sum+=prices.length;\\n        long consecutive=0;\\n        for(int i=0;i<prices.length;i++){\\n            if(i+1<prices.length&&prices[i]-prices[i+1]==1){\\n                sum++;\\n                consecutive++;\\n            } else{\\n                if(consecutive>=2){\\n                    sum+=sumConsecutive(consecutive-1);\\n                }\\n                    consecutive=0;\\n            }\\n        }\\n        if(consecutive>=2) sum+=sumConsecutive(consecutive-1);\\n\\n        return sum;\\n\\n    }\\n\\n    public long sumConsecutive(long num){\\n        return (1+num)*num/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353142,
                "title": "c-o-n-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long ans = 0, cur = 0, prev = INT_MIN;\\n        for (auto& n : prices){\\n            if (n == prev - 1) ans += ++cur;\\n            else ans += cur = 1;\\n            prev = n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long ans = 0, cur = 0, prev = INT_MIN;\\n        for (auto& n : prices){\\n            if (n == prev - 1) ans += ++cur;\\n            else ans += cur = 1;\\n            prev = n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346371,
                "title": "recursive-approach-tle",
                "content": "Following the standard input-output method!\\n```\\nclass Solution {\\nprivate:    \\n    void solve(int index, vector<int> &nums, vector<int> &op){\\n        if(index==nums.size()) return;\\n        \\n        if(op.size()==0){\\n            count++;\\n            vector<int> temp;\\n            op.push_back(nums[index]);\\n            solve(index+1,nums,op);\\n            solve(index+1,nums,temp);\\n        }\\n        else{\\n            if(op.back()==1+nums[index]){\\n                count++;\\n                op.push_back(nums[index]);\\n                solve(index+1,nums,op);\\n            }\\n        }\\n    }\\n    \\n    \\npublic:\\n    int count=0;\\n    long long getDescentPeriods(vector<int>& nums) {\\n        vector<int> op;\\n        solve(0,nums,op);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:    \\n    void solve(int index, vector<int> &nums, vector<int> &op){\\n        if(index==nums.size()) return;\\n        \\n        if(op.size()==0){\\n            count++;\\n            vector<int> temp;\\n            op.push_back(nums[index]);\\n            solve(index+1,nums,op);\\n            solve(index+1,nums,temp);\\n        }\\n        else{\\n            if(op.back()==1+nums[index]){\\n                count++;\\n                op.push_back(nums[index]);\\n                solve(index+1,nums,op);\\n            }\\n        }\\n    }\\n    \\n    \\npublic:\\n    int count=0;\\n    long long getDescentPeriods(vector<int>& nums) {\\n        vector<int> op;\\n        solve(0,nums,op);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331086,
                "title": "c-easy-approach",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& arr) {\\n        long long ans=1;\\n        long long count=1;\\n        int n=arr.size();\\n\\n        for(int i=1;i<n;i++){\\n            if(arr[i]-arr[i-1]==-1) {\\n                count++;\\n            }\\n            else{\\n                count=1;\\n            }\\n            ans+=count;\\n        }\\n\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& arr) {\\n        long long ans=1;\\n        long long count=1;\\n        int n=arr.size();\\n\\n        for(int i=1;i<n;i++){\\n            if(arr[i]-arr[i-1]==-1) {\\n                count++;\\n            }\\n            else{\\n                count=1;\\n            }\\n            ans+=count;\\n        }\\n\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328953,
                "title": "java-0ms-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n                  O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n                  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long getDescentPeriods(int[] arr) {\\n      long num=0;\\n      long sum=0;\\n      for(int i=0;i<arr.length-1;i++){\\n          if(arr[i]==arr[i+1]+1){\\n              num++;\\n              sum+=num;\\n          }\\n          else{\\n              num++;\\n              sum+=num;\\n              num=0;\\n          }\\n      }  \\n      if(num!=0){\\n          sum+=num;\\n          num=0;\\n      }\\n      return sum+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long getDescentPeriods(int[] arr) {\\n      long num=0;\\n      long sum=0;\\n      for(int i=0;i<arr.length-1;i++){\\n          if(arr[i]==arr[i+1]+1){\\n              num++;\\n              sum+=num;\\n          }\\n          else{\\n              num++;\\n              sum+=num;\\n              num=0;\\n          }\\n      }  \\n      if(num!=0){\\n          sum+=num;\\n          num=0;\\n      }\\n      return sum+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326210,
                "title": "sliding-window-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long int i=0,j=0,ans=0;\\n        while(i<prices.size()){\\n   \\n                while(i-j!=prices[j]-prices[i] && j<=i){\\n                    j++;\\n                }\\n          \\n            ans+=(long long)(i-j+1);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        long long int i=0,j=0,ans=0;\\n        while(i<prices.size()){\\n   \\n                while(i-j!=prices[j]-prices[i] && j<=i){\\n                    j++;\\n                }\\n          \\n            ans+=(long long)(i-j+1);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326203,
                "title": "simple-c-solution-with-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& p) {\\n        long long cnt=0;\\n        long long ans=0;\\n      \\n        for(int i=0;i<p.size()-1;i++){\\n            if(p[i]-p[i+1]==1){\\n                cnt++;\\n                ans+=cnt;\\n            }\\n            else{\\n                cnt=0;\\n\\n            }\\n        }\\n        ans+=p.size();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& p) {\\n        long long cnt=0;\\n        long long ans=0;\\n      \\n        for(int i=0;i<p.size()-1;i++){\\n            if(p[i]-p[i+1]==1){\\n                cnt++;\\n                ans+=cnt;\\n            }\\n            else{\\n                cnt=0;\\n\\n            }\\n        }\\n        ans+=p.size();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325833,
                "title": "made-easy-c-100-intutive",
                "content": "###### This problem is same as [leetcode-413](https://leetcode.com/problems/arithmetic-slices/solutions/3325813/made-easy-c-100-intutive/?orderBy=hot) So I strongly  recommend to solve it first.\\n\\n# \\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\n# Complexity \\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n                    //\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        long long ans=n,count=0;\\n\\n        for(int i=1; i<n; i++)\\n        {\\n            if(prices[i] - prices[i-1] == -1){\\n                count++;\\n            }\\n            else{\\n                count=0;\\n            }\\n            ans+=count;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\n                    //\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n        int n = prices.size();\\n        long long ans=n,count=0;\\n\\n        for(int i=1; i<n; i++)\\n        {\\n            if(prices[i] - prices[i-1] == -1){\\n                count++;\\n            }\\n            else{\\n                count=0;\\n            }\\n            ans+=count;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325634,
                "title": "easy-javascript-solution-beats-92-with-o-n-tc",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar getDescentPeriods = function(prices) {\\n    let count = 0\\n    let res = 0\\n    for (let i=0;i<prices.length-1;i++){\\n        if(prices[i]-prices[i+1] === 1){\\n            count += 1\\n            res += count\\n        } else {\\n            count = 0\\n        }\\n    }\\n    return res + prices.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar getDescentPeriods = function(prices) {\\n    let count = 0\\n    let res = 0\\n    for (let i=0;i<prices.length-1;i++){\\n        if(prices[i]-prices[i+1] === 1){\\n            count += 1\\n            res += count\\n        } else {\\n            count = 0\\n        }\\n    }\\n    return res + prices.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3325095,
                "title": "sliding-window-simple-and-understandable-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n      // each day (single) is included in the smooth descent period\\n        long long ans = 0 , count = 1;\\n        if(prices.size()==1) return 1;\\n        int i = 0;\\n        int size = prices.size()-1;\\n        while(i < size )\\n        {\\n            if(prices[i] - prices[i+1] == 1)\\n            {\\n                count++;\\n                i++;\\n            }\\n            else\\n            {\\n                ans = ans + count*(count+1)/2;\\n                count = 1;\\n                i++;\\n            }\\n        }\\n        \\n        ans = ans + count*(count+1)/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& prices) {\\n      // each day (single) is included in the smooth descent period\\n        long long ans = 0 , count = 1;\\n        if(prices.size()==1) return 1;\\n        int i = 0;\\n        int size = prices.size()-1;\\n        while(i < size )\\n        {\\n            if(prices[i] - prices[i+1] == 1)\\n            {\\n                count++;\\n                i++;\\n            }\\n            else\\n            {\\n                ans = ans + count*(count+1)/2;\\n                count = 1;\\n                i++;\\n            }\\n        }\\n        \\n        ans = ans + count*(count+1)/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324576,
                "title": "c-simple-iteration-mathematical-very-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        for(int i=0;i<n;i++) {\\n            bool found = false;\\n\\n            if(i+1 < n && nums[i] - 1 == nums[i+1]) {\\n                found = true;\\n                int j = i;\\n                while(j+1 < n && nums[j] - 1 == nums[j+1]) {\\n                    j++;\\n                }\\n                long long len = j - i + 1;\\n                ans += len*(len+1)/2;\\n                i = j;\\n            }\\n\\n            if(!found) {\\n                ans += 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getDescentPeriods(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        for(int i=0;i<n;i++) {\\n            bool found = false;\\n\\n            if(i+1 < n && nums[i] - 1 == nums[i+1]) {\\n                found = true;\\n                int j = i;\\n                while(j+1 < n && nums[j] - 1 == nums[j+1]) {\\n                    j++;\\n                }\\n                long long len = j - i + 1;\\n                ans += len*(len+1)/2;\\n                i = j;\\n            }\\n\\n            if(!found) {\\n                ans += 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1727516,
                "content": [
                    {
                        "username": "Wizmurmu07",
                        "content": "Please UPVOTE if you LIKE! \\uD83D\\uDE01\\n\\nNote that the end of smooth descent periods are all marked in bold.\\nso the return value is sum(dp) = 7, because the answer needs the total count of smooth descent periods ended at any index of prices.\\nFurthmore since dp[i] is only dependent on dp[i - 1], the Space Complexity can be reduced to O(1), and we can redefine dp as the number of smooth descent periods ended at the previous index\\nCode link : https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/solutions/2944556/100-faster-java-soln-with-o1/"
                    }
                ]
            }
        ]
    }
]