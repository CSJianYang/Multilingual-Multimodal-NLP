[
    {
        "title": "Partition Array Into Two Arrays to Minimize Sum Difference",
        "question_content": "You are given an integer array nums of 2 * n integers. You need to partition nums into two arrays of length n to minimize the absolute difference of the sums of the arrays. To partition nums, put each element of nums into one of the two arrays.\nReturn the minimum possible absolute difference.\n&nbsp;\nExample 1:\n\nInput: nums = [3,9,7,3]\nOutput: 2\nExplanation: One optimal partition is: [3,9] and [7,3].\nThe absolute difference between the sums of the arrays is abs((3 + 9) - (7 + 3)) = 2.\n\nExample 2:\n\nInput: nums = [-36,36]\nOutput: 72\nExplanation: One optimal partition is: [-36] and [36].\nThe absolute difference between the sums of the arrays is abs((-36) - (36)) = 72.\n\nExample 3:\n\nInput: nums = [2,-1,0,4,-2,-9]\nOutput: 0\nExplanation: One optimal partition is: [2,4,-9] and [-1,0,-2].\nThe absolute difference between the sums of the arrays is abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 15\n\tnums.length == 2 * n\n\t-107 <= nums[i] <= 107",
        "solutions": [
            {
                "id": 1513298,
                "title": "c-meet-in-middle",
                "content": "**Algorithm**\\n\\n**High Level Approach:**\\n\\n\\t*  We divide the input array into two arbitary parts. \\n\\t*  Then, We take one subset from each part, such that, sum of size of both subset = n. \\n\\t*  And with that subset we try to minimise the absolute difference.\\n\\n**Detailed:**\\n* Divide the original array in *two arbitary parts*, each of size n. LeftPart: [0, n-1], RightPart[n,2 * n-1]  \\n* Find all possible sums in each part.\\n\\t* As each part will be of size <= 15\\n\\t* We can safely enumerate all possible sums in each part.\\n\\t* For each part, store the sum of a subset along with the size of the subset.\\n\\t* In Code:\\n\\t\\t* I have used two 2-D vectors, left and right, to store sums of all possible subset.\\n\\t\\t* Left[ i ]: stores all possible sums of the subset of size i, in the left part.\\n\\t\\t* Similarly, for right part.\\n\\t\\t\\n* **Requirement:** We need to divide the original array in two parts of size n, each. *Such that the absolute difference of sum is minimised.*\\n\\t* Let say from left part we take a subset of size *sz* (Let\\'s say its sum is *a*), then from right part we need to take a subset of size of *n-sz* (Let\\'s say its sum is *b*). Then, Part1Sum = a+b.\\n\\t\\t* We have to minimise *abs(Part1Sum - Part2Sum)*\\n\\t\\t\\t* Now, Part1Sum = a+b and Part2Sum = TotalSum - (a+b)\\n\\t\\t\\t* Thus we have to minimise, *abs(TotalSum -2  a - 2  b)*\\n\\t\\t* Now we iterate over a, and binary search b in the *vector right*    \\n \\n**TC**\\nO(2^n * log(2^n))\\n\\nThis technique commonly known as **Meet In Middle**. Commonly used when **25 <= array_size <= 40**\\n\\n\\n*UPD1 : Used vector instead of sets, code is almost 50% faster than before.*\\n\\t\\n\\t\\n```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size(), res = 0, sum = 0;\\n        sum = accumulate(nums.begin(), nums.end(),0);\\n        \\n        int N = n/2;\\n        vector<vector<int>> left(N+1), right(N+1);\\n        \\n\\t\\t//storing all possible sum in left and right part\\n        for(int mask = 0; mask<(1<<N); ++mask){\\n            int sz = 0, l = 0, r = 0;\\n            for(int i=0; i<N; ++i){\\n                if(mask&(1<<i)){\\n                    sz++;\\n                    l += nums[i];\\n                    r += nums[i+N];\\n                }\\n            }\\n            left[sz].push_back(l);\\n            right[sz].push_back(r);\\n        }\\n\\n        for(int sz=0; sz<=N; ++sz){\\n            sort(right[sz].begin(), right[sz].end());\\n        }\\n\\n        res = min(abs(sum-2*left[N][0]), abs(sum-2*right[N][0]));\\n\\n\\t\\t//iterating over left part\\n        for(int sz=1; sz<N; ++sz){\\n            for(auto &a : left[sz]){\\n                int b = (sum - 2*a)/2, rsz = N-sz;\\n                auto &v = right[rsz];\\n                auto itr = lower_bound(v.begin(), v.end(),b); //binary search over right part\\n                \\n                if(itr!=v.end()) res = min(res, abs(sum-2*(a+(*itr))));\\n                if(itr!= v.begin()){\\n                    auto it = itr; --it;\\n                    res = min(res, abs(sum-2*(a+(*it))));\\n                }                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size(), res = 0, sum = 0;\\n        sum = accumulate(nums.begin(), nums.end(),0);\\n        \\n        int N = n/2;\\n        vector<vector<int>> left(N+1), right(N+1);\\n        \\n\\t\\t//storing all possible sum in left and right part\\n        for(int mask = 0; mask<(1<<N); ++mask){\\n            int sz = 0, l = 0, r = 0;\\n            for(int i=0; i<N; ++i){\\n                if(mask&(1<<i)){\\n                    sz++;\\n                    l += nums[i];\\n                    r += nums[i+N];\\n                }\\n            }\\n            left[sz].push_back(l);\\n            right[sz].push_back(r);\\n        }\\n\\n        for(int sz=0; sz<=N; ++sz){\\n            sort(right[sz].begin(), right[sz].end());\\n        }\\n\\n        res = min(abs(sum-2*left[N][0]), abs(sum-2*right[N][0]));\\n\\n\\t\\t//iterating over left part\\n        for(int sz=1; sz<N; ++sz){\\n            for(auto &a : left[sz]){\\n                int b = (sum - 2*a)/2, rsz = N-sz;\\n                auto &v = right[rsz];\\n                auto itr = lower_bound(v.begin(), v.end(),b); //binary search over right part\\n                \\n                if(itr!=v.end()) res = min(res, abs(sum-2*(a+(*itr))));\\n                if(itr!= v.begin()){\\n                    auto it = itr; --it;\\n                    res = min(res, abs(sum-2*(a+(*it))));\\n                }                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513435,
                "title": "python-easy-explanation-meet-in-the-middle",
                "content": "**NOTE** - This is question was very easy, if you had done this https://leetcode.com/problems/closest-subsequence-sum/. So Please first go and try that.\\n\\nHere we have to find 2 groups of equal length (N).\\nLet\\'s say, left_ans is required the N elements required for first group, and right_ans is the other N elements for second group.\\n\\n**Intuition ->**\\nThe main and only intuition which is required here is,\\nnums = [1,3,6,5,4,2]\\nSo, let\\'s divide into 2 parts\\nleft_part = [1,3,6]\\nright_part = [5,4,2]\\nN = len(nums) // 2, i.e. no. of elements in each group. Here 3.\\nSo here, to make left_ans either we can take all 3 from left_part and 0 from right_part, or 1 from left_part and 2(N-1) from right_part, 2 from left_part and 1(N-2) from right_part.\\n\\nSo how this works is, if we take 1 from left_part, so this means we have taken one group of element, so its sum is taken from l_sum = left_sums[1], now to make is closer to half = total // 2, we need to add req_sum = half - l_sum, so we will binary search the value of it in right_sums. So now lest_ans_sum will become l_sum + r_sum(the binary search sum we got closest go req_sum).\\nNote - Above we are just finding the best possible sum of left_ans, as right_ans sum will then be total - left_ans_sum.\\n\\nThe get_sums function generate all possible subset sums using k elements from nums.\\nnums = [1,3,6]\\nget_sums(nums) will give,\\n{1: [1, 3, 6], # using only 1 elements from nums\\n2: [4, 7, 9], # using only 2\\n3: [10]} # using all 3\\n\\n**Why not TLE ->**\\nAnd why this works is, because we are generating all possible subset sums using only k elements, where k is from 1 to N. Which is in total 2\\\\**k, and as max value of k is 15, so 2\\\\**15 is 32,000. Which is easy to work with. While if you try to make all subset sums, it becomes 2\\\\**30 is 1,073,741,824 which will give TLE.\\n\\n**Meet in the Middle ->**\\nThis technique is called meet in the middle. Here we are halving the max array size from 30, to 15. As generating all possible subset sums is feasible, ie 2\\\\**15. And to complete left_ans, we are taking subset sum of k from left_part, and N-k from right_part.\\n\\n**Time Complexity ->** \\nFor N elements, there are 2\\\\**N subset possible. Then we also sum those each of those subset. O(N * 2^N)\\nFor each k from 1 to 15, there are 2\\\\**M1 subset sums for left, then we are sorting right O(M2 * logM2), then we are finding its other part using binary search logM2. \\nO(2\\\\**M1 * logM2 + M2 * logM2), \\nwhere,\\nM1 = no. of elements in left_sums[k], \\nM2 = no. of elements in right_sums[N-k]\\n\\n**Space Complexity ->**\\nAs there are 2\\\\**N subsets, for left and right. So, O(2 * 2^N), where max value of N is 15.\\n\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        N = len(nums) // 2 # Note this is N/2, ie no. of elements required in each.\\n        \\n        def get_sums(nums): # generate all combinations sum of k elements\\n            ans = {}\\n            N = len(nums)\\n            for k in range(1, N+1): # takes k element for nums\\n                sums = []\\n                for comb in combinations(nums, k):\\n                    s = sum(comb)\\n                    sums.append(s)\\n                ans[k] = sums\\n            return ans\\n        \\n        left_part, right_part = nums[:N], nums[N:]\\n        left_sums, right_sums = get_sums(left_part), get_sums(right_part)\\n        ans = abs(sum(left_part) - sum(right_part)) # the case when taking all N from left_part for left_ans, and vice versa\\n        total = sum(nums) \\n        half = total // 2 # the best sum required for each, we have to find sum nearest to this\\n        for k in range(1, N):\\n            left = left_sums[k] # if taking k no. from left_sums\\n            right = right_sums[N-k] # then we have to take remaining N-k from right_sums.\\n            right.sort() # sorting, so that we can binary search the required value\\n            for x in left:\\n                r = half - x # required, how much we need to add in x to bring it closer to half.\\n                p = bisect.bisect_left(right, r) # we are finding index of value closest to r, present in right, using binary search\\n                for q in [p, p-1]:\\n                    if 0 <= q < len(right):\\n                        left_ans_sum = x + right[q]\\n                        right_ans_sum = total - left_ans_sum\\n                        diff = abs(left_ans_sum - right_ans_sum)\\n                        ans = min(ans, diff) \\n        return ans\\n```\\n\\n\\nPlease give this a **UPVOTE** , if you liked my effort.\\nAnd feel free to let me know if you have any doubts or suggestions.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        N = len(nums) // 2 # Note this is N/2, ie no. of elements required in each.\\n        \\n        def get_sums(nums): # generate all combinations sum of k elements\\n            ans = {}\\n            N = len(nums)\\n            for k in range(1, N+1): # takes k element for nums\\n                sums = []\\n                for comb in combinations(nums, k):\\n                    s = sum(comb)\\n                    sums.append(s)\\n                ans[k] = sums\\n            return ans\\n        \\n        left_part, right_part = nums[:N], nums[N:]\\n        left_sums, right_sums = get_sums(left_part), get_sums(right_part)\\n        ans = abs(sum(left_part) - sum(right_part)) # the case when taking all N from left_part for left_ans, and vice versa\\n        total = sum(nums) \\n        half = total // 2 # the best sum required for each, we have to find sum nearest to this\\n        for k in range(1, N):\\n            left = left_sums[k] # if taking k no. from left_sums\\n            right = right_sums[N-k] # then we have to take remaining N-k from right_sums.\\n            right.sort() # sorting, so that we can binary search the required value\\n            for x in left:\\n                r = half - x # required, how much we need to add in x to bring it closer to half.\\n                p = bisect.bisect_left(right, r) # we are finding index of value closest to r, present in right, using binary search\\n                for q in [p, p-1]:\\n                    if 0 <= q < len(right):\\n                        left_ans_sum = x + right[q]\\n                        right_ans_sum = total - left_ans_sum\\n                        diff = abs(left_ans_sum - right_ans_sum)\\n                        ans = min(ans, diff) \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721045,
                "title": "best-solution-tabulation-failed-full-explaination-c",
                "content": "***Before we start understanding the reason and the solution which will resolve this , all I want is ,you all to be focused ,patient and have a copy and pen with yourself!**\\n\\n *Basic Approach* :-\\n \\n-> We\\'ll find the total sum of the given array which will be our range of the array  **i.e arr[] = [1,2,7]**\\n-> our range will be **0--10**\\n->Now we\\'ll use the Tabulation method to the generate the subset sum of the given array and put that element in the \\nvector \\n\\n\\t\\t\\t\\tfor example --  arr[] = [1,2,7]\\n\\t\\t\\t\\tsumbset sum = [ 0 , 1 , 2 , 3 , 7 , 8 , 9 , 10] // we\\'ll get this from tabulation from the last row\\n\\t\\t\\t\\tHere we\\'ll consider *0* because ,what if we don\\'t select any element\\n\\t\\t\\t\\t\\n\\n-> After getting this subset sum vector , we\\'ll divide array into two half and check the value from the first half and minimize it\\n\\tExplained below why first half only\\n\\n\\t i.e minimize(abs(Sum1-Sum2))        -->where Sum1 = Sum of left part , Sum2 = sum of right part \\n\\t\\tAlso Total Sum(Ts)= Sum1 + Sum2;      -->Total Sum is 10 here i.e Sum of Given array \\n\\t\\tTherefore Sum2 = Ts - Sum1;\\n\\t\\tminimize(abs(Sum1 - (Ts - Sum1)));\\n\\t\\ti.e **Minimize(Ts - 2*Sum1)**  // Final value which we have to be minimize\\n\\t\\n**NOTE : There\\'s a problem in this i.e *It will work only for +ve intgeres (i.e All values in the given array is +ve)***\\n\\n**## 1. Reason why tabulation failed!**\\n\\nAs we encounter the negative elements in the given array So there\\'s a possibility that our **Total Sum or Range becomes \\nnegavtive**\\nAs soon as our range becomes negative the tabulation method fails because it is impossible to create a 2D matrix of size less than 0 i.e NEGATIVE \\nOr There\\'s a possibilty that our sum or range becomes **0** in this case too it is impossible to create the 2D matrix.\\nSo we\\'ll follow up with another approach which is know as **Meet in the Middle** \\n\\n**## 2. Meet In The Middle Approach**\\n*Will explain with eg at end*\\n\\n1. Here, the only and simple approach is that we\\'ll divide our array into two parts.\\n\\n2. As it is given that our array is of even length so we\\'ll have the partitioned array of equal length (N/2) where N is the size of original array\\n3. Then we will find the all the subset sum in both the arrays i.e in the left array as well as right array.\\n\\t\\t-> while calculating the subset sum of left array and right array we also have to take the count of element used while taking          out sum\\n4. We can store the sum with given values in MAP or in 2D vector acoording to our need, Here I\\'ve used vector because it is easy to access the value \\n5. So here, to make left_ans either we can take all 3 from left_part and 0 from right_part, or 1 from left_part and (N-1) from right_part, 2 from left_part and (N-2) from right_part.\\n\\n\\t\\tfor eg : arr[] = [3,9,7,3]\\n\\t\\tleft array = [3,9] , right array = [7,3]\\n\\t\\tleft array and right array subset sum with number of element used :\\n\\t\\tNumber used : Sum  (for left)                Number used : Sum (for right)\\n\\t\\t\\t\\t  [0 : 0]                                      [0 : 0]\\n\\t\\t\\t\\t  [1 : 3 , 9 ]                                 [1 : 7, 3]\\n\\t\\t\\t\\t  [2 : 12 ]                                    [2 : 10]\\n\\t\\t\\t\\t  \\n\\n6. Now we\\'ll iterate through the left array and find the nearest possible value which will help to minimize the ans\\n7. Also for finding the value in the right array we\\'ll first sort it and use binary search to get the value\\n8.  So how this works is, if we take 1 from left_part, so this means we have taken one group of element, so its sum is taken from left part i.e **l_sum = left_sums[1]**, now to make is closer to **half = total / 2**(Where Total is the size of array)\\n  \\n\\t we need to add **required_sum = half - l_sum**, so we will binary search the value of it in right_sums\\n\\t So now **least_ans_sum will become l_sum + r_sum(the binary search sum we got closest go required_sum).**\\n\\t \\n9. Explanation of **int b = (totalSum - 2*a)/2** :\\nLet **T = totalSum**. We want to **minimize abs(sum2 - sum1)**. We can say **sum2 = T - sum1**\\nLet say from left part we take a **subset of size sz (Let\\'s say its sum is a)**, then from right part we need to take a **subset of size of n-sz (Let\\'s say its sum is b).**\\n\\n  Objective now becomes **minimize abs(T - 2 * sum1)**, at the best possible outcome we can have abs() = 0 which will     happen when 2 * sum1 = T\\n\\nWe can say **sum1 = a+b**. We know a which comes from left part.\\n\\t**So 2 * (a+b) = T ===> b = (T-2*a)/2 .**\\n\\t\\n10. Now it\\'ll be more clear with code which is given below \\n\\n\\n ///\\n\\n\\tclass Solution {\\n\\tpublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size(),  sum = 0;\\n        sum = accumulate(nums.begin(), nums.end(),0);  // To find the total sum of the array \\n        \\n        int N = n/2; // Divide it into two equals parts as length is even\\n        vector<vector<int>> left(N+1), right(N+1); // left array and right array\\n        \\n\\t\\t//All possible sum in left and right part (Generating and storing using BIT-Masking)\\n        for(int mask = 0; mask<(1<<N); ++mask){  // (1<<n) means 2^n i.e we\\'ll iterate through 0 to 2^n\\n            int idx = 0, l_sum = 0, r_sum = 0;\\n            for(int i=0; i<N; ++i){\\n                if(mask&(1<<i)){  // To check if the bit is set or not \\n                    idx++;\\n                    l_sum += nums[i];\\n                    r_sum += nums[i+N];\\n                }\\n            }\\n            left[idx].push_back(l_sum);\\n            right[idx].push_back(r_sum);   // storing\\n        }\\n\\n        for(int idx=0; idx<=N; ++idx){\\n            sort(right[idx].begin(), right[idx].end());   // as we\\'ll perform binary search on right so we have to sort it first\\n        }\\n\\n\\t int res = min(abs(sum-2*left[N][0]), abs(sum-2*right[N][0]));  // To get the minimum answer from the max sum from both array\\n\\t\\t\\t//iterating over left part\\n\\t\\t\\tfor(int idx=1; idx<N; ++idx){ // iterate from 1 so we dont have to include 0 and check for all value except last as we have alr considered it\\n\\t\\t\\t\\tfor(auto &a : left[idx]){ // check the sum at each number position\\n\\t\\t\\t\\t\\tint b = (sum - 2*a)/2; // find the value to be minimized \\n\\t\\t\\t\\t\\tint rightidx = N-idx; // find the number value in right array\\n\\t\\t\\t\\t\\tauto &v = right[rightidx]; // store the vector in v at right number position\\n\\t\\t\\t\\t\\tauto itr = lower_bound(v.begin(), v.end(),b); //binary search over right part\\n\\n\\t\\t\\t\\t\\tif(itr!=v.end()) res = min(res, abs(sum-2*(a+(*itr)))); // if found in vector then only update otherwise continue\\n\\n\\t\\t\\t\\t\\t}                \\n\\t\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\n\\t\\t}\\n\\t};\\n \\n**## Why NOT TLE ?**\\n\\n\\n   This works ,because we are generating all possible subset sums using only k elements, where k is from 1 to N. Which is in total 2k, and as max value of k is 15, so 215 is 32,000. Which is easy to work with. While if you try to make all subset sums, it becomes 230 is 1,073,741,824 which will give TLE.\\n   \\n**##    IF IT HELPS YOU! UPVOTE PLEASE!**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size(),  sum = 0;\\n        sum = accumulate(nums.begin(), nums.end(),0);  // To find the total sum of the array \\n        \\n        int N = n/2; // Divide it into two equals parts as length is even\\n        vector<vector<int>> left(N+1), right(N+1); // left array and right array\\n        \\n\\t\\t//All possible sum in left and right part (Generating and storing using BIT-Masking)\\n        for(int mask = 0; mask<(1<<N); ++mask){  // (1<<n) means 2^n i.e we\\'ll iterate through 0 to 2^n\\n            int idx = 0, l_sum = 0, r_sum = 0;\\n            for(int i=0; i<N; ++i){\\n                if(mask&(1<<i)){  // To check if the bit is set or not \\n                    idx++;\\n                    l_sum += nums[i];\\n                    r_sum += nums[i+N];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1630774,
                "title": "python-explanation-with-pictures-binary-search",
                "content": "You might have seen the so-called meet-in-the-middle solution, here I will explain it in detail with pictures.\\n\\nSuppose we brute force check all possible subsets firstly, the time complexity would be O(2 ^ N), where N is the length of the array. Given N = 30, we are likely to have a time complexity of O(10 ^ 9) and TLE.\\n\\n> The key is: we divide the array into two halves, **iterate over one half and binary search on the other half**. Thus the time complexity would be reduced to O(n logn) where n = 10^5.\\n\\nLet\\'s say that we need to divide array **A** of 2\\\\*N numbers into **a** and **b** with N numbers each. Since we know which numbers are in **b** once we finish **a**, so the problem can be simplified to just select N numbers into **a**. \\n![image](https://assets.leetcode.com/users/images/290ac4bb-a49d-47e7-b5c5-03d9a043c48e_1639617073.0572672.png)\\n\\nAs we mentioned earlier, we won\\'t directly pick N numbers from **A**, but we divide **A** into two sub-arrays of N numbers each. Then we select some numbers from the first sub-array, some numbers from the second sub-array to make up **a**.\\n\\n![image](https://assets.leetcode.com/users/images/da8477f5-b34e-47f1-a6b7-de55e6b2ec70_1639617242.7950191.png)\\n\\nMore specifically, since we have N numbers in **a**, suppose we pick **x** numbers from the first sub-array, we must then pick exactly **N - x** numbers from the second sub-array.\\n\\n![image](https://assets.leetcode.com/users/images/bd400e4c-e66e-48a7-8642-89f74b26390a_1639617399.616014.png)\\n\\nThen we iterate over the first half, find out **ALL** sublist and record its:\\n- number of elements in this sublist: **num**\\n- sum of this sublist: **sum**\\n\\nWe store all **num - sum** pair into a hastable **Lft**. Similarly we build **Rgt** on the second sub-array, but we need to make the list sorted.\\n\\n![image](https://assets.leetcode.com/users/images/7ff6a2cb-faa1-416b-8a84-3235f9d91128_1639617473.0285244.png)\\n\\nFinally, we just need to iterate over all possible **num - sum** pair in **Lft**.\\nSuppose we have **num_1** and **sum_1**, what we are looking for?\\n> We are looking for a pair **num_2 - sum_2** in **Rgt**, where **num_2 = N - num_1** and **sum_2** is as close to **sum(A)/2 - sum_1** as possible, which can be done using Binary Search.\\n\\n![image](https://assets.leetcode.com/users/images/d52f18c1-c594-44ca-820b-bdcd7717d2fd_1639617716.7262156.png)\\n\\n**Python**\\n```\\ndef minimumDifference(self, A: List[int]) -> int:\\n        n, target = len(A) // 2, sum(A) // 2\\n        lft, rgt = A[:n], A[n:]\\n        l_iter, r_iter = [(0, 0)], [(0, 0)] # (No. of numbers, sum)\\n\\t\\t\\n\\t\\t# Build Lft and Rgt\\n        for a in lft:\\n            cur = []\\n            for pre_num, pre_sum in l_iter:\\n                cur.append((pre_num, pre_sum))\\n                cur.append((pre_num + 1, pre_sum + a))\\n            l_iter = cur[:]\\n        for a in rgt:\\n            cur = []\\n            for pre_num, pre_sum in r_iter:\\n                cur.append((pre_num, pre_sum))\\n                cur.append((pre_num + 1, pre_sum + a))\\n            r_iter = cur[:]\\n            \\n        r_dic = collections.defaultdict(list)\\n        for num, s in r_iter:\\n            r_dic[num].append(s)\\n        for key in r_dic.keys():\\n            r_dic[key] = sorted(r_dic[key])\\n            \\n        ans = float(\\'inf\\')\\n\\t\\t\\n\\t\\t# Iterate over Lft and binary search for the closet half sum in Rgt.\\n        for num, s in l_iter:\\n            key = n - num\\n            idx = bisect.bisect_right(r_dic[key], target - s)\\n            if idx > 0:\\n                ans = min(ans, target - s - r_dic[key][idx - 1])\\n            if idx < len(r_dic[key]):\\n                ans = min(ans, r_dic[key][idx] - target + s)\\n                \\n        return ans * 2 + sum(A) % 2\\n```\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\ndef minimumDifference(self, A: List[int]) -> int:\\n        n, target = len(A) // 2, sum(A) // 2\\n        lft, rgt = A[:n], A[n:]\\n        l_iter, r_iter = [(0, 0)], [(0, 0)] # (No. of numbers, sum)\\n\\t\\t\\n\\t\\t# Build Lft and Rgt\\n        for a in lft:\\n            cur = []\\n            for pre_num, pre_sum in l_iter:\\n                cur.append((pre_num, pre_sum))\\n                cur.append((pre_num + 1, pre_sum + a))\\n            l_iter = cur[:]\\n        for a in rgt:\\n            cur = []\\n            for pre_num, pre_sum in r_iter:\\n                cur.append((pre_num, pre_sum))\\n                cur.append((pre_num + 1, pre_sum + a))\\n            r_iter = cur[:]\\n            \\n        r_dic = collections.defaultdict(list)\\n        for num, s in r_iter:\\n            r_dic[num].append(s)\\n        for key in r_dic.keys():\\n            r_dic[key] = sorted(r_dic[key])\\n            \\n        ans = float(\\'inf\\')\\n\\t\\t\\n\\t\\t# Iterate over Lft and binary search for the closet half sum in Rgt.\\n        for num, s in l_iter:\\n            key = n - num\\n            idx = bisect.bisect_right(r_dic[key], target - s)\\n            if idx > 0:\\n                ans = min(ans, target - s - r_dic[key][idx - 1])\\n            if idx < len(r_dic[key]):\\n                ans = min(ans, r_dic[key][idx] - target + s)\\n                \\n        return ans * 2 + sum(A) % 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1513368,
                "title": "c-python3-binary-search",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/933e9b50b2532374ab8252f431da84b6675663a8) for solutions of weekly 262.\\n\\n**Intuition**\\nHere, we want to pick `n` elements out of `2n` from `nums` such that the absolution difference of the two groups is as close to 0 as possible. If we solve this problem naively, we are facing a `2n` choose `n` time complexity which can be as large as `10^8` when `n == 15`.\\n\\nWe can apply a trick here to trade space for time. We evenly divide `nums` into 2 length-`n` vectors `half0` (first half) and `half1` (second half). For the first half, we compute all combinations of length 0, 1, ..., `n` which takes `2^n` ops to finish (`n*2^n` more precisely). For each group, we save these outcomes in a sorted array. We do the same ops for the 2nd half. When we pick `cnt` numbers from the 2nd half, we need to go to the group corresponding to `n-cnt` from the 1st half to find the proper partition such that when combing the two the total difference is the closest to 0. This can be achieved by binary search which is the reason why we sort the numbers of each group from the 1st half. \\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/2; \\n        vector<int> left(nums.begin(), nums.begin()+n), right(nums.begin()+n, nums.begin()+2*n); \\n        \\n        vector<vector<int>> vals(n+1); \\n        for (int mask = 0; mask < (1<<n); ++mask) {\\n            int diff = 0, key = __builtin_popcount(mask); \\n            for (int i = 0; i < n; ++i) \\n                diff += (mask & (1 << i)) ? left[i] : -left[i]; \\n            vals[key].push_back(diff); \\n        }\\n        \\n        for (auto& v : vals) sort(v.begin(), v.end()); \\n        \\n        int ans = INT_MAX; \\n        for (int mask = 0; mask < (1<<n); ++mask) {\\n            int diff = 0, key = n - __builtin_popcount(mask); \\n            for (int i = 0; i < n; ++i) \\n                diff += (mask & (1 << i)) ? right[i] : -right[i]; \\n            auto it = lower_bound(vals[key].begin(), vals[key].end(), -diff); \\n            if (it != vals[key].begin()) ans = min(ans, abs(diff + *prev(it))); \\n            if (it != vals[key].end()) ans = min(ans, abs(diff + *it)); \\n        }\\n        return ans; \\n    }\\n};\\n```\\n\\nAdding implementation in Python3\\nThe key for this solution to pass is to utilize `combinations` function\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)//2\\n        left, right = nums[:n], nums[n:]\\n        lsum, rsum = sum(left), sum(right)\\n        \\n        ans = inf\\n        for i in range(n+1): \\n            vals = sorted(2*sum(combo)-lsum for combo in combinations(left, i))\\n            for combo in combinations(right, n-i): \\n                diff = 2*sum(combo) - rsum\\n                k = bisect_left(vals, -diff)\\n                if k: ans = min(ans, abs(vals[k-1] + diff))\\n                if k < len(vals): ans = min(ans, abs(vals[k] + diff))\\n        return ans \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/2; \\n        vector<int> left(nums.begin(), nums.begin()+n), right(nums.begin()+n, nums.begin()+2*n); \\n        \\n        vector<vector<int>> vals(n+1); \\n        for (int mask = 0; mask < (1<<n); ++mask) {\\n            int diff = 0, key = __builtin_popcount(mask); \\n            for (int i = 0; i < n; ++i) \\n                diff += (mask & (1 << i)) ? left[i] : -left[i]; \\n            vals[key].push_back(diff); \\n        }\\n        \\n        for (auto& v : vals) sort(v.begin(), v.end()); \\n        \\n        int ans = INT_MAX; \\n        for (int mask = 0; mask < (1<<n); ++mask) {\\n            int diff = 0, key = n - __builtin_popcount(mask); \\n            for (int i = 0; i < n; ++i) \\n                diff += (mask & (1 << i)) ? right[i] : -right[i]; \\n            auto it = lower_bound(vals[key].begin(), vals[key].end(), -diff); \\n            if (it != vals[key].begin()) ans = min(ans, abs(diff + *prev(it))); \\n            if (it != vals[key].end()) ans = min(ans, abs(diff + *it)); \\n        }\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)//2\\n        left, right = nums[:n], nums[n:]\\n        lsum, rsum = sum(left), sum(right)\\n        \\n        ans = inf\\n        for i in range(n+1): \\n            vals = sorted(2*sum(combo)-lsum for combo in combinations(left, i))\\n            for combo in combinations(right, n-i): \\n                diff = 2*sum(combo) - rsum\\n                k = bisect_left(vals, -diff)\\n                if k: ans = min(ans, abs(vals[k-1] + diff))\\n                if k < len(vals): ans = min(ans, abs(vals[k] + diff))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850095,
                "title": "c-first-timers-explanation-meet-in-middle-simplest-code",
                "content": "This is actually a simple concept - but can be little challenging first time you see it.\\nThis was my first time, if you are too, good for you.\\n\\nI have explained below just the way I understood this concept. Short and to point. No BS.\\n\\n**Method 1: Naive Method - DP** (\\u274C TLE)\\n* Memoization would be memory limit, since states include - pos, k, sum\\n* Handling -ve nos. is possible using `unordered_map<string, int>`, where we define a \\n`key = pos + \"#\" + k + \"#\" + sum`, but not a good way.\\n```cpp\\nint totalSum;\\nint solve(vector<int>& nums, int sum, int k, int pos) {\\n    if (k == 0) return abs(2 * sum - totalSum);\\n    if (pos == nums.size()) return INT_MAX;\\n\\n    int take = solve(nums, sum + nums[pos], k - 1, pos + 1);\\n    int dontTake = solve(nums, sum, k, pos + 1);\\n\\n    return min(take, dontTake);\\n}\\nint minimumDifference(vector<int>& nums) {\\n    int n = nums.size();\\n    totalSum = accumulate(begin(nums), end(nums), 0);\\n    return solve(nums, 0, n / 2, 0);\\n}\\n```\\n\\n**Method 2: Meet in the Middle:** \\u2705\\n- Out of `N` length array, we first partition it as left and right arrays each of `N/2` length.\\n- Why? Because it works somewhat like divide and conquer technique.\\n\\n**Step 0**: Pre-compute all the`subarray lengths` -> `subarray possible sum` on either N/2 sides.\\nExample: We have `nums = [3,9,7,3]`\\n\\n**Left** (0 to N/2-1)\\n| subarray length | possible sums |\\n|-----------------|---------------|\\n| 0 ->            |  [0]          |\\n| 1 ->            |  [3, 9]       |\\n| 2 ->            |  [12]         |\\n\\n**Right** (N/2 to N-1)\\n| subarray length | possible sums |\\n|-----------------|---------------|\\n| 0 ->            | [0]           |\\n| 1 ->            | [7, 3]        |\\n| 2 ->            | [10]          |\\n\\n- Now think what we are going to do - we can take each `i` length `left` array sum and compare with each `n-i` length on `right side`.\\n- Can we do it better? Yes, `lower_bound` operation and `totalSum/2 - iLengthSubArrSum` can help us - since otherwise we will N^2 and also search which will cost us.\\n\\n**Read the code now:**\\n```cpp\\nvector<vector<int>> findAllSubsetsSum(vector<int>& nums, int l, int r) {\\n    int totLengthOfSubarray = r - l + 1;\\n    vector<vector<int>> res(totLengthOfSubarray + 1);\\n    for (int i = 0; i < (1 << totLengthOfSubarray); i++) {\\n        int sum = 0, countOfChosenNos = 0;\\n        for (int j = 0; j < totLengthOfSubarray; j++) {\\n            if (i & (1 << j)) {\\n                sum += nums[l + j];\\n                countOfChosenNos++;\\n            }\\n        }\\n        res[countOfChosenNos].push_back(sum);\\n    }\\n    return res;\\n}\\n\\nint minimumDifference(vector<int>& nums) {\\n    int totalSum = accumulate(begin(nums), end(nums), 0);\\n    int n = nums.size();\\n\\n    auto left = findAllSubsetsSum(nums, 0, n / 2 - 1);\\n    auto right = findAllSubsetsSum(nums, n / 2, n - 1);\\n    int target = totalSum / 2, ans = INT_MAX;\\n\\n    //we can take (0 to n/2) length numbers from left\\n    for (int i = 0; i <= n / 2; i++) {\\n        //now we take rest - (n/2-i) length from right, we sort it to binary search\\n        auto r = right[n / 2 - i];\\n        sort(begin(r), end(r));\\n\\n        for (int curleftSum : left[i]) {\\n            int needSumFromRight = target - curleftSum;\\n            auto it = lower_bound(begin(r), end(r), needSumFromRight);\\n            if (it != end(r))\\n                ans = min(ans, abs(totalSum - 2 * (curleftSum + *it)));\\n        }\\n    }\\n    return ans;\\n}\\n```\\n\\n**Q. Why is the minimum answer - `abs(totalSum - 2 * (curleftSum + *it))`?**\\n- `(curleftSum + *it)` is the sum of one side of our `N/2` elements. Consider this as sum `A`.\\n- The sum of other `N/2` elements would be `totalSum - A`. Correct?\\n- Absolute difference would be =  `abs((totalSum - A) - A)` =  `abs(totalSum - 2*A)` = `abs(totalSum - 2 * (curleftSum + *it))`, same as we want.\\n\\n**Upvote if it helps :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint totalSum;\\nint solve(vector<int>& nums, int sum, int k, int pos) {\\n    if (k == 0) return abs(2 * sum - totalSum);\\n    if (pos == nums.size()) return INT_MAX;\\n\\n    int take = solve(nums, sum + nums[pos], k - 1, pos + 1);\\n    int dontTake = solve(nums, sum, k, pos + 1);\\n\\n    return min(take, dontTake);\\n}\\nint minimumDifference(vector<int>& nums) {\\n    int n = nums.size();\\n    totalSum = accumulate(begin(nums), end(nums), 0);\\n    return solve(nums, 0, n / 2, 0);\\n}\\n```\n```cpp\\nvector<vector<int>> findAllSubsetsSum(vector<int>& nums, int l, int r) {\\n    int totLengthOfSubarray = r - l + 1;\\n    vector<vector<int>> res(totLengthOfSubarray + 1);\\n    for (int i = 0; i < (1 << totLengthOfSubarray); i++) {\\n        int sum = 0, countOfChosenNos = 0;\\n        for (int j = 0; j < totLengthOfSubarray; j++) {\\n            if (i & (1 << j)) {\\n                sum += nums[l + j];\\n                countOfChosenNos++;\\n            }\\n        }\\n        res[countOfChosenNos].push_back(sum);\\n    }\\n    return res;\\n}\\n\\nint minimumDifference(vector<int>& nums) {\\n    int totalSum = accumulate(begin(nums), end(nums), 0);\\n    int n = nums.size();\\n\\n    auto left = findAllSubsetsSum(nums, 0, n / 2 - 1);\\n    auto right = findAllSubsetsSum(nums, n / 2, n - 1);\\n    int target = totalSum / 2, ans = INT_MAX;\\n\\n    //we can take (0 to n/2) length numbers from left\\n    for (int i = 0; i <= n / 2; i++) {\\n        //now we take rest - (n/2-i) length from right, we sort it to binary search\\n        auto r = right[n / 2 - i];\\n        sort(begin(r), end(r));\\n\\n        for (int curleftSum : left[i]) {\\n            int needSumFromRight = target - curleftSum;\\n            auto it = lower_bound(begin(r), end(r), needSumFromRight);\\n            if (it != end(r))\\n                ans = min(ans, abs(totalSum - 2 * (curleftSum + *it)));\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1515202,
                "title": "replace-up-to-n-2-elements",
                "content": "> Update: with the use of sorted arrays instead of sets, the runtime went down from 960 to 264 ms. Note that OJ runtime varies like crazy - it was from 960 ms to TLE for the C++ solution with hash sets or ordered sets.\\n\\nThis looks like a typical DP problem. However, even with just 30 elements, there are 155,117,520 ways of picking 15 elements out of 30. This will give us TLE. Another set back is that the value range is wide (`-10^7 <= nums[i] <= 10^7`). We may not have many repeating sums, and, therefore, the memoisation will take a lot of memory and won\\'t be efficient.\\n\\nTo build an intuition on how to solve it, I suggest reading hints for this problem - there are 4 of them.\\n\\nWe first split the array into two halves. To produce an optimal partition, we replace `k` elements in the first array with `k` elements in the second.\\n\\n> This is where this solution differs from the hints. Per hint 4, we pick `k` elements from the first array and try to combine it with `n - k` elements from the second one. This requires to calculate sums of up to `n - 1` elements, where our solution only needs sums of up to `n / 2` elements.\\n\\nWhat is the range for `k`? It is from `0` to `n / 2`. Yes, we only need to go up to `n / 2` - say our arrays are 11 elements each. Replacing 7 elements in the first array with 7 elements in the second will give us the same result as replacing `4` **other** elements. The sums of the arrays will swap - but we do not care as their difference will be the same.\\n\\nSo the idea is to generate all possible sums for the first and second array for 1, 2, 3, ... n / 2 elements. The `dfs` function below does just that.\\n\\nThen, for `k` in `[1, n / 2]`, we pick a sum from the first array, and binary-search for a compliment sum from the second array. The complement value is calculated to minimize the difference between two arrays as `comp = (sum1 + sum2) / 2 - (sum1 - s1k)`. Half of the array\\'s sum is the \\'ideal\\' state when two arrays sums are the same, and `s1k` is one of the generated sums of `k` elements from the first array.\\n\\nWe binary-search for this complement value among all sums of `k` elements from the second array (`s2[k]`), and track the smaller difference.\\n\\n **C++**\\n```cpp\\nvoid dfs(vector<int> &nums, int i, int end, int k, int sum, vector<vector<int>> &sums) {\\n    if (i == end || k >= nums.size() / 4)\\n        sums[k].push_back(sum);\\n    else {\\n        dfs(nums, i + 1, end, k, sum, sums);\\n        dfs(nums, i + 1, end, k + 1, sum + nums[i], sums);\\n    }\\n}\\nint minimumDifference(vector<int>& nums) {\\n    int n = nums.size() / 2, n2 = n / 2, res = INT_MAX;\\n    int sum1 = accumulate(begin(nums), begin(nums) + n, 0), sum2 = accumulate(begin(nums) + n, end(nums), 0);\\n    vector<vector<int>> s1(n2 + 1), s2(n2 + 1);\\n    dfs(nums, 0, n, 0, 0, s1);\\n    dfs(nums, n, 2 * n, 0, 0, s2);\\n    for (int k = 0; k <= n2; ++k) {\\n        sort(begin(s2[k]), end(s2[k]));\\n        for (int s1k : s1[k]) {\\n            int comp = (sum1 + sum2) / 2 - (sum1 - s1k), diff = sum1 - sum2 - s1k * 2;\\n            int j = lower_bound(begin(s2[k]), end(s2[k]), comp) - begin(s2[k]);\\n            if (j < s2[k].size())\\n                res = min(res, abs(diff + s2[k][j] * 2));\\n            if (j > 0)\\n                res = min(res, abs(diff + s2[k][j - 1] * 2));\\n        }\\n    }\\n    return res;\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n, n2, res = len(nums) // 2, len(nums) // 4, inf\\n        def dfs(i: int, end: int, k: int, s: int, sums: List[List[int]]):\\n            if i == end or k >= n2:\\n                sums[k].append(s)\\n                return sums\\n            return (dfs(i + 1, end, k, s, sums), dfs(i + 1, end, k + 1, s + nums[i], sums))[0]\\n        sum1, sum2 = sum(nums[:n]), sum(nums[n:])\\n        s1 = dfs(0, n, 0, 0, [[] for _ in range(n2 + 1)])\\n        s2 = dfs(n, n * 2, 0, 0, [[] for _ in range(n2 + 1)])\\n        for k in range(n2 + 1):\\n            s2[k].sort()\\n            for s1k in s1[k]:\\n                comp, diff = (sum1 + sum2) // 2 - (sum1 - s1k), sum1 - sum2 - s1k * 2\\n                j = bisect.bisect_left(s2[k], comp)\\n                if j < len(s2[k]):\\n                    res = min(res, abs(diff + s2[k][j] * 2))\\n                if j > 0:\\n                    res = min(res, abs(diff + s2[k][j - 1] * 2))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```cpp\\nvoid dfs(vector<int> &nums, int i, int end, int k, int sum, vector<vector<int>> &sums) {\\n    if (i == end || k >= nums.size() / 4)\\n        sums[k].push_back(sum);\\n    else {\\n        dfs(nums, i + 1, end, k, sum, sums);\\n        dfs(nums, i + 1, end, k + 1, sum + nums[i], sums);\\n    }\\n}\\nint minimumDifference(vector<int>& nums) {\\n    int n = nums.size() / 2, n2 = n / 2, res = INT_MAX;\\n    int sum1 = accumulate(begin(nums), begin(nums) + n, 0), sum2 = accumulate(begin(nums) + n, end(nums), 0);\\n    vector<vector<int>> s1(n2 + 1), s2(n2 + 1);\\n    dfs(nums, 0, n, 0, 0, s1);\\n    dfs(nums, n, 2 * n, 0, 0, s2);\\n    for (int k = 0; k <= n2; ++k) {\\n        sort(begin(s2[k]), end(s2[k]));\\n        for (int s1k : s1[k]) {\\n            int comp = (sum1 + sum2) / 2 - (sum1 - s1k), diff = sum1 - sum2 - s1k * 2;\\n            int j = lower_bound(begin(s2[k]), end(s2[k]), comp) - begin(s2[k]);\\n            if (j < s2[k].size())\\n                res = min(res, abs(diff + s2[k][j] * 2));\\n            if (j > 0)\\n                res = min(res, abs(diff + s2[k][j - 1] * 2));\\n        }\\n    }\\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n, n2, res = len(nums) // 2, len(nums) // 4, inf\\n        def dfs(i: int, end: int, k: int, s: int, sums: List[List[int]]):\\n            if i == end or k >= n2:\\n                sums[k].append(s)\\n                return sums\\n            return (dfs(i + 1, end, k, s, sums), dfs(i + 1, end, k + 1, s + nums[i], sums))[0]\\n        sum1, sum2 = sum(nums[:n]), sum(nums[n:])\\n        s1 = dfs(0, n, 0, 0, [[] for _ in range(n2 + 1)])\\n        s2 = dfs(n, n * 2, 0, 0, [[] for _ in range(n2 + 1)])\\n        for k in range(n2 + 1):\\n            s2[k].sort()\\n            for s1k in s1[k]:\\n                comp, diff = (sum1 + sum2) // 2 - (sum1 - s1k), sum1 - sum2 - s1k * 2\\n                j = bisect.bisect_left(s2[k], comp)\\n                if j < len(s2[k]):\\n                    res = min(res, abs(diff + s2[k][j] * 2))\\n                if j > 0:\\n                    res = min(res, abs(diff + s2[k][j - 1] * 2))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213827,
                "title": "java-eli5-explanation-meet-in-the-middle-two-pointer",
                "content": "This Question took me forever, and I had to gather bits and pieces from a bunch of solutions to get it, so I thought I would break this down and explain it in the best way possible.\\n\\n\\n**Quick Subset Recap:**\\n**\\nA subset is a a set of which all the elements are contained in another set. Lets say the \"other set\" is this array  [1,2,3,4]*,\\nAll possible Subsets of this array will be the following:**\\n\\n**1 - {1}\\n2 - {2}\\n3 - {3}\\n4 - {4}\\n5 - {1,2}\\n6 - {1,3}\\n7 - {1,4}\\n8 - {2,3}\\n9 - {2,4}\\n10 - {3,4}\\n11 - {1,2,3}\\n12 - {1,2,4}\\n13 - {1,3,4}\\n14 - {2,3,4}\\n15 - {1,2,3,4}**\\n\\nDid you notice Something? The number of possible subsets of a set is the **2 ^ (Length of the original set) - 1.**\\n\\nSo our original set was of length **4**, and **2 ^ 4 - 1 = 15**.\\n\\n**One way we can generate a set is to count from 1 to 2 ^ (Length of set) - 1, but we have to do this IN BINARY**\\n\\nSo we start with 0001, 0010, 0011, 0100....... until 1111.\\n\\nIf we choose to take only the positions where there is a \\'1\\' at each step, we can generate every subset by the time we reach 1111.\\n\\nNotice now, that the time complexity of this operation is 2^N where N is the length of the set.\\n\\n\\n**Part 1 - The Most Brute Force way to solve this problem**\\n\\nWe have an array such as **[3,9,7,3]** . We can solve this by first getting the totalsum of the array, which in this case is \\n22. Then, we can generate every possible subset of this set, and everytime we run into a situation where **exactly half** of the\\nbits are \\'1\\', then we have ran into a valid parition of the array. Then if we can get the value of the remaining parition by taking \\ntotal and subtracting it by the sum of all the bit positions that were 1.\\n\\n**Example:** \\nWhen we see 0011, we take, we take position 2 and 3. So 7 and 3. The sum is 10. Now total, which is 22 - 10, gives us the \\nsum of the remaining portion of the array, which is 12.\\n\\nNow we can find the difference between 12 and 10 now, and record it. \\n\\nWe keep doing this till we reach 1111, adn we record every difference, and keep track of the minimum.\\n\\nNow, you can notice that this algorithm will take 2^n. So lets look at what we can do to improve this.\\n\\n\\n**Part 2 - What the heck is Meet in the Middle?**\\n\\nThe Brute force way is very wasteful, because we are travelling through many binary strings that do not have exactly\\nN / 2 bits. \\n\\n**Instead of doing this for the full array, and generating every subset for the array of length N, we will do this for two seperate arrays\\nof length N / 2.**  If we generate every subset for an array of Length N, there will be approximately an 2^N - 1 Operations.\\n\\nHowever, if we do it for 2 arrays of length N / 2. There will be 2(N/2) - 1 + 2(N/2) - 1 operations, which is much less!\\n\\nLets prove it! Say an array is of length 8. \\n\\nGenerating every subset for an array of length 8 = 2^8 - 1 = **255 operations:**\\nGenerating every subset for 2 arrays of length 4 = 2^4 -1 + 2^4 - 1 = **30 operations**\\n\\nBy doing this, we managed to improve the performance of the code by almost **90%!!!**\\n\\nNow lets see how we can use this concept and apply it to solve this problem.\\n\\n\\n**Part 3 - How to use Meet in the Middle to solve this problem**\\n\\nNow, lets say I were to split this array in two halfs, right in the middle [1,9,2,0,-5,7,3,6]:\\n\\nSo I will have **[1,9,2,0]** and **[-5,7,3,6]**.\\n\\nHow Can I try to get every possible partition from here?\\n\\nOne logical way to go about this is to think like this:\\n\\n1 - I need 4 elements to get half the sum of the array, then I can just subtract that from total to get the second half.\\n2 - I can try every combination of 1 elements in the left array, and match each combination with every combination\\nof 3 elements from the right side.\\n3 -  I can try every combination of 2 elements in the left array, and match each combination with every combination\\nof 2 elements from the right side.\\n4 -  I can try every combination of 3 elements in the left array, and match each combination with every combination\\nof 1 elements from the right side\\n\\nAnd so on and so on: The general  formula is when we are taking **X** elements from left, we need **N/2 - x elements** from the right.\\n\\nSo now, all we have to do is this:\\n\\n1 - Try every possible subset for left.\\n2 - Every time a bit is turned on (equal 1), we take that position of the bit, and add it to a sum\\n3 - We mainatin a HashMap<count of numbers, the sum of the numbers>\\n4 - We do this for both left and right.\\n\\nFinally, we can check our left HashMap, and look at all the sums that can be generated by each X amount of numbers chosen from \\nleft, then we look at take the complement of that to get half, which again, is N/2 - X from the right, and we can calculate each\\npossible partition this way.\\n\\n**Example with [1,5,3,7,9,4 ]:**\\n\\nRemember, the structure of the HashMap is Map<Amount of numbers chosen, The sum of the numbers>\\n\\nSo after constructing the HashMaps they will look like this in this example:\\n\\n**HashMap Left =\\n {\\n 1: [1,5,3]\\n 2: [(1 + 5) = 6, (1 + 3) = 4, (5 + 3) = 8]\\n 3: [9]\\n }**\\n \\n  **HashMap right =\\n {\\n 1: [7,9,4]\\n 2: [(7 + 9) = 16, (7 + 4) = 11, (9 + 4) = 13]\\n 3: [20]\\n }**\\n\\n\\nSo when we look at a sum where we only took 1 number from the left side, we have to look at sums where we took\\n2 from the right side to make 3 Numbers.\\n\\nThen we take total and subtract by the sum of the numbers from left and right), and that gives us the value of the other half\\nof the array that are unused. Now, we can calculate the difference between both portions and keep track of the min.\\n\\nOne last tidbit to point out, is that we will also have to include 0 as a key in this map. And 0 will mean that we are not taking\\nany elemetns of the specific side(left or right), but when we apply our formula, this will allow us to look for 3 elements from\\nthe other side, and it will play out the same from there. You can try commenting out the part of the code where we add the 0 key and see how some test cases fail to understand this if its not clear.\\n\\nTechnically, we have already improved the time complexity so much at this point, but we can do a bit better. This still wont pass on leetcode because this is a heavy optimization problem with tight time constraints.\\n\\nSo lets look at the final part and see how we can use two pointers to make it work.\\n\\n**Part 4 - Two Pointer**\\n\\nFinally, lets make the observation that the best possible case is where a partition is equal to the total sum of the array / 2. If this happens, then the absolute difference will be 0. **So we want this to happen!**\\n\\nTherefore, we will sort all the lists of sums in our HashMap to beable to apply a two pointer solution.\\n\\nSo now imagine this, we have\\n\\nList of Sums from the left part:\\nList of Sums from the right part:\\n\\nLets have a pointer starting from the begining for the leftSide, and a portion starting from the end of the right list.\\n\\nWe sum up left[0] and right[end -1]. Now we have a sum from some parttion of half the array. We calculate the difference between\\nthis sum adn the sum of the other half.\\n\\nFinally, since we want the sum to gravitate towards total / 2 and not away from it, we check if the current sum is greater than\\ntotal / 2, if it is, we want to make this number sum smaller, so we decrease the pointer from right, else if we want to make it bigger\\nwe increase the pointer from left. We can similarly apply a binary search here, but I chose to skip it since this problem is already so involved.\\n\\n```\\nclass Solution {\\n\\n\\tpublic int minimumDifference(int[] nums) {\\n\\t\\tint n = nums.length / 2;\\n\\t\\tint total = Arrays.stream(nums).sum();\\n\\t\\tHashMap<Integer,List<Integer>> leftMap = new HashMap();\\n\\t\\tHashMap<Integer,List<Integer>> rightMap = new HashMap();\\n\\n\\t\\tcreateSumMappings(0, leftMap, nums, n);\\n\\t\\tcreateSumMappings(n, rightMap, nums, n);\\n        leftMap.put(0,Arrays.asList(0));\\n        rightMap.put(0,Arrays.asList(0));\\n\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tfor(int i = 0; i <= n; i++){\\n            List<Integer> left = leftMap.get(i);\\n            List<Integer> right = rightMap.get(n - i);\\n            Collections.sort(left);\\n            Collections.sort(right);\\n            \\n            int p1 = 0, p2 = right.size() - 1;\\n            while(p1 < left.size() && p2 >= 0){\\n                int sum = left.get(p1) + right.get(p2);\\n                int remaining = total - sum;\\n                int diff =  Math.abs(remaining - sum);\\n                min = Math.min(min,diff);\\n                if(sum > total / 2) p2--;\\n                else p1++;\\n                \\n            }\\n        }\\n\\t\\treturn min;\\n\\t}\\n\\tpublic void createSumMappings(int offSet, HashMap < Integer, List < Integer >> map, int[] nums, int n) {\\n\\t\\tfor (int i = 1; i <= Math.pow(2, n) - 1; i++) {\\n\\t\\t\\tString binary = Integer.toBinaryString(i);\\n\\t\\t\\tint sum = 0,\\n\\t\\t\\tsetBits = 0;\\n\\t\\t\\tfor (int j = binary.length() - 1, index = nums.length - 1; j >= 0; j--, index--) {\\n\\t\\t\\t\\tif (binary.charAt(j) == \\'1\\') {\\n\\t\\t\\t\\t\\tsetBits++;\\n\\t\\t\\t\\t\\tsum += nums[index - offSet];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!map.containsKey(setBits)) map.put(setBits, new ArrayList());\\n\\t\\t\\tmap.get(setBits).add(sum);\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n\\tpublic int minimumDifference(int[] nums) {\\n\\t\\tint n = nums.length / 2;\\n\\t\\tint total = Arrays.stream(nums).sum();\\n\\t\\tHashMap<Integer,List<Integer>> leftMap = new HashMap();\\n\\t\\tHashMap<Integer,List<Integer>> rightMap = new HashMap();\\n\\n\\t\\tcreateSumMappings(0, leftMap, nums, n);\\n\\t\\tcreateSumMappings(n, rightMap, nums, n);\\n        leftMap.put(0,Arrays.asList(0));\\n        rightMap.put(0,Arrays.asList(0));\\n\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tfor(int i = 0; i <= n; i++){\\n            List<Integer> left = leftMap.get(i);\\n            List<Integer> right = rightMap.get(n - i);\\n            Collections.sort(left);\\n            Collections.sort(right);\\n            \\n            int p1 = 0, p2 = right.size() - 1;\\n            while(p1 < left.size() && p2 >= 0){\\n                int sum = left.get(p1) + right.get(p2);\\n                int remaining = total - sum;\\n                int diff =  Math.abs(remaining - sum);\\n                min = Math.min(min,diff);\\n                if(sum > total / 2) p2--;\\n                else p1++;\\n                \\n            }\\n        }\\n\\t\\treturn min;\\n\\t}\\n\\tpublic void createSumMappings(int offSet, HashMap < Integer, List < Integer >> map, int[] nums, int n) {\\n\\t\\tfor (int i = 1; i <= Math.pow(2, n) - 1; i++) {\\n\\t\\t\\tString binary = Integer.toBinaryString(i);\\n\\t\\t\\tint sum = 0,\\n\\t\\t\\tsetBits = 0;\\n\\t\\t\\tfor (int j = binary.length() - 1, index = nums.length - 1; j >= 0; j--, index--) {\\n\\t\\t\\t\\tif (binary.charAt(j) == \\'1\\') {\\n\\t\\t\\t\\t\\tsetBits++;\\n\\t\\t\\t\\t\\tsum += nums[index - offSet];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!map.containsKey(setBits)) map.put(setBits, new ArrayList());\\n\\t\\t\\tmap.get(setBits).add(sum);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513541,
                "title": "java-meet-in-the-middle-and-two-pointers-time-o-n-2-n-2-space-o-2-n-2",
                "content": "It\\'s obviously NP-hard problem.\\nWe divide our number array on two parts. Generate for both parts all possible splits and compute their sums difference.\\nThen for two lists of generated splits we try find two elements in them such that their absolute difference minimized.\\n\\n```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        if (n == 2) return Math.abs(nums[1] - nums[0]);       \\n        int[][] lists1 = generate(Arrays.copyOfRange(nums, 0, n / 2));\\n        int[][] lists2 = generate(Arrays.copyOfRange(nums, n / 2, n));\\n        int ans = Integer.MAX_VALUE;\\n        for (int d = 0; d <= n / 2; d++) {\\n            int[] arr1 = lists1[d], arr2 = lists2[d];\\n            int k = arr1.length;\\n            int i1 = 0, i2 = 0; // we use two pointers to find two elements in arr1, arr2 with minimum absolute difference\\n            while (i1 < k && i2 < k) {\\n                int diff = arr1[i1] - arr2[i2];\\n                ans = Math.min(ans, Math.abs(diff));\\n                if (diff <= 0) i1++;\\n                if (diff >= 0) i2++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private static int[][] generate(int[] nums) {\\n        int n = nums.length;\\n        int total = 0;\\n        for (int num : nums) total += num;\\n        int[][] ans = new int[n + 1][];\\n        int[] pos = new int[n + 1];\\n        for (int i = 0, binomial = 1; i <= n; i++) {\\n            ans[i] = new int[binomial]; // number of ways to choose i from n = binomial(i,n)\\n            binomial = binomial * (n - i) / (i + 1);\\n        }\\n        int maxValue = 1 << n;\\n        for (int key = 0; key < maxValue; key++) {\\n            int sum1 = 0;\\n            for (int i = 0; i < n; i++) {\\n                if ((key >> i & 1) == 1) sum1 += nums[i];\\n            }\\n            int sum2 = total - sum1;\\n            int bits = Integer.bitCount(key);\\n            ans[bits][pos[bits]++] = sum1 - sum2;\\n        }\\n        for (int[] arr : ans) Arrays.sort(arr);\\n        return ans;\\n    }\\n}\\n```\\n\\nSpace complexity - O(2^(n/2)) because number of ways to split n/2 elements is 2^(n/2)\\nTime complexity - O(2^(n/2) * n) as we compute each split\\'s sum and sort them.",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        if (n == 2) return Math.abs(nums[1] - nums[0]);       \\n        int[][] lists1 = generate(Arrays.copyOfRange(nums, 0, n / 2));\\n        int[][] lists2 = generate(Arrays.copyOfRange(nums, n / 2, n));\\n        int ans = Integer.MAX_VALUE;\\n        for (int d = 0; d <= n / 2; d++) {\\n            int[] arr1 = lists1[d], arr2 = lists2[d];\\n            int k = arr1.length;\\n            int i1 = 0, i2 = 0; // we use two pointers to find two elements in arr1, arr2 with minimum absolute difference\\n            while (i1 < k && i2 < k) {\\n                int diff = arr1[i1] - arr2[i2];\\n                ans = Math.min(ans, Math.abs(diff));\\n                if (diff <= 0) i1++;\\n                if (diff >= 0) i2++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private static int[][] generate(int[] nums) {\\n        int n = nums.length;\\n        int total = 0;\\n        for (int num : nums) total += num;\\n        int[][] ans = new int[n + 1][];\\n        int[] pos = new int[n + 1];\\n        for (int i = 0, binomial = 1; i <= n; i++) {\\n            ans[i] = new int[binomial]; // number of ways to choose i from n = binomial(i,n)\\n            binomial = binomial * (n - i) / (i + 1);\\n        }\\n        int maxValue = 1 << n;\\n        for (int key = 0; key < maxValue; key++) {\\n            int sum1 = 0;\\n            for (int i = 0; i < n; i++) {\\n                if ((key >> i & 1) == 1) sum1 += nums[i];\\n            }\\n            int sum2 = total - sum1;\\n            int bits = Integer.bitCount(key);\\n            ans[bits][pos[bits]++] = sum1 - sum2;\\n        }\\n        for (int[] arr : ans) Arrays.sort(arr);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487145,
                "title": "most-intutive-approach-meet-in-middle",
                "content": "# Intuition\\n\\n![1image.jpg](https://assets.leetcode.com/users/images/907ce371-c512-44f9-ba05-21fd41a8e56e_1683259325.9089768.jpeg)\\n\\n![2image.jpg](https://assets.leetcode.com/users/images/11347e1d-44db-4cea-a3b8-9c226403ffa3_1683259387.9765384.jpeg)\\n\\n![3image.jpg](https://assets.leetcode.com/users/images/7966be58-c56f-45db-a53e-77e2574125db_1683259407.8872268.jpeg)\\n\\nError sum of subarray of size 3 will be 6,9 only\\n\\n# Code\\n\\n\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n\\n        int n=nums.size();\\n        int N=n/2;\\n        vector<vector<int>> left(N+1), right(N+1);\\n        int sum=accumulate(nums.begin(),nums.end(),0);\\n\\n        \\n\\n        for(int mask=0;mask<(1<<N);mask++)  for finding the subarrays\\n        {\\n            int size=0;\\n            int sum1=0,sum2=0;\\n            for(int j=0;j<N;j++)\\n            {\\n              if(mask & (1<<j))\\n              {\\n                  size++; // how many no of elements\\n                  sum1+=nums[j];\\n                  sum2+=nums[j+N];\\n              }\\n            }\\n            left[size].push_back(sum1);\\n            right[size].push_back(sum2);\\n        }\\n\\n        for(int i=0;i<N;i++)\\n        {\\n         sort(right[i].begin(),right[i].end());\\n        }\\n\\n        int ans=abs(sum-2*left[N][0]);  \\n\\n        for(int i=1;i<N;i++)\\n        {\\n           for(auto it:left[i])\\n           {\\n              int b=(sum-2*it)/2;\\n              int right_indx=N-i;\\n              auto itr=lower_bound(right[right_indx].begin(),right[right_indx].end(),b);\\n              if(itr!=right[right_indx].end())\\n              {\\n                ans=min(ans,abs(sum-2*(it+ *itr)));\\n              }\\n           }\\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n\\n\\nPLEASE UPVOTE IF IT HELPS YOU.\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n\\n        int n=nums.size();\\n        int N=n/2;\\n        vector<vector<int>> left(N+1), right(N+1);\\n        int sum=accumulate(nums.begin(),nums.end(),0);\\n\\n        \\n\\n        for(int mask=0;mask<(1<<N);mask++)  for finding the subarrays\\n        {\\n            int size=0;\\n            int sum1=0,sum2=0;\\n            for(int j=0;j<N;j++)\\n            {\\n              if(mask & (1<<j))\\n              {\\n                  size++; // how many no of elements\\n                  sum1+=nums[j];\\n                  sum2+=nums[j+N];\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 2376648,
                "title": "bitmasking-two-pointers-java-solution-explained",
                "content": "\\n```\\n/***\\n\\tWe need to select n numbers in each partition ( where n = nums.length/2).\\n Lets divide the nums array into two equal halves each having n elements.\\n Now lets say we want to select a total of t elements for the first partition . \\nThen we can select x elements from the first half of nums and (t-x) elements from the second half of nums.\\n\\nUsing bitmask, we can interate over all the possible subset \\nof the first/second half of nums and create an mapping of [setBits, List<Integer>] \\nwhere setBits is the number of elements we pick from the first/second half and\\n List store the sum of all those integers that we pick. For example if say n is 4 and\\n we pick up 1011 it means we are picking 3 elements ( the no of set bits) and \\nwe are picking 0th,1st and 3rd element. \\nso we can add (nums[0]+nums[1]+nums[3]) in the list where key is 3.\\n\\nOnce we are done creating this map for both halves of the array,\\n we can iterate over the no of setBits in the first half of the nums \\narray and whatever is left can be pick up from the second half.\\n Since we are taking sum of one partition, we can simply add those two \\nvalues to find what the sum of first partition will look like. \\nOnce we know the first partition sum, other half sum will simply be total- firstPartitionSum\\n\\nSince we are trying to minimise the abolute difference, \\nthis will happen when we try to make the sum close to total/2. \\nSo we can sort the list individually for both halves and do a two pointer\\n approach where if sum > total/2, we try decrementing \\nthe sum and if its smaller we try incrementing the sum.\\n\\n***/\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int total = Arrays.stream(nums).sum();\\n        int n = nums.length/2;\\n        \\n        Map<Integer, List<Integer>> mp1 = new HashMap();\\n        Map<Integer, List<Integer>> mp2 = new HashMap();\\n        \\n        for(int i=0;i<(1<<n);i++){\\n            int setBits = 0, sum=0;\\n            for(int j=0;j<n;j++){\\n                if((i & (1<<j))!=0){\\n                    setBits++;\\n                    sum+= nums[j];\\n                }\\n            }\\n            if(!mp1.containsKey(setBits)){\\n                mp1.put(setBits,new ArrayList());\\n            }\\n            mp1.get(setBits).add(sum);\\n            \\n        }\\n        \\n        for(int i=0;i<(1<<n);i++){\\n            int setBits = 0, sum=0;\\n            for(int j=0;j<n;j++){\\n                 if((i & (1<<j))!=0){\\n                    setBits++;\\n                    sum+= nums[n+j];\\n                }\\n            }\\n            if(!mp2.containsKey(setBits)){\\n                mp2.put(setBits,new ArrayList());\\n            }\\n            mp2.get(setBits).add(sum);\\n            \\n        }\\n        \\n        for(int i=0;i<=n;i++){\\n            if(mp1.containsKey(i)){\\n                Collections.sort(mp1.get(i));\\n            }\\n            \\n            if(mp2.containsKey(i)){\\n                Collections.sort(mp2.get(i));\\n            }\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<=n;i++){\\n            int a = 0, b=mp2.get(n-i).size()-1;\\n            while(a < mp1.get(i).size() && b>=0){\\n                int sum = mp1.get(i).get(a) + mp2.get(n-i).get(b);\\n                int diff = Math.abs(total - 2*sum);\\n                ans = Math.min(ans,diff);\\n                if(2*sum > total )b--;\\n                else a++;\\n            }\\n\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n}```",
                "solutionTags": [
                    "Two Pointers",
                    "Bitmask"
                ],
                "code": "```\\n/***\\n\\tWe need to select n numbers in each partition ( where n = nums.length/2).\\n Lets divide the nums array into two equal halves each having n elements.\\n Now lets say we want to select a total of t elements for the first partition . \\nThen we can select x elements from the first half of nums and (t-x) elements from the second half of nums.\\n\\nUsing bitmask, we can interate over all the possible subset \\nof the first/second half of nums and create an mapping of [setBits, List<Integer>] \\nwhere setBits is the number of elements we pick from the first/second half and\\n List store the sum of all those integers that we pick. For example if say n is 4 and\\n we pick up 1011 it means we are picking 3 elements ( the no of set bits) and \\nwe are picking 0th,1st and 3rd element. \\nso we can add (nums[0]+nums[1]+nums[3]) in the list where key is 3.\\n\\nOnce we are done creating this map for both halves of the array,\\n we can iterate over the no of setBits in the first half of the nums \\narray and whatever is left can be pick up from the second half.\\n Since we are taking sum of one partition, we can simply add those two \\nvalues to find what the sum of first partition will look like. \\nOnce we know the first partition sum, other half sum will simply be total- firstPartitionSum\\n\\nSince we are trying to minimise the abolute difference, \\nthis will happen when we try to make the sum close to total/2. \\nSo we can sort the list individually for both halves and do a two pointer\\n approach where if sum > total/2, we try decrementing \\nthe sum and if its smaller we try incrementing the sum.\\n\\n***/\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int total = Arrays.stream(nums).sum();\\n        int n = nums.length/2;\\n        \\n        Map<Integer, List<Integer>> mp1 = new HashMap();\\n        Map<Integer, List<Integer>> mp2 = new HashMap();\\n        \\n        for(int i=0;i<(1<<n);i++){\\n            int setBits = 0, sum=0;\\n            for(int j=0;j<n;j++){\\n                if((i & (1<<j))!=0){\\n                    setBits++;\\n                    sum+= nums[j];\\n                }\\n            }\\n            if(!mp1.containsKey(setBits)){\\n                mp1.put(setBits,new ArrayList());\\n            }\\n            mp1.get(setBits).add(sum);\\n            \\n        }\\n        \\n        for(int i=0;i<(1<<n);i++){\\n            int setBits = 0, sum=0;\\n            for(int j=0;j<n;j++){\\n                 if((i & (1<<j))!=0){\\n                    setBits++;\\n                    sum+= nums[n+j];\\n                }\\n            }\\n            if(!mp2.containsKey(setBits)){\\n                mp2.put(setBits,new ArrayList());\\n            }\\n            mp2.get(setBits).add(sum);\\n            \\n        }\\n        \\n        for(int i=0;i<=n;i++){\\n            if(mp1.containsKey(i)){\\n                Collections.sort(mp1.get(i));\\n            }\\n            \\n            if(mp2.containsKey(i)){\\n                Collections.sort(mp2.get(i));\\n            }\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<=n;i++){\\n            int a = 0, b=mp2.get(n-i).size()-1;\\n            while(a < mp1.get(i).size() && b>=0){\\n                int sum = mp1.get(i).get(a) + mp2.get(n-i).get(b);\\n                int diff = Math.abs(total - 2*sum);\\n                ans = Math.min(ans,diff);\\n                if(2*sum > total )b--;\\n                else a++;\\n            }\\n\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1772580,
                "title": "recursive-approach-need-to-memoizise-it-can-anyone-convert-it-tabulation-form",
                "content": "```\\n//recursive approach\\nclass Solution {\\n       public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        int totalsum = 0;\\n        for (int i : nums)\\n            totalsum += i;\\n        return f(nums, n - 1, n / 2, totalsum, 0);\\n\\n    }\\n\\n    public int f(int[] a, int ind, int k, int totalsum, int sum) {\\n        if (ind == 0)\\n            if (k == 0)\\n                return Math.abs(2 * sum - totalsum);\\n            else\\n                return (int) Math.pow(10, 9);\\n        if (k == 0)\\n            return Math.abs(2 * sum - totalsum);\\n        // if (k < 0)\\n        //     return (int) Math.pow(10, 9);\\n\\n        int notpick = f(a, ind - 1, k, totalsum, sum);\\n        int pick = f(a, ind - 1, k - 1, totalsum, sum + a[ind]);\\n\\n        return Math.min(notpick, pick);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n//recursive approach\\nclass Solution {\\n       public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        int totalsum = 0;\\n        for (int i : nums)\\n            totalsum += i;\\n        return f(nums, n - 1, n / 2, totalsum, 0);\\n\\n    }\\n\\n    public int f(int[] a, int ind, int k, int totalsum, int sum) {\\n        if (ind == 0)\\n            if (k == 0)\\n                return Math.abs(2 * sum - totalsum);\\n            else\\n                return (int) Math.pow(10, 9);\\n        if (k == 0)\\n            return Math.abs(2 * sum - totalsum);\\n        // if (k < 0)\\n        //     return (int) Math.pow(10, 9);\\n\\n        int notpick = f(a, ind - 1, k, totalsum, sum);\\n        int pick = f(a, ind - 1, k - 1, totalsum, sum + a[ind]);\\n\\n        return Math.min(notpick, pick);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121935,
                "title": "c-meet-in-middle-but-no-tle-faster-than-50",
                "content": "* Let me tell you a point first:\\nWhenever you see a small constraint on N, you may always try to approach your problem with this **Meet in The Middle** Technque (I\\'m not telling this will always work but you may find it working in many cases.)\\n\\n* Let us now discuss this trick!\\nIn this trick, we often divide our array into two parts and then combine the solution in such a way that our main problem is solved. Like, in this question, we may divide our array into two parts, and then think of selecting a total of n elements from these two smaller arrays. \\n**But why do we do this? Is it helpful?**\\nOfcourse yeah, because when you divide the array you only need to work with only n/2 elements and creating all possible subsets will surely be working within the time limit.\\ni.e. the complexity becomes **O(2^(n/2+1))**.\\n\\n* Let\\'s see our **code** and understand (**through comments**) what we have done:\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n        int target = sum/2;  //our target sum should be close to half of original because\\n\\t\\t                    //this is the best possible case when ans = 0.\\n        vector<vector<int>>left = get_subset_sum(nums,0,n/2-1); //this returns all possible sums if select i elements from left part\\n        vector<vector<int>>right = get_subset_sum(nums,n/2,n-1);\\n        int ans=INT_MAX;\\n        for(int i=0;i<=n/2;i++){\\n            sort(right[n/2-i].begin(),right[n/2-i].end());\\n            for(int j=0;j<left[i].size();j++){\\n               int curr_left = left[i][j];\\n               auto it = lower_bound(right[n/2-i].begin(),right[n/2-i].end(),target-curr_left);//we do binary search in the right part such that we choose n/2-i elements (i.e. total n/2) which is closest to target i.e. sum/2.\\n                if(it!=right[n/2-i].end())\\n               ans=min(ans,abs(sum-2*(curr_left + *it)));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<vector<int>> get_subset_sum(vector<int>nums,int l,int r){\\n       \\n\\n        int len=r-l+1;\\n        vector<vector<int>>res(len+1,vector<int>());\\n        for(int i=0;i<(1<<len);i++){\\n              int sum=0,cnt=0;\\n            for(int j=0;j<len;j++){\\n                if(i & (1<<j)){\\n                    sum+=nums[l+j];\\n                    cnt++;\\n                }\\n            }\\n            res[cnt].push_back(sum);\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n**Hope you liked it, this will not give a TLE!**\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n        int target = sum/2;  //our target sum should be close to half of original because\\n\\t\\t                    //this is the best possible case when ans = 0.\\n        vector<vector<int>>left = get_subset_sum(nums,0,n/2-1); //this returns all possible sums if select i elements from left part\\n        vector<vector<int>>right = get_subset_sum(nums,n/2,n-1);\\n        int ans=INT_MAX;\\n        for(int i=0;i<=n/2;i++){\\n            sort(right[n/2-i].begin(),right[n/2-i].end());\\n            for(int j=0;j<left[i].size();j++){\\n               int curr_left = left[i][j];\\n               auto it = lower_bound(right[n/2-i].begin(),right[n/2-i].end(),target-curr_left);//we do binary search in the right part such that we choose n/2-i elements (i.e. total n/2) which is closest to target i.e. sum/2.\\n                if(it!=right[n/2-i].end())\\n               ans=min(ans,abs(sum-2*(curr_left + *it)));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    vector<vector<int>> get_subset_sum(vector<int>nums,int l,int r){\\n       \\n\\n        int len=r-l+1;\\n        vector<vector<int>>res(len+1,vector<int>());\\n        for(int i=0;i<(1<<len);i++){\\n              int sum=0,cnt=0;\\n            for(int j=0;j<len;j++){\\n                if(i & (1<<j)){\\n                    sum+=nums[l+j];\\n                    cnt++;\\n                }\\n            }\\n            res[cnt].push_back(sum);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513432,
                "title": "java-bitmask-treeset",
                "content": "```java\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        int sum = 0;\\n        for (int i : nums) {\\n            sum += i;\\n        }\\n        \\n        TreeSet<Integer>[] sets = new TreeSet[n/2+1];\\n        for (int i = 0; i < (1 << (n / 2)); ++i) {\\n            int curSum = 0;\\n            int m = 0;\\n            for (int j = 0; j < n / 2; ++j) {\\n                if ((i & (1<<j)) != 0) {\\n                    curSum += nums[j];\\n                    m ++;\\n                }\\n            }\\n            if (sets[m] == null)\\n                sets[m] = new TreeSet<Integer>();\\n            sets[m].add(curSum);\\n        }\\n        \\n        int res = Integer.MAX_VALUE / 3;\\n        for (int i = 0; i < (1 << (n / 2)); ++i) {\\n            int curSum = 0;\\n            int m = 0;\\n            for (int j = 0; j < n / 2; ++j) {\\n                if ((i & (1<<j)) != 0) {\\n                    curSum += nums[n/2 + j];\\n                    m ++;\\n                }\\n            }\\n            int target = (sum - 2 * curSum) / 2;\\n            \\n            Integer left = sets[n/2-m].floor(target), right = sets[n/2-m].ceiling(target);\\n            if (left != null) {\\n                res = Math.min(res, Math.abs(sum - 2 * (curSum + left.intValue())));\\n            }\\n            \\n            if (right != null) {\\n                res = Math.min(res, Math.abs(sum - 2 * (curSum + right.intValue())));\\n            }\\n            \\n            if (res == 0)\\n                return 0;\\n                               \\n        }\\n        \\n        return res;\\n    }\\n}\\n// Time Complexity: O(2^(n/2) * n/2 * n/2)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        int sum = 0;\\n        for (int i : nums) {\\n            sum += i;\\n        }\\n        \\n        TreeSet<Integer>[] sets = new TreeSet[n/2+1];\\n        for (int i = 0; i < (1 << (n / 2)); ++i) {\\n            int curSum = 0;\\n            int m = 0;\\n            for (int j = 0; j < n / 2; ++j) {\\n                if ((i & (1<<j)) != 0) {\\n                    curSum += nums[j];\\n                    m ++;\\n                }\\n            }\\n            if (sets[m] == null)\\n                sets[m] = new TreeSet<Integer>();\\n            sets[m].add(curSum);\\n        }\\n        \\n        int res = Integer.MAX_VALUE / 3;\\n        for (int i = 0; i < (1 << (n / 2)); ++i) {\\n            int curSum = 0;\\n            int m = 0;\\n            for (int j = 0; j < n / 2; ++j) {\\n                if ((i & (1<<j)) != 0) {\\n                    curSum += nums[n/2 + j];\\n                    m ++;\\n                }\\n            }\\n            int target = (sum - 2 * curSum) / 2;\\n            \\n            Integer left = sets[n/2-m].floor(target), right = sets[n/2-m].ceiling(target);\\n            if (left != null) {\\n                res = Math.min(res, Math.abs(sum - 2 * (curSum + left.intValue())));\\n            }\\n            \\n            if (right != null) {\\n                res = Math.min(res, Math.abs(sum - 2 * (curSum + right.intValue())));\\n            }\\n            \\n            if (res == 0)\\n                return 0;\\n                               \\n        }\\n        \\n        return res;\\n    }\\n}\\n// Time Complexity: O(2^(n/2) * n/2 * n/2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786039,
                "title": "dp-handling-cases-when-sum-is-negative-c",
                "content": "What you can do for -ve numbers is find the minimum number in array then add its absolute (if it is negative) to whole array it will make all elements positive but our absolute difference will not change.\\n\\n**NOTE: This approach will still not work as it doesn\\'t partition array in two equal halves but the question demands the 2*n array to be splitted in 2 arrays of equal length n. \\nIn short : This question cannot be solved by DP.**\\n\\nIf You know how to handle this issue please let me know\\n\\nBelow is the code for handling -ve sum cases \\n```\\nclass Solution {\\npublic:\\n     bool isSubsetSum(vector<int>&arr, int sum, vector<int>&v){\\n        // code here \\n   int  n=arr.size();\\n        int dp[n+1][sum+1];\\n        // initialization\\n        for(int i=0;i<=n;i++)\\n        {\\n            dp[i][0]=1;\\n            for(int j=1;j<=sum;j++)\\n            {\\n                dp[0][j]=0;\\n            }\\n        }\\n        // table filling\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=sum;j++)\\n            {\\n                if(arr[i-1]<=j)\\n                {\\n                    dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n                }\\n                else\\n                dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n         for(int i=0;i<sum/2+1;i++)\\n         {\\n             if(dp[n][i]==1)\\n             v.push_back(i);\\n         }\\n        return dp[n][sum];\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int>v;\\n        \\n             int n=nums.size(),mi=INT_MAX,sum=0;\\n         for(int i=0;i<nums.size();i++)\\n            sum+=nums[i];\\n        if(sum<=0)\\n        {\\n         for(int i=0;i<n;i++)\\n             mi=min(mi,nums[i]);\\n          \\n         for(int i=0;i<n;i++)\\n             nums[i]+=abs(mi);\\n        }\\n        int sum2=0;\\n        for(int i=0;i<nums.size();i++)\\n            sum2+=nums[i];\\n        bool ans=isSubsetSum(nums,sum2,v);\\n        int mini=INT_MAX;\\n        for(int i=0;i<v.size();i++)\\n         {\\n            if(sum2-2*v[i]<mini)\\n             mini=sum2-2*v[i];\\n         }\\n        return mini;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool isSubsetSum(vector<int>&arr, int sum, vector<int>&v){\\n        // code here \\n   int  n=arr.size();\\n        int dp[n+1][sum+1];\\n        // initialization\\n        for(int i=0;i<=n;i++)\\n        {\\n            dp[i][0]=1;\\n            for(int j=1;j<=sum;j++)\\n            {\\n                dp[0][j]=0;\\n            }\\n        }\\n        // table filling\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=sum;j++)\\n            {\\n                if(arr[i-1]<=j)\\n                {\\n                    dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n                }\\n                else\\n                dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n         for(int i=0;i<sum/2+1;i++)\\n         {\\n             if(dp[n][i]==1)\\n             v.push_back(i);\\n         }\\n        return dp[n][sum];\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int>v;\\n        \\n             int n=nums.size(),mi=INT_MAX,sum=0;\\n         for(int i=0;i<nums.size();i++)\\n            sum+=nums[i];\\n        if(sum<=0)\\n        {\\n         for(int i=0;i<n;i++)\\n             mi=min(mi,nums[i]);\\n          \\n         for(int i=0;i<n;i++)\\n             nums[i]+=abs(mi);\\n        }\\n        int sum2=0;\\n        for(int i=0;i<nums.size();i++)\\n            sum2+=nums[i];\\n        bool ans=isSubsetSum(nums,sum2,v);\\n        int mini=INT_MAX;\\n        for(int i=0;i<v.size();i++)\\n         {\\n            if(sum2-2*v[i]<mini)\\n             mini=sum2-2*v[i];\\n         }\\n        return mini;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253949,
                "title": "partition-array-into-two-arrays-to-minimize-sum-difference",
                "content": "First of all, you have given an array containing even number of elements ,\\nand i am telling you to devide array into two equal parts, what will be your answer obviously there can be many solution of this one question ,that is \\nyou can partition this array into two equal parts in many different ways,\\nand for each partition there will be a absolute difference value of the sum of two parts , and the asking you to return minm possible absolute difference . \\nFirst what your mind will tell you to do to solve this problem ,obviously try to find all possible absolute difference and return the minm among them. Now the question is how you will perform this task so whenever there is case you want to perform all possible ways you should think of recurssion , and when there is recurssion there can be overlapping subproblem , so you should check is there ovelapping subproblem in your recurssive solution if it is , you can  improve the time complexity of your solution by doing memoization  , you also can improve space complexity of your solution by doing botom up solution of your meemoized version.\\n\\nnow in this case what will be the recurssive solution i think you can think it i am pasting the code here below\\n\\n\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n            sum+=nums[i];\\n        return f(nums.size()-1,1e9,1e9,nums,n/2,n/2);\\n    }\\n    int f(int n,int sum1,int sum2,vector<int> &nums,int n1,int n2){\\n        if(n<0&&n1==0&&n2==0) \\n            return abs(sum1-sum2);\\n        if(n<0)\\n            return 1e9;\\n        int x1=1e9,x2=1e9;\\n        if(sum1==1e9)\\n            x1=f(n-1,nums[n],sum2,nums,n1-1,n2);\\n            else \\n        x1=f(n-1,sum1+nums[n],sum2,nums,n1-1,n2);\\n        if(sum2==1e9)\\n            x2=f(n-1,sum1,nums[n],nums,n1,n2-1);\\n        else\\n        x2=f(n-1,sum1,sum2+nums[n],nums,n1,n2-1);\\n        return minm(x1,x2);\\n    }\\n    int abs(int x){\\n        if(x<0) return -x;\\n        return x;\\n    }\\n    int minm(int x1,int x2){\\n        if(x1<x2) return x1;\\n        return x2;\\n    }\\n};\\n\\nit will pass 134 test case of the question and it will give TLE.\\n\\nnow think can you memoize this recurssive solution , if not modify it in such a way that you can memoize it ,\\n   problem in this recurssion regarding memoization \\n      ------->>>>>  five thing are changing in this function at each stage\\n\\t  we will not go to make 5D matrix okay ,if possible then also\\n\\t  //////////////\\nideas when you think of improving the recurrsion will come in your mind  \\n\\t\\t(i) \\n   \\n\\nhere is the  improved recurssive  solution with  3 variable changing at each stage.\\n\\n\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        int totalsum=0;\\n        for(int i=0;i<nums.size();i++)\\n            totalsum+=nums[i];\\n        return f(nums.size()-1,0,nums,n/2,totalsum);\\n    }\\n    int f(int n,int sum1,vector<int> &nums,int n1,int totalsum){\\n       if(n1==0){\\n           return abs(totalsum-sum1-sum1);\\n       }\\n       else if(n<0)\\n            return 1e9;\\n        \\n        int take=f(n-1,sum1+nums[n],nums,n1-1,totalsum);\\n        int nottake=f(n-1,sum1,nums,n1,totalsum);\\n        \\n       return minm(take,nottake);\\n       \\n    }\\n    int abs(int x){\\n        if(x<0) return -x;\\n        return x;\\n    }\\n    int minm(int x1,int x2){\\n        if(x1<x2) return x1;\\n        return x2;\\n    }\\n};\\n\\nso what you are think of to do memoization using vector, as you know sum can voverflow in int so i wiil prefer to use hash map lets try it will work or not but there is one problem hash map that when you check particular element is present in hashmap or not then it takes time graeter as compared to vector and in some problem memoization using hash map give TLE.\\nif give TLE try to optimize recurssive solution more so that memoization using vector class posiible.\\nhere is the memoization using hash function but it is also giving TLE with 112 test case pass------>>>>>>>>\\n\\n\\nclass Solution {\\n    \\n    map<pair<int,pair<int,int>>,int> dp;\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        int totalsum=0;\\n        for(int i=0;i<nums.size();i++)\\n            totalsum+=nums[i];\\n        return f(nums.size()-1,0,nums,n/2,totalsum);\\n    }\\n    int f(int n,int sum1,vector<int> &nums,int n1,int totalsum){\\n        if(dp.count({n,{sum1,n1}}))\\n            return dp[{n,{sum1,n1}}];\\n       if(n1==0){\\n           return dp[{n,{sum1,n1}}]=abs(totalsum-sum1-sum1);\\n       }\\n       else if(n<0)\\n            return dp[{n,{sum1,n1}}]=1e9;\\n        \\n        int take=f(n-1,sum1+nums[n],nums,n1-1,totalsum);\\n        int nottake=f(n-1,sum1,nums,n1,totalsum);\\n        \\n       return dp[{n,{sum1,n1}}]=minm(take,nottake);\\n       \\n    }\\n    int abs(int x){\\n        if(x<0) return -x;\\n        return x;\\n    }\\n    int minm(int x1,int x2){\\n        if(x1<x2) return x1;\\n        return x2;\\n    }\\n};\\n\\n///////////////////////////////\\nnow what will be the next plan for the solution optimisation \\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n            sum+=nums[i];\\n        return f(nums.size()-1,1e9,1e9,nums,n/2,n/2);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1514436,
                "title": "c-variation-of-meet-in-the-middle",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int> firstHalf, secHalf;\\n        int n = nums.size() / 2;\\n        int sum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i < n)firstHalf.push_back(nums[i]);\\n            else secHalf.push_back(nums[i]);\\n            sum += nums[i];\\n        }\\n        int l = sum / 2;\\n\\n        vector<vector<int>> part1(n + 1, vector<int> ());\\n        vector<vector<int>> part2(n + 1, vector<int> ());\\n\\n        for (int i = 0; i < (1 << n); i++) {\\n            int curSum = 0;\\n            int cnt = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (i & (1 << j)) {\\n                    curSum += firstHalf[j];\\n                    cnt++;\\n                }\\n            }\\n            part1[cnt].push_back(curSum);\\n        }\\n        for (int i = 0; i < (1 << n); i++) {\\n            int curSum = 0;\\n            int cnt = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (i & (1 << j)) {\\n                    curSum += secHalf[j];\\n                    cnt++;\\n                }\\n            }\\n            part2[cnt].push_back(curSum);\\n        }\\n        for (int i = 0; i <= n; i++)sort(part2[i].begin(), part2[i].end());\\n        int ans = INT_MAX;\\n        for (int i = 0; i <= n; i++) {\\n\\n            for (int j = 0; j < part1[i].size(); j++) {\\n                int cur = part1[i][j];\\n                int o = lower_bound(part2[n - i].begin(), part2[n - i].end(), l - cur) - part2[n - i].begin();\\n                if (o == part2[n - i].size())o--;\\n\\n                ans = min(ans, abs((sum - (cur + part2[n - i][o]) ) - (cur + part2[n - i][o])));\\n\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int> firstHalf, secHalf;\\n        int n = nums.size() / 2;\\n        int sum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i < n)firstHalf.push_back(nums[i]);\\n            else secHalf.push_back(nums[i]);\\n            sum += nums[i];\\n        }\\n        int l = sum / 2;\\n\\n        vector<vector<int>> part1(n + 1, vector<int> ());\\n        vector<vector<int>> part2(n + 1, vector<int> ());\\n\\n        for (int i = 0; i < (1 << n); i++) {\\n            int curSum = 0;\\n            int cnt = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (i & (1 << j)) {\\n                    curSum += firstHalf[j];\\n                    cnt++;\\n                }\\n            }\\n            part1[cnt].push_back(curSum);\\n        }\\n        for (int i = 0; i < (1 << n); i++) {\\n            int curSum = 0;\\n            int cnt = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (i & (1 << j)) {\\n                    curSum += secHalf[j];\\n                    cnt++;\\n                }\\n            }\\n            part2[cnt].push_back(curSum);\\n        }\\n        for (int i = 0; i <= n; i++)sort(part2[i].begin(), part2[i].end());\\n        int ans = INT_MAX;\\n        for (int i = 0; i <= n; i++) {\\n\\n            for (int j = 0; j < part1[i].size(); j++) {\\n                int cur = part1[i][j];\\n                int o = lower_bound(part2[n - i].begin(), part2[n - i].end(), l - cur) - part2[n - i].begin();\\n                if (o == part2[n - i].size())o--;\\n\\n                ans = min(ans, abs((sum - (cur + part2[n - i][o]) ) - (cur + part2[n - i][o])));\\n\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530354,
                "title": "python-solution-with-analogy",
                "content": "Idea: use `meet-in-the-middle` with the aid of `combinations` and `bisect`\\n```\\n# Return the minimum possible absolute difference.\\nfrom bisect import bisect_left, bisect_right\\nfrom itertools import combinations\\n\\n\\nclass Solution:\\n    def minimumDifference(self, nums):\\n        N = len(nums) // 2\\n\\n        # fn to generate all combinational sum of k elements\\n        # for k from 1 up to N\\n        def get_sums(nums):\\n            ans = dict()\\n            for k in range(1, N + 1):\\n                sums = set()\\n                for cmb in combinations(nums, k):\\n                    sums.add(sum(cmb))\\n                ans[k] = sums\\n            return ans\\n\\n        left_part, right_part = nums[:N], nums[N:]\\n        left_sums, right_sums = get_sums(left_part), get_sums(right_part)\\n        ans = abs(sum(left_part) - sum(right_part))\\n        total = sum(nums)\\n        half = total // 2\\n        for k in range(1, N):\\n            left = left_sums[k]\\n            right = right_sums[N - k]\\n            right = sorted(right)\\n            for x in left:\\n                r = half - x\\n                # Here again, both bisect_right and bisect_left work\\n                # reason as in Q2\\n                # p = bisect_right(right, r)\\n                p = bisect_left(right, r)\\n                for q in [p, p - 1]:\\n                    if 0 <= q < len(right):\\n                        left_ans_sum = x + right[q]\\n                        right_ans_sum = total - left_ans_sum\\n                        diff = abs(left_ans_sum - right_ans_sum)\\n                        ans = min(ans, diff)\\n        return ans\\n\\n\\nprint(\"Q3 checks:\")\\nobj = Solution().minimumDifference\\nnums = [3, 9, 7, 3]\\nprint(obj(nums), obj(nums) == 2)\\nnums = [-36, 36]\\nprint(obj(nums), obj(nums) == 72)\\nnums = [2, -1, 0, 4, -2, -9]\\nprint(obj(nums), obj(nums) == 0)\\n```\\n\\nThis problem is quite similar to\\n1755. Closest Subsequence Sum\\n#https://leetcode.com/problems/closest-subsequence-sum/\\n\\nA solution following same idea is as below:\\n```\\nfrom bisect import bisect_left, bisect_right\\n\\n\\nclass Solution:\\n    def minAbsDifference(self, nums, goal):\\n        \"\"\"\\n        As the length of nums has upper bound n = 40, a brute force way of checking the\\n        possible subsequnce sums will have time complexity 2 ** n. That is too large.\\n        The idea here is to split the nums into two halves, each has length upper bound 20.\\n        So getting all possible sums xs, ys for each part has time O(2 ** (n/2)).\\n        In the algorithm, we sorted one of xs, ys, say ys, it takes O(2 **(n/2) * log(2 **(n/2)))\\n        For each x in xs, we do binary search in ys to find nearest candidates (may need check twice, i.e,\\n        left, right of the binary insertion index), the time is again O(2 **(n/2) * log(2 **(n/2)))\\n        So overall time complexity is O(2 **(n/2) * log(2 *2(n/2))), i.e., O(n * 2 **(n/2)).\\n        \\n        \"\"\"\\n\\n        def helper(nums):\\n            aux = {0}\\n            for x in nums:\\n                for y in aux.copy():\\n                    aux.add(x + y)\\n            return aux\\n\\n        n = len(nums) // 2\\n        xs, ys = helper(nums[:n]), helper(nums[n:])\\n        ys = sorted(ys)\\n        res = float(\"inf\")\\n        for x in xs:\\n            target = goal - x\\n            i = bisect_left(ys, target)\\n            if i < len(ys):\\n                res = min(res, abs(target - ys[i]))\\n            if i > 0:\\n                res = min(res, abs(target - ys[i - 1]))\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Return the minimum possible absolute difference.\\nfrom bisect import bisect_left, bisect_right\\nfrom itertools import combinations\\n\\n\\nclass Solution:\\n    def minimumDifference(self, nums):\\n        N = len(nums) // 2\\n\\n        # fn to generate all combinational sum of k elements\\n        # for k from 1 up to N\\n        def get_sums(nums):\\n            ans = dict()\\n            for k in range(1, N + 1):\\n                sums = set()\\n                for cmb in combinations(nums, k):\\n                    sums.add(sum(cmb))\\n                ans[k] = sums\\n            return ans\\n\\n        left_part, right_part = nums[:N], nums[N:]\\n        left_sums, right_sums = get_sums(left_part), get_sums(right_part)\\n        ans = abs(sum(left_part) - sum(right_part))\\n        total = sum(nums)\\n        half = total // 2\\n        for k in range(1, N):\\n            left = left_sums[k]\\n            right = right_sums[N - k]\\n            right = sorted(right)\\n            for x in left:\\n                r = half - x\\n                # Here again, both bisect_right and bisect_left work\\n                # reason as in Q2\\n                # p = bisect_right(right, r)\\n                p = bisect_left(right, r)\\n                for q in [p, p - 1]:\\n                    if 0 <= q < len(right):\\n                        left_ans_sum = x + right[q]\\n                        right_ans_sum = total - left_ans_sum\\n                        diff = abs(left_ans_sum - right_ans_sum)\\n                        ans = min(ans, diff)\\n        return ans\\n\\n\\nprint(\"Q3 checks:\")\\nobj = Solution().minimumDifference\\nnums = [3, 9, 7, 3]\\nprint(obj(nums), obj(nums) == 2)\\nnums = [-36, 36]\\nprint(obj(nums), obj(nums) == 72)\\nnums = [2, -1, 0, 4, -2, -9]\\nprint(obj(nums), obj(nums) == 0)\\n```\n```\\nfrom bisect import bisect_left, bisect_right\\n\\n\\nclass Solution:\\n    def minAbsDifference(self, nums, goal):\\n        \"\"\"\\n        As the length of nums has upper bound n = 40, a brute force way of checking the\\n        possible subsequnce sums will have time complexity 2 ** n. That is too large.\\n        The idea here is to split the nums into two halves, each has length upper bound 20.\\n        So getting all possible sums xs, ys for each part has time O(2 ** (n/2)).\\n        In the algorithm, we sorted one of xs, ys, say ys, it takes O(2 **(n/2) * log(2 **(n/2)))\\n        For each x in xs, we do binary search in ys to find nearest candidates (may need check twice, i.e,\\n        left, right of the binary insertion index), the time is again O(2 **(n/2) * log(2 **(n/2)))\\n        So overall time complexity is O(2 **(n/2) * log(2 *2(n/2))), i.e., O(n * 2 **(n/2)).\\n        \\n        \"\"\"\\n\\n        def helper(nums):\\n            aux = {0}\\n            for x in nums:\\n                for y in aux.copy():\\n                    aux.add(x + y)\\n            return aux\\n\\n        n = len(nums) // 2\\n        xs, ys = helper(nums[:n]), helper(nums[n:])\\n        ys = sorted(ys)\\n        res = float(\"inf\")\\n        for x in xs:\\n            target = goal - x\\n            i = bisect_left(ys, target)\\n            if i < len(ys):\\n                res = min(res, abs(target - ys[i]))\\n            if i > 0:\\n                res = min(res, abs(target - ys[i - 1]))\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670157,
                "title": "c-tabulation-not-for-negative-test-case-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = 0;\\n\\t    for(int i=0;i<n;i++){\\n\\t        sum += nums[i];\\n\\t    }\\n\\t    \\n\\t   vector<vector<bool>> dp(n+1,vector<bool>(sum/2+1,false));\\n\\t   \\n\\t   for(int i=0;i<n+1;i++){\\n\\t       dp[i][0] = true;\\n\\t   }\\n\\t   \\n\\t   for(int i=1;i<n+1;i++){\\n\\t       for(int j=1;j<sum/2+1;j++){\\n\\t           if(nums[i-1] <= j){\\n\\t               dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];\\n            } else {\\n                dp[i][j] = dp[i - 1][j];\\n            }\\n        }\\n    }\\n    \\n    int mx = -1;\\n    for(int j=0;j<sum/2+1;j++){\\n        if(dp[n][j] == true){\\n            mx = j;\\n        }\\n    }\\n     return sum-2*mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = 0;\\n\\t    for(int i=0;i<n;i++){\\n\\t        sum += nums[i];\\n\\t    }\\n\\t    \\n\\t   vector<vector<bool>> dp(n+1,vector<bool>(sum/2+1,false));\\n\\t   \\n\\t   for(int i=0;i<n+1;i++){\\n\\t       dp[i][0] = true;\\n\\t   }\\n\\t   \\n\\t   for(int i=1;i<n+1;i++){\\n\\t       for(int j=1;j<sum/2+1;j++){\\n\\t           if(nums[i-1] <= j){\\n\\t               dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];\\n            } else {\\n                dp[i][j] = dp[i - 1][j];\\n            }\\n        }\\n    }\\n    \\n    int mx = -1;\\n    for(int j=0;j<sum/2+1;j++){\\n        if(dp[n][j] == true){\\n            mx = j;\\n        }\\n    }\\n     return sum-2*mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278318,
                "title": "c-bitmask-meet-in-the-middle-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();        \\n        int N = n/2;                                //Divide the whole array into two parts of size n/2\\n        \\n        vector<vector<int>> left(N+1);         // 0 -- N-1   to store sum of all subsets of left half the nums\\n        vector<vector<int>> right(N+1);        // N -- n-1   to store sum of all subsets of right half the nums\\n        \\n        for(int bitmask = 0; bitmask < (1<<N); bitmask++)//Using bitmask find all the subsets of left part of nums\\n        {\\n            int mask = bitmask;\\n            int no_of_set_bits = 0;         //Denotes which element in nums is the part of subset (size of subset)\\n            int sum = 0;                    // Ex = {1010} means {2,3,4,5} 2 & 4 are the part of subset\\n            int index = 0;                  //Denotes the index of element in nums\\n            \\n            while(mask > 0)\\n            {\\n                if(mask&1)                  //If the bit is set then include it in subset\\n                {\\n                    sum += nums[index];         //calculate sum of the elements that are the part of the subset\\n                    no_of_set_bits++;\\n                }\\n                mask = mask >> 1;\\n                index++;\\n            }\\n            left[no_of_set_bits].push_back(sum);    //Corresponding to size of susbset add the sum of that subset\\n        }\\n        \\n        for(int bitmask = 0; bitmask < (1<<N); bitmask++)   //Find all the subsets of right part of the nums\\n        {\\n            int mask = bitmask;\\n            int no_of_set_bits = 0;\\n            int sum = 0;\\n            int index = 0;\\n            \\n            while(mask > 0)\\n            {\\n                if(mask&1)\\n                {\\n                    sum += nums[index+N];       //To make sure we only include elements from the right half\\n                    no_of_set_bits++;           //we add N to the index so that it include right half elements\\n                }\\n                mask = mask >> 1;\\n                index++;\\n            }\\n            right[no_of_set_bits].push_back(sum);\\n        }\\n        \\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        int ans = INT_MAX;\\n        \\n        for(int size = 0; size <= N; size++)        //Now iterate over each sum in left part from size 0 to N\\n        {   \\n            vector<int> v2 = right[N - size];       //Consider corresponding part of right half such that\\n            sort(v2.begin(), v2.end());             // no of element in left sum + right sum == N \\n            for(auto &a:left[size])\\n            {   \\n                int b = (sum - 2*a)/2;                     //To find appropriate sum b of subset of size N-size\\n                auto itr = lower_bound(v2.begin(), v2.end(), b);  //We use binary search in right half vector\\n                \\n                if(itr != v2.end())\\n                {\\n                    b = *itr;\\n                    ans = min(ans, abs(sum - 2*(a + b)));\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();        \\n        int N = n/2;                                //Divide the whole array into two parts of size n/2\\n        \\n        vector<vector<int>> left(N+1);         // 0 -- N-1   to store sum of all subsets of left half the nums\\n        vector<vector<int>> right(N+1);        // N -- n-1   to store sum of all subsets of right half the nums\\n        \\n        for(int bitmask = 0; bitmask < (1<<N); bitmask++)//Using bitmask find all the subsets of left part of nums\\n        {\\n            int mask = bitmask;\\n            int no_of_set_bits = 0;         //Denotes which element in nums is the part of subset (size of subset)\\n            int sum = 0;                    // Ex = {1010} means {2,3,4,5} 2 & 4 are the part of subset\\n            int index = 0;                  //Denotes the index of element in nums\\n            \\n            while(mask > 0)\\n            {\\n                if(mask&1)                  //If the bit is set then include it in subset\\n                {\\n                    sum += nums[index];         //calculate sum of the elements that are the part of the subset\\n                    no_of_set_bits++;\\n                }\\n                mask = mask >> 1;\\n                index++;\\n            }\\n            left[no_of_set_bits].push_back(sum);    //Corresponding to size of susbset add the sum of that subset\\n        }\\n        \\n        for(int bitmask = 0; bitmask < (1<<N); bitmask++)   //Find all the subsets of right part of the nums\\n        {\\n            int mask = bitmask;\\n            int no_of_set_bits = 0;\\n            int sum = 0;\\n            int index = 0;\\n            \\n            while(mask > 0)\\n            {\\n                if(mask&1)\\n                {\\n                    sum += nums[index+N];       //To make sure we only include elements from the right half\\n                    no_of_set_bits++;           //we add N to the index so that it include right half elements\\n                }\\n                mask = mask >> 1;\\n                index++;\\n            }\\n            right[no_of_set_bits].push_back(sum);\\n        }\\n        \\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        int ans = INT_MAX;\\n        \\n        for(int size = 0; size <= N; size++)        //Now iterate over each sum in left part from size 0 to N\\n        {   \\n            vector<int> v2 = right[N - size];       //Consider corresponding part of right half such that\\n            sort(v2.begin(), v2.end());             // no of element in left sum + right sum == N \\n            for(auto &a:left[size])\\n            {   \\n                int b = (sum - 2*a)/2;                     //To find appropriate sum b of subset of size N-size\\n                auto itr = lower_bound(v2.begin(), v2.end(), b);  //We use binary search in right half vector\\n                \\n                if(itr != v2.end())\\n                {\\n                    b = *itr;\\n                    ans = min(ans, abs(sum - 2*(a + b)));\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594677,
                "title": "meet-in-the-middle",
                "content": "```\\nclass Solution {\\n    HashMap<Integer, TreeSet<Integer>> leftMap = new HashMap<>();\\n    HashMap<Integer, TreeSet<Integer>> rightMap = new HashMap<>();\\n\\n    public int minimumDifference(int[] nums) {\\n        int sum = Arrays.stream(nums).sum();\\n        subsets(0, Arrays.copyOfRange(nums, 0, nums.length / 2), 0, 0, leftMap);\\n        subsets(0, Arrays.copyOfRange(nums, nums.length / 2, nums.length), 0, 0, rightMap);\\n        int ans = Integer.MAX_VALUE;\\n        for (int len : leftMap.keySet()) {\\n            int rightArrayLen = nums.length / 2 - len;\\n            TreeSet<Integer> right = rightMap.get(rightArrayLen);\\n            if (right != null) {\\n                for (int leftSum : leftMap.get(len)) {\\n                    int rightSum = sum / 2 - leftSum;\\n                    Integer closest = right.floor(rightSum);\\n                    if (closest != null) {\\n                        int oneSum = (closest + leftSum);\\n                        int otherSum = sum - oneSum;\\n                        ans = Math.min(ans, Math.abs(oneSum - otherSum));\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private void subsets(int idx, int[] arr, int sum, int length, HashMap<Integer, TreeSet<Integer>> map) {\\n        if (idx >= arr.length) {\\n            TreeSet<Integer> set = map.getOrDefault(length, new TreeSet<>());\\n            set.add(sum);\\n            map.put(length, set);\\n            return;\\n        }\\n        subsets(idx + 1, arr, sum, length, map);\\n        subsets(idx + 1, arr, sum + arr[idx], length + 1, map);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer, TreeSet<Integer>> leftMap = new HashMap<>();\\n    HashMap<Integer, TreeSet<Integer>> rightMap = new HashMap<>();\\n\\n    public int minimumDifference(int[] nums) {\\n        int sum = Arrays.stream(nums).sum();\\n        subsets(0, Arrays.copyOfRange(nums, 0, nums.length / 2), 0, 0, leftMap);\\n        subsets(0, Arrays.copyOfRange(nums, nums.length / 2, nums.length), 0, 0, rightMap);\\n        int ans = Integer.MAX_VALUE;\\n        for (int len : leftMap.keySet()) {\\n            int rightArrayLen = nums.length / 2 - len;\\n            TreeSet<Integer> right = rightMap.get(rightArrayLen);\\n            if (right != null) {\\n                for (int leftSum : leftMap.get(len)) {\\n                    int rightSum = sum / 2 - leftSum;\\n                    Integer closest = right.floor(rightSum);\\n                    if (closest != null) {\\n                        int oneSum = (closest + leftSum);\\n                        int otherSum = sum - oneSum;\\n                        ans = Math.min(ans, Math.abs(oneSum - otherSum));\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private void subsets(int idx, int[] arr, int sum, int length, HashMap<Integer, TreeSet<Integer>> map) {\\n        if (idx >= arr.length) {\\n            TreeSet<Integer> set = map.getOrDefault(length, new TreeSet<>());\\n            set.add(sum);\\n            map.put(length, set);\\n            return;\\n        }\\n        subsets(idx + 1, arr, sum, length, map);\\n        subsets(idx + 1, arr, sum + arr[idx], length + 1, map);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515002,
                "title": "c-2035-partition-array-into-two-arrays-to-minimize-sum-difference",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/2; \\n        vector<int> left(nums.begin(), nums.begin()+n), right(nums.begin()+n, nums.begin()+2*n); \\n        \\n        vector<vector<int>> vals(n+1); \\n        for (int mask = 0; mask < (1<<n); ++mask) {\\n            int diff = 0, key = __builtin_popcount(mask); \\n            for (int i = 0; i < n; ++i) \\n                diff += (mask & (1 << i)) ? left[i] : -left[i]; \\n            vals[key].push_back(diff); \\n        }\\n        \\n        for (auto& v : vals) sort(v.begin(), v.end()); \\n        \\n        int ans = INT_MAX; \\n        for (int mask = 0; mask < (1<<n); ++mask) {\\n            int diff = 0, key = n - __builtin_popcount(mask); \\n            for (int i = 0; i < n; ++i) \\n                diff += (mask & (1 << i)) ? right[i] : -right[i]; \\n            auto it = lower_bound(vals[key].begin(), vals[key].end(), -diff); \\n            if (it != vals[key].begin()) ans = min(ans, abs(diff + *prev(it))); \\n            if (it != vals[key].end()) ans = min(ans, abs(diff + *it)); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/2; \\n        vector<int> left(nums.begin(), nums.begin()+n), right(nums.begin()+n, nums.begin()+2*n); \\n        \\n        vector<vector<int>> vals(n+1); \\n        for (int mask = 0; mask < (1<<n); ++mask) {\\n            int diff = 0, key = __builtin_popcount(mask); \\n            for (int i = 0; i < n; ++i) \\n                diff += (mask & (1 << i)) ? left[i] : -left[i]; \\n            vals[key].push_back(diff); \\n        }\\n        \\n        for (auto& v : vals) sort(v.begin(), v.end()); \\n        \\n        int ans = INT_MAX; \\n        for (int mask = 0; mask < (1<<n); ++mask) {\\n            int diff = 0, key = n - __builtin_popcount(mask); \\n            for (int i = 0; i < n; ++i) \\n                diff += (mask & (1 << i)) ? right[i] : -right[i]; \\n            auto it = lower_bound(vals[key].begin(), vals[key].end(), -diff); \\n            if (it != vals[key].begin()) ans = min(ans, abs(diff + *prev(it))); \\n            if (it != vals[key].end()) ans = min(ans, abs(diff + *it)); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451785,
                "title": "c-easy-solution-with-simple-explanation",
                "content": "**Objective**\\nWe have to divide this array into two sub-sequences (Say **A** and **B**) having length **N** such that the absolute difference between the sum of both sequences must be as minimal as possible\\n\\n**Solution**\\nWe can split the array of size **2N** into two parts from index **[0 to N-1]** and **[N to 2N-1]** . Now let say **K** elements from the first part are in sequence **A** then obviously **N-K** must be present in sequence **B** and from the second part **N-K** elements are in sequence **A** and **K** elements in sequence **B**.\\n\\nNow the question is how to find the sum of any **K** elements from the first part?\\nSince **(N <= 15)** we can use brute force to find the sum of all the subsets containing **K** elements. This job is being done by the **Solve** function of the following code.\\n\\nIf sum of **K** elements is **Sum1** in the first part, then for the second part we must find sum of **N-K** elements, let\\'s say it is **Sum2**. **(Sum of all elements) - (Sum1 + Sum2)** may contribute to my answer, so we should find this for all possible values of K that is [0 - N], and the minimum of all these values will be my answer.\\n\\nWhat if we subtract elements of sequence **B** simultaneously while adding elements in sequence **A**? Now we just need to minimise **abs(Sum1+Sum2)**. We can use Binary Search to find Sum2  corrosponding to Sum1 optimally.\\n\\n***Role of Binary Search (lower_bound)?***\\nConsider that the sum of *K* elements from the first part is Sum1, then we need to find such a value of Sum2 that both are as close as possible. Therefore, it can be done optimally using lowerbound.  \\n\\n\\n**CODE**\\n```\\nclass Solution {\\n    void solve(vector<int> &nums,int idx,int n,int acc,int sum,vector<vector<int>> &v)\\n    {\\n        if(idx == n)\\n        {\\n           v[acc].push_back(sum);\\n        }\\n        else\\n        {\\n            solve(nums,idx+1,n,acc,sum-nums[idx],v);\\n            solve(nums,idx+1,n,acc+1,sum+nums[idx],v);\\n        }\\n    }\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/2;\\n        vector<vector<int>> va(n+1),vb(n+1);\\n        solve(nums,0,n,0,0,va);\\n        solve(nums,n,2*n,0,0,vb);\\n        for(int i=0;i<=n;i++)\\n        {\\n            sort(va[i].begin(),va[i].end());\\n            sort(vb[i].begin(),vb[i].end());\\n        }\\n        int ans = 1e9;\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<va[i].size();j++)\\n            {\\n                int tar = -va[i][j];\\n                if(tar <= vb[n-i][0])\\n                {\\n                    ans = min(ans,abs(va[i][j] + vb[n-i][0]));\\n                }\\n                else if(tar >= vb[n-i].back())\\n                {\\n                    ans = min(ans,abs(va[i][j] + vb[n-i].back()));\\n                }\\n                else\\n                {\\n                    int idx = lower_bound(vb[n-i].begin(),vb[n-i].end(),tar) - vb[n-i].begin();\\n                    int val = min(abs(va[i][j] + vb[n-i][idx]),abs(va[i][j] + vb[n-i][idx-1]));\\n                    ans = min(ans,val);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    void solve(vector<int> &nums,int idx,int n,int acc,int sum,vector<vector<int>> &v)\\n    {\\n        if(idx == n)\\n        {\\n           v[acc].push_back(sum);\\n        }\\n        else\\n        {\\n            solve(nums,idx+1,n,acc,sum-nums[idx],v);\\n            solve(nums,idx+1,n,acc+1,sum+nums[idx],v);\\n        }\\n    }\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/2;\\n        vector<vector<int>> va(n+1),vb(n+1);\\n        solve(nums,0,n,0,0,va);\\n        solve(nums,n,2*n,0,0,vb);\\n        for(int i=0;i<=n;i++)\\n        {\\n            sort(va[i].begin(),va[i].end());\\n            sort(vb[i].begin(),vb[i].end());\\n        }\\n        int ans = 1e9;\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<va[i].size();j++)\\n            {\\n                int tar = -va[i][j];\\n                if(tar <= vb[n-i][0])\\n                {\\n                    ans = min(ans,abs(va[i][j] + vb[n-i][0]));\\n                }\\n                else if(tar >= vb[n-i].back())\\n                {\\n                    ans = min(ans,abs(va[i][j] + vb[n-i].back()));\\n                }\\n                else\\n                {\\n                    int idx = lower_bound(vb[n-i].begin(),vb[n-i].end(),tar) - vb[n-i].begin();\\n                    int val = min(abs(va[i][j] + vb[n-i][idx]),abs(va[i][j] + vb[n-i][idx-1]));\\n                    ans = min(ans,val);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299111,
                "title": "java-solution-recursion-tle",
                "content": "```\\nclass Solution {\\n  int min = Integer.MAX_VALUE;\\n  \\n  public int minimumDifference(int[] nums) {\\n    minSumDiff(nums, 0, 0, 0, 0, 0);\\n    return min;\\n  }\\n  \\n  public void minSumDiff(int[] nums, int i, \\n                         int array1, int array2, \\n                         int array1Count, int array2Count) {\\n    \\n    if(array1Count > nums.length / 2 \\n       || array2Count > nums.length / 2) {\\n      return;\\n    }\\n    \\n    if(i == nums.length) {\\n      int diff = array1 - array2;\\n      min = Math.min(min, Math.abs(diff));\\n      return;\\n    }\\n    \\n    minSumDiff(nums, i + 1, array1 + nums[i], array2, array1Count + 1, array2Count);\\n    minSumDiff(nums, i + 1, array1, array2 + nums[i], array1Count, array2Count + 1);\\n  } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  int min = Integer.MAX_VALUE;\\n  \\n  public int minimumDifference(int[] nums) {\\n    minSumDiff(nums, 0, 0, 0, 0, 0);\\n    return min;\\n  }\\n  \\n  public void minSumDiff(int[] nums, int i, \\n                         int array1, int array2, \\n                         int array1Count, int array2Count) {\\n    \\n    if(array1Count > nums.length / 2 \\n       || array2Count > nums.length / 2) {\\n      return;\\n    }\\n    \\n    if(i == nums.length) {\\n      int diff = array1 - array2;\\n      min = Math.min(min, Math.abs(diff));\\n      return;\\n    }\\n    \\n    minSumDiff(nums, i + 1, array1 + nums[i], array2, array1Count + 1, array2Count);\\n    minSumDiff(nums, i + 1, array1, array2 + nums[i], array1Count, array2Count + 1);\\n  } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843279,
                "title": "how-to-deal-with-negative-numbers-from-my-code-if-possible",
                "content": "class Solution {\\npublic:\\n    \\n    int minimumDifference(vector<int>& nums) {\\n    \\n        int n=nums.size();\\n        int target=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            target=target+nums[i];\\n        }\\n        \\n        if(n==2)\\n        {\\n            return abs(nums[0]-nums[1]);\\n        }\\n   \\n        vector<vector<bool>> dp(n,vector<bool> (abs(target)+1,0));\\n    \\n          \\n        for(int i=0;i<n;i++)\\n        {\\n        dp[i][0]=true;        \\n        }\\n        if(nums[0]<=target) // Seeing 2d size of dp array\\n        dp[0][nums[0]]=true;\\n        \\n\\n   \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<=target;j++)\\n            {\\n                \\n                bool np=dp[i-1][j];\\n               \\n                bool p=false;\\n                if(nums[i]<=j)\\n                {\\n                    p=dp[i-1][abs(j-nums[i])];\\n                }\\n                dp[i][j] = np || p;\\n                \\n                    \\n            }\\n        }\\n   \\n    \\n        int mini=10000000;\\n        for(int i=0;i<target+1;i++)\\n        {\\n            if(dp[n-1][i]==true)\\n            {\\n                \\n                mini=min(mini,abs(i-(target-i)));\\n            }\\n        }\\n    \\n    return mini;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int minimumDifference(vector<int>& nums) {\\n    \\n        int n=nums.size();\\n        int target=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            target=target+nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1514580,
                "title": "python-3-hint-solution-binary-search",
                "content": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        tot = sum(nums)\\n\\n        l, r = nums[:n//2], nums[n//2:]\\n        lsum, rsum = defaultdict(set), defaultdict(set)\\n\\n        for k in range(n // 2 + 1):\\n            lsum[k] |= set(map(sum, combinations(l, k)))\\n            rsum[k] |= set(map(sum, combinations(r, k)))\\n        \\n        \\n        ans = float(\\'inf\\')\\n        for k in lsum:\\n            rsum_cand = sorted(rsum[n // 2 - k])\\n            for ls in lsum[k]:\\n                cand = tot // 2 - ls                \\n                loc = bisect.bisect(rsum_cand, cand)\\n                if loc == 0:\\n                    rs = rsum_cand[loc]\\n                    ans = min(ans, abs(tot - 2 * (rs + ls)))\\n                elif loc == len(rsum_cand):\\n                    rs = rsum_cand[loc-1]\\n                    ans = min(ans, abs(tot - 2 * (rs + ls)))\\n                else:\\n                    rs1, rs2 = rsum_cand[loc-1], rsum_cand[loc]\\n                    ans = min(ans, abs(tot - 2 * (rs1 + ls)), abs(tot - 2 * (rs2 + ls)))        \\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n        tot = sum(nums)\\n\\n        l, r = nums[:n//2], nums[n//2:]\\n        lsum, rsum = defaultdict(set), defaultdict(set)\\n\\n        for k in range(n // 2 + 1):\\n            lsum[k] |= set(map(sum, combinations(l, k)))\\n            rsum[k] |= set(map(sum, combinations(r, k)))\\n        \\n        \\n        ans = float(\\'inf\\')\\n        for k in lsum:\\n            rsum_cand = sorted(rsum[n // 2 - k])\\n            for ls in lsum[k]:\\n                cand = tot // 2 - ls                \\n                loc = bisect.bisect(rsum_cand, cand)\\n                if loc == 0:\\n                    rs = rsum_cand[loc]\\n                    ans = min(ans, abs(tot - 2 * (rs + ls)))\\n                elif loc == len(rsum_cand):\\n                    rs = rsum_cand[loc-1]\\n                    ans = min(ans, abs(tot - 2 * (rs + ls)))\\n                else:\\n                    rs1, rs2 = rsum_cand[loc-1], rsum_cand[loc]\\n                    ans = min(ans, abs(tot - 2 * (rs1 + ls)), abs(tot - 2 * (rs2 + ls)))        \\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1513342,
                "title": "c-kind-of-binary-search-easy-understanding-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n=nums.size()/2;\\n        vector<int> v[n+1];\\n        for(int i=0;i<(1<<n);i++){\\n            int ct=0;\\n            int summ=0;\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))!=0){\\n                    ct++;\\n                    summ+=nums[j];\\n                }\\n                else\\n                    summ-=nums[j];\\n            }\\n            v[ct].push_back(summ);\\n        }\\n        for(int i=0;i<=n;i++)\\n            sort(v[i].begin(),v[i].end());\\n        int minn=1e9;\\n        for(int i=0;i<(1<<n);i++){\\n            int ct=0;\\n            int summ=0;\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))!=0){\\n                    ct++;\\n                    summ+=nums[j+n];\\n                }\\n                else\\n                    summ-=nums[j+n];\\n            }\\n            int pos=lower_bound(v[n-ct].begin(),v[n-ct].end(),-summ)-v[n-ct].begin();\\n            if(pos<v[n-ct].size())\\n                minn=min(minn,abs(v[n-ct][pos]+summ));\\n            if(pos!=0){\\n                pos-=1;\\n                minn=min(minn,abs(v[n-ct][pos]+summ));\\n            }\\n        }\\n        return minn;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n=nums.size()/2;\\n        vector<int> v[n+1];\\n        for(int i=0;i<(1<<n);i++){\\n            int ct=0;\\n            int summ=0;\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))!=0){\\n                    ct++;\\n                    summ+=nums[j];\\n                }\\n                else\\n                    summ-=nums[j];\\n            }\\n            v[ct].push_back(summ);\\n        }\\n        for(int i=0;i<=n;i++)\\n            sort(v[i].begin(),v[i].end());\\n        int minn=1e9;\\n        for(int i=0;i<(1<<n);i++){\\n            int ct=0;\\n            int summ=0;\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))!=0){\\n                    ct++;\\n                    summ+=nums[j+n];\\n                }\\n                else\\n                    summ-=nums[j+n];\\n            }\\n            int pos=lower_bound(v[n-ct].begin(),v[n-ct].end(),-summ)-v[n-ct].begin();\\n            if(pos<v[n-ct].size())\\n                minn=min(minn,abs(v[n-ct][pos]+summ));\\n            if(pos!=0){\\n                pos-=1;\\n                minn=min(minn,abs(v[n-ct][pos]+summ));\\n            }\\n        }\\n        return minn;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513322,
                "title": "getting-tle-please-help-c",
                "content": "I was getting tle during contest. If I use vector or int array of 1<<30+1 than I faced memory limite exceeded and when I used HashMap than TLE.\\nPlease help what I missed.\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> dp;\\n    int ans = INT_MAX;\\n    int solve(vector<int>& nums, long first, int firstCnt, long totalSum, int mask) {\\n        if(firstCnt >= nums.size()/2) {\\n            long sec = totalSum - first;\\n            return abs(first-sec);\\n        }\\n        \\n        if(dp.find(mask)!=dp.end()){\\n            return dp[mask];\\n        }\\n        \\n        int res = INT_MAX;\\n        for(int j=0;j<nums.size();j++) {\\n            if((mask & (1<<j)) != 0)  continue;\\n            res = min(res, solve(nums,first+nums[j], firstCnt+1, totalSum, mask | 1<<j));\\n        }\\n        return dp[mask]=res;\\n    }\\n    \\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        long totalSum = 0;\\n        for(int &i:nums) totalSum+=i;\\n        return solve(nums,0,0,totalSum, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> dp;\\n    int ans = INT_MAX;\\n    int solve(vector<int>& nums, long first, int firstCnt, long totalSum, int mask) {\\n        if(firstCnt >= nums.size()/2) {\\n            long sec = totalSum - first;\\n            return abs(first-sec);\\n        }\\n        \\n        if(dp.find(mask)!=dp.end()){\\n            return dp[mask];\\n        }\\n        \\n        int res = INT_MAX;\\n        for(int j=0;j<nums.size();j++) {\\n            if((mask & (1<<j)) != 0)  continue;\\n            res = min(res, solve(nums,first+nums[j], firstCnt+1, totalSum, mask | 1<<j));\\n        }\\n        return dp[mask]=res;\\n    }\\n    \\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        long totalSum = 0;\\n        for(int &i:nums) totalSum+=i;\\n        return solve(nums,0,0,totalSum, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760921,
                "title": "avoiding-tle-while-using-set",
                "content": "# Intuition\\nUsing meet in the middle technique (just a fancy name)\\n\\n# Approach\\nDivide array in two half ( **$$firstArr$$ , $$secondArr$$** ).\\n\\nFor n = 15 or nums size = n*2 = 30\\nboth array size is 15.\\n\\nMake 2 map<int, set<int>> **($$firstMap$$, $$secondMap$$)** and store sum of each possible subset of both array and use number of set bits as key ( see implementation).\\n\\nNow use the first **$$HINT$$** in question.\\nWe have to find the sum of n(15 in our case) elements as close \\npossible as to (Total sum of given array)/2 , let call this **$$halfSum$$**.\\n\\nFor this iterate over firstMap :\\nFor each key (which is number of set Bit (let x bit))\\niterate over elements (let $$p$$ ) in set ( $$firstMap[x]$$ ).\\nand find element (let $$q$$) in set $$secondMap[ n - x ]$$\\nsucn that $$p + q$$ is as close as to $$halfSum$$.\\n\\nFor this for each element in set ( $$firstMap[x]$$ ) \\napply lowerBound( halfSum - p ) in set $$secondMap[ n - x ]$$.\\nIf we got $$secondMap[ n - x ]$$.end() use last element of set $$secondMap[ n - x ]$$ as q.\\n \\n\\n# Complexity\\n- Time complexity  :  $$2^n$$ * $$log(2^n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,set<int>>first, second;\\n\\n    void fillMap(int bit, vector<int>&num, bool firstMap){\\n        int countOfSetBit = 0, i = 0, ans = 0;\\n        while(bit){\\n            if(bit%2){\\n                countOfSetBit++;\\n                ans += num[i];\\n            }\\n            bit >>= 1;\\n            i++;\\n        }\\n        if(firstMap) first[countOfSetBit].insert(ans);\\n        else second[countOfSetBit].insert(ans);\\n    }\\n\\n    // firstMap denote whether to fill firstMap or secondMap\\n    void helper(vector<int>&num, bool firstMap){\\n        int n = num.size();\\n        for(int bit=0; bit<pow(2,n); bit++){\\n            fillMap(bit, num, firstMap);\\n        }\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int>firstHalf, secondHalf;\\n        int n = nums.size();\\n        int sum = 0;\\n        for(int i=0; i<n/2; i++){\\n            firstHalf.push_back(nums[i]);\\n            sum += nums[i];\\n        }\\n        for(int i = n/2; i<n; i++){\\n            secondHalf.push_back(nums[i]);\\n            sum += nums[i];\\n        }\\n        \\n        int halfSum = sum/2;\\n        int ans = INT_MAX;\\n\\n        helper(firstHalf, 1);\\n        helper(secondHalf, 0);\\n        \\n        // use this & to avoid TLE (this helps to avoid creating extra copy)\\n        for(auto &K: first){\\n            \\n            int totalOne = K.first;\\n\\n            // use this & to avoid TLE\\n            for(auto &ele : K.second){\\n\\n                int req = halfSum - ele;\\n                \\n                                // set<int>st\\n                // don\\'t create this \\u2B06\\uFE0F extra set , simply use set reference from first/second map \\n                //(this helps to avoid creating extra copy)\\n                auto it = second[n/2 - totalOne].lower_bound(req);\\n\\n                int tot = ele;\\n                if( it != second[n/2 - totalOne].end())\\n                    tot += (*it);\\n                else if(second[n/2 - totalOne].size())\\n                    tot += (*second[n/2 - totalOne].rbegin());\\n\\n                ans = min(ans, abs((sum - tot) - tot));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,set<int>>first, second;\\n\\n    void fillMap(int bit, vector<int>&num, bool firstMap){\\n        int countOfSetBit = 0, i = 0, ans = 0;\\n        while(bit){\\n            if(bit%2){\\n                countOfSetBit++;\\n                ans += num[i];\\n            }\\n            bit >>= 1;\\n            i++;\\n        }\\n        if(firstMap) first[countOfSetBit].insert(ans);\\n        else second[countOfSetBit].insert(ans);\\n    }\\n\\n    // firstMap denote whether to fill firstMap or secondMap\\n    void helper(vector<int>&num, bool firstMap){\\n        int n = num.size();\\n        for(int bit=0; bit<pow(2,n); bit++){\\n            fillMap(bit, num, firstMap);\\n        }\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int>firstHalf, secondHalf;\\n        int n = nums.size();\\n        int sum = 0;\\n        for(int i=0; i<n/2; i++){\\n            firstHalf.push_back(nums[i]);\\n            sum += nums[i];\\n        }\\n        for(int i = n/2; i<n; i++){\\n            secondHalf.push_back(nums[i]);\\n            sum += nums[i];\\n        }\\n        \\n        int halfSum = sum/2;\\n        int ans = INT_MAX;\\n\\n        helper(firstHalf, 1);\\n        helper(secondHalf, 0);\\n        \\n        // use this & to avoid TLE (this helps to avoid creating extra copy)\\n        for(auto &K: first){\\n            \\n            int totalOne = K.first;\\n\\n            // use this & to avoid TLE\\n            for(auto &ele : K.second){\\n\\n                int req = halfSum - ele;\\n                \\n                                // set<int>st\\n                // don\\'t create this \\u2B06\\uFE0F extra set , simply use set reference from first/second map \\n                //(this helps to avoid creating extra copy)\\n                auto it = second[n/2 - totalOne].lower_bound(req);\\n\\n                int tot = ele;\\n                if( it != second[n/2 - totalOne].end())\\n                    tot += (*it);\\n                else if(second[n/2 - totalOne].size())\\n                    tot += (*second[n/2 - totalOne].rbegin());\\n\\n                ans = min(ans, abs((sum - tot) - tot));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556255,
                "title": "c-recursive-code-to-generate-all-subsets-for-left-and-right-half-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void subset(int idx,vector<vector<int>>& ans,int siz,int sum,vector<int>& nums)\\n    {\\n        if(idx>=nums.size())\\n        {\\n            if(siz>0)\\n            ans[siz].push_back(sum);\\n            return;\\n        }\\n        subset(idx+1,ans,siz+1,sum+nums[idx],nums);\\n        subset(idx+1,ans,siz,sum,nums);\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/2;\\n        vector<vector<int>> left(n+1),right(n+1);\\n        vector<int> v1,v2;\\n        for(int i=0;i<n;i++)\\n        v1.push_back(nums[i]);\\n        for(int i=n;i<2*n;i++)\\n        v2.push_back(nums[i]);\\n        \\n        subset(0,left,0,0,v1);\\n        subset(0,right,0,0,v2);\\n        \\n        for(int i=0;i<right.size();i++)\\n        {\\n            sort(right[i].begin(),right[i].end());\\n        }\\n        int ans = 1e9;\\n        int sum = 0;\\n        for(auto &i:nums)\\n        sum+=i;\\n        ans = min(abs(sum-2*left[n][0]),abs(sum-2*right[n][0]));\\n        for(int i=1;i<=n;i++)\\n        {\\n            int rsiz = n-i;\\n            vector<int> tmp = right[rsiz];\\n            for(auto &j:left[i])\\n            {\\n                int b = (sum-2*j)/2;\\n                auto it = lower_bound(tmp.begin(),tmp.end(),b);\\n                if(it!=tmp.end())\\n                {\\n                    ans = min(ans,abs(sum-2*(j+(*it))));\\n                }\\n                if(it!=tmp.begin())\\n                {\\n                    it--;\\n                    ans = min(ans,abs(sum-2*(j+(*it))));\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void subset(int idx,vector<vector<int>>& ans,int siz,int sum,vector<int>& nums)\\n    {\\n        if(idx>=nums.size())\\n        {\\n            if(siz>0)\\n            ans[siz].push_back(sum);\\n            return;\\n        }\\n        subset(idx+1,ans,siz+1,sum+nums[idx],nums);\\n        subset(idx+1,ans,siz,sum,nums);\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/2;\\n        vector<vector<int>> left(n+1),right(n+1);\\n        vector<int> v1,v2;\\n        for(int i=0;i<n;i++)\\n        v1.push_back(nums[i]);\\n        for(int i=n;i<2*n;i++)\\n        v2.push_back(nums[i]);\\n        \\n        subset(0,left,0,0,v1);\\n        subset(0,right,0,0,v2);\\n        \\n        for(int i=0;i<right.size();i++)\\n        {\\n            sort(right[i].begin(),right[i].end());\\n        }\\n        int ans = 1e9;\\n        int sum = 0;\\n        for(auto &i:nums)\\n        sum+=i;\\n        ans = min(abs(sum-2*left[n][0]),abs(sum-2*right[n][0]));\\n        for(int i=1;i<=n;i++)\\n        {\\n            int rsiz = n-i;\\n            vector<int> tmp = right[rsiz];\\n            for(auto &j:left[i])\\n            {\\n                int b = (sum-2*j)/2;\\n                auto it = lower_bound(tmp.begin(),tmp.end(),b);\\n                if(it!=tmp.end())\\n                {\\n                    ans = min(ans,abs(sum-2*(j+(*it))));\\n                }\\n                if(it!=tmp.begin())\\n                {\\n                    it--;\\n                    ans = min(ans,abs(sum-2*(j+(*it))));\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580710,
                "title": "simple-solution-but-showing-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>nums, int i, int left, int right, int &res,int count1, int count2){\\n        if(i>=nums.size()){\\n            if(count1==count2){\\n                res= min(res, abs(left-right));\\n            }\\n            return;\\n        }\\n        \\n        solve(nums, i+1, left+nums[i], right, res,count1+1,count2);\\n        solve(nums, i+1, left, right+nums[i], res,count1, count2+1);\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        int res= INT_MAX;\\n        solve(nums, 0, 0,0, res,0,0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>nums, int i, int left, int right, int &res,int count1, int count2){\\n        if(i>=nums.size()){\\n            if(count1==count2){\\n                res= min(res, abs(left-right));\\n            }\\n            return;\\n        }\\n        \\n        solve(nums, i+1, left+nums[i], right, res,count1+1,count2);\\n        solve(nums, i+1, left, right+nums[i], res,count1, count2+1);\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        int res= INT_MAX;\\n        solve(nums, 0, 0,0, res,0,0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538231,
                "title": "c-meet-in-the-middle-binary-search-explained",
                "content": "**Here we have to find 2 groups of equal length (N).\\nLet\\'s say, left_ans is required the N elements required for first group, and right_ans is the other N elements for second group.**\\n\\n* **Intuition ->\\nThe main and only intuition which is required here is,\\nnums = [1,3,6,5,4,2]\\nSo, let\\'s divide into 2 parts\\nleft_part = [1,3,6]\\nright_part = [5,4,2]\\nN = nums.size() / 2, i.e. no. of elements in each group. Here 3.\\nSo here, to make left_ans either we can take all 3 from left_part and 0 from right_part, or 1 from left_part and 2(N-1) from right_part, 2 from left_part and 1(N-2) from right_part.**\\n\\n* **So how this works is, if we take 1 from left_part, so this means we have taken one group of element, so its sum is taken from l_sum = left_sums[1], now to make is closer to half = total / 2, we need to add req_sum = half - l_sum, so we will binary search the value of it in right_sums. So now lest_ans_sum will become l_sum + r_sum(the binary search sum we got closest go req_sum).\\nNote - Above we are just finding the best possible sum of left_ans, as right_ans sum will then be total - left_ans_sum.**\\n\\n* **The get_sums function generate all possible subset sums using k elements from nums.\\nnums = [1,3,6]\\nget_sums(nums) will give,\\n{1: [1, 3, 6], // using only 1 elements from nums\\n2: [4, 7, 9], // using only 2\\n3: [10]} // using all 3**\\n\\n* **Why not TLE ->\\nAnd why this works is, because we are generating all possible subset sums using only k elements, where k is from 1 to N. Which is in total 2k, and as max value of k is 15, so 215 is 32,000. Which is easy to work with. While if you try to make all subset sums, it becomes 230 is 1,073,741,824 which will give TLE.**\\n\\n* **Meet in the Middle ->\\nThis technique is called meet in the middle. Here we are halving the max array size from 30, to 15. As generating all possible subset sums is feasible, ie 215. And to complete left_ans, we are taking subset sum of k from left_part, and N-k from right_part.**\\n\\n* **Time Complexity ->\\nFor N elements, there are 2N subset possible. Then we also sum those each of those subset. O(N * 2^N)\\nFor each k from 1 to 15, there are 2M1 subset sums for left, then we are sorting right O(M2 * logM2), then we are finding its other part using binary search logM2.\\nO(2M1 * logM2 + M2 * logM2),\\nwhere,\\nM1 = no. of elements in left_sums[k],\\nM2 = no. of elements in right_sums[N-k]**\\n\\n* **Space Complexity ->\\nAs there are 2N subsets, for left and right. So, O(2 * 2^N), where max value of N is 15.**\\n\\n----------------------------------------------------------------------------------------------------------------\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tint minimumDifference(vector<int>& nums) {\\n\\n\\t\\tint n = nums.size() / 2;\\n\\t\\tvector<vector<int>> left(n+1, vector<int>()), right(n+1, vector<int>());\\n\\t\\tfunction<void(int, int, int, int, vector<vector<int>>&)> generate;\\n\\n\\t\\tint total = accumulate(begin(nums), end(nums), 0);\\n\\t\\tint target = total / 2;\\n\\n\\t\\tgenerate = [&](int i, int s, int total, int len, vector<vector<int>>& v){\\n\\t\\t\\tif(i-s >= n){\\n\\t\\t\\t\\tv[len].push_back(total);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tgenerate(i+1, s, total, len, v);            \\n\\t\\t\\tgenerate(i+1, s, total+nums[i], len+1, v);\\n\\n\\t\\t};\\n\\n\\t\\tgenerate(0,0,0,0,left);        \\n\\t\\tgenerate(n,n,0,0,right);\\n\\n\\t\\tfor(auto& v : right) \\n\\t\\t\\tsort(begin(v), end(v));\\n\\n\\t\\tint ans = INT_MAX;\\n\\t\\tfor(int i=0; i<=n; ++i){\\n\\t\\t\\tfor(int& L : left[i]){\\n\\t\\t\\t\\tint key = target - L;\\n\\t\\t\\t\\tauto iter = lower_bound(right[n-i].begin(), right[n-i].end(), key);\\n\\t\\t\\t\\tif(iter == right[n-i].end()) iter--;\\n\\n\\t\\t\\t\\tint lsum = L + *iter;\\n\\t\\t\\t\\tint rsum = total - lsum;\\n\\t\\t\\t\\tint diff = abs(lsum - rsum);\\n\\n\\t\\t\\t\\tif(diff == 0) \\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\tans = min(ans, diff);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minimumDifference(vector<int>& nums) {\\n\\n\\t\\tint n = nums.size() / 2;\\n\\t\\tvector<vector<int>> left(n+1, vector<int>()), right(n+1, vector<int>());\\n\\t\\tfunction<void(int, int, int, int, vector<vector<int>>&)> generate;\\n\\n\\t\\tint total = accumulate(begin(nums), end(nums), 0);\\n\\t\\tint target = total / 2;\\n\\n\\t\\tgenerate = [&](int i, int s, int total, int len, vector<vector<int>>& v){\\n\\t\\t\\tif(i-s >= n){\\n\\t\\t\\t\\tv[len].push_back(total);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tgenerate(i+1, s, total, len, v);            \\n\\t\\t\\tgenerate(i+1, s, total+nums[i], len+1, v);\\n\\n\\t\\t};\\n\\n\\t\\tgenerate(0,0,0,0,left);        \\n\\t\\tgenerate(n,n,0,0,right);\\n\\n\\t\\tfor(auto& v : right) \\n\\t\\t\\tsort(begin(v), end(v));\\n\\n\\t\\tint ans = INT_MAX;\\n\\t\\tfor(int i=0; i<=n; ++i){\\n\\t\\t\\tfor(int& L : left[i]){\\n\\t\\t\\t\\tint key = target - L;\\n\\t\\t\\t\\tauto iter = lower_bound(right[n-i].begin(), right[n-i].end(), key);\\n\\t\\t\\t\\tif(iter == right[n-i].end()) iter--;\\n\\n\\t\\t\\t\\tint lsum = L + *iter;\\n\\t\\t\\t\\tint rsum = total - lsum;\\n\\t\\t\\t\\tint diff = abs(lsum - rsum);\\n\\n\\t\\t\\t\\tif(diff == 0) \\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\tans = min(ans, diff);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503878,
                "title": "java-meet-in-middle",
                "content": "```\\n/*\\n    Main intuition behind this approach is \\n    to split the problem into two halves\\n    \\n    In the first half we\\'ll calculate all possible sums that can be\\n    generated from subsets of size at max n/2\\n    \\n    In the second half we\\'ll find out minimum sum difference.\\n    We\\'ll Follow the same process as above to calculate the sum (y),\\n    now we need to find some subset x from first half such that\\n    (t) - 2 * (x + y) is minimum\\n    \\n    Suppose we have total sum of 16, \\n    We are iterating in second half and got sum 5\\n    Now our desired sum from first half should be 3\\n    So (16) - 2 * (5 + 3) = 0 i.e Minimum.\\n    \\n    If we did not find 3 in first half, then next greater or smaller value\\n    from first half would be next be candidate\\n    (16) - 2 * (5 + 4) = 3 or\\n    (16) - 2 * (5 + 2) = 2 (minimum)\\n*/\\n\\n/*\\n    Here in this solution, BitMask is used to generate all possible subsets\\n    Iterating from 0 to 2 ^ (n/2) would return all possible combinations\\n    like 001101, 10001, 111111, 0000000\\n    We\\'ll include element in the current sum if ith bit is set (1)\\n    \\n    HashMap<Integer, TreeSet> is used to maintain (in sorted order) the all possible sums that can be generated\\n    of from subset of size x.\\n*/\\n\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        int t = 0;\\n        for(int i : nums) t += i;\\n        HashMap<Integer, TreeSet<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < (1 << (n/2)); i++){\\n            int sum = 0;\\n            int cnt = 0;\\n            int j = i;\\n            int set = 0;\\n            while(j > 0){\\n                if((j & 1) == 1){\\n                    sum += nums[cnt];\\n                    set++;\\n                }\\n                cnt++;\\n                j >>= 1;\\n            }\\n            if(!map.containsKey(set)) map.put(set, new TreeSet<>());\\n            map.get(set).add(sum);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0; i < (1 << (n/2)); i++){\\n            int sum = 0;\\n            int cnt = (n/2);\\n            int j = i;\\n            int set = 0;\\n            while(j > 0){\\n                if((j & 1) == 1){\\n                    sum += nums[cnt];\\n                    set++;\\n                }\\n                cnt++;\\n                j >>= 1;\\n            }\\n            TreeSet<Integer> searchSpace = map.get((n/2) - set);\\n            int d = (t/2) - sum;\\n            Integer left = searchSpace.floor(d);\\n            if(left != null) res = Math.min(res, Math.abs(t - 2 * (left + sum)));\\n            Integer right = searchSpace.ceiling(d);\\n            if(right != null) res = Math.min(res, Math.abs(t - 2 * (right + sum)));\\n            if(res == 0) return 0;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n    Main intuition behind this approach is \\n    to split the problem into two halves\\n    \\n    In the first half we\\'ll calculate all possible sums that can be\\n    generated from subsets of size at max n/2\\n    \\n    In the second half we\\'ll find out minimum sum difference.\\n    We\\'ll Follow the same process as above to calculate the sum (y),\\n    now we need to find some subset x from first half such that\\n    (t) - 2 * (x + y) is minimum\\n    \\n    Suppose we have total sum of 16, \\n    We are iterating in second half and got sum 5\\n    Now our desired sum from first half should be 3\\n    So (16) - 2 * (5 + 3) = 0 i.e Minimum.\\n    \\n    If we did not find 3 in first half, then next greater or smaller value\\n    from first half would be next be candidate\\n    (16) - 2 * (5 + 4) = 3 or\\n    (16) - 2 * (5 + 2) = 2 (minimum)\\n*/\\n\\n/*\\n    Here in this solution, BitMask is used to generate all possible subsets\\n    Iterating from 0 to 2 ^ (n/2) would return all possible combinations\\n    like 001101, 10001, 111111, 0000000\\n    We\\'ll include element in the current sum if ith bit is set (1)\\n    \\n    HashMap<Integer, TreeSet> is used to maintain (in sorted order) the all possible sums that can be generated\\n    of from subset of size x.\\n*/\\n\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        int t = 0;\\n        for(int i : nums) t += i;\\n        HashMap<Integer, TreeSet<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < (1 << (n/2)); i++){\\n            int sum = 0;\\n            int cnt = 0;\\n            int j = i;\\n            int set = 0;\\n            while(j > 0){\\n                if((j & 1) == 1){\\n                    sum += nums[cnt];\\n                    set++;\\n                }\\n                cnt++;\\n                j >>= 1;\\n            }\\n            if(!map.containsKey(set)) map.put(set, new TreeSet<>());\\n            map.get(set).add(sum);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0; i < (1 << (n/2)); i++){\\n            int sum = 0;\\n            int cnt = (n/2);\\n            int j = i;\\n            int set = 0;\\n            while(j > 0){\\n                if((j & 1) == 1){\\n                    sum += nums[cnt];\\n                    set++;\\n                }\\n                cnt++;\\n                j >>= 1;\\n            }\\n            TreeSet<Integer> searchSpace = map.get((n/2) - set);\\n            int d = (t/2) - sum;\\n            Integer left = searchSpace.floor(d);\\n            if(left != null) res = Math.min(res, Math.abs(t - 2 * (left + sum)));\\n            Integer right = searchSpace.ceiling(d);\\n            if(right != null) res = Math.min(res, Math.abs(t - 2 * (right + sum)));\\n            if(res == 0) return 0;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463375,
                "title": "how-to-handle-negative-numbers-using-dp",
                "content": "The solution below is quite intuitive but cannot handle negative numbers, please leave your comment if you know how.\\n\\n```\\nconst minimumSubsetSumDifference = function (nums) {\\n  let n = nums.length;\\n  let total = nums.reduce((sum, cur) => (sum += cur), 0);\\n  let sum = Math.floor(total / 2);\\n  let dp = Array(sum + 1).fill(false);\\n  dp[0] = true;\\n  for (let s = 1; s <= sum; s++) {\\n    dp[s] = nums[0] === s;\\n  }\\n\\n  for (let i = 1; i < n; i++) {\\n    for (let s = sum; s >= 0; s--) {\\n      if (!dp[s] && s >= nums[i]) {\\n        dp[s] = dp[s - nums[i]];\\n      }\\n    }\\n  }\\n\\n  let sum1 = 0;\\n  for (let i = sum; i >= 0; i--) {\\n    if (dp[i] === true) {\\n      sum1 = i;\\n      break;\\n    }\\n  }\\n  let sum2 = total - sum1;\\n\\n  return Math.abs(sum2 - sum1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst minimumSubsetSumDifference = function (nums) {\\n  let n = nums.length;\\n  let total = nums.reduce((sum, cur) => (sum += cur), 0);\\n  let sum = Math.floor(total / 2);\\n  let dp = Array(sum + 1).fill(false);\\n  dp[0] = true;\\n  for (let s = 1; s <= sum; s++) {\\n    dp[s] = nums[0] === s;\\n  }\\n\\n  for (let i = 1; i < n; i++) {\\n    for (let s = sum; s >= 0; s--) {\\n      if (!dp[s] && s >= nums[i]) {\\n        dp[s] = dp[s - nums[i]];\\n      }\\n    }\\n  }\\n\\n  let sum1 = 0;\\n  for (let i = sum; i >= 0; i--) {\\n    if (dp[i] === true) {\\n      sum1 = i;\\n      break;\\n    }\\n  }\\n  let sum2 = total - sum1;\\n\\n  return Math.abs(sum2 - sum1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2298929,
                "title": "how-to-handle-negative-test-cases-suggestions-are-most-welcome",
                "content": "```\\nclass Solution:\\n    \\n    def f(self,target,index,nums,dp):\\n        \\n        if target==0:\\n\\t\\t    dp[index][target]=True\\n            return dp[index][target]\\n        if index==0: \\n\\t\\t\\tdp[index][target]=nums[index]==target\\n\\t\\t\\treturn dp[index][target]\\n        if dp[index][target]!=-1:\\n            return dp[index][target]==target\\n        nottaken=self.f(target,index-1,nums,dp)\\n        taken=False\\n        if nums[index]<=target:\\n            taken=self.f(target-nums[index],index-1,nums,dp)\\n        dp[index][target]= taken or nottaken\\n        return dp[index][target]\\n        \\n        \\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        m=min(nums)\\n        totalsum=sum(nums)\\n        dp=[[-1 for _ in range(totalsum+1)] for _ in range(n)]\\n        for target in range(totalsum):\\n            dummy=self.f(target,n-1,nums,dp)\\n        \\n        minimum=10e9\\n        for target in range(totalsum):\\n            if dp[n-1][target]==True:\\n                minimum=min(minimum,abs(target-(totalsum-target)))\\n        return minimum\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def f(self,target,index,nums,dp):\\n        \\n        if target==0:\\n\\t\\t    dp[index][target]=True\\n            return dp[index][target]\\n        if index==0: \\n\\t\\t\\tdp[index][target]=nums[index]==target\\n\\t\\t\\treturn dp[index][target]\\n        if dp[index][target]!=-1:\\n            return dp[index][target]==target\\n        nottaken=self.f(target,index-1,nums,dp)\\n        taken=False\\n        if nums[index]<=target:\\n            taken=self.f(target-nums[index],index-1,nums,dp)\\n        dp[index][target]= taken or nottaken\\n        return dp[index][target]\\n        \\n        \\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        m=min(nums)\\n        totalsum=sum(nums)\\n        dp=[[-1 for _ in range(totalsum+1)] for _ in range(n)]\\n        for target in range(totalsum):\\n            dummy=self.f(target,n-1,nums,dp)\\n        \\n        minimum=10e9\\n        for target in range(totalsum):\\n            if dp[n-1][target]==True:\\n                minimum=min(minimum,abs(target-(totalsum-target)))\\n        return minimum\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243065,
                "title": "compact-meet-in-the-middle",
                "content": "The other Python solutions are way too verbose. Use the standard library.\\n\\nThis problem is fundamentally a knapsack task, so don\\'t sweat the exponential runtime. You can\\'t do better than that.\\n\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n=len(nums)//2\\n        A=[sorted(sum(x) for x in combinations(nums[:n],k)) for k in range(n+1)]\\n        B=[sorted(sum(x) for x in combinations(nums[n:],k)) for k in range(n+1)]\\n        S=sum(nums)\\n        T=S/2\\n        best=float(\\'inf\\')\\n        for k in range(n+1):\\n            a = A[k]\\n            b = B[n-k]\\n            for ai in a:\\n                j = bisect_left(b, T-ai)\\n                if j<len(b):\\n                    best = min(best, abs(S-2*(ai+b[j])))\\n                if j:\\n                    best = min(best, abs(S-2*(ai+b[j-1])))\\n        return best\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n=len(nums)//2\\n        A=[sorted(sum(x) for x in combinations(nums[:n],k)) for k in range(n+1)]\\n        B=[sorted(sum(x) for x in combinations(nums[n:],k)) for k in range(n+1)]\\n        S=sum(nums)\\n        T=S/2\\n        best=float(\\'inf\\')\\n        for k in range(n+1):\\n            a = A[k]\\n            b = B[n-k]\\n            for ai in a:\\n                j = bisect_left(b, T-ai)\\n                if j<len(b):\\n                    best = min(best, abs(S-2*(ai+b[j])))\\n                if j:\\n                    best = min(best, abs(S-2*(ai+b[j-1])))\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234929,
                "title": "all-subset-sum-dp-top-down",
                "content": "ANYONE KNOW HOW TO MEMOIZE THIS SO THAT IT DONT GIVE TLE????\\n\\n\\n```java\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int sum=0;\\n        \\n        for(int i=0; i<nums.length; i++)\\n            sum+=nums[i];\\n        \\n        List<Integer> list=new ArrayList<>();\\n        f(nums, 0, 0, 0, list);\\n        \\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0; i<=list.size()/2; i++) \\n            ans=Math.min(ans, Math.abs(sum-list.get(i)-list.get(i)));\\n        \\n        return ans;\\n    }\\n    void f(int[] nums, int i, int sum, int l, List<Integer> list) {\\n        if(l == nums.length/2) {\\n            list.add(sum);\\n            return;\\n        }\\n        if(i == nums.length) \\n            return;\\n        \\n        f(nums, i+1, sum+nums[i], l+1, list);\\n        f(nums, i+1, sum, l, list);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int sum=0;\\n        \\n        for(int i=0; i<nums.length; i++)\\n            sum+=nums[i];\\n        \\n        List<Integer> list=new ArrayList<>();\\n        f(nums, 0, 0, 0, list);\\n        \\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0; i<=list.size()/2; i++) \\n            ans=Math.min(ans, Math.abs(sum-list.get(i)-list.get(i)));\\n        \\n        return ans;\\n    }\\n    void f(int[] nums, int i, int sum, int l, List<Integer> list) {\\n        if(l == nums.length/2) {\\n            list.add(sum);\\n            return;\\n        }\\n        if(i == nums.length) \\n            return;\\n        \\n        f(nums, i+1, sum+nums[i], l+1, list);\\n        f(nums, i+1, sum, l, list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125182,
                "title": "c-code-for-beginners-meet-in-the-middle",
                "content": "```\\nclass Solution {\\npublic:\\n    void fill2D(vector<int> &nums, int curr, int k, int sum, vector<vector<int>> &sums){\\n        if(curr==nums.size()){\\n            sums[k].push_back(sum);\\n            return;\\n        }\\n        fill2D(nums,curr+1,k,sum,sums);\\n        fill2D(nums,curr+1,k+1,sum+nums[curr],sums);\\n    }\\n    \\n    int minimumDifference(vector<int>& nums) {\\n        int n=nums.size()/2;\\n        \\n        vector<int> arr1;\\n        vector<int> arr2;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(i<n){\\n                arr1.push_back(nums[i]);\\n            }\\n            else{\\n                arr2.push_back(nums[i]);\\n            } \\n        }\\n        \\n        vector<vector<int>> part1(n+1);\\n        vector<vector<int>> part2(n+1);\\n        \\n        fill2D(arr1,0,0,0,part1);      \\n        fill2D(arr2,0,0,0,part2);\\n\\n        for(auto &vec: part2){\\n            sort(vec.begin(),vec.end());  // for binary searching\\n        }\\n        \\n        int res=INT_MAX;\\n        int sum=accumulate(nums.begin(),nums.end(),0);\\n        \\n        for(int k=0;k<=n;k++){\\n            vector<int> P1=part1[k];\\n            vector<int> P2=part2[n-k];  //BECAUSE IF WE ARE TAKING 1 FROM PART1 WE NEED TO TAKE N-K FROM PART 2 SINCE EACH LENGTH OF SUBSET SHOULD RESULT TO N\\n            for(auto e: P1){\\n                \\n                auto itr=lower_bound(P2.begin(),P2.end(),sum/2-e);  // searching for mid value reduce difference\\n                \\n                if(itr!=P2.end()){\\n                    int subset1_Sum=e+*itr;\\n                    int subset2_Sum=sum-subset1_Sum;\\n                    res=min(res,abs(subset1_Sum-subset2_Sum));\\n                }\\n                \\n                if(itr!=P2.begin()){\\n                    itr--;  \\n// because lower bound points at index which is >= searched element, so the index just before the returned index will be always smaller or equal value\\n                    int subset1_Sum=e+*itr;\\n                    int subset2_Sum=sum-subset1_Sum;\\n                    res=min(res,abs(subset1_Sum-subset2_Sum));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void fill2D(vector<int> &nums, int curr, int k, int sum, vector<vector<int>> &sums){\\n        if(curr==nums.size()){\\n            sums[k].push_back(sum);\\n            return;\\n        }\\n        fill2D(nums,curr+1,k,sum,sums);\\n        fill2D(nums,curr+1,k+1,sum+nums[curr],sums);\\n    }\\n    \\n    int minimumDifference(vector<int>& nums) {\\n        int n=nums.size()/2;\\n        \\n        vector<int> arr1;\\n        vector<int> arr2;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(i<n){\\n                arr1.push_back(nums[i]);\\n            }\\n            else{\\n                arr2.push_back(nums[i]);\\n            } \\n        }\\n        \\n        vector<vector<int>> part1(n+1);\\n        vector<vector<int>> part2(n+1);\\n        \\n        fill2D(arr1,0,0,0,part1);      \\n        fill2D(arr2,0,0,0,part2);\\n\\n        for(auto &vec: part2){\\n            sort(vec.begin(),vec.end());  // for binary searching\\n        }\\n        \\n        int res=INT_MAX;\\n        int sum=accumulate(nums.begin(),nums.end(),0);\\n        \\n        for(int k=0;k<=n;k++){\\n            vector<int> P1=part1[k];\\n            vector<int> P2=part2[n-k];  //BECAUSE IF WE ARE TAKING 1 FROM PART1 WE NEED TO TAKE N-K FROM PART 2 SINCE EACH LENGTH OF SUBSET SHOULD RESULT TO N\\n            for(auto e: P1){\\n                \\n                auto itr=lower_bound(P2.begin(),P2.end(),sum/2-e);  // searching for mid value reduce difference\\n                \\n                if(itr!=P2.end()){\\n                    int subset1_Sum=e+*itr;\\n                    int subset2_Sum=sum-subset1_Sum;\\n                    res=min(res,abs(subset1_Sum-subset2_Sum));\\n                }\\n                \\n                if(itr!=P2.begin()){\\n                    itr--;  \\n// because lower bound points at index which is >= searched element, so the index just before the returned index will be always smaller or equal value\\n                    int subset1_Sum=e+*itr;\\n                    int subset2_Sum=sum-subset1_Sum;\\n                    res=min(res,abs(subset1_Sum-subset2_Sum));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079796,
                "title": "hashmap-meet-in-the-middle-two-pointer-java-solution",
                "content": "```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int total= 0;\\n        for(int i : nums){\\n            total+=i;\\n        }\\n        int target = total/2, min = Integer.MAX_VALUE, val = min;\\n        HashMap<Integer, ArrayList<Integer>> hm1 = new HashMap<>();\\n        HashMap<Integer, ArrayList<Integer>> hm2 = new HashMap<>();\\n        int half = nums.length/2;\\n        for(int i = 0 ; i<=half ; i++){\\n            hm1.put(i,new ArrayList<Integer>());\\n            hm2.put(i,new ArrayList<Integer>());\\n        }\\n        solve(nums,0,0,0,half,hm1);\\n        solve(nums,half,0,0,nums.length,hm2);\\n        for(int i = 0 ; i<=half ; i++){\\n            ArrayList<Integer> list1 = hm1.get(i);\\n            ArrayList<Integer> list2 = hm2.get(half-i);\\n            Collections.sort(list1);\\n            Collections.sort(list2);\\n            int j = 0 , k = list2.size()-1;\\n            while(j<list1.size() && k>=0){\\n                int sum = list1.get(j) + list2.get(k);\\n                if(sum==target){\\n                    return Math.abs(total-2*sum);\\n                }else if(sum>target){\\n                    k--;\\n                }else{\\n                    j++;\\n                }\\n                int diff = Math.abs(sum-target);\\n                if(diff<min){\\n                    min = diff;\\n                    val = sum;\\n                }\\n            }\\n            \\n        }\\n        return Math.abs(total - 2*val);\\n    }\\n    \\n    public void solve(int []nums,int i, int sum, int count, int high, HashMap<Integer, ArrayList<Integer>> hm){\\n        if(i==high){\\n            hm.get(count).add(sum);\\n            return;\\n        } \\n        solve(nums,i+1,sum+nums[i],count+1,high,hm);\\n        solve(nums,i+1,sum,count,high,hm);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int total= 0;\\n        for(int i : nums){\\n            total+=i;\\n        }\\n        int target = total/2, min = Integer.MAX_VALUE, val = min;\\n        HashMap<Integer, ArrayList<Integer>> hm1 = new HashMap<>();\\n        HashMap<Integer, ArrayList<Integer>> hm2 = new HashMap<>();\\n        int half = nums.length/2;\\n        for(int i = 0 ; i<=half ; i++){\\n            hm1.put(i,new ArrayList<Integer>());\\n            hm2.put(i,new ArrayList<Integer>());\\n        }\\n        solve(nums,0,0,0,half,hm1);\\n        solve(nums,half,0,0,nums.length,hm2);\\n        for(int i = 0 ; i<=half ; i++){\\n            ArrayList<Integer> list1 = hm1.get(i);\\n            ArrayList<Integer> list2 = hm2.get(half-i);\\n            Collections.sort(list1);\\n            Collections.sort(list2);\\n            int j = 0 , k = list2.size()-1;\\n            while(j<list1.size() && k>=0){\\n                int sum = list1.get(j) + list2.get(k);\\n                if(sum==target){\\n                    return Math.abs(total-2*sum);\\n                }else if(sum>target){\\n                    k--;\\n                }else{\\n                    j++;\\n                }\\n                int diff = Math.abs(sum-target);\\n                if(diff<min){\\n                    min = diff;\\n                    val = sum;\\n                }\\n            }\\n            \\n        }\\n        return Math.abs(total - 2*val);\\n    }\\n    \\n    public void solve(int []nums,int i, int sum, int count, int high, HashMap<Integer, ArrayList<Integer>> hm){\\n        if(i==high){\\n            hm.get(count).add(sum);\\n            return;\\n        } \\n        solve(nums,i+1,sum+nums[i],count+1,high,hm);\\n        solve(nums,i+1,sum,count,high,hm);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847981,
                "title": "c-3-solutions",
                "content": "**Solution 1: Fastest**\\n```\\n        public int MinimumDifference(int[] nums)\\n        {\\n            var len = nums.Length / 2;\\n            var leftSum = 0;\\n            var rightSum = 0;\\n            for (int i = 0; i < len; i++)\\n            {\\n                leftSum += nums[i];\\n                rightSum += nums[len + i];\\n            }\\n            var diff = (leftSum - rightSum) / 2;\\n\\n            var result = Math.Abs(leftSum - rightSum);\\n            for (int i = 0; i < len / 2; i++)\\n            {\\n                var leftCS = new List<int>();\\n                var rightCS = new List<int>();\\n                FillCombSums(nums, 0, len, 0, i, leftCS);\\n                FillCombSums(nums, len, nums.Length, 0, i, rightCS);\\n                rightCS.Sort();\\n\\n                foreach (var sum in leftCS)\\n                {\\n                    var target = sum - diff;\\n                    var newSum = GetMinDistance(rightCS, target);\\n                    var currentResult = Math.Abs((leftSum - sum + newSum) - (rightSum - newSum + sum));\\n                    result = Math.Min(result, currentResult);\\n                    if (result <= 1)\\n                    {\\n                        return result;\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n\\n        private void FillCombSums(int[] nums, int firstPos, int lastPos, int sum, int level, List<int> result)\\n        {\\n            for (int i = firstPos; i < lastPos - level; i++)\\n            {\\n                if (level == 0)\\n                {\\n                    result.Add(sum + nums[i]);\\n                }\\n                else\\n                {\\n                    FillCombSums(nums, i + 1, lastPos, sum + nums[i], level - 1, result);\\n                }\\n            }\\n        }\\n\\n        private int GetMinDistance(List<int> sortedNums, int target)\\n        {\\n            var left = 0;\\n            var right = sortedNums.Count - 1;\\n            while (left < right)\\n            {\\n                var mid = (left + right) / 2;\\n                if (sortedNums[mid] == target)\\n                {\\n                    return sortedNums[mid];\\n                }\\n                if (sortedNums[mid] > target)\\n                {\\n                    right = mid - 1;\\n                }\\n                else\\n                {\\n                    left = mid + 1;\\n                }\\n            }\\n            var result = sortedNums[left];\\n            var rdist = Math.Abs(sortedNums[left] - target);\\n\\n            if (left > 0 && rdist > Math.Abs(sortedNums[left - 1] - target))\\n            {\\n                result = sortedNums[left - 1];\\n                rdist = Math.Abs(sortedNums[left - 1] -  target);\\n            }\\n            if (left < sortedNums.Count - 1 && rdist > Math.Abs(sortedNums[left + 1] -  target))\\n            {\\n                result = sortedNums[left + 1];\\n            }\\n            return result;\\n        }\\n```\\n\\n**Solution 2: Faster / Shortest (but has bitwise operations)**\\n```\\npublic int MinimumDifference(int[] nums)\\n\\t{\\n\\t\\tvar n = nums.Length/2;\\n        //Array.Sort(nums);\\n        \\n        var left = new List<int>[n+1];\\n        var right = new List<int>[n+1];\\n\\n\\t\\tleft[0] = new List<int>();\\n\\t\\tright[0] = new List<int>();\\n\\t\\tleft[n] = new List<int>();\\n\\t\\tright[n] = new List<int>();\\n\\t\\tvar sum = 0;\\n        for(var i = 0; i < n; i++)\\n        {\\n            sum += nums[i] + nums[n+i];\\n            left[i] = new List<int>();\\n            right[i] = new List<int>();\\n        }\\n        \\n        for(var mask = 0; mask < (1 << n); mask++)\\n        {\\n            var sz = 0;\\n            var ls = 0;\\n            var rs = 0;\\n            for(var i = 0; i < n; i++)\\n            {\\n                if((mask & (1 << i)) > 0)\\n                {\\n                    sz++;\\n\\t\\t\\t\\t\\tls += nums[i];\\n\\t\\t\\t\\t\\trs += nums[n + i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tleft[sz].Add(ls);\\n\\t\\t\\tright[sz].Add(rs);\\n\\t\\t}\\n\\n\\t\\tfor (var i = 0; i < n; i++)\\n\\t\\t\\tright[i].Sort();\\n\\n\\t\\tvar tgt = sum >> 1;\\n\\t\\tvar min = int.MaxValue;\\n\\t\\tfor (var i = 0; i <= n; i++)\\n\\t\\t{\\n\\t\\t\\tfor (var j = 0; j < left[i].Count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar rTgt = tgt - left[i][j];\\n\\n\\t\\t\\t\\tvar rIndex = right[n - i].BinarySearch(rTgt);\\n\\t\\t\\t\\tif (rIndex >= 0) return sum & 1;\\n\\t\\t\\t\\trIndex = ~rIndex;\\n\\t\\t\\t\\tif (rIndex < right[n - i].Count) min = Math.Min(min, Math.Abs(rTgt - right[n - i][rIndex]));\\n\\t\\t\\t\\tif (rIndex > 0) min = Math.Min(min, Math.Abs(rTgt - right[n - i][rIndex - 1]));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn min * 2 + (sum & 1);\\n\\t}\\n```\\n\\n**Solution 3: Slowest**\\n```\\n        Dictionary<int, SortedSet<int>> leftMap = new Dictionary<int, SortedSet<int>>();\\n        Dictionary<int, SortedSet<int>> rightMap = new Dictionary<int, SortedSet<int>>();\\n\\n        public int minimumDifference(int[] nums)\\n        {\\n            if (nums == null || nums.Length == 0)\\n            {\\n                return -1;\\n            }\\n\\n            int n = nums.Length / 2;\\n            int sum = 0;\\n            // 1. generate {#_of_ele_in_set: [sums]}\\n            List<List<int>> arr1 = new List<List<int>>();\\n            List<List<int>> arr2 = new List<List<int>>();\\n            for (int i = 0; i <= n; i++)\\n            {\\n                arr1.Add(new List<int>());\\n                arr2.Add(new List<int>());\\n                if (i < n)\\n                {\\n                    sum += nums[i];\\n                    sum += nums[i + n];\\n                }\\n            }\\n\\n            for (int state = 0; state < (1 << n); state++)\\n            {\\n                int sum1 = 0, sum2 = 0;\\n                for (int i = 0; i < n; i++)\\n                {\\n                    if ((state & (1 << i)) == 0)\\n                    {\\n                        continue;\\n                    }\\n                    int a1 = nums[i];\\n                    int a2 = nums[i + n];\\n                    sum1 += a1;\\n                    sum2 += a2;\\n                }\\n                int numOfEleInSet = BitCount(state);\\n                arr1[numOfEleInSet].Add(sum1);\\n                arr2[numOfEleInSet].Add(sum2);\\n            }\\n\\n            var sortedArray = new List<int>();\\n            // 2. sort each [sums] in arr2\\n            for (int i = 0; i <= n; i++)\\n            {\\n                arr2[i].Sort();\\n            }\\n\\n            // 3. binary search\\n            int min = int.MaxValue;\\n            for (int i = 0; i <= n; i++)\\n            {\\n                List<int> sums1 = arr1[i];\\n                List<int> sums2 = arr2[n - i];\\n\\n                foreach (int s1 in sums1)\\n                {\\n                    int idx = sums2.BinarySearch(sum / 2 - s1);\\n                    if (idx < 0)\\n                    {\\n                        idx = -(idx + 1);\\n                    }\\n                    if (idx < sums1.Count)\\n                    {\\n                        min = Math.Min(min, Math.Abs((sum - s1 - sums2[idx]) - (sums2[idx] + s1)));\\n                    }\\n                    if (idx - 1 >= 0)\\n                    {\\n                        min = Math.Min(min, Math.Abs((sum - s1 - sums2[idx - 1]) - (sums2[idx - 1] + s1)));\\n                    }\\n                }\\n            }\\n\\n            return min;\\n        }\\n\\n        public static int BitCount(int n)\\n        {\\n            var count = 0;\\n            while (n != 0)\\n            {\\n                count++;\\n                n &= (n - 1); //walking through all the bits which are set to one\\n            }\\n\\n            return count;\\n        }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n        public int MinimumDifference(int[] nums)\\n        {\\n            var len = nums.Length / 2;\\n            var leftSum = 0;\\n            var rightSum = 0;\\n            for (int i = 0; i < len; i++)\\n            {\\n                leftSum += nums[i];\\n                rightSum += nums[len + i];\\n            }\\n            var diff = (leftSum - rightSum) / 2;\\n\\n            var result = Math.Abs(leftSum - rightSum);\\n            for (int i = 0; i < len / 2; i++)\\n            {\\n                var leftCS = new List<int>();\\n                var rightCS = new List<int>();\\n                FillCombSums(nums, 0, len, 0, i, leftCS);\\n                FillCombSums(nums, len, nums.Length, 0, i, rightCS);\\n                rightCS.Sort();\\n\\n                foreach (var sum in leftCS)\\n                {\\n                    var target = sum - diff;\\n                    var newSum = GetMinDistance(rightCS, target);\\n                    var currentResult = Math.Abs((leftSum - sum + newSum) - (rightSum - newSum + sum));\\n                    result = Math.Min(result, currentResult);\\n                    if (result <= 1)\\n                    {\\n                        return result;\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n\\n        private void FillCombSums(int[] nums, int firstPos, int lastPos, int sum, int level, List<int> result)\\n        {\\n            for (int i = firstPos; i < lastPos - level; i++)\\n            {\\n                if (level == 0)\\n                {\\n                    result.Add(sum + nums[i]);\\n                }\\n                else\\n                {\\n                    FillCombSums(nums, i + 1, lastPos, sum + nums[i], level - 1, result);\\n                }\\n            }\\n        }\\n\\n        private int GetMinDistance(List<int> sortedNums, int target)\\n        {\\n            var left = 0;\\n            var right = sortedNums.Count - 1;\\n            while (left < right)\\n            {\\n                var mid = (left + right) / 2;\\n                if (sortedNums[mid] == target)\\n                {\\n                    return sortedNums[mid];\\n                }\\n                if (sortedNums[mid] > target)\\n                {\\n                    right = mid - 1;\\n                }\\n                else\\n                {\\n                    left = mid + 1;\\n                }\\n            }\\n            var result = sortedNums[left];\\n            var rdist = Math.Abs(sortedNums[left] - target);\\n\\n            if (left > 0 && rdist > Math.Abs(sortedNums[left - 1] - target))\\n            {\\n                result = sortedNums[left - 1];\\n                rdist = Math.Abs(sortedNums[left - 1] -  target);\\n            }\\n            if (left < sortedNums.Count - 1 && rdist > Math.Abs(sortedNums[left + 1] -  target))\\n            {\\n                result = sortedNums[left + 1];\\n            }\\n            return result;\\n        }\\n```\n```\\npublic int MinimumDifference(int[] nums)\\n\\t{\\n\\t\\tvar n = nums.Length/2;\\n        //Array.Sort(nums);\\n        \\n        var left = new List<int>[n+1];\\n        var right = new List<int>[n+1];\\n\\n\\t\\tleft[0] = new List<int>();\\n\\t\\tright[0] = new List<int>();\\n\\t\\tleft[n] = new List<int>();\\n\\t\\tright[n] = new List<int>();\\n\\t\\tvar sum = 0;\\n        for(var i = 0; i < n; i++)\\n        {\\n            sum += nums[i] + nums[n+i];\\n            left[i] = new List<int>();\\n            right[i] = new List<int>();\\n        }\\n        \\n        for(var mask = 0; mask < (1 << n); mask++)\\n        {\\n            var sz = 0;\\n            var ls = 0;\\n            var rs = 0;\\n            for(var i = 0; i < n; i++)\\n            {\\n                if((mask & (1 << i)) > 0)\\n                {\\n                    sz++;\\n\\t\\t\\t\\t\\tls += nums[i];\\n\\t\\t\\t\\t\\trs += nums[n + i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tleft[sz].Add(ls);\\n\\t\\t\\tright[sz].Add(rs);\\n\\t\\t}\\n\\n\\t\\tfor (var i = 0; i < n; i++)\\n\\t\\t\\tright[i].Sort();\\n\\n\\t\\tvar tgt = sum >> 1;\\n\\t\\tvar min = int.MaxValue;\\n\\t\\tfor (var i = 0; i <= n; i++)\\n\\t\\t{\\n\\t\\t\\tfor (var j = 0; j < left[i].Count; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar rTgt = tgt - left[i][j];\\n\\n\\t\\t\\t\\tvar rIndex = right[n - i].BinarySearch(rTgt);\\n\\t\\t\\t\\tif (rIndex >= 0) return sum & 1;\\n\\t\\t\\t\\trIndex = ~rIndex;\\n\\t\\t\\t\\tif (rIndex < right[n - i].Count) min = Math.Min(min, Math.Abs(rTgt - right[n - i][rIndex]));\\n\\t\\t\\t\\tif (rIndex > 0) min = Math.Min(min, Math.Abs(rTgt - right[n - i][rIndex - 1]));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn min * 2 + (sum & 1);\\n\\t}\\n```\n```\\n        Dictionary<int, SortedSet<int>> leftMap = new Dictionary<int, SortedSet<int>>();\\n        Dictionary<int, SortedSet<int>> rightMap = new Dictionary<int, SortedSet<int>>();\\n\\n        public int minimumDifference(int[] nums)\\n        {\\n            if (nums == null || nums.Length == 0)\\n            {\\n                return -1;\\n            }\\n\\n            int n = nums.Length / 2;\\n            int sum = 0;\\n            // 1. generate {#_of_ele_in_set: [sums]}\\n            List<List<int>> arr1 = new List<List<int>>();\\n            List<List<int>> arr2 = new List<List<int>>();\\n            for (int i = 0; i <= n; i++)\\n            {\\n                arr1.Add(new List<int>());\\n                arr2.Add(new List<int>());\\n                if (i < n)\\n                {\\n                    sum += nums[i];\\n                    sum += nums[i + n];\\n                }\\n            }\\n\\n            for (int state = 0; state < (1 << n); state++)\\n            {\\n                int sum1 = 0, sum2 = 0;\\n                for (int i = 0; i < n; i++)\\n                {\\n                    if ((state & (1 << i)) == 0)\\n                    {\\n                        continue;\\n                    }\\n                    int a1 = nums[i];\\n                    int a2 = nums[i + n];\\n                    sum1 += a1;\\n                    sum2 += a2;\\n                }\\n                int numOfEleInSet = BitCount(state);\\n                arr1[numOfEleInSet].Add(sum1);\\n                arr2[numOfEleInSet].Add(sum2);\\n            }\\n\\n            var sortedArray = new List<int>();\\n            // 2. sort each [sums] in arr2\\n            for (int i = 0; i <= n; i++)\\n            {\\n                arr2[i].Sort();\\n            }\\n\\n            // 3. binary search\\n            int min = int.MaxValue;\\n            for (int i = 0; i <= n; i++)\\n            {\\n                List<int> sums1 = arr1[i];\\n                List<int> sums2 = arr2[n - i];\\n\\n                foreach (int s1 in sums1)\\n                {\\n                    int idx = sums2.BinarySearch(sum / 2 - s1);\\n                    if (idx < 0)\\n                    {\\n                        idx = -(idx + 1);\\n                    }\\n                    if (idx < sums1.Count)\\n                    {\\n                        min = Math.Min(min, Math.Abs((sum - s1 - sums2[idx]) - (sums2[idx] + s1)));\\n                    }\\n                    if (idx - 1 >= 0)\\n                    {\\n                        min = Math.Min(min, Math.Abs((sum - s1 - sums2[idx - 1]) - (sums2[idx - 1] + s1)));\\n                    }\\n                }\\n            }\\n\\n            return min;\\n        }\\n\\n        public static int BitCount(int n)\\n        {\\n            var count = 0;\\n            while (n != 0)\\n            {\\n                count++;\\n                n &= (n - 1); //walking through all the bits which are set to one\\n            }\\n\\n            return count;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1745359,
                "title": "split-array-into-half-and-bit-mask-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int totalSum = 0;\\n      \\n        for(int num : nums) {\\n          totalSum += num;\\n        }\\n        \\n        int n = nums.size();\\n        vector <vector<int>> left_part(n / 2 + 1), right_part(n / 2 + 1);\\n      \\n        left_part[0].push_back(0);\\n        right_part[0].push_back(0);\\n      \\n        int part_len = n / 2;\\n        for(int i = 0; i < (1 << part_len); i++) {\\n          int part_sum = 0, len = 0;\\n          \\n          for(int j = 0; j < n / 2; j++) {\\n            if(i & (1 << j)) {\\n              part_sum += nums[j];\\n              len++;\\n            }\\n          }\\n          \\n          left_part[len].push_back(part_sum);\\n        }\\n      \\n      \\n        for(int i = 0; i < (1 << part_len); i++) {\\n          int part_sum = 0, len = 0;\\n          \\n          for(int j = 0; j < n / 2; j++) {\\n            if(i & (1 << j)) {\\n              part_sum += nums[j + n / 2];\\n              len++;\\n            }\\n          }\\n          \\n          right_part[len].push_back(part_sum);\\n        }\\n      \\n        for(int l = 0; l <= n / 2; l++) {\\n            sort(left_part[l].begin(), left_part[l].end());\\n            sort(right_part[l].begin(), right_part[l].end());\\n        }\\n      \\n        int minDiff = INT_MAX;\\n        for(int l = 0; l <= n / 2; l++) {\\n            int left_len = l, right_len = n / 2 - l;\\n          \\n            int half = totalSum / 2;\\n            for(int i = 0; i < left_part[left_len].size(); i++) {\\n                int req = half - left_part[left_len][i];\\n                auto it = lower_bound(right_part[right_len].begin(), right_part[right_len].end(), req);\\n              \\n                if(it == right_part[right_len].end()) {\\n                  it--;\\n                }\\n                int p1 = left_part[left_len][i] + (*it);\\n                int p2 = totalSum - p1;\\n              \\n                minDiff = min(abs(p1 - p2), minDiff);\\n            }\\n        }\\n        \\n        return minDiff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int totalSum = 0;\\n      \\n        for(int num : nums) {\\n          totalSum += num;\\n        }\\n        \\n        int n = nums.size();\\n        vector <vector<int>> left_part(n / 2 + 1), right_part(n / 2 + 1);\\n      \\n        left_part[0].push_back(0);\\n        right_part[0].push_back(0);\\n      \\n        int part_len = n / 2;\\n        for(int i = 0; i < (1 << part_len); i++) {\\n          int part_sum = 0, len = 0;\\n          \\n          for(int j = 0; j < n / 2; j++) {\\n            if(i & (1 << j)) {\\n              part_sum += nums[j];\\n              len++;\\n            }\\n          }\\n          \\n          left_part[len].push_back(part_sum);\\n        }\\n      \\n      \\n        for(int i = 0; i < (1 << part_len); i++) {\\n          int part_sum = 0, len = 0;\\n          \\n          for(int j = 0; j < n / 2; j++) {\\n            if(i & (1 << j)) {\\n              part_sum += nums[j + n / 2];\\n              len++;\\n            }\\n          }\\n          \\n          right_part[len].push_back(part_sum);\\n        }\\n      \\n        for(int l = 0; l <= n / 2; l++) {\\n            sort(left_part[l].begin(), left_part[l].end());\\n            sort(right_part[l].begin(), right_part[l].end());\\n        }\\n      \\n        int minDiff = INT_MAX;\\n        for(int l = 0; l <= n / 2; l++) {\\n            int left_len = l, right_len = n / 2 - l;\\n          \\n            int half = totalSum / 2;\\n            for(int i = 0; i < left_part[left_len].size(); i++) {\\n                int req = half - left_part[left_len][i];\\n                auto it = lower_bound(right_part[right_len].begin(), right_part[right_len].end(), req);\\n              \\n                if(it == right_part[right_len].end()) {\\n                  it--;\\n                }\\n                int p1 = left_part[left_len][i] + (*it);\\n                int p2 = totalSum - p1;\\n              \\n                minDiff = min(abs(p1 - p2), minDiff);\\n            }\\n        }\\n        \\n        return minDiff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535744,
                "title": "c-divide-array-half-using-hint-of-input-size-95",
                "content": "```\\ntypedef long long LL;\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        LL sum = accumulate(nums.begin(), nums.end(), 0LL);\\n        int n = nums.size() / 2;\\n        vector<vector<LL>> v1(n * 2),v2(n * 2);\\n\\n        dfs(nums, 0, n, 0LL, v1, 0);\\n        dfs(nums, n, n * 2, 0LL, v2, 0);\\n        LL res = 0x3f3f3f3f;\\n        for(auto& vec : v2){\\n            sort(vec.begin(), vec.end());\\n        }\\n        for(int i = 0; i < v1.size(); i++){\\n            for(auto& sum1: v1[i]){\\n                auto iter = lower_bound(v2[n - i].begin(), v2[n - i].end(), sum / 2 - sum1);\\n                if(iter != v2[n - i].end()){\\n                    res = min(res, abs(sum - 2 * (sum1 + (*iter))));\\n                }\\n                \\n                if(iter != v2[n - i].begin()){\\n                    res = min(res, abs(sum - 2 * (sum1 + (*prev(iter)))));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\nprivate:\\n    void dfs(vector<int>& nums, int start, int end, LL sum, vector<vector<LL>>& vec, int count){\\n        if(start == end){\\n            vec[count].push_back(sum);\\n            return;\\n        }\\n        \\n        dfs(nums, start + 1, end, sum + nums[start], vec, count + 1);\\n        dfs(nums, start + 1, end, sum, vec, count);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long LL;\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        LL sum = accumulate(nums.begin(), nums.end(), 0LL);\\n        int n = nums.size() / 2;\\n        vector<vector<LL>> v1(n * 2),v2(n * 2);\\n\\n        dfs(nums, 0, n, 0LL, v1, 0);\\n        dfs(nums, n, n * 2, 0LL, v2, 0);\\n        LL res = 0x3f3f3f3f;\\n        for(auto& vec : v2){\\n            sort(vec.begin(), vec.end());\\n        }\\n        for(int i = 0; i < v1.size(); i++){\\n            for(auto& sum1: v1[i]){\\n                auto iter = lower_bound(v2[n - i].begin(), v2[n - i].end(), sum / 2 - sum1);\\n                if(iter != v2[n - i].end()){\\n                    res = min(res, abs(sum - 2 * (sum1 + (*iter))));\\n                }\\n                \\n                if(iter != v2[n - i].begin()){\\n                    res = min(res, abs(sum - 2 * (sum1 + (*prev(iter)))));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\nprivate:\\n    void dfs(vector<int>& nums, int start, int end, LL sum, vector<vector<LL>>& vec, int count){\\n        if(start == end){\\n            vec[count].push_back(sum);\\n            return;\\n        }\\n        \\n        dfs(nums, start + 1, end, sum + nums[start], vec, count + 1);\\n        dfs(nums, start + 1, end, sum, vec, count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514888,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn minimum_difference(nums: Vec<i32>) -> i32 {\\n        let n = nums.len() / 2;\\n        let mut cache_left: Vec<Vec<i32>> = vec![vec![]; n + 1];\\n        let s: i32 = nums.iter().sum();\\n        for i in 0..(1 << n) as u32 {\\n            let len_left = i.count_ones() as usize;\\n            let sum_left = Solution::subsum(i, &nums[..n]);\\n            cache_left[len_left].push(s - 2 * sum_left);\\n        }\\n\\n        cache_left.iter_mut().for_each(|x| x.sort_unstable());\\n\\n        let mut min_absdiff = i32::max_value();\\n        for i in 0..(1 << n) as u32 {\\n            let sum_right = Solution::subsum(i, &nums[n..]);\\n            let cl = &cache_left[n - i.count_ones() as usize];\\n            let absdiff = Solution::bsearch_min_absdiff(cl, sum_right);\\n            min_absdiff = min_absdiff.min(absdiff);\\n        }\\n        min_absdiff\\n    }\\n\\n    fn subsum(bitset: u32, nums: &[i32]) -> i32 {\\n        nums.iter().enumerate().fold(\\n            0,\\n            |sum, (j, v)| if bitset & (1 << j) != 0 { sum + v } else { sum },\\n        )\\n    }\\n\\n    fn bsearch_min_absdiff(cl: &[i32], sum_right: i32) -> i32 {\\n        match cl.binary_search(&(2 * sum_right)) {\\n            Ok(_) => 0,\\n            Err(j) => {\\n                if j == 0 {\\n                    (cl[j] - 2 * sum_right).abs()\\n                } else if j == cl.len() {\\n                    (cl[j - 1] - 2 * sum_right).abs()\\n                } else {\\n                    let absdiff_left = (cl[j - 1] - 2 * sum_right).abs();\\n                    let absdiff_right = (cl[j] - 2 * sum_right).abs();\\n                    absdiff_left.min(absdiff_right)\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n\\nI have tried several solution with TLE.\\n\\nMy first attempt is a brute force solution `O(n * 4^n)`.\\n\\n```rust\\nimpl Solution {\\n    // 4^n\\n    pub fn minimum_difference(nums: Vec<i32>) -> i32 {\\n        let s: i32 = nums.iter().sum();\\n        let mut min_abs_diff = i32::max_value();\\n        for bit_set in 0..1 << nums.len() {\\n            let mut sub_sum = 0;\\n            let mut cnt = 0;\\n            for (i, v) in nums.iter().enumerate() {\\n                if bit_set & (1 << i) != 0 {\\n                    sub_sum += v;\\n                    cnt += 1;\\n                }\\n            }\\n            if cnt == nums.len() / 2 {\\n                min_abs_diff = min_abs_diff.min((s - sub_sum - sub_sum).abs());\\n            }\\n        }\\n\\n        min_abs_diff\\n    }\\n}\\n```\\n\\nThen I realize I can split the input into two array and solve the subproblems. It still got TLE.\\n\\n```rust\\nimpl Solution {\\n    pub fn minimum_difference(nums: Vec<i32>) -> i32 {\\n        let n = nums.len() / 2;\\n        let mut cache_left: Vec<Vec<i32>> = vec![vec![]; n + 1];\\n        for i in 0..(1 << n) as u32 {\\n            let len_left = i.count_ones() as usize;\\n            cache_left[len_left].push(nums[..n].iter().enumerate().fold(0, |sum, (j, v)| {\\n                if i & (1 << j) != 0 {\\n                    sum + v\\n                } else {\\n                    sum\\n                }\\n            }));\\n        }\\n        let mut min_absdiff = i32::max_value();\\n        let s: i32 = nums.iter().sum();\\n        for i in 0..(1 << n) as u32 {\\n            let sum_right =\\n                nums[n..].iter().enumerate().fold(\\n                    0,\\n                    |sum, (j, v)| if i & (1 << j) != 0 { sum + v } else { sum },\\n                );\\n            let len_left = n - i.count_ones() as usize;\\n\\t\\t\\t// Big complexity here // consider use binary search then got the final solution\\n            for sum_left in &cache_left[len_left] {\\n                let subsum = sum_left + sum_right;\\n                let absdiff = (s - subsum - subsum).abs();\\n                min_absdiff = min_absdiff.min(absdiff);\\n            }\\n        }\\n        min_absdiff\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn minimum_difference(nums: Vec<i32>) -> i32 {\\n        let n = nums.len() / 2;\\n        let mut cache_left: Vec<Vec<i32>> = vec![vec![]; n + 1];\\n        let s: i32 = nums.iter().sum();\\n        for i in 0..(1 << n) as u32 {\\n            let len_left = i.count_ones() as usize;\\n            let sum_left = Solution::subsum(i, &nums[..n]);\\n            cache_left[len_left].push(s - 2 * sum_left);\\n        }\\n\\n        cache_left.iter_mut().for_each(|x| x.sort_unstable());\\n\\n        let mut min_absdiff = i32::max_value();\\n        for i in 0..(1 << n) as u32 {\\n            let sum_right = Solution::subsum(i, &nums[n..]);\\n            let cl = &cache_left[n - i.count_ones() as usize];\\n            let absdiff = Solution::bsearch_min_absdiff(cl, sum_right);\\n            min_absdiff = min_absdiff.min(absdiff);\\n        }\\n        min_absdiff\\n    }\\n\\n    fn subsum(bitset: u32, nums: &[i32]) -> i32 {\\n        nums.iter().enumerate().fold(\\n            0,\\n            |sum, (j, v)| if bitset & (1 << j) != 0 { sum + v } else { sum },\\n        )\\n    }\\n\\n    fn bsearch_min_absdiff(cl: &[i32], sum_right: i32) -> i32 {\\n        match cl.binary_search(&(2 * sum_right)) {\\n            Ok(_) => 0,\\n            Err(j) => {\\n                if j == 0 {\\n                    (cl[j] - 2 * sum_right).abs()\\n                } else if j == cl.len() {\\n                    (cl[j - 1] - 2 * sum_right).abs()\\n                } else {\\n                    let absdiff_left = (cl[j - 1] - 2 * sum_right).abs();\\n                    let absdiff_right = (cl[j] - 2 * sum_right).abs();\\n                    absdiff_left.min(absdiff_right)\\n                }\\n            }\\n        }\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    // 4^n\\n    pub fn minimum_difference(nums: Vec<i32>) -> i32 {\\n        let s: i32 = nums.iter().sum();\\n        let mut min_abs_diff = i32::max_value();\\n        for bit_set in 0..1 << nums.len() {\\n            let mut sub_sum = 0;\\n            let mut cnt = 0;\\n            for (i, v) in nums.iter().enumerate() {\\n                if bit_set & (1 << i) != 0 {\\n                    sub_sum += v;\\n                    cnt += 1;\\n                }\\n            }\\n            if cnt == nums.len() / 2 {\\n                min_abs_diff = min_abs_diff.min((s - sub_sum - sub_sum).abs());\\n            }\\n        }\\n\\n        min_abs_diff\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn minimum_difference(nums: Vec<i32>) -> i32 {\\n        let n = nums.len() / 2;\\n        let mut cache_left: Vec<Vec<i32>> = vec![vec![]; n + 1];\\n        for i in 0..(1 << n) as u32 {\\n            let len_left = i.count_ones() as usize;\\n            cache_left[len_left].push(nums[..n].iter().enumerate().fold(0, |sum, (j, v)| {\\n                if i & (1 << j) != 0 {\\n                    sum + v\\n                } else {\\n                    sum\\n                }\\n            }));\\n        }\\n        let mut min_absdiff = i32::max_value();\\n        let s: i32 = nums.iter().sum();\\n        for i in 0..(1 << n) as u32 {\\n            let sum_right =\\n                nums[n..].iter().enumerate().fold(\\n                    0,\\n                    |sum, (j, v)| if i & (1 << j) != 0 { sum + v } else { sum },\\n                );\\n            let len_left = n - i.count_ones() as usize;\\n\\t\\t\\t// Big complexity here // consider use binary search then got the final solution\\n            for sum_left in &cache_left[len_left] {\\n                let subsum = sum_left + sum_right;\\n                let absdiff = (s - subsum - subsum).abs();\\n                min_absdiff = min_absdiff.min(absdiff);\\n            }\\n        }\\n        min_absdiff\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514561,
                "title": "java-treeset-meet-in-the-middle",
                "content": "```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int finalMin = Integer.MAX_VALUE, total = 0, n = nums.length/2;\\n        for(int ea: nums) total+=ea;\\n        TreeSet<?>[] leftSet = new TreeSet<?>[n+1];\\n        TreeSet<?>[] rightSet = new TreeSet<?>[n+1];\\n        for(int i=0;i<(1<<n);i++) {\\n            int elems=0,l=0,r=0;\\n            for(int x=0;x<n;x++) {\\n                if((i&(1<<x))!=0) {\\n                    l+=nums[x];\\n                    r+=nums[n+x];\\n                    elems++;\\n                }\\n            }\\n            if(leftSet[elems]==null) leftSet[elems] = new TreeSet<Integer>();\\n            ((TreeSet<Integer>)leftSet[elems]).add(l);\\n            if(rightSet[elems]==null) rightSet[elems] = new TreeSet<Integer>();\\n            ((TreeSet<Integer>)rightSet[elems]).add(r);\\n        }\\n        for(int i=1;i<=n;i++) {\\n            for(int leftCandidate: (TreeSet<Integer>)leftSet[i]) {\\n                int rightIdeal = (total - 2 * leftCandidate)/2;\\n                int rightCount = n-i;\\n                Integer lowerCandidate = ((TreeSet<Integer>)rightSet[rightCount]).floor(rightIdeal);\\n                Integer higherCandidate = ((TreeSet<Integer>)rightSet[rightCount]).ceiling(rightIdeal);\\n                if(lowerCandidate!=null) finalMin = Math.min(finalMin, Math.abs(total-2*(leftCandidate + lowerCandidate)));\\n                if(higherCandidate!=null) finalMin = Math.min(finalMin, Math.abs(total-2*(leftCandidate + higherCandidate)));\\n                if(finalMin == 0) return 0;\\n            }\\n        }\\n        return finalMin;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int finalMin = Integer.MAX_VALUE, total = 0, n = nums.length/2;\\n        for(int ea: nums) total+=ea;\\n        TreeSet<?>[] leftSet = new TreeSet<?>[n+1];\\n        TreeSet<?>[] rightSet = new TreeSet<?>[n+1];\\n        for(int i=0;i<(1<<n);i++) {\\n            int elems=0,l=0,r=0;\\n            for(int x=0;x<n;x++) {\\n                if((i&(1<<x))!=0) {\\n                    l+=nums[x];\\n                    r+=nums[n+x];\\n                    elems++;\\n                }\\n            }\\n            if(leftSet[elems]==null) leftSet[elems] = new TreeSet<Integer>();\\n            ((TreeSet<Integer>)leftSet[elems]).add(l);\\n            if(rightSet[elems]==null) rightSet[elems] = new TreeSet<Integer>();\\n            ((TreeSet<Integer>)rightSet[elems]).add(r);\\n        }\\n        for(int i=1;i<=n;i++) {\\n            for(int leftCandidate: (TreeSet<Integer>)leftSet[i]) {\\n                int rightIdeal = (total - 2 * leftCandidate)/2;\\n                int rightCount = n-i;\\n                Integer lowerCandidate = ((TreeSet<Integer>)rightSet[rightCount]).floor(rightIdeal);\\n                Integer higherCandidate = ((TreeSet<Integer>)rightSet[rightCount]).ceiling(rightIdeal);\\n                if(lowerCandidate!=null) finalMin = Math.min(finalMin, Math.abs(total-2*(leftCandidate + lowerCandidate)));\\n                if(higherCandidate!=null) finalMin = Math.min(finalMin, Math.abs(total-2*(leftCandidate + higherCandidate)));\\n                if(finalMin == 0) return 0;\\n            }\\n        }\\n        return finalMin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513495,
                "title": "c-concise-meet-in-the-middle",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        int total = 0;\\n        for(int i = 0; i < n; ++i){\\n            total += nums[i];\\n        }\\n        vector<set<int>> st(n/2+1);\\n        for(int i = 0; i < (1<<(n/2)); ++i){\\n            int sum = 0;\\n            int cont = 0;\\n            for(int j = 0; j < n/2; ++j){\\n                if(i & (1<<j)){\\n                    sum += nums[j];\\n                    ++cont;\\n                }\\n            }\\n            st[cont].insert(2*sum);\\n        }\\n        int mini = INT_MAX;\\n        for(int i = 0; i < (1<<(n/2)); ++i){\\n            int sum = 0;\\n            int cont = 0;\\n            for(int j = 0; j < n/2; ++j){\\n                if(i & (1<<j)){\\n                    sum += nums[j+(n/2)];\\n                    ++cont;\\n                }\\n            }\\n            int num = total-2*sum;\\n            auto it = st[n/2-cont].lower_bound(num);\\n            if(it != st[n/2-cont].end()){\\n                mini = min(mini, abs(num-(*it)));\\n            }\\n            if(st[n/2-cont].size() >= 1 && it != st[n/2-cont].begin()){\\n                --it;\\n                mini = min(mini, abs(num-(*it)));\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        int total = 0;\\n        for(int i = 0; i < n; ++i){\\n            total += nums[i];\\n        }\\n        vector<set<int>> st(n/2+1);\\n        for(int i = 0; i < (1<<(n/2)); ++i){\\n            int sum = 0;\\n            int cont = 0;\\n            for(int j = 0; j < n/2; ++j){\\n                if(i & (1<<j)){\\n                    sum += nums[j];\\n                    ++cont;\\n                }\\n            }\\n            st[cont].insert(2*sum);\\n        }\\n        int mini = INT_MAX;\\n        for(int i = 0; i < (1<<(n/2)); ++i){\\n            int sum = 0;\\n            int cont = 0;\\n            for(int j = 0; j < n/2; ++j){\\n                if(i & (1<<j)){\\n                    sum += nums[j+(n/2)];\\n                    ++cont;\\n                }\\n            }\\n            int num = total-2*sum;\\n            auto it = st[n/2-cont].lower_bound(num);\\n            if(it != st[n/2-cont].end()){\\n                mini = min(mini, abs(num-(*it)));\\n            }\\n            if(st[n/2-cont].size() >= 1 && it != st[n/2-cont].begin()){\\n                --it;\\n                mini = min(mini, abs(num-(*it)));\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821390,
                "title": "meet-in-the-middle-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public static int lowerBound(ArrayList<Integer> list, int key) {\\n        int left = 0;\\n        int right = list.size()-1;\\nint ans=list.size()-1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int midValue = list.get(mid);\\n\\n            if (midValue >= key) {\\n               ans=mid;\\n               right=mid-1;\\n            } else {\\n               left=mid+1;\\n            }\\n        }\\n\\n        return list.get(ans);\\n    }\\n    public int minimumDifference(int[] nums) {\\n        \\n        HashMap<Integer,ArrayList<Integer>> one=new HashMap<>();\\n        HashMap<Integer,ArrayList<Integer>> two=new HashMap<>();\\n        int n=nums.length/2;\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n        }\\n\\n        for(int i=0;i<(1<<n);i++){\\n            int s1=0;\\n            int s2=0;\\n            int l1=0;\\n            int l2=0;\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))>=1){\\n                s1+=nums[j];\\n                s2+=nums[j+n];\\n                l1++;\\n                l2++;\\n                }\\n            }\\n           ArrayList<Integer> fi= one.getOrDefault(l1,new ArrayList<>());\\n           ArrayList<Integer> se= two.getOrDefault(l2,new ArrayList<>());\\n           fi.add(s1);\\n           se.add(s2);\\n           one.put(l1,fi);\\n           two.put(l2,se);\\n         \\n        }\\n        for(ArrayList<Integer> e:two.values()){\\n            Collections.sort(e);\\n        }\\n     int ans=Integer.MAX_VALUE;\\n        for(Integer e:one.keySet()){\\n             ArrayList<Integer> nfi=one.get(e);\\n             ArrayList<Integer> nse=two.get(n-e);\\n             for(Integer m:nfi){\\n             int lb=lowerBound(nse,(sum-2*m)/2);\\n             ans=Math.min(ans,Math.abs(sum-2*(m+lb)));\\n             }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public static int lowerBound(ArrayList<Integer> list, int key) {\\n        int left = 0;\\n        int right = list.size()-1;\\nint ans=list.size()-1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int midValue = list.get(mid);\\n\\n            if (midValue >= key) {\\n               ans=mid;\\n               right=mid-1;\\n            } else {\\n               left=mid+1;\\n            }\\n        }\\n\\n        return list.get(ans);\\n    }\\n    public int minimumDifference(int[] nums) {\\n        \\n        HashMap<Integer,ArrayList<Integer>> one=new HashMap<>();\\n        HashMap<Integer,ArrayList<Integer>> two=new HashMap<>();\\n        int n=nums.length/2;\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n        }\\n\\n        for(int i=0;i<(1<<n);i++){\\n            int s1=0;\\n            int s2=0;\\n            int l1=0;\\n            int l2=0;\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j))>=1){\\n                s1+=nums[j];\\n                s2+=nums[j+n];\\n                l1++;\\n                l2++;\\n                }\\n            }\\n           ArrayList<Integer> fi= one.getOrDefault(l1,new ArrayList<>());\\n           ArrayList<Integer> se= two.getOrDefault(l2,new ArrayList<>());\\n           fi.add(s1);\\n           se.add(s2);\\n           one.put(l1,fi);\\n           two.put(l2,se);\\n         \\n        }\\n        for(ArrayList<Integer> e:two.values()){\\n            Collections.sort(e);\\n        }\\n     int ans=Integer.MAX_VALUE;\\n        for(Integer e:one.keySet()){\\n             ArrayList<Integer> nfi=one.get(e);\\n             ArrayList<Integer> nse=two.get(n-e);\\n             for(Integer m:nfi){\\n             int lb=lowerBound(nse,(sum-2*m)/2);\\n             ans=Math.min(ans,Math.abs(sum-2*(m+lb)));\\n             }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714548,
                "title": "c-meet-in-the-middle-o-2-n-2-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe would have been able to solve this question, with just simple brute force. Picking and not picking elements, when `n <= 20`. But, we have `n <= 30` for this problem. In such cases, we might think of using Meet in the Middle.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe general approach of Meet in the Middle is if we are able to solve for half of the input, and are able to combine them in some way, usually with non-exponential time complexity, then we can use it.\\n\\nThus, we divide the array `nums` into two equal parts `l1` and `l2`. Now, we generate all possible sums which can be acheived in these arrays. We are also interested in dividing the original array into two equal parts, i.e. `n` elements each. Thus, it would be useful not only to generate all the sums, but also the number of elements needed to achieve it.\\n\\nFor each required number of elements taken to achieve the sums, we sort this sums, and also remove duplicates, as duplicates would be irrelavant to our search. It might also create trouble for the binary search later on, as with equal adjacent elements. It would be difficult to do a binary search to identify a trough.\\n\\nNow, we are able to have a binary search as basically we want to minimise: \\n$$|sum - 2*subsetSum1|$$, whose graph will decrease till 0 linearly and then increase. \\n\\nThe binary search is similar to [162. Find Peak Element](https://leetcode.com/problems/find-peak-element/description/) except in case of peak we need to find a trough.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(2^{n/2} * n)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(2^{n/2} * n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        int n = nums.size() / 2;\\n        vector<int> l1(n), l2(n);\\n        for (int i = 0; i < n; i++) {\\n            l1[i] = nums[i];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            l2[i] = nums[i + n];\\n        }\\n        map<int, vector<int>> sums1, sums2;\\n        populateSums(sums1, l1);\\n        populateSums(sums2, l2);\\n        int mn = 1e9;\\n        for (auto &it : sums1) {\\n            for (auto &a : it.second) {\\n                if (sums2.count(n - it.first) == 0) break;\\n                vector<int> &vec = sums2[n - it.first];\\n                int l = 0, r = vec.size() - 1;\\n                while (l <= r) {\\n                    int mid = l + (r - l) / 2;\\n                    int s = abs(sum - 2*(a + vec[mid]));\\n                    int s_l = mid - 1 >= 0 ? abs(sum - 2*(a + vec[mid - 1])) : 1e9;\\n                    int s_r = mid + 1 < vec.size() ? abs(sum - 2*(a + vec[mid + 1])) : 1e9;\\n                    if (s_l > s) {\\n                        mn = min(mn, s);\\n                        l = mid + 1;\\n                    } else {\\n                        r = mid - 1;\\n                    }\\n                }\\n            }\\n        }\\n        return mn;\\n    }\\nprivate:\\n    void populateSums (map<int, vector<int>> &sums, vector<int> &l) {\\n        int n = l.size();\\n        for (int mask = 0; mask < (1 << n); mask++) {\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                if ((mask >> i) & 1) {\\n                    sum += l[i];\\n                }\\n            }\\n            sums[__builtin_popcount(mask)].push_back(sum);\\n        }\\n        for (auto &it: sums) {\\n            vector<int> &v = it.second;\\n            sort(v.begin(), v.end());\\n            v.resize(unique(v.begin(), v.end()) - v.begin());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        int n = nums.size() / 2;\\n        vector<int> l1(n), l2(n);\\n        for (int i = 0; i < n; i++) {\\n            l1[i] = nums[i];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            l2[i] = nums[i + n];\\n        }\\n        map<int, vector<int>> sums1, sums2;\\n        populateSums(sums1, l1);\\n        populateSums(sums2, l2);\\n        int mn = 1e9;\\n        for (auto &it : sums1) {\\n            for (auto &a : it.second) {\\n                if (sums2.count(n - it.first) == 0) break;\\n                vector<int> &vec = sums2[n - it.first];\\n                int l = 0, r = vec.size() - 1;\\n                while (l <= r) {\\n                    int mid = l + (r - l) / 2;\\n                    int s = abs(sum - 2*(a + vec[mid]));\\n                    int s_l = mid - 1 >= 0 ? abs(sum - 2*(a + vec[mid - 1])) : 1e9;\\n                    int s_r = mid + 1 < vec.size() ? abs(sum - 2*(a + vec[mid + 1])) : 1e9;\\n                    if (s_l > s) {\\n                        mn = min(mn, s);\\n                        l = mid + 1;\\n                    } else {\\n                        r = mid - 1;\\n                    }\\n                }\\n            }\\n        }\\n        return mn;\\n    }\\nprivate:\\n    void populateSums (map<int, vector<int>> &sums, vector<int> &l) {\\n        int n = l.size();\\n        for (int mask = 0; mask < (1 << n); mask++) {\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                if ((mask >> i) & 1) {\\n                    sum += l[i];\\n                }\\n            }\\n            sums[__builtin_popcount(mask)].push_back(sum);\\n        }\\n        for (auto &it: sums) {\\n            vector<int> &v = it.second;\\n            sort(v.begin(), v.end());\\n            v.resize(unique(v.begin(), v.end()) - v.begin());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441240,
                "title": "c-solution-partition-array-into-two-arrays-to-minimize-sum-difference",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution algorithm uses a recursive branching approach (dfs) to generate all possible subsets of a given set of integers nums. When generating subsets, the sum of elements is calculated and stored in the corresponding arrays s1 and s2. Then the required sums are sorted in the array s2, and then the minimum difference between the sums of elements in subsets A and B is searched. For this, all possible combinations of subsets A and B are searched, taking into account the restriction on the number of elements in each subset (no more than n/4, where n is the number of elements in the set nums). For each combination of subsets A and B, the sum of the elements in each of them is calculated and the difference between them is calculated. It then finds the value in array s2 closest to half the difference between the sums of the elements in A and B, and calculates the absolute difference between the found value and half the difference between the sums of the elements in A and B. From all the absolute differences, the minimum value is selected and returned as a result.\\n\\nThe general idea of the algorithm is to enumerate all possible combinations of subsets A and B and find the closest value in the array s2. This allows us to solve the problem in O(2^(n/2) * n * log(n)) time, where n is the number of elements in the set nums.\\n# Complexity\\n- Time complexity: O(2^(n/2) * n * log(n))\\n- Space complexity: O(n/4)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        const int half_size = nums.size() / 2;\\n        const int quarter_size = nums.size() / 4;\\n        vector<vector<int>> s1(quarter_size + 1); \\n        vector<vector<int>> s2(quarter_size + 1);\\n        dfs(nums, 0, half_size, 0, 0, s1);\\n        dfs(nums, half_size, nums.size(), 0, 0, s2);\\n       \\n        return countDiff(\\n            s1, \\n            s2, \\n            quarter_size, \\n            accumulate(nums.begin(), nums.begin() + half_size, 0), \\n            accumulate(nums.begin() + half_size, nums.end(), 0));\\n    }\\n\\n    inline int countDiff(vector<vector<int>> s1, \\n                         vector<vector<int>> s2, \\n                         int quarter_size, \\n                         const int sum1, \\n                         const int sum2) \\n    {\\n        int min_diff = 0x7fffffff;\\n        for (int k = 0; k <= quarter_size; ++k)\\n        {\\n            sort(s2[k].begin(), s2[k].end());\\n            for (int s1_sum : s1[k])\\n            {\\n                int conn = (sum1 + sum2) / 2 - (sum1 - s1_sum);\\n                auto it = lower_bound(s2[k].begin(), s2[k].end(), conn);\\n                int diff = (sum1 - sum2 - 2 * s1_sum);\\n                int absolute_diff = getMinDiff(s2[k], diff, it);          \\n                min_diff = min(min_diff, absolute_diff);\\n            }\\n        }\\n\\n        return min_diff;\\n    }\\n\\n    inline int getMinDiff(const vector<int>& s2_k, \\n                          int diff, \\n                          vector<int>::iterator& it_value)\\n    {\\n        int min_diff = 0x7fffffff;\\n        if (!(it_value != s2_k.end() || it_value != s2_k.begin())) {\\n            return min_diff;\\n        }\\n        else\\n        {\\n            if (it_value != s2_k.end()) {\\n                min_diff = min(min_diff, abs(diff + (*it_value) * 2));\\n            }\\n            if (it_value != s2_k.begin()) {\\n                min_diff = min(min_diff, abs(diff + (*(--it_value)) * 2));\\n            }\\n            return min_diff;\\n        }\\n    }\\n\\n\\n    void dfs(vector<int>& nums, int i, int end, int k, int sum, vector<vector<int>>& sums) {\\n        if (i != end && k < nums.size() / 4) {\\n            dfs(nums, i + 1, end, k, sum, sums);\\n            dfs(nums, i + 1, end, k + 1, sum + nums[i], sums);\\n        }\\n        else {\\n            sums[k].push_back(sum);\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        const int half_size = nums.size() / 2;\\n        const int quarter_size = nums.size() / 4;\\n        vector<vector<int>> s1(quarter_size + 1); \\n        vector<vector<int>> s2(quarter_size + 1);\\n        dfs(nums, 0, half_size, 0, 0, s1);\\n        dfs(nums, half_size, nums.size(), 0, 0, s2);\\n       \\n        return countDiff(\\n            s1, \\n            s2, \\n            quarter_size, \\n            accumulate(nums.begin(), nums.begin() + half_size, 0), \\n            accumulate(nums.begin() + half_size, nums.end(), 0));\\n    }\\n\\n    inline int countDiff(vector<vector<int>> s1, \\n                         vector<vector<int>> s2, \\n                         int quarter_size, \\n                         const int sum1, \\n                         const int sum2) \\n    {\\n        int min_diff = 0x7fffffff;\\n        for (int k = 0; k <= quarter_size; ++k)\\n        {\\n            sort(s2[k].begin(), s2[k].end());\\n            for (int s1_sum : s1[k])\\n            {\\n                int conn = (sum1 + sum2) / 2 - (sum1 - s1_sum);\\n                auto it = lower_bound(s2[k].begin(), s2[k].end(), conn);\\n                int diff = (sum1 - sum2 - 2 * s1_sum);\\n                int absolute_diff = getMinDiff(s2[k], diff, it);          \\n                min_diff = min(min_diff, absolute_diff);\\n            }\\n        }\\n\\n        return min_diff;\\n    }\\n\\n    inline int getMinDiff(const vector<int>& s2_k, \\n                          int diff, \\n                          vector<int>::iterator& it_value)\\n    {\\n        int min_diff = 0x7fffffff;\\n        if (!(it_value != s2_k.end() || it_value != s2_k.begin())) {\\n            return min_diff;\\n        }\\n        else\\n        {\\n            if (it_value != s2_k.end()) {\\n                min_diff = min(min_diff, abs(diff + (*it_value) * 2));\\n            }\\n            if (it_value != s2_k.begin()) {\\n                min_diff = min(min_diff, abs(diff + (*(--it_value)) * 2));\\n            }\\n            return min_diff;\\n        }\\n    }\\n\\n\\n    void dfs(vector<int>& nums, int i, int end, int k, int sum, vector<vector<int>>& sums) {\\n        if (i != end && k < nums.size() / 4) {\\n            dfs(nums, i + 1, end, k, sum, sums);\\n            dfs(nums, i + 1, end, k + 1, sum + nums[i], sums);\\n        }\\n        else {\\n            sums[k].push_back(sum);\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186666,
                "title": "meet-in-middle-binary-search",
                "content": "# Approach\\nA natural approach to solving this problem is to compute all partitions and determine the minimum absolute difference. This approach takes $O(2^n)$ time, which gets TLE. The time complexity can be reduced to $O(2^{n / 2})$ by partitioning the initial array into two arbitrary arrays of length $n / 2$. Then, the sum of all elements in all subsets $n / 2 \\\\choose k$, $0 < k \\\\leq n / 2$, i.e. $\\\\sum_{k = 0}^{n / 2}$ $ n / 2 \\\\choose k$ $ = 2^{n / 2} = O(2^{n / 2})$, of each partition is computed and the minimum sum difference is computed. \\n\\n# Code\\n```\\nclass Solution {\\n\\n    void computeSums(vector<int> & inSet, int k, int i, vector<int> & outSet, vector<int> & sums) {\\n\\n        int n = inSet.size();\\n\\n        if(outSet.size() == k) {\\n            int sum = 0;\\n            for(auto e : outSet)\\n                sum += e;\\n            sums.push_back(sum);\\n            return;\\n        }\\n\\n        if(i > n - 1)\\n            return;\\n\\n        outSet.push_back(inSet[i]);\\n        computeSums(inSet, k, i + 1, outSet, sums);\\n        outSet.pop_back();\\n        computeSums(inSet, k, i + 1, outSet, sums);\\n    }    \\n\\n    int binSearch(vector<int> & arr, int i, int j, int target) {\\n\\n        int res = 0;\\n\\n        int m = (i + j) / 2;\\n\\n        if(i == j)\\n            return target + 2 * arr[i];\\n\\n        if(2 * arr[m] >= -target) \\n            res = binSearch(arr, i, m, target);\\n        if(2 * arr[m] < -target) \\n            res = binSearch(arr, m + 1, j, target);\\n\\n        return res;\\n    }\\n\\npublic:\\n    int minimumDifference(vector<int> & nums) {\\n\\n        int n = nums.size();\\n\\n        vector<int> left(n / 2);\\n        vector<int> right(n / 2);\\n\\n        int totSum = 0;\\n\\n        // Partition input nums into two arrays of size n / 2\\n        for(int i = 1; i <= n; i++) {\\n            totSum += nums[i - 1];\\n            if(i <= n / 2)\\n                left[i - 1] = nums[i - 1];\\n            else\\n                right[i - n / 2 - 1] = nums[i - 1];\\n        } \\n\\n        // Compute subset sums and determine minimum sum difference\\n        int minD = INT_MAX;\\n\\n        for(int i = 1; i <= n / 2; i++) {\\n            vector<int> outSet;\\n            vector<int> leftSums;\\n            vector<int> rightSums;\\n\\n            computeSums(left, i, 0, outSet, leftSums);\\n            computeSums(right, n / 2 - i, 0, outSet, rightSums);\\n\\n            sort(leftSums.begin(), leftSums.end());\\n            sort(rightSums.begin(), rightSums.end());\\n\\n            for(auto sum : leftSums) {\\n                int minSum = binSearch(rightSums, 0, rightSums.size() - 1, (2 * sum - totSum));\\n\\n                minD = min(minD, abs(minSum));\\n            }\\n        } \\n\\n        return minD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    void computeSums(vector<int> & inSet, int k, int i, vector<int> & outSet, vector<int> & sums) {\\n\\n        int n = inSet.size();\\n\\n        if(outSet.size() == k) {\\n            int sum = 0;\\n            for(auto e : outSet)\\n                sum += e;\\n            sums.push_back(sum);\\n            return;\\n        }\\n\\n        if(i > n - 1)\\n            return;\\n\\n        outSet.push_back(inSet[i]);\\n        computeSums(inSet, k, i + 1, outSet, sums);\\n        outSet.pop_back();\\n        computeSums(inSet, k, i + 1, outSet, sums);\\n    }    \\n\\n    int binSearch(vector<int> & arr, int i, int j, int target) {\\n\\n        int res = 0;\\n\\n        int m = (i + j) / 2;\\n\\n        if(i == j)\\n            return target + 2 * arr[i];\\n\\n        if(2 * arr[m] >= -target) \\n            res = binSearch(arr, i, m, target);\\n        if(2 * arr[m] < -target) \\n            res = binSearch(arr, m + 1, j, target);\\n\\n        return res;\\n    }\\n\\npublic:\\n    int minimumDifference(vector<int> & nums) {\\n\\n        int n = nums.size();\\n\\n        vector<int> left(n / 2);\\n        vector<int> right(n / 2);\\n\\n        int totSum = 0;\\n\\n        // Partition input nums into two arrays of size n / 2\\n        for(int i = 1; i <= n; i++) {\\n            totSum += nums[i - 1];\\n            if(i <= n / 2)\\n                left[i - 1] = nums[i - 1];\\n            else\\n                right[i - n / 2 - 1] = nums[i - 1];\\n        } \\n\\n        // Compute subset sums and determine minimum sum difference\\n        int minD = INT_MAX;\\n\\n        for(int i = 1; i <= n / 2; i++) {\\n            vector<int> outSet;\\n            vector<int> leftSums;\\n            vector<int> rightSums;\\n\\n            computeSums(left, i, 0, outSet, leftSums);\\n            computeSums(right, n / 2 - i, 0, outSet, rightSums);\\n\\n            sort(leftSums.begin(), leftSums.end());\\n            sort(rightSums.begin(), rightSums.end());\\n\\n            for(auto sum : leftSums) {\\n                int minSum = binSearch(rightSums, 0, rightSums.size() - 1, (2 * sum - totSum));\\n\\n                minD = min(minD, abs(minSum));\\n            }\\n        } \\n\\n        return minD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131322,
                "title": "100-0ms-java-solution",
                "content": "# Code\\n```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        if (n == 2) return Math.abs(nums[1] - nums[0]);       \\n        int[][] lists1 = generate(Arrays.copyOfRange(nums, 0, n / 2));\\n        int[][] lists2 = generate(Arrays.copyOfRange(nums, n / 2, n));\\n        int ans = Integer.MAX_VALUE;\\n        for (int d = 0; d <= n / 2; d++) {\\n            int[] arr1 = lists1[d], arr2 = lists2[d];\\n            int k = arr1.length;\\n            int i1 = 0, i2 = 0; // we use two pointers to find two elements in arr1, arr2 with minimum absolute difference\\n            while (i1 < k && i2 < k) {\\n                int diff = arr1[i1] - arr2[i2];\\n                ans = Math.min(ans, Math.abs(diff));\\n                if (diff <= 0) i1++;\\n                if (diff >= 0) i2++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private static int[][] generate(int[] nums) {\\n        int n = nums.length;\\n        int total = 0;\\n        for (int num : nums) total += num;\\n        int[][] ans = new int[n + 1][];\\n        int[] pos = new int[n + 1];\\n        for (int i = 0, binomial = 1; i <= n; i++) {\\n            ans[i] = new int[binomial]; // number of ways to choose i from n = binomial(i,n)\\n            binomial = binomial * (n - i) / (i + 1);\\n        }\\n        int maxValue = 1 << n;\\n        for (int key = 0; key < maxValue; key++) {\\n            int sum1 = 0;\\n            for (int i = 0; i < n; i++) {\\n                if ((key >> i & 1) == 1) sum1 += nums[i];\\n            }\\n            int sum2 = total - sum1;\\n            int bits = Integer.bitCount(key);\\n            ans[bits][pos[bits]++] = sum1 - sum2;\\n        }\\n        for (int[] arr : ans) Arrays.sort(arr);\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        if (n == 2) return Math.abs(nums[1] - nums[0]);       \\n        int[][] lists1 = generate(Arrays.copyOfRange(nums, 0, n / 2));\\n        int[][] lists2 = generate(Arrays.copyOfRange(nums, n / 2, n));\\n        int ans = Integer.MAX_VALUE;\\n        for (int d = 0; d <= n / 2; d++) {\\n            int[] arr1 = lists1[d], arr2 = lists2[d];\\n            int k = arr1.length;\\n            int i1 = 0, i2 = 0; // we use two pointers to find two elements in arr1, arr2 with minimum absolute difference\\n            while (i1 < k && i2 < k) {\\n                int diff = arr1[i1] - arr2[i2];\\n                ans = Math.min(ans, Math.abs(diff));\\n                if (diff <= 0) i1++;\\n                if (diff >= 0) i2++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private static int[][] generate(int[] nums) {\\n        int n = nums.length;\\n        int total = 0;\\n        for (int num : nums) total += num;\\n        int[][] ans = new int[n + 1][];\\n        int[] pos = new int[n + 1];\\n        for (int i = 0, binomial = 1; i <= n; i++) {\\n            ans[i] = new int[binomial]; // number of ways to choose i from n = binomial(i,n)\\n            binomial = binomial * (n - i) / (i + 1);\\n        }\\n        int maxValue = 1 << n;\\n        for (int key = 0; key < maxValue; key++) {\\n            int sum1 = 0;\\n            for (int i = 0; i < n; i++) {\\n                if ((key >> i & 1) == 1) sum1 += nums[i];\\n            }\\n            int sum2 = total - sum1;\\n            int bits = Integer.bitCount(key);\\n            ans[bits][pos[bits]++] = sum1 - sum2;\\n        }\\n        for (int[] arr : ans) Arrays.sort(arr);\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039358,
                "title": "meet-in-the-middle-trinary-search-bitmasking",
                "content": "# Complexity\\n- Time complexity: $$O(n.2^{n/2})$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2^{n/2})$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define pb push_back\\nusing ll = long long;\\nconst int inf = 1e12;\\n\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& a) {\\n        int n = a.size() / 2;\\n        vector<ll> left[n+1], right[n+1];\\n        for(int m=0;m<(1<<n);m++){\\n            int bC = __builtin_popcount(m);\\n            ll sL = 0, sR = 0;\\n            for(int i=0;i<n;i++){\\n                if(m & (1<<i)){\\n                    sL += a[i];\\n                    sR += a[i+n];\\n                }else{\\n                    sL -= a[i];\\n                    sR -= a[i+n];\\n                }\\n            }\\n            left[bC].pb(sL);\\n            right[bC].pb(sR);\\n        }\\n        ll mia = inf;\\n        for(int i=0;i<=n;i++){\\n            sort(left[i].begin(), left[i].end());\\n            sort(right[i].begin(), right[i].end());\\n        }\\n        for(int i=0;i<=n;i++){\\n            for(auto e: left[i]){\\n                ll tmi = inf;\\n                int l = 0, r = right[n-i].size() - 1;\\n                while((r-l)>=3){\\n                    int m1 = l + (r-l)/3;\\n                    int m2 = r - (r-l)/3;\\n                    if(abs(right[n-i][m1]+e) < abs(right[n-i][m2]+e)){\\n                        r = m2;\\n                    }else l = m1;\\n                }\\n                for(int k=l;k<=r;k++){\\n                    tmi = min(tmi, abs(e+right[n-i][k]));\\n                }\\n                mia = min(mia, tmi);\\n            }\\n        }\\n        return mia;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\n#define pb push_back\\nusing ll = long long;\\nconst int inf = 1e12;\\n\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& a) {\\n        int n = a.size() / 2;\\n        vector<ll> left[n+1], right[n+1];\\n        for(int m=0;m<(1<<n);m++){\\n            int bC = __builtin_popcount(m);\\n            ll sL = 0, sR = 0;\\n            for(int i=0;i<n;i++){\\n                if(m & (1<<i)){\\n                    sL += a[i];\\n                    sR += a[i+n];\\n                }else{\\n                    sL -= a[i];\\n                    sR -= a[i+n];\\n                }\\n            }\\n            left[bC].pb(sL);\\n            right[bC].pb(sR);\\n        }\\n        ll mia = inf;\\n        for(int i=0;i<=n;i++){\\n            sort(left[i].begin(), left[i].end());\\n            sort(right[i].begin(), right[i].end());\\n        }\\n        for(int i=0;i<=n;i++){\\n            for(auto e: left[i]){\\n                ll tmi = inf;\\n                int l = 0, r = right[n-i].size() - 1;\\n                while((r-l)>=3){\\n                    int m1 = l + (r-l)/3;\\n                    int m2 = r - (r-l)/3;\\n                    if(abs(right[n-i][m1]+e) < abs(right[n-i][m2]+e)){\\n                        r = m2;\\n                    }else l = m1;\\n                }\\n                for(int k=l;k<=r;k++){\\n                    tmi = min(tmi, abs(e+right[n-i][k]));\\n                }\\n                mia = min(mia, tmi);\\n            }\\n        }\\n        return mia;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903868,
                "title": "meet-in-the-middle-tabulation-failed-dp-c-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolving Via Meet in the Middle Algorithm.\\nWhy not tabulation?\\nTabulation Failed because of Negative Integer\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMeet in the Middle: \\u2705\\n\\n1) Out of N length array, we first partition it as left and right arrays each of N/2 length.\\n2) Why? Because it works somewhat like divide and conquer technique.\\n\\n# Code\\nclass Solution {\\npublic:\\n    vector<vector<int>> findAllSubsetsSum(vector<int>& nums, int l, int r) {\\n    int totLengthOfSubarray = r - l + 1;\\n    vector<vector<int>> res(totLengthOfSubarray + 1);\\n    for (int i = 0; i < (1 << totLengthOfSubarray); i++) {\\n        int sum = 0, countOfChosenNos = 0;\\n        for (int j = 0; j < totLengthOfSubarray; j++) {\\n            if (i & (1 << j)) {\\n                sum += nums[l + j];\\n                countOfChosenNos++;\\n            }\\n        }\\n        res[countOfChosenNos].push_back(sum);\\n    }\\n    return res;\\n}\\n\\n    int minimumDifference(vector<int>& nums) {\\n    int totalSum = accumulate(nums.begin(), nums.end(), 0);\\n    int n = nums.size();\\n\\n    auto left = findAllSubsetsSum(nums, 0, n / 2 - 1);\\n    auto right = findAllSubsetsSum(nums, n / 2, n - 1);\\n    int target = totalSum / 2, ans = INT_MAX;\\n\\n    //we can take (0 to n/2) length numbers from left\\n    for (int i = 0; i <= n / 2; i++) {\\n        //now we take rest - (n/2-i) length from right, we sort it to binary search\\n        auto r = right[n / 2 - i];\\n        sort(begin(r), end(r));\\n\\n        for (int curleftSum : left[i]) {\\n            int needSumFromRight = target - curleftSum;\\n            auto it = lower_bound(r.begin(), r.end(), needSumFromRight);\\n            if (it != end(r))\\n                ans = min(ans, abs(totalSum - 2 * (curleftSum + *it)));\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> findAllSubsetsSum(vector<int>& nums, int l, int r) {\\n    int totLengthOfSubarray = r - l + 1;\\n    vector<vector<int>> res(totLengthOfSubarray + 1);\\n    for (int i = 0; i < (1 << totLengthOfSubarray); i++) {\\n        int sum = 0, countOfChosenNos = 0;\\n        for (int j = 0; j < totLengthOfSubarray; j++) {\\n            if (i & (1 << j)) {\\n                sum += nums[l + j];\\n                countOfChosenNos++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2850241,
                "title": "code-with-explanation",
                "content": "\\n\\n# Code\\n```\\n/*\\nAlgorithm\\n\\nHigh Level Approach:\\n\\n*  We divide the input array into two arbitary parts. \\n*  Then, We take one subset from each part, such that, sum of size of both subset = n. \\n*  And with that subset we try to minimise the absolute difference.\\nDetailed:\\n\\nDivide the original array in two arbitary parts, each of size n. LeftPart: [0, n-1], RightPart[n,2 * n-1]\\nFind all possible sums in each part.\\nAs each part will be of size <= 15\\nWe can safely enumerate all possible sums in each part.\\nFor each part, store the sum of a subset along with the size of the subset.\\nIn Code:\\nI have used two 2-D vectors, left and right, to store sums of all possible subset.\\nLeft[ i ]: stores all possible sums of the subset of size i, in the left part.\\nSimilarly, for right part.\\nRequirement: We need to divide the original array in two parts of size n, each. Such that the absolute difference of sum is minimised.\\nLet say from left part we take a subset of size sz (Let\\'s say its sum is a), then from right part we need to take a subset of size of n-sz (Let\\'s say its sum is b). Then, Part1Sum = a+b.\\nWe have to minimise abs(Part1Sum - Part2Sum)\\nNow, Part1Sum = a+b and Part2Sum = TotalSum - (a+b)\\nThus we have to minimise, abs(TotalSum -2 a - 2 b)\\nNow we iterate over a, and binary search b in the vector right\\nTC\\nO(2^n * log(2^n))\\n\\nThis technique commonly known as Meet In Middle. Commonly used when 25 <= array_size <= 40\\n\\nUPD1 : Used vector instead of sets, code is almost 50% faster than before.\\n\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size(), res = 0, sum = 0;\\n        sum = accumulate(nums.begin(), nums.end(),0);\\n        \\n        int N = n/2;\\n        vector<vector<int>> left(N+1), right(N+1);\\n        \\n\\t\\t//storing all possible sum in left and right part\\n        for(int mask = 0; mask<(1<<N); ++mask){\\n            int sz = 0, l = 0, r = 0;\\n            for(int i=0; i<N; ++i){\\n                if(mask&(1<<i)){\\n                    sz++;\\n                    l += nums[i];\\n                    r += nums[i+N];\\n                }\\n            }\\n            left[sz].push_back(l);\\n            right[sz].push_back(r);\\n        }\\n\\n        for(int sz=0; sz<=N; ++sz){\\n            sort(right[sz].begin(), right[sz].end());\\n        }\\n\\n        res = min(abs(sum-2*left[N][0]), abs(sum-2*right[N][0]));\\n\\n\\t\\t//iterating over left part\\n        for(int sz=1; sz<N; ++sz){\\n            for(auto &a : left[sz]){\\n                int b = (sum - 2*a)/2, rsz = N-sz;\\n                auto &v = right[rsz];\\n                auto itr = lower_bound(v.begin(), v.end(),b); //binary search over right part\\n                \\n                if(itr!=v.end()) res = min(res, abs(sum-2*(a+(*itr))));\\n                if(itr!= v.begin()){\\n                    auto it = itr; --it;\\n                    res = min(res, abs(sum-2*(a+(*it))));\\n                }                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n*/\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size(), res = 0, sum = 0;\\n        sum = accumulate(nums.begin(), nums.end(),0);\\n        \\n        int N = n/2;\\n        vector<vector<int>> left(N+1), right(N+1);\\n        \\n\\t\\t//storing all possible sum in left and right part\\n        for(int mask = 0; mask<(1<<N); ++mask){\\n            int sz = 0, l = 0, r = 0;\\n            for(int i=0; i<N; ++i){\\n                if(mask&(1<<i)){\\n                    sz++;\\n                    l += nums[i];\\n                    r += nums[i+N];\\n                }\\n            }\\n            left[sz].push_back(l);\\n            right[sz].push_back(r);\\n        }\\n\\n        for(int sz=0; sz<=N; ++sz){\\n            sort(right[sz].begin(), right[sz].end());\\n        }\\n\\n        res = min(abs(sum-2*left[N][0]), abs(sum-2*right[N][0]));\\n\\n\\t\\t//iterating over left part\\n        for(int sz=1; sz<N; ++sz){\\n            for(auto &a : left[sz]){\\n                int b = (sum - 2*a)/2, rsz = N-sz;\\n                auto &v = right[rsz];\\n                auto itr = lower_bound(v.begin(), v.end(),b); //binary search over right part\\n                \\n                if(itr!=v.end()) res = min(res, abs(sum-2*(a+(*itr))));\\n                if(itr!= v.begin()){\\n                    auto it = itr; --it;\\n                    res = min(res, abs(sum-2*(a+(*it))));\\n                }                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nAlgorithm\\n\\nHigh Level Approach:\\n\\n*  We divide the input array into two arbitary parts. \\n*  Then, We take one subset from each part, such that, sum of size of both subset = n. \\n*  And with that subset we try to minimise the absolute difference.\\nDetailed:\\n\\nDivide the original array in two arbitary parts, each of size n. LeftPart: [0, n-1], RightPart[n,2 * n-1]\\nFind all possible sums in each part.\\nAs each part will be of size <= 15\\nWe can safely enumerate all possible sums in each part.\\nFor each part, store the sum of a subset along with the size of the subset.\\nIn Code:\\nI have used two 2-D vectors, left and right, to store sums of all possible subset.\\nLeft[ i ]: stores all possible sums of the subset of size i, in the left part.\\nSimilarly, for right part.\\nRequirement: We need to divide the original array in two parts of size n, each. Such that the absolute difference of sum is minimised.\\nLet say from left part we take a subset of size sz (Let\\'s say its sum is a), then from right part we need to take a subset of size of n-sz (Let\\'s say its sum is b). Then, Part1Sum = a+b.\\nWe have to minimise abs(Part1Sum - Part2Sum)\\nNow, Part1Sum = a+b and Part2Sum = TotalSum - (a+b)\\nThus we have to minimise, abs(TotalSum -2 a - 2 b)\\nNow we iterate over a, and binary search b in the vector right\\nTC\\nO(2^n * log(2^n))\\n\\nThis technique commonly known as Meet In Middle. Commonly used when 25 <= array_size <= 40\\n\\nUPD1 : Used vector instead of sets, code is almost 50% faster than before.\\n\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size(), res = 0, sum = 0;\\n        sum = accumulate(nums.begin(), nums.end(),0);\\n        \\n        int N = n/2;\\n        vector<vector<int>> left(N+1), right(N+1);\\n        \\n\\t\\t//storing all possible sum in left and right part\\n        for(int mask = 0; mask<(1<<N); ++mask){\\n            int sz = 0, l = 0, r = 0;\\n            for(int i=0; i<N; ++i){\\n                if(mask&(1<<i)){\\n                    sz++;\\n                    l += nums[i];\\n                    r += nums[i+N];\\n                }\\n            }\\n            left[sz].push_back(l);\\n            right[sz].push_back(r);\\n        }\\n\\n        for(int sz=0; sz<=N; ++sz){\\n            sort(right[sz].begin(), right[sz].end());\\n        }\\n\\n        res = min(abs(sum-2*left[N][0]), abs(sum-2*right[N][0]));\\n\\n\\t\\t//iterating over left part\\n        for(int sz=1; sz<N; ++sz){\\n            for(auto &a : left[sz]){\\n                int b = (sum - 2*a)/2, rsz = N-sz;\\n                auto &v = right[rsz];\\n                auto itr = lower_bound(v.begin(), v.end(),b); //binary search over right part\\n                \\n                if(itr!=v.end()) res = min(res, abs(sum-2*(a+(*itr))));\\n                if(itr!= v.begin()){\\n                    auto it = itr; --it;\\n                    res = min(res, abs(sum-2*(a+(*it))));\\n                }                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n*/\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size(), res = 0, sum = 0;\\n        sum = accumulate(nums.begin(), nums.end(),0);\\n        \\n        int N = n/2;\\n        vector<vector<int>> left(N+1), right(N+1);\\n        \\n\\t\\t//storing all possible sum in left and right part\\n        for(int mask = 0; mask<(1<<N); ++mask){\\n            int sz = 0, l = 0, r = 0;\\n            for(int i=0; i<N; ++i){\\n                if(mask&(1<<i)){\\n                    sz++;\\n                    l += nums[i];\\n                    r += nums[i+N];\\n                }\\n            }\\n            left[sz].push_back(l);\\n            right[sz].push_back(r);\\n        }\\n\\n        for(int sz=0; sz<=N; ++sz){\\n            sort(right[sz].begin(), right[sz].end());\\n        }\\n\\n        res = min(abs(sum-2*left[N][0]), abs(sum-2*right[N][0]));\\n\\n\\t\\t//iterating over left part\\n        for(int sz=1; sz<N; ++sz){\\n            for(auto &a : left[sz]){\\n                int b = (sum - 2*a)/2, rsz = N-sz;\\n                auto &v = right[rsz];\\n                auto itr = lower_bound(v.begin(), v.end(),b); //binary search over right part\\n                \\n                if(itr!=v.end()) res = min(res, abs(sum-2*(a+(*itr))));\\n                if(itr!= v.begin()){\\n                    auto it = itr; --it;\\n                    res = min(res, abs(sum-2*(a+(*it))));\\n                }                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729823,
                "title": "meet-in-the-middle-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> a, b;\\n        vector<vector<long long int>> dp1(40), dp2(40);\\n        long long int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i < n / 2)\\n                a.push_back(nums[i]), sum1 += nums[i];\\n            else\\n                b.push_back(nums[i]), sum2 += nums[i];\\n        }\\n        n = n / 2;\\n        unordered_map<long long int, int> m1, m2;\\n        vector<long long int> v1, v2;\\n        for (int i = 0; i < (int)(1 << n); i++)\\n        {\\n            long long int sum1 = 0, sum2 = 0;\\n            int sets = 0;\\n            for (int j = 0; j < n; j++)\\n            {\\n                if ((i & (1 << j))){\\n                    sets++;\\n                    sum1 += a[j];\\n                }\\n            }\\n            dp1[sets].push_back(sum1);\\n        }\\n        for (int i = 0; i < (int)(1 << n); i++)\\n        {\\n            long long int sum2 = 0, sum1 = 0;\\n            int sets = 0;\\n            for (int j = 0; j < n; j++)\\n            {\\n                if ((i & (1 << j))){\\n                    sets++;\\n                    sum1 += b[j];\\n                }\\n            }\\n            dp2[sets].push_back(sum1);\\n        }\\n       long long int ans = LLONG_MAX;\\n       for(int i = 0; i <= n; i++)\\n       {\\n           int sets = i;\\n           int nonsets = n - i; \\n           sort(dp2[nonsets].begin(), dp2[nonsets].end());\\n           for(auto i: dp1[sets]){\\n               long long currSum = (sum1 + sum2 - 2 * i) / 2;\\n               int loc = lower_bound(dp2[nonsets].begin(), dp2[nonsets].end(), currSum) \\n               - dp2[nonsets].begin();\\n                if(loc != dp2[nonsets].size())\\n                    ans = min(ans, abs(sum1 + sum2 - 2 * i - 2 * dp2[nonsets][loc]));\\n                if(loc > 0)\\n                    ans = min(ans, abs(sum1 + sum2 - 2 * i - 2 * dp2[nonsets][loc - 1])); \\n                if(loc + 1 < dp2[nonsets].size())\\n                    ans = min(ans, abs(sum1 + sum2 - 2 * i - 2 * dp2[nonsets][loc + 1])); \\n\\n            }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> a, b;\\n        vector<vector<long long int>> dp1(40), dp2(40);\\n        long long int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i < n / 2)\\n                a.push_back(nums[i]), sum1 += nums[i];\\n            else\\n                b.push_back(nums[i]), sum2 += nums[i];\\n        }\\n        n = n / 2;\\n        unordered_map<long long int, int> m1, m2;\\n        vector<long long int> v1, v2;\\n        for (int i = 0; i < (int)(1 << n); i++)\\n        {\\n            long long int sum1 = 0, sum2 = 0;\\n            int sets = 0;\\n            for (int j = 0; j < n; j++)\\n            {\\n                if ((i & (1 << j))){\\n                    sets++;\\n                    sum1 += a[j];\\n                }\\n            }\\n            dp1[sets].push_back(sum1);\\n        }\\n        for (int i = 0; i < (int)(1 << n); i++)\\n        {\\n            long long int sum2 = 0, sum1 = 0;\\n            int sets = 0;\\n            for (int j = 0; j < n; j++)\\n            {\\n                if ((i & (1 << j))){\\n                    sets++;\\n                    sum1 += b[j];\\n                }\\n            }\\n            dp2[sets].push_back(sum1);\\n        }\\n       long long int ans = LLONG_MAX;\\n       for(int i = 0; i <= n; i++)\\n       {\\n           int sets = i;\\n           int nonsets = n - i; \\n           sort(dp2[nonsets].begin(), dp2[nonsets].end());\\n           for(auto i: dp1[sets]){\\n               long long currSum = (sum1 + sum2 - 2 * i) / 2;\\n               int loc = lower_bound(dp2[nonsets].begin(), dp2[nonsets].end(), currSum) \\n               - dp2[nonsets].begin();\\n                if(loc != dp2[nonsets].size())\\n                    ans = min(ans, abs(sum1 + sum2 - 2 * i - 2 * dp2[nonsets][loc]));\\n                if(loc > 0)\\n                    ans = min(ans, abs(sum1 + sum2 - 2 * i - 2 * dp2[nonsets][loc - 1])); \\n                if(loc + 1 < dp2[nonsets].size())\\n                    ans = min(ans, abs(sum1 + sum2 - 2 * i - 2 * dp2[nonsets][loc + 1])); \\n\\n            }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620175,
                "title": "90-fast-c-solution-split-the-array-and-then-binary-search",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid find(int i,int n,int count,int sum,vector<int>& nums,vector<vector<int>>& a)\\n\\t\\t{\\n\\t\\t\\tif(i==n)\\n\\t\\t\\t{\\n\\t\\t\\t\\ta[count].push_back(sum);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tfind(i+1,n,count,sum,nums,a);\\n\\t\\t\\tfind(i+1,n,count+1,sum+nums[i],nums,a);\\n\\t\\t}\\n\\t\\tint minimumDifference(vector<int>& nums) {\\n\\t\\t\\tvector<int> nums1,nums2;\\n\\t\\t\\tint n = nums.size()/2;\\n\\t\\t\\tlong long sum=0;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnums1.push_back(nums[i]);\\n\\t\\t\\t\\tnums2.push_back(nums[i+n]);\\n\\t\\t\\t\\tsum+=nums1.back()+nums2.back();\\n\\t\\t\\t}\\n\\t\\t\\tvector<vector<int>> a(n+1,vector<int>());\\n\\t\\t\\tvector<vector<int>> b(n+1,vector<int>());\\n\\n\\t\\t\\tfind(0,n,0,0,nums1,a);\\n\\t\\t\\tfind(0,n,0,0,nums2,b);\\n\\n\\t\\t\\tfor(int i=0;i<=n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsort(a[i].begin(),a[i].end());\\n\\t\\t\\t\\tsort(b[i].begin(),b[i].end());\\n\\t\\t\\t}\\n\\t\\t\\tlong long max_sum = (sum)/2;\\n\\t\\t\\tint ans=INT_MIN;\\n\\t\\t\\tfor(int i=0;i<=n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(auto k:a[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tauto itr=lower_bound(b[n-i].begin(),b[n-i].end(),max_sum-k);\\n\\n\\t\\t\\t\\t\\tif(itr!=b[n-i].end() && *itr==max_sum-k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn ( 2*max_sum==sum ? 0 : 1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(itr==b[n-i].begin())\\n\\t\\t\\t\\t\\t{\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\titr--;\\n\\t\\t\\t\\t\\tans=max(ans,*itr+k);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn abs(sum-ans-ans);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid find(int i,int n,int count,int sum,vector<int>& nums,vector<vector<int>>& a)\\n\\t\\t{\\n\\t\\t\\tif(i==n)\\n\\t\\t\\t{\\n\\t\\t\\t\\ta[count].push_back(sum);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2472123,
                "title": "c-solution-100-working-easy-to-understand",
                "content": "This approach is according to the hints given in the problem description.\\n\\n```\\nclass Solution {\\npublic:\\n    std::function<void (vector<vector<int>>&, int, int, int, int)> dp;\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/2;\\n        // both the 2d array refer to sum of the parts of the first\\n        // half array, one has k elements from left of nums,\\n        // the other part has n-k elements from the right of nums\\n        vector<vector<int>> leftKsums (n+1, vector<int>());\\n        vector<vector<int>> rightKsums (n+1, vector<int>());\\n        \\n        // lambda to recursively calculate all sums\\n        // NOTE: [&] in lamda will capture local variables by reference\\n        // so that we don\\'t need to pass them in the arguments\\n\\t\\t// e.g., \\'n\\' is captured by the lamda from the scope\\n        //\\n        // for each subproblem, we can calculate the sum \\n        // 1. either by taking the current element\\n        // 2. or by skipping the current element\\n        dp = [&] (vector<vector<int>> &Ksums, int sum, int len, int start, int index) {\\n            // the scan is complete\\n            if (index-start >= n) {\\n                // register the sum corresponding to the length\\n                Ksums[len].push_back(sum);\\n                return;\\n            }\\n            \\n            // take the current element and move to the next index\\n            dp(Ksums, sum+nums[index], len+1, start, index+1);\\n            \\n            // skip the current element and move ahead\\n            dp(Ksums, sum, len, start, index+1);\\n        };\\n        \\n        dp(leftKsums, 0, 0, 0, 0);\\n        dp(rightKsums, 0, 0, n, n);\\n        \\n        // the target sum for each half array is total / 2\\n        int total = 0;\\n        int target = 0;\\n        \\n        for (int& num: nums)\\n            total += num;\\n        \\n        target = total / 2;\\n        \\n        // sort the subarray on which binary search (lower_bound) will be performed\\n\\t\\tfor (vector<int>& right: rightKsums)\\n\\t\\t\\tstd::sort(right.begin(), right.end());\\n        \\n        int ans = INT_MAX;\\n        \\n        // loop through all possible sums corresponding to various length k[0... n] on left part\\n        for (int i=0; i<=n; i++) {\\n            // find the closest match on the right part corresponding to length n-k\\n            for (int& leftHalfSum: leftKsums[i]) {\\n                int key = target - leftHalfSum;\\n                std::vector<int>::iterator it = std::lower_bound(rightKsums[n-i].begin(), rightKsums[n-i].end(), key);\\n                if (it == rightKsums[n-i].end())\\n                    it--;\\n                \\n                int rightHalfSum = *it;\\n                // leftSum indicates the sum of the left half array\\n                // same is true for rightSum\\n                int leftSum = leftHalfSum + rightHalfSum;\\n                int rightSum = total - leftSum;\\n                int diff = std::abs(leftSum-rightSum);\\n                \\n\\t\\t\\t\\t// since the minimum absolute difference cannot be\\n\\t\\t\\t\\t// less than zero\\n                if (diff == 0)\\n                    return 0;\\n                \\n                if (diff < ans) \\n                    ans = diff;\\n\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nFeel free to discuss the code in the comments.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    std::function<void (vector<vector<int>>&, int, int, int, int)> dp;\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/2;\\n        // both the 2d array refer to sum of the parts of the first\\n        // half array, one has k elements from left of nums,\\n        // the other part has n-k elements from the right of nums\\n        vector<vector<int>> leftKsums (n+1, vector<int>());\\n        vector<vector<int>> rightKsums (n+1, vector<int>());\\n        \\n        // lambda to recursively calculate all sums\\n        // NOTE: [&] in lamda will capture local variables by reference\\n        // so that we don\\'t need to pass them in the arguments\\n\\t\\t// e.g., \\'n\\' is captured by the lamda from the scope\\n        //\\n        // for each subproblem, we can calculate the sum \\n        // 1. either by taking the current element\\n        // 2. or by skipping the current element\\n        dp = [&] (vector<vector<int>> &Ksums, int sum, int len, int start, int index) {\\n            // the scan is complete\\n            if (index-start >= n) {\\n                // register the sum corresponding to the length\\n                Ksums[len].push_back(sum);\\n                return;\\n            }\\n            \\n            // take the current element and move to the next index\\n            dp(Ksums, sum+nums[index], len+1, start, index+1);\\n            \\n            // skip the current element and move ahead\\n            dp(Ksums, sum, len, start, index+1);\\n        };\\n        \\n        dp(leftKsums, 0, 0, 0, 0);\\n        dp(rightKsums, 0, 0, n, n);\\n        \\n        // the target sum for each half array is total / 2\\n        int total = 0;\\n        int target = 0;\\n        \\n        for (int& num: nums)\\n            total += num;\\n        \\n        target = total / 2;\\n        \\n        // sort the subarray on which binary search (lower_bound) will be performed\\n\\t\\tfor (vector<int>& right: rightKsums)\\n\\t\\t\\tstd::sort(right.begin(), right.end());\\n        \\n        int ans = INT_MAX;\\n        \\n        // loop through all possible sums corresponding to various length k[0... n] on left part\\n        for (int i=0; i<=n; i++) {\\n            // find the closest match on the right part corresponding to length n-k\\n            for (int& leftHalfSum: leftKsums[i]) {\\n                int key = target - leftHalfSum;\\n                std::vector<int>::iterator it = std::lower_bound(rightKsums[n-i].begin(), rightKsums[n-i].end(), key);\\n                if (it == rightKsums[n-i].end())\\n                    it--;\\n                \\n                int rightHalfSum = *it;\\n                // leftSum indicates the sum of the left half array\\n                // same is true for rightSum\\n                int leftSum = leftHalfSum + rightHalfSum;\\n                int rightSum = total - leftSum;\\n                int diff = std::abs(leftSum-rightSum);\\n                \\n\\t\\t\\t\\t// since the minimum absolute difference cannot be\\n\\t\\t\\t\\t// less than zero\\n                if (diff == 0)\\n                    return 0;\\n                \\n                if (diff < ans) \\n                    ans = diff;\\n\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398729,
                "title": "what-is-the-problem-with-my-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int util(int totalSum, int sum, int i, vector<int>& nums){\\n        if(i==0) return abs(totalSum-2*sum);\\n        return min(util(totalSum, sum+nums[i-1],i-1,nums),util(totalSum, sum,i-1,nums));\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        int totalSum = 0;\\n        int n = nums.size();\\n        for(auto i:nums) totalSum += i;\\n        return util(totalSum, 0,n-1,nums);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int util(int totalSum, int sum, int i, vector<int>& nums){\\n        if(i==0) return abs(totalSum-2*sum);\\n        return min(util(totalSum, sum+nums[i-1],i-1,nums),util(totalSum, sum,i-1,nums));\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        int totalSum = 0;\\n        int n = nums.size();\\n        for(auto i:nums) totalSum += i;\\n        return util(totalSum, 0,n-1,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352230,
                "title": "c-simple-o-2-n-faster-than-90",
                "content": "```\\nclass Solution {\\npublic:\\n    void func(int ind, int sum, int count, int n, vector<int> &nums, vector<vector<int>> &a){\\n        if(ind==n)\\n        {\\n            a[count].push_back(sum);\\n            return;\\n        }\\n        func(ind+1, sum, count, n, nums, a);\\n        func(ind+1, sum+nums[ind], count+1, n, nums, a);\\n    }\\n    \\n    int minimumDifference(vector<int>& nums) {\\n        vector<vector<int>> a(nums.size()/2+1), b(nums.size()/2+1);\\n        int total=0, mn=INT_MAX;\\n        for(auto num: nums)\\n            total+=num;\\n        func(0, 0, 0, nums.size()/2, nums, a);\\n        func(nums.size()/2, 0, 0, nums.size(), nums, b);\\n        \\n        for(int i=0; i<=nums.size()/2; i++)\\n            sort(a[i].begin(), a[i].end());\\n\\n        for(int i=0; i<=nums.size()/2; i++)\\n            for(int j=0; j<b[i].size(); j++)\\n            {\\n                auto it=lower_bound(a[nums.size()/2-i].begin(), a[nums.size()/2-i].end(), \\n                                    total/2-b[i][j]);\\n                if(it!=a[nums.size()/2-i].end())\\n                    mn=min(mn, abs(total - 2*(b[i][j]+*it)));\\n                it--;\\n                if(it>=a[nums.size()/2-i].begin())\\n                    mn=min(mn, abs(total - 2*(b[i][j]+*it)));\\n            }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void func(int ind, int sum, int count, int n, vector<int> &nums, vector<vector<int>> &a){\\n        if(ind==n)\\n        {\\n            a[count].push_back(sum);\\n            return;\\n        }\\n        func(ind+1, sum, count, n, nums, a);\\n        func(ind+1, sum+nums[ind], count+1, n, nums, a);\\n    }\\n    \\n    int minimumDifference(vector<int>& nums) {\\n        vector<vector<int>> a(nums.size()/2+1), b(nums.size()/2+1);\\n        int total=0, mn=INT_MAX;\\n        for(auto num: nums)\\n            total+=num;\\n        func(0, 0, 0, nums.size()/2, nums, a);\\n        func(nums.size()/2, 0, 0, nums.size(), nums, b);\\n        \\n        for(int i=0; i<=nums.size()/2; i++)\\n            sort(a[i].begin(), a[i].end());\\n\\n        for(int i=0; i<=nums.size()/2; i++)\\n            for(int j=0; j<b[i].size(); j++)\\n            {\\n                auto it=lower_bound(a[nums.size()/2-i].begin(), a[nums.size()/2-i].end(), \\n                                    total/2-b[i][j]);\\n                if(it!=a[nums.size()/2-i].end())\\n                    mn=min(mn, abs(total - 2*(b[i][j]+*it)));\\n                it--;\\n                if(it>=a[nums.size()/2-i].begin())\\n                    mn=min(mn, abs(total - 2*(b[i][j]+*it)));\\n            }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346227,
                "title": "runtime-1740-ms-memory-usage-17-2-mb",
                "content": "![image](https://assets.leetcode.com/users/images/2df1ee02-daff-4783-9e0f-4879f83406cc_1659018089.9444842.png)\\n**Best possible solution from me *@vimla_kushwaha* .., i hope it\\'ll help you out !!**\\n\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 2;\\n        sum1, sum2 = sum(nums[:n]), sum(nums[n:]);\\n        psum1, psum2 = [{0}], [{0}];\\n        \\n        for ns, ps in zip([nums[:n], nums[n:]], [psum1, psum2]):\\n            for i, x in enumerate(ns):\\n                if len(ps) <= n//2: ps.append({s + x for s in ps[-1]});\\n                \\n                for j in range(len(ps) - 1, 0, -1):\\n                    ps[j] = ps[j].union({s + x for s in ps[j-1]});\\n                    \\n        target = sum1 - sum2;\\n        answer = abs(target);\\n\\n        # 2p1 - 2p2 ~ sum1 - sum2\\n        \\n        for i in range(len(psum1)):\\n            p1, p2 = sorted(list(psum1[i])), sorted(list(psum2[i]));\\n            idx1, idx2 = 0, 0;\\n            len1, len2 = len(p1), len(p2);\\n            \\n            while idx1 < len1 and idx2 < len2:\\n                diff = p1[idx1] - p2[idx2];\\n                offset = 2 * diff - target;\\n                \\n                answer = min(answer, abs(offset));\\n                if offset < 0: idx1 += 1;\\n                else: idx2 += 1;\\n                    \\n        return answer;\\n```\\n\\n**Like this post ... if this helped you out somehow**\\nif you have any suggesstions or wanna ask any question to me .. your most welcome :)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 2;\\n        sum1, sum2 = sum(nums[:n]), sum(nums[n:]);\\n        psum1, psum2 = [{0}], [{0}];\\n        \\n        for ns, ps in zip([nums[:n], nums[n:]], [psum1, psum2]):\\n            for i, x in enumerate(ns):\\n                if len(ps) <= n//2: ps.append({s + x for s in ps[-1]});\\n                \\n                for j in range(len(ps) - 1, 0, -1):\\n                    ps[j] = ps[j].union({s + x for s in ps[j-1]});\\n                    \\n        target = sum1 - sum2;\\n        answer = abs(target);\\n\\n        # 2p1 - 2p2 ~ sum1 - sum2\\n        \\n        for i in range(len(psum1)):\\n            p1, p2 = sorted(list(psum1[i])), sorted(list(psum2[i]));\\n            idx1, idx2 = 0, 0;\\n            len1, len2 = len(p1), len(p2);\\n            \\n            while idx1 < len1 and idx2 < len2:\\n                diff = p1[idx1] - p2[idx2];\\n                offset = 2 * diff - target;\\n                \\n                answer = min(answer, abs(offset));\\n                if offset < 0: idx1 += 1;\\n                else: idx2 += 1;\\n                    \\n        return answer;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328102,
                "title": "python-meet-in-the-middle",
                "content": "```python\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        # abs(s - 2*i)\\n        # i <= s / 2\\n        def f(A):\\n            n = len(A)\\n            a = [set() for _ in range(n+1)]\\n            a[0].add(0)\\n            for i in A:\\n                for j in range(n,0,-1):\\n                    for v in a[j-1]:\\n                        a[j].add(v+i)\\n            return list(map(sorted, a))\\n        s = sum(nums)\\n        n = len(nums)\\n        a = f(nums[:n//2])\\n        b = f(nums[n//2:])\\n        res = float(\\'inf\\')\\n        for i in range(n//2+1):\\n            j = len(b[n//2-i]) - 1\\n            for v in a[i]:\\n                while j >= 0 and v + b[n//2-i][j] > s // 2:\\n                    j -= 1\\n                if j >=0:\\n                    res = min(res, s - 2 * (v+b[n//2-i][j]))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        # abs(s - 2*i)\\n        # i <= s / 2\\n        def f(A):\\n            n = len(A)\\n            a = [set() for _ in range(n+1)]\\n            a[0].add(0)\\n            for i in A:\\n                for j in range(n,0,-1):\\n                    for v in a[j-1]:\\n                        a[j].add(v+i)\\n            return list(map(sorted, a))\\n        s = sum(nums)\\n        n = len(nums)\\n        a = f(nums[:n//2])\\n        b = f(nums[n//2:])\\n        res = float(\\'inf\\')\\n        for i in range(n//2+1):\\n            j = len(b[n//2-i]) - 1\\n            for v in a[i]:\\n                while j >= 0 and v + b[n//2-i][j] > s // 2:\\n                    j -= 1\\n                if j >=0:\\n                    res = min(res, s - 2 * (v+b[n//2-i][j]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296715,
                "title": "c-meet-in-the-middle-using-binary-search",
                "content": "###**Upvote**### If you Like my solution, comment if you have any doubt or suggestion :)\\n```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        int totalsum=accumulate(nums.begin(),nums.end(),0);\\n        vector<vector<int>> left(n/2+1); //left[i] = > stores all possible sums with i no. of elements for first half of the array\\n        vector<vector<int>> right(n/2+1);\\n        dfs(nums,0,n/2-1,0,0,left);\\n        dfs(nums,n/2,n-1,0,0,right);\\n        int res = INT_MAX;\\n        for(int i = 0; i <= n/2;i++){\\n            vector<int>& v = right[n/2-i]; // \\'i\\' elements from left, \\'n/2 - i\\' elements from right => total n/2 elements choosen\\n            sort(v.begin(),v.end());\\n            for(auto x: left[i]){\\n                int k = near(v, totalsum/2 - x); //to minimise the diff we choose n/2 element in such a way that make the sum nearest to totalsum/2\\n                int val1 = ( k - 1 >= 0 ? v[k-1] : INT_MAX);\\n                int val2 = (k < v.size() ? v[k] : INT_MAX);\\n                int nearest = min(val1,val2);\\n                res = min(res, abs(totalsum - 2*(x + nearest))); //left = x, right = nearest, => sum = x+nearest (having n/2 elemets)\\n            } //rest n/2 element have the Sum => totalsum-(sum of first n/2 element) = totalsum - (x+nearest)\\n        } // Diff = abs(sum of first n/2 element - sum of rest n/2 element) = > abs(totalsum-(x+nearest) - (x+nearest)) = abs(totalsum - 2*(x+nearest))\\n        return res;\\n    }\\n\\t//Generate all possible sums with \\'cnt\\' no. of elements ranges from start to end O(2^n), n is atmost 15\\n    void dfs(vector<int>&nums,int start,int end,int cnt,int sum,vector<vector<int>>&v){\\n        if(start > end){\\n            v[cnt].push_back(sum);\\n        }else{\\n            dfs(nums,start+1,end,cnt+1,sum+nums[start],v);\\n            dfs(nums,start+1,end,cnt,sum,v);\\n        }\\n    }\\n    int near(vector<int>& v,int val){\\n        int n = v.size();\\n        int i = 0, j = n-1;\\n        while(i <= j){\\n            int m = i + (j-i)/2;\\n            if(v[m] <= val){\\n                i = m+1;\\n            }else{\\n                j = m-1;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        int totalsum=accumulate(nums.begin(),nums.end(),0);\\n        vector<vector<int>> left(n/2+1); //left[i] = > stores all possible sums with i no. of elements for first half of the array\\n        vector<vector<int>> right(n/2+1);\\n        dfs(nums,0,n/2-1,0,0,left);\\n        dfs(nums,n/2,n-1,0,0,right);\\n        int res = INT_MAX;\\n        for(int i = 0; i <= n/2;i++){\\n            vector<int>& v = right[n/2-i]; // \\'i\\' elements from left, \\'n/2 - i\\' elements from right => total n/2 elements choosen\\n            sort(v.begin(),v.end());\\n            for(auto x: left[i]){\\n                int k = near(v, totalsum/2 - x); //to minimise the diff we choose n/2 element in such a way that make the sum nearest to totalsum/2\\n                int val1 = ( k - 1 >= 0 ? v[k-1] : INT_MAX);\\n                int val2 = (k < v.size() ? v[k] : INT_MAX);\\n                int nearest = min(val1,val2);\\n                res = min(res, abs(totalsum - 2*(x + nearest))); //left = x, right = nearest, => sum = x+nearest (having n/2 elemets)\\n            } //rest n/2 element have the Sum => totalsum-(sum of first n/2 element) = totalsum - (x+nearest)\\n        } // Diff = abs(sum of first n/2 element - sum of rest n/2 element) = > abs(totalsum-(x+nearest) - (x+nearest)) = abs(totalsum - 2*(x+nearest))\\n        return res;\\n    }\\n\\t//Generate all possible sums with \\'cnt\\' no. of elements ranges from start to end O(2^n), n is atmost 15\\n    void dfs(vector<int>&nums,int start,int end,int cnt,int sum,vector<vector<int>>&v){\\n        if(start > end){\\n            v[cnt].push_back(sum);\\n        }else{\\n            dfs(nums,start+1,end,cnt+1,sum+nums[start],v);\\n            dfs(nums,start+1,end,cnt,sum,v);\\n        }\\n    }\\n    int near(vector<int>& v,int val){\\n        int n = v.size();\\n        int i = 0, j = n-1;\\n        while(i <= j){\\n            int m = i + (j-i)/2;\\n            if(v[m] <= val){\\n                i = m+1;\\n            }else{\\n                j = m-1;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258073,
                "title": "can-someone-tell-how-to-handle-the-negative-test-cases",
                "content": "This is the recursion based Java solution . It would be helpful if someone could suggest the solution to handle negative test case like [-36,36], also the memoization of the below code.\\n```\\nclass Solution {\\n       public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        int totalsum = 0;\\n        for (int i : nums)\\n            totalsum += i;\\n        return f(nums, n - 1, n / 2, totalsum, 0);\\n\\n    }\\n\\n    public int f(int[] a, int ind, int k, int totalsum, int sum) {\\n        if (ind == 0)\\n            if (k == 0)\\n                return Math.abs(2 * sum - totalsum);\\n            else\\n                return (int) Math.pow(10, 9);\\n        if (k == 0)\\n            return Math.abs(2 * sum - totalsum);\\n        // if (k < 0)\\n        //     return (int) Math.pow(10, 9);\\n\\n        int notpick = f(a, ind - 1, k, totalsum, sum);\\n        int pick = f(a, ind - 1, k - 1, totalsum, sum + a[ind]);\\n\\n        return Math.min(notpick, pick);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n       public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        int totalsum = 0;\\n        for (int i : nums)\\n            totalsum += i;\\n        return f(nums, n - 1, n / 2, totalsum, 0);\\n\\n    }\\n\\n    public int f(int[] a, int ind, int k, int totalsum, int sum) {\\n        if (ind == 0)\\n            if (k == 0)\\n                return Math.abs(2 * sum - totalsum);\\n            else\\n                return (int) Math.pow(10, 9);\\n        if (k == 0)\\n            return Math.abs(2 * sum - totalsum);\\n        // if (k < 0)\\n        //     return (int) Math.pow(10, 9);\\n\\n        int notpick = f(a, ind - 1, k, totalsum, sum);\\n        int pick = f(a, ind - 1, k - 1, totalsum, sum + a[ind]);\\n\\n        return Math.min(notpick, pick);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256632,
                "title": "c-meet-in-middle-commented-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> &left, vector<vector<int>> &leftSumLen, int len, int currSum, int i) {\\n        if(i >= left.size()) {\\n            leftSumLen[len].push_back(currSum);\\n            return;\\n        }\\n        //take it in the currSum\\n        dfs(left, leftSumLen, len + 1, currSum + left[i], i + 1);\\n        //don\\'t take it in the currSum and move ahead\\n        dfs(left, leftSumLen, len, currSum, i + 1);\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        \\n        //step 1 ->divide into two vectors\\n        int n = nums.size() / 2;\\n        vector<int> left;\\n        vector<int> right;\\n        int totalSum = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            left.push_back(nums[i]);\\n            totalSum += nums[i];\\n        }\\n        for(int i = n; i < nums.size(); i++) {\\n            right.push_back(nums[i]);\\n            totalSum += nums[i];\\n        }\\n        int sum = totalSum / 2;\\n        \\n        //step 2 -> find sum of possible lengths in both of these vectors - left, right\\n        //the length can range from 1 to n\\n        vector<vector<int>> leftSumLen(n + 1, vector<int> ());\\n        vector<vector<int>> rightSumLen(n + 1, vector<int> ());\\n        \\n        dfs(left, leftSumLen, 0, 0, 0);\\n        dfs(right, rightSumLen, 0, 0, 0);\\n        \\n        //setp 3 -> sort the rightSumLen as binary search will be applied\\n        for(int i = 0; i < rightSumLen.size(); i++) {\\n            sort(rightSumLen[i].begin(), rightSumLen[i].end());\\n        }\\n        \\n        int minDiff = INT_MAX;\\n        \\n        //step 4 -> go to each option in leftSumLen and go to corresponding option in rightSumLen and find the min diff\\n        for(int i = 0; i <= n; i++) {\\n            //for ith len find option for n - i len in rightSumLen\\n            for(auto firstHalfSumLeft: leftSumLen[i]) {\\n                int reqSecondHalfSumLeft = sum - firstHalfSumLeft;\\n                int found_idx = lower_bound(rightSumLen[n - i].begin(), rightSumLen[n - i].end(), reqSecondHalfSumLeft) - rightSumLen[n - i].begin();\\n                if(found_idx == rightSumLen[n - i].size()) found_idx--;\\n                \\n                int leftHalfSum = firstHalfSumLeft + rightSumLen[n - i][found_idx];\\n                int rightHalfSum = totalSum  - leftHalfSum;\\n                \\n                int diff = abs(leftHalfSum - rightHalfSum);\\n                \\n                minDiff = min(minDiff, diff);\\n                \\n            }\\n        }\\n        return minDiff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> &left, vector<vector<int>> &leftSumLen, int len, int currSum, int i) {\\n        if(i >= left.size()) {\\n            leftSumLen[len].push_back(currSum);\\n            return;\\n        }\\n        //take it in the currSum\\n        dfs(left, leftSumLen, len + 1, currSum + left[i], i + 1);\\n        //don\\'t take it in the currSum and move ahead\\n        dfs(left, leftSumLen, len, currSum, i + 1);\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        \\n        //step 1 ->divide into two vectors\\n        int n = nums.size() / 2;\\n        vector<int> left;\\n        vector<int> right;\\n        int totalSum = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            left.push_back(nums[i]);\\n            totalSum += nums[i];\\n        }\\n        for(int i = n; i < nums.size(); i++) {\\n            right.push_back(nums[i]);\\n            totalSum += nums[i];\\n        }\\n        int sum = totalSum / 2;\\n        \\n        //step 2 -> find sum of possible lengths in both of these vectors - left, right\\n        //the length can range from 1 to n\\n        vector<vector<int>> leftSumLen(n + 1, vector<int> ());\\n        vector<vector<int>> rightSumLen(n + 1, vector<int> ());\\n        \\n        dfs(left, leftSumLen, 0, 0, 0);\\n        dfs(right, rightSumLen, 0, 0, 0);\\n        \\n        //setp 3 -> sort the rightSumLen as binary search will be applied\\n        for(int i = 0; i < rightSumLen.size(); i++) {\\n            sort(rightSumLen[i].begin(), rightSumLen[i].end());\\n        }\\n        \\n        int minDiff = INT_MAX;\\n        \\n        //step 4 -> go to each option in leftSumLen and go to corresponding option in rightSumLen and find the min diff\\n        for(int i = 0; i <= n; i++) {\\n            //for ith len find option for n - i len in rightSumLen\\n            for(auto firstHalfSumLeft: leftSumLen[i]) {\\n                int reqSecondHalfSumLeft = sum - firstHalfSumLeft;\\n                int found_idx = lower_bound(rightSumLen[n - i].begin(), rightSumLen[n - i].end(), reqSecondHalfSumLeft) - rightSumLen[n - i].begin();\\n                if(found_idx == rightSumLen[n - i].size()) found_idx--;\\n                \\n                int leftHalfSum = firstHalfSumLeft + rightSumLen[n - i][found_idx];\\n                int rightHalfSum = totalSum  - leftHalfSum;\\n                \\n                int diff = abs(leftHalfSum - rightHalfSum);\\n                \\n                minDiff = min(minDiff, diff);\\n                \\n            }\\n        }\\n        return minDiff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236833,
                "title": "failing-for-testcase-c-code",
                "content": "Failing for testcase : [76,8,45,20,74,84,28,1] answer according to leetcode =2 but u can properly devide this to two parts\\nset 1=76+8+84=168, set 2=rest of the elements 168, diference 168-168=0 ?\\n```\\nint solve(vector<int>& nums,int sum,int n){\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<sum+1;i++){\\n            dp[0][i]=0;\\n        }\\n        for(int i=0;i<n+1;i++){\\n            dp[i][0]=1;\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<sum+1;j++){\\n                if(j<nums[i-1]){\\n                    dp[i][j]=dp[i-1][j];\\n                }else{\\n                    dp[i][j]=dp[i-1][j]||dp[i-1][j-nums[i-1]];\\n                }\\n            }\\n        }\\n        int min=INT_MAX;\\n        for(int i=0;i<sum+1;i++){\\n            if(dp[n][i]==1){\\n                cout<<i<<\" \";\\n                int diff=abs(sum-2*i);\\n                if(diff<min){\\n                    min=diff;\\n                }\\n            }\\n        }\\n        return min;\\n        \\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        int sum=0;\\n        int n=nums.size();\\n        int min=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            sum+=abs(nums[i]);\\n            if(nums[i]<min){\\n                min=nums[i];\\n            }\\n        }\\n        if(min<0){\\n            for(int i=0;i<n;i++){\\n                nums[i]+=abs(min);\\n                cout<<nums[i]<<\"-\";\\n            }\\n        }\\n        \\n        cout<<sum<<\" \";\\n        return solve(nums,sum,n);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint solve(vector<int>& nums,int sum,int n){\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<sum+1;i++){\\n            dp[0][i]=0;\\n        }\\n        for(int i=0;i<n+1;i++){\\n            dp[i][0]=1;\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<sum+1;j++){\\n                if(j<nums[i-1]){\\n                    dp[i][j]=dp[i-1][j];\\n                }else{\\n                    dp[i][j]=dp[i-1][j]||dp[i-1][j-nums[i-1]];\\n                }\\n            }\\n        }\\n        int min=INT_MAX;\\n        for(int i=0;i<sum+1;i++){\\n            if(dp[n][i]==1){\\n                cout<<i<<\" \";\\n                int diff=abs(sum-2*i);\\n                if(diff<min){\\n                    min=diff;\\n                }\\n            }\\n        }\\n        return min;\\n        \\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        int sum=0;\\n        int n=nums.size();\\n        int min=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            sum+=abs(nums[i]);\\n            if(nums[i]<min){\\n                min=nums[i];\\n            }\\n        }\\n        if(min<0){\\n            for(int i=0;i<n;i++){\\n                nums[i]+=abs(min);\\n                cout<<nums[i]<<\"-\";\\n            }\\n        }\\n        \\n        cout<<sum<<\" \";\\n        return solve(nums,sum,n);\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2236144,
                "title": "question",
                "content": "why the ans of this input [76,8,45,20,74,84,28,1]  2 and not  0 as\\nset 1=76+8+84=168\\nset 2=rest of the elements 168 \\nso diference 168-168=0 ?\\n\\nMy Code \\nclass Solution {\\npublic:\\n    void find(int i,int n,vector<int> &nums,int sum1,int tsum,int &ans,int t1,int t2)\\n    {\\n        if(i==n)\\n        {\\n            if(t1==0 || t2==0) return;\\n            ans=min(ans,abs(tsum-sum1));\\n            return ;\\n        }\\n        find(i+1,n,nums,sum1+nums[i],tsum-nums[i],ans,t1+1,t2-1);\\n        find(i+1,n,nums,sum1,tsum,ans,t1,t2);\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        int sum1=0,ans=INT_MAX;\\n        int tsum=0;\\n        for(auto x:nums) tsum+=x;\\n        ans=INT_MAX;\\n        find(0,nums.size(),nums,0,tsum,ans,0,nums.size());\\n        return ans;\\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void find(int i,int n,vector<int> &nums,int sum1,int tsum,int &ans,int t1,int t2)\\n    {\\n        if(i==n)\\n        {\\n            if(t1==0 || t2==0) return;\\n            ans=min(ans,abs(tsum-sum1));\\n            return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2205487,
                "title": "c",
                "content": "```\\n#define all(a) a.begin(),a.end()\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& v) {\\n        int tot = 0;\\n        for(int i:v)tot+=i;\\n        int n = v.size()/2;\\n        int N = (1<<n);\\n        vector<int> a[n+1];\\n        for(int i=0;i<N;i++)\\n        {\\n            int t = __builtin_popcount(i);\\n            int sum = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i&(1<<j))>0)sum+=v[j];\\n            }\\n            a[t].push_back(sum);\\n        }\\n        for(int i=0;i<=n;i++)\\n        {\\n            sort(all(a[i]));\\n        }\\n        reverse(all(v));\\n        int ans = 2e9;\\n        int T = tot/2;\\n        for(int i=0;i<N;i++)\\n        {\\n            int t = __builtin_popcount(i);\\n            int sum = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i&(1<<j))>0)sum+=v[j];\\n            }\\n            t = n-t;\\n            int j = lower_bound(all(a[t]),T-sum)-a[t].begin();\\n            if(j<a[t].size())ans = min(ans,abs(tot-2*(sum+a[t][j])));\\n            if(j>0)ans = min(ans,abs(tot-2*(sum+a[t][j-1]))); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define all(a) a.begin(),a.end()\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& v) {\\n        int tot = 0;\\n        for(int i:v)tot+=i;\\n        int n = v.size()/2;\\n        int N = (1<<n);\\n        vector<int> a[n+1];\\n        for(int i=0;i<N;i++)\\n        {\\n            int t = __builtin_popcount(i);\\n            int sum = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i&(1<<j))>0)sum+=v[j];\\n            }\\n            a[t].push_back(sum);\\n        }\\n        for(int i=0;i<=n;i++)\\n        {\\n            sort(all(a[i]));\\n        }\\n        reverse(all(v));\\n        int ans = 2e9;\\n        int T = tot/2;\\n        for(int i=0;i<N;i++)\\n        {\\n            int t = __builtin_popcount(i);\\n            int sum = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i&(1<<j))>0)sum+=v[j];\\n            }\\n            t = n-t;\\n            int j = lower_bound(all(a[t]),T-sum)-a[t].begin();\\n            if(j<a[t].size())ans = min(ans,abs(tot-2*(sum+a[t][j])));\\n            if(j>0)ans = min(ans,abs(tot-2*(sum+a[t][j-1]))); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111818,
                "title": "recursive-code-need-help-in-memoizing-the-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& v,int j, int i,int sum){\\n        if(i==0) return  abs(sum);\\n        if(j<0) return INT_MAX;\\n        return  min(fun(v,j-1,i-1,sum-2*v[j]),fun(v,j-1,i,sum));\\n        \\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        int sum=0;\\n        for(auto x:nums) sum+=x;\\n        return fun(nums,nums.size()-1,nums.size()/2,sum);\\n    }\\n};\\n```\\nHow to memoize this recursive code ?",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>& v,int j, int i,int sum){\\n        if(i==0) return  abs(sum);\\n        if(j<0) return INT_MAX;\\n        return  min(fun(v,j-1,i-1,sum-2*v[j]),fun(v,j-1,i,sum));\\n        \\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        int sum=0;\\n        for(auto x:nums) sum+=x;\\n        return fun(nums,nums.size()-1,nums.size()/2,sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076252,
                "title": "how-to-deal-with-negative-numbers-from-code-if-possible",
                "content": "````\\nclass Solution {\\npublic:\\n    vector<int> subsetSum(vector<int> nums, int n, int sum)\\n    {\\n        bool dp[n + 1][sum + 1];\\n        \\n        for(int i = 0; i < sum + 1; i++)\\n        {\\n            dp[0][i] = 0;\\n        }\\n        \\n        for(int i = 0; i < n + 1; i++)\\n        {\\n            dp[i][0] = 1;\\n        }\\n        \\n        for(int i = 1; i < n + 1; i++)\\n        {\\n            for(int j = 1; j < sum + 1; j++)\\n            {\\n                if(nums[i - 1] <= j)\\n                {\\n                    dp[i][j] = dp[i - 1][j - nums[i - 1]] || dp[i - 1][j]; \\n                }\\n                else\\n                {\\n                    dp[i][j] = dp[i - 1][j];\\n                }\\n            }\\n        }\\n        \\n        vector<int> v;\\n        for(int i = 0; i < (sum / 2) + 1; i++)\\n        {\\n            if(dp[n][i] == 1)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        return v;\\n    }\\n    \\n    int minimumDifference(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int range = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            range += nums[i];\\n        }\\n        \\n        vector<int> arr = subsetSum(nums, n, range);\\n        \\n        int mini = INT_MAX;\\n        \\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            mini = min(mini, range - 2 * arr[i]);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> subsetSum(vector<int> nums, int n, int sum)\\n    {\\n        bool dp[n + 1][sum + 1];\\n        \\n        for(int i = 0; i < sum + 1; i++)\\n        {\\n            dp[0][i] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2038575,
                "title": "c-meet-in-the-middle-binary-search",
                "content": "```\\nclass Solution {\\npublic: \\n    vector<vector<int>> sub;\\n    void dfs(vector<int>& nums, int idx, int sum, int cnt){\\n        if(idx == nums.size()){\\n            sub[cnt].push_back(sum);\\n            return;\\n        }\\n        dfs(nums,idx+1,sum+nums[idx],cnt+1);\\n        dfs(nums,idx+1,sum,cnt);\\n    }\\n    \\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        int m = n/2;\\n\\n        vector<int> left, right;\\n        for(int i=0; i<n; ++i){\\n            if(i<n/2) left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }\\n        \\n        int total = accumulate(nums.begin(), nums.end(), 0);\\n        \\n        sub.clear();\\n        sub.resize(m+1);\\n        dfs(left,0,0,0);\\n        vector<vector<int>> leftSub(sub.begin(), sub.end());\\n        \\n        sub.clear();\\n        sub.resize(m+1);\\n        dfs(right,0,0,0);\\n        vector<vector<int>> rightSub(sub.begin(), sub.end());\\n        \\n        for(int i=0; i<leftSub.size(); ++i){\\n            sort(leftSub[i].begin(), leftSub[i].end());\\n        }\\n        for(int i=0; i<rightSub.size(); ++i){\\n            sort(rightSub[i].begin(), rightSub[i].end());\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(int i=0; i<leftSub.size(); ++i){\\n            vector<int> larr = leftSub[i];\\n            int r_len = m-i;\\n            vector<int> rarr = rightSub[r_len];\\n            int half = total/2;\\n            for(auto &e : larr){\\n                int req = half - e;\\n                auto pos = lower_bound(rarr.begin(), rarr.end(), req);\\n                if(pos==rarr.end()) pos--;\\n                int p1 = e+(*pos);\\n                int p2 = total - p1;\\n                ans = min(ans, abs(p2-p1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    vector<vector<int>> sub;\\n    void dfs(vector<int>& nums, int idx, int sum, int cnt){\\n        if(idx == nums.size()){\\n            sub[cnt].push_back(sum);\\n            return;\\n        }\\n        dfs(nums,idx+1,sum+nums[idx],cnt+1);\\n        dfs(nums,idx+1,sum,cnt);\\n    }\\n    \\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        int m = n/2;\\n\\n        vector<int> left, right;\\n        for(int i=0; i<n; ++i){\\n            if(i<n/2) left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }\\n        \\n        int total = accumulate(nums.begin(), nums.end(), 0);\\n        \\n        sub.clear();\\n        sub.resize(m+1);\\n        dfs(left,0,0,0);\\n        vector<vector<int>> leftSub(sub.begin(), sub.end());\\n        \\n        sub.clear();\\n        sub.resize(m+1);\\n        dfs(right,0,0,0);\\n        vector<vector<int>> rightSub(sub.begin(), sub.end());\\n        \\n        for(int i=0; i<leftSub.size(); ++i){\\n            sort(leftSub[i].begin(), leftSub[i].end());\\n        }\\n        for(int i=0; i<rightSub.size(); ++i){\\n            sort(rightSub[i].begin(), rightSub[i].end());\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(int i=0; i<leftSub.size(); ++i){\\n            vector<int> larr = leftSub[i];\\n            int r_len = m-i;\\n            vector<int> rarr = rightSub[r_len];\\n            int half = total/2;\\n            for(auto &e : larr){\\n                int req = half - e;\\n                auto pos = lower_bound(rarr.begin(), rarr.end(), req);\\n                if(pos==rarr.end()) pos--;\\n                int p1 = e+(*pos);\\n                int p2 = total - p1;\\n                ans = min(ans, abs(p2-p1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029807,
                "title": "python3-solution-with-explanation-two-halves",
                "content": "```\\ndef minimumDifference(self, nums: List[int]) -> int:\\n        total = sum(nums)\\n        l = len(nums)\\n        if l==2:\\n            return abs(nums[0]-nums[1])\\n        \\n        # obtain the sum of possible 0 to l//2 numbers\\n        # to reduce complexity\\n        s1 = self.kSum(nums[0:l//2])\\n        s2 = self.kSum(nums[l//2:l])\\n            \\n        # if the sum of each party is target, then the difference is the smallest\\n        target = total/2\\n        ans = inf\\n        for i in range(l//2):\\n            j = l//2-i\\n            # find in s1[i] and s2[j] which number is closest to target\\n            y = len(s2[j])-1\\n            for x in s1[i]:\\n                while y>=0:\\n                    ans = min(ans, abs(total - 2*(x + s2[j][y])))\\n                    if s2[j][y]+x>target:\\n                        y -= 1\\n                    else:\\n                        break\\n        return ans\\n            \\n    # this function calculates sum of k numbers from num\\n    # with s[0] representing the sum of 0 number\\n    # s[1] representing the sum of 1 number\\n    # s[i] representing the sum of i numbers\\n    def kSum(self, nums: List[int]) -> list[list]:\\n        l = len(nums)\\n        s = [0]*(l+1)\\n        # use sets to avoid duplicates\\n        for i in range(l+1):\\n            s[i] = set()\\n        n = 0\\n        s[0].add(0)\\n        for i in nums:\\n            j = n\\n            while j>=0:\\n                for element in s[j]:\\n                    s[j+1].add(element + i)\\n                j -= 1\\n            n += 1\\n            \\n        # sort it\\n        for i in range(len(s)):\\n            s[i] = sorted(list(s[i]))\\n        return s\\n        \\n\\t\\t```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minimumDifference(self, nums: List[int]) -> int:\\n        total = sum(nums)\\n        l = len(nums)\\n        if l==2:\\n            return abs(nums[0]-nums[1])\\n        \\n        # obtain the sum of possible 0 to l//2 numbers\\n        # to reduce complexity\\n        s1 = self.kSum(nums[0:l//2])\\n        s2 = self.kSum(nums[l//2:l])\\n            \\n        # if the sum of each party is target, then the difference is the smallest\\n        target = total/2\\n        ans = inf\\n        for i in range(l//2):\\n            j = l//2-i\\n            # find in s1[i] and s2[j] which number is closest to target\\n            y = len(s2[j])-1\\n            for x in s1[i]:\\n                while y>=0:\\n                    ans = min(ans, abs(total - 2*(x + s2[j][y])))\\n                    if s2[j][y]+x>target:\\n                        y -= 1\\n                    else:\\n                        break\\n        return ans\\n            \\n    # this function calculates sum of k numbers from num\\n    # with s[0] representing the sum of 0 number\\n    # s[1] representing the sum of 1 number\\n    # s[i] representing the sum of i numbers\\n    def kSum(self, nums: List[int]) -> list[list]:\\n        l = len(nums)\\n        s = [0]*(l+1)\\n        # use sets to avoid duplicates\\n        for i in range(l+1):\\n            s[i] = set()\\n        n = 0\\n        s[0].add(0)\\n        for i in nums:\\n            j = n\\n            while j>=0:\\n                for element in s[j]:\\n                    s[j+1].add(element + i)\\n                j -= 1\\n            n += 1\\n            \\n        # sort it\\n        for i in range(len(s)):\\n            s[i] = sorted(list(s[i]))\\n        return s\\n        \\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1794557,
                "title": "python-tree-structure-recursive-function",
                "content": "root=[], root of tree structure\\n\\n1. n=1\\n\\t\\t\\tnum=[x0, x1]\\n\\t\\t\\ta=[x0], b=[x1] or a=[x1], b=[x0]\\n\\t\\t\\tdiff = (x0-x1) or (x1-x0)\\n\\t\\t\\tIn this case, tree has 1 level, 2 nodes, node value: diff or -diff\\n\\n2. n=2\\n\\n\\t\\tnum=[x0, x1, x2, x3]\\n\\t\\ta=[a0, a1], b=[b0, b1]\\n\\t\\tChoices of selection of a0 and b0 as level1 of the tree\\n\\t\\tif a0=x0:\\n\\t\\tb0 could be x1, x2 or x3\\n\\t\\teg. a0=x0, b0=x1\\n\\t\\tdiff0 = (x0-x1)\\n\\t\\tlevel1 node value would be diff0 or -diff0\\n\\t\\tnumbers remain in num would be num1=[x2, x3], go to step 1 .\\n\\t\\tdiff1 = x2-x3\\n\\t\\tTree would be one of [diff0, diff1], [diff0, -diff1], [-diff0, diff1] or [-diff0, -diff1]\\n\\t\\tchoose the one with minimum absolute sum value.\\n\\n3. n>2\\n\\n\\t\\tProcess tree from root to level n.\\n\\t\\tchoose the minimum aboslute sum value to be out.\\n\\t\\tif out is zero, exit search.\\n\\n\\n\\'\\'\\'\\nclass Solution(object):\\n    def minimumDifference(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        n = int(len(nums) / 2)\\n        root = []\\n        out = None\\n        root, out = partitionArray(nums, root, out)\\n\\n        return out\\n\\n\\ndef partitionArray(nums, root, out):\\n\\t\\tn = int(len(nums) / 2)\\n\\n\\t\\tif n == 1 or out ==0:\\n\\t\\t\\tif out == 0:\\n\\t\\t\\t\\treturn root, out\\n\\n\\t\\t\\t_sum = 0\\n\\t\\t\\tfor r in root:\\n\\t\\t\\t\\t_sum +=r\\n\\n\\t\\t\\tdiff1 = nums[0] - nums[1]\\n\\n\\t\\t\\tsum = abs(_sum+diff1)\\n\\t\\t\\tif out==None or out >sum:\\n\\t\\t\\t\\tout = sum\\n\\n\\t\\t\\tsum = abs(_sum-diff1)\\n\\t\\t\\tif out==None or out >sum:\\n\\t\\t\\t\\tout = sum\\n\\n\\t\\t\\treturn root, out\\n\\t\\telse:\\n\\t\\t\\ta0 = nums[0]\\n\\t\\t\\tfor i in range(1, 2 * n - 1):\\n\\t\\t\\t\\tb0 = nums[i]\\n\\t\\t\\t\\tdiff0 = a0 - b0\\n\\t\\t\\t\\troot.append(diff0)\\n\\n\\t\\t\\t\\tnums1 = nums[1:i] + nums[i + 1:] if i < 2 * n - 1 else []\\n\\t\\t\\t\\troot, out = partitionArray(nums1, root, out)\\n\\t\\t\\t\\troot.pop()\\n\\t\\t\\t\\tif out==0:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\troot.append(-1*diff0)\\n\\t\\t\\t\\troot, out = partitionArray(nums1, root, out)\\n\\t\\t\\t\\troot.pop()\\n\\t\\t\\t\\tif out==0:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn root, out\\n",
                "solutionTags": [],
                "code": "root=[], root of tree structure\\n\\n1. n=1\\n\\t\\t\\tnum=[x0, x1]\\n\\t\\t\\ta=[x0], b=[x1] or a=[x1], b=[x0]\\n\\t\\t\\tdiff = (x0-x1) or (x1-x0)\\n\\t\\t\\tIn this case, tree has 1 level, 2 nodes, node value: diff or -diff\\n\\n2. n=2\\n\\n\\t\\tnum=[x0, x1, x2, x3]\\n\\t\\ta=[a0, a1], b=[b0, b1]\\n\\t\\tChoices of selection of a0 and b0 as level1 of the tree\\n\\t\\tif a0=x0:\\n\\t\\tb0 could be x1, x2 or x3\\n\\t\\teg. a0=x0, b0=x1\\n\\t\\tdiff0 = (x0-x1)\\n\\t\\tlevel1 node value would be diff0 or -diff0\\n\\t\\tnumbers remain in num would be num1=[x2, x3], go to step 1 .\\n\\t\\tdiff1 = x2-x3\\n\\t\\tTree would be one of [diff0, diff1], [diff0, -diff1], [-diff0, diff1] or [-diff0, -diff1]\\n\\t\\tchoose the one with minimum absolute sum value.\\n\\n3. n>2\\n\\n\\t\\tProcess tree from root to level n.\\n\\t\\tchoose the minimum aboslute sum value to be out.\\n\\t\\tif out is zero, exit search.\\n\\n\\n\\'\\'\\'\\nclass Solution(object):\\n    def minimumDifference(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        n = int(len(nums) / 2)\\n        root = []\\n        out = None\\n        root, out = partitionArray(nums, root, out)\\n\\n        return out\\n\\n\\ndef partitionArray(nums, root, out):\\n\\t\\tn = int(len(nums) / 2)\\n\\n\\t\\tif n == 1 or out ==0:\\n\\t\\t\\tif out == 0:\\n\\t\\t\\t\\treturn root, out\\n\\n\\t\\t\\t_sum = 0\\n\\t\\t\\tfor r in root:\\n\\t\\t\\t\\t_sum +=r\\n\\n\\t\\t\\tdiff1 = nums[0] - nums[1]\\n\\n\\t\\t\\tsum = abs(_sum+diff1)\\n\\t\\t\\tif out==None or out >sum:\\n\\t\\t\\t\\tout = sum\\n\\n\\t\\t\\tsum = abs(_sum-diff1)\\n\\t\\t\\tif out==None or out >sum:\\n\\t\\t\\t\\tout = sum\\n\\n\\t\\t\\treturn root, out\\n\\t\\telse:\\n\\t\\t\\ta0 = nums[0]\\n\\t\\t\\tfor i in range(1, 2 * n - 1):\\n\\t\\t\\t\\tb0 = nums[i]\\n\\t\\t\\t\\tdiff0 = a0 - b0\\n\\t\\t\\t\\troot.append(diff0)\\n\\n\\t\\t\\t\\tnums1 = nums[1:i] + nums[i + 1:] if i < 2 * n - 1 else []\\n\\t\\t\\t\\troot, out = partitionArray(nums1, root, out)\\n\\t\\t\\t\\troot.pop()\\n\\t\\t\\t\\tif out==0:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\troot.append(-1*diff0)\\n\\t\\t\\t\\troot, out = partitionArray(nums1, root, out)\\n\\t\\t\\t\\troot.pop()\\n\\t\\t\\t\\tif out==0:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn root, out\\n",
                "codeTag": "Java"
            },
            {
                "id": 1774041,
                "title": "c-meet-in-the-middle-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int> left, right;\\n        int sum = 0;\\n        int n = nums.size() / 2;\\n        for(int i = 0; i < 2 * n; i++) {\\n            if(i < n)\\n                left.push_back(nums[i]);\\n            else\\n                right.push_back(nums[i]);\\n            sum += nums[i];\\n        }\\n        vector<vector<int>> sumLeft(n + 1), sumRight(n + 1); //sumRight[i] stores all possible sum of i elements in the Right array\\n        for(int i = 1; i < 1 << n; i++) {\\n            int count = 0;\\n            int subSetSum = 0;\\n            for(int j = 0; j < n; j++) {\\n                if((1 << j ) & i){\\n                    count++;\\n                    subSetSum += left[j];\\n                }\\n            }\\n            sumLeft[count].push_back(subSetSum);\\n            subSetSum = 0;\\n            count = 0;\\n            for(int j = 0; j < n; j++) {\\n                if((1 << j ) & i){\\n                    count++;\\n                    subSetSum += right[j];\\n                }\\n            }\\n            sumRight[count].push_back(subSetSum);\\n        }\\n        sumLeft[0].push_back(0);\\n        sumRight[0].push_back(0);\\n        for(auto it: sumLeft){\\n            sort(it.begin(), it.end());\\n        }\\n        int ans = INT_MAX;\\n        for(int i = 0; i <= n; i++) {\\n                sort(sumRight[n-i].begin(), sumRight[n-i].end());\\n            for(auto iSumLeft : sumLeft[i]) {\\n                int fi = (sum - 2*iSumLeft) / 2;\\n                auto it = lower_bound(sumRight[n-i].begin(), sumRight[n-i].end(), fi) - sumRight[n-i].begin();// try to find the closest element in the sumRight[n - i] array such that our answer is close to 0\\n                if(it != sumRight[n-i].size())\\n                    ans = min(ans, abs(sum - 2*((sumRight[n-i][it]) + iSumLeft)));\\n                if(it != 0){\\n                    ans = min(ans, abs(sum-2*(iSumLeft+(sumRight[n-i][it-1]))));}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int> left, right;\\n        int sum = 0;\\n        int n = nums.size() / 2;\\n        for(int i = 0; i < 2 * n; i++) {\\n            if(i < n)\\n                left.push_back(nums[i]);\\n            else\\n                right.push_back(nums[i]);\\n            sum += nums[i];\\n        }\\n        vector<vector<int>> sumLeft(n + 1), sumRight(n + 1); //sumRight[i] stores all possible sum of i elements in the Right array\\n        for(int i = 1; i < 1 << n; i++) {\\n            int count = 0;\\n            int subSetSum = 0;\\n            for(int j = 0; j < n; j++) {\\n                if((1 << j ) & i){\\n                    count++;\\n                    subSetSum += left[j];\\n                }\\n            }\\n            sumLeft[count].push_back(subSetSum);\\n            subSetSum = 0;\\n            count = 0;\\n            for(int j = 0; j < n; j++) {\\n                if((1 << j ) & i){\\n                    count++;\\n                    subSetSum += right[j];\\n                }\\n            }\\n            sumRight[count].push_back(subSetSum);\\n        }\\n        sumLeft[0].push_back(0);\\n        sumRight[0].push_back(0);\\n        for(auto it: sumLeft){\\n            sort(it.begin(), it.end());\\n        }\\n        int ans = INT_MAX;\\n        for(int i = 0; i <= n; i++) {\\n                sort(sumRight[n-i].begin(), sumRight[n-i].end());\\n            for(auto iSumLeft : sumLeft[i]) {\\n                int fi = (sum - 2*iSumLeft) / 2;\\n                auto it = lower_bound(sumRight[n-i].begin(), sumRight[n-i].end(), fi) - sumRight[n-i].begin();// try to find the closest element in the sumRight[n - i] array such that our answer is close to 0\\n                if(it != sumRight[n-i].size())\\n                    ans = min(ans, abs(sum - 2*((sumRight[n-i][it]) + iSumLeft)));\\n                if(it != 0){\\n                    ans = min(ans, abs(sum-2*(iSumLeft+(sumRight[n-i][it-1]))));}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737446,
                "title": "why-this-solution-is-not-working",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int sum=0, n=nums.size();\\n        for(int i=0; i<nums.size(); i++){\\n            sum+=nums[i];\\n        }\\n        \\n        bool dp[n+1][sum+1];\\n        for(int i=0; i<n+1; i++){\\n            for(int j=0; j<sum+1; j++){\\n                if(i==0)\\n                    dp[i][j]=false;\\n                if(j==0)\\n                    dp[i][j]=true;\\n            }\\n        }\\n        for(int i=1; i<n+1; i++){\\n            for(int j=1; j<sum+1; j++){\\n                if(nums[i-1]<=j){\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-nums[i-1]];\\n                }\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        \\n        int res;\\n        for(int j=0; j<=(sum/2); j++){\\n            if(dp[n][j]==true)\\n                res=j;\\n        }\\n        return sum-(2*res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int sum=0, n=nums.size();\\n        for(int i=0; i<nums.size(); i++){\\n            sum+=nums[i];\\n        }\\n        \\n        bool dp[n+1][sum+1];\\n        for(int i=0; i<n+1; i++){\\n            for(int j=0; j<sum+1; j++){\\n                if(i==0)\\n                    dp[i][j]=false;\\n                if(j==0)\\n                    dp[i][j]=true;\\n            }\\n        }\\n        for(int i=1; i<n+1; i++){\\n            for(int j=1; j<sum+1; j++){\\n                if(nums[i-1]<=j){\\n                    dp[i][j]=dp[i-1][j] || dp[i-1][j-nums[i-1]];\\n                }\\n                else\\n                    dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n        \\n        int res;\\n        for(int j=0; j<=(sum/2); j++){\\n            if(dp[n][j]==true)\\n                res=j;\\n        }\\n        return sum-(2*res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690566,
                "title": "c-explanation",
                "content": "General strategy : \\n\\nFind a subset R in the right part of the array and an other subset L in the left part of the array such that if we partition the set in  :\\nP1= elements of R + elements of L\\nP2=all the other elements \\nthose are the partitions that satisfy the problem. \\nApproaching the problem this way will make possible to do some important optimizations.\\n \\n \\nWhat the code does:\\n\\n1.Finds the sums of the elements of every subset L in the left-half  and stores them in a matrix such that in the row \"i\" of the matrix are stored all the sums of subsets of size \"i\".\\n2. sorts every row of the matrix mentioned before.\\n3. Considers every possible right subset R: if the size of the right subset is k and the size of the original array is n ,    n/2 - k should be the size of a left-half set L that we want. \\n4. Now, having the partial sum of the right set and of the left-half subsets, for a given R we can take an L of the right size and calculate if we minimize the solution, we take advantage of the fact that having sorted the array of the sums of the subsets L ( let\\'s call L-sum a sum of the elements of a left-half subset) we can use binary search to find the best possible L-sums for a given R and see if it minimizes the solution. Binary search made possible to not consider all the possible combinations reducing the time complexity to O(n* 2^n) \\n5. Before starting binary search we check if the optimal L-sum is one the extremes of the array of L-sums that we are considering , since this is quite common .\\n6. We use memoization to optimize further.\\n\\n```\\n#define MAX_SN 7000\\nint sumArray(int *v, int size){\\n    int sum=0;\\n    for(int i=0; i<size; ++i) sum+=v[i];\\n    return sum;\\n}\\nint min(int a, int b){return a<b?a:b;}\\nint cmp_int(const void*a, const void*b){return *(const int*)a-*(const int*)b;}\\n\\n\\nvoid listSubsets(int subsets[16][MAX_SN], int SubsetsSizes[16], int *nums,int n, int partialSum,int subsetSize){\\n    if(n==0){\\n        subsets[subsetSize][SubsetsSizes[subsetSize]++]=partialSum;\\n        return;\\n    }\\n\\n    listSubsets(subsets, SubsetsSizes, nums+1, n-1, partialSum, subsetSize);\\n    listSubsets(subsets, SubsetsSizes, nums+1, n-1, partialSum+nums[0], subsetSize+1);\\n    \\n}\\n\\nvoid MIM(int subsets[16][MAX_SN], int SubsetsSizes[16], int *nums,int n,int partialSum,int subsetSize,int *sol, int total, int N,int memoization[16][11939]){\\n    \\n    if(n==0){\\n        if(memoization[subsetSize][abs(partialSum+11939)%11939]) return;\\n        memoization[subsetSize][abs(partialSum+11939)%11939]=1;\\n        int l,r,m,temp, complementSize;\\n        complementSize=N/2 - subsetSize;\\n        l=0;\\n        r=SubsetsSizes[complementSize]-1;\\n        temp=abs(total-2*(subsets[complementSize][r]+partialSum));\\n        if(r==0 || abs(total-2*(subsets[complementSize][r-1]+partialSum))>temp) {\\n            *sol=min(*sol,temp);\\n            return;\\n        }\\n        temp=abs(total-2*(subsets[complementSize][l]+partialSum));\\n        if( abs(total-2*(subsets[complementSize][l+1]+partialSum))>temp) {\\n            *sol=min(*sol,temp);\\n            return;\\n        }\\n        while(r-l>3){\\n            \\n            m=l+(r-l)/2;\\n            temp=abs(total-2*(subsets[complementSize][m]+partialSum));\\n            if(abs(total-2*(subsets[complementSize][m+1]+partialSum))>temp) r=m;\\n            else if(abs(total-2*(subsets[complementSize][m+1]+partialSum))<temp) l=m;\\n            else r--;\\n        \\n        }\\n     \\n        for(int i=l; i<=r; ++i){\\n            temp=abs(total-2*(subsets[complementSize][i]+partialSum));\\n            *sol=min(*sol,temp);\\n        }\\n        \\n    }\\n    else{\\n        MIM(subsets, SubsetsSizes, nums+1, n-1, partialSum, subsetSize, sol, total, N, memoization);\\n        MIM(subsets, SubsetsSizes, nums+1, n-1, partialSum+nums[0], subsetSize+1, sol, total, N, memoization);\\n    }\\n    \\n}\\n\\nint minimumDifference(int* nums, int n){\\n    int total=sumArray(nums,n);// so absolute difference = abs(total-2halfSum)\\n    int sol=INT_MAX;//we consider here the case the vector is already partitioned correctly\\n    int subsets[16][MAX_SN];\\n    int SubsetsSizes[16]={0};\\n    int memoization[16][11939];\\n    for(int i=0; i<16; ++i)\\n        for(int j=0; j<11939; ++j) memoization[i][j]=0;\\n    listSubsets(subsets, SubsetsSizes, nums, n/2, 0, 0);\\n    \\n    for(int i=0; i<=n/2; ++i){\\n        qsort(subsets[i],SubsetsSizes[i],sizeof(subsets[i][0]),cmp_int);\\n    }\\n    \\n    MIM(subsets, SubsetsSizes, nums+n/2, n/2, 0, 0, &sol, total, n, memoization);\\n    \\n    return sol;\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define MAX_SN 7000\\nint sumArray(int *v, int size){\\n    int sum=0;\\n    for(int i=0; i<size; ++i) sum+=v[i];\\n    return sum;\\n}\\nint min(int a, int b){return a<b?a:b;}\\nint cmp_int(const void*a, const void*b){return *(const int*)a-*(const int*)b;}\\n\\n\\nvoid listSubsets(int subsets[16][MAX_SN], int SubsetsSizes[16], int *nums,int n, int partialSum,int subsetSize){\\n    if(n==0){\\n        subsets[subsetSize][SubsetsSizes[subsetSize]++]=partialSum;\\n        return;\\n    }\\n\\n    listSubsets(subsets, SubsetsSizes, nums+1, n-1, partialSum, subsetSize);\\n    listSubsets(subsets, SubsetsSizes, nums+1, n-1, partialSum+nums[0], subsetSize+1);\\n    \\n}\\n\\nvoid MIM(int subsets[16][MAX_SN], int SubsetsSizes[16], int *nums,int n,int partialSum,int subsetSize,int *sol, int total, int N,int memoization[16][11939]){\\n    \\n    if(n==0){\\n        if(memoization[subsetSize][abs(partialSum+11939)%11939]) return;\\n        memoization[subsetSize][abs(partialSum+11939)%11939]=1;\\n        int l,r,m,temp, complementSize;\\n        complementSize=N/2 - subsetSize;\\n        l=0;\\n        r=SubsetsSizes[complementSize]-1;\\n        temp=abs(total-2*(subsets[complementSize][r]+partialSum));\\n        if(r==0 || abs(total-2*(subsets[complementSize][r-1]+partialSum))>temp) {\\n            *sol=min(*sol,temp);\\n            return;\\n        }\\n        temp=abs(total-2*(subsets[complementSize][l]+partialSum));\\n        if( abs(total-2*(subsets[complementSize][l+1]+partialSum))>temp) {\\n            *sol=min(*sol,temp);\\n            return;\\n        }\\n        while(r-l>3){\\n            \\n            m=l+(r-l)/2;\\n            temp=abs(total-2*(subsets[complementSize][m]+partialSum));\\n            if(abs(total-2*(subsets[complementSize][m+1]+partialSum))>temp) r=m;\\n            else if(abs(total-2*(subsets[complementSize][m+1]+partialSum))<temp) l=m;\\n            else r--;\\n        \\n        }\\n     \\n        for(int i=l; i<=r; ++i){\\n            temp=abs(total-2*(subsets[complementSize][i]+partialSum));\\n            *sol=min(*sol,temp);\\n        }\\n        \\n    }\\n    else{\\n        MIM(subsets, SubsetsSizes, nums+1, n-1, partialSum, subsetSize, sol, total, N, memoization);\\n        MIM(subsets, SubsetsSizes, nums+1, n-1, partialSum+nums[0], subsetSize+1, sol, total, N, memoization);\\n    }\\n    \\n}\\n\\nint minimumDifference(int* nums, int n){\\n    int total=sumArray(nums,n);// so absolute difference = abs(total-2halfSum)\\n    int sol=INT_MAX;//we consider here the case the vector is already partitioned correctly\\n    int subsets[16][MAX_SN];\\n    int SubsetsSizes[16]={0};\\n    int memoization[16][11939];\\n    for(int i=0; i<16; ++i)\\n        for(int j=0; j<11939; ++j) memoization[i][j]=0;\\n    listSubsets(subsets, SubsetsSizes, nums, n/2, 0, 0);\\n    \\n    for(int i=0; i<=n/2; ++i){\\n        qsort(subsets[i],SubsetsSizes[i],sizeof(subsets[i][0]),cmp_int);\\n    }\\n    \\n    MIM(subsets, SubsetsSizes, nums+n/2, n/2, 0, 0, &sol, total, n, memoization);\\n    \\n    return sol;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681027,
                "title": "time-limit-exceeded-for-nums-i-in-the-range-of-10-7-to-10-7",
                "content": "Hello All, I tried solving this problem using memoization and recursion. But for array size let\\'s say 30 which is the maximum allowes input size, my code is giving TLE for numbers which are in the range of \\n-10^7 to 10^7. But for same input size if the numbers are of range -1000 to 1000. The code is passed with out any TLE.\\ncan anyone please tell me how this problem can be solved by memoization. I am writin my code here.\\n\\nNo TLE for this input : [197,211,-449,-364,55,-329,497,-976,315,-187,-283,119,450,720,128,4678,-1499,-7388,-3827,128,773,673,374,7656,-279,0,226,-577,-885,-9694]\\n\\nTLE for this input: \\n[7772197,4460211,-7641449,-8856364,546755,-3673029,527497,-9392076,3130315,-5309187,-4781283,5919119,3093450,1132720,\\n6380128,-3954678,-1651499,-7944388,-3056827,1610628,7711173,6595873,302974,7656726\\n,-2572679,0,2121026,-5743797,-8897395,-9699694]\\n```\\nclass Solution {\\n  \\n    int aLen = 0;\\n    int bLen = 0;\\n    int totalsum=0;\\n    public int minimumDifference(int[] nums) {\\n        List<Map<Integer,Integer>> dpMap = new ArrayList<>();\\n        for(int i=0; i<nums.length;i++){\\n            totalsum+=nums[i];\\n            dpMap.add(new HashMap<>());\\n        }\\n        dpMap.add(new HashMap<>());\\n        \\n        int ans = funcUtil(nums,0,0,dpMap);\\n      //System.out.println(dpMap);\\n      return ans;\\n    }\\n  \\n  \\n    public int funcUtil(int[] nums,int sA, int ix,List<Map<Integer,Integer>> dpMap){\\n      if(aLen== nums.length/2 || bLen==nums.length/2){\\n        return Math.abs(sA-(totalsum - sA));\\n      }else if(aLen>nums.length/2 || bLen>nums.length/2){\\n        return Integer.MAX_VALUE;\\n      }\\n      else{\\n        int addNum = add(sA,nums[ix]);\\n        aLen++;\\n        if(!dpMap.get(ix+1).containsKey(addNum)){\\n          dpMap.get(ix+1).put(addNum,funcUtil(nums,addNum,ix+1,dpMap));\\n        }\\n        aLen--;\\n        bLen++;\\n        if(!dpMap.get(ix+1).containsKey(sA)){\\n          dpMap.get(ix+1).put(sA,funcUtil(nums,sA,ix+1,dpMap));\\n        }\\n        bLen--;\\n        return Math.min(dpMap.get(ix+1).get(sA),dpMap.get(ix+1).get(addNum));\\n      }\\n    }\\n  \\n    int add(int x, int y)\\n    {\\n        // Iterate till there is no carry\\n        while (y != 0)\\n        {\\n            // carry now contains common\\n            // set bits of x and y\\n            int carry = x & y;\\n \\n            // Sum of bits of x and\\n            // y where at least one\\n            // of the bits is not set\\n            x = x ^ y;\\n \\n            // Carry is shifted by\\n            // one so that adding it\\n            // to x gives the required sum\\n            y = carry << 1;\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n  \\n    int aLen = 0;\\n    int bLen = 0;\\n    int totalsum=0;\\n    public int minimumDifference(int[] nums) {\\n        List<Map<Integer,Integer>> dpMap = new ArrayList<>();\\n        for(int i=0; i<nums.length;i++){\\n            totalsum+=nums[i];\\n            dpMap.add(new HashMap<>());\\n        }\\n        dpMap.add(new HashMap<>());\\n        \\n        int ans = funcUtil(nums,0,0,dpMap);\\n      //System.out.println(dpMap);\\n      return ans;\\n    }\\n  \\n  \\n    public int funcUtil(int[] nums,int sA, int ix,List<Map<Integer,Integer>> dpMap){\\n      if(aLen== nums.length/2 || bLen==nums.length/2){\\n        return Math.abs(sA-(totalsum - sA));\\n      }else if(aLen>nums.length/2 || bLen>nums.length/2){\\n        return Integer.MAX_VALUE;\\n      }\\n      else{\\n        int addNum = add(sA,nums[ix]);\\n        aLen++;\\n        if(!dpMap.get(ix+1).containsKey(addNum)){\\n          dpMap.get(ix+1).put(addNum,funcUtil(nums,addNum,ix+1,dpMap));\\n        }\\n        aLen--;\\n        bLen++;\\n        if(!dpMap.get(ix+1).containsKey(sA)){\\n          dpMap.get(ix+1).put(sA,funcUtil(nums,sA,ix+1,dpMap));\\n        }\\n        bLen--;\\n        return Math.min(dpMap.get(ix+1).get(sA),dpMap.get(ix+1).get(addNum));\\n      }\\n    }\\n  \\n    int add(int x, int y)\\n    {\\n        // Iterate till there is no carry\\n        while (y != 0)\\n        {\\n            // carry now contains common\\n            // set bits of x and y\\n            int carry = x & y;\\n \\n            // Sum of bits of x and\\n            // y where at least one\\n            // of the bits is not set\\n            x = x ^ y;\\n \\n            // Carry is shifted by\\n            // one so that adding it\\n            // to x gives the required sum\\n            y = carry << 1;\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626718,
                "title": "c-split-and-list-832-ms-56-81-70-1-mb-73-57-o-2-n",
                "content": "Since 2^30 is apparently too large to calculate, we have to consider another wau to solve this problem.\\nTo deal with this kind of problems, splitting is a effective way.\\nFirst, split the array into two arrays with the length `n`.\\nFor each row, we calculate all possible values beforehand. These values are stored in the arrays which correspond to the size of elements used for summing up. Furthermore, these values are sorted with respect to its value. Eventually, we have two set of possible values made from two separated rows.\\n\\nWith these values, we can search all possible combinations. The code is written in below.\\n\\n```c++\\nclass Solution {\\npublic:\\n    #define MAX 15\\n    #define INF (int)(1e9)\\n    vector<int> values[2][MAX+1]; \\n\\n    void get_comb(vector<int>& v, int loc){\\n        int lim = (1 << v.size());\\n        for(int i=0;i<lim;i++){\\n            int d = i;\\n            int sum = 0;\\n            int cnt = 0;\\n            for(int n=0;n<v.size();n++){\\n                if((d & 1) == 1){\\n                    sum += v[n];\\n                    cnt++;\\n                }\\n                d = d >> 1;\\n            }\\n            values[loc][cnt].emplace_back(sum);\\n        }\\n    }\\n    void value_sort(){\\n        for(int i=0;i<=MAX;i++){\\n            sort(values[0][i].begin(), values[0][i].end());\\n            sort(values[1][i].begin(), values[1][i].end());\\n            values[0][i].erase(unique(values[0][i].begin(), values[0][i].end()), values[0][i].end());\\n            values[1][i].erase(unique(values[1][i].begin(), values[1][i].end()), values[1][i].end());\\n        }\\n    }\\n    \\n    void update(int& ans, int e, int x, int total){\\n        int value = abs(-2*e - 2*x + total);\\n        if(value < ans){\\n            ans = value;\\n        }\\n    }\\n    \\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/2;\\n        int total = 0;\\n        vector<int> left(n), right(n);\\n        for(int i=0;i<n;i++){\\n            left[i] = nums[i];\\n            right[i] = nums[i+n];\\n            total += nums[i];\\n            total += nums[i+n];\\n        }\\n        get_comb(left, 0);\\n        get_comb(right, 1);\\n        int ans = INF;\\n        value_sort();\\n        for(int i=0;i<=n;i++){\\n            for(int e : values[0][i]){\\n                auto lower = lower_bound(values[1][n-i].begin(), values[1][n-i].end(), (total - 2*e + 1)/2);\\n                if(lower != values[1][n-i].end()){\\n                    update(ans, e, *(lower), total);\\n                }\\n                if(lower != values[1][n-i].begin()){\\n                    lower--;\\n                    update(ans, e, *(lower), total);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    #define MAX 15\\n    #define INF (int)(1e9)\\n    vector<int> values[2][MAX+1]; \\n\\n    void get_comb(vector<int>& v, int loc){\\n        int lim = (1 << v.size());\\n        for(int i=0;i<lim;i++){\\n            int d = i;\\n            int sum = 0;\\n            int cnt = 0;\\n            for(int n=0;n<v.size();n++){\\n                if((d & 1) == 1){\\n                    sum += v[n];\\n                    cnt++;\\n                }\\n                d = d >> 1;\\n            }\\n            values[loc][cnt].emplace_back(sum);\\n        }\\n    }\\n    void value_sort(){\\n        for(int i=0;i<=MAX;i++){\\n            sort(values[0][i].begin(), values[0][i].end());\\n            sort(values[1][i].begin(), values[1][i].end());\\n            values[0][i].erase(unique(values[0][i].begin(), values[0][i].end()), values[0][i].end());\\n            values[1][i].erase(unique(values[1][i].begin(), values[1][i].end()), values[1][i].end());\\n        }\\n    }\\n    \\n    void update(int& ans, int e, int x, int total){\\n        int value = abs(-2*e - 2*x + total);\\n        if(value < ans){\\n            ans = value;\\n        }\\n    }\\n    \\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/2;\\n        int total = 0;\\n        vector<int> left(n), right(n);\\n        for(int i=0;i<n;i++){\\n            left[i] = nums[i];\\n            right[i] = nums[i+n];\\n            total += nums[i];\\n            total += nums[i+n];\\n        }\\n        get_comb(left, 0);\\n        get_comb(right, 1);\\n        int ans = INF;\\n        value_sort();\\n        for(int i=0;i<=n;i++){\\n            for(int e : values[0][i]){\\n                auto lower = lower_bound(values[1][n-i].begin(), values[1][n-i].end(), (total - 2*e + 1)/2);\\n                if(lower != values[1][n-i].end()){\\n                    update(ans, e, *(lower), total);\\n                }\\n                if(lower != values[1][n-i].begin()){\\n                    lower--;\\n                    update(ans, e, *(lower), total);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526061,
                "title": "bitmask-binary-search",
                "content": "```java\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length/2, totalSum = 0;\\n        for (int num : nums) totalSum += num;\\n        \\n        // left(i) stores all subset sum of size i from the left part.\\n        // right defined in similar way\\n        List<List<Integer>> left = new ArrayList<>(n);\\n        List<List<Integer>> right = new ArrayList<>(n);\\n        for(int i=0;i<=n;++i) {\\n            left.add(new ArrayList<>());\\n            right.add(new ArrayList<>());\\n        }\\n        \\n        fillSubsetSum(nums, 0, n-1, left);\\n        fillSubsetSum(nums, n, 2*n-1, right);\\n        \\n        int minDiff = Integer.MAX_VALUE;\\n        for(int leftSubsetSize=0;leftSubsetSize<=n;++leftSubsetSize) {\\n            int rightSubsetSize = n - leftSubsetSize;\\n            \\n            for(int sum : left.get(leftSubsetSize)) {\\n                int minDiffLocal = (int) Math.abs(\\n                    findMinimalDifference(sum, right.get(rightSubsetSize), totalSum)\\n                );\\n                minDiff = Integer.min(minDiff, minDiffLocal);\\n            }\\n        }\\n        \\n        return minDiff;\\n    }\\n    \\n    /**\\n     * O(log(right.size()))\\n     */\\n    private int findMinimalDifference(int leftSum, List<Integer> right, int totalSum) {\\n        int low = 0, high = right.size()-1;\\n        int diff = 0, minDiff = Integer.MAX_VALUE;\\n        \\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            diff = totalSum - 2*leftSum - 2*right.get(mid);\\n            minDiff = Integer.min(Math.abs(diff), minDiff);\\n            \\n            if (diff == 0)\\n                return 0;\\n            else if (diff > 0) low = mid+1;\\n            else high = mid-1;\\n        }\\n        \\n        return Integer.min(Math.abs(diff), minDiff);\\n    }\\n    \\n    /**\\n     * O(2^n)\\n     * 1 <= n <= 15 => 2^n ~ 2^15 = ~32k\\n     */\\n    private void fillSubsetSum(int[] nums, int low, int high, List<List<Integer>> resArray) {\\n        int n = high - low + 1;\\n        \\n        for(int i=0;i<(int)Math.pow(2, n);++i) {\\n            int subsetSum = 0;\\n            int size = 0;\\n            for(int j=0;j<16;++j) {\\n                if ((i & (1<<j)) > 0 && low+j<nums.length) {\\n                    subsetSum += nums[low+j];\\n                    ++size;\\n                }\\n            }\\n            \\n            resArray.get(size).add(subsetSum);\\n        }\\n        \\n        for(List<Integer> list : resArray) Collections.sort(list);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Bitmask"
                ],
                "code": "```java\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length/2, totalSum = 0;\\n        for (int num : nums) totalSum += num;\\n        \\n        // left(i) stores all subset sum of size i from the left part.\\n        // right defined in similar way\\n        List<List<Integer>> left = new ArrayList<>(n);\\n        List<List<Integer>> right = new ArrayList<>(n);\\n        for(int i=0;i<=n;++i) {\\n            left.add(new ArrayList<>());\\n            right.add(new ArrayList<>());\\n        }\\n        \\n        fillSubsetSum(nums, 0, n-1, left);\\n        fillSubsetSum(nums, n, 2*n-1, right);\\n        \\n        int minDiff = Integer.MAX_VALUE;\\n        for(int leftSubsetSize=0;leftSubsetSize<=n;++leftSubsetSize) {\\n            int rightSubsetSize = n - leftSubsetSize;\\n            \\n            for(int sum : left.get(leftSubsetSize)) {\\n                int minDiffLocal = (int) Math.abs(\\n                    findMinimalDifference(sum, right.get(rightSubsetSize), totalSum)\\n                );\\n                minDiff = Integer.min(minDiff, minDiffLocal);\\n            }\\n        }\\n        \\n        return minDiff;\\n    }\\n    \\n    /**\\n     * O(log(right.size()))\\n     */\\n    private int findMinimalDifference(int leftSum, List<Integer> right, int totalSum) {\\n        int low = 0, high = right.size()-1;\\n        int diff = 0, minDiff = Integer.MAX_VALUE;\\n        \\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            diff = totalSum - 2*leftSum - 2*right.get(mid);\\n            minDiff = Integer.min(Math.abs(diff), minDiff);\\n            \\n            if (diff == 0)\\n                return 0;\\n            else if (diff > 0) low = mid+1;\\n            else high = mid-1;\\n        }\\n        \\n        return Integer.min(Math.abs(diff), minDiff);\\n    }\\n    \\n    /**\\n     * O(2^n)\\n     * 1 <= n <= 15 => 2^n ~ 2^15 = ~32k\\n     */\\n    private void fillSubsetSum(int[] nums, int low, int high, List<List<Integer>> resArray) {\\n        int n = high - low + 1;\\n        \\n        for(int i=0;i<(int)Math.pow(2, n);++i) {\\n            int subsetSum = 0;\\n            int size = 0;\\n            for(int j=0;j<16;++j) {\\n                if ((i & (1<<j)) > 0 && low+j<nums.length) {\\n                    subsetSum += nums[low+j];\\n                    ++size;\\n                }\\n            }\\n            \\n            resArray.get(size).add(subsetSum);\\n        }\\n        \\n        for(List<Integer> list : resArray) Collections.sort(list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524056,
                "title": "meet-in-the-middle-binary-search-bitmask-dp-o-n-2-n-2",
                "content": "```\\n#define ll long long int\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\nclass Solution {\\n    ll pw2[20],tot,ans;\\npublic:\\n    // returns the count of set bits in a number\\n    int count(ll n){\\n        ll cnt=0;\\n        while(n){\\n            if(n&1)\\n                cnt++;\\n            n>>=1;\\n        }\\n        return cnt;\\n    }\\n    \\n    // returns the sums of various bitmasks\\n    // ans[i]--contains the sum of all possible bitmasks with i set-bits\\n    vector<vector<ll>> get(vector<int>& a){\\n        int i=0,n=a.size();\\n        int mask=(1<<n);\\n        vector<vector<ll>> ans(n+2);\\n        \\n        for(i=0;i<mask;i++){\\n            int s=0,cnt=count(i);\\n            for(int j=0;j<n;j++){\\n                if(i&pw2[j])\\n                    s+=a[j];\\n            }\\n            ans[cnt].push_back(s);\\n        }\\n        \\n        for(i=0;i<=n;i++)\\n            if(ans[i].size())\\n                sort(ans[i].begin(),ans[i].end());\\n        \\n        return ans;\\n    }    \\n    \\n    // binary-search\\n    void bs(vector<ll>& a,ll s1){\\n        int l=0,r=a.size()-1;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            ll curr=tot-2*s1-2*a[m];\\n            ans=min(ans,abs(curr));\\n            if(curr>0)\\n                l=m+1;\\n            else\\n                r=m-1;\\n        }\\n    }\\n    \\n    int minimumDifference(vector<int>& a) {\\n        IOS;\\n        int i,n=a.size();\\n        int m=n/2;\\n        \\n        ans=INT_MAX;\\n        tot=0;\\n        for(auto e:a)\\n            tot+=e;\\n        \\n        pw2[0]=1;\\n        for(i=1;i<20;i++)\\n            pw2[i]=pw2[i-1]<<1;\\n        \\n        vector<int> l,r;\\n        for(i=0;i<m;i++)\\n            l.push_back(a[i]);\\n        \\n        for(i=m;i<n;i++)\\n            r.push_back(a[i]);\\n        \\n        vector<vector<ll>> left=get(l);\\n        vector<vector<ll>> right=get(r);\\n        \\n        for(int i=0;i<=m;i++)\\n            for(auto e:left[i])\\n                bs(right[m-i],e);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Binary Tree",
                    "Bitmask"
                ],
                "code": "```\\n#define ll long long int\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\nclass Solution {\\n    ll pw2[20],tot,ans;\\npublic:\\n    // returns the count of set bits in a number\\n    int count(ll n){\\n        ll cnt=0;\\n        while(n){\\n            if(n&1)\\n                cnt++;\\n            n>>=1;\\n        }\\n        return cnt;\\n    }\\n    \\n    // returns the sums of various bitmasks\\n    // ans[i]--contains the sum of all possible bitmasks with i set-bits\\n    vector<vector<ll>> get(vector<int>& a){\\n        int i=0,n=a.size();\\n        int mask=(1<<n);\\n        vector<vector<ll>> ans(n+2);\\n        \\n        for(i=0;i<mask;i++){\\n            int s=0,cnt=count(i);\\n            for(int j=0;j<n;j++){\\n                if(i&pw2[j])\\n                    s+=a[j];\\n            }\\n            ans[cnt].push_back(s);\\n        }\\n        \\n        for(i=0;i<=n;i++)\\n            if(ans[i].size())\\n                sort(ans[i].begin(),ans[i].end());\\n        \\n        return ans;\\n    }    \\n    \\n    // binary-search\\n    void bs(vector<ll>& a,ll s1){\\n        int l=0,r=a.size()-1;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            ll curr=tot-2*s1-2*a[m];\\n            ans=min(ans,abs(curr));\\n            if(curr>0)\\n                l=m+1;\\n            else\\n                r=m-1;\\n        }\\n    }\\n    \\n    int minimumDifference(vector<int>& a) {\\n        IOS;\\n        int i,n=a.size();\\n        int m=n/2;\\n        \\n        ans=INT_MAX;\\n        tot=0;\\n        for(auto e:a)\\n            tot+=e;\\n        \\n        pw2[0]=1;\\n        for(i=1;i<20;i++)\\n            pw2[i]=pw2[i-1]<<1;\\n        \\n        vector<int> l,r;\\n        for(i=0;i<m;i++)\\n            l.push_back(a[i]);\\n        \\n        for(i=m;i<n;i++)\\n            r.push_back(a[i]);\\n        \\n        vector<vector<ll>> left=get(l);\\n        vector<vector<ll>> right=get(r);\\n        \\n        for(int i=0;i<=m;i++)\\n            for(auto e:left[i])\\n                bs(right[m-i],e);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1515443,
                "title": "python-divide-the-array-into-halves-and-binary-search",
                "content": "The idea is the same as other submissions: Divide the array into halves and use binary search.\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 2\\n        total = sum(nums)\\n        target = total // 2\\n        \\n        def sums(arr):\\n            subs = {0 : {0}}\\n            for k in range(1, n + 1):\\n                subs[k] = {sum(comb) for comb in itertools.combinations(arr, k)}\\n            return subs\\n        \\n        first_half = sums(nums[: n])\\n        second_half = sums(nums[n :])\\n\\n        def search():\\n            for k in second_half:\\n                half = [float(\"-inf\"), *sorted(first_half[n - k]), float(\"inf\")]\\n                for x in second_half[k]:\\n                    idx = bisect.bisect_left(half, target - x)\\n                    for y in half[idx - 1 : idx + 1]:\\n                        yield abs(2*(x + y) - total)\\n\\n        return min(search())\\n```\\n\\nThe same idea can be used to solve questions:\\nhttps://leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/\\nhttps://leetcode.com/problems/closest-subsequence-sum/",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 2\\n        total = sum(nums)\\n        target = total // 2\\n        \\n        def sums(arr):\\n            subs = {0 : {0}}\\n            for k in range(1, n + 1):\\n                subs[k] = {sum(comb) for comb in itertools.combinations(arr, k)}\\n            return subs\\n        \\n        first_half = sums(nums[: n])\\n        second_half = sums(nums[n :])\\n\\n        def search():\\n            for k in second_half:\\n                half = [float(\"-inf\"), *sorted(first_half[n - k]), float(\"inf\")]\\n                for x in second_half[k]:\\n                    idx = bisect.bisect_left(half, target - x)\\n                    for y in half[idx - 1 : idx + 1]:\\n                        yield abs(2*(x + y) - total)\\n\\n        return min(search())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514894,
                "title": "go-o-2-n-split-in-two-brute-force-one-and-binary-search-other",
                "content": "Similar to many other examples here.\\n\\n* The best possible partition minimizes the distance to half of the total sum.\\n* Brute-force collecting sums from the entire input is too expensive.\\n* Brute-forcing collecting sums from half of the input can be done in (2^15 ~= 32k operations). Cheap!\\n* The trick is to to split the input into two halves, then match `k` items from one half with `n-k` items from the other half.\\n* Possible sums for one half is sorted to enable binary search.\\n* If the total sum is not divisible by 2, then 1 needs to be added when calculating the optimal distance from a partition. This is because the search finds the partition closest to half of the total sum, and that side will be 1 closer than the other partition.\\n\\nApproach:\\n\\n1. Calculate total sum. The goal is to find a partition sum close to half of that sum.\\n2. Split nums into left (`nums[:n]`) and right `(nums[n:])` halves.\\n3. Collect all possible sums for either side. This could be optimized so that only one side is collected, but I opted for a non-optimal solution with less code.\\n4. Sort possible sums in the left side.\\n5. For each sum on the right side that uses `k` items, match it with a sum on the left side that uses `n-k` items using binary search. Keep track of the minimum distance to the center point (half of total sum).\\n6. If the total sum is odd, add 1 to the minimum partition distance.\\n\\n### Complexity\\n\\n* The total number of possible partitions on either side is `2^n`.\\n* The number of possible sums for a given `k` is the binomial coefficient (*n choose k*).\\n* The max number of permutations of size `k` is given by the largest binomial coefficient, also known as the central binomial coefficient. It\\'s [upper-bound approximation](https://en.wikipedia.org/wiki/Central_binomial_coefficient#Approximations) is `4^(n/2)`.\\n* Sorting is done in O(n * 4^(n/2) * log(4^(n/2))) => O(4^(n/2))\\n* Searching is done in O(log(4^(n/2))) => O(n/2)\\n* This gives O(2^n * log(4^(n/2)) + 4^(n/2)) => O(2^n+4^(n/2)) => O(2^n)\\n\\n```go\\nfunc minimumDifference(nums []int) int {\\n\\tn := len(nums) / 2\\n\\tleft, right := nums[:n], nums[n:]\\n\\tleftSums := make([][]int, n+1)\\n\\trightSums := make([][]int, n+1)\\n\\tvar sum int\\n\\tfor _, num := range nums {\\n\\t\\tsum += num\\n\\t}\\n\\tcollectPossibleSums(0, n, 0, 0, left, &leftSums)\\n\\tcollectPossibleSums(0, n, 0, 0, right, &rightSums)\\n\\tfor k := range leftSums {\\n\\t\\tsort.Ints(leftSums[k])\\n\\t}\\n\\thalfSum := sum / 2\\n\\tminDist := math.MaxInt32\\n\\t// pick k numbers from rightSums\\n\\tfor k := range rightSums {\\n\\t\\tfor _, rightSum := range rightSums[k] {\\n\\t\\t    // and n-k numbers from the right side\\n\\t\\t\\tremains := n - k\\n\\t\\t\\toptions := leftSums[remains]\\n\\t\\t\\tif len(options) == 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\t// Search for closest match\\n\\t\\t\\t// recall that searchInts finds the place where the given number would\\n\\t\\t\\t// be inserted. That position can be both before and after the optimal\\n\\t\\t\\t// match, and beyond the size of the slice.\\n\\t\\t\\tidx := sort.SearchInts(options, halfSum-rightSum)\\n\\t\\t\\t\\n\\t\\t\\tif idx != len(options) {\\n\\t\\t\\t\\tminDist = min(minDist, 2*abs(rightSum+options[idx]-halfSum))\\n\\t\\t\\t}\\n\\t\\t\\tif idx != 0 {\\n\\t\\t\\t\\tminDist = min(minDist, 2*abs(rightSum+options[idx-1]-halfSum))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif abs(sum)%2 == 1 {\\n\\t\\tminDist += 1\\n\\t}\\n\\treturn minDist\\n}\\n\\nfunc collectPossibleSums(i, n, nitems, currSum int, nums []int, output *[][]int) {\\n\\tif i == n {\\n\\t\\t(*output)[nitems] = append((*output)[nitems], currSum)\\n\\t\\treturn\\n\\t}\\n\\tcollectPossibleSums(i+1, n, nitems+1, currSum+nums[i], nums, output) // pick\\n\\tcollectPossibleSums(i+1, n, nitems, currSum, nums, output)           // skip\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc abs(a int) int {\\n\\tif a < 0 {\\n\\t\\treturn -a\\n\\t}\\n\\treturn a\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minimumDifference(nums []int) int {\\n\\tn := len(nums) / 2\\n\\tleft, right := nums[:n], nums[n:]\\n\\tleftSums := make([][]int, n+1)\\n\\trightSums := make([][]int, n+1)\\n\\tvar sum int\\n\\tfor _, num := range nums {\\n\\t\\tsum += num\\n\\t}\\n\\tcollectPossibleSums(0, n, 0, 0, left, &leftSums)\\n\\tcollectPossibleSums(0, n, 0, 0, right, &rightSums)\\n\\tfor k := range leftSums {\\n\\t\\tsort.Ints(leftSums[k])\\n\\t}\\n\\thalfSum := sum / 2\\n\\tminDist := math.MaxInt32\\n\\t// pick k numbers from rightSums\\n\\tfor k := range rightSums {\\n\\t\\tfor _, rightSum := range rightSums[k] {\\n\\t\\t    // and n-k numbers from the right side\\n\\t\\t\\tremains := n - k\\n\\t\\t\\toptions := leftSums[remains]\\n\\t\\t\\tif len(options) == 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\t// Search for closest match\\n\\t\\t\\t// recall that searchInts finds the place where the given number would\\n\\t\\t\\t// be inserted. That position can be both before and after the optimal\\n\\t\\t\\t// match, and beyond the size of the slice.\\n\\t\\t\\tidx := sort.SearchInts(options, halfSum-rightSum)\\n\\t\\t\\t\\n\\t\\t\\tif idx != len(options) {\\n\\t\\t\\t\\tminDist = min(minDist, 2*abs(rightSum+options[idx]-halfSum))\\n\\t\\t\\t}\\n\\t\\t\\tif idx != 0 {\\n\\t\\t\\t\\tminDist = min(minDist, 2*abs(rightSum+options[idx-1]-halfSum))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif abs(sum)%2 == 1 {\\n\\t\\tminDist += 1\\n\\t}\\n\\treturn minDist\\n}\\n\\nfunc collectPossibleSums(i, n, nitems, currSum int, nums []int, output *[][]int) {\\n\\tif i == n {\\n\\t\\t(*output)[nitems] = append((*output)[nitems], currSum)\\n\\t\\treturn\\n\\t}\\n\\tcollectPossibleSums(i+1, n, nitems+1, currSum+nums[i], nums, output) // pick\\n\\tcollectPossibleSums(i+1, n, nitems, currSum, nums, output)           // skip\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc abs(a int) int {\\n\\tif a < 0 {\\n\\t\\treturn -a\\n\\t}\\n\\treturn a\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513770,
                "title": "200-200-test-cases-passed-but-took-too-long",
                "content": "# Screw LeetCode\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n=(int)nums.size()/2,tot=0;\\n        for(int i=0;i<2*n;i++){\\n            nums[i]*=2;\\n            tot+=nums[i];\\n        }\\n        vector<set<int>>ca(n+1),cb(n+1);\\n        for(int s=0;s<1<<n;s++){\\n            int k=__builtin_popcount(s),sa=0,sb=0;\\n            for(int i=0;i<n;i++){\\n                sa+=(s>>i&1)*nums[i];\\n                sb+=(s>>i&1)*nums[n+i];\\n            }\\n            ca[k].insert(sa);\\n            cb[k].insert(sb);\\n        }\\n        int ans=2e9,tar=tot/2;\\n        for(int k=0;k<=n;k++){\\n            for(int a:ca[n-k]){\\n                auto b=cb[k].lower_bound(tar-a);\\n                int dif=2e9;\\n                if(b!=cb[k].end())dif=abs(tar-(a+*b));\\n                if(b!=cb[k].begin())dif=min(dif,abs(tar-(a+*prev(b))));\\n                ans=min(ans,2*dif);\\n            }\\n        }\\n        return ans/2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n=(int)nums.size()/2,tot=0;\\n        for(int i=0;i<2*n;i++){\\n            nums[i]*=2;\\n            tot+=nums[i];\\n        }\\n        vector<set<int>>ca(n+1),cb(n+1);\\n        for(int s=0;s<1<<n;s++){\\n            int k=__builtin_popcount(s),sa=0,sb=0;\\n            for(int i=0;i<n;i++){\\n                sa+=(s>>i&1)*nums[i];\\n                sb+=(s>>i&1)*nums[n+i];\\n            }\\n            ca[k].insert(sa);\\n            cb[k].insert(sb);\\n        }\\n        int ans=2e9,tar=tot/2;\\n        for(int k=0;k<=n;k++){\\n            for(int a:ca[n-k]){\\n                auto b=cb[k].lower_bound(tar-a);\\n                int dif=2e9;\\n                if(b!=cb[k].end())dif=abs(tar-(a+*b));\\n                if(b!=cb[k].begin())dif=min(dif,abs(tar-(a+*prev(b))));\\n                ans=min(ans,2*dif);\\n            }\\n        }\\n        return ans/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513482,
                "title": "optimize-brute-force-combination-with-binary-search",
                "content": "This question is the equivalent of saying picking n elements, with the sum as near as possible to half the total sum of the array.\\n\\nThe initial thought would be to pick n out of 2n and compute sum, which would lead to O(Combination(2 * n, n)), that is 155117520 for n = 15, so got TLE in Java.\\n\\nOn second thoughts, this would be equivalent as say, we divide array into first n half and second n half, then pick i from first half and n - i from second half, and make sum(i) + sum(n - i) as near as possible to half the total sum, where i in (0, n)\\n\\nWe can perform this computation by matching every result from first half onto every result of second half, which is equivalent to O(Combination(2 * n, n)), but since we\\'re looking for a number as near as half the total sum, we can perform a binary search on every result of second half.\\n\\nFor example, say we have n = 15, and we want to know what is the nearest possible when we pick 1 from first half, and 14 from second half.\\n\\nPicking 1 from first half will lead to 15 possible sums, picking 14 from second half will also lead to 15 possible sums. We can do 15 * 15 adds to get the nearest to half total sum, or we could do 15 * log(15) adds to get the nearest half (similar to two sum). This will dramatically reduce the number of adds we need to do -> reduce from N to log(N). Picking 7 from 15 will lead to 6435 possible sums, and instead of doing 6435 * 6435 adds, we\\'ll just do 6435 * log(6435) adds.\\n\\n```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length / 2;\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n\\t\\t\\n\\t\\t// split into first and second half (in fact we do not even need the sort, just easier to calculate upper bound this way)\\n        int[] firstHalf = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            firstHalf[i] = nums[i];\\n        }\\n        int[] secondHalf = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            secondHalf[i] = nums[n + i];\\n        }\\n        \\n        int firstSum = 0;\\n        for (int num : firstHalf) firstSum += num;\\n        \\n        int minimal = Math.abs(sum - 2 * firstSum);\\n        for (int i = 1; i < n; i++) {\\n            int other = n - i; // pick i from first half and pick other from second half\\n            List<Integer> firstList = new ArrayList<>();\\n            helper(firstHalf, 0, 0, 0, i, firstList);\\n            TreeSet<Integer> set = new TreeSet<>(firstList); // prepare for binary search\\n            \\n            List<Integer> secondList = new ArrayList<>();\\n            helper(secondHalf, 0, 0, 0, other, secondList);\\n            for (int second : secondList) {\\n                int target = sum / 2 - second;\\n                Integer floor = set.floor(target); // search for a smaller value\\n                if (floor != null) {\\n                    int curSum = second + floor;\\n                    int curAbs = Math.abs(sum - curSum * 2);\\n                    if (curAbs < minimal) {\\n                        minimal = curAbs;\\n                    }\\n                }\\n                Integer ceiling = set.ceiling(target); // search for a larget value\\n                if (ceiling != null) {\\n                    int curSum = second + ceiling;\\n                    int curAbs = Math.abs(sum - curSum * 2);\\n                    if (curAbs < minimal) {\\n                        minimal = curAbs;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return minimal;\\n    }\\n    \\n    private void helper(int[] nums, int ptr, int pickedCount, int sum, int targetCount, List<Integer> vals) { // calculate all possible sums when picking targetCount from array\\n        if (pickedCount > targetCount) return;\\n        \\n        if (pickedCount == targetCount) {\\n            vals.add(sum);\\n            return;\\n        }\\n        \\n        if (ptr == nums.length) return;\\n        \\n        helper(nums, ptr + 1, pickedCount, sum, targetCount, vals);\\n        helper(nums, ptr + 1, pickedCount + 1, sum + nums[ptr], targetCount, vals);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length / 2;\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n\\t\\t\\n\\t\\t// split into first and second half (in fact we do not even need the sort, just easier to calculate upper bound this way)\\n        int[] firstHalf = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            firstHalf[i] = nums[i];\\n        }\\n        int[] secondHalf = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            secondHalf[i] = nums[n + i];\\n        }\\n        \\n        int firstSum = 0;\\n        for (int num : firstHalf) firstSum += num;\\n        \\n        int minimal = Math.abs(sum - 2 * firstSum);\\n        for (int i = 1; i < n; i++) {\\n            int other = n - i; // pick i from first half and pick other from second half\\n            List<Integer> firstList = new ArrayList<>();\\n            helper(firstHalf, 0, 0, 0, i, firstList);\\n            TreeSet<Integer> set = new TreeSet<>(firstList); // prepare for binary search\\n            \\n            List<Integer> secondList = new ArrayList<>();\\n            helper(secondHalf, 0, 0, 0, other, secondList);\\n            for (int second : secondList) {\\n                int target = sum / 2 - second;\\n                Integer floor = set.floor(target); // search for a smaller value\\n                if (floor != null) {\\n                    int curSum = second + floor;\\n                    int curAbs = Math.abs(sum - curSum * 2);\\n                    if (curAbs < minimal) {\\n                        minimal = curAbs;\\n                    }\\n                }\\n                Integer ceiling = set.ceiling(target); // search for a larget value\\n                if (ceiling != null) {\\n                    int curSum = second + ceiling;\\n                    int curAbs = Math.abs(sum - curSum * 2);\\n                    if (curAbs < minimal) {\\n                        minimal = curAbs;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return minimal;\\n    }\\n    \\n    private void helper(int[] nums, int ptr, int pickedCount, int sum, int targetCount, List<Integer> vals) { // calculate all possible sums when picking targetCount from array\\n        if (pickedCount > targetCount) return;\\n        \\n        if (pickedCount == targetCount) {\\n            vals.add(sum);\\n            return;\\n        }\\n        \\n        if (ptr == nums.length) return;\\n        \\n        helper(nums, ptr + 1, pickedCount, sum, targetCount, vals);\\n        helper(nums, ptr + 1, pickedCount + 1, sum + nums[ptr], targetCount, vals);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513431,
                "title": "python-meet-in-the-middle",
                "content": "We can either generate all the possible sums, or find the closest sum to a given target.\\nHowever, there are potentially `math.comb(30, 15) = 155117520` possible sums for the former, and the same number of targets we may want to search for for the latter. If we meet in the middle, i.e. search for the closest sum to a given target for the 1st half, and then just generate all the possible sums for the 2nd half, both numbers are *just* manageable:\\n\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        total = sum(nums)\\n        half = total // 2\\n        n = len(nums)        \\n        @functools.lru_cache(None)\\n        def options(i, to_pick):\\n            if not to_pick:\\n                return [0]\\n            if i == n:\\n                return []\\n            it = heapq.merge(options(i + 1, to_pick), [e + nums[i] for e in options(i + 1, to_pick - 1)])\\n            return [k for k, _ in itertools.groupby(it)]\\n        \\n        @functools.lru_cache(None)\\n        def dp(i, to_pick, target):\\n            if not to_pick:\\n                return 0\\n            if i == n:\\n                return math.inf\\n            if i < n // 2:\\n                ans1 = dp(i + 1, to_pick, target)\\n                ans2 = dp(i + 1, to_pick - 1, target - nums[i]) + nums[i]\\n                diff1 = abs(target - ans1)\\n                diff2 = abs(target - nums[i] - dp(i + 1, to_pick - 1, target - nums[i]))\\n                if diff1 < diff2:\\n                    return ans1\\n                elif diff1 == diff2:\\n                    return max(ans1, ans2)\\n                else:\\n                    return ans2\\n            else:\\n                op = options(i, to_pick)\\n                index = bisect.bisect(op, target)\\n                ans = math.inf\\n                if index < len(op):\\n                    ans = op[index]\\n                if index and abs(op[index - 1] - target) < abs(ans - target):\\n                    ans = op[index - 1]\\n                return ans\\n        \\n        closest = dp(1, n // 2 - 1, half - nums[0]) + nums[0]\\n        return abs(total - 2 * closest)\\n```\\nI probably over-optimized a bit by forcing the partition we use to include the first element (and prefer the larger sum when the absolute value of the difference is the same, in case of odd total sum).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        total = sum(nums)\\n        half = total // 2\\n        n = len(nums)        \\n        @functools.lru_cache(None)\\n        def options(i, to_pick):\\n            if not to_pick:\\n                return [0]\\n            if i == n:\\n                return []\\n            it = heapq.merge(options(i + 1, to_pick), [e + nums[i] for e in options(i + 1, to_pick - 1)])\\n            return [k for k, _ in itertools.groupby(it)]\\n        \\n        @functools.lru_cache(None)\\n        def dp(i, to_pick, target):\\n            if not to_pick:\\n                return 0\\n            if i == n:\\n                return math.inf\\n            if i < n // 2:\\n                ans1 = dp(i + 1, to_pick, target)\\n                ans2 = dp(i + 1, to_pick - 1, target - nums[i]) + nums[i]\\n                diff1 = abs(target - ans1)\\n                diff2 = abs(target - nums[i] - dp(i + 1, to_pick - 1, target - nums[i]))\\n                if diff1 < diff2:\\n                    return ans1\\n                elif diff1 == diff2:\\n                    return max(ans1, ans2)\\n                else:\\n                    return ans2\\n            else:\\n                op = options(i, to_pick)\\n                index = bisect.bisect(op, target)\\n                ans = math.inf\\n                if index < len(op):\\n                    ans = op[index]\\n                if index and abs(op[index - 1] - target) < abs(ans - target):\\n                    ans = op[index - 1]\\n                return ans\\n        \\n        closest = dp(1, n // 2 - 1, half - nums[0]) + nums[0]\\n        return abs(total - 2 * closest)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513364,
                "title": "meet-in-middle-o-2-n-log-2-n-gets-tle",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<ll> a, b;\\n    ll s = 0;\\n    ll n = 0, n2 = 0;\\n    ll best = 0;\\n    vector<set<ll>> first, second;\\n    void search(ll p, ll c, ll cur, vector<ll> &a, vector<set<ll>> &first) {\\n        first[c].insert(cur);\\n        //cout << p << \" \"<< c <<\" \"<<cur<<\":\\\\n\";\\n        if (p >= a.size()) {\\n            return;\\n        }\\n        \\n        // not pick\\n        search(p+1, c, cur, a, first);\\n        // pick\\n        search(p+1, c+1, cur+a[p], a, first);\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        n2 = nums.size();\\n        n = n2/2;\\n        ll low = pow(10, 7);\\n        for (auto i: nums) {\\n            low = min(low, (ll)i);\\n        }\\n        for (int i = 0; i < n2; i++) {\\n            ll t = nums[i] - low;\\n            s += t;\\n            if (i < n) {\\n                a.push_back(t);    \\n            } else {\\n                b.push_back(t);\\n            }\\n        }\\n        first = vector<set<ll>> (20);\\n        second = vector<set<ll>> (20);\\n        best = s;\\n        search(0, 0, 0, a, first);\\n        search(0, 0, 0, b, second);\\n        ll ss = s/2;\\n        for (int i = 0; i <= n; i++) {\\n            int j = n - i;\\n            for (auto s1 : first[i]) {\\n                ll target = ss - s1;\\n                auto p = second[j].lower_bound(target);\\n                if (p != second[j].end()) {\\n                    best = min(best, abs(2*((*p) + s1) - s));\\n                }\\n                if (second[j].size() > 0 && p != second[j].begin()) {\\n                    p = prev(p);\\n                    best = min(best, abs(2*((*p) + s1) - s));\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<ll> a, b;\\n    ll s = 0;\\n    ll n = 0, n2 = 0;\\n    ll best = 0;\\n    vector<set<ll>> first, second;\\n    void search(ll p, ll c, ll cur, vector<ll> &a, vector<set<ll>> &first) {\\n        first[c].insert(cur);\\n        //cout << p << \" \"<< c <<\" \"<<cur<<\":\\\\n\";\\n        if (p >= a.size()) {\\n            return;\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 4081959,
                "title": "meet-in-the-middle-using-template",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n2*N <= 30. So this has to be some sort of bitmask or meet in the middle. Meet in the middle template: map + brute recursion to save values for 2 halves. Then use max/min/value of the answer to find appropriate value from second half iterating over only the first half.\\n\\nMeet in the middle: We divide the array into N/2 parts. We pick some parts from one half and the rest from another. So we have to save all the sums we can get from a particular count of elements from both sides. We can do this using a simple recursion rec(i, k, sum) and store map[k] = sum after i reached the end. Since there are many sums, we can maintain a map<int, vector<int>> instead for both halves. \\n\\nNow we want to find the appropriate element from the second half map for each element in the first half. If the current first half element is map1[count][i], we have to look in map2[N/2 - count]. We will only want the element x that will make abs(sum - 2*(map1[count][i] + x)) the minimum possible. So we can use binary search on map2[N/2 - count]. \\n\\nSo we have to sort the vectors first. If sorting within a loop iterating over the map elements we have to iterate by reference (auto& ele : map1) so that the sorting reflects in the map itself.\\n\\nClearly at some point the absolute difference above becomes minimum in the sorted array after which it starts increasing. So we can try to find the largest index x such that the absolute difference is lower than using x-1. We can set ans as 0 and search from 1 to size-1. However, this is not a monotone function on the array as the array can have repeating elements with the same abs difference. So we should remove the repeating elements first before running binary search.\\n\\n# Complexity\\n- Time complexity: 2^N/2 for each recursion. All the arrays combined in either map can have at most 2^N/2 elements. Sorting one of the \"maps\" can be at most 2^N/2*log(2^N/2) = N/2 * 2^N/2. Then iterating over each element of a map is again N/2 * 2^N/2 at most. The binary search for each element is log(2^N/2) ~ N/2 at most. So the total complexity is N^2/4 * 2^N/2 + N/2 * 2^N/2 + 2^N/2 ~ O(N^2$\\\\times$2^(N/2)) for N<=30 which is ~1000 * 30000 ~ 3 x 10^7 which is fine.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> arr;\\n    int sum;\\n\\n    \\n    void recHalf(int i, int end, int k, int sum, map<int,vector<int>>& mp)\\n    {\\n        if(i >= end)\\n        {\\n            mp[k].push_back(sum);\\n        }\\n        else\\n        {\\n            recHalf(i+1, end, k, sum, mp);\\n            recHalf(i+1, end, k+1, sum+arr[i], mp);\\n        }\\n    }\\n\\n    int diff(int x)\\n    {\\n        return abs(sum - 2*x);\\n    }\\n\\n    int bsearch(vector<int>& a, int& val)\\n    {\\n        // we want x from a such that abs(sum - (val + x) - (val + x)) is minimum\\n        \\n        int lo = 1;\\n        int hi = (int)a.size() - 1;\\n        int ans = 0;\\n\\n        while(lo <= hi)\\n        {\\n            int mid = lo + (hi - lo)/2;\\n            if(diff(val + a[mid]) < diff(val + a[mid-1]))\\n            {\\n                ans = mid;\\n                lo = mid+1;\\n            }\\n            else\\n            {\\n                hi = mid-1;\\n            }\\n        }\\n\\n        return diff(val + a[ans]);\\n    }\\n    \\n    int minimumDifference(vector<int>& nums) {\\n\\n        map<int, vector<int>> firstHalfSums;\\n        map<int, vector<int>> secondHalfSums;\\n\\n        n = (int)nums.size();\\n        sum = 0;\\n\\n        for(int i = 0; i<n; i++)\\n        {\\n            sum += nums[i];\\n        }\\n\\n        arr.assign(nums.begin(), nums.begin()+n);\\n        recHalf(0, n/2, 0, 0, firstHalfSums);\\n        recHalf(n/2, n, 0, 0, secondHalfSums);\\n\\n        for(auto& pair : secondHalfSums)\\n        {\\n            sort(pair.second.begin(), pair.second.end());\\n            auto len = std::unique(pair.second.begin(), pair.second.end());\\n            pair.second.resize(std::distance(pair.second.begin(), len));\\n        }\\n\\n        int min_diff = INT_MAX;\\n\\n        for(auto ele : firstHalfSums)\\n        {\\n            int count = ele.first;\\n            for(auto val : ele.second)\\n            {\\n                int ans = bsearch(secondHalfSums[n/2 - count], val);\\n                min_diff = min(min_diff, ans);\\n            }\\n        }\\n\\n        return min_diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> arr;\\n    int sum;\\n\\n    \\n    void recHalf(int i, int end, int k, int sum, map<int,vector<int>>& mp)\\n    {\\n        if(i >= end)\\n        {\\n            mp[k].push_back(sum);\\n        }\\n        else\\n        {\\n            recHalf(i+1, end, k, sum, mp);\\n            recHalf(i+1, end, k+1, sum+arr[i], mp);\\n        }\\n    }\\n\\n    int diff(int x)\\n    {\\n        return abs(sum - 2*x);\\n    }\\n\\n    int bsearch(vector<int>& a, int& val)\\n    {\\n        // we want x from a such that abs(sum - (val + x) - (val + x)) is minimum\\n        \\n        int lo = 1;\\n        int hi = (int)a.size() - 1;\\n        int ans = 0;\\n\\n        while(lo <= hi)\\n        {\\n            int mid = lo + (hi - lo)/2;\\n            if(diff(val + a[mid]) < diff(val + a[mid-1]))\\n            {\\n                ans = mid;\\n                lo = mid+1;\\n            }\\n            else\\n            {\\n                hi = mid-1;\\n            }\\n        }\\n\\n        return diff(val + a[ans]);\\n    }\\n    \\n    int minimumDifference(vector<int>& nums) {\\n\\n        map<int, vector<int>> firstHalfSums;\\n        map<int, vector<int>> secondHalfSums;\\n\\n        n = (int)nums.size();\\n        sum = 0;\\n\\n        for(int i = 0; i<n; i++)\\n        {\\n            sum += nums[i];\\n        }\\n\\n        arr.assign(nums.begin(), nums.begin()+n);\\n        recHalf(0, n/2, 0, 0, firstHalfSums);\\n        recHalf(n/2, n, 0, 0, secondHalfSums);\\n\\n        for(auto& pair : secondHalfSums)\\n        {\\n            sort(pair.second.begin(), pair.second.end());\\n            auto len = std::unique(pair.second.begin(), pair.second.end());\\n            pair.second.resize(std::distance(pair.second.begin(), len));\\n        }\\n\\n        int min_diff = INT_MAX;\\n\\n        for(auto ele : firstHalfSums)\\n        {\\n            int count = ele.first;\\n            for(auto val : ele.second)\\n            {\\n                int ans = bsearch(secondHalfSums[n/2 - count], val);\\n                min_diff = min(min_diff, ans);\\n            }\\n        }\\n\\n        return min_diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072226,
                "title": "very-fast-python3-solution-698-ms-faster-than-100-solutions-meet-in-middle-2-pointers",
                "content": "# Complexity\\n- Time complexity: $$O(2^n \\\\cdot n^{1.5})$$\\n<!-- Add your time complexity here, e.g. $$O(2^n)$$ -->\\n\\n- Space complexity: $$O(2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(2^n)$$ -->\\n\\n\\nTime complexity of `get_subsets_sums` is $$O(2^n)$$,\\ntime complexity of `calc` is $$O(n \\\\cdot k \\\\cdot log(k))$$,\\nwhere $$k = O(C^{n/2}_n)$$.\\n\\nUsing Stirling\\'s approximation ([wiki](https://en.wikipedia.org/wiki/Stirling%27s_approximation)) got $$k = O(2^n \\\\cdot n ^ {-0.5})$$, and $$log(k) = O(n)$$.\\n\\nAnd finally\\n$$n \\\\cdot k \\\\cdot log(k) = O(n) \\\\cdot O(2^n \\\\cdot n ^ {-0.5}) \\\\cdot O(n) = O(2^n \\\\cdot n^{1.5})$$.\\n\\n\\n# Code\\n``` python3 []\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        half = n // 2\\n\\n        full_sum = sum(nums)\\n        half_sum = full_sum // 2\\n\\n        # check if left and right part is optimal\\n        if sum(nums[: half]) == half_sum:\\n            # here and further\\n            # (full_sum - 2 * half_sum) is equivalent (full_sum % 2) and isn\\'t equivalent (0)\\n            # because sum(nums) may be odd \\n            return full_sum - 2 * half_sum\\n        if sum(nums[half :]) == half_sum:\\n            return full_sum - 2 * half_sum\\n\\n        def get_subsets_sums(elems):\\n            result = defaultdict(set)\\n            result[0] = {0}\\n            for elem in elems:\\n                for cnt in reversed(list(result)):\\n                    result[cnt + 1].update(\\n                        value + elem\\n                        for value in result[cnt]\\n                    )\\n            return result\\n\\n        left = get_subsets_sums(nums[: half])\\n        right = get_subsets_sums(nums[half :])\\n\\n        def calc(left, right):\\n            # initial var result\\n            # find max of n-subset of nums, if sum of subset is equal or less than half_sum\\n            result = min(min(left[half]), min(right[half]))\\n            \\n            for left_cnt, left_sums in left.items():\\n                right_cnt = half - left_cnt\\n                right_sums = right[right_cnt]\\n\\n                a = sorted(left_sums)\\n                b = sorted(right_sums)\\n                m = len(a)\\n                l = len(b)\\n                i = 0\\n                j = l - 1\\n                \\n                # use 2 pointers instead of a loop in a loop\\n                while i < m and j >= 0:\\n                    current = a[i] + b[j]\\n                    if current == half_sum:\\n                        return full_sum - 2 * current\\n                    if current > half_sum:\\n                        j -= 1\\n                    else:\\n                        result = max(result, current)\\n                        i += 1\\n            \\n            return full_sum - 2 * result\\n\\n        return calc(left, right)\\n```\\n\\n#### If you found this useful or interesting, please upvote!",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "``` python3 []\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        half = n // 2\\n\\n        full_sum = sum(nums)\\n        half_sum = full_sum // 2\\n\\n        # check if left and right part is optimal\\n        if sum(nums[: half]) == half_sum:\\n            # here and further\\n            # (full_sum - 2 * half_sum) is equivalent (full_sum % 2) and isn\\'t equivalent (0)\\n            # because sum(nums) may be odd \\n            return full_sum - 2 * half_sum\\n        if sum(nums[half :]) == half_sum:\\n            return full_sum - 2 * half_sum\\n\\n        def get_subsets_sums(elems):\\n            result = defaultdict(set)\\n            result[0] = {0}\\n            for elem in elems:\\n                for cnt in reversed(list(result)):\\n                    result[cnt + 1].update(\\n                        value + elem\\n                        for value in result[cnt]\\n                    )\\n            return result\\n\\n        left = get_subsets_sums(nums[: half])\\n        right = get_subsets_sums(nums[half :])\\n\\n        def calc(left, right):\\n            # initial var result\\n            # find max of n-subset of nums, if sum of subset is equal or less than half_sum\\n            result = min(min(left[half]), min(right[half]))\\n            \\n            for left_cnt, left_sums in left.items():\\n                right_cnt = half - left_cnt\\n                right_sums = right[right_cnt]\\n\\n                a = sorted(left_sums)\\n                b = sorted(right_sums)\\n                m = len(a)\\n                l = len(b)\\n                i = 0\\n                j = l - 1\\n                \\n                # use 2 pointers instead of a loop in a loop\\n                while i < m and j >= 0:\\n                    current = a[i] + b[j]\\n                    if current == half_sum:\\n                        return full_sum - 2 * current\\n                    if current > half_sum:\\n                        j -= 1\\n                    else:\\n                        result = max(result, current)\\n                        i += 1\\n            \\n            return full_sum - 2 * result\\n\\n        return calc(left, right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043740,
                "title": "upper-lower-bound-meet-in-middle",
                "content": "# Intuition\\nmeet int the middle\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    map<int,vector<int>>mp1;\\n    map<int,vector<int>>mp2;\\n    #define all(a) a.begin(),a.end()\\n    void get_filled(int name,vector<int>&arr){\\n        int n=arr.size();\\n        for(int i=0;i<(1LL<<n);i++){\\n\\n            int mask=i;\\n            int cnt=0;\\n            while(mask){\\n                if(mask%2)cnt++;\\n                mask/=2;\\n            }\\n\\n            int sum=0;\\n            for(int j=0;j<n;j++){\\n                if((i&(1LL<<j)))sum+=arr[j];\\n            }\\n            // cout<<sum<<endl;\\n            if(name==1){\\n                mp1[cnt].push_back(2*sum);\\n            }else{\\n                mp2[cnt].push_back(2*sum);\\n            }\\n        }\\n    }\\n    \\n    int minimumDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>arr;\\n        vector<int>brr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i%2)arr.push_back(nums[i]);\\n            else brr.push_back(nums[i]);\\n            sum+=nums[i];\\n        }\\n\\n        // for(auto x:arr){\\n        //     cout<<x<<\\' \\';\\n        // }\\n        // cout<<endl;\\n        // for(auto x:brr){\\n        //     cout<<x<<\\' \\';\\n        // }\\n        // cout<<endl;\\n\\n        get_filled(1,arr);\\n        get_filled(2,brr);\\n\\n        int n2=n/2;\\n\\n        for(auto v:mp2){\\n            sort(all(mp2[v.first]));\\n            // for(int i=0;i<mp2[v.first].size();i++){\\n            //     cout<<mp2[v.first][i]<<\\' \\';\\n            // }\\n            // cout<<endl;\\n        }\\n\\n\\n\\n        int ans=1e9;\\n\\n        for(auto v:mp1){\\n            int cnt1=v.first;\\n            int cnt2=n2-cnt1;\\n\\n            for(auto x:v.second){\\n\\n                auto it =lower_bound(all(mp2[cnt2]),x-sum);\\n                if(it!=mp2[cnt2].end()){\\n                    int y=*it;\\n                    ans=min(ans,abs(x-sum+y));\\n                }\\n                it=lower_bound(all(mp2[cnt2]),sum-x);\\n                if(it!=mp2[cnt2].end()){\\n                    int y=*it;\\n                    ans=min(ans,abs(sum-x-y));\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    map<int,vector<int>>mp1;\\n    map<int,vector<int>>mp2;\\n    #define all(a) a.begin(),a.end()\\n    void get_filled(int name,vector<int>&arr){\\n        int n=arr.size();\\n        for(int i=0;i<(1LL<<n);i++){\\n\\n            int mask=i;\\n            int cnt=0;\\n            while(mask){\\n                if(mask%2)cnt++;\\n                mask/=2;\\n            }\\n\\n            int sum=0;\\n            for(int j=0;j<n;j++){\\n                if((i&(1LL<<j)))sum+=arr[j];\\n            }\\n            // cout<<sum<<endl;\\n            if(name==1){\\n                mp1[cnt].push_back(2*sum);\\n            }else{\\n                mp2[cnt].push_back(2*sum);\\n            }\\n        }\\n    }\\n    \\n    int minimumDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>arr;\\n        vector<int>brr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i%2)arr.push_back(nums[i]);\\n            else brr.push_back(nums[i]);\\n            sum+=nums[i];\\n        }\\n\\n        // for(auto x:arr){\\n        //     cout<<x<<\\' \\';\\n        // }\\n        // cout<<endl;\\n        // for(auto x:brr){\\n        //     cout<<x<<\\' \\';\\n        // }\\n        // cout<<endl;\\n\\n        get_filled(1,arr);\\n        get_filled(2,brr);\\n\\n        int n2=n/2;\\n\\n        for(auto v:mp2){\\n            sort(all(mp2[v.first]));\\n            // for(int i=0;i<mp2[v.first].size();i++){\\n            //     cout<<mp2[v.first][i]<<\\' \\';\\n            // }\\n            // cout<<endl;\\n        }\\n\\n\\n\\n        int ans=1e9;\\n\\n        for(auto v:mp1){\\n            int cnt1=v.first;\\n            int cnt2=n2-cnt1;\\n\\n            for(auto x:v.second){\\n\\n                auto it =lower_bound(all(mp2[cnt2]),x-sum);\\n                if(it!=mp2[cnt2].end()){\\n                    int y=*it;\\n                    ans=min(ans,abs(x-sum+y));\\n                }\\n                it=lower_bound(all(mp2[cnt2]),sum-x);\\n                if(it!=mp2[cnt2].end()){\\n                    int y=*it;\\n                    ans=min(ans,abs(sum-x-y));\\n                }\\n            }\\n\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4041670,
                "title": "simple-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int sum = 0;\\n        for(int num : nums) {\\n            sum += num;\\n        }\\n\\n        Map<Integer, List<Integer>> leftMap = new HashMap<>();\\n        Map<Integer, List<Integer>> rightMap = new HashMap<>();\\n\\n        \\n        int n = nums.length;\\n\\n        generateSubsetSum(nums, 0, n/2-1, leftMap);\\n        generateSubsetSum(nums, n/2, n-1, rightMap);\\n\\n        int k = sum/2;\\n        int res = Integer.MAX_VALUE;\\n\\n        for(int len : leftMap.keySet()) {\\n            List<Integer> left = leftMap.get(len);\\n            List<Integer> right = rightMap.get(nums.length/2 - len);\\n           \\n            if(right != null) {\\n                Collections.sort(right);\\n                for(int num : left) {\\n                    int target = (sum/2) - num;\\n                    int lb = findLowerBoundNumber(right, target);\\n                    res = Math.min(res, Math.abs(sum - 2*(num + lb)));\\n                }\\n            }\\n        }\\n       \\n        return res;\\n    }\\n\\n    private void generateSubsetSum(int[] nums, int left, int right, Map<Integer, List<Integer>> subsetSumMap) {\\n        int n = right - left + 1;\\n        for(int i = 0; i < (1 << n); i++) {\\n            int sum = 0;\\n            int len = 0;\\n            for(int j = 0; j < n; j++) {\\n                if((i & (1 << j)) >= 1) {\\n                    sum+=nums[left + j];\\n                    len++;\\n                }\\n            }\\n            subsetSumMap.computeIfAbsent(len, k -> new ArrayList<>()).add(sum);\\n        }\\n    }\\n\\n    private int findLowerBoundNumber(List<Integer> subsetSums, int target) {\\n        int low = 0;\\n        int high = subsetSums.size() - 1;\\n        int mid;\\n        int ans = high;\\n\\n        while(low <= high) {\\n            mid = low + (high - low)/2;\\n            if(subsetSums.get(mid) >= target) {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return subsetSums.get(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int sum = 0;\\n        for(int num : nums) {\\n            sum += num;\\n        }\\n\\n        Map<Integer, List<Integer>> leftMap = new HashMap<>();\\n        Map<Integer, List<Integer>> rightMap = new HashMap<>();\\n\\n        \\n        int n = nums.length;\\n\\n        generateSubsetSum(nums, 0, n/2-1, leftMap);\\n        generateSubsetSum(nums, n/2, n-1, rightMap);\\n\\n        int k = sum/2;\\n        int res = Integer.MAX_VALUE;\\n\\n        for(int len : leftMap.keySet()) {\\n            List<Integer> left = leftMap.get(len);\\n            List<Integer> right = rightMap.get(nums.length/2 - len);\\n           \\n            if(right != null) {\\n                Collections.sort(right);\\n                for(int num : left) {\\n                    int target = (sum/2) - num;\\n                    int lb = findLowerBoundNumber(right, target);\\n                    res = Math.min(res, Math.abs(sum - 2*(num + lb)));\\n                }\\n            }\\n        }\\n       \\n        return res;\\n    }\\n\\n    private void generateSubsetSum(int[] nums, int left, int right, Map<Integer, List<Integer>> subsetSumMap) {\\n        int n = right - left + 1;\\n        for(int i = 0; i < (1 << n); i++) {\\n            int sum = 0;\\n            int len = 0;\\n            for(int j = 0; j < n; j++) {\\n                if((i & (1 << j)) >= 1) {\\n                    sum+=nums[left + j];\\n                    len++;\\n                }\\n            }\\n            subsetSumMap.computeIfAbsent(len, k -> new ArrayList<>()).add(sum);\\n        }\\n    }\\n\\n    private int findLowerBoundNumber(List<Integer> subsetSums, int target) {\\n        int low = 0;\\n        int high = subsetSums.size() - 1;\\n        int mid;\\n        int ans = high;\\n\\n        while(low <= high) {\\n            mid = low + (high - low)/2;\\n            if(subsetSums.get(mid) >= target) {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return subsetSums.get(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011619,
                "title": "why-i-m-getting-tle-on-36-36",
                "content": "Can any one please explain why I\\'m getting TLE on [-36,36] ? I\\'ve been trying since long but could\\'nt figure out what wrong i\\'m doing..\\n\\n```\\nclass Solution {\\npublic:\\n    long long SubsetSum(int level, int sum_taken, int sum, vector<vector<long long>>& dp, vector<int>& arr, int n) \\n    {\\n        // PRUNING\\n        if (level == n) \\n        {\\n            return abs(sum_taken - (sum - sum_taken));\\n        }\\n\\n        // CACHE CHECK\\n        if (dp[level][sum_taken] != -100000000)\\n        {\\n            return dp[level][sum_taken];\\n        }\\n\\n        // COMPUTE\\n        long long include = SubsetSum(level + 1, sum_taken + arr[level], sum, dp, arr, n);\\n        long long exclude = SubsetSum(level + 1, sum_taken, sum, dp, arr, n);\\n\\n        // SAVE AND RETURN\\n        return dp[level][sum_taken] = min(include, exclude);\\n    }\\n\\n    int minimumDifference(vector<int>& nums) \\n    {\\n        int sum = 0;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) \\n        {\\n            sum += nums[i];\\n        }\\n\\n        vector<vector<long long>> dp(n, vector<long long>(sum + 1, -100000000));\\n\\n        int minDiff = SubsetSum(0, 0, sum, dp, nums, n);\\n\\n        return minDiff;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long SubsetSum(int level, int sum_taken, int sum, vector<vector<long long>>& dp, vector<int>& arr, int n) \\n    {\\n        // PRUNING\\n        if (level == n) \\n        {\\n            return abs(sum_taken - (sum - sum_taken));\\n        }\\n\\n        // CACHE CHECK\\n        if (dp[level][sum_taken] != -100000000)\\n        {\\n            return dp[level][sum_taken];\\n        }\\n\\n        // COMPUTE\\n        long long include = SubsetSum(level + 1, sum_taken + arr[level], sum, dp, arr, n);\\n        long long exclude = SubsetSum(level + 1, sum_taken, sum, dp, arr, n);\\n\\n        // SAVE AND RETURN\\n        return dp[level][sum_taken] = min(include, exclude);\\n    }\\n\\n    int minimumDifference(vector<int>& nums) \\n    {\\n        int sum = 0;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) \\n        {\\n            sum += nums[i];\\n        }\\n\\n        vector<vector<long long>> dp(n, vector<long long>(sum + 1, -100000000));\\n\\n        int minDiff = SubsetSum(0, 0, sum, dp, nums, n);\\n\\n        return minDiff;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993984,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        if (n == 2) return Math.abs(nums[1] - nums[0]);       \\n        int[][] lists1 = generate(Arrays.copyOfRange(nums, 0, n / 2));\\n        int[][] lists2 = generate(Arrays.copyOfRange(nums, n / 2, n));\\n        int ans = Integer.MAX_VALUE;\\n        for (int d = 0; d <= n / 2; d++) {\\n            int[] arr1 = lists1[d], arr2 = lists2[d];\\n            int k = arr1.length;\\n            int i1 = 0, i2 = 0; // we use two pointers to find two elements in arr1, arr2 with minimum absolute difference\\n            while (i1 < k && i2 < k) {\\n                int diff = arr1[i1] - arr2[i2];\\n                ans = Math.min(ans, Math.abs(diff));\\n                if (diff <= 0) i1++;\\n                if (diff >= 0) i2++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private static int[][] generate(int[] nums) {\\n        int n = nums.length;\\n        int total = 0;\\n        for (int num : nums) total += num;\\n        int[][] ans = new int[n + 1][];\\n        int[] pos = new int[n + 1];\\n        for (int i = 0, binomial = 1; i <= n; i++) {\\n            ans[i] = new int[binomial]; // number of ways to choose i from n = binomial(i,n)\\n            binomial = binomial * (n - i) / (i + 1);\\n        }\\n        int maxValue = 1 << n;\\n        for (int key = 0; key < maxValue; key++) {\\n            int sum1 = 0;\\n            for (int i = 0; i < n; i++) {\\n                if ((key >> i & 1) == 1) sum1 += nums[i];\\n            }\\n            int sum2 = total - sum1;\\n            int bits = Integer.bitCount(key);\\n            ans[bits][pos[bits]++] = sum1 - sum2;\\n        }\\n        for (int[] arr : ans) Arrays.sort(arr);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        if (n == 2) return Math.abs(nums[1] - nums[0]);       \\n        int[][] lists1 = generate(Arrays.copyOfRange(nums, 0, n / 2));\\n        int[][] lists2 = generate(Arrays.copyOfRange(nums, n / 2, n));\\n        int ans = Integer.MAX_VALUE;\\n        for (int d = 0; d <= n / 2; d++) {\\n            int[] arr1 = lists1[d], arr2 = lists2[d];\\n            int k = arr1.length;\\n            int i1 = 0, i2 = 0; // we use two pointers to find two elements in arr1, arr2 with minimum absolute difference\\n            while (i1 < k && i2 < k) {\\n                int diff = arr1[i1] - arr2[i2];\\n                ans = Math.min(ans, Math.abs(diff));\\n                if (diff <= 0) i1++;\\n                if (diff >= 0) i2++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private static int[][] generate(int[] nums) {\\n        int n = nums.length;\\n        int total = 0;\\n        for (int num : nums) total += num;\\n        int[][] ans = new int[n + 1][];\\n        int[] pos = new int[n + 1];\\n        for (int i = 0, binomial = 1; i <= n; i++) {\\n            ans[i] = new int[binomial]; // number of ways to choose i from n = binomial(i,n)\\n            binomial = binomial * (n - i) / (i + 1);\\n        }\\n        int maxValue = 1 << n;\\n        for (int key = 0; key < maxValue; key++) {\\n            int sum1 = 0;\\n            for (int i = 0; i < n; i++) {\\n                if ((key >> i & 1) == 1) sum1 += nums[i];\\n            }\\n            int sum2 = total - sum1;\\n            int bits = Integer.bitCount(key);\\n            ans[bits][pos[bits]++] = sum1 - sum2;\\n        }\\n        for (int[] arr : ans) Arrays.sort(arr);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967658,
                "title": "partition-array-into-two-arrays-to-minimize-sum-difference",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom bisect import bisect_left\\n\\nclass Solution(object):\\n    def minimumDifference(self, nums):\\n        n = len(nums)\\n        N = n // 2\\n        left, right = [[] for _ in range(N + 1)], [[] for _ in range(N + 1)]\\n        total_sum = sum(nums)\\n\\n        for mask in range(1 << N):\\n            l_sum, r_sum = 0, 0\\n            l_count = bin(mask).count(\\'1\\')\\n            for j in range(N):\\n                if mask & (1 << j):\\n                    l_sum += nums[j]\\n                    r_sum += nums[j + N]\\n            left[l_count].append(l_sum)\\n            right[l_count].append(r_sum)\\n\\n        for r in right:\\n            r.sort()\\n\\n        ans = abs(total_sum - 2 * left[N][0])\\n        for i in range(1, N):\\n            for l_val in left[i]:\\n                target = (total_sum - 2 * l_val) // 2\\n                idx = bisect_left(right[N-i], target)\\n                if idx < len(right[N-i]):\\n                    ans = min(ans, abs(total_sum - 2 * (l_val + right[N-i][idx])))\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom bisect import bisect_left\\n\\nclass Solution(object):\\n    def minimumDifference(self, nums):\\n        n = len(nums)\\n        N = n // 2\\n        left, right = [[] for _ in range(N + 1)], [[] for _ in range(N + 1)]\\n        total_sum = sum(nums)\\n\\n        for mask in range(1 << N):\\n            l_sum, r_sum = 0, 0\\n            l_count = bin(mask).count(\\'1\\')\\n            for j in range(N):\\n                if mask & (1 << j):\\n                    l_sum += nums[j]\\n                    r_sum += nums[j + N]\\n            left[l_count].append(l_sum)\\n            right[l_count].append(r_sum)\\n\\n        for r in right:\\n            r.sort()\\n\\n        ans = abs(total_sum - 2 * left[N][0])\\n        for i in range(1, N):\\n            for l_val in left[i]:\\n                target = (total_sum - 2 * l_val) // 2\\n                idx = bisect_left(right[N-i], target)\\n                if idx < len(right[N-i]):\\n                    ans = min(ans, abs(total_sum - 2 * (l_val + right[N-i][idx])))\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956531,
                "title": "bigner-friendly-divide-the-array-and-search-in-two-parts",
                "content": "Here only thing we are intrested in is sum of two subparts of length n so the brut force way for doing that is ki find all selection of length n and calculate the sum of each part and find minimum\\nso the complexcity : \\n30C15 = 155117520 (number of ways to choose k items from a set of n items without considering the order)\\nSo clearly it\\'ll fail  :(\\n\\n**```Optimized version```**\\nso insted of finding all 15\\'s sum at once we can subdevide the search space \\nfirst devide the array in left and right subpart of length n\\n\\ncalculate all possible subset sum of left & store in s1 with subset length similarly do for right and store in s2\\ncomplexity till  now:  2 * (2^(n/2))    at max( 2* 2^15 =65536 )   \\n\\nso now we will itrate through i=0; to i=n/2 and try to find for each sumvalue for   ``` ith length subset sum in s1 say it s1[i][j]  ( j from 0 to s1[i].size() )```   we will find max closest value of (total_sum/2- s1[i][j] ) in s2[n/2- i] by using lower bound and find the minimum possible value\\n\\n```\\n  Time : 2^n/2 * log(2^n)   (log term will never have 2^n value it\\'s just upper bound)\\n```\\n```\\n  Space : 2^n/2\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int idx, int s, int k, vector<int> &a, vector<vector<int>>&tem)\\n    {\\n        if(idx==a.size())\\n        {\\n            tem[k].push_back(s);\\n            return;\\n        }\\n        dfs(idx+1,s+a[idx],k+1,a,tem);\\n        dfs(idx+1,s,k,a,tem);\\n    }\\n    \\n    int minimumDifference(vector<int>& a)\\n    {\\n        sort(a.begin(),a.end());\\n        int sum=0;\\n        for(auto i:a) sum+=i;\\n        int total=sum;\\n        sum=sum/2;\\n        \\n        \\n        vector<int> left,right;\\n        \\n        int n=a.size();\\n        vector<vector<int>> s1((n/2)+1);\\n\\n        vector<vector<int>> s2((n/2)+1);\\n        for(int i=0; i<n/2; i++) left.push_back(a[i]);\\n        for(int i=n/2; i<n; i++) right.push_back(a[i]);\\n        \\n        dfs(0,0,0,left,s1);\\n        dfs(0,0,0,right,s2);\\n        int ans=INT_MAX;\\n        for(int i=0; i<=n/2; i++)\\n        {\\n            // sort(s1[i].begin(),s1[i].end());\\n            sort(s2[n/2-i].begin(),s2[n/2-i].end());\\n            for(auto j: s1[i])\\n            {\\n                int need= sum-j;\\n                int l= lower_bound(s2[n/2-i].begin(),s2[n/2-i].end(),need)-s2[n/2-i].begin();\\n                if(l<s2[n/2-i].size())\\n                {\\n                    ans= min(ans, abs(total-2*(j+s2[n/2-i][l])));\\n                }\\n                if(l>0)\\n                {\\n                    ans= min(ans, abs(total-2*(j+s2[n/2-i][l-1])));\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```Optimized version```\n``` ith length subset sum in s1 say it s1[i][j]  ( j from 0 to s1[i].size() )```\n```\\n  Time : 2^n/2 * log(2^n)   (log term will never have 2^n value it\\'s just upper bound)\\n```\n```\\n  Space : 2^n/2\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int idx, int s, int k, vector<int> &a, vector<vector<int>>&tem)\\n    {\\n        if(idx==a.size())\\n        {\\n            tem[k].push_back(s);\\n            return;\\n        }\\n        dfs(idx+1,s+a[idx],k+1,a,tem);\\n        dfs(idx+1,s,k,a,tem);\\n    }\\n    \\n    int minimumDifference(vector<int>& a)\\n    {\\n        sort(a.begin(),a.end());\\n        int sum=0;\\n        for(auto i:a) sum+=i;\\n        int total=sum;\\n        sum=sum/2;\\n        \\n        \\n        vector<int> left,right;\\n        \\n        int n=a.size();\\n        vector<vector<int>> s1((n/2)+1);\\n\\n        vector<vector<int>> s2((n/2)+1);\\n        for(int i=0; i<n/2; i++) left.push_back(a[i]);\\n        for(int i=n/2; i<n; i++) right.push_back(a[i]);\\n        \\n        dfs(0,0,0,left,s1);\\n        dfs(0,0,0,right,s2);\\n        int ans=INT_MAX;\\n        for(int i=0; i<=n/2; i++)\\n        {\\n            // sort(s1[i].begin(),s1[i].end());\\n            sort(s2[n/2-i].begin(),s2[n/2-i].end());\\n            for(auto j: s1[i])\\n            {\\n                int need= sum-j;\\n                int l= lower_bound(s2[n/2-i].begin(),s2[n/2-i].end(),need)-s2[n/2-i].begin();\\n                if(l<s2[n/2-i].size())\\n                {\\n                    ans= min(ans, abs(total-2*(j+s2[n/2-i][l])));\\n                }\\n                if(l>0)\\n                {\\n                    ans= min(ans, abs(total-2*(j+s2[n/2-i][l-1])));\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940810,
                "title": "c-code-but-getting-tle",
                "content": "class Solution {\\npublic:\\n  int mini=INT_MAX;\\n  void solve(int i,vector<int>&v,int sum,int s,int count,int summ)\\n  {\\n    if(count==v.size()/2)\\n    {\\n      int diff=abs(sum-summ-summ);\\n      mini=min(mini,diff);\\n      return;\\n    }\\n    \\n    if(i==v.size())\\n    return;\\n    \\n    count++;\\n    summ+=v[i];\\n    solve(i+1,v,sum,s,count,summ);\\n    count--;\\n    summ-=v[i];\\n    solve(i+1,v,sum,s,count,summ);\\n    \\n  }\\n  \\n    int minimumDifference(vector<int>& nums)\\n    {\\n        \\n     int sum=accumulate(nums.begin(),nums.end(),0);\\n      int c=0,summ=0;\\n      solve(0,nums,sum,0,c,summ);\\n      \\n      return mini;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n  int mini=INT_MAX;\\n  void solve(int i,vector<int>&v,int sum,int s,int count,int summ)\\n  {\\n    if(count==v.size()/2)\\n    {\\n      int diff=abs(sum-summ-summ);\\n      mini=min(mini,diff);\\n      return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3867821,
                "title": "partition-array-into-two-arrays-to-minimize-sum-difference-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length , res = 0 , sum = 0;\\n        for(int num : nums){\\n            sum+=num;\\n        }\\n\\n        int N =n/2;\\n        List<List<Integer>> left = new ArrayList<>(N+1);\\n        List<List<Integer>> right = new ArrayList<>(N+1);\\n\\n        for(int i=0 ; i<=N ; i++){\\n            left.add(new ArrayList<>());\\n            right.add(new ArrayList<>());\\n        }\\n\\n        //Storing all possible sum of left & right part\\n        for(int mask=0 ; mask<(1<<N) ; ++mask){\\n            int sz = 0 , l = 0 , r = 0;\\n            for(int i=0 ; i<N ; ++i){\\n                if((mask & (1<<i)) != 0){\\n                    sz++;\\n                    l+=nums[i];\\n                    r+=nums[i+N];\\n                }\\n            }\\n            left.get(sz).add(l);\\n            right.get(sz).add(r);\\n        }\\n\\n        for(int sz=0 ; sz<=N ; ++sz){\\n            Collections.sort(right.get(sz));\\n        }\\n\\n        res=Math.min(Math.abs(sum-2*left.get(N).get(0)) , Math.abs(sum-2*right.get(N).get(0)));\\n\\n        //Iterating over the left part\\n        for(int sz=1 ; sz<N ; ++sz){\\n            for(int a : left.get(sz)){\\n                int b = (sum-2*a)/2 , rsz = N - sz;\\n                List<Integer> v = right.get(rsz);\\n                int idx = Collections.binarySearch(v,b); // Binary Search over the right part\\n\\n                if(idx>=0){\\n                    res=Math.min(res,Math.abs(sum-2*(a+v.get(idx))));\\n                }\\n                else{\\n                    int insertionpoint = -idx -1;\\n                    if(insertionpoint<v.size()){\\n                        res=Math.min(res,Math.abs(sum-2*(a+v.get(insertionpoint))));\\n                    }\\n                    if(insertionpoint<0){\\n                        res=Math.min(res,Math.abs(sum-2*(a+v.get(insertionpoint-1))));\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length , res = 0 , sum = 0;\\n        for(int num : nums){\\n            sum+=num;\\n        }\\n\\n        int N =n/2;\\n        List<List<Integer>> left = new ArrayList<>(N+1);\\n        List<List<Integer>> right = new ArrayList<>(N+1);\\n\\n        for(int i=0 ; i<=N ; i++){\\n            left.add(new ArrayList<>());\\n            right.add(new ArrayList<>());\\n        }\\n\\n        //Storing all possible sum of left & right part\\n        for(int mask=0 ; mask<(1<<N) ; ++mask){\\n            int sz = 0 , l = 0 , r = 0;\\n            for(int i=0 ; i<N ; ++i){\\n                if((mask & (1<<i)) != 0){\\n                    sz++;\\n                    l+=nums[i];\\n                    r+=nums[i+N];\\n                }\\n            }\\n            left.get(sz).add(l);\\n            right.get(sz).add(r);\\n        }\\n\\n        for(int sz=0 ; sz<=N ; ++sz){\\n            Collections.sort(right.get(sz));\\n        }\\n\\n        res=Math.min(Math.abs(sum-2*left.get(N).get(0)) , Math.abs(sum-2*right.get(N).get(0)));\\n\\n        //Iterating over the left part\\n        for(int sz=1 ; sz<N ; ++sz){\\n            for(int a : left.get(sz)){\\n                int b = (sum-2*a)/2 , rsz = N - sz;\\n                List<Integer> v = right.get(rsz);\\n                int idx = Collections.binarySearch(v,b); // Binary Search over the right part\\n\\n                if(idx>=0){\\n                    res=Math.min(res,Math.abs(sum-2*(a+v.get(idx))));\\n                }\\n                else{\\n                    int insertionpoint = -idx -1;\\n                    if(insertionpoint<v.size()){\\n                        res=Math.min(res,Math.abs(sum-2*(a+v.get(insertionpoint))));\\n                    }\\n                    if(insertionpoint<0){\\n                        res=Math.min(res,Math.abs(sum-2*(a+v.get(insertionpoint-1))));\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858418,
                "title": "c-smart-coupling-less-than-100-ms",
                "content": "# Intuition\\nThis problem is usually solved by the Meet in the Middle method.\\n\\nAn array $$A$$ of integers of length $$2n$$ is given. It is required to divide the array into two equal parts (let\\'s call them right and left) in such a way as to minimize the difference between their sums.\\n\\nLet\\'s split the original array $$A$$ into two halves $$A1$$, $$A2$$ of length $$n$$ (let\\'s conventionally call them \\'green\\' and \\'red\\').\\nIn the \\'green\\' half, we place k elements on the right side, and the rest $$(n-k)$$ on the left. Accordingly, in the \\'red\\' half it will be necessary to place $$(n-k)$$ on the right side, and $$k$$ on the left.\\nThen for each half we get $$\\\\frac{n!}{k!*(n-k)!}$$ variants of partitions. Given the limitations of the input, this number cannot be more than $$6435$$, which allows us to meet the allotted time and memory size.\\n\\nFor each partition of each half for a given value of k, we calculate the sum. Elements placed on the left side will enter it with a \\'+\\' sign, and those placed on the right side with a \\'-\\' sign.\\nAt the first step $$k = 0$$, there is only one configuration for the \\'green\\' half - all elements on the left, its sum is equal to the sum of all elements of the array\\nTo get all the configurations for $$k = 1$$, we take one of the elements in turn and put it to the right - we get $$n$$ configurations. When the element $$A[i]$$ is moved to the right, the sum changes to $$(-2 \\\\cdot A[i])$$ - it disappears on the left with a \\'+\\' sign, and appears on the right with a \\'-\\' sign.\\n\\n![fig.1.jpg](https://assets.leetcode.com/users/images/c7b286a1-cfc5-4f38-b1d2-ec40f7069c76_1691068922.9714391.jpeg)\\n\\nFor $$k \\\\ge 2$$, we must ensure that the configurations are not repeated. To do that, for each configuration with $$(k - 1)$$ we go through all the elements of $$A1[i]$$ starting from $$i = 0$$. If this element is on the left, we create a new configuration in which it is on the right. If we have reached some element $$A1[p]$$, which is already on the left, we end the cycle and move on to the next configuration with $$(k-1)$$.\\nWhat if there are more elements on the right with an index greater than $$j$$ that need to be moved? Consider the configuration $$\\u0421(k, p)$$ with k elements on the right. Let\\'s move the element with the smallest possible index $$p$$ to the left, we get the configuration $$\\u0421(k-1, p+1)$$. From this configuration, according to the algorithm described above, one can always obtain, among others, $$C(k, p)$$. If we move any other element to the left in $$C(k, p)$$, then we will not be able to get it back later by the algorythm, since the cycle will be interrupted at a lower index. So having all configurations of $$(k-1)$$ we can get all configurations of $$k$$ without duplicates. To do this, we just need to remember the smallest index of the element on the right $$p$$.\\nThis procedure must be done for $$k$$ values from $$0$$ to $$n/2$$. If $$k > n/2$$ we get the symmetrical case $$k \\\\Rightarrow (n-k)$$.\\n\\n![fig.3.jpg](https://assets.leetcode.com/users/images/c94153b5-d6ca-4687-96ae-ec076cc20cb7_1691068970.211936.jpeg)\\n\\nIf we add any of the \"green\" sums to any of the \"red\" sums for a given $$k$$, we get the difference between the left and right parts, the absolute value of which we need to minimize. For convenience, we will change the sign of the \"red\" sums, then the problem will be reduced to finding the closest \"red\" and \"green\" sums to each other.\\nThe sums for the green half will be placed in the array $$v_1$$, the sums for the red half will be placed in the array $$v_2$$.\\nLet\\'s sort the array $$v_1$$ in ascending order. Further, it is possible, for example, for each element of $$v_2$$ to search for the nearest element from $$v_1$$ by the binary search.\\nOr you can also sort the array $$v_2$$. Let $$i = 0$$ be the index of the current element in $$v_1$$, $$j = 0$$ be the index of the current element in $$v_2$$, and $$diff$$ be the difference between $$v_1[i] - v_2[j]$$. Then if the difference is negative, then if we further reduce it, then the absolute value will increase. So it needs to be increased. To do this, we increase the index $$i$$ and, accordingly, $$v_1[i]$$ also increases. Conversely, if $$diff$$ is positive, increase the index $$j$$ and $$v_2[j]$$ to decrease it. After running through all the indices and taking the least $$abs(diff)$$, we get the desired minimum.\\n\\nHowever, we don\\'t need sorting of arrays as such. If, for example, the maximum value of $$v_1$$ is less than the minimum value of $$v_2$$, then their difference will be the desired minimum distance, and we are not interested in the remaining elements. In addition, if for some $$k$$ we have already found the minimum distance, we can not compare elements that are obviously further away. To account for these circumstances, we can proceed as follows.\\nLet\\'s find in each array $$v_1$$, $$v_2$$ the maximum and minimum values.\\nLet us know the minimum absolute difference $$d$$ found earlier for smaller $$k$$ (or we set it to be $$INT_{max}$$).\\nFind the minimum of pairwise differences: $$abs(min(v_1)-min(v_2))$$, $$abs(min(v_1)-max(v_2))$$, $$abs(max(v_1)-min(v_2))$$, $$abs(max(v1)-max(v_2))$$. If it is less than $$d$$, then assign it to $$d$$.\\nIf $$min(v_1) <= max(v_2)$$ or $$min(v_2) <= max(v_1)$$, then we\\'re done.\\nOtherwise, split the interval $$[min(v_1); max(v_1)]$$ into segments of length $$w = max(d, (max(v_1) - min(v_1) + 1) / len(v_1))$$. We number the segments from $$0$$ to $$(max(v_1) - min(v_1)) / w$$;\\nFor each segment, we find the number of elements $$v_1$$ falling into it, as well as the maximum and minimum of these elements.\\nLet\\'s go through all the elements from $$v_2$$.\\nIf this element $$v_2[i]$$ does not fall within the interval $$[min(v_1); max(v_1)]$$, then we check the distance to its borders, after which we discard this element.\\nOtherwise, we are looking for a segment $$q$$, which corresponds to it. If the following segment $$(q+1)$$ contains some elements from $$v1$$, then we check the distance from $$v_2[i]$$ to the minimum of them. Similarly, we check the distance from $$v_2[i]$$ to the maximum value $$v_1$$ reached inside the segment $$(q-1)$$. Update $$d$$ if any of this distances is less.\\nIf there are no elements $$v_1$$ inside the segment $$q$$, then we discard $$v_2[i]$$ and go to the next $$i$$. If there is, then we compare $$v_2[i]$$ with the maximum and minimum inside the segment $$q$$. If $$v_2[i]$$ lies outside the interval $$[min_q(v_1), max_q(v_1)]$$, then we also discard it. If $$v_2[i]$$ lies within this interval, then we leave this value for the future and move on to the next one.\\n\\n![fig.2.jpg](https://assets.leetcode.com/users/images/d1cb8d78-8f82-4690-a20c-551bf2be2019_1691069052.2351274.jpeg)\\n\\nAfter we have checked all $$v_2$$, we repeat this entire procedure, choosing as the initial interval each of the obtained segments, in which both $$v_1$$ and $$v_2$$ remain. At the same time, the maximum and minimum $$v_1$$ inside each of the segments can also be discarded, because we have already compared them with all $$v_2$$ from this interval.\\nAt each iteration, the length of the segment decreases at least twice, at most $$len(v_1)$$ times, so that the process converges exponentially with a base of degree $$2$$ or more.\\nWe can show this by noting that we discard all $$v_2$$\\'s outside the interval. In the worst case, when initially $$d = max(v_1)-min(v_1)$$, any value of $$v_2$$ lying inside will be no further than $$d/2$$ from one of the ends.\\nAt some point, we will discard all the values of $$v_1$$ or $$v_2$$ (at least when no more than 2 values of $$v_1$$ remain in each segment), then the problem can be considered solved.\\nIn practice, the solution converges in 1 - 2 iterations, which gives an almost linear time to find the least difference.\\nThis method is a relative of sorting buckets and hash tables.\\n\\n# Complexity\\n- Time complexity:\\n$$O(\\\\frac{n}{(1..n)} \\\\cdot 2^n)$$\\n\\n- Space complexity:\\n$$O(\\\\frac{n!}{(n/2)!((n+1)/2)!})$$\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    // Class for accounting all possible sums for one of the halves\\n    class Handler {\\n        \\n        using val_t = int;\\n        using conf_t = unsigned int;\\n        using buff_t = vector<pair<val_t, conf_t>>;\\n        using iterator = vector<int>::iterator;\\n\\n        static const conf_t ones = 0xFFFFFFFF;\\n\\n        buff_t buffer, new_buffer; // Buffer containing pairs (sum, config)\\n                                   // Config is the index of the first element in right array\\n        vector<int> array;         // Stores the original array\\n        int neg_cnt;               // Counter of elenments in the right array (negative)\\n        int lower, upper;          // Min and max sums\\n\\n    public:\\n\\n        // The first case is then all numbers placed to the left array\\n        Handler(iterator begin, iterator end) : array(begin, end), buffer(1), neg_cnt(0) {\\n            val_t sum = 0;\\n            for (auto& x : array) {\\n                sum += x;\\n                x *= 2;\\n            }\\n            upper = lower = sum;\\n            buffer.front() = make_pair(sum, array.size());\\n        }\\n\\n        // Move one number to the second array and evaluate sums\\n        void inc() {\\n            ++neg_cnt;\\n            new_buffer.clear();\\n            new_buffer.reserve( buffer.size() * (array.size() - neg_cnt + 1) / neg_cnt );\\n            lower = INT_MAX;\\n            upper = INT_MIN;\\n            for (auto& b : buffer) {\\n                val_t val = b.first;\\n                conf_t config = b.second;\\n                for (conf_t i = 0; i < config; i++) {\\n                    int new_val = val - array[i];\\n                    lower = min(lower, new_val);\\n                    upper = max(upper, new_val);\\n                    new_buffer.emplace_back(new_val, i);\\n                }\\n            }\\n            swap(buffer, new_buffer);\\n        }\\n\\n        // Get sum value\\n        int operator[](int idx) {\\n            return buffer[idx].first;\\n        }\\n        \\n        // Get size\\n        int size() {return buffer.size();}\\n\\n        // Get vector containing the sums\\n        void get_vec(vector<int>& v) {\\n            v.clear();\\n            v.reserve(buffer.size());\\n            for (auto& b: buffer) v.push_back(b.first);\\n        }\\n\\n        int get_min() {return lower;}\\n        int get_max() {return upper;}\\n    };\\n\\n\\n    // Record to store segment configuration\\n    struct Record {\\n        int begin1, n1;\\n        int begin2, n2;\\n        int min, max;\\n        Record() :\\n                begin1(0), n1(0), begin2(0), n2(0), min(INT_MAX), max(INT_MIN) {}\\n        Record(int _begin1, int _size1, int _begin2, int _size2, int _min, int _max) :\\n                begin1(_begin1), n1(_size1), begin2(_begin2), n2(_size2), min(_min), max(_max) {}\\n    };\\n\\n    // Function to find the least difference\\n    static void get_min_dist(vector<int>& v1, vector<int>& v2, int& dist,\\n                            pair<int, int> minmax1 = {INT_MAX, INT_MIN},\\n                            pair<int, int> minmax2 = {INT_MAX, INT_MIN}) {\\n        \\n        static vector<Record> segments;\\n        static stack<int> stack1, stack2;\\n        \\n        if (minmax1.first > minmax1.second)\\n            for (auto& val: v1) {\\n                minmax1.first = min(minmax1.first, val);\\n                minmax1.second = max(minmax1.second, val);\\n            }\\n        \\n        if (minmax2.first > minmax2.second)\\n            for (auto& val: v1) {\\n                minmax2.first = min(minmax2.first, val);\\n                minmax2.second = max(minmax2.second, val);\\n            }\\n\\n\\n        dist = min(dist, abs(minmax1.first - minmax2.second));\\n        dist = min(dist, abs(minmax2.first - minmax1.second));\\n        dist = min(dist, abs(minmax2.first - minmax1.first));\\n        dist = min(dist, abs(minmax2.second - minmax1.second));\\n        if (!dist || minmax1.first >= minmax2.second || minmax2.first >= minmax1.second) return;\\n\\n        segments.push_back(Record(0, v1.size(), 0, v2.size(), minmax1.first, minmax1.second));\\n\\n        //int counter = 0;\\n        while (v1.size() && v2.size() && dist) {\\n            Record old_segm = segments.back();\\n            segments.pop_back();\\n\\n            //counter += max(v1.size() - old_segm.begin1, v2.size() - old_segm.begin2);\\n            \\n            int left = old_segm.min;\\n            int right = old_segm.max;\\n\\n            int width = max(dist, (right - left + 1) / old_segm.n1);\\n\\n            int section = segments.size();\\n            segments.resize(section + (right - left)/width + 1);\\n\\n            //cout << \"------------------------\\\\n\";\\n            //cout << \"v1.size = \" << v1.size() << \", v2.size = \" <<  v2.size() <<\", dist = \" <<  dist << endl;\\n            //cout << \"left = \" << left << \", right = \" << right << endl;\\n            //cout << \"width = \" << width << endl;\\n            //cout << \"max segments size: \" << section + (right - left)/width + 1 << endl;\\n\\n            for (int i = old_segm.begin1; i < v1.size(); i++) {\\n                int val = v1[i];\\n                //cout << left << \" | \" << val << \" | \" << right << endl;\\n                auto& curr = segments[section + (val - left)/width];\\n\\n                if (!curr.n1) {\\n                    curr.n1++;\\n                    curr.min = curr.max = val;\\n                }\\n                else if (curr.n1 == 1) {\\n                    curr.n1++;\\n                    if (val < curr.min) curr.min = val;\\n                    else curr.max = val;\\n                }\\n                else if (val < curr.min) {\\n                    curr.n1++;\\n                    stack1.push(curr.min);\\n                    curr.min = val;\\n                }\\n                else if (val > curr.max) {\\n                    curr.n1++;\\n                    stack1.push(curr.max);\\n                    curr.max = val;\\n                }\\n                else if (val > curr.min && val < curr.max) {\\n                    curr.n1++;\\n                    stack1.push(val);\\n                }\\n            }\\n\\n            //cout << \"New segment filled of v1\\\\n\";\\n\\n            for (int i = old_segm.begin2; i < v2.size(); i++) {\\n                int val = v2[i];\\n                if (val < left) dist = min(dist, left - val);\\n                else if (val > right) dist = min(dist, val - right);\\n                else {\\n                    int idx = section + (val - left)/width;\\n                    auto& curr = segments[idx];\\n\\n                    if (idx > section && segments[idx-1].n1)\\n                        dist = min(dist, val - segments[idx-1].max);\\n                    if (idx < segments.size()-1 && segments[idx+1].n1)\\n                        dist = min(dist, segments[idx+1].min - val);\\n                    if (curr.n1) {\\n                        dist = min(dist, abs(curr.min - val));\\n                        dist = min(dist, abs(val - curr.max));\\n                        if (val > curr.min && val < curr.max && curr.n1 > 2) {\\n                            stack2.push(val);\\n                            ++curr.n2;\\n                        }\\n                    }\\n                }\\n                if (!dist) break;\\n            }\\n\\n            //cout << \"New segment filled of v2\\\\n\";\\n\\n            //if (stack1.size() != stack2.size())\\n                //cout << \"stack1.size = \" << stack1.size() << \", stack2.size = \" << stack2.size() << endl;\\n\\n            int pos1 = old_segm.begin1;\\n            int pos2 = old_segm.begin2;\\n            for (int i = section; i < segments.size(); i++) {\\n                auto& curr = segments[i];\\n                if ((curr.n1 -= 2) <= 0 || !curr.n2) curr.n1 = curr.n2 = 0;\\n                curr.begin1 = pos1 += curr.n1;\\n                curr.begin2 = pos2 += curr.n2;\\n                curr.min = INT_MAX;\\n                curr.max = INT_MIN;\\n            }\\n            \\n            v1.resize(segments.back().begin1);\\n            v2.resize(segments.back().begin2);\\n\\n            while (!stack1.empty()) {\\n                int val = stack1.top();\\n                stack1.pop();\\n                auto& curr = segments[section + (val - left)/width];\\n                if (curr.n1) {\\n                    v1[--curr.begin1] = val;\\n                    curr.min = min(curr.min, val);\\n                    curr.max = max(curr.max, val);\\n                }\\n            }\\n\\n            //cout << \"v1 filled\\\\n\";\\n\\n            while (!stack2.empty()) {\\n                int val = stack2.top();\\n                stack2.pop();\\n                auto& curr = segments[section + (val - left)/width];\\n                if (curr.n2) v2[--curr.begin2] = val;\\n            }\\n\\n            //cout << \"v2 filled\\\\n\";\\n            \\n            for (int i = section; i < segments.size(); i++) {\\n                if (segments[i].n1) {\\n                    segments[section] = segments[i];\\n                    section++;\\n                }\\n            }\\n            \\n            //cout << \"new partition size: \" << section << endl;\\n            segments.resize(section);\\n        }\\n        //cout << \"counter = \" << counter << \", dist = \" <<  dist << \"\\\\n\";\\n        \\n        segments.clear();\\n    }\\n\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        //cout << \"\\\\n[\";\\n        //for (auto& val : nums) cout << val << \", \";\\n        //cout << \"]\\\\n\";\\n\\n        int n = nums.size() / 2;\\n\\n        Handler h1(nums.begin(), nums.begin()+n), h2(nums.begin()+n, nums.end());\\n        vector<int> v1, v2;\\n\\n        //long long time1 = 0, time2 = 0, time3 = 0;\\n\\n        int result = abs(h1[0] - h2[0]);\\n        for (int i = 0; i < n/2; i++) {\\n            \\n            //clock_t start = clock();\\n            h1.inc();\\n            h1.get_vec(v1);\\n            h2.inc();\\n            h2.get_vec(v2);\\n            //time1 += clock() - start;\\n\\n            //start = clock();\\n            get_min_dist(v1, v2, result,\\n                    make_pair(h1.get_min(), h1.get_max()),\\n                    make_pair(h2.get_min(), h2.get_max())\\n            );\\n            //time2 += clock() - start;\\n        }\\n\\n        //cout << \"Combining: \" << time1*1000 / CLOCKS_PER_SEC << \" ms\" << endl;\\n        //cout << \"Comparing: \" << time2*1000 / CLOCKS_PER_SEC << \" ms\" << endl;\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // Class for accounting all possible sums for one of the halves\\n    class Handler {\\n        \\n        using val_t = int;\\n        using conf_t = unsigned int;\\n        using buff_t = vector<pair<val_t, conf_t>>;\\n        using iterator = vector<int>::iterator;\\n\\n        static const conf_t ones = 0xFFFFFFFF;\\n\\n        buff_t buffer, new_buffer; // Buffer containing pairs (sum, config)\\n                                   // Config is the index of the first element in right array\\n        vector<int> array;         // Stores the original array\\n        int neg_cnt;               // Counter of elenments in the right array (negative)\\n        int lower, upper;          // Min and max sums\\n\\n    public:\\n\\n        // The first case is then all numbers placed to the left array\\n        Handler(iterator begin, iterator end) : array(begin, end), buffer(1), neg_cnt(0) {\\n            val_t sum = 0;\\n            for (auto& x : array) {\\n                sum += x;\\n                x *= 2;\\n            }\\n            upper = lower = sum;\\n            buffer.front() = make_pair(sum, array.size());\\n        }\\n\\n        // Move one number to the second array and evaluate sums\\n        void inc() {\\n            ++neg_cnt;\\n            new_buffer.clear();\\n            new_buffer.reserve( buffer.size() * (array.size() - neg_cnt + 1) / neg_cnt );\\n            lower = INT_MAX;\\n            upper = INT_MIN;\\n            for (auto& b : buffer) {\\n                val_t val = b.first;\\n                conf_t config = b.second;\\n                for (conf_t i = 0; i < config; i++) {\\n                    int new_val = val - array[i];\\n                    lower = min(lower, new_val);\\n                    upper = max(upper, new_val);\\n                    new_buffer.emplace_back(new_val, i);\\n                }\\n            }\\n            swap(buffer, new_buffer);\\n        }\\n\\n        // Get sum value\\n        int operator[](int idx) {\\n            return buffer[idx].first;\\n        }\\n        \\n        // Get size\\n        int size() {return buffer.size();}\\n\\n        // Get vector containing the sums\\n        void get_vec(vector<int>& v) {\\n            v.clear();\\n            v.reserve(buffer.size());\\n            for (auto& b: buffer) v.push_back(b.first);\\n        }\\n\\n        int get_min() {return lower;}\\n        int get_max() {return upper;}\\n    };\\n\\n\\n    // Record to store segment configuration\\n    struct Record {\\n        int begin1, n1;\\n        int begin2, n2;\\n        int min, max;\\n        Record() :\\n                begin1(0), n1(0), begin2(0), n2(0), min(INT_MAX), max(INT_MIN) {}\\n        Record(int _begin1, int _size1, int _begin2, int _size2, int _min, int _max) :\\n                begin1(_begin1), n1(_size1), begin2(_begin2), n2(_size2), min(_min), max(_max) {}\\n    };\\n\\n    // Function to find the least difference\\n    static void get_min_dist(vector<int>& v1, vector<int>& v2, int& dist,\\n                            pair<int, int> minmax1 = {INT_MAX, INT_MIN},\\n                            pair<int, int> minmax2 = {INT_MAX, INT_MIN}) {\\n        \\n        static vector<Record> segments;\\n        static stack<int> stack1, stack2;\\n        \\n        if (minmax1.first > minmax1.second)\\n            for (auto& val: v1) {\\n                minmax1.first = min(minmax1.first, val);\\n                minmax1.second = max(minmax1.second, val);\\n            }\\n        \\n        if (minmax2.first > minmax2.second)\\n            for (auto& val: v1) {\\n                minmax2.first = min(minmax2.first, val);\\n                minmax2.second = max(minmax2.second, val);\\n            }\\n\\n\\n        dist = min(dist, abs(minmax1.first - minmax2.second));\\n        dist = min(dist, abs(minmax2.first - minmax1.second));\\n        dist = min(dist, abs(minmax2.first - minmax1.first));\\n        dist = min(dist, abs(minmax2.second - minmax1.second));\\n        if (!dist || minmax1.first >= minmax2.second || minmax2.first >= minmax1.second) return;\\n\\n        segments.push_back(Record(0, v1.size(), 0, v2.size(), minmax1.first, minmax1.second));\\n\\n        //int counter = 0;\\n        while (v1.size() && v2.size() && dist) {\\n            Record old_segm = segments.back();\\n            segments.pop_back();\\n\\n            //counter += max(v1.size() - old_segm.begin1, v2.size() - old_segm.begin2);\\n            \\n            int left = old_segm.min;\\n            int right = old_segm.max;\\n\\n            int width = max(dist, (right - left + 1) / old_segm.n1);\\n\\n            int section = segments.size();\\n            segments.resize(section + (right - left)/width + 1);\\n\\n            //cout << \"------------------------\\\\n\";\\n            //cout << \"v1.size = \" << v1.size() << \", v2.size = \" <<  v2.size() <<\", dist = \" <<  dist << endl;\\n            //cout << \"left = \" << left << \", right = \" << right << endl;\\n            //cout << \"width = \" << width << endl;\\n            //cout << \"max segments size: \" << section + (right - left)/width + 1 << endl;\\n\\n            for (int i = old_segm.begin1; i < v1.size(); i++) {\\n                int val = v1[i];\\n                //cout << left << \" | \" << val << \" | \" << right << endl;\\n                auto& curr = segments[section + (val - left)/width];\\n\\n                if (!curr.n1) {\\n                    curr.n1++;\\n                    curr.min = curr.max = val;\\n                }\\n                else if (curr.n1 == 1) {\\n                    curr.n1++;\\n                    if (val < curr.min) curr.min = val;\\n                    else curr.max = val;\\n                }\\n                else if (val < curr.min) {\\n                    curr.n1++;\\n                    stack1.push(curr.min);\\n                    curr.min = val;\\n                }\\n                else if (val > curr.max) {\\n                    curr.n1++;\\n                    stack1.push(curr.max);\\n                    curr.max = val;\\n                }\\n                else if (val > curr.min && val < curr.max) {\\n                    curr.n1++;\\n                    stack1.push(val);\\n                }\\n            }\\n\\n            //cout << \"New segment filled of v1\\\\n\";\\n\\n            for (int i = old_segm.begin2; i < v2.size(); i++) {\\n                int val = v2[i];\\n                if (val < left) dist = min(dist, left - val);\\n                else if (val > right) dist = min(dist, val - right);\\n                else {\\n                    int idx = section + (val - left)/width;\\n                    auto& curr = segments[idx];\\n\\n                    if (idx > section && segments[idx-1].n1)\\n                        dist = min(dist, val - segments[idx-1].max);\\n                    if (idx < segments.size()-1 && segments[idx+1].n1)\\n                        dist = min(dist, segments[idx+1].min - val);\\n                    if (curr.n1) {\\n                        dist = min(dist, abs(curr.min - val));\\n                        dist = min(dist, abs(val - curr.max));\\n                        if (val > curr.min && val < curr.max && curr.n1 > 2) {\\n                            stack2.push(val);\\n                            ++curr.n2;\\n                        }\\n                    }\\n                }\\n                if (!dist) break;\\n            }\\n\\n            //cout << \"New segment filled of v2\\\\n\";\\n\\n            //if (stack1.size() != stack2.size())\\n                //cout << \"stack1.size = \" << stack1.size() << \", stack2.size = \" << stack2.size() << endl;\\n\\n            int pos1 = old_segm.begin1;\\n            int pos2 = old_segm.begin2;\\n            for (int i = section; i < segments.size(); i++) {\\n                auto& curr = segments[i];\\n                if ((curr.n1 -= 2) <= 0 || !curr.n2) curr.n1 = curr.n2 = 0;\\n                curr.begin1 = pos1 += curr.n1;\\n                curr.begin2 = pos2 += curr.n2;\\n                curr.min = INT_MAX;\\n                curr.max = INT_MIN;\\n            }\\n            \\n            v1.resize(segments.back().begin1);\\n            v2.resize(segments.back().begin2);\\n\\n            while (!stack1.empty()) {\\n                int val = stack1.top();\\n                stack1.pop();\\n                auto& curr = segments[section + (val - left)/width];\\n                if (curr.n1) {\\n                    v1[--curr.begin1] = val;\\n                    curr.min = min(curr.min, val);\\n                    curr.max = max(curr.max, val);\\n                }\\n            }\\n\\n            //cout << \"v1 filled\\\\n\";\\n\\n            while (!stack2.empty()) {\\n                int val = stack2.top();\\n                stack2.pop();\\n                auto& curr = segments[section + (val - left)/width];\\n                if (curr.n2) v2[--curr.begin2] = val;\\n            }\\n\\n            //cout << \"v2 filled\\\\n\";\\n            \\n            for (int i = section; i < segments.size(); i++) {\\n                if (segments[i].n1) {\\n                    segments[section] = segments[i];\\n                    section++;\\n                }\\n            }\\n            \\n            //cout << \"new partition size: \" << section << endl;\\n            segments.resize(section);\\n        }\\n        //cout << \"counter = \" << counter << \", dist = \" <<  dist << \"\\\\n\";\\n        \\n        segments.clear();\\n    }\\n\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        //cout << \"\\\\n[\";\\n        //for (auto& val : nums) cout << val << \", \";\\n        //cout << \"]\\\\n\";\\n\\n        int n = nums.size() / 2;\\n\\n        Handler h1(nums.begin(), nums.begin()+n), h2(nums.begin()+n, nums.end());\\n        vector<int> v1, v2;\\n\\n        //long long time1 = 0, time2 = 0, time3 = 0;\\n\\n        int result = abs(h1[0] - h2[0]);\\n        for (int i = 0; i < n/2; i++) {\\n            \\n            //clock_t start = clock();\\n            h1.inc();\\n            h1.get_vec(v1);\\n            h2.inc();\\n            h2.get_vec(v2);\\n            //time1 += clock() - start;\\n\\n            //start = clock();\\n            get_min_dist(v1, v2, result,\\n                    make_pair(h1.get_min(), h1.get_max()),\\n                    make_pair(h2.get_min(), h2.get_max())\\n            );\\n            //time2 += clock() - start;\\n        }\\n\\n        //cout << \"Combining: \" << time1*1000 / CLOCKS_PER_SEC << \" ms\" << endl;\\n        //cout << \"Comparing: \" << time2*1000 / CLOCKS_PER_SEC << \" ms\" << endl;\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3816211,
                "title": "python-solution-meet-in-the-middle",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 2\\n        total = sum(nums)\\n        goal = total // 2\\n\\n        def dfs(nums):\\n            ans = {(0, 0)}\\n            \\n            for num in nums:\\n                ans |= {(num + j[0], j[1] + 1) for j in ans}\\n            \\n            arr = []\\n\\n            for i in range(n-1):\\n                arr.append([])\\n\\n            length = 0\\n            \\n            for val, idx in ans:\\n                if idx != 0 and idx != n:\\n                    arr[idx-1].append(val)\\n                    \\n            return arr\\n            \\n        arr1 = dfs(nums[:n])\\n        arr2 = [sorted(arr) for arr in dfs(nums[n:])]\\n\\n        halfSum = sum(nums[:n])\\n\\n        min_diff = abs((total - halfSum) - halfSum)\\n\\n        for i in range(len(arr1)):\\n            for j in range(len(arr1[i])):\\n                target = goal - arr1[i][j]\\n                \\n                idx = bisect.bisect_left(arr2[n-i-2], target)\\n                \\n                minDiff = math.inf\\n                value = math.inf\\n                \\n                if idx<len(arr2[n-i-2])and abs(target - arr2[n-i-2][idx]) < minDiff:\\n                        minDiff = abs(target - arr2[n-i-2][idx])\\n                        value = arr2[n-i-2][idx]\\n                if idx>0 and abs(target - arr2[n-i-2][idx-1]) < minDiff:\\n                        minDiff = abs(target - arr2[n-i-2][idx-1])\\n                        value = arr2[n-i-2][idx-1]\\n                \\n                halfSum = arr1[i][j] + value\\n                min_diff = min(min_diff, abs((total - halfSum) - halfSum))\\n                \\n        return min_diff\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 2\\n        total = sum(nums)\\n        goal = total // 2\\n\\n        def dfs(nums):\\n            ans = {(0, 0)}\\n            \\n            for num in nums:\\n                ans |= {(num + j[0], j[1] + 1) for j in ans}\\n            \\n            arr = []\\n\\n            for i in range(n-1):\\n                arr.append([])\\n\\n            length = 0\\n            \\n            for val, idx in ans:\\n                if idx != 0 and idx != n:\\n                    arr[idx-1].append(val)\\n                    \\n            return arr\\n            \\n        arr1 = dfs(nums[:n])\\n        arr2 = [sorted(arr) for arr in dfs(nums[n:])]\\n\\n        halfSum = sum(nums[:n])\\n\\n        min_diff = abs((total - halfSum) - halfSum)\\n\\n        for i in range(len(arr1)):\\n            for j in range(len(arr1[i])):\\n                target = goal - arr1[i][j]\\n                \\n                idx = bisect.bisect_left(arr2[n-i-2], target)\\n                \\n                minDiff = math.inf\\n                value = math.inf\\n                \\n                if idx<len(arr2[n-i-2])and abs(target - arr2[n-i-2][idx]) < minDiff:\\n                        minDiff = abs(target - arr2[n-i-2][idx])\\n                        value = arr2[n-i-2][idx]\\n                if idx>0 and abs(target - arr2[n-i-2][idx-1]) < minDiff:\\n                        minDiff = abs(target - arr2[n-i-2][idx-1])\\n                        value = arr2[n-i-2][idx-1]\\n                \\n                halfSum = arr1[i][j] + value\\n                min_diff = min(min_diff, abs((total - halfSum) - halfSum))\\n                \\n        return min_diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802275,
                "title": "js-meet-in-the-middle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(2^n/2 + 2^n/2 + log(2^n/2)2^n/2) = O(n*2^n/2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// meeting in the middle\\n// bitmask + binary search\\n// for num[i]>=0, you can use 0-1 knapsack approach\\n\\nvar minimumDifference = function (nums) {\\n  const N = nums.length;\\n  const n = N / 2;\\n  const left = new Array(n + 1).fill().map(() => new Array().fill());\\n  const right = new Array(n + 1).fill().map(() => new Array().fill());\\n\\n  let sum = 0;\\n  nums.forEach((num) => (sum += num));\\n\\n  for (let i = 0; i < 1 << n; i++) {\\n    let count = 0; // to count number of elements in the subset\\n    let leftSum = 0;\\n    let rightSum = 0;\\n\\n    for (let j = 0; j < n; j++) {\\n      if (i & (1 << j)) {\\n        count++;\\n        leftSum += nums[j];\\n        rightSum += nums[n + j];   \\n      }\\n    }\\n\\n    left[count].push(leftSum); \\n    // store the number of elements in the subset as i\\'th index or key of the 2D array\\n    right[count].push(rightSum);\\n  }\\n\\n  for (let i = 0; i < n; i++) {\\n    right[i].sort((a, b) => a - b);\\n  }\\n\\n  let ans = Number.MAX_VALUE;\\n\\n  for (let i = 0; i < n; i++) {\\n    const leftArr = left[i];\\n    const rightArr = right[n - i]; \\n    // we have to find min abs diff in two equal size arrays\\n\\n    leftArr.forEach((element) => {\\n      let low = 0;\\n      let high = rightArr.length - 1;\\n\\n      while (low <= high) {\\n        const mid = Math.floor(low + (high - low) / 2);\\n        const value = sum - 2 * (element + rightArr[mid]);\\n        ans = Math.min(ans, Math.abs(value));\\n        if (ans == 0) {\\n          return ans;\\n        }\\n        if (value > 0) {\\n          low = mid + 1;\\n        } else {\\n          high = mid - 1;\\n        }\\n      }\\n\\n    });\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bitmask"
                ],
                "code": "```\\n// meeting in the middle\\n// bitmask + binary search\\n// for num[i]>=0, you can use 0-1 knapsack approach\\n\\nvar minimumDifference = function (nums) {\\n  const N = nums.length;\\n  const n = N / 2;\\n  const left = new Array(n + 1).fill().map(() => new Array().fill());\\n  const right = new Array(n + 1).fill().map(() => new Array().fill());\\n\\n  let sum = 0;\\n  nums.forEach((num) => (sum += num));\\n\\n  for (let i = 0; i < 1 << n; i++) {\\n    let count = 0; // to count number of elements in the subset\\n    let leftSum = 0;\\n    let rightSum = 0;\\n\\n    for (let j = 0; j < n; j++) {\\n      if (i & (1 << j)) {\\n        count++;\\n        leftSum += nums[j];\\n        rightSum += nums[n + j];   \\n      }\\n    }\\n\\n    left[count].push(leftSum); \\n    // store the number of elements in the subset as i\\'th index or key of the 2D array\\n    right[count].push(rightSum);\\n  }\\n\\n  for (let i = 0; i < n; i++) {\\n    right[i].sort((a, b) => a - b);\\n  }\\n\\n  let ans = Number.MAX_VALUE;\\n\\n  for (let i = 0; i < n; i++) {\\n    const leftArr = left[i];\\n    const rightArr = right[n - i]; \\n    // we have to find min abs diff in two equal size arrays\\n\\n    leftArr.forEach((element) => {\\n      let low = 0;\\n      let high = rightArr.length - 1;\\n\\n      while (low <= high) {\\n        const mid = Math.floor(low + (high - low) / 2);\\n        const value = sum - 2 * (element + rightArr[mid]);\\n        ans = Math.min(ans, Math.abs(value));\\n        if (ans == 0) {\\n          return ans;\\n        }\\n        if (value > 0) {\\n          low = mid + 1;\\n        } else {\\n          high = mid - 1;\\n        }\\n      }\\n\\n    });\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3764055,
                "title": "meet-in-the-middle-c-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        int ss=0;\\n        for(int i=0;i<n;i++)ss+=nums[i];\\n\\n        map<int,set<int>>mp;\\n        for(int i=0;i<(1<<n/2);i++)\\n        {\\n            int sum=0, count=0;\\n            for(int j=0;j<n/2;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    sum+=nums[n/2+j];\\n                    count++;\\n                }\\n            }\\n            mp[count].insert(sum);\\n        }\\n\\n        int ans = 1e9;\\n        for(int i=0;i<(1<<n/2);i++)\\n        {\\n            int sum=0, count=0;\\n            for(int j=0;j<n/2;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    sum+=nums[j];\\n                    count++;\\n                }\\n            }\\n            if(1){\\n                auto it = mp[n/2-count].lower_bound(ss/2-sum);\\n                if(*it!=(ss/2-sum)||it==mp[n/2-count].end())\\n                {\\n                    if(it!=mp[n/2-count].begin())\\n                    {\\n                        it--;\\n                        ans = min(ans,abs(ss-2*(sum+(*it))));\\n                    }\\n                }else{\\n                    ans = min(ans,abs(ss-2*(sum+(*it))));\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        int ss=0;\\n        for(int i=0;i<n;i++)ss+=nums[i];\\n\\n        map<int,set<int>>mp;\\n        for(int i=0;i<(1<<n/2);i++)\\n        {\\n            int sum=0, count=0;\\n            for(int j=0;j<n/2;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    sum+=nums[n/2+j];\\n                    count++;\\n                }\\n            }\\n            mp[count].insert(sum);\\n        }\\n\\n        int ans = 1e9;\\n        for(int i=0;i<(1<<n/2);i++)\\n        {\\n            int sum=0, count=0;\\n            for(int j=0;j<n/2;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    sum+=nums[j];\\n                    count++;\\n                }\\n            }\\n            if(1){\\n                auto it = mp[n/2-count].lower_bound(ss/2-sum);\\n                if(*it!=(ss/2-sum)||it==mp[n/2-count].end())\\n                {\\n                    if(it!=mp[n/2-count].begin())\\n                    {\\n                        it--;\\n                        ans = min(ans,abs(ss-2*(sum+(*it))));\\n                    }\\n                }else{\\n                    ans = min(ans,abs(ss-2*(sum+(*it))));\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711835,
                "title": "minimum-difference-easy-approach-dp",
                "content": "\\n# Problem Statement: \\uD83C\\uDFAF\\nGiven an array of integers, we need to divide it into two parts of size `n` each, such that the absolute difference of their sums is minimized.\\n\\n# Approach and Intuition: \\uD83D\\uDCA1\\nWe can approach this problem by dividing the original array into two parts of size `n`, each representing a subset. Let\\'s say we take a subset of size `size` from the left part, and its sum is `leftSumValue`. Then, we need to take a subset of size `n - size` from the right part, and its sum is `rightSumValue`. Now, the sum of the two subsets from the left and right parts will be:\\n\\n `Part1Sum = leftSumValue + rightSumValue`.\\n\\n Since we need to minimize the absolute difference between the sums of the two parts, we also need to consider the other part, which will be :\\n\\n`Part2Sum = TotalSum - (leftSumValue + rightSumValue)`.\\n\\nThus, we need to minimize `abs(TotalSum - 2*leftSumValue  - 2*rightSumValue)`.\\n\\nTo do this, we can iterate over `leftSUmValue`, and for each `leftSUmValue`, we perform a binary search to find the corresponding `rightSumValue` in the right part using the specific place. By calculating the absolute difference for each `leftSumValue` and `rightSumValue`, we can update the minimum difference accordingly.\\n\\n# Algorithm: \\uD83D\\uDE80\\n1. Define a class `Solution` that includes the function \\n2. `minimumDifference` to solve the problem.\\n2. Calculate the total sum of all elements in the input array and store it in the `totalSum` variable.\\n3. Create two two-dimensional vectors, \\n4. `leftSum` and `rightSum`, to store the sums of subsets. `leftSum[i]` will contain the sums of all subsets of size `i` from the left half of the input array, and `rightSum[i]` will contain the sums of all subsets of size `i` from the right half of the input array.\\n4. Generate all possible subsets of the input array using a bitmask. Iterate through the binary representation of the subset bitmask and calculate the sum of the corresponding subset from the left and right halves of the input array. Store these sums in the `leftSum` and `rightSum` vectors based on their sizes.\\n5. Calculate the initial minimum difference by comparing the absolute difference between the total sum and twice the sum of the first subset in `leftSum[n]` and `rightSum[n]`, where `n` is half the size of the input array.\\n6. Sort the `rightSum` vectors in ascending order for each subset size to prepare for binary search later.\\n7. Iterate through the subsets in `leftSum` starting from size 1 up to `n-1`. For each subset, iterate through its sums.\\n8. For each left subset sum `leftSumValue`, calculate the desired sum for the right subset by subtracting twice the left subset sum `leftSumValue` from the total sum and dividing it by 2. This gives us the target sum that we want to find in the right subsets.\\n9. Perform a binary search using `lower_bound` on the sorted `rightSums` vector for the desired sum `rightSumValue`. If a valid sum is found, update the minimum difference if necessary.\\n10. Check the previous element in case the desired sum `rightSumValue` is not found in `rightSums`, and update the minimum difference if necessary.\\n11. Finally, return the minimum difference as the result.\\n\\n# Complexity Analysis: \\u23F0\\n- Generating all subsets takes O(2^N) time and O(2^N) space.\\n- Sorting the \\'rightSum\\' vectors takes O(N^2 log N) time and O(N^2) space.\\n- The nested loop for iterating through the subsets and performing binary search takes O(N^3 log N) time.\\n- Overall, the time complexity is O(N^3 log N), where N is the number of elements in the input array.\\n- The space complexity is O(N^2) to store the sums of subsets.\\n\\nCode: \\uD83D\\uDCBB\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int N = nums.size(); // Number of elements in the input vector\\n        int n = N / 2; // Half the size of the vector\\n        vector<vector<int>> leftSum(n + 1), rightSum(n + 1); // Two-dimensional vectors to store the sums of subsets\\n\\n        // Generate all possible subsets of the input vector\\n        int countLimitMask = ((1 << n) - 1); // Mask to iterate through subsets\\n        for (int i = 0; i <= countLimitMask; i++) {\\n            int leftSize = 0; // Number of elements in the current left subset\\n            int leftSumValue = 0; // Sum of elements in the left subset\\n            int rightSumValue = 0; // Sum of elements in the right subset\\n\\n            // Iterate through the binary representation of the subset\\n            for (int j = 0; j < n; j++) {\\n                if (i & (1 << j)) { // Check if the j-th bit is set in the subset\\n                    leftSize++;\\n                    leftSumValue += nums[j]; // Add the j-th element to the left subset sum\\n                    rightSumValue += nums[j + n]; // Add the (j+n)-th element to the right subset sum\\n                }\\n            }\\n\\n            // Store the sums in the corresponding size vectors\\n            leftSum[leftSize].push_back(leftSumValue);\\n            rightSum[leftSize].push_back(rightSumValue);\\n        }\\n\\n        int totalSum = accumulate(nums.begin(), nums.end(), 0); // Calculate the total sum of all elements\\n        int minDifference = min(abs(totalSum - 2 * leftSum[n][0]), abs(totalSum - 2 * rightSum[n][0])); // Calculate the initial minimum difference\\n\\n        // Sort the rightSum vectors for binary search later\\n        for (int rightSize = 0; rightSize <= n; rightSize++) {\\n            sort(rightSum[rightSize].begin(), rightSum[rightSize].end());\\n        }\\n\\n        // Iterate through the leftSum vectors\\n        for (int leftSize = 1; leftSize < n; leftSize++) {\\n            for (auto &leftSumValue : leftSum[leftSize]) { // Iterate through the subsets of size leftSize in the leftSum vector\\n                int desiredRightSum = (totalSum - 2 * leftSumValue) / 2; // Calculate the desired sum for the right subset\\n                int rightSize = n - leftSize; // Calculate the size of the right subset\\n                auto &rightSums = rightSum[rightSize]; // Get the corresponding rightSum vector\\n\\n                auto itr = lower_bound(rightSums.begin(), rightSums.end(), desiredRightSum); // Find the lower bound of the desired sum in the rightSum vector\\n                if (itr != rightSums.end()) { // If a valid sum is found\\n                    minDifference = min(minDifference, abs(totalSum - 2 * leftSumValue - 2 * (*itr))); // Update the minimum difference if necessary\\n                }\\n                if (itr != rightSums.begin()) { // If the lower bound is not the first element\\n                    itr--; // Move to the previous element\\n                    minDifference = min(minDifference, abs(totalSum - 2 * leftSumValue - 2 * (*itr))); // Update the minimum difference if necessary\\n                }\\n            }\\n        }\\n\\n        return minDifference; // Return the minimum difference\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int N = nums.size(); // Number of elements in the input vector\\n        int n = N / 2; // Half the size of the vector\\n        vector<vector<int>> leftSum(n + 1), rightSum(n + 1); // Two-dimensional vectors to store the sums of subsets\\n\\n        // Generate all possible subsets of the input vector\\n        int countLimitMask = ((1 << n) - 1); // Mask to iterate through subsets\\n        for (int i = 0; i <= countLimitMask; i++) {\\n            int leftSize = 0; // Number of elements in the current left subset\\n            int leftSumValue = 0; // Sum of elements in the left subset\\n            int rightSumValue = 0; // Sum of elements in the right subset\\n\\n            // Iterate through the binary representation of the subset\\n            for (int j = 0; j < n; j++) {\\n                if (i & (1 << j)) { // Check if the j-th bit is set in the subset\\n                    leftSize++;\\n                    leftSumValue += nums[j]; // Add the j-th element to the left subset sum\\n                    rightSumValue += nums[j + n]; // Add the (j+n)-th element to the right subset sum\\n                }\\n            }\\n\\n            // Store the sums in the corresponding size vectors\\n            leftSum[leftSize].push_back(leftSumValue);\\n            rightSum[leftSize].push_back(rightSumValue);\\n        }\\n\\n        int totalSum = accumulate(nums.begin(), nums.end(), 0); // Calculate the total sum of all elements\\n        int minDifference = min(abs(totalSum - 2 * leftSum[n][0]), abs(totalSum - 2 * rightSum[n][0])); // Calculate the initial minimum difference\\n\\n        // Sort the rightSum vectors for binary search later\\n        for (int rightSize = 0; rightSize <= n; rightSize++) {\\n            sort(rightSum[rightSize].begin(), rightSum[rightSize].end());\\n        }\\n\\n        // Iterate through the leftSum vectors\\n        for (int leftSize = 1; leftSize < n; leftSize++) {\\n            for (auto &leftSumValue : leftSum[leftSize]) { // Iterate through the subsets of size leftSize in the leftSum vector\\n                int desiredRightSum = (totalSum - 2 * leftSumValue) / 2; // Calculate the desired sum for the right subset\\n                int rightSize = n - leftSize; // Calculate the size of the right subset\\n                auto &rightSums = rightSum[rightSize]; // Get the corresponding rightSum vector\\n\\n                auto itr = lower_bound(rightSums.begin(), rightSums.end(), desiredRightSum); // Find the lower bound of the desired sum in the rightSum vector\\n                if (itr != rightSums.end()) { // If a valid sum is found\\n                    minDifference = min(minDifference, abs(totalSum - 2 * leftSumValue - 2 * (*itr))); // Update the minimum difference if necessary\\n                }\\n                if (itr != rightSums.begin()) { // If the lower bound is not the first element\\n                    itr--; // Move to the previous element\\n                    minDifference = min(minDifference, abs(totalSum - 2 * leftSumValue - 2 * (*itr))); // Update the minimum difference if necessary\\n                }\\n            }\\n        }\\n\\n        return minDifference; // Return the minimum difference\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685851,
                "title": "shortest-solution-by-far-smallest-memory-16-8mb-good-runtime-1500ms",
                "content": "# Intuition\\nThis is a tight implementation of the meet-in-the-middle strategy.\\n\\n# Approach\\nFor the general approach see other solutions.\\n\\nThe tightness comes from merging the subset sums of left half and right half together before looking for closest matches. The merging is using only integers, by making sure the left sums are divisible by 4, and the right sums are 1 mod 4. We stick to integers so that `sorted` is as fast as it can be.\\n\\nWe thus get the correct answer multiplyied by four, with an extra +-1. We don\\'t use multiples of 2, because then we wouldn\\'t know how to divide by 2. By using 4, we know if to do -+1 by the residue mod 4.\\n\\n# Complexity\\n- Time complexity:\\nO(n2^(n))\\n\\n- Space complexity:\\nO(2^n)\\n\\n# Code\\n```python\\nfrom itertools import chain, combinations, pairwise\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        h, ss, nums = len(nums)//2, 4*sum(nums), sorted(8*n for n in nums)\\n        four_ret = min(\\n            abs(x1 - x2)\\n            for i in range(h+1)\\n            for x1, x2 in pairwise(sorted(chain(\\n                map(sum, combinations(nums[h:], h-i)),\\n                (ss-sum(l)+1 for l in combinations(nums[:h], i)),\\n            )))\\n            if x1%2 != x2%2\\n        )\\n        return (four_ret + four_ret % 4 - 2)//4\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nfrom itertools import chain, combinations, pairwise\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        h, ss, nums = len(nums)//2, 4*sum(nums), sorted(8*n for n in nums)\\n        four_ret = min(\\n            abs(x1 - x2)\\n            for i in range(h+1)\\n            for x1, x2 in pairwise(sorted(chain(\\n                map(sum, combinations(nums[h:], h-i)),\\n                (ss-sum(l)+1 for l in combinations(nums[:h], i)),\\n            )))\\n            if x1%2 != x2%2\\n        )\\n        return (four_ret + four_ret % 4 - 2)//4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655162,
                "title": "swift-solution-with-detailed-explanations-and-dry-run",
                "content": "# Approach\\n1. The input array is split into two halves.\\n2. All possible subsets of each half are generated using a bit manipulation technique.\\n3. The sums of the subsets are calculated and stored in ans arrays based on the number of set bits (non-zero bits) in the subset\\'s representation.\\n4. The subsets are sorted in ascending order within each ans array.\\n5. The two halves are compared by iterating over their corresponding subsets to find the minimum difference.\\n\\n\\n# Explanation\\n\\n1. The main function is `minimumDifference` that takes an array of integers (`nums`) as input and returns the minimum difference between two subsets of `nums`.\\n2. The length of the array `nums` is stored in `n`.\\n3. If the length of `nums` is 2, the absolute difference between the two elements is returned as the minimum difference.\\n4. The `generate` function is called twice to generate two lists of subsets from the left and right halves of `nums`.\\n5. The variable `ans` is initialized with the maximum possible integer value.\\n6. A loop is performed from 0 to `n/2` (inclusive) to consider different splits of the subsets.\\n7. For each split, two subsets `arr1` and `arr2` are obtained from the generated lists.\\n8. The variable `k` stores the length of the subsets.\\n9. Pointers `i1` and `i2` are initialized to 0 to iterate over the subsets.\\n10. While both pointers are within range (`i1 < k` and `i2 < k`), the difference between the corresponding elements of `arr1` and `arr2` is calculated.\\n11. The absolute difference is compared with the current minimum difference (`ans`) and updated if necessary.\\n12. If the difference is less than or equal to 0, `i1` is incremented to move to the next element in `arr1`.\\n13. If the difference is greater than or equal to 0, `i2` is incremented to move to the next element in `arr2`.\\n14. After the loop, the minimum difference (`ans`) is returned.\\n\\nThe `generate` function is a helper function used to generate subsets and calculate their sums efficiently.\\n\\n# Dry Run\\n\\nSure, here is the dry run of the code for the example array [3,9,7,3].\\n\\nInput: nums = [3,9,7,3]\\n\\nStep 1: Check if the input array has only 2 elements. If yes, then return the absolute difference between the two elements.\\nnums.count = 4 > 2\\n\\nStep 2: Generate the two lists, lists1 and lists2, of all possible sums of subsets of the first and second half of the input array, respectively.\\nlists1 = [[3], [6], [9]]\\nlists2 = [[3], [10], [13]]\\n\\nStep 3: Initialize ans to Int.max.\\nans = 9\\n\\nStep 4: Iterate over all the combinations of sums in lists1 and lists2.\\n```\\nfor d in 0...2 {\\n    let arr1 = lists1[d], arr2 = lists2[d]\\n    let k = arr1.count\\n    var i1 = 0, i2 = 0\\n    while i1 < k && i2 < k {\\n        let diff = arr1[i1] - arr2[i2]\\n        ans = min(ans, abs(diff))\\n        if diff <= 0 { i1 += 1 }\\n        if diff >= 0 { i2 += 1 }\\n    }\\n}\\n```\\n\\nStep 5: Return ans.\\nans = 2\\n\\n\\nThe code works by first generating the two lists, lists1 and lists2, of all possible sums of subsets of the first and second half of the input array, respectively. Then, it iterates over all the combinations of sums in lists1 and lists2 and finds the minimum difference between any two sums. The minimum difference is then returned.\\n\\nIn the example above, the minimum difference between any two sums in lists1 and lists2 is 2. This is because the difference between the smallest sum in lists1 and the largest sum in lists2 is 2. Therefore, the code returns 2.\\n\\n# Complexity\\n- Time complexity: The function first calls the generate function, which has a time complexity of `O(2^n)`, where `n` is the number of elements in the input array. Then, the function iterates over all pairs of lists generated by the `generate` function, and for each pair, it iterates over the lists to find the minimum difference. This gives a total time complexity of `O(2^n * n^2)`.\\n- Space complexity: The function uses two arrays of size `n + 1` to store the lists generated by the generate function. It also uses a temporary array of size `n` to store the sum of the elements in the input array. Therefore, the space complexity of the function is `O(n^2)`.\\n\\n# Code\\n```\\nclass Solution {\\n    func minimumDifference(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        if n == 2 { return abs(nums[1] - nums[0]) }\\n        let lists1 = generate(Array(nums[0..<n / 2]))\\n        let lists2 = generate(Array(nums[n / 2..<n]))\\n        var ans = Int.max\\n        for d in 0...n / 2 {\\n            let arr1 = lists1[d], arr2 = lists2[d]\\n            let k = arr1.count\\n            var i1 = 0, i2 = 0\\n            while i1 < k && i2 < k {\\n                let diff = arr1[i1] - arr2[i2]\\n                ans = min(ans, abs(diff))\\n                if diff <= 0 { i1 += 1 }\\n                if diff >= 0 { i2 += 1 }\\n            }\\n        }\\n        return ans\\n    }\\n\\n    private func generate(_ nums: [Int]) -> [[Int]] {\\n        let n = nums.count\\n        var total = 0\\n        for num in nums { total += num }\\n        var ans = [[Int]](repeating: [], count: n + 1)\\n        var pos = [Int](repeating: 0, count: n + 1)\\n        var binomial = 1\\n        for i in 0...n {\\n            ans[i] = [Int](repeating: 0, count: binomial)\\n            binomial = binomial * (n - i) / (i + 1)\\n        }\\n        let maxValue = 1 << n\\n        for key in 0..<maxValue {\\n            var sum1 = 0\\n            for i in 0..<n {\\n                if (key >> i & 1) == 1 { sum1 += nums[i] }\\n            }\\n            let sum2 = total - sum1\\n            let bits = key.nonzeroBitCount\\n            ans[bits][pos[bits]] = sum1 - sum2\\n            pos[bits] += 1\\n        }\\n        for i in 0...n { ans[i].sort() }\\n        return ans\\n    }\\n}\\n```\\n\\n# Please UpVote if you find it Useful. \\uD83D\\uDE42",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfor d in 0...2 {\\n    let arr1 = lists1[d], arr2 = lists2[d]\\n    let k = arr1.count\\n    var i1 = 0, i2 = 0\\n    while i1 < k && i2 < k {\\n        let diff = arr1[i1] - arr2[i2]\\n        ans = min(ans, abs(diff))\\n        if diff <= 0 { i1 += 1 }\\n        if diff >= 0 { i2 += 1 }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func minimumDifference(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        if n == 2 { return abs(nums[1] - nums[0]) }\\n        let lists1 = generate(Array(nums[0..<n / 2]))\\n        let lists2 = generate(Array(nums[n / 2..<n]))\\n        var ans = Int.max\\n        for d in 0...n / 2 {\\n            let arr1 = lists1[d], arr2 = lists2[d]\\n            let k = arr1.count\\n            var i1 = 0, i2 = 0\\n            while i1 < k && i2 < k {\\n                let diff = arr1[i1] - arr2[i2]\\n                ans = min(ans, abs(diff))\\n                if diff <= 0 { i1 += 1 }\\n                if diff >= 0 { i2 += 1 }\\n            }\\n        }\\n        return ans\\n    }\\n\\n    private func generate(_ nums: [Int]) -> [[Int]] {\\n        let n = nums.count\\n        var total = 0\\n        for num in nums { total += num }\\n        var ans = [[Int]](repeating: [], count: n + 1)\\n        var pos = [Int](repeating: 0, count: n + 1)\\n        var binomial = 1\\n        for i in 0...n {\\n            ans[i] = [Int](repeating: 0, count: binomial)\\n            binomial = binomial * (n - i) / (i + 1)\\n        }\\n        let maxValue = 1 << n\\n        for key in 0..<maxValue {\\n            var sum1 = 0\\n            for i in 0..<n {\\n                if (key >> i & 1) == 1 { sum1 += nums[i] }\\n            }\\n            let sum2 = total - sum1\\n            let bits = key.nonzeroBitCount\\n            ans[bits][pos[bits]] = sum1 - sum2\\n            pos[bits] += 1\\n        }\\n        for i in 0...n { ans[i].sort() }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606069,
                "title": "why-tabulation-not-working-what-is-meet-in-middle-all-questions-answered",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n## The reason why tabulation fails in this case is because encountering negative elements in the given array can lead to a negative total sum or range. When the range becomes negative or zero, it becomes impossible to create a 2D matrix of size less than zero or zero.\\n\\nFor example, let\\'s say we have an array [1, -2, 3, -4]. If we try to use tabulation to solve a problem related to this array, we might encounter a negative range. Let\\'s consider a range from index 1 to index 2. The sum of this range is -2 + 3 = 1. If we encounter a negative range like this, it is not possible to create a 2D matrix to store the values of the range sums because we cannot have a matrix of negative size.\\n\\nSimilarly, if the range sum becomes zero, for example, a range sum of 0 + 0 = 0, it is also impossible to create a 2D matrix because we cannot have a matrix of size zero.\\n\\nDue to these limitations, tabulation fails when encountering negative elements or when the total sum or range becomes negative or zero. In such cases, we need to follow an alternative approach known as the \"Meet in the Middle\" method to handle these scenarios and find a solution.\\nThe \"meet in the middle\" approach is a technique used to solve optimization problems by dividing the problem into two parts, solving each part separately, and then combining the results to find the optimal solution. This approach is commonly used when the problem size is too large to solve using a brute force or dynamic programming approach.\\n\\nIn the given code, the objective is to partition an array (nums) into two arrays such that the difference between the sums of the two arrays is minimized.\\n\\nNow let\\'s go through the code line by line:\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nint n = nums.size();: This line initializes the variable n with the size of the input array nums.\\n\\nint N = n/2;: Here, N is set to half the size of the array nums. This will be used later to divide the array into two parts.\\n\\nvector<vector<int>> left(N+1), right(N+1);: Two vectors of vectors (left and right) are created, each of size N+1. These vectors will store the possible sums of the left and right partitions.\\n\\nint sum = accumulate(nums.begin(), nums.end(), 0);: The variable sum is calculated by summing all the elements in the nums array using the accumulate function.\\n\\nThe next block of code consists of nested loops and is used to find all possible subarrays by using a bitmask approach.\\n\\nfor (int mask = 0; mask < (1 << N); mask++): This loop iterates over all possible bitmasks with N bits. The bitmask is used to select elements from the nums array to form subarrays.\\n\\nint size = 0;, int sum1 = 0, sum2 = 0;: These variables are initialized to keep track of the size, sum of elements in the left subarray (sum1), and sum of elements in the right subarray (sum2).\\n\\nThe next inner loop (for (int j = 0; j < N; j++)) iterates over the bits of the current bitmask.\\n\\nif (mask & (1 << j)): This condition checks if the jth bit of the bitmask is set.\\n\\nIf the condition in the previous line is true, the jth element from the nums array is added to sum1 (for the left subarray) and sum2 (for the right subarray), and the size is incremented.\\n\\nleft[size].push_back(sum1);, right[size].push_back(sum2);: The sums of the left and right subarrays are stored in their respective vectors (left and right) based on the current size.\\n\\nfor (int i = 0; i < N; i++): This loop is used to sort the right vectors in ascending order, allowing efficient searching later.\\n\\nint ans = abs(sum - 2 * left[N][0]);: The variable ans is initialized with the difference between the total sum of the array nums and twice the sum of the first element in the left vector with size equal to N.\\n\\nThe next block of code consists of nested loops to find the optimal partition.\\n\\nThe outer loop (for (int i = 1; i < N; i++)) iterates from 1 to N-1, representing the possible sizes of the left subarrays.\\n\\nThe inner loop (for (auto it : left[i])) iterates over the elements in the `left[i]vector, which contains the sums of left subarrays with sizei`.\\n\\nInside the inner loop, the variable it represents the current sum of the left subarray.\\n\\nint b = (sum - 2 * it) / 2;: The variable b is calculated as half the difference between the total sum of the array nums and twice the current sum of the left subarray. This value represents the target sum for the right subarray to balance the partition.\\n\\nint right_indx = N - i;: The variable right_indx is set to the index of the right subarray vector corresponding to the remaining size after selecting i elements for the left subarray.\\n\\nauto itr = lower_bound(right[right_indx].begin(), right[right_indx].end(), b);: The lower_bound function is used to find an iterator pointing to the first element in the sorted right[right_indx] vector that is not less than b. This is done to find a possible sum in the right subarray that balances the partition.\\n\\nif (itr != right[right_indx].end()): This condition checks if a valid iterator is found, indicating that a sum in the right subarray was found that balances the partition.\\n\\nIf the condition is true, the current difference between the total sum and twice the sum of the left subarray and the sum found in the right subarray (it + *itr) is calculated. If this difference is smaller than the current answer (ans), the answer is updated.\\n\\nFinally, the ans variable, representing the minimum difference between the sums of the two partitions, is returned as the result.\\n\\nTo summarize, the code follows a \"meet in the middle\" approach to partition the input array into two subarrays. It generates all possible subarrays using bitmasks, calculates their sums, and stores them in separate vectors. Then, it iterates over the left subarray sizes and finds a corresponding sum in the right subarray to balance the partition. The minimum difference between the sums is continuously updated, and the final result is returned.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nThe time complexity of the above code can be analyzed as follows:\\n\\nGenerating Subarrays: The nested loop that generates all possible subarrays using bitmasks has a time complexity of O(2^N * N), where N is the size of the input array nums. This is because there are 2^N possible bitmasks, and for each bitmask, we iterate through N elements in the array.\\n\\nSorting Right Subarray Sums: The subsequent loop that sorts the right subarray sums has a time complexity of O(N * log(N)), where N is the size of the right subarray. This sorting operation is performed N times for N different subarray sizes.\\n\\nSearching for Optimal Partition: The nested loop used to find the optimal partition iterates through all possible left subarray sizes and performs a binary search on the right subarray sums. This loop has a time complexity of O(N^2 * log(N)), where N is the size of the left subarray.\\n\\nTherefore, the overall time complexity of the code can be approximated as O(2^N * N + N^2 * log(N)). The dominant factor is the generation of subarrays, which grows exponentially with the size of the input array.\\n\\nVideo:\\nYou can watch this video to get the idea:\\nhttps://www.youtube.com/watch?v=JUFHwaZjO_M&ab_channel=HappyEngineeringWithAnmol\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int arraySize = nums.size(); // Get the size of the input array\\n        int subarraySize = arraySize / 2; // Calculate the desired size for the left subarray\\n        vector<vector<int>> leftSums(subarraySize + 1), rightSums(subarraySize + 1); // Vectors to store left and right subarray sums\\n        int totalSum = accumulate(nums.begin(), nums.end(), 0); // Calculate the total sum of the array\\n\\n        // Generate all possible subarrays using bitmasks\\n        for (int bitmask = 0; bitmask < (1 << subarraySize); bitmask++) { // Iterate over all possible bitmasks\\n            int subarrayElements = 0; // Track the size of the current subarray\\n            int leftSum = 0, rightSum = 0; // Track the sums of elements in the left and right subarrays\\n\\n            // Iterate over the bits of the current bitmask\\n            for (int i = 0; i < subarraySize; i++) {\\n                if (bitmask & (1 << i)) { // Check if the i-th bit is set\\n                    subarrayElements++; // Increment the size of the subarray\\n                    leftSum += nums[i]; // Add the i-th element to the left subarray sum\\n                    rightSum += nums[i + subarraySize]; // Add the corresponding element to the right subarray sum\\n                }\\n            }\\n\\n            // Store the sums in their respective vectors based on the subarray size\\n            leftSums[subarrayElements].push_back(leftSum);\\n            rightSums[subarrayElements].push_back(rightSum);\\n        }\\n\\n        // Sort the right subarray sums for efficient searching\\n        for (int i = 0; i < subarraySize; i++) {\\n            sort(rightSums[i].begin(), rightSums[i].end());\\n        }\\n\\n        int minDifference = abs(totalSum - 2 * leftSums[subarraySize][0]); // Initialize the answer with the difference between the total sum and twice the sum of the first left subarray\\n\\n        // Find the optimal partition by iterating over left subarray sizes\\n        for (int i = 1; i < subarraySize; i++) {\\n            for (auto sum : leftSums[i]) { // Iterate over sums of left subarrays with size i\\n                int targetSum = (totalSum - 2 * sum) / 2; // Calculate the target sum for the right subarray\\n                int rightSubarrayIndex = subarraySize - i; // Get the index of the right subarray vector\\n\\n                auto itr = lower_bound(rightSums[rightSubarrayIndex].begin(), rightSums[rightSubarrayIndex].end(), targetSum); // Find the lower bound in the right subarray\\n\\n                if (itr != rightSums[rightSubarrayIndex].end()) { // Check if a valid lower bound is found\\n                    minDifference = min(minDifference, abs(totalSum - 2 * (sum + *itr))); // Update the answer if a better partition is found\\n                }\\n            }\\n        }\\n\\n        return minDifference; // Return the minimum difference between the sums of the two partitions\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int arraySize = nums.size(); // Get the size of the input array\\n        int subarraySize = arraySize / 2; // Calculate the desired size for the left subarray\\n        vector<vector<int>> leftSums(subarraySize + 1), rightSums(subarraySize + 1); // Vectors to store left and right subarray sums\\n        int totalSum = accumulate(nums.begin(), nums.end(), 0); // Calculate the total sum of the array\\n\\n        // Generate all possible subarrays using bitmasks\\n        for (int bitmask = 0; bitmask < (1 << subarraySize); bitmask++) { // Iterate over all possible bitmasks\\n            int subarrayElements = 0; // Track the size of the current subarray\\n            int leftSum = 0, rightSum = 0; // Track the sums of elements in the left and right subarrays\\n\\n            // Iterate over the bits of the current bitmask\\n            for (int i = 0; i < subarraySize; i++) {\\n                if (bitmask & (1 << i)) { // Check if the i-th bit is set\\n                    subarrayElements++; // Increment the size of the subarray\\n                    leftSum += nums[i]; // Add the i-th element to the left subarray sum\\n                    rightSum += nums[i + subarraySize]; // Add the corresponding element to the right subarray sum\\n                }\\n            }\\n\\n            // Store the sums in their respective vectors based on the subarray size\\n            leftSums[subarrayElements].push_back(leftSum);\\n            rightSums[subarrayElements].push_back(rightSum);\\n        }\\n\\n        // Sort the right subarray sums for efficient searching\\n        for (int i = 0; i < subarraySize; i++) {\\n            sort(rightSums[i].begin(), rightSums[i].end());\\n        }\\n\\n        int minDifference = abs(totalSum - 2 * leftSums[subarraySize][0]); // Initialize the answer with the difference between the total sum and twice the sum of the first left subarray\\n\\n        // Find the optimal partition by iterating over left subarray sizes\\n        for (int i = 1; i < subarraySize; i++) {\\n            for (auto sum : leftSums[i]) { // Iterate over sums of left subarrays with size i\\n                int targetSum = (totalSum - 2 * sum) / 2; // Calculate the target sum for the right subarray\\n                int rightSubarrayIndex = subarraySize - i; // Get the index of the right subarray vector\\n\\n                auto itr = lower_bound(rightSums[rightSubarrayIndex].begin(), rightSums[rightSubarrayIndex].end(), targetSum); // Find the lower bound in the right subarray\\n\\n                if (itr != rightSums[rightSubarrayIndex].end()) { // Check if a valid lower bound is found\\n                    minDifference = min(minDifference, abs(totalSum - 2 * (sum + *itr))); // Update the answer if a better partition is found\\n                }\\n            }\\n        }\\n\\n        return minDifference; // Return the minimum difference between the sums of the two partitions\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606054,
                "title": "why-tabulation-not-working-what-is-meet-in-middle-all-questions-answered",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n## The reason why tabulation fails in this case is because encountering negative elements in the given array can lead to a negative total sum or range. When the range becomes negative or zero, it becomes impossible to create a 2D matrix of size less than zero or zero.\\n\\nFor example, let\\'s say we have an array [1, -2, 3, -4]. If we try to use tabulation to solve a problem related to this array, we might encounter a negative range. Let\\'s consider a range from index 1 to index 2. The sum of this range is -2 + 3 = 1. If we encounter a negative range like this, it is not possible to create a 2D matrix to store the values of the range sums because we cannot have a matrix of negative size.\\n\\nSimilarly, if the range sum becomes zero, for example, a range sum of 0 + 0 = 0, it is also impossible to create a 2D matrix because we cannot have a matrix of size zero.\\n\\nDue to these limitations, tabulation fails when encountering negative elements or when the total sum or range becomes negative or zero. In such cases, we need to follow an alternative approach known as the \"Meet in the Middle\" method to handle these scenarios and find a solution.\\nThe \"meet in the middle\" approach is a technique used to solve optimization problems by dividing the problem into two parts, solving each part separately, and then combining the results to find the optimal solution. This approach is commonly used when the problem size is too large to solve using a brute force or dynamic programming approach.\\n\\nIn the given code, the objective is to partition an array (nums) into two arrays such that the difference between the sums of the two arrays is minimized.\\n\\nNow let\\'s go through the code line by line:\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nint n = nums.size();: This line initializes the variable n with the size of the input array nums.\\n\\nint N = n/2;: Here, N is set to half the size of the array nums. This will be used later to divide the array into two parts.\\n\\nvector<vector<int>> left(N+1), right(N+1);: Two vectors of vectors (left and right) are created, each of size N+1. These vectors will store the possible sums of the left and right partitions.\\n\\nint sum = accumulate(nums.begin(), nums.end(), 0);: The variable sum is calculated by summing all the elements in the nums array using the accumulate function.\\n\\nThe next block of code consists of nested loops and is used to find all possible subarrays by using a bitmask approach.\\n\\nfor (int mask = 0; mask < (1 << N); mask++): This loop iterates over all possible bitmasks with N bits. The bitmask is used to select elements from the nums array to form subarrays.\\n\\nint size = 0;, int sum1 = 0, sum2 = 0;: These variables are initialized to keep track of the size, sum of elements in the left subarray (sum1), and sum of elements in the right subarray (sum2).\\n\\nThe next inner loop (for (int j = 0; j < N; j++)) iterates over the bits of the current bitmask.\\n\\nif (mask & (1 << j)): This condition checks if the jth bit of the bitmask is set.\\n\\nIf the condition in the previous line is true, the jth element from the nums array is added to sum1 (for the left subarray) and sum2 (for the right subarray), and the size is incremented.\\n\\nleft[size].push_back(sum1);, right[size].push_back(sum2);: The sums of the left and right subarrays are stored in their respective vectors (left and right) based on the current size.\\n\\nfor (int i = 0; i < N; i++): This loop is used to sort the right vectors in ascending order, allowing efficient searching later.\\n\\nint ans = abs(sum - 2 * left[N][0]);: The variable ans is initialized with the difference between the total sum of the array nums and twice the sum of the first element in the left vector with size equal to N.\\n\\nThe next block of code consists of nested loops to find the optimal partition.\\n\\nThe outer loop (for (int i = 1; i < N; i++)) iterates from 1 to N-1, representing the possible sizes of the left subarrays.\\n\\nThe inner loop (for (auto it : left[i])) iterates over the elements in the `left[i]vector, which contains the sums of left subarrays with sizei`.\\n\\nInside the inner loop, the variable it represents the current sum of the left subarray.\\n\\nint b = (sum - 2 * it) / 2;: The variable b is calculated as half the difference between the total sum of the array nums and twice the current sum of the left subarray. This value represents the target sum for the right subarray to balance the partition.\\n\\nint right_indx = N - i;: The variable right_indx is set to the index of the right subarray vector corresponding to the remaining size after selecting i elements for the left subarray.\\n\\nauto itr = lower_bound(right[right_indx].begin(), right[right_indx].end(), b);: The lower_bound function is used to find an iterator pointing to the first element in the sorted right[right_indx] vector that is not less than b. This is done to find a possible sum in the right subarray that balances the partition.\\n\\nif (itr != right[right_indx].end()): This condition checks if a valid iterator is found, indicating that a sum in the right subarray was found that balances the partition.\\n\\nIf the condition is true, the current difference between the total sum and twice the sum of the left subarray and the sum found in the right subarray (it + *itr) is calculated. If this difference is smaller than the current answer (ans), the answer is updated.\\n\\nFinally, the ans variable, representing the minimum difference between the sums of the two partitions, is returned as the result.\\n\\nTo summarize, the code follows a \"meet in the middle\" approach to partition the input array into two subarrays. It generates all possible subarrays using bitmasks, calculates their sums, and stores them in separate vectors. Then, it iterates over the left subarray sizes and finds a corresponding sum in the right subarray to balance the partition. The minimum difference between the sums is continuously updated, and the final result is returned.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nThe time complexity of the above code can be analyzed as follows:\\n\\nGenerating Subarrays: The nested loop that generates all possible subarrays using bitmasks has a time complexity of O(2^N * N), where N is the size of the input array nums. This is because there are 2^N possible bitmasks, and for each bitmask, we iterate through N elements in the array.\\n\\nSorting Right Subarray Sums: The subsequent loop that sorts the right subarray sums has a time complexity of O(N * log(N)), where N is the size of the right subarray. This sorting operation is performed N times for N different subarray sizes.\\n\\nSearching for Optimal Partition: The nested loop used to find the optimal partition iterates through all possible left subarray sizes and performs a binary search on the right subarray sums. This loop has a time complexity of O(N^2 * log(N)), where N is the size of the left subarray.\\n\\nTherefore, the overall time complexity of the code can be approximated as O(2^N * N + N^2 * log(N)). The dominant factor is the generation of subarrays, which grows exponentially with the size of the input array.\\n\\nVideo:\\nYou can watch this video to get the idea:\\nhttps://www.youtube.com/watch?v=JUFHwaZjO_M&ab_channel=HappyEngineeringWithAnmol\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int arraySize = nums.size(); // Get the size of the input array\\n        int subarraySize = arraySize / 2; // Calculate the desired size for the left subarray\\n        vector<vector<int>> leftSums(subarraySize + 1), rightSums(subarraySize + 1); // Vectors to store left and right subarray sums\\n        int totalSum = accumulate(nums.begin(), nums.end(), 0); // Calculate the total sum of the array\\n\\n        // Generate all possible subarrays using bitmasks\\n        for (int bitmask = 0; bitmask < (1 << subarraySize); bitmask++) { // Iterate over all possible bitmasks\\n            int subarrayElements = 0; // Track the size of the current subarray\\n            int leftSum = 0, rightSum = 0; // Track the sums of elements in the left and right subarrays\\n\\n            // Iterate over the bits of the current bitmask\\n            for (int i = 0; i < subarraySize; i++) {\\n                if (bitmask & (1 << i)) { // Check if the i-th bit is set\\n                    subarrayElements++; // Increment the size of the subarray\\n                    leftSum += nums[i]; // Add the i-th element to the left subarray sum\\n                    rightSum += nums[i + subarraySize]; // Add the corresponding element to the right subarray sum\\n                }\\n            }\\n\\n            // Store the sums in their respective vectors based on the subarray size\\n            leftSums[subarrayElements].push_back(leftSum);\\n            rightSums[subarrayElements].push_back(rightSum);\\n        }\\n\\n        // Sort the right subarray sums for efficient searching\\n        for (int i = 0; i < subarraySize; i++) {\\n            sort(rightSums[i].begin(), rightSums[i].end());\\n        }\\n\\n        int minDifference = abs(totalSum - 2 * leftSums[subarraySize][0]); // Initialize the answer with the difference between the total sum and twice the sum of the first left subarray\\n\\n        // Find the optimal partition by iterating over left subarray sizes\\n        for (int i = 1; i < subarraySize; i++) {\\n            for (auto sum : leftSums[i]) { // Iterate over sums of left subarrays with size i\\n                int targetSum = (totalSum - 2 * sum) / 2; // Calculate the target sum for the right subarray\\n                int rightSubarrayIndex = subarraySize - i; // Get the index of the right subarray vector\\n\\n                auto itr = lower_bound(rightSums[rightSubarrayIndex].begin(), rightSums[rightSubarrayIndex].end(), targetSum); // Find the lower bound in the right subarray\\n\\n                if (itr != rightSums[rightSubarrayIndex].end()) { // Check if a valid lower bound is found\\n                    minDifference = min(minDifference, abs(totalSum - 2 * (sum + *itr))); // Update the answer if a better partition is found\\n                }\\n            }\\n        }\\n\\n        return minDifference; // Return the minimum difference between the sums of the two partitions\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int arraySize = nums.size(); // Get the size of the input array\\n        int subarraySize = arraySize / 2; // Calculate the desired size for the left subarray\\n        vector<vector<int>> leftSums(subarraySize + 1), rightSums(subarraySize + 1); // Vectors to store left and right subarray sums\\n        int totalSum = accumulate(nums.begin(), nums.end(), 0); // Calculate the total sum of the array\\n\\n        // Generate all possible subarrays using bitmasks\\n        for (int bitmask = 0; bitmask < (1 << subarraySize); bitmask++) { // Iterate over all possible bitmasks\\n            int subarrayElements = 0; // Track the size of the current subarray\\n            int leftSum = 0, rightSum = 0; // Track the sums of elements in the left and right subarrays\\n\\n            // Iterate over the bits of the current bitmask\\n            for (int i = 0; i < subarraySize; i++) {\\n                if (bitmask & (1 << i)) { // Check if the i-th bit is set\\n                    subarrayElements++; // Increment the size of the subarray\\n                    leftSum += nums[i]; // Add the i-th element to the left subarray sum\\n                    rightSum += nums[i + subarraySize]; // Add the corresponding element to the right subarray sum\\n                }\\n            }\\n\\n            // Store the sums in their respective vectors based on the subarray size\\n            leftSums[subarrayElements].push_back(leftSum);\\n            rightSums[subarrayElements].push_back(rightSum);\\n        }\\n\\n        // Sort the right subarray sums for efficient searching\\n        for (int i = 0; i < subarraySize; i++) {\\n            sort(rightSums[i].begin(), rightSums[i].end());\\n        }\\n\\n        int minDifference = abs(totalSum - 2 * leftSums[subarraySize][0]); // Initialize the answer with the difference between the total sum and twice the sum of the first left subarray\\n\\n        // Find the optimal partition by iterating over left subarray sizes\\n        for (int i = 1; i < subarraySize; i++) {\\n            for (auto sum : leftSums[i]) { // Iterate over sums of left subarrays with size i\\n                int targetSum = (totalSum - 2 * sum) / 2; // Calculate the target sum for the right subarray\\n                int rightSubarrayIndex = subarraySize - i; // Get the index of the right subarray vector\\n\\n                auto itr = lower_bound(rightSums[rightSubarrayIndex].begin(), rightSums[rightSubarrayIndex].end(), targetSum); // Find the lower bound in the right subarray\\n\\n                if (itr != rightSums[rightSubarrayIndex].end()) { // Check if a valid lower bound is found\\n                    minDifference = min(minDifference, abs(totalSum - 2 * (sum + *itr))); // Update the answer if a better partition is found\\n                }\\n            }\\n        }\\n\\n        return minDifference; // Return the minimum difference between the sums of the two partitions\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606043,
                "title": "why-tabulation-not-working-what-is-meet-in-middle-all-questions-answered",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n## The reason why tabulation fails in this case is because encountering negative elements in the given array can lead to a negative total sum or range. When the range becomes negative or zero, it becomes impossible to create a 2D matrix of size less than zero or zero.\\n\\nFor example, let\\'s say we have an array [1, -2, 3, -4]. If we try to use tabulation to solve a problem related to this array, we might encounter a negative range. Let\\'s consider a range from index 1 to index 2. The sum of this range is -2 + 3 = 1. If we encounter a negative range like this, it is not possible to create a 2D matrix to store the values of the range sums because we cannot have a matrix of negative size.\\n\\nSimilarly, if the range sum becomes zero, for example, a range sum of 0 + 0 = 0, it is also impossible to create a 2D matrix because we cannot have a matrix of size zero.\\n\\nDue to these limitations, tabulation fails when encountering negative elements or when the total sum or range becomes negative or zero. In such cases, we need to follow an alternative approach known as the \"Meet in the Middle\" method to handle these scenarios and find a solution.\\nThe \"meet in the middle\" approach is a technique used to solve optimization problems by dividing the problem into two parts, solving each part separately, and then combining the results to find the optimal solution. This approach is commonly used when the problem size is too large to solve using a brute force or dynamic programming approach.\\n\\nIn the given code, the objective is to partition an array (nums) into two arrays such that the difference between the sums of the two arrays is minimized.\\n\\nNow let\\'s go through the code line by line:\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nint n = nums.size();: This line initializes the variable n with the size of the input array nums.\\n\\nint N = n/2;: Here, N is set to half the size of the array nums. This will be used later to divide the array into two parts.\\n\\nvector<vector<int>> left(N+1), right(N+1);: Two vectors of vectors (left and right) are created, each of size N+1. These vectors will store the possible sums of the left and right partitions.\\n\\nint sum = accumulate(nums.begin(), nums.end(), 0);: The variable sum is calculated by summing all the elements in the nums array using the accumulate function.\\n\\nThe next block of code consists of nested loops and is used to find all possible subarrays by using a bitmask approach.\\n\\nfor (int mask = 0; mask < (1 << N); mask++): This loop iterates over all possible bitmasks with N bits. The bitmask is used to select elements from the nums array to form subarrays.\\n\\nint size = 0;, int sum1 = 0, sum2 = 0;: These variables are initialized to keep track of the size, sum of elements in the left subarray (sum1), and sum of elements in the right subarray (sum2).\\n\\nThe next inner loop (for (int j = 0; j < N; j++)) iterates over the bits of the current bitmask.\\n\\nif (mask & (1 << j)): This condition checks if the jth bit of the bitmask is set.\\n\\nIf the condition in the previous line is true, the jth element from the nums array is added to sum1 (for the left subarray) and sum2 (for the right subarray), and the size is incremented.\\n\\nleft[size].push_back(sum1);, right[size].push_back(sum2);: The sums of the left and right subarrays are stored in their respective vectors (left and right) based on the current size.\\n\\nfor (int i = 0; i < N; i++): This loop is used to sort the right vectors in ascending order, allowing efficient searching later.\\n\\nint ans = abs(sum - 2 * left[N][0]);: The variable ans is initialized with the difference between the total sum of the array nums and twice the sum of the first element in the left vector with size equal to N.\\n\\nThe next block of code consists of nested loops to find the optimal partition.\\n\\nThe outer loop (for (int i = 1; i < N; i++)) iterates from 1 to N-1, representing the possible sizes of the left subarrays.\\n\\nThe inner loop (for (auto it : left[i])) iterates over the elements in the `left[i]vector, which contains the sums of left subarrays with sizei`.\\n\\nInside the inner loop, the variable it represents the current sum of the left subarray.\\n\\nint b = (sum - 2 * it) / 2;: The variable b is calculated as half the difference between the total sum of the array nums and twice the current sum of the left subarray. This value represents the target sum for the right subarray to balance the partition.\\n\\nint right_indx = N - i;: The variable right_indx is set to the index of the right subarray vector corresponding to the remaining size after selecting i elements for the left subarray.\\n\\nauto itr = lower_bound(right[right_indx].begin(), right[right_indx].end(), b);: The lower_bound function is used to find an iterator pointing to the first element in the sorted right[right_indx] vector that is not less than b. This is done to find a possible sum in the right subarray that balances the partition.\\n\\nif (itr != right[right_indx].end()): This condition checks if a valid iterator is found, indicating that a sum in the right subarray was found that balances the partition.\\n\\nIf the condition is true, the current difference between the total sum and twice the sum of the left subarray and the sum found in the right subarray (it + *itr) is calculated. If this difference is smaller than the current answer (ans), the answer is updated.\\n\\nFinally, the ans variable, representing the minimum difference between the sums of the two partitions, is returned as the result.\\n\\nTo summarize, the code follows a \"meet in the middle\" approach to partition the input array into two subarrays. It generates all possible subarrays using bitmasks, calculates their sums, and stores them in separate vectors. Then, it iterates over the left subarray sizes and finds a corresponding sum in the right subarray to balance the partition. The minimum difference between the sums is continuously updated, and the final result is returned.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nThe time complexity of the above code can be analyzed as follows:\\n\\nGenerating Subarrays: The nested loop that generates all possible subarrays using bitmasks has a time complexity of O(2^N * N), where N is the size of the input array nums. This is because there are 2^N possible bitmasks, and for each bitmask, we iterate through N elements in the array.\\n\\nSorting Right Subarray Sums: The subsequent loop that sorts the right subarray sums has a time complexity of O(N * log(N)), where N is the size of the right subarray. This sorting operation is performed N times for N different subarray sizes.\\n\\nSearching for Optimal Partition: The nested loop used to find the optimal partition iterates through all possible left subarray sizes and performs a binary search on the right subarray sums. This loop has a time complexity of O(N^2 * log(N)), where N is the size of the left subarray.\\n\\nTherefore, the overall time complexity of the code can be approximated as O(2^N * N + N^2 * log(N)). The dominant factor is the generation of subarrays, which grows exponentially with the size of the input array.\\n\\nVideo:\\nYou can watch this video to get the idea:\\nhttps://www.youtube.com/watch?v=JUFHwaZjO_M&ab_channel=HappyEngineeringWithAnmol\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int arraySize = nums.size(); // Get the size of the input array\\n        int subarraySize = arraySize / 2; // Calculate the desired size for the left subarray\\n        vector<vector<int>> leftSums(subarraySize + 1), rightSums(subarraySize + 1); // Vectors to store left and right subarray sums\\n        int totalSum = accumulate(nums.begin(), nums.end(), 0); // Calculate the total sum of the array\\n\\n        // Generate all possible subarrays using bitmasks\\n        for (int bitmask = 0; bitmask < (1 << subarraySize); bitmask++) { // Iterate over all possible bitmasks\\n            int subarrayElements = 0; // Track the size of the current subarray\\n            int leftSum = 0, rightSum = 0; // Track the sums of elements in the left and right subarrays\\n\\n            // Iterate over the bits of the current bitmask\\n            for (int i = 0; i < subarraySize; i++) {\\n                if (bitmask & (1 << i)) { // Check if the i-th bit is set\\n                    subarrayElements++; // Increment the size of the subarray\\n                    leftSum += nums[i]; // Add the i-th element to the left subarray sum\\n                    rightSum += nums[i + subarraySize]; // Add the corresponding element to the right subarray sum\\n                }\\n            }\\n\\n            // Store the sums in their respective vectors based on the subarray size\\n            leftSums[subarrayElements].push_back(leftSum);\\n            rightSums[subarrayElements].push_back(rightSum);\\n        }\\n\\n        // Sort the right subarray sums for efficient searching\\n        for (int i = 0; i < subarraySize; i++) {\\n            sort(rightSums[i].begin(), rightSums[i].end());\\n        }\\n\\n        int minDifference = abs(totalSum - 2 * leftSums[subarraySize][0]); // Initialize the answer with the difference between the total sum and twice the sum of the first left subarray\\n\\n        // Find the optimal partition by iterating over left subarray sizes\\n        for (int i = 1; i < subarraySize; i++) {\\n            for (auto sum : leftSums[i]) { // Iterate over sums of left subarrays with size i\\n                int targetSum = (totalSum - 2 * sum) / 2; // Calculate the target sum for the right subarray\\n                int rightSubarrayIndex = subarraySize - i; // Get the index of the right subarray vector\\n\\n                auto itr = lower_bound(rightSums[rightSubarrayIndex].begin(), rightSums[rightSubarrayIndex].end(), targetSum); // Find the lower bound in the right subarray\\n\\n                if (itr != rightSums[rightSubarrayIndex].end()) { // Check if a valid lower bound is found\\n                    minDifference = min(minDifference, abs(totalSum - 2 * (sum + *itr))); // Update the answer if a better partition is found\\n                }\\n            }\\n        }\\n\\n        return minDifference; // Return the minimum difference between the sums of the two partitions\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int arraySize = nums.size(); // Get the size of the input array\\n        int subarraySize = arraySize / 2; // Calculate the desired size for the left subarray\\n        vector<vector<int>> leftSums(subarraySize + 1), rightSums(subarraySize + 1); // Vectors to store left and right subarray sums\\n        int totalSum = accumulate(nums.begin(), nums.end(), 0); // Calculate the total sum of the array\\n\\n        // Generate all possible subarrays using bitmasks\\n        for (int bitmask = 0; bitmask < (1 << subarraySize); bitmask++) { // Iterate over all possible bitmasks\\n            int subarrayElements = 0; // Track the size of the current subarray\\n            int leftSum = 0, rightSum = 0; // Track the sums of elements in the left and right subarrays\\n\\n            // Iterate over the bits of the current bitmask\\n            for (int i = 0; i < subarraySize; i++) {\\n                if (bitmask & (1 << i)) { // Check if the i-th bit is set\\n                    subarrayElements++; // Increment the size of the subarray\\n                    leftSum += nums[i]; // Add the i-th element to the left subarray sum\\n                    rightSum += nums[i + subarraySize]; // Add the corresponding element to the right subarray sum\\n                }\\n            }\\n\\n            // Store the sums in their respective vectors based on the subarray size\\n            leftSums[subarrayElements].push_back(leftSum);\\n            rightSums[subarrayElements].push_back(rightSum);\\n        }\\n\\n        // Sort the right subarray sums for efficient searching\\n        for (int i = 0; i < subarraySize; i++) {\\n            sort(rightSums[i].begin(), rightSums[i].end());\\n        }\\n\\n        int minDifference = abs(totalSum - 2 * leftSums[subarraySize][0]); // Initialize the answer with the difference between the total sum and twice the sum of the first left subarray\\n\\n        // Find the optimal partition by iterating over left subarray sizes\\n        for (int i = 1; i < subarraySize; i++) {\\n            for (auto sum : leftSums[i]) { // Iterate over sums of left subarrays with size i\\n                int targetSum = (totalSum - 2 * sum) / 2; // Calculate the target sum for the right subarray\\n                int rightSubarrayIndex = subarraySize - i; // Get the index of the right subarray vector\\n\\n                auto itr = lower_bound(rightSums[rightSubarrayIndex].begin(), rightSums[rightSubarrayIndex].end(), targetSum); // Find the lower bound in the right subarray\\n\\n                if (itr != rightSums[rightSubarrayIndex].end()) { // Check if a valid lower bound is found\\n                    minDifference = min(minDifference, abs(totalSum - 2 * (sum + *itr))); // Update the answer if a better partition is found\\n                }\\n            }\\n        }\\n\\n        return minDifference; // Return the minimum difference between the sums of the two partitions\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601609,
                "title": "meet-in-the-middle",
                "content": "```\\nfrom collections import defaultdict\\nimport bisect\\n\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        total = sum(nums)\\n        target = total // 2\\n        k = n // 2\\n        left = defaultdict(set)\\n        right = defaultdict(set)\\n        for mask in range(1 << k):\\n            l = r = 0\\n            ctr = 0\\n            for i in range(k):\\n                if mask & (1 << i):\\n                    l += nums[i]\\n                    r += nums[k + i]\\n                    ctr += 1\\n            left[ctr].add(l)\\n            right[ctr].add(r)\\n        for x in list(right.keys()):\\n            right[x] = sorted(right[x])\\n        res = float(\\'inf\\')\\n        for x in left:\\n            for s in left[x]:\\n                i = bisect.bisect_left(right[k - x], target - s)\\n                if i < len(right[k - x]):\\n                    res = min(res, abs(2 * (s + right[k - x][i]) - total))\\n                if i > 0:\\n                    res = min(res, abs(2 * (s + right[k - x][i - 1]) - total))\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nimport bisect\\n\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        total = sum(nums)\\n        target = total // 2\\n        k = n // 2\\n        left = defaultdict(set)\\n        right = defaultdict(set)\\n        for mask in range(1 << k):\\n            l = r = 0\\n            ctr = 0\\n            for i in range(k):\\n                if mask & (1 << i):\\n                    l += nums[i]\\n                    r += nums[k + i]\\n                    ctr += 1\\n            left[ctr].add(l)\\n            right[ctr].add(r)\\n        for x in list(right.keys()):\\n            right[x] = sorted(right[x])\\n        res = float(\\'inf\\')\\n        for x in left:\\n            for s in left[x]:\\n                i = bisect.bisect_left(right[k - x], target - s)\\n                if i < len(right[k - x]):\\n                    res = min(res, abs(2 * (s + right[k - x][i]) - total))\\n                if i > 0:\\n                    res = min(res, abs(2 * (s + right[k - x][i - 1]) - total))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591444,
                "title": "meet-in-the-middle-with-powersets-13-lines-of-code",
                "content": "# Intuition\\nThis took me way too many approaches. Even after doing mitm I still couldn\\'t figure it out because I was missing the bisect.\\n\\n# Approach\\nTwo major realizations:\\n\\n1. You want to split your list into two sublists and find all potential sums for k elements with 0 $\\\\leq$ k $\\\\leq$ n (where n is half the length of nums.)\\n2. Then you sort one of the list of sums so that you can take the other side and know exactly which sum to check. Say the sum you\\'re going for is 5, and you have the left side of your list giving you the sum of 2. So you check the other half for any sum that\\'s close to 5 - 2 = 3. So this line in the code is where the magic happens:\\n\\n`bisect(sums_right[n - sub_len_left], goal - sub_sum_left)`\\n\\nThe resulting array will be our best guess for joining the left and right sub lists.\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^{\\\\frac n 2})$$\\n\\n- Space complexity:\\n$$O(2^{\\\\frac n 2})$$\\n\\n# Code\\n```\\nfrom itertools import chain, combinations\\nfrom bisect import *\\n\\npowerset = lambda s: chain.from_iterable([\\n    (c, r) for c in combinations(s, r)\\n] for r in range(len(s) + 1))\\n\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        nums = [i - min(nums) for i in nums]\\n        goal = sum(nums)\\n        left, right = nums[::2], nums[1::2]\\n        N, m = len(left), 9e9\\n        sums = {i: set() for i in range(N + 1)}\\n\\n        for r, n in powerset(right):\\n            sums[n].add(2 * sum(r))\\n        sums = {k: list(sorted(v)) + [9e9] for k, v in sums.items()}\\n\\n        for sub, l_n in powerset(left):\\n            l_s = 2 * sum(sub)\\n            i = bisect_left(sums[N - l_n], goal - l_s)\\n            m = min(m, abs(sums[N - l_n][i] + l_s - goal))\\n\\n        return m\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import chain, combinations\\nfrom bisect import *\\n\\npowerset = lambda s: chain.from_iterable([\\n    (c, r) for c in combinations(s, r)\\n] for r in range(len(s) + 1))\\n\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        nums = [i - min(nums) for i in nums]\\n        goal = sum(nums)\\n        left, right = nums[::2], nums[1::2]\\n        N, m = len(left), 9e9\\n        sums = {i: set() for i in range(N + 1)}\\n\\n        for r, n in powerset(right):\\n            sums[n].add(2 * sum(r))\\n        sums = {k: list(sorted(v)) + [9e9] for k, v in sums.items()}\\n\\n        for sub, l_n in powerset(left):\\n            l_s = 2 * sum(sub)\\n            i = bisect_left(sums[N - l_n], goal - l_s)\\n            m = min(m, abs(sums[N - l_n][i] + l_s - goal))\\n\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575588,
                "title": "java-solution-with-comments-and-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDifference(int[] arr) {\\n\\t\\t\\t\\n\\t\\t\\t// divide array in 2 halves\\n\\t\\t\\tint n = arr.length/2;\\n\\n\\t\\t\\t// get subset sum of first half and second half. \\n\\t\\t\\t// Map will have key as subset size and values as \\n\\t\\t\\t// list of subestsum with given size(key)\\n\\t\\t\\t// (3,9,7,3) -> 3,9 and 7,3\\n\\t\\t\\t// left-> 0-[0], 1-[3,9], 2-[12]\\n\\t\\t\\t// right-> 0-[0],1-[7,3], 2-[10]  \\n\\t\\t\\tMap<Integer, List<Integer>> left = \\tsubSetSum(arr, 0, n-1);\\n\\t\\t\\tMap<Integer, List<Integer>> right =\\tsubSetSum(arr, n, arr.length-1);\\n\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\t// Get sum of array\\n\\t\\t\\tfor(int i=0;i<arr.length;i++){\\n\\t\\t\\t\\tsum += arr[i];\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint minDiff = Integer.MAX_VALUE;\\n\\n\\t\\t\\t// Eg: ----a---/----b--- sum of subests\\n\\t\\t\\t// To mimimize:  remainingSum - (a+b)\\n\\t\\t\\t// Sum = remainingSum + (a+b)\\n\\t\\t\\t// So now to minimize: [Sum - 2*(a+b)]\\n\\n\\t\\t\\t// Now take i element sum from left map and (n-i) element\\n\\t\\t\\t// sum from right, so that we get sum of n elements.\\n\\t\\t\\t// for each subset sum in left find correspoding subset sum in b , \\n\\t\\t\\t// such that [Sum - 2*(a+b)] should be minimized.\\n\\t\\t\\t// Sort and find lower bound in right array to find the correct value of b\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\n\\t\\t\\t\\tList<Integer> leftSum = left.get(i);\\n\\t\\t\\t\\tList<Integer> rightSum = right.get(n-i);\\n\\n\\t\\t\\t\\t// sort the right array\\n\\t\\t\\t\\tCollections.sort(rightSum);\\n\\n\\t\\t\\t\\tfor(int a: leftSum){\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tint b = (sum - (2*a))/2;\\n\\n\\t\\t\\t\\t\\t// find the lower bound of expected b\\n\\t\\t\\t\\t\\tint index = findLowerBound(rightSum, b);\\n\\n\\t\\t\\t\\t\\t// get the correct b and use this in minimizing\\n\\t\\t\\t\\t\\tint b1 = rightSum.get(index);\\n\\n\\t\\t//\\tSystem.out.println(\"n: \"+n+\" A: \"+ a+\" B: \"+b+\"  SUm: \"+sum+\"  mind: \"+ minDiff+\" b1: \"+ b1 );\\n\\t\\t\\t\\t\\t\\tminDiff = Math.min(minDiff, Math.abs(sum - 2*(a+b1)));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn minDiff;\\n\\t}\\n\\n\\tint findLowerBound(List<Integer> arr, int b){\\n\\t\\tint left = 0;\\n\\t\\tint right = arr.size();\\n\\n\\t\\twhile(left < right){\\n\\n\\t\\t\\tint mid= left + (right-left)/2;\\n\\t\\t\\tif(b <= arr.get(mid)){\\n\\t\\t\\t\\tright = mid;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tleft = mid+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn left >= arr.size() ? arr.size()-1: left;\\n\\t}\\n\\n\\t// get subset sum for each set \\n\\tMap<Integer, List<Integer>> subSetSum(int[] arr, int start, int end){\\n\\n\\t\\t// max no of elements in each subset\\n\\t\\tint bits = end-start+1;\\n\\n\\t\\t// no of total subsets\\n\\t\\tint n = (int)Math.pow(2, bits);\\n\\t\\t\\n\\t\\tMap<Integer, List<Integer>> map = new HashMap<>();\\n\\t\\t\\n\\t\\t// elements in current set or the no of set bits in i\\n\\t\\tint count = 0;\\n\\t\\t// sum of current set elements\\n\\t\\tint sum = 0;\\n\\n\\t\\t// iterate over each subset\\n\\t\\tfor(int i =0;i<n;i++){\\n\\n\\t\\t\\t// for each value of bits , check if that element has to be included or not\\n\\t\\t\\tfor(int j=0;j<bits;j++){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//System.out.println(\"1<<j: \"+ (1<<j)+ \"  i:\"+i);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// shift 1 for each j times, so that the bit which are set in \\n\\t\\t\\t\\t// i will only be true and then we will include that element in our set \\n\\t\\t\\t\\tif((i & (1<<j)) != 0){\\n\\t\\t\\t\\t\\t//System.out.println(\"j: \"+ j+ \"  i:\"+i);\\n\\t\\t\\t\\t\\tsum += arr[j+start];\\n\\t\\t\\t\\t\\t++count;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmap.computeIfAbsent(count, k -> new ArrayList<>()).add(sum);\\n\\t\\t\\tcount=0;\\n\\t\\t\\tsum =0;\\n\\t\\t}\\n\\t//\\tmap.forEach((k,v) -> System.out.println(\"K: \"+ k+\"  v: \"+v.toString()));\\n\\t\\treturn map;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDifference(int[] arr) {\\n\\t\\t\\t\\n\\t\\t\\t// divide array in 2 halves\\n\\t\\t\\tint n = arr.length/2;\\n\\n\\t\\t\\t// get subset sum of first half and second half. \\n\\t\\t\\t// Map will have key as subset size and values as \\n\\t\\t\\t// list of subestsum with given size(key)\\n\\t\\t\\t// (3,9,7,3) -> 3,9 and 7,3\\n\\t\\t\\t// left-> 0-[0], 1-[3,9], 2-[12]\\n\\t\\t\\t// right-> 0-[0],1-[7,3], 2-[10]  \\n\\t\\t\\tMap<Integer, List<Integer>> left = \\tsubSetSum(arr, 0, n-1);\\n\\t\\t\\tMap<Integer, List<Integer>> right =\\tsubSetSum(arr, n, arr.length-1);\\n\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\t// Get sum of array\\n\\t\\t\\tfor(int i=0;i<arr.length;i++){\\n\\t\\t\\t\\tsum += arr[i];\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint minDiff = Integer.MAX_VALUE;\\n\\n\\t\\t\\t// Eg: ----a---/----b--- sum of subests\\n\\t\\t\\t// To mimimize:  remainingSum - (a+b)\\n\\t\\t\\t// Sum = remainingSum + (a+b)\\n\\t\\t\\t// So now to minimize: [Sum - 2*(a+b)]\\n\\n\\t\\t\\t// Now take i element sum from left map and (n-i) element\\n\\t\\t\\t// sum from right, so that we get sum of n elements.\\n\\t\\t\\t// for each subset sum in left find correspoding subset sum in b , \\n\\t\\t\\t// such that [Sum - 2*(a+b)] should be minimized.\\n\\t\\t\\t// Sort and find lower bound in right array to find the correct value of b\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\n\\t\\t\\t\\tList<Integer> leftSum = left.get(i);\\n\\t\\t\\t\\tList<Integer> rightSum = right.get(n-i);\\n\\n\\t\\t\\t\\t// sort the right array\\n\\t\\t\\t\\tCollections.sort(rightSum);\\n\\n\\t\\t\\t\\tfor(int a: leftSum){\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tint b = (sum - (2*a))/2;\\n\\n\\t\\t\\t\\t\\t// find the lower bound of expected b\\n\\t\\t\\t\\t\\tint index = findLowerBound(rightSum, b);\\n\\n\\t\\t\\t\\t\\t// get the correct b and use this in minimizing\\n\\t\\t\\t\\t\\tint b1 = rightSum.get(index);\\n\\n\\t\\t//\\tSystem.out.println(\"n: \"+n+\" A: \"+ a+\" B: \"+b+\"  SUm: \"+sum+\"  mind: \"+ minDiff+\" b1: \"+ b1 );\\n\\t\\t\\t\\t\\t\\tminDiff = Math.min(minDiff, Math.abs(sum - 2*(a+b1)));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn minDiff;\\n\\t}\\n\\n\\tint findLowerBound(List<Integer> arr, int b){\\n\\t\\tint left = 0;\\n\\t\\tint right = arr.size();\\n\\n\\t\\twhile(left < right){\\n\\n\\t\\t\\tint mid= left + (right-left)/2;\\n\\t\\t\\tif(b <= arr.get(mid)){\\n\\t\\t\\t\\tright = mid;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tleft = mid+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn left >= arr.size() ? arr.size()-1: left;\\n\\t}\\n\\n\\t// get subset sum for each set \\n\\tMap<Integer, List<Integer>> subSetSum(int[] arr, int start, int end){\\n\\n\\t\\t// max no of elements in each subset\\n\\t\\tint bits = end-start+1;\\n\\n\\t\\t// no of total subsets\\n\\t\\tint n = (int)Math.pow(2, bits);\\n\\t\\t\\n\\t\\tMap<Integer, List<Integer>> map = new HashMap<>();\\n\\t\\t\\n\\t\\t// elements in current set or the no of set bits in i\\n\\t\\tint count = 0;\\n\\t\\t// sum of current set elements\\n\\t\\tint sum = 0;\\n\\n\\t\\t// iterate over each subset\\n\\t\\tfor(int i =0;i<n;i++){\\n\\n\\t\\t\\t// for each value of bits , check if that element has to be included or not\\n\\t\\t\\tfor(int j=0;j<bits;j++){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//System.out.println(\"1<<j: \"+ (1<<j)+ \"  i:\"+i);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// shift 1 for each j times, so that the bit which are set in \\n\\t\\t\\t\\t// i will only be true and then we will include that element in our set \\n\\t\\t\\t\\tif((i & (1<<j)) != 0){\\n\\t\\t\\t\\t\\t//System.out.println(\"j: \"+ j+ \"  i:\"+i);\\n\\t\\t\\t\\t\\tsum += arr[j+start];\\n\\t\\t\\t\\t\\t++count;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmap.computeIfAbsent(count, k -> new ArrayList<>()).add(sum);\\n\\t\\t\\tcount=0;\\n\\t\\t\\tsum =0;\\n\\t\\t}\\n\\t//\\tmap.forEach((k,v) -> System.out.println(\"K: \"+ k+\"  v: \"+v.toString()));\\n\\t\\treturn map;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519067,
                "title": "example-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom itertools import combinations\\nimport bisect\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        N = len(nums) // 2\\n    \\n        def get_sums(nums):\\n            ans = {}\\n            N = len(nums)\\n            for k in range(1, N + 1):\\n                sums = []\\n                for comb in combinations(nums, k):\\n                    s = sum(comb)\\n                    sums.append(s)\\n                ans[k] = sums\\n            return ans\\n    \\n        left_part, right_part = nums[:N], nums[N:]\\n        left_sums, right_sums = get_sums(left_part), get_sums(right_part)\\n        ans = abs(sum(left_part) - sum(right_part))\\n        total = sum(nums)\\n        half = total // 2\\n    \\n        for k in range(1, N):\\n            left = left_sums[k]\\n            right = right_sums[N - k]\\n            right.sort()\\n    \\n            for x in left:\\n                r = half - x\\n                p = bisect.bisect_left(right, r)\\n                for q in [p, p - 1]:\\n                    if 0 <= q < len(right):\\n                        left_ans_sum = x + right[q]\\n                        right_ans_sum = total - left_ans_sum\\n                        diff = abs(left_ans_sum - right_ans_sum)\\n                        ans = min(ans, diff)\\n    \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import combinations\\nimport bisect\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        N = len(nums) // 2\\n    \\n        def get_sums(nums):\\n            ans = {}\\n            N = len(nums)\\n            for k in range(1, N + 1):\\n                sums = []\\n                for comb in combinations(nums, k):\\n                    s = sum(comb)\\n                    sums.append(s)\\n                ans[k] = sums\\n            return ans\\n    \\n        left_part, right_part = nums[:N], nums[N:]\\n        left_sums, right_sums = get_sums(left_part), get_sums(right_part)\\n        ans = abs(sum(left_part) - sum(right_part))\\n        total = sum(nums)\\n        half = total // 2\\n    \\n        for k in range(1, N):\\n            left = left_sums[k]\\n            right = right_sums[N - k]\\n            right.sort()\\n    \\n            for x in left:\\n                r = half - x\\n                p = bisect.bisect_left(right, r)\\n                for q in [p, p - 1]:\\n                    if 0 <= q < len(right):\\n                        left_ans_sum = x + right[q]\\n                        right_ans_sum = total - left_ans_sum\\n                        diff = abs(left_ans_sum - right_ans_sum)\\n                        ans = min(ans, diff)\\n    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512531,
                "title": "easiest-approach-but-question-is-really-difficult-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Buddhi khrb karne vala question lakin badiya question\\n    //Here we use aaporach meet in the middle\\n    // we divide the array into two halfves\\n    // left and right,left size (0,n-1) right (n,2*n-1) \\n    // now suppose we left subset have size =sz therefore right subset size=n-sz\\n    // suppse from left half we get sum=s1 and from right half we get sum =s2\\n    // so we want that abs(s2-s1)=minium \\n    // therefore s2=total sum of array -s1 means s2=sum-s1\\n    // therefore sum-s1-s1 means we have to minimise sum-2s1.\\n    // we have get  sum=s1 from leftsubset to we can binary search the s2 sum in right half\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size(), res = 0, sum = 0;\\n        sum = accumulate(nums.begin(), nums.end(),0);\\n        \\n        int N = n/2;\\n        vector<vector<int>> left(N+1), right(N+1);\\n        \\n\\t\\t//storing all possible sum in left and right part\\n        for(int mask = 0; mask<(1<<N); ++mask){\\n            int sz = 0, l = 0, r = 0;\\n            for(int i=0; i<N; ++i){\\n                if(mask&(1<<i)){\\n                    sz++;\\n                    l += nums[i];\\n                    r += nums[i+N];\\n                }\\n            }\\n            left[sz].push_back(l);\\n            right[sz].push_back(r);\\n        }\\n\\n        for(int sz=0; sz<=N; ++sz){\\n            sort(right[sz].begin(), right[sz].end());\\n        }\\n\\n        res = min(abs(sum-2*left[N][0]), abs(sum-2*right[N][0]));\\n\\n\\t\\t//iterating over left part\\n        for(int sz=1; sz<N; ++sz){\\n            for(auto &a : left[sz]){\\n                int b = (sum - 2*a)/2, rsz = N-sz;\\n                auto &v = right[rsz];\\n                auto itr = lower_bound(v.begin(), v.end(),b); //binary search over right part\\n                \\n                if(itr!=v.end()) res = min(res, abs(sum-2*(a+(*itr))));\\n                if(itr!= v.begin()){\\n                    auto it = itr; --it;\\n                    res = min(res, abs(sum-2*(a+(*it))));\\n                }                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Buddhi khrb karne vala question lakin badiya question\\n    //Here we use aaporach meet in the middle\\n    // we divide the array into two halfves\\n    // left and right,left size (0,n-1) right (n,2*n-1) \\n    // now suppose we left subset have size =sz therefore right subset size=n-sz\\n    // suppse from left half we get sum=s1 and from right half we get sum =s2\\n    // so we want that abs(s2-s1)=minium \\n    // therefore s2=total sum of array -s1 means s2=sum-s1\\n    // therefore sum-s1-s1 means we have to minimise sum-2s1.\\n    // we have get  sum=s1 from leftsubset to we can binary search the s2 sum in right half\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size(), res = 0, sum = 0;\\n        sum = accumulate(nums.begin(), nums.end(),0);\\n        \\n        int N = n/2;\\n        vector<vector<int>> left(N+1), right(N+1);\\n        \\n\\t\\t//storing all possible sum in left and right part\\n        for(int mask = 0; mask<(1<<N); ++mask){\\n            int sz = 0, l = 0, r = 0;\\n            for(int i=0; i<N; ++i){\\n                if(mask&(1<<i)){\\n                    sz++;\\n                    l += nums[i];\\n                    r += nums[i+N];\\n                }\\n            }\\n            left[sz].push_back(l);\\n            right[sz].push_back(r);\\n        }\\n\\n        for(int sz=0; sz<=N; ++sz){\\n            sort(right[sz].begin(), right[sz].end());\\n        }\\n\\n        res = min(abs(sum-2*left[N][0]), abs(sum-2*right[N][0]));\\n\\n\\t\\t//iterating over left part\\n        for(int sz=1; sz<N; ++sz){\\n            for(auto &a : left[sz]){\\n                int b = (sum - 2*a)/2, rsz = N-sz;\\n                auto &v = right[rsz];\\n                auto itr = lower_bound(v.begin(), v.end(),b); //binary search over right part\\n                \\n                if(itr!=v.end()) res = min(res, abs(sum-2*(a+(*itr))));\\n                if(itr!= v.begin()){\\n                    auto it = itr; --it;\\n                    res = min(res, abs(sum-2*(a+(*it))));\\n                }                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493046,
                "title": "my-solutions",
                "content": "**1. Sort the corresponding two groups and find minimum difference by the iteration**\\n```\\n/**\\n * divide the vector `nums` into two equal-length parts, `left_part` and `right_part`,\\n * each of which has the length of `n`.\\n * let 0 <= `i` < `n`, and `j` = `n` - `i`\\n * 1. choose `i` elements from left_part, and `j` elements from right_part into the `group_1`\\n * 2. choose `j` elements from left_part, and `i` elements from right_part into the `group_2`\\n * 3. the target is to find the minimum value of all abs(sum(group_1) - sum(group_2))\\n *    where `sum(group)` stands for the sum of all elements in the group `group`\\n * 4. let `sum_left_part_i` stand for the sum of `i` elements in the left_part\\n *        `sum_left_part_j` stand for the sum of `j` elements in the left_part\\n *        `sum_right_part_i` stand for the sum of `i` elements in the right_part\\n *        `sum_right_part_j` stand for the sum of `j` elements in the right_part\\n * 5. sum(group_1) = sum_left_part_i + sum_right_part_j\\n *    sum(group_2) = sum_right_part_i + sum_left_part_j\\n *    sum(group_1) - sum(group_2) = (sum_left_part_i + sum_right_part_j) - (sum_right_part_i + sum_left_part_j)\\n *                                = (sum_left_part_i - sum_left_part_j) - (sum_right_part_i - sum_right_part_j)\\n *\\n * the algorithm is as following\\n * 1. pre-calculate all (sum_left_part_i - sum_left_part_j),\\n *    group them by `i`,\\n *    and sort every group, or use `std::set` to make every group sorted\\n * 2. iterate every (sum_right_part_i - sum_right_part_j),\\n *    and find the closest corresponding (sum_left_part_i - sum_left_part_j)\\n *\\n * Time Complexity: O(n * (2 ^ n))\\n * Space Complexity: O(2 ^ n)\\n */\\nclass Solution {\\n public:\\n  int minimumDifference(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size()) / 2;\\n    vector<vector<int>> groups1 = generate_groups(nums, 0, n);\\n    vector<vector<int>> groups2 = generate_groups(nums, n, n);\\n    int ret = numeric_limits<int>::max();\\n    for (int i = 0; i < n && ret != 0; ++i) {\\n      const vector<int> &group1 = groups1[i];\\n      const vector<int> &group2 = groups2[i];\\n      for (int i1 = 0, i2 = 0; i1 < group1.size() && i2 < group2.size(); ) {\\n        if (group1[i1] == group2[i2]) {\\n          ret = 0;\\n          break;\\n        }\\n        ret = min(ret, abs(group1[i1] - group2[i2]));\\n        if (group1[i1] < group2[i2]) {\\n          ++i1;\\n        } else {\\n          ++i2;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  vector<vector<int>> generate_groups(const vector<int> &nums, const int start, const int n) {\\n    const int layouts = 1 << n;\\n    vector<vector<int>> ret(n);\\n    for (int layout = 0; layout < layouts - 1; ++layout) {\\n      int count = 0;\\n      int diff_sum = 0;\\n      for (int offset = 0; offset < n; ++offset) {\\n        if ((layout & (1 << offset)) == 0) {\\n          diff_sum -= nums[start + offset];\\n        } else {\\n          ++count;\\n          diff_sum += nums[start + offset];\\n        }\\n      }\\n      ret[count].emplace_back(diff_sum);\\n    }\\n    \\n    for (vector<int> &group : ret) {\\n      sort(group.begin(), group.end());\\n      group.erase(unique(group.begin(), group.end()), group.end());\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Sort the one group and iterate the corresponding another group to find the minimum difference by using `std::lower_bound`**\\n```\\n/**\\n * divide the vector `nums` into two equal-length parts, `left_part` and `right_part`,\\n * each of which has the length of `n`.\\n * let 0 <= `i` < `n`, and `j` = `n` - `i`\\n * 1. choose `i` elements from left_part, and `j` elements from right_part into the `group_1`\\n * 2. choose `j` elements from left_part, and `i` elements from right_part into the `group_2`\\n * 3. the target is to find the minimum value of all abs(sum(group_1) - sum(group_2))\\n *    where `sum(group)` stands for the sum of all elements in the group `group`\\n * 4. let `sum_left_part_i` stand for the sum of `i` elements in the left_part\\n *        `sum_left_part_j` stand for the sum of `j` elements in the left_part\\n *        `sum_right_part_i` stand for the sum of `i` elements in the right_part\\n *        `sum_right_part_j` stand for the sum of `j` elements in the right_part\\n * 5. sum(group_1) = sum_left_part_i + sum_right_part_j\\n *    sum(group_2) = sum_right_part_i + sum_left_part_j\\n *    sum(group_1) - sum(group_2) = (sum_left_part_i + sum_right_part_j) - (sum_right_part_i + sum_left_part_j)\\n *                                = (sum_left_part_i - sum_left_part_j) - (sum_right_part_i - sum_right_part_j)\\n *\\n * the algorithm is as following\\n * 1. pre-calculate all (sum_left_part_i - sum_left_part_j),\\n *    group them by `i`,\\n *    and sort every group, or use `std::set` to make every group sorted\\n * 2. iterate every (sum_right_part_i - sum_right_part_j),\\n *    and find the closest corresponding (sum_left_part_i - sum_left_part_j)\\n *\\n * Time Complexity: O(n * (2 ^ n))\\n * Space Complexity: O(2 ^ n)\\n */\\nclass Solution {\\n public:\\n  int minimumDifference(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size()) / 2;\\n    const int layouts = 1 << n;\\n    vector<int> groups[n];\\n    for (int layout = 0; layout < layouts - 1; ++layout) {\\n      int count = 0;\\n      int diff_sum = 0;\\n      for (int offset = 0; offset < n; ++offset) {\\n        if ((layout & (1 << offset)) == 0) {\\n          diff_sum -= nums[offset];\\n        } else {\\n          ++count;\\n          diff_sum += nums[offset];\\n        }\\n      }\\n      groups[count].emplace_back(diff_sum);\\n    }\\n    \\n    for (vector<int> &group : groups) {\\n      sort(group.begin(), group.end());\\n      group.erase(unique(group.begin(), group.end()), group.end());\\n    }\\n    \\n    int ret = numeric_limits<int>::max();\\n    for (int layout = 0; layout < layouts - 1 && ret != 0; ++layout) {\\n      int count = 0;\\n      int diff_sum = 0;\\n      for (int offset = 0; offset < n; ++offset) {\\n        if ((layout & (1 << offset)) == 0) {\\n          diff_sum -= nums[n + offset];\\n        } else {\\n          ++count;\\n          diff_sum += nums[n + offset];\\n        }\\n      }\\n      \\n      const vector<int> &group = groups[count];\\n      auto lb = lower_bound(group.begin(), group.end(), diff_sum);\\n      if (lb != group.end()) {\\n        ret = min(ret, *lb - diff_sum);\\n      }\\n      if (lb != group.begin()) {\\n        ret = min(ret, diff_sum - *prev(lb));\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * divide the vector `nums` into two equal-length parts, `left_part` and `right_part`,\\n * each of which has the length of `n`.\\n * let 0 <= `i` < `n`, and `j` = `n` - `i`\\n * 1. choose `i` elements from left_part, and `j` elements from right_part into the `group_1`\\n * 2. choose `j` elements from left_part, and `i` elements from right_part into the `group_2`\\n * 3. the target is to find the minimum value of all abs(sum(group_1) - sum(group_2))\\n *    where `sum(group)` stands for the sum of all elements in the group `group`\\n * 4. let `sum_left_part_i` stand for the sum of `i` elements in the left_part\\n *        `sum_left_part_j` stand for the sum of `j` elements in the left_part\\n *        `sum_right_part_i` stand for the sum of `i` elements in the right_part\\n *        `sum_right_part_j` stand for the sum of `j` elements in the right_part\\n * 5. sum(group_1) = sum_left_part_i + sum_right_part_j\\n *    sum(group_2) = sum_right_part_i + sum_left_part_j\\n *    sum(group_1) - sum(group_2) = (sum_left_part_i + sum_right_part_j) - (sum_right_part_i + sum_left_part_j)\\n *                                = (sum_left_part_i - sum_left_part_j) - (sum_right_part_i - sum_right_part_j)\\n *\\n * the algorithm is as following\\n * 1. pre-calculate all (sum_left_part_i - sum_left_part_j),\\n *    group them by `i`,\\n *    and sort every group, or use `std::set` to make every group sorted\\n * 2. iterate every (sum_right_part_i - sum_right_part_j),\\n *    and find the closest corresponding (sum_left_part_i - sum_left_part_j)\\n *\\n * Time Complexity: O(n * (2 ^ n))\\n * Space Complexity: O(2 ^ n)\\n */\\nclass Solution {\\n public:\\n  int minimumDifference(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size()) / 2;\\n    vector<vector<int>> groups1 = generate_groups(nums, 0, n);\\n    vector<vector<int>> groups2 = generate_groups(nums, n, n);\\n    int ret = numeric_limits<int>::max();\\n    for (int i = 0; i < n && ret != 0; ++i) {\\n      const vector<int> &group1 = groups1[i];\\n      const vector<int> &group2 = groups2[i];\\n      for (int i1 = 0, i2 = 0; i1 < group1.size() && i2 < group2.size(); ) {\\n        if (group1[i1] == group2[i2]) {\\n          ret = 0;\\n          break;\\n        }\\n        ret = min(ret, abs(group1[i1] - group2[i2]));\\n        if (group1[i1] < group2[i2]) {\\n          ++i1;\\n        } else {\\n          ++i2;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  vector<vector<int>> generate_groups(const vector<int> &nums, const int start, const int n) {\\n    const int layouts = 1 << n;\\n    vector<vector<int>> ret(n);\\n    for (int layout = 0; layout < layouts - 1; ++layout) {\\n      int count = 0;\\n      int diff_sum = 0;\\n      for (int offset = 0; offset < n; ++offset) {\\n        if ((layout & (1 << offset)) == 0) {\\n          diff_sum -= nums[start + offset];\\n        } else {\\n          ++count;\\n          diff_sum += nums[start + offset];\\n        }\\n      }\\n      ret[count].emplace_back(diff_sum);\\n    }\\n    \\n    for (vector<int> &group : ret) {\\n      sort(group.begin(), group.end());\\n      group.erase(unique(group.begin(), group.end()), group.end());\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * divide the vector `nums` into two equal-length parts, `left_part` and `right_part`,\\n * each of which has the length of `n`.\\n * let 0 <= `i` < `n`, and `j` = `n` - `i`\\n * 1. choose `i` elements from left_part, and `j` elements from right_part into the `group_1`\\n * 2. choose `j` elements from left_part, and `i` elements from right_part into the `group_2`\\n * 3. the target is to find the minimum value of all abs(sum(group_1) - sum(group_2))\\n *    where `sum(group)` stands for the sum of all elements in the group `group`\\n * 4. let `sum_left_part_i` stand for the sum of `i` elements in the left_part\\n *        `sum_left_part_j` stand for the sum of `j` elements in the left_part\\n *        `sum_right_part_i` stand for the sum of `i` elements in the right_part\\n *        `sum_right_part_j` stand for the sum of `j` elements in the right_part\\n * 5. sum(group_1) = sum_left_part_i + sum_right_part_j\\n *    sum(group_2) = sum_right_part_i + sum_left_part_j\\n *    sum(group_1) - sum(group_2) = (sum_left_part_i + sum_right_part_j) - (sum_right_part_i + sum_left_part_j)\\n *                                = (sum_left_part_i - sum_left_part_j) - (sum_right_part_i - sum_right_part_j)\\n *\\n * the algorithm is as following\\n * 1. pre-calculate all (sum_left_part_i - sum_left_part_j),\\n *    group them by `i`,\\n *    and sort every group, or use `std::set` to make every group sorted\\n * 2. iterate every (sum_right_part_i - sum_right_part_j),\\n *    and find the closest corresponding (sum_left_part_i - sum_left_part_j)\\n *\\n * Time Complexity: O(n * (2 ^ n))\\n * Space Complexity: O(2 ^ n)\\n */\\nclass Solution {\\n public:\\n  int minimumDifference(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size()) / 2;\\n    const int layouts = 1 << n;\\n    vector<int> groups[n];\\n    for (int layout = 0; layout < layouts - 1; ++layout) {\\n      int count = 0;\\n      int diff_sum = 0;\\n      for (int offset = 0; offset < n; ++offset) {\\n        if ((layout & (1 << offset)) == 0) {\\n          diff_sum -= nums[offset];\\n        } else {\\n          ++count;\\n          diff_sum += nums[offset];\\n        }\\n      }\\n      groups[count].emplace_back(diff_sum);\\n    }\\n    \\n    for (vector<int> &group : groups) {\\n      sort(group.begin(), group.end());\\n      group.erase(unique(group.begin(), group.end()), group.end());\\n    }\\n    \\n    int ret = numeric_limits<int>::max();\\n    for (int layout = 0; layout < layouts - 1 && ret != 0; ++layout) {\\n      int count = 0;\\n      int diff_sum = 0;\\n      for (int offset = 0; offset < n; ++offset) {\\n        if ((layout & (1 << offset)) == 0) {\\n          diff_sum -= nums[n + offset];\\n        } else {\\n          ++count;\\n          diff_sum += nums[n + offset];\\n        }\\n      }\\n      \\n      const vector<int> &group = groups[count];\\n      auto lb = lower_bound(group.begin(), group.end(), diff_sum);\\n      if (lb != group.end()) {\\n        ret = min(ret, *lb - diff_sum);\\n      }\\n      if (lb != group.begin()) {\\n        ret = min(ret, diff_sum - *prev(lb));\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486341,
                "title": "meet-in-middle-bitmasking-binary-search-easy-c-logic",
                "content": "```\\nclass Solution {\\npublic:\\n     int minimumDifference(vector<int>& v) {\\n  //as we have neg weightswe have to generate all possible subsets\\n          //we have to use bitmasking butt n=30 ans 2^30 > 10^9 not possible\\n         //use meeet in middle :\\n         // divide the arr into 2 parts take sum ele from left and some from right\\n         //try to get this sum as close to totsum/2 \\n         int n=v.size();\\n         n=n/2;         \\n         //store sum of all subsets in left and right part of arr \\n         vector<vector<int>>left(n+1);  \\n         vector<vector<int>>right(n+1);\\n         \\n         //create bitmasks store subsets in left arr\\n         for(int i=0; i<(1<<n) ; i++){ \\n             int mask=i;  //1010 -> choose 3 , 7 in subarr\\n             //each mask from 1 to 2^15 represent diff way of chooseig 15 elements\\n             int s=0;\\n             int ind=0;\\n             int set=0;\\n             //iterate over mask\\n             while(mask>0){                 \\n                 if(mask&1){  //bit is set \\n                     s+= v[ind];  //addin sum\\n                     set++;\\n                 }\\n                 mask = mask>>1 ;\\n                 ind++;\\n             }\\n             left[set].push_back(s);  //no. of elemts - their sum pair\\n         }\\n         \\n          //create bitmasks store subsets in right arr\\n         for(int i=0; i< (1<<n) ; i++){ \\n             int mask=i;  //1010 -> choose 3 , 7 in subarr\\n             //each mask from 1 to 2^15 represent diff way of chooseig 15 elements\\n             int s=0;\\n             int ind=0;\\n             int set=0;\\n             //iterate over mask\\n             while(mask>0){                 \\n                 if(mask&1){  //bit is set \\n                     s+= v[ind+n];  //addin sum RIGHT SIDE ind+N/2\\n                     set++;\\n                 }\\n                 mask = mask>>1 ;\\n                 ind++;                \\n             }\\n              right[set].push_back(s);  //no. of elemts - their sum pair\\n         }\\n         //  tot=10 we need to find a subarr of size=5  ex:(3 fromleft + 2 from right)\\n         //iterate over each sum from 0 to n/2 in left half \\n         // find coresposing pair in right such that no.of ele in left+right= size\\n         int sum=accumulate(v.begin(),v.end(),0);\\n         int ans=INT_MAX;\\n         \\n         for(int i=0;i<=n;i++){\\n             int size=i;\\n             //other side elemets with (n/2-size) length\\n             vector<int>v1= left[size];\\n             vector<int>v2 = right[n-size];\\n             \\n             sort(v2.begin(),v2.end());\\n             //now the tot ele = n/2\\n             for(auto a : v1){\\n                 \\n                 //try to find b in right that makes a+b nearest to totsum/2;\\n                 int b= (sum/2) - a;  //find this in right side\\n                 \\n                 int k= lower_bound(v2.begin(), v2.end(),b)-v2.begin();\\n                 if(k<v2.size()){\\n                     b=v2[k];    //most optimal b\\n                     ans = min(ans, abs(sum - 2*(a+b)));\\n                 }\\n                 \\n             }\\n         }\\n         \\n         return ans;\\n          \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int minimumDifference(vector<int>& v) {\\n  //as we have neg weightswe have to generate all possible subsets\\n          //we have to use bitmasking butt n=30 ans 2^30 > 10^9 not possible\\n         //use meeet in middle :\\n         // divide the arr into 2 parts take sum ele from left and some from right\\n         //try to get this sum as close to totsum/2 \\n         int n=v.size();\\n         n=n/2;         \\n         //store sum of all subsets in left and right part of arr \\n         vector<vector<int>>left(n+1);  \\n         vector<vector<int>>right(n+1);\\n         \\n         //create bitmasks store subsets in left arr\\n         for(int i=0; i<(1<<n) ; i++){ \\n             int mask=i;  //1010 -> choose 3 , 7 in subarr\\n             //each mask from 1 to 2^15 represent diff way of chooseig 15 elements\\n             int s=0;\\n             int ind=0;\\n             int set=0;\\n             //iterate over mask\\n             while(mask>0){                 \\n                 if(mask&1){  //bit is set \\n                     s+= v[ind];  //addin sum\\n                     set++;\\n                 }\\n                 mask = mask>>1 ;\\n                 ind++;\\n             }\\n             left[set].push_back(s);  //no. of elemts - their sum pair\\n         }\\n         \\n          //create bitmasks store subsets in right arr\\n         for(int i=0; i< (1<<n) ; i++){ \\n             int mask=i;  //1010 -> choose 3 , 7 in subarr\\n             //each mask from 1 to 2^15 represent diff way of chooseig 15 elements\\n             int s=0;\\n             int ind=0;\\n             int set=0;\\n             //iterate over mask\\n             while(mask>0){                 \\n                 if(mask&1){  //bit is set \\n                     s+= v[ind+n];  //addin sum RIGHT SIDE ind+N/2\\n                     set++;\\n                 }\\n                 mask = mask>>1 ;\\n                 ind++;                \\n             }\\n              right[set].push_back(s);  //no. of elemts - their sum pair\\n         }\\n         //  tot=10 we need to find a subarr of size=5  ex:(3 fromleft + 2 from right)\\n         //iterate over each sum from 0 to n/2 in left half \\n         // find coresposing pair in right such that no.of ele in left+right= size\\n         int sum=accumulate(v.begin(),v.end(),0);\\n         int ans=INT_MAX;\\n         \\n         for(int i=0;i<=n;i++){\\n             int size=i;\\n             //other side elemets with (n/2-size) length\\n             vector<int>v1= left[size];\\n             vector<int>v2 = right[n-size];\\n             \\n             sort(v2.begin(),v2.end());\\n             //now the tot ele = n/2\\n             for(auto a : v1){\\n                 \\n                 //try to find b in right that makes a+b nearest to totsum/2;\\n                 int b= (sum/2) - a;  //find this in right side\\n                 \\n                 int k= lower_bound(v2.begin(), v2.end(),b)-v2.begin();\\n                 if(k<v2.size()){\\n                     b=v2[k];    //most optimal b\\n                     ans = min(ans, abs(sum - 2*(a+b)));\\n                 }\\n                 \\n             }\\n         }\\n         \\n         return ans;\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430897,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nclass Solution {\\n    vector<vector<LL>> helper(vector<int>&nums){\\n        int n = nums.size() ;\\n        vector<vector<LL>>ret(n+1) ;\\n        for(int state = 0; state < (1 << n); state++ ){\\n            int i = __builtin_popcount(state) ;\\n            LL sum = 0 ;\\n            for(int k = 0; k < n; k++){\\n                if((state >> k)&1)\\n                    sum += (LL)nums[k] ;\\n            }\\n            ret[i].push_back(sum) ;\\n        }\\n        for(int i = 0; i < n; i++){\\n            sort(ret[i].begin(), ret[i].end()) ;\\n        }\\n        return ret ;\\n    }\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/2 ;\\n        vector<int>nums1(n) ;\\n        vector<int>nums2(n) ;\\n        int ret = INT_MAX ;\\n        LL sum = accumulate(nums.begin(), nums.end(), 0LL) ;\\n        \\n        for(int i = 0; i < n; i++)\\n            nums1[i] = nums[i] ;\\n        for(int i = n; i < 2*n ;i++)\\n            nums2[i-n] = nums[i] ;\\n\\n        vector<vector<LL>>Map2 = helper(nums2) ;\\n \\n        for(int state = 0; state < (1 << n); state++){\\n            int i =  __builtin_popcount(state) ;\\n            LL x = 0 ;\\n            for(int k = 0; k < n; k++){\\n                if((state >> k)&1)\\n                    x += (LL)nums1[k] ;\\n            }\\n            int j = n - i ;\\n \\n            auto iter = lower_bound( Map2[j].begin(), Map2[j].end(), sum/2-x ) ;\\n            if(iter != Map2[j].end())\\n                ret = fmin(ret, abs(*iter*2+2*x-sum));\\n            if(iter != Map2[j].begin()){\\n                iter = prev(iter);\\n                ret = fmin(ret, abs(*iter*2+2*x-sum));\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing LL = long long ;\\nclass Solution {\\n    vector<vector<LL>> helper(vector<int>&nums){\\n        int n = nums.size() ;\\n        vector<vector<LL>>ret(n+1) ;\\n        for(int state = 0; state < (1 << n); state++ ){\\n            int i = __builtin_popcount(state) ;\\n            LL sum = 0 ;\\n            for(int k = 0; k < n; k++){\\n                if((state >> k)&1)\\n                    sum += (LL)nums[k] ;\\n            }\\n            ret[i].push_back(sum) ;\\n        }\\n        for(int i = 0; i < n; i++){\\n            sort(ret[i].begin(), ret[i].end()) ;\\n        }\\n        return ret ;\\n    }\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/2 ;\\n        vector<int>nums1(n) ;\\n        vector<int>nums2(n) ;\\n        int ret = INT_MAX ;\\n        LL sum = accumulate(nums.begin(), nums.end(), 0LL) ;\\n        \\n        for(int i = 0; i < n; i++)\\n            nums1[i] = nums[i] ;\\n        for(int i = n; i < 2*n ;i++)\\n            nums2[i-n] = nums[i] ;\\n\\n        vector<vector<LL>>Map2 = helper(nums2) ;\\n \\n        for(int state = 0; state < (1 << n); state++){\\n            int i =  __builtin_popcount(state) ;\\n            LL x = 0 ;\\n            for(int k = 0; k < n; k++){\\n                if((state >> k)&1)\\n                    x += (LL)nums1[k] ;\\n            }\\n            int j = n - i ;\\n \\n            auto iter = lower_bound( Map2[j].begin(), Map2[j].end(), sum/2-x ) ;\\n            if(iter != Map2[j].end())\\n                ret = fmin(ret, abs(*iter*2+2*x-sum));\\n            if(iter != Map2[j].begin()){\\n                iter = prev(iter);\\n                ret = fmin(ret, abs(*iter*2+2*x-sum));\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428426,
                "title": "java-solution-negative-case-not-handled",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n\\n        int range = 0;\\n        int n = nums.length;\\n        for(int i:nums){\\n            range+=i;\\n        }\\n\\n        if(range < 0){\\n            range = -range;\\n        }\\n\\n        List<Integer> ans = helper(nums,range,n);\\n        int final_ans = minDifference(ans,nums,range);\\n        return final_ans;\\n\\n    }\\n\\n    public List<Integer> helper(int[] nums, int range, int n) {\\n        boolean[][] dp = new boolean[n + 1][range + 1];\\n\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = true;\\n        }\\n        for (int i = 1; i <= range; i++) {\\n            dp[0][i] = false;\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= range; j++) {\\n                if (nums[i - 1] <= j) {\\n                    dp[i][j] = dp[i - 1][j - nums[i - 1]] || dp[i - 1][j];\\n                } else {\\n                    dp[i][j] = dp[i - 1][j];\\n                }\\n            }\\n        }\\n\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 0; i <= range / 2; i++) {\\n            if (dp[n][i]) {\\n                list.add(i);\\n            }\\n        }\\n\\n        return list;\\n    }\\n\\n    public int minDifference(List<Integer> list, int[]nums,int range){\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<list.size();i++){\\n            min = Math.min(min,range -(2*list.get(i)));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n\\n        int range = 0;\\n        int n = nums.length;\\n        for(int i:nums){\\n            range+=i;\\n        }\\n\\n        if(range < 0){\\n            range = -range;\\n        }\\n\\n        List<Integer> ans = helper(nums,range,n);\\n        int final_ans = minDifference(ans,nums,range);\\n        return final_ans;\\n\\n    }\\n\\n    public List<Integer> helper(int[] nums, int range, int n) {\\n        boolean[][] dp = new boolean[n + 1][range + 1];\\n\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = true;\\n        }\\n        for (int i = 1; i <= range; i++) {\\n            dp[0][i] = false;\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= range; j++) {\\n                if (nums[i - 1] <= j) {\\n                    dp[i][j] = dp[i - 1][j - nums[i - 1]] || dp[i - 1][j];\\n                } else {\\n                    dp[i][j] = dp[i - 1][j];\\n                }\\n            }\\n        }\\n\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 0; i <= range / 2; i++) {\\n            if (dp[n][i]) {\\n                list.add(i);\\n            }\\n        }\\n\\n        return list;\\n    }\\n\\n    public int minDifference(List<Integer> list, int[]nums,int range){\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<list.size();i++){\\n            min = Math.min(min,range -(2*list.get(i)));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387739,
                "title": "time-o-n-2n-2-o-n-2n-2-space-o-2n-2-o-2n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def minimumDifference(self, nums: List[int]) -> int:\\n    n = len(nums) // 2\\n    summ = sum(nums)\\n    goal = summ // 2\\n    lNums = nums[:n]\\n    rNums = nums[n:]\\n    ans = abs(sum(lNums) - sum(rNums))\\n    lSums = [[] for _ in range(n + 1)]\\n    rSums = [[] for _ in range(n + 1)]\\n\\n    def dfs(A: List[int], i: int, count: int, path: int, sums: List[List[int]]):\\n      if i == len(A):\\n        sums[count].append(path)\\n        return\\n      dfs(A, i + 1, count + 1, path + A[i], sums)\\n      dfs(A, i + 1, count, path, sums)\\n\\n    dfs(lNums, 0, 0, 0, lSums)\\n    dfs(rNums, 0, 0, 0, rSums)\\n\\n    for lCount in range(n):\\n      l = lSums[lCount]\\n      r = rSums[n - lCount]\\n      r.sort()\\n      for lSum in l:\\n        i = bisect_left(r, goal - lSum)\\n        if i < len(r):\\n          sumPartOne = summ - lSum - r[i]\\n          sumPartTwo = summ - sumPartOne\\n          ans = min(ans, abs(sumPartOne - sumPartTwo))\\n        if i > 0:\\n          sumPartOne = summ - lSum - r[i - 1]\\n          sumPartTwo = summ - sumPartOne\\n          ans = min(ans, abs(sumPartOne - sumPartTwo))\\n\\n    return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def minimumDifference(self, nums: List[int]) -> int:\\n    n = len(nums) // 2\\n    summ = sum(nums)\\n    goal = summ // 2\\n    lNums = nums[:n]\\n    rNums = nums[n:]\\n    ans = abs(sum(lNums) - sum(rNums))\\n    lSums = [[] for _ in range(n + 1)]\\n    rSums = [[] for _ in range(n + 1)]\\n\\n    def dfs(A: List[int], i: int, count: int, path: int, sums: List[List[int]]):\\n      if i == len(A):\\n        sums[count].append(path)\\n        return\\n      dfs(A, i + 1, count + 1, path + A[i], sums)\\n      dfs(A, i + 1, count, path, sums)\\n\\n    dfs(lNums, 0, 0, 0, lSums)\\n    dfs(rNums, 0, 0, 0, rSums)\\n\\n    for lCount in range(n):\\n      l = lSums[lCount]\\n      r = rSums[n - lCount]\\n      r.sort()\\n      for lSum in l:\\n        i = bisect_left(r, goal - lSum)\\n        if i < len(r):\\n          sumPartOne = summ - lSum - r[i]\\n          sumPartTwo = summ - sumPartOne\\n          ans = min(ans, abs(sumPartOne - sumPartTwo))\\n        if i > 0:\\n          sumPartOne = summ - lSum - r[i - 1]\\n          sumPartTwo = summ - sumPartOne\\n          ans = min(ans, abs(sumPartOne - sumPartTwo))\\n\\n    return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386608,
                "title": "beautiful-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing LL = long long;\\nclass Solution {\\npublic:\\n    map<int, vector<LL>> genSum(vector<int> &arr){\\n        map<int, vector<LL>> ret;\\n        for(int bitmask = 0; bitmask < (1 << arr.size()); bitmask++){\\n            int oneBit = __builtin_popcount(bitmask);\\n            LL sum = 0;\\n            for(int i = 0; i < arr.size(); i++){\\n                if((1 << i) & bitmask)sum += arr[i];\\n            }\\n            ret[oneBit].push_back(sum);\\n        }\\n        for(auto &x : ret){\\n            sort(x.second.begin(), x.second.end());\\n        }\\n        return ret;\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        if(nums.empty())return 0;\\n        int N = nums.size();\\n        int n = N/2;\\n        vector<int> a1;\\n        vector<int> a2;\\n        for(int i = 0; i < N; i++){\\n            if(i < n)a1.push_back(nums[i]);\\n            else a2.push_back(nums[i]);\\n        }\\n        LL SUM = accumulate(nums.begin(), nums.end(), 0LL);\\n        map<int, vector<LL>> sum = genSum(a2);\\n        LL res = LLONG_MAX;\\n        for(int bitmask = 0; bitmask < (1 << n); bitmask++){\\n            int oneBit = __builtin_popcount(bitmask);\\n            LL x(0);\\n            for(int i = 0; i < n; i++){\\n                if((1 << i) & bitmask)x += a1[i];\\n            }\\n            int restOneBit = n - oneBit;\\n            auto bsIter = lower_bound(sum[restOneBit].begin(), sum[restOneBit].end(), SUM/2 - x);\\n            if(bsIter != sum[restOneBit].end())res = min(res, abs(SUM - 2* (*bsIter + x)));\\n            if(bsIter != sum[restOneBit].begin())res = min(res, abs(SUM - 2* (*prev(bsIter) + x)));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing LL = long long;\\nclass Solution {\\npublic:\\n    map<int, vector<LL>> genSum(vector<int> &arr){\\n        map<int, vector<LL>> ret;\\n        for(int bitmask = 0; bitmask < (1 << arr.size()); bitmask++){\\n            int oneBit = __builtin_popcount(bitmask);\\n            LL sum = 0;\\n            for(int i = 0; i < arr.size(); i++){\\n                if((1 << i) & bitmask)sum += arr[i];\\n            }\\n            ret[oneBit].push_back(sum);\\n        }\\n        for(auto &x : ret){\\n            sort(x.second.begin(), x.second.end());\\n        }\\n        return ret;\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        if(nums.empty())return 0;\\n        int N = nums.size();\\n        int n = N/2;\\n        vector<int> a1;\\n        vector<int> a2;\\n        for(int i = 0; i < N; i++){\\n            if(i < n)a1.push_back(nums[i]);\\n            else a2.push_back(nums[i]);\\n        }\\n        LL SUM = accumulate(nums.begin(), nums.end(), 0LL);\\n        map<int, vector<LL>> sum = genSum(a2);\\n        LL res = LLONG_MAX;\\n        for(int bitmask = 0; bitmask < (1 << n); bitmask++){\\n            int oneBit = __builtin_popcount(bitmask);\\n            LL x(0);\\n            for(int i = 0; i < n; i++){\\n                if((1 << i) & bitmask)x += a1[i];\\n            }\\n            int restOneBit = n - oneBit;\\n            auto bsIter = lower_bound(sum[restOneBit].begin(), sum[restOneBit].end(), SUM/2 - x);\\n            if(bsIter != sum[restOneBit].end())res = min(res, abs(SUM - 2* (*bsIter + x)));\\n            if(bsIter != sum[restOneBit].begin())res = min(res, abs(SUM - 2* (*prev(bsIter) + x)));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333034,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_difference(nums: Vec<i32>) -> i32 {\\n        fn build_sums(nums: &Vec<i32>, from: usize, to: usize) -> HashMap<i32, Vec<i32>> {\\n            let mut sum_by_count_of_elements = HashMap::new();\\n            let n = to - from + 1;\\n            for i in 0..1 << n {\\n                let mut ones_count = 0;\\n                let mut sum = 0;\\n                for j in 0..n {\\n                    if (i >> j) & 1 == 1 {\\n                        ones_count += 1;\\n                        let idx = from + j;\\n                        sum += nums[idx];\\n                    }\\n                }\\n                sum_by_count_of_elements\\n                    .entry(ones_count)\\n                    .or_insert(vec![])\\n                    .push(sum);\\n            }\\n            sum_by_count_of_elements\\n        }\\n        use std::collections::HashMap;\\n        let half = nums.len() / 2;\\n        let sum = nums.iter().copied().sum::<i32>();\\n\\n        let mut left = build_sums(&nums, 0, half - 1);\\n        // println!(\"{:?}\", left);\\n        let mut right = build_sums(&nums, half, nums.len() - 1);\\n        // println!(\"{:?}\", right);\\n\\n        let mut min_diff = i32::MAX;\\n\\n        for i in 0..=half {\\n            let l = left.get_mut(&(i as i32)).unwrap();\\n            l.sort();\\n            let r = right.get_mut(&(half as i32 - i as i32)).unwrap();\\n            r.sort();\\n\\n            // println!(\\n            //     \"comparing l: {} {:?} r: {} {:?}\",\\n            //     i,\\n            //     l,\\n            //     half as i32 - i as i32,\\n            //     r\\n            // );\\n\\n            let mut lo = 0;\\n            let mut hi = r.len() as i32 - 1;\\n\\n            while lo < l.len() as i32 && hi >= 0 {\\n                let half_sum = (l[lo as usize] + r[hi as usize]);\\n                let remaining = sum - half_sum;\\n                let diff = (remaining - half_sum).abs();\\n                min_diff = min_diff.min(diff);\\n                if half_sum > sum / 2 {\\n                    hi -= 1;\\n                } else {\\n                    lo += 1;\\n                }\\n            }\\n        }\\n\\n        min_diff\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_difference(nums: Vec<i32>) -> i32 {\\n        fn build_sums(nums: &Vec<i32>, from: usize, to: usize) -> HashMap<i32, Vec<i32>> {\\n            let mut sum_by_count_of_elements = HashMap::new();\\n            let n = to - from + 1;\\n            for i in 0..1 << n {\\n                let mut ones_count = 0;\\n                let mut sum = 0;\\n                for j in 0..n {\\n                    if (i >> j) & 1 == 1 {\\n                        ones_count += 1;\\n                        let idx = from + j;\\n                        sum += nums[idx];\\n                    }\\n                }\\n                sum_by_count_of_elements\\n                    .entry(ones_count)\\n                    .or_insert(vec![])\\n                    .push(sum);\\n            }\\n            sum_by_count_of_elements\\n        }\\n        use std::collections::HashMap;\\n        let half = nums.len() / 2;\\n        let sum = nums.iter().copied().sum::<i32>();\\n\\n        let mut left = build_sums(&nums, 0, half - 1);\\n        // println!(\"{:?}\", left);\\n        let mut right = build_sums(&nums, half, nums.len() - 1);\\n        // println!(\"{:?}\", right);\\n\\n        let mut min_diff = i32::MAX;\\n\\n        for i in 0..=half {\\n            let l = left.get_mut(&(i as i32)).unwrap();\\n            l.sort();\\n            let r = right.get_mut(&(half as i32 - i as i32)).unwrap();\\n            r.sort();\\n\\n            // println!(\\n            //     \"comparing l: {} {:?} r: {} {:?}\",\\n            //     i,\\n            //     l,\\n            //     half as i32 - i as i32,\\n            //     r\\n            // );\\n\\n            let mut lo = 0;\\n            let mut hi = r.len() as i32 - 1;\\n\\n            while lo < l.len() as i32 && hi >= 0 {\\n                let half_sum = (l[lo as usize] + r[hi as usize]);\\n                let remaining = sum - half_sum;\\n                let diff = (remaining - half_sum).abs();\\n                min_diff = min_diff.min(diff);\\n                if half_sum > sum / 2 {\\n                    hi -= 1;\\n                } else {\\n                    lo += 1;\\n                }\\n            }\\n        }\\n\\n        min_diff\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3285298,
                "title": "meet-in-the-middle-solution-recursive-c-binary-search",
                "content": "```\\n// meet in the middle \\n// store all the possible in a matrix\\n// for optimization sort the another matrix\\nclass Solution {\\npublic:\\n    vector<vector<int>>v1,v2;\\n    void f(vector<int>&nums,int i,int l,bool a,int cnt = 0,int sum =0){\\n        if(i==l){\\n            if(!a) v1[cnt].push_back(sum);\\n            else v2[cnt].push_back(sum);\\n            return;\\n        }\\n        f(nums,i+1,l,a,cnt,sum);\\n        f(nums,i+1,l,a,cnt+1,sum+nums[i]);\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        v1.resize(n/2+1);\\n        v2.resize(n/2+1);\\n        f(nums,0,n/2,0);\\n        f(nums,n/2,n,1);\\n        int sum = accumulate(nums.begin(),nums.end(),0);\\n        int k = sum/2;\\n        for(auto &v:v2){\\n            sort(v.begin(),v.end());\\n        }\\n        int ans = INT_MIN;\\n        for(int i=0;i<=n/2;i++){\\n            for(int j=0;j<v1[i].size();j++){\\n                int curr = v1[i][j];\\n                int t = lower_bound(v2[n/2-i].begin(),v2[n/2-i].end(),k-curr)-v2[n/2-i].begin();\\n                if(t==v2[n/2-i].size()){\\n                    ans = max(ans,curr+v2[n/2-i][t-1]);\\n                }else{\\n                    if(v2[n/2-i][t]==k-curr)\\n                     ans = max(ans,curr+v2[n/2-i][t]);\\n                    if(t!=0){\\n                        ans = max(ans,curr+v2[n/2-i][t-1]);\\n                    }\\n                }\\n            }\\n        }\\n        return abs(sum - 2*ans); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n// meet in the middle \\n// store all the possible in a matrix\\n// for optimization sort the another matrix\\nclass Solution {\\npublic:\\n    vector<vector<int>>v1,v2;\\n    void f(vector<int>&nums,int i,int l,bool a,int cnt = 0,int sum =0){\\n        if(i==l){\\n            if(!a) v1[cnt].push_back(sum);\\n            else v2[cnt].push_back(sum);\\n            return;\\n        }\\n        f(nums,i+1,l,a,cnt,sum);\\n        f(nums,i+1,l,a,cnt+1,sum+nums[i]);\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        v1.resize(n/2+1);\\n        v2.resize(n/2+1);\\n        f(nums,0,n/2,0);\\n        f(nums,n/2,n,1);\\n        int sum = accumulate(nums.begin(),nums.end(),0);\\n        int k = sum/2;\\n        for(auto &v:v2){\\n            sort(v.begin(),v.end());\\n        }\\n        int ans = INT_MIN;\\n        for(int i=0;i<=n/2;i++){\\n            for(int j=0;j<v1[i].size();j++){\\n                int curr = v1[i][j];\\n                int t = lower_bound(v2[n/2-i].begin(),v2[n/2-i].end(),k-curr)-v2[n/2-i].begin();\\n                if(t==v2[n/2-i].size()){\\n                    ans = max(ans,curr+v2[n/2-i][t-1]);\\n                }else{\\n                    if(v2[n/2-i][t]==k-curr)\\n                     ans = max(ans,curr+v2[n/2-i][t]);\\n                    if(t!=0){\\n                        ans = max(ans,curr+v2[n/2-i][t-1]);\\n                    }\\n                }\\n            }\\n        }\\n        return abs(sum - 2*ans); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283983,
                "title": "bitmasking-binary-search-c",
                "content": "# Intuition\\nDivide the array into 2 parts. Iterate the subsets using bitmasking (ie n is very small (15 ~ $$2^15$$) ~512000 subsets) for which we can calculate the difference separately and combine at the end using binary search. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n \\\\binom{n}{n/2})$$\\n\\n- Space complexity:\\n$$o(2^n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size() / 2; int fsum(0), ssum(0);\\n        ll result(INT_MAX); int limit = 1 << n;\\n\\n        for (int i = 0; i < n; i++) fsum += nums[i], ssum += nums[i + n];\\n        vector<vector<ll>> second(n + 1);\\n\\n        for (int mask = 0; mask < limit; mask++)  {\\n            ll csum(0), setCount(0);\\n            for (int i = 0; i < n; i++) { \\n                if (mask & ( 1 << i)) {\\n                    setCount++;\\n                    csum += nums[2*n - 1 - i];\\n                }\\n            }\\n\\n            second[setCount].push_back(2*csum - ssum);\\n        }\\n\\n        for (int i = 0; i <=n; i++) sort(second[i].begin(), second[i].end());\\n\\n        for (int mask = 0; mask < limit; mask++)  {\\n            ll cfsum(0), setCount(0);\\n            for (int i = 0; i < n; i++) { \\n                if (mask & ( 1 << i)) {\\n                    setCount++;\\n                    cfsum += nums[n-1-i];\\n                }\\n            }\\n\\n            int cdiff = 2*cfsum - fsum;\\n\\n            int l(0), h(second[n - setCount].size() - 1);\\n\\n            while (l < h) {\\n                int mid = l + (h - l)/2; mid++;\\n                if (-1 * cdiff < second[n - setCount][mid]) h = mid - 1;\\n                else l = mid;\\n            }\\n\\n            result = min(result, abs(cdiff + second[n-setCount][l]));\\n            if ((l + 1) < second[n-setCount].size())\\n                result = min(result, abs(cdiff + second[n-setCount][l + 1]));\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size() / 2; int fsum(0), ssum(0);\\n        ll result(INT_MAX); int limit = 1 << n;\\n\\n        for (int i = 0; i < n; i++) fsum += nums[i], ssum += nums[i + n];\\n        vector<vector<ll>> second(n + 1);\\n\\n        for (int mask = 0; mask < limit; mask++)  {\\n            ll csum(0), setCount(0);\\n            for (int i = 0; i < n; i++) { \\n                if (mask & ( 1 << i)) {\\n                    setCount++;\\n                    csum += nums[2*n - 1 - i];\\n                }\\n            }\\n\\n            second[setCount].push_back(2*csum - ssum);\\n        }\\n\\n        for (int i = 0; i <=n; i++) sort(second[i].begin(), second[i].end());\\n\\n        for (int mask = 0; mask < limit; mask++)  {\\n            ll cfsum(0), setCount(0);\\n            for (int i = 0; i < n; i++) { \\n                if (mask & ( 1 << i)) {\\n                    setCount++;\\n                    cfsum += nums[n-1-i];\\n                }\\n            }\\n\\n            int cdiff = 2*cfsum - fsum;\\n\\n            int l(0), h(second[n - setCount].size() - 1);\\n\\n            while (l < h) {\\n                int mid = l + (h - l)/2; mid++;\\n                if (-1 * cdiff < second[n - setCount][mid]) h = mid - 1;\\n                else l = mid;\\n            }\\n\\n            result = min(result, abs(cdiff + second[n-setCount][l]));\\n            if ((l + 1) < second[n-setCount].size())\\n                result = min(result, abs(cdiff + second[n-setCount][l + 1]));\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255945,
                "title": "c-beats-95",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        const int n = nums.size()/2;\\n        auto vv1 = init(vector(nums.begin(), nums.begin()+n));\\n        auto vv2 = init(vector(nums.begin()+n, nums.end()));\\n        const int sum = accumulate(nums.begin(), nums.end(), 0), target = sum/2;\\n        int res = 1e9;\\n        for(int k=0;k<=n;k++){\\n            auto &v1 = vv1[k], &v2 = vv2[n-k];\\n            for(int i=0, j=v2.size()-1; i<v1.size() && j>=0; i++){\\n                while(j >= 0 && v1[i] +v2[j] > target) j--;\\n                if(j+1<v2.size()) res = min(res, abs((v1[i]+v2[j+1])*2-sum));\\n                if(j>=0) res = min(res, abs((v1[i]+v2[j])*2-sum));\\n            }\\n        }\\n        return res;\\n    }\\n\\n    vector<vector<int>> init(vector<int> v){\\n        int n = v.size();\\n        auto res = vector(n+1, vector<int>());\\n        res[0].push_back(0);\\n        for(auto& v:res) v.reserve(1<<n);\\n        dfs(v, 0, 0, 0, res);\\n        for(auto& v:res) sort(begin(v), end(v));\\n        return res;\\n    }\\n\\n    void dfs(const vector<int>& v, int i, int len, int sum, vector<vector<int>>& res){\\n        if(i == v.size()) return;\\n        for(int j=i;j<v.size();j++){\\n            res[len+1].push_back(sum+v[j]);\\n            dfs(v, j+1, len+1, sum+v[j], res);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        const int n = nums.size()/2;\\n        auto vv1 = init(vector(nums.begin(), nums.begin()+n));\\n        auto vv2 = init(vector(nums.begin()+n, nums.end()));\\n        const int sum = accumulate(nums.begin(), nums.end(), 0), target = sum/2;\\n        int res = 1e9;\\n        for(int k=0;k<=n;k++){\\n            auto &v1 = vv1[k], &v2 = vv2[n-k];\\n            for(int i=0, j=v2.size()-1; i<v1.size() && j>=0; i++){\\n                while(j >= 0 && v1[i] +v2[j] > target) j--;\\n                if(j+1<v2.size()) res = min(res, abs((v1[i]+v2[j+1])*2-sum));\\n                if(j>=0) res = min(res, abs((v1[i]+v2[j])*2-sum));\\n            }\\n        }\\n        return res;\\n    }\\n\\n    vector<vector<int>> init(vector<int> v){\\n        int n = v.size();\\n        auto res = vector(n+1, vector<int>());\\n        res[0].push_back(0);\\n        for(auto& v:res) v.reserve(1<<n);\\n        dfs(v, 0, 0, 0, res);\\n        for(auto& v:res) sort(begin(v), end(v));\\n        return res;\\n    }\\n\\n    void dfs(const vector<int>& v, int i, int len, int sum, vector<vector<int>>& res){\\n        if(i == v.size()) return;\\n        for(int j=i;j<v.size();j++){\\n            res[len+1].push_back(sum+v[j]);\\n            dfs(v, j+1, len+1, sum+v[j], res);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250454,
                "title": "java-meet-in-the-middle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMeet in the middle. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDivide the array into two half and compupte the sum of all elements of powerset(remember the result with the number of element in the element of powerset).\\nNow to join the two computed result, you can use d elements from first half and (n / 2 - d) elements from the second half, this is beacuse you have to compute the nearest sum with n / 2 elements.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n/2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2^n/2)\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    // -9 -2 -1 1 2 3 4 8\\n    // [-9 1 2 ] [-2 -1 ]\\n\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        if (n == 2) {\\n            return Math.abs(nums[0] - nums[1]);\\n        }\\n        int total = Arrays.stream(nums).sum();\\n        Map<Integer, List<Integer>> allSubsetSum = getSubsetSum(nums, 0, nums.length / 2);\\n        Map<Integer, List<Integer>> allSubsetSum1 = getSubsetSum(nums, nums.length / 2, nums.length);\\n        //\\n        int ans = Integer.MAX_VALUE;\\n// join the subset sum\\n        for (int d = 0; d <= n / 2; d++) {\\n            List<Integer> first = allSubsetSum.getOrDefault(d, Collections.emptyList());\\n            List<Integer> second = allSubsetSum1.getOrDefault(n / 2 - d, Collections.emptyList());\\n            int i1 = 0, i2 = second.size()  - 1;\\n            while (i1 < first.size() && i2 >= 0) {\\n                int diff = total - 2 * (first.get(i1) + second.get(i2));\\n                ans = Math.min(ans, Math.abs(diff));\\n                if (diff <= 0) {\\n                    i2--;\\n                } else {\\n                    i1++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n// compute the subset sum of each half\\n    private Map<Integer, List<Integer>> getSubsetSum(int[] nums, int from, int length) {\\n        int[] first = Arrays.copyOfRange(nums, from, length);\\n        return getAllSubsetSum(first);\\n    }\\n\\n    public record Count (int sum, int setBit) {}\\n    private Map<Integer, List<Integer>> getAllSubsetSum(int[] nums) {\\n        int mask = 1 << nums.length;\\n        var map = new HashMap<Integer, List<Integer>>();\\n        for (int i = 1; i < mask; i++) {\\n            Count sumSubset = getSumOfSubset(nums, i);\\n            map.computeIfAbsent(sumSubset.setBit(), k -> new ArrayList<>()).add(sumSubset.sum());\\n        }\\n        map.put(0, new ArrayList<>(List.of(0)));\\n        map.forEach((key, val) -> Collections.sort(val));\\n        return map;\\n    }\\n\\n    // mask = 5  (101)\\n    private Count getSumOfSubset(int[] nums, int mask) {\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (((mask >> i) & 1) == 1) {\\n                sum += nums[i];\\n            }\\n        }\\n        return new Count(sum, Integer.bitCount(mask));\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    // -9 -2 -1 1 2 3 4 8\\n    // [-9 1 2 ] [-2 -1 ]\\n\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        if (n == 2) {\\n            return Math.abs(nums[0] - nums[1]);\\n        }\\n        int total = Arrays.stream(nums).sum();\\n        Map<Integer, List<Integer>> allSubsetSum = getSubsetSum(nums, 0, nums.length / 2);\\n        Map<Integer, List<Integer>> allSubsetSum1 = getSubsetSum(nums, nums.length / 2, nums.length);\\n        //\\n        int ans = Integer.MAX_VALUE;\\n// join the subset sum\\n        for (int d = 0; d <= n / 2; d++) {\\n            List<Integer> first = allSubsetSum.getOrDefault(d, Collections.emptyList());\\n            List<Integer> second = allSubsetSum1.getOrDefault(n / 2 - d, Collections.emptyList());\\n            int i1 = 0, i2 = second.size()  - 1;\\n            while (i1 < first.size() && i2 >= 0) {\\n                int diff = total - 2 * (first.get(i1) + second.get(i2));\\n                ans = Math.min(ans, Math.abs(diff));\\n                if (diff <= 0) {\\n                    i2--;\\n                } else {\\n                    i1++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n// compute the subset sum of each half\\n    private Map<Integer, List<Integer>> getSubsetSum(int[] nums, int from, int length) {\\n        int[] first = Arrays.copyOfRange(nums, from, length);\\n        return getAllSubsetSum(first);\\n    }\\n\\n    public record Count (int sum, int setBit) {}\\n    private Map<Integer, List<Integer>> getAllSubsetSum(int[] nums) {\\n        int mask = 1 << nums.length;\\n        var map = new HashMap<Integer, List<Integer>>();\\n        for (int i = 1; i < mask; i++) {\\n            Count sumSubset = getSumOfSubset(nums, i);\\n            map.computeIfAbsent(sumSubset.setBit(), k -> new ArrayList<>()).add(sumSubset.sum());\\n        }\\n        map.put(0, new ArrayList<>(List.of(0)));\\n        map.forEach((key, val) -> Collections.sort(val));\\n        return map;\\n    }\\n\\n    // mask = 5  (101)\\n    private Count getSumOfSubset(int[] nums, int mask) {\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (((mask >> i) & 1) == 1) {\\n                sum += nums[i];\\n            }\\n        }\\n        return new Count(sum, Integer.bitCount(mask));\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184660,
                "title": "c-meet-in-the-middle-great-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size() / 2;\\n        int total = accumulate(nums.begin(), nums.end(), 0);\\n        vector<vector<int>> L(n + 1); // stores sum of different sized subsets in range (0...n - 1)\\n        vector<vector<int>> R(n + 1); // stores sum of different sized subsets in range (n...2n - 1)\\n        for(int mask = 0; mask < (1 << n); mask++) {\\n            int count = 0;\\n            int lSum = 0;\\n            int rSum = 0;\\n            for(int i = 0; i < n; i++) {\\n                if(mask & (1 << i)) {\\n                    count++;\\n                    lSum += nums[i];\\n                    rSum += nums[n + i];\\n                }\\n            }\\n            L[count].push_back(lSum);\\n            R[count].push_back(rSum);\\n        }\\n        cout << \"reached\" <<endl;\\n        for(int sz = 0; sz <= n; sz++) {\\n            sort(L[sz].begin(), L[sz].end());\\n            sort(R[sz].begin(), R[sz].end());\\n        }\\n        // L --> {sz -> a, (n - sz) -> b} totalSum = a + b\\n        // R --> remaining sum = total - (a + b)\\n        // difference = abs((a + b) - (total) + (a + b)) = abs(total - 2a - 2b)\\n        // for each a in L find best value of b in R to minimize difference\\n        int ans = INT_MAX;\\n        for(int sz = 0; sz <= n; sz++) {\\n            for(int a : L[sz]) {\\n                int b = (total - (2 * a)) / 2; // sum to be fetched in R[n - sz]\\n                int rsz = n - sz;\\n                auto it = lower_bound(R[rsz].begin(), R[rsz].end(), b);\\n                if(it != R[rsz].end()) {\\n                    ans = min(ans, abs(total - (2 * a) - (2 * (*it))));\\n                }\\n                if(it != R[rsz].begin()) {\\n                    ans = min(ans, abs(total - (2 * a) - (2 * (*prev(it)))));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size() / 2;\\n        int total = accumulate(nums.begin(), nums.end(), 0);\\n        vector<vector<int>> L(n + 1); // stores sum of different sized subsets in range (0...n - 1)\\n        vector<vector<int>> R(n + 1); // stores sum of different sized subsets in range (n...2n - 1)\\n        for(int mask = 0; mask < (1 << n); mask++) {\\n            int count = 0;\\n            int lSum = 0;\\n            int rSum = 0;\\n            for(int i = 0; i < n; i++) {\\n                if(mask & (1 << i)) {\\n                    count++;\\n                    lSum += nums[i];\\n                    rSum += nums[n + i];\\n                }\\n            }\\n            L[count].push_back(lSum);\\n            R[count].push_back(rSum);\\n        }\\n        cout << \"reached\" <<endl;\\n        for(int sz = 0; sz <= n; sz++) {\\n            sort(L[sz].begin(), L[sz].end());\\n            sort(R[sz].begin(), R[sz].end());\\n        }\\n        // L --> {sz -> a, (n - sz) -> b} totalSum = a + b\\n        // R --> remaining sum = total - (a + b)\\n        // difference = abs((a + b) - (total) + (a + b)) = abs(total - 2a - 2b)\\n        // for each a in L find best value of b in R to minimize difference\\n        int ans = INT_MAX;\\n        for(int sz = 0; sz <= n; sz++) {\\n            for(int a : L[sz]) {\\n                int b = (total - (2 * a)) / 2; // sum to be fetched in R[n - sz]\\n                int rsz = n - sz;\\n                auto it = lower_bound(R[rsz].begin(), R[rsz].end(), b);\\n                if(it != R[rsz].end()) {\\n                    ans = min(ans, abs(total - (2 * a) - (2 * (*it))));\\n                }\\n                if(it != R[rsz].begin()) {\\n                    ans = min(ans, abs(total - (2 * a) - (2 * (*prev(it)))));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3180458,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int firstGreaterEqual(List<Integer> list, int target){\\n        int left = 0;\\n        int right = list.size();\\n\\n        while (left < right){\\n            int middle = (left + right) / 2;\\n\\n            if (list.get(middle) >= target){\\n                right = middle;\\n            } else {\\n                left = middle + 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n    public int minimumDifference(int[] nums) {\\n        int sum = Arrays.stream(nums).sum();\\n        int n = nums.length / 2;\\n        int answer = Integer.MAX_VALUE;\\n\\n        Map<Integer, List<Integer>> map1 = new HashMap();\\n        Map<Integer, List<Integer>> map2 = new HashMap();\\n\\n        for (int bitmask = 0; bitmask < (1 << n); bitmask++){\\n            int current_left_sum = 0;\\n            int current_right_sum = 0;\\n            int setbits = 0;\\n            for (int i = 0; i < n; i++){\\n                if ((bitmask & (1 << i)) != 0){\\n                    current_left_sum += nums[i];\\n                    current_right_sum += nums[i + n];\\n                    setbits += 1;\\n                }\\n            }\\n\\n            if (!map1.containsKey(setbits)){\\n                map1.put(setbits, new ArrayList());\\n            }\\n\\n            if (!map2.containsKey(setbits)){\\n                map2.put(setbits, new ArrayList());\\n            }\\n\\n            map1.get(setbits).add(current_left_sum);\\n            map2.get(setbits).add(current_right_sum);\\n        }\\n\\n        for (int i = 0; i <= n; i++){\\n            if (map2.containsKey(i)){\\n                Collections.sort(map2.get(i));\\n            }\\n        }\\n\\n        for (int i = 0; i <= n; i++){\\n            List<Integer> left = map1.get(i);\\n            List<Integer> right = map2.get(n - i);\\n\\n            for (int left_sum : left) {\\n                int index = firstGreaterEqual(right, sum/2 - left_sum);\\n\\n                if (index < right.size()){\\n                    int sum_part_one = left_sum + right.get(index);\\n                    answer = Math.min(answer, Math.abs(sum - 2 * sum_part_one));\\n                }\\n            }   \\n\\n        }\\n        return answer;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int firstGreaterEqual(List<Integer> list, int target){\\n        int left = 0;\\n        int right = list.size();\\n\\n        while (left < right){\\n            int middle = (left + right) / 2;\\n\\n            if (list.get(middle) >= target){\\n                right = middle;\\n            } else {\\n                left = middle + 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n    public int minimumDifference(int[] nums) {\\n        int sum = Arrays.stream(nums).sum();\\n        int n = nums.length / 2;\\n        int answer = Integer.MAX_VALUE;\\n\\n        Map<Integer, List<Integer>> map1 = new HashMap();\\n        Map<Integer, List<Integer>> map2 = new HashMap();\\n\\n        for (int bitmask = 0; bitmask < (1 << n); bitmask++){\\n            int current_left_sum = 0;\\n            int current_right_sum = 0;\\n            int setbits = 0;\\n            for (int i = 0; i < n; i++){\\n                if ((bitmask & (1 << i)) != 0){\\n                    current_left_sum += nums[i];\\n                    current_right_sum += nums[i + n];\\n                    setbits += 1;\\n                }\\n            }\\n\\n            if (!map1.containsKey(setbits)){\\n                map1.put(setbits, new ArrayList());\\n            }\\n\\n            if (!map2.containsKey(setbits)){\\n                map2.put(setbits, new ArrayList());\\n            }\\n\\n            map1.get(setbits).add(current_left_sum);\\n            map2.get(setbits).add(current_right_sum);\\n        }\\n\\n        for (int i = 0; i <= n; i++){\\n            if (map2.containsKey(i)){\\n                Collections.sort(map2.get(i));\\n            }\\n        }\\n\\n        for (int i = 0; i <= n; i++){\\n            List<Integer> left = map1.get(i);\\n            List<Integer> right = map2.get(n - i);\\n\\n            for (int left_sum : left) {\\n                int index = firstGreaterEqual(right, sum/2 - left_sum);\\n\\n                if (index < right.size()){\\n                    int sum_part_one = left_sum + right.get(index);\\n                    answer = Math.min(answer, Math.abs(sum - 2 * sum_part_one));\\n                }\\n            }   \\n\\n        }\\n        return answer;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179168,
                "title": "using-meet-in-the-middle-by-finding-all-subset-sums-on-half-array",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n\\n    # Meet in the middle approach\\n    def minimumDifference(self, nums: List[int]) -> int:\\n\\n        mid = len(nums) // 2\\n        leftSplit = nums[0 : mid]\\n        rightSplit = nums[mid :]\\n\\n        def buildSums(numsTaken, ind, splitList, storeIn):\\n            \\n            if ind == len(splitList):\\n                # Only keep sums where atleast 1 element was used\\n                if len(numsTaken) > 0:\\n                    # Insert the numbers in sorted order so they can be searched faster later \\n                    bisect.insort_left(storeIn[len(numsTaken)], sum(numsTaken))\\n                return\\n\\n            numsTaken.append(splitList[ind])\\n            buildSums(numsTaken, ind + 1, splitList, storeIn)\\n            # Backtrack and not use this num for sum\\n            numsTaken.pop()\\n            buildSums(numsTaken, ind + 1, splitList, storeIn)\\n\\n\\n        leftSplit_sums = collections.defaultdict(list)\\n        rightSplit_sums = collections.defaultdict(list)\\n\\n        # Use bactrack to try out all possible sums in list 1 and list 2 \\n        # and store them in a map. The whole list size is 30 max, which will\\n        # give you 2^30 subsets which is a lot. 2^15 subsets max is much more \\n        # managable without giving TLE\\n        buildSums([], 0, leftSplit, leftSplit_sums)\\n        buildSums([], 0, rightSplit, rightSplit_sums)\\n\\n    \\n        total = sum(nums) # The toatal of all elements \\n        # To get minimum difference between 2 lists we need the sum to be \\n        # equal to total / 2, so that\\'s our target\\n        target = total // 2\\n\\n        # If we use the left and right split as it is \\n        min_diff = abs(sum(leftSplit) - sum(rightSplit))\\n\\n        # Take 1 to n-1 elements from left list to build sum\\n        # Since we considered the case of taking 0 or n elements from leftList above \\n        # At 0 from left, we use all from right and the 2 lists get filpped \\n        # At n from left it is the same split we had before\\n        for i in range(1, mid):\\n\\n            leftSums = leftSplit_sums[i]\\n            rightSums = rightSplit_sums[mid-i]\\n\\n            for leftSum in leftSums:\\n                remaining = target - leftSum\\n                # Binary seach the number we need to meet target in right sums list \\n                # Faster than linear seach \\n                ind = bisect.bisect_left(rightSums, remaining)\\n                if ind == len(rightSums):\\n                    ind -= 1\\n                rightSum = rightSums[ind]\\n                n_sum = leftSum + rightSum\\n                compliment_sum = total - n_sum\\n                diff = abs(n_sum - compliment_sum)\\n                min_diff = min(diff, min_diff)\\n\\n        return min_diff\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    # Meet in the middle approach\\n    def minimumDifference(self, nums: List[int]) -> int:\\n\\n        mid = len(nums) // 2\\n        leftSplit = nums[0 : mid]\\n        rightSplit = nums[mid :]\\n\\n        def buildSums(numsTaken, ind, splitList, storeIn):\\n            \\n            if ind == len(splitList):\\n                # Only keep sums where atleast 1 element was used\\n                if len(numsTaken) > 0:\\n                    # Insert the numbers in sorted order so they can be searched faster later \\n                    bisect.insort_left(storeIn[len(numsTaken)], sum(numsTaken))\\n                return\\n\\n            numsTaken.append(splitList[ind])\\n            buildSums(numsTaken, ind + 1, splitList, storeIn)\\n            # Backtrack and not use this num for sum\\n            numsTaken.pop()\\n            buildSums(numsTaken, ind + 1, splitList, storeIn)\\n\\n\\n        leftSplit_sums = collections.defaultdict(list)\\n        rightSplit_sums = collections.defaultdict(list)\\n\\n        # Use bactrack to try out all possible sums in list 1 and list 2 \\n        # and store them in a map. The whole list size is 30 max, which will\\n        # give you 2^30 subsets which is a lot. 2^15 subsets max is much more \\n        # managable without giving TLE\\n        buildSums([], 0, leftSplit, leftSplit_sums)\\n        buildSums([], 0, rightSplit, rightSplit_sums)\\n\\n    \\n        total = sum(nums) # The toatal of all elements \\n        # To get minimum difference between 2 lists we need the sum to be \\n        # equal to total / 2, so that\\'s our target\\n        target = total // 2\\n\\n        # If we use the left and right split as it is \\n        min_diff = abs(sum(leftSplit) - sum(rightSplit))\\n\\n        # Take 1 to n-1 elements from left list to build sum\\n        # Since we considered the case of taking 0 or n elements from leftList above \\n        # At 0 from left, we use all from right and the 2 lists get filpped \\n        # At n from left it is the same split we had before\\n        for i in range(1, mid):\\n\\n            leftSums = leftSplit_sums[i]\\n            rightSums = rightSplit_sums[mid-i]\\n\\n            for leftSum in leftSums:\\n                remaining = target - leftSum\\n                # Binary seach the number we need to meet target in right sums list \\n                # Faster than linear seach \\n                ind = bisect.bisect_left(rightSums, remaining)\\n                if ind == len(rightSums):\\n                    ind -= 1\\n                rightSum = rightSums[ind]\\n                n_sum = leftSum + rightSum\\n                compliment_sum = total - n_sum\\n                diff = abs(n_sum - compliment_sum)\\n                min_diff = min(diff, min_diff)\\n\\n        return min_diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168837,
                "title": "bitmasking-java-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        if(nums.length == 2) return Math.abs(nums[0] - nums[1]);\\n        int total = Arrays.stream(nums).sum();\\n        int n = nums.length / 2;\\n\\n        HashMap<Integer,ArrayList<Integer>> map1 = new HashMap<>();\\n        HashMap<Integer,ArrayList<Integer>> map2 = new HashMap<>();\\n\\n        for(int i = 0 ; i < (1 << n) ; i++){\\n            int bitmask = i;\\n            int pos = 0;\\n            int sumbits = 0;\\n            int sum = 0;\\n\\n            while(pos < nums.length / 2 && bitmask > 0){\\n                 if((bitmask&1) == 1){\\n                     sumbits++;\\n                     sum += nums[pos];\\n                 }\\n                 pos++;\\n                 bitmask = bitmask >> 1;\\n            }\\n\\n            if(!map1.containsKey(sumbits)) map1.put(sumbits,new ArrayList<>());\\n            map1.get(sumbits).add(sum);\\n        }\\n        \\n        for(int i = 0 ; i < (1 << n) ; i++){\\n            int bitmask = i;\\n            int pos = 0;\\n            int sumbits = 0;\\n            int sum = 0;\\n\\n            while(pos < nums.length / 2 && bitmask > 0){\\n                 if((bitmask&1) == 1){\\n                     sumbits++;\\n                     sum += nums[pos + n];\\n                 }\\n                 pos++;\\n                 bitmask = bitmask >> 1;\\n            }\\n\\n            if(!map2.containsKey(sumbits)) map2.put(sumbits,new ArrayList<>());\\n            map2.get(sumbits).add(sum);\\n        }\\n        \\n        for(int i = 0 ; i <= n ; i++){\\n            if(map1.containsKey(i)){\\n                Collections.sort(map1.get(i));\\n            }\\n\\n            if(map2.containsKey(i)){\\n                Collections.sort(map2.get(i));\\n            }\\n        }\\n        \\n        // for(Map.Entry<Integer,ArrayList<Integer>> entry : map1.entrySet()){\\n        //     System.out.println(entry.getKey() + \" : \" + entry.getValue());\\n        // }\\n\\n        // for(Map.Entry<Integer,ArrayList<Integer>> entry : map2.entrySet()){\\n        //     System.out.println(entry.getKey() + \" : \" + entry.getValue());\\n        // }\\n\\n        int res = Integer.MAX_VALUE;\\n\\n        for(int i = 0 ; i <= n ; i++){\\n            int x = 0 , y = map2.get(n - i).size() - 1;\\n            while(x < map1.get(i).size() && y >= 0){\\n                int sum = map1.get(i).get(x) + map2.get(n-i).get(y);\\n                int diff = total - 2*sum;\\n                res = Math.min(res,Math.abs(diff));\\n                if(diff <= 0) y--;\\n                else if(diff >= 0) x++;\\n                else return 0;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        if(nums.length == 2) return Math.abs(nums[0] - nums[1]);\\n        int total = Arrays.stream(nums).sum();\\n        int n = nums.length / 2;\\n\\n        HashMap<Integer,ArrayList<Integer>> map1 = new HashMap<>();\\n        HashMap<Integer,ArrayList<Integer>> map2 = new HashMap<>();\\n\\n        for(int i = 0 ; i < (1 << n) ; i++){\\n            int bitmask = i;\\n            int pos = 0;\\n            int sumbits = 0;\\n            int sum = 0;\\n\\n            while(pos < nums.length / 2 && bitmask > 0){\\n                 if((bitmask&1) == 1){\\n                     sumbits++;\\n                     sum += nums[pos];\\n                 }\\n                 pos++;\\n                 bitmask = bitmask >> 1;\\n            }\\n\\n            if(!map1.containsKey(sumbits)) map1.put(sumbits,new ArrayList<>());\\n            map1.get(sumbits).add(sum);\\n        }\\n        \\n        for(int i = 0 ; i < (1 << n) ; i++){\\n            int bitmask = i;\\n            int pos = 0;\\n            int sumbits = 0;\\n            int sum = 0;\\n\\n            while(pos < nums.length / 2 && bitmask > 0){\\n                 if((bitmask&1) == 1){\\n                     sumbits++;\\n                     sum += nums[pos + n];\\n                 }\\n                 pos++;\\n                 bitmask = bitmask >> 1;\\n            }\\n\\n            if(!map2.containsKey(sumbits)) map2.put(sumbits,new ArrayList<>());\\n            map2.get(sumbits).add(sum);\\n        }\\n        \\n        for(int i = 0 ; i <= n ; i++){\\n            if(map1.containsKey(i)){\\n                Collections.sort(map1.get(i));\\n            }\\n\\n            if(map2.containsKey(i)){\\n                Collections.sort(map2.get(i));\\n            }\\n        }\\n        \\n        // for(Map.Entry<Integer,ArrayList<Integer>> entry : map1.entrySet()){\\n        //     System.out.println(entry.getKey() + \" : \" + entry.getValue());\\n        // }\\n\\n        // for(Map.Entry<Integer,ArrayList<Integer>> entry : map2.entrySet()){\\n        //     System.out.println(entry.getKey() + \" : \" + entry.getValue());\\n        // }\\n\\n        int res = Integer.MAX_VALUE;\\n\\n        for(int i = 0 ; i <= n ; i++){\\n            int x = 0 , y = map2.get(n - i).size() - 1;\\n            while(x < map1.get(i).size() && y >= 0){\\n                int sum = map1.get(i).get(x) + map2.get(n-i).get(y);\\n                int diff = total - 2*sum;\\n                res = Math.min(res,Math.abs(diff));\\n                if(diff <= 0) y--;\\n                else if(diff >= 0) x++;\\n                else return 0;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157259,
                "title": "javascript-meet-in-the-middle",
                "content": "# Intuition\\nMeet in the middle\\n\\n# Approach\\n- Divide the array into two halves and calculate the sum\\n- Find the sum of all possible sub arrays with i elements in the subarray and store it dp. dp[i] will hold all possible sum for subarray of length i.\\n- To find this sum, recurse through the array, to consider/not consider an element in a sub-array of k elements\\n- For the second array, sort the sums for later to conduct binary search\\n- Iterate through the first array\\'s dp for number of elements to be considered from first half.\\n- Consider each possibility of sum for that number of elements from first half in one half.\\n- Calculate the remaining length that we must include from second half and the remaining sum from first half for the other half.\\n- Conduct binary search on second half dp on the remaining length element, where left =0 and right will be length of secondhalf dp of remaining length.\\n- If the sums are equal, return 0\\n- Else calculate the minimum and return at the end.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n * log(2^n))\\n\\n- Space complexity:\\nO(n*2)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumDifference = function(nums) {\\n    const middle = parseInt(nums.length/2);\\n    // divide array into two parts\\n    const firstHalf = nums.slice(0, middle);\\n    const secondHalf = nums.slice(middle);\\n    // calculate the two arrays sum\\n    const firstHalfSum = firstHalf.reduce((a, b) => a+b);\\n    const secondHalfSum = secondHalf.reduce((a, b) => a+b);\\n    // k is the number of elements in that subset\\n    // index is the index of the element in the array; whether we consider that element in that array \\n    const findKSum = (array, set, sum, index, k) => {\\n        // if the set is populated for all k elements return the set with sum\\n        if (k===0) return set.add(sum);\\n        // if index has reached array length, there are no more elements to consider\\n        if (index===array.length) return;\\n        // Array sum when we don\\'t consider this element in k subarray\\n        findKSum(array, set, sum, index+1, k);\\n        // Array sum when we consider this element in k subarray\\n        findKSum(array, set, sum+array[index], index+1, k-1);\\n    }\\n    // dp such that dp[i] holds all possible sum of array of length i\\n    const populateArray = (array, dp, isSecondArray) => {\\n        for(let i=1; i<=array.length; i++) {\\n            // holds all possible sum of i elements; using set so that no duplicate values\\n            let set = new Set();\\n            findKSum(array, set, 0, 0, i);\\n            // converting set to array, since easy to sort\\n            set = [...set.values()];\\n            // sorting values of only second array as we will perform binary search on this array\\n            if(isSecondArray) {\\n                set.sort((a,b) => a-b);\\n            }\\n            dp[i] = (set);\\n        }\\n    }\\n    // dp[i] has the sum of subset of i elements\\n    // dp[0] will be 0 as the sum of 0 elements is 0\\n    const firstDp = [[0]];\\n    const secondDp = [[0]];\\n    populateArray(firstHalf, firstDp, false);\\n    populateArray(secondHalf, secondDp, true);\\n    let min = Infinity;\\n    // iterate through number elements we\\'ll consider from first half to find the second half sum\\n    for (let i = 1; i<firstDp.length; i++) {\\n        // for each possible sum in first half for i elements\\n        for (const num1 of firstDp[i]) {\\n            // considering num1 to be a part of sum of one half; calculating the remaining sum in firstHalf that we have\\n            const remainingNum1 = firstHalfSum-num1;\\n            // remaining length from second to be considered in the sum of one half\\n            const remainingLength = secondHalf.length - i;\\n            // We have to find the minimum difference of considering num1 in one half\\n            // left will be 0; right will be length of secondDp of remaining length\\n            let left = 0;\\n            let right = secondDp[remainingLength].length -1;\\n            while(left <= right) {\\n                let mid = left+parseInt((right-left)/2);\\n                // considering mid element as num2\\n                const num2 = secondDp[remainingLength][mid];\\n                // remaining num will be part of the other array with remainingNum1\\n                const remainingNum2 = secondHalfSum-num2;\\n                const firstSum = num1+num2;\\n                const secondSum = remainingNum1+remainingNum2;\\n                // if they are equal; min difference if 0; we can return\\n                if(firstSum === secondSum) return 0;\\n                // if not; we need to check if this difference is the least and store it in min\\n                min = Math.min(min, Math.abs(firstSum-secondSum));\\n                if(firstSum > secondSum) right = mid-1;\\n                else left = mid+1;\\n            }\\n        }\\n    }\\n    return min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Binary Search",
                    "Dynamic Programming",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumDifference = function(nums) {\\n    const middle = parseInt(nums.length/2);\\n    // divide array into two parts\\n    const firstHalf = nums.slice(0, middle);\\n    const secondHalf = nums.slice(middle);\\n    // calculate the two arrays sum\\n    const firstHalfSum = firstHalf.reduce((a, b) => a+b);\\n    const secondHalfSum = secondHalf.reduce((a, b) => a+b);\\n    // k is the number of elements in that subset\\n    // index is the index of the element in the array; whether we consider that element in that array \\n    const findKSum = (array, set, sum, index, k) => {\\n        // if the set is populated for all k elements return the set with sum\\n        if (k===0) return set.add(sum);\\n        // if index has reached array length, there are no more elements to consider\\n        if (index===array.length) return;\\n        // Array sum when we don\\'t consider this element in k subarray\\n        findKSum(array, set, sum, index+1, k);\\n        // Array sum when we consider this element in k subarray\\n        findKSum(array, set, sum+array[index], index+1, k-1);\\n    }\\n    // dp such that dp[i] holds all possible sum of array of length i\\n    const populateArray = (array, dp, isSecondArray) => {\\n        for(let i=1; i<=array.length; i++) {\\n            // holds all possible sum of i elements; using set so that no duplicate values\\n            let set = new Set();\\n            findKSum(array, set, 0, 0, i);\\n            // converting set to array, since easy to sort\\n            set = [...set.values()];\\n            // sorting values of only second array as we will perform binary search on this array\\n            if(isSecondArray) {\\n                set.sort((a,b) => a-b);\\n            }\\n            dp[i] = (set);\\n        }\\n    }\\n    // dp[i] has the sum of subset of i elements\\n    // dp[0] will be 0 as the sum of 0 elements is 0\\n    const firstDp = [[0]];\\n    const secondDp = [[0]];\\n    populateArray(firstHalf, firstDp, false);\\n    populateArray(secondHalf, secondDp, true);\\n    let min = Infinity;\\n    // iterate through number elements we\\'ll consider from first half to find the second half sum\\n    for (let i = 1; i<firstDp.length; i++) {\\n        // for each possible sum in first half for i elements\\n        for (const num1 of firstDp[i]) {\\n            // considering num1 to be a part of sum of one half; calculating the remaining sum in firstHalf that we have\\n            const remainingNum1 = firstHalfSum-num1;\\n            // remaining length from second to be considered in the sum of one half\\n            const remainingLength = secondHalf.length - i;\\n            // We have to find the minimum difference of considering num1 in one half\\n            // left will be 0; right will be length of secondDp of remaining length\\n            let left = 0;\\n            let right = secondDp[remainingLength].length -1;\\n            while(left <= right) {\\n                let mid = left+parseInt((right-left)/2);\\n                // considering mid element as num2\\n                const num2 = secondDp[remainingLength][mid];\\n                // remaining num will be part of the other array with remainingNum1\\n                const remainingNum2 = secondHalfSum-num2;\\n                const firstSum = num1+num2;\\n                const secondSum = remainingNum1+remainingNum2;\\n                // if they are equal; min difference if 0; we can return\\n                if(firstSum === secondSum) return 0;\\n                // if not; we need to check if this difference is the least and store it in min\\n                min = Math.min(min, Math.abs(firstSum-secondSum));\\n                if(firstSum > secondSum) right = mid-1;\\n                else left = mid+1;\\n            }\\n        }\\n    }\\n    return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3133017,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        int len = n / 2;\\n        vector<int> num1(nums.begin(), nums.begin() + len);\\n        vector<int> num2(nums.begin() + len, nums.end());\\n        sort(num1.begin(), num1.end());\\n        sort(num2.begin(), num2.end());\\n        vector<vector<int>> sums1(len + 1);\\n        vector<vector<int>> sums2(len + 1);\\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < len; i++)\\n        {\\n            search(num1, sums1, i, 0, 0);\\n            search(num2, sums2, i, 0, 0);\\n            sum1 += num1[i];\\n            sum2 += num2[i];\\n        }\\n        sums1[0].push_back(0);\\n        sums2[0].push_back(0);\\n        sums1.back().push_back(sum1);\\n        sums2.back().push_back(sum2);\\n        double target = (double)(sum1 + sum2) / 2;\\n        for (int i = 1; i < len; i++)\\n        {\\n            if (i * 2 <= len)\\n            {\\n                sort(sums1[i].begin(), sums1[i].end());\\n                sort(sums2[i].begin(), sums2[i].end());\\n            }\\n            else\\n            {\\n                for (int j = sums1[len-i].size() - 1; j >= 0; j--)\\n                    sums1[i].push_back(sum1 - sums1[len-i][j]);\\n                for (int j = sums2[len-i].size() - 1; j >= 0; j--)\\n                    sums2[i].push_back(sum2 - sums2[len-i][j]);\\n            }\\n        }\\n        double ans = 100000000;\\n        for (int k = 0; k <= len; k++)\\n        {\\n            vector<int>& a = sums1[k];\\n            vector<int>& b = sums2[len-k];\\n            int i = 0, j = b.size() - 1;\\n            while (i < a.size())\\n            {\\n                while (j > 0 && b[j-1] + a[i] >= target) j--;\\n                double diff = abs(target - a[i] - b[j]);\\n                if (j > 0) diff = min(diff, abs(target - a[i] - b[j-1]));\\n                ans = min(ans, diff);\\n                if (ans == 0) return 0;\\n                i++;\\n            }\\n        }\\n        \\n        return (int) (ans * 2);\\n    }\\n\\n    void search(vector<int>& nums, vector<vector<int>>& sums, int i, int sum, int take)\\n    {\\n        if ((take + 1) * 2 > nums.size()) return;\\n        sum += nums[i];\\n        take++;\\n        sums[take].push_back(sum);\\n        for (int j = i + 1; j < nums.size(); j++)\\n            search(nums, sums, j, sum, take);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 2;\\n        sum1, sum2 = sum(nums[:n]), sum(nums[n:]);\\n        psum1, psum2 = [{0}], [{0}];\\n        \\n        for ns, ps in zip([nums[:n], nums[n:]], [psum1, psum2]):\\n            for i, x in enumerate(ns):\\n                if len(ps) <= n//2: ps.append({s + x for s in ps[-1]});\\n                \\n                for j in range(len(ps) - 1, 0, -1):\\n                    ps[j] = ps[j].union({s + x for s in ps[j-1]});\\n                    \\n        target = sum1 - sum2;\\n        answer = abs(target);\\n        \\n        for i in range(len(psum1)):\\n            p1, p2 = sorted(list(psum1[i])), sorted(list(psum2[i]));\\n            idx1, idx2 = 0, 0;\\n            len1, len2 = len(p1), len(p2);\\n            \\n            while idx1 < len1 and idx2 < len2:\\n                diff = p1[idx1] - p2[idx2];\\n                offset = 2 * diff - target;\\n                \\n                answer = min(answer, abs(offset));\\n                if offset < 0: idx1 += 1;\\n                else: idx2 += 1;\\n                    \\n        return answer;\\n```\\n\\n```Java []\\npublic class Solution {\\npublic int minimumDifference(int[] nums) {\\n    int L = nums.length;\\n    int[][] diff1 = generate(Arrays.copyOfRange(nums, 0, L / 2));\\n    int[][] diff2 = generate(Arrays.copyOfRange(nums, L / 2, L));\\n\\n    int min = Integer.MAX_VALUE;\\n    for (int len = 0; len <= L / 2; len++) {\\n        int[] left = diff1[len];\\n        int[] right = diff2[len];\\n\\n        int l = 0;\\n        int r = 0;\\n\\n        while(l < left.length && r < left.length) {\\n            //arrays are already sorted so we move one pointer at a time to make the diff closer to 0\\n            int diff = left[l] - right[r];\\n            min = Math.min(min, Math.abs(diff));\\n            if (diff < 0) l++;\\n            else if (diff > 0) r++;\\n            else return 0;\\n        }\\n    }\\n\\n    return min;\\n}\\n\\nprivate static int[][] generate(int[] nums) {\\n        int n = nums.length;\\n        int ansSize = 1 << n;\\n\\n        int total = 0;\\n        for (int num : nums) total += num;\\n\\n        for (int i = 0; i < n; i++) nums[i] <<= 1;\\n        int[] sums = new int[ansSize];\\n        sums[0] -= total;\\n        for (int i = 0, maxTo = 1; i < n; i++, maxTo <<= 1) {\\n            int num = nums[i];\\n            for (int from = 0, to = maxTo; from < maxTo; from++, to++) sums[to] = sums[from] + num;\\n        }\\n\\n        int[][] ans = new int[n + 1][];\\n        int[] pos = new int[n + 1];\\n        for (int i = 0, binomial = 1; i <= n; i++) {\\n            ans[i] = new int[binomial];\\n            binomial = binomial * (n - i) / (i + 1);\\n        }\\n        for (int key = 0; key < ansSize; key++) {\\n            int bits = Integer.bitCount(key);\\n            ans[bits][pos[bits]++] = sums[key];\\n        }\\n        for (int[] arr : ans) Arrays.sort(arr);\\n        return ans;\\n    }\\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        int len = n / 2;\\n        vector<int> num1(nums.begin(), nums.begin() + len);\\n        vector<int> num2(nums.begin() + len, nums.end());\\n        sort(num1.begin(), num1.end());\\n        sort(num2.begin(), num2.end());\\n        vector<vector<int>> sums1(len + 1);\\n        vector<vector<int>> sums2(len + 1);\\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < len; i++)\\n        {\\n            search(num1, sums1, i, 0, 0);\\n            search(num2, sums2, i, 0, 0);\\n            sum1 += num1[i];\\n            sum2 += num2[i];\\n        }\\n        sums1[0].push_back(0);\\n        sums2[0].push_back(0);\\n        sums1.back().push_back(sum1);\\n        sums2.back().push_back(sum2);\\n        double target = (double)(sum1 + sum2) / 2;\\n        for (int i = 1; i < len; i++)\\n        {\\n            if (i * 2 <= len)\\n            {\\n                sort(sums1[i].begin(), sums1[i].end());\\n                sort(sums2[i].begin(), sums2[i].end());\\n            }\\n            else\\n            {\\n                for (int j = sums1[len-i].size() - 1; j >= 0; j--)\\n                    sums1[i].push_back(sum1 - sums1[len-i][j]);\\n                for (int j = sums2[len-i].size() - 1; j >= 0; j--)\\n                    sums2[i].push_back(sum2 - sums2[len-i][j]);\\n            }\\n        }\\n        double ans = 100000000;\\n        for (int k = 0; k <= len; k++)\\n        {\\n            vector<int>& a = sums1[k];\\n            vector<int>& b = sums2[len-k];\\n            int i = 0, j = b.size() - 1;\\n            while (i < a.size())\\n            {\\n                while (j > 0 && b[j-1] + a[i] >= target) j--;\\n                double diff = abs(target - a[i] - b[j]);\\n                if (j > 0) diff = min(diff, abs(target - a[i] - b[j-1]));\\n                ans = min(ans, diff);\\n                if (ans == 0) return 0;\\n                i++;\\n            }\\n        }\\n        \\n        return (int) (ans * 2);\\n    }\\n\\n    void search(vector<int>& nums, vector<vector<int>>& sums, int i, int sum, int take)\\n    {\\n        if ((take + 1) * 2 > nums.size()) return;\\n        sum += nums[i];\\n        take++;\\n        sums[take].push_back(sum);\\n        for (int j = i + 1; j < nums.size(); j++)\\n            search(nums, sums, j, sum, take);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 2;\\n        sum1, sum2 = sum(nums[:n]), sum(nums[n:]);\\n        psum1, psum2 = [{0}], [{0}];\\n        \\n        for ns, ps in zip([nums[:n], nums[n:]], [psum1, psum2]):\\n            for i, x in enumerate(ns):\\n                if len(ps) <= n//2: ps.append({s + x for s in ps[-1]});\\n                \\n                for j in range(len(ps) - 1, 0, -1):\\n                    ps[j] = ps[j].union({s + x for s in ps[j-1]});\\n                    \\n        target = sum1 - sum2;\\n        answer = abs(target);\\n        \\n        for i in range(len(psum1)):\\n            p1, p2 = sorted(list(psum1[i])), sorted(list(psum2[i]));\\n            idx1, idx2 = 0, 0;\\n            len1, len2 = len(p1), len(p2);\\n            \\n            while idx1 < len1 and idx2 < len2:\\n                diff = p1[idx1] - p2[idx2];\\n                offset = 2 * diff - target;\\n                \\n                answer = min(answer, abs(offset));\\n                if offset < 0: idx1 += 1;\\n                else: idx2 += 1;\\n                    \\n        return answer;\\n```\n```Java []\\npublic class Solution {\\npublic int minimumDifference(int[] nums) {\\n    int L = nums.length;\\n    int[][] diff1 = generate(Arrays.copyOfRange(nums, 0, L / 2));\\n    int[][] diff2 = generate(Arrays.copyOfRange(nums, L / 2, L));\\n\\n    int min = Integer.MAX_VALUE;\\n    for (int len = 0; len <= L / 2; len++) {\\n        int[] left = diff1[len];\\n        int[] right = diff2[len];\\n\\n        int l = 0;\\n        int r = 0;\\n\\n        while(l < left.length && r < left.length) {\\n            //arrays are already sorted so we move one pointer at a time to make the diff closer to 0\\n            int diff = left[l] - right[r];\\n            min = Math.min(min, Math.abs(diff));\\n            if (diff < 0) l++;\\n            else if (diff > 0) r++;\\n            else return 0;\\n        }\\n    }\\n\\n    return min;\\n}\\n\\nprivate static int[][] generate(int[] nums) {\\n        int n = nums.length;\\n        int ansSize = 1 << n;\\n\\n        int total = 0;\\n        for (int num : nums) total += num;\\n\\n        for (int i = 0; i < n; i++) nums[i] <<= 1;\\n        int[] sums = new int[ansSize];\\n        sums[0] -= total;\\n        for (int i = 0, maxTo = 1; i < n; i++, maxTo <<= 1) {\\n            int num = nums[i];\\n            for (int from = 0, to = maxTo; from < maxTo; from++, to++) sums[to] = sums[from] + num;\\n        }\\n\\n        int[][] ans = new int[n + 1][];\\n        int[] pos = new int[n + 1];\\n        for (int i = 0, binomial = 1; i <= n; i++) {\\n            ans[i] = new int[binomial];\\n            binomial = binomial * (n - i) / (i + 1);\\n        }\\n        for (int key = 0; key < ansSize; key++) {\\n            int bits = Integer.bitCount(key);\\n            ans[bits][pos[bits]++] = sums[key];\\n        }\\n        for (int[] arr : ans) Arrays.sort(arr);\\n        return ans;\\n    }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090502,
                "title": "c-binary-search-bitmask-meet-in-the-middle",
                "content": "```\\nclass Solution {\\npublic:\\n      vector<vector<int>> fun(vector<int>& arr)\\n    {\\n        vector<vector<int>>adj(16);\\n         int nn = arr.size();\\n        int tl = (1<<nn);\\n        for(int  i = 0;i<tl;i++)\\n        {\\n            int cnt = 0;\\n             int num = i;\\n            int sum = 0;\\n            for(int j = 0;j<nn;j++)\\n            {\\n                if((num>>j)&1)\\n                {\\n                  sum += arr[j];\\n                    cnt++;\\n                }\\n            }\\n            adj[cnt].push_back(sum);\\n        }\\n        for(int  i =0;i<16;i++)\\n        {\\n            sort(adj[i].begin(), adj[i].end());\\n        }\\n        return adj;\\n        \\n    }\\n    int minimumDifference(vector<int>& nums) \\n    {\\n      \\n       int twon = nums.size();\\n       int n  = twon/2;\\n        \\n        vector<int>left;\\n        vector<int>right;\\n        int tot = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            tot  += nums[i];\\n            left.push_back(nums[i]);\\n        }\\n        for(int i =n;i<twon;i++)\\n        {\\n            tot += nums[i];\\n            right.push_back(nums[i]);\\n        }\\n        int each = tot/2;\\n        vector<vector<int>>adj1 = fun(left);\\n        vector<vector<int>>adj2 = fun(right);\\n       \\n        int ans=INT_MAX;\\n        for(int i = 0;i<16;i++)\\n        {\\n            int req_n = (n-i);\\n           \\n          \\n            for(auto it: adj1[i])\\n            {\\n                 if(req_n==0)\\n            {\\n                ans= min(ans, abs(tot-2*it));\\n                continue;\\n            }\\n                \\n                int  req_sum = (each-it);\\n                int lw = lower_bound(adj2[req_n].begin(), adj2[req_n].end(), req_sum)-adj2[req_n].begin();\\n                int sii = adj2[req_n].size();\\n                if(lw<sii)\\n                {\\n                     int sm1 = it+adj2[req_n][lw];\\n                     ans =min(ans, abs(tot-2*sm1));\\n                }\\n               if(lw!=0)\\n               {\\n                   --lw;\\n                     int sm1 = it+adj2[req_n][lw];\\n                      ans =min(ans, abs(tot-2*sm1));\\n               }                 \\n            }\\n            \\n        }\\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n      vector<vector<int>> fun(vector<int>& arr)\\n    {\\n        vector<vector<int>>adj(16);\\n         int nn = arr.size();\\n        int tl = (1<<nn);\\n        for(int  i = 0;i<tl;i++)\\n        {\\n            int cnt = 0;\\n             int num = i;\\n            int sum = 0;\\n            for(int j = 0;j<nn;j++)\\n            {\\n                if((num>>j)&1)\\n                {\\n                  sum += arr[j];\\n                    cnt++;\\n                }\\n            }\\n            adj[cnt].push_back(sum);\\n        }\\n        for(int  i =0;i<16;i++)\\n        {\\n            sort(adj[i].begin(), adj[i].end());\\n        }\\n        return adj;\\n        \\n    }\\n    int minimumDifference(vector<int>& nums) \\n    {\\n      \\n       int twon = nums.size();\\n       int n  = twon/2;\\n        \\n        vector<int>left;\\n        vector<int>right;\\n        int tot = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            tot  += nums[i];\\n            left.push_back(nums[i]);\\n        }\\n        for(int i =n;i<twon;i++)\\n        {\\n            tot += nums[i];\\n            right.push_back(nums[i]);\\n        }\\n        int each = tot/2;\\n        vector<vector<int>>adj1 = fun(left);\\n        vector<vector<int>>adj2 = fun(right);\\n       \\n        int ans=INT_MAX;\\n        for(int i = 0;i<16;i++)\\n        {\\n            int req_n = (n-i);\\n           \\n          \\n            for(auto it: adj1[i])\\n            {\\n                 if(req_n==0)\\n            {\\n                ans= min(ans, abs(tot-2*it));\\n                continue;\\n            }\\n                \\n                int  req_sum = (each-it);\\n                int lw = lower_bound(adj2[req_n].begin(), adj2[req_n].end(), req_sum)-adj2[req_n].begin();\\n                int sii = adj2[req_n].size();\\n                if(lw<sii)\\n                {\\n                     int sm1 = it+adj2[req_n][lw];\\n                     ans =min(ans, abs(tot-2*sm1));\\n                }\\n               if(lw!=0)\\n               {\\n                   --lw;\\n                     int sm1 = it+adj2[req_n][lw];\\n                      ans =min(ans, abs(tot-2*sm1));\\n               }                 \\n            }\\n            \\n        }\\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041633,
                "title": "solution-using-binary-search-and-bitmasking",
                "content": "# Approach\\nThis is not a problem which can be solved using dynamic programming at least with these constraints, for solving this problem , I created two arrays of vectors and then stored the subset sums with the count of elements which they sum up of like if a subset has 4 elements and its sum is 55 then we store as table[4][index]=55 and then sorted the whole table.Then search for required value from one half of the table in other half of the table , when found then take the differences and take the minimum of them.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //for storing the sum of subsets of array, for first part ,second part each of equal length\\n    vector<int>firsthalf[16], secondhalf[16];\\n    //using binary search for finding the subset in other array of subset sums\\n    int upper(vector<int>a[16],int x, int k, int n) {\\n\\t\\tint i = 0, j = n - 1, mid;\\n\\t\\tif (a[x][j] <= k) return a[x][j];\\n\\t\\twhile (i <= j) {\\n\\t\\t\\tmid = i + (j - i) / 2;\\n\\t\\t\\tif (a[x][mid] <= k and a[x][mid + 1] > k)return a[x][mid];\\n\\t\\t\\telse if (a[x][mid] > k)j = mid - 1;\\n\\t\\t\\telse if (a[x][mid < k])i = mid + 1;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n    //for calculating the subset sums of both parts of the array each of length \\'n\\' time complexity of this is O(n*2^n) when considering size of the array is 2*n\\n\\tvoid f(vector<int>&nums, int start, int length,vector<int>answer[16]) {\\n\\t\\tint n = length;\\n\\t\\tfor (int i = 0; i < (1 << n); i++) {\\n\\t\\t\\tint ans = 0,count=0;\\n\\t\\t\\tfor (int j = 0; j < n; j++)if (i & (1 << j))ans += nums[j + start],count++;\\n\\t\\t\\tanswer[count].push_back(ans);\\n\\t\\t}\\n        for(int i=0;i<16;i++)sort(begin(answer[i]),end(answer[i]));\\n\\t}\\n    //main function for calculating the minimum difference\\n\\tint minimumDifference(vector<int>& nums) {\\n        sort(begin(nums),end(nums),greater<int>());\\n\\t\\tint minimum = nums[0], sum = 0,n=nums.size();\\n\\t\\tfor (auto i : nums)minimum = min(minimum, i);\\n        //addition of minimum positive value to make all the elements of the array positive as i didn\\'t like the idea of dealing with negative numbers\\n\\t\\tfor (int i = 0; i < n ; i++)nums[i] += abs(minimum), sum += nums[i];\\n\\t\\t//filling arrays for both halves of the subset sums\\n\\t\\tf(nums, 0, n / 2,firsthalf); //for first half\\n\\t\\tf(nums, n / 2, n / 2,secondhalf);//for second half\\n\\t\\tint minsum=sum;\\n        //calculation of the difference using binary search\\n        for(int i=1;i<n /2;i++){\\n            for(auto j:firsthalf[i]){\\n                int k=sum/2-j;\\n                k=upper(secondhalf,n/2-i,k,secondhalf[n/2-i].size());\\n                if(k>=0)minsum=min(minsum,abs(sum-2*(j+k)));\\n            }\\n        }\\n\\t\\treturn minsum;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //for storing the sum of subsets of array, for first part ,second part each of equal length\\n    vector<int>firsthalf[16], secondhalf[16];\\n    //using binary search for finding the subset in other array of subset sums\\n    int upper(vector<int>a[16],int x, int k, int n) {\\n\\t\\tint i = 0, j = n - 1, mid;\\n\\t\\tif (a[x][j] <= k) return a[x][j];\\n\\t\\twhile (i <= j) {\\n\\t\\t\\tmid = i + (j - i) / 2;\\n\\t\\t\\tif (a[x][mid] <= k and a[x][mid + 1] > k)return a[x][mid];\\n\\t\\t\\telse if (a[x][mid] > k)j = mid - 1;\\n\\t\\t\\telse if (a[x][mid < k])i = mid + 1;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n    //for calculating the subset sums of both parts of the array each of length \\'n\\' time complexity of this is O(n*2^n) when considering size of the array is 2*n\\n\\tvoid f(vector<int>&nums, int start, int length,vector<int>answer[16]) {\\n\\t\\tint n = length;\\n\\t\\tfor (int i = 0; i < (1 << n); i++) {\\n\\t\\t\\tint ans = 0,count=0;\\n\\t\\t\\tfor (int j = 0; j < n; j++)if (i & (1 << j))ans += nums[j + start],count++;\\n\\t\\t\\tanswer[count].push_back(ans);\\n\\t\\t}\\n        for(int i=0;i<16;i++)sort(begin(answer[i]),end(answer[i]));\\n\\t}\\n    //main function for calculating the minimum difference\\n\\tint minimumDifference(vector<int>& nums) {\\n        sort(begin(nums),end(nums),greater<int>());\\n\\t\\tint minimum = nums[0], sum = 0,n=nums.size();\\n\\t\\tfor (auto i : nums)minimum = min(minimum, i);\\n        //addition of minimum positive value to make all the elements of the array positive as i didn\\'t like the idea of dealing with negative numbers\\n\\t\\tfor (int i = 0; i < n ; i++)nums[i] += abs(minimum), sum += nums[i];\\n\\t\\t//filling arrays for both halves of the subset sums\\n\\t\\tf(nums, 0, n / 2,firsthalf); //for first half\\n\\t\\tf(nums, n / 2, n / 2,secondhalf);//for second half\\n\\t\\tint minsum=sum;\\n        //calculation of the difference using binary search\\n        for(int i=1;i<n /2;i++){\\n            for(auto j:firsthalf[i]){\\n                int k=sum/2-j;\\n                k=upper(secondhalf,n/2-i,k,secondhalf[n/2-i].size());\\n                if(k>=0)minsum=min(minsum,abs(sum-2*(j+k)));\\n            }\\n        }\\n\\t\\treturn minsum;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041632,
                "title": "solution-using-binary-search-and-bitmasking",
                "content": "# Approach\\nThis is not a problem which can be solved using dynamic programming at least with these constraints, for solving this problem , I created two arrays of vectors and then stored the subset sums with the count of elements which they sum up of like if a subset has 4 elements and its sum is 55 then we store as table[4][index]=55 and then sorted the whole table.Then search for required value from one half of the table in other half of the table , when found then take the differences and take the minimum of them.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //for storing the sum of subsets of array, for first part ,second part each of equal length\\n    vector<int>firsthalf[16], secondhalf[16];\\n    //using binary search for finding the subset in other array of subset sums\\n    int upper(vector<int>a[16],int x, int k, int n) {\\n\\t\\tint i = 0, j = n - 1, mid;\\n\\t\\tif (a[x][j] <= k) return a[x][j];\\n\\t\\twhile (i <= j) {\\n\\t\\t\\tmid = i + (j - i) / 2;\\n\\t\\t\\tif (a[x][mid] <= k and a[x][mid + 1] > k)return a[x][mid];\\n\\t\\t\\telse if (a[x][mid] > k)j = mid - 1;\\n\\t\\t\\telse if (a[x][mid < k])i = mid + 1;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n    //for calculating the subset sums of both parts of the array each of length \\'n\\' time complexity of this is O(n*2^n) when considering size of the array is 2*n\\n\\tvoid f(vector<int>&nums, int start, int length,vector<int>answer[16]) {\\n\\t\\tint n = length;\\n\\t\\tfor (int i = 0; i < (1 << n); i++) {\\n\\t\\t\\tint ans = 0,count=0;\\n\\t\\t\\tfor (int j = 0; j < n; j++)if (i & (1 << j))ans += nums[j + start],count++;\\n\\t\\t\\tanswer[count].push_back(ans);\\n\\t\\t}\\n        for(int i=0;i<16;i++)sort(begin(answer[i]),end(answer[i]));\\n\\t}\\n    //main function for calculating the minimum difference\\n\\tint minimumDifference(vector<int>& nums) {\\n        sort(begin(nums),end(nums),greater<int>());\\n\\t\\tint minimum = nums[0], sum = 0,n=nums.size();\\n\\t\\tfor (auto i : nums)minimum = min(minimum, i);\\n        //addition of minimum positive value to make all the elements of the array positive as i didn\\'t like the idea of dealing with negative numbers\\n\\t\\tfor (int i = 0; i < n ; i++)nums[i] += abs(minimum), sum += nums[i];\\n\\t\\t//filling arrays for both halves of the subset sums\\n\\t\\tf(nums, 0, n / 2,firsthalf); //for first half\\n\\t\\tf(nums, n / 2, n / 2,secondhalf);//for second half\\n\\t\\tint minsum=sum;\\n        //calculation of the difference using binary search\\n        for(int i=1;i<n /2;i++){\\n            for(auto j:firsthalf[i]){\\n                int k=sum/2-j;\\n                k=upper(secondhalf,n/2-i,k,secondhalf[n/2-i].size());\\n                if(k>=0)minsum=min(minsum,abs(sum-2*(j+k)));\\n            }\\n        }\\n\\t\\treturn minsum;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //for storing the sum of subsets of array, for first part ,second part each of equal length\\n    vector<int>firsthalf[16], secondhalf[16];\\n    //using binary search for finding the subset in other array of subset sums\\n    int upper(vector<int>a[16],int x, int k, int n) {\\n\\t\\tint i = 0, j = n - 1, mid;\\n\\t\\tif (a[x][j] <= k) return a[x][j];\\n\\t\\twhile (i <= j) {\\n\\t\\t\\tmid = i + (j - i) / 2;\\n\\t\\t\\tif (a[x][mid] <= k and a[x][mid + 1] > k)return a[x][mid];\\n\\t\\t\\telse if (a[x][mid] > k)j = mid - 1;\\n\\t\\t\\telse if (a[x][mid < k])i = mid + 1;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n    //for calculating the subset sums of both parts of the array each of length \\'n\\' time complexity of this is O(n*2^n) when considering size of the array is 2*n\\n\\tvoid f(vector<int>&nums, int start, int length,vector<int>answer[16]) {\\n\\t\\tint n = length;\\n\\t\\tfor (int i = 0; i < (1 << n); i++) {\\n\\t\\t\\tint ans = 0,count=0;\\n\\t\\t\\tfor (int j = 0; j < n; j++)if (i & (1 << j))ans += nums[j + start],count++;\\n\\t\\t\\tanswer[count].push_back(ans);\\n\\t\\t}\\n        for(int i=0;i<16;i++)sort(begin(answer[i]),end(answer[i]));\\n\\t}\\n    //main function for calculating the minimum difference\\n\\tint minimumDifference(vector<int>& nums) {\\n        sort(begin(nums),end(nums),greater<int>());\\n\\t\\tint minimum = nums[0], sum = 0,n=nums.size();\\n\\t\\tfor (auto i : nums)minimum = min(minimum, i);\\n        //addition of minimum positive value to make all the elements of the array positive as i didn\\'t like the idea of dealing with negative numbers\\n\\t\\tfor (int i = 0; i < n ; i++)nums[i] += abs(minimum), sum += nums[i];\\n\\t\\t//filling arrays for both halves of the subset sums\\n\\t\\tf(nums, 0, n / 2,firsthalf); //for first half\\n\\t\\tf(nums, n / 2, n / 2,secondhalf);//for second half\\n\\t\\tint minsum=sum;\\n        //calculation of the difference using binary search\\n        for(int i=1;i<n /2;i++){\\n            for(auto j:firsthalf[i]){\\n                int k=sum/2-j;\\n                k=upper(secondhalf,n/2-i,k,secondhalf[n/2-i].size());\\n                if(k>=0)minsum=min(minsum,abs(sum-2*(j+k)));\\n            }\\n        }\\n\\t\\treturn minsum;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026691,
                "title": "go-lang-meet-in-the-middle-implementation",
                "content": "# Intuition\\nGo Lang Meet in the middle implementation\\n\\n# Approach\\nImplement a brute force algorithm that will return the diffs of all possible partitions. Keep track of the length of the first partition, which goes from 0 to N/2\\n\\nDivide the input array in to two by cutting it in the middle. Run the above brute force twice.\\n\\nNow combine the two results to find the min partion. This is a little tricky, as Golang primitives are basic. \\n\\n# Complexity\\n- Time complexity:\\nBrute Force is O(2^N)\\n\\nMerging is O(NLogN)\\n\\nSo combined is O(2^(N/2)) + O((N/2)Log(N/2)) = O(2^N/2)\\n\\n- Space complexity:\\nO(2^(N/2))\\n\\n# Code\\n```\\nfunc partitionRec(i int, requiredCountInA , countInA, sumA, countInB, sumB int, nums []int, diffs map[int]map[int]bool) {\\n    if countInA == requiredCountInA {\\n        for i < len(nums) {\\n            sumB += nums[i]\\n            i++\\n        }\\n\\n        if diffs[requiredCountInA] == nil {\\n            diffs[requiredCountInA] = make(map[int]bool)\\n        }\\n\\n        diffs[requiredCountInA][sumA - sumB] = true\\n        return\\n    }\\n\\n    if countInB == len(nums) - requiredCountInA {\\n        for i < len(nums) {\\n            sumA += nums[i]\\n            i++\\n        }\\n\\n        diffs[requiredCountInA][sumA - sumB] = true\\n        return\\n    }\\n    \\n    partitionRec(i + 1, requiredCountInA, countInA + 1, sumA + nums[i], countInB,     sumB,           nums, diffs)\\n    partitionRec(i + 1, requiredCountInA, countInA,     sumA ,          countInB + 1, sumB + nums[i], nums, diffs)\\n}\\n\\nfunc Abs(i int) int {\\n    if i < 0 {\\n        return -i\\n    }\\n\\n    return i\\n}\\n\\nfunc minimumDifference(nums []int) int {\\n    if len(nums) == 2 {\\n        return Abs(nums[0] - nums[1])\\n    }\\n\\n    resAMap := make(map[int]map[int]bool)\\n    for i := 0; i <= len(nums)/4; i ++ {\\n        partitionRec(0, i, 0, 0, 0, 0, nums[:len(nums)/2], resAMap)\\n    }\\n\\n    resA := make(map[int][]int, len(resAMap))\\n    i := 0\\n    for k, v := range resAMap {\\n        resA[k] = []int{}\\n        for w := range v {\\n            resA[k] = append(resA[k], w)\\n        }\\n        i++\\n    }\\n\\n    resBMap := make(map[int]map[int]bool)\\n    for i := 0; i <= len(nums)/4; i ++ {\\n        partitionRec(0, i, 0, 0, 0, 0, nums[len(nums)/2:], resBMap)\\n    }\\n\\n    resB := make(map[int][]int, len(resBMap))\\n    i = 0\\n    for k, v := range resBMap {\\n        resB[k] = []int{}\\n        for w := range v {\\n            resB[k] = append(resB[k], w)\\n        }\\n        sort.Ints(resB[k])\\n        i++\\n    }\\n\\n    minDiff := math.MaxInt\\n    for lenA1, diffs := range resA {\\n        lenB1 := len(nums)/2 - lenA1\\n\\n        for _, d := range diffs {\\n            if candidates, ok := resB[lenB1]; ok {\\n                idx := sort.SearchInts(candidates, -d)\\n                if idx < len(candidates) && candidates[idx] == -d {\\n                    return 0\\n                } else {\\n                    if idx > 0 {\\n                        r := Abs(d + candidates[idx - 1])\\n                        if r < minDiff {\\n                            minDiff = r\\n                        }\\n                    }\\n\\n                    if idx < len(resB[lenB1]) {\\n                        r := Abs(d + candidates[idx])\\n                        if r < minDiff {\\n                            minDiff = r\\n                        }\\n                    }\\n                }\\n            }\\n\\n            if candidates, ok := resB[lenA1]; ok {\\n                idx := sort.SearchInts(candidates, d)\\n                if idx < len(candidates) && candidates[idx] == d {\\n                    return 0\\n                } else {\\n                    if idx > 0 {\\n                        r := Abs(d - candidates[idx - 1])\\n                        if r < minDiff {\\n                            minDiff = r\\n                        }\\n                    }\\n\\n                    if idx < len(candidates) {\\n                        r := Abs(d - candidates[idx])\\n                        if r < minDiff {\\n                            minDiff = r\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return minDiff\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc partitionRec(i int, requiredCountInA , countInA, sumA, countInB, sumB int, nums []int, diffs map[int]map[int]bool) {\\n    if countInA == requiredCountInA {\\n        for i < len(nums) {\\n            sumB += nums[i]\\n            i++\\n        }\\n\\n        if diffs[requiredCountInA] == nil {\\n            diffs[requiredCountInA] = make(map[int]bool)\\n        }\\n\\n        diffs[requiredCountInA][sumA - sumB] = true\\n        return\\n    }\\n\\n    if countInB == len(nums) - requiredCountInA {\\n        for i < len(nums) {\\n            sumA += nums[i]\\n            i++\\n        }\\n\\n        diffs[requiredCountInA][sumA - sumB] = true\\n        return\\n    }\\n    \\n    partitionRec(i + 1, requiredCountInA, countInA + 1, sumA + nums[i], countInB,     sumB,           nums, diffs)\\n    partitionRec(i + 1, requiredCountInA, countInA,     sumA ,          countInB + 1, sumB + nums[i], nums, diffs)\\n}\\n\\nfunc Abs(i int) int {\\n    if i < 0 {\\n        return -i\\n    }\\n\\n    return i\\n}\\n\\nfunc minimumDifference(nums []int) int {\\n    if len(nums) == 2 {\\n        return Abs(nums[0] - nums[1])\\n    }\\n\\n    resAMap := make(map[int]map[int]bool)\\n    for i := 0; i <= len(nums)/4; i ++ {\\n        partitionRec(0, i, 0, 0, 0, 0, nums[:len(nums)/2], resAMap)\\n    }\\n\\n    resA := make(map[int][]int, len(resAMap))\\n    i := 0\\n    for k, v := range resAMap {\\n        resA[k] = []int{}\\n        for w := range v {\\n            resA[k] = append(resA[k], w)\\n        }\\n        i++\\n    }\\n\\n    resBMap := make(map[int]map[int]bool)\\n    for i := 0; i <= len(nums)/4; i ++ {\\n        partitionRec(0, i, 0, 0, 0, 0, nums[len(nums)/2:], resBMap)\\n    }\\n\\n    resB := make(map[int][]int, len(resBMap))\\n    i = 0\\n    for k, v := range resBMap {\\n        resB[k] = []int{}\\n        for w := range v {\\n            resB[k] = append(resB[k], w)\\n        }\\n        sort.Ints(resB[k])\\n        i++\\n    }\\n\\n    minDiff := math.MaxInt\\n    for lenA1, diffs := range resA {\\n        lenB1 := len(nums)/2 - lenA1\\n\\n        for _, d := range diffs {\\n            if candidates, ok := resB[lenB1]; ok {\\n                idx := sort.SearchInts(candidates, -d)\\n                if idx < len(candidates) && candidates[idx] == -d {\\n                    return 0\\n                } else {\\n                    if idx > 0 {\\n                        r := Abs(d + candidates[idx - 1])\\n                        if r < minDiff {\\n                            minDiff = r\\n                        }\\n                    }\\n\\n                    if idx < len(resB[lenB1]) {\\n                        r := Abs(d + candidates[idx])\\n                        if r < minDiff {\\n                            minDiff = r\\n                        }\\n                    }\\n                }\\n            }\\n\\n            if candidates, ok := resB[lenA1]; ok {\\n                idx := sort.SearchInts(candidates, d)\\n                if idx < len(candidates) && candidates[idx] == d {\\n                    return 0\\n                } else {\\n                    if idx > 0 {\\n                        r := Abs(d - candidates[idx - 1])\\n                        if r < minDiff {\\n                            minDiff = r\\n                        }\\n                    }\\n\\n                    if idx < len(candidates) {\\n                        r := Abs(d - candidates[idx])\\n                        if r < minDiff {\\n                            minDiff = r\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return minDiff\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3026095,
                "title": "c-meet-in-the-middle",
                "content": "# Complexity\\n- Time complexity: $$O(n * 2^n)$$\\n- Space complexity: $$O(2^n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MinimumDifference(int[] nums)\\n    {\\n        int n = nums.Length;\\n\\n        int sum = 0;\\n        foreach (int num in nums)\\n        {\\n            sum += num;\\n        }\\n\\n        var dict1 = Build(nums, 0, (n - 1) / 2);\\n        var dict2 = Build(nums, n / 2, n - 1);\\n\\n        foreach (int key in dict2.Keys)\\n        {\\n            dict2[key].Sort();\\n        }\\n\\n        int min = int.MaxValue;\\n\\n        foreach (int count in dict1.Keys)\\n        {\\n            foreach (int sum1 in dict1[count])\\n            {\\n                if (dict2[n / 2 - count].Count > 0)\\n                {\\n                    int target = (sum - 2 * sum1) / 2;\\n\\n                    int start = 0;\\n                    int end = dict2[n / 2 - count].Count - 1;\\n\\n                    int mid;\\n                    while (start + 1 < end)\\n                    {\\n                        mid = start + (end - start) / 2;\\n\\n                        if (dict2[n / 2 - count][mid] <= target)\\n                        {\\n                            start = mid;\\n                        }\\n                        else\\n                        {\\n                            end = mid;\\n                        }\\n                    }\\n\\n                    int sum2 = dict2[n / 2 - count][start];\\n                    min = Math.Min(min, Math.Abs(2 * (sum1 + sum2) - sum));\\n\\n                    sum2 = dict2[n / 2 - count][end];\\n                    min = Math.Min(min, Math.Abs(2 * (sum1 + sum2) - sum));\\n                }\\n            }\\n        }\\n\\n        return min;\\n    }\\n\\n    private IDictionary<int, List<int>> Build(int[] nums, int l, int r)\\n    {\\n        int n = r - l + 1;\\n\\n        var dict = new Dictionary<int, List<int>>();\\n        for (int i = 0; i <= n; i++)\\n        {\\n            dict.Add(i, new List<int>());\\n        }\\n\\n        int count;\\n        int sum;\\n        for (int mask = 0; mask < 1 << n; mask++)\\n        {\\n            count = 0;\\n            sum = 0;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (((mask >> i) & 1) > 0)\\n                {\\n                    count++;\\n                    sum += nums[l + i];\\n                }\\n            }\\n\\n            dict[count].Add(sum);\\n        }\\n\\n        return dict;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinimumDifference(int[] nums)\\n    {\\n        int n = nums.Length;\\n\\n        int sum = 0;\\n        foreach (int num in nums)\\n        {\\n            sum += num;\\n        }\\n\\n        var dict1 = Build(nums, 0, (n - 1) / 2);\\n        var dict2 = Build(nums, n / 2, n - 1);\\n\\n        foreach (int key in dict2.Keys)\\n        {\\n            dict2[key].Sort();\\n        }\\n\\n        int min = int.MaxValue;\\n\\n        foreach (int count in dict1.Keys)\\n        {\\n            foreach (int sum1 in dict1[count])\\n            {\\n                if (dict2[n / 2 - count].Count > 0)\\n                {\\n                    int target = (sum - 2 * sum1) / 2;\\n\\n                    int start = 0;\\n                    int end = dict2[n / 2 - count].Count - 1;\\n\\n                    int mid;\\n                    while (start + 1 < end)\\n                    {\\n                        mid = start + (end - start) / 2;\\n\\n                        if (dict2[n / 2 - count][mid] <= target)\\n                        {\\n                            start = mid;\\n                        }\\n                        else\\n                        {\\n                            end = mid;\\n                        }\\n                    }\\n\\n                    int sum2 = dict2[n / 2 - count][start];\\n                    min = Math.Min(min, Math.Abs(2 * (sum1 + sum2) - sum));\\n\\n                    sum2 = dict2[n / 2 - count][end];\\n                    min = Math.Min(min, Math.Abs(2 * (sum1 + sum2) - sum));\\n                }\\n            }\\n        }\\n\\n        return min;\\n    }\\n\\n    private IDictionary<int, List<int>> Build(int[] nums, int l, int r)\\n    {\\n        int n = r - l + 1;\\n\\n        var dict = new Dictionary<int, List<int>>();\\n        for (int i = 0; i <= n; i++)\\n        {\\n            dict.Add(i, new List<int>());\\n        }\\n\\n        int count;\\n        int sum;\\n        for (int mask = 0; mask < 1 << n; mask++)\\n        {\\n            count = 0;\\n            sum = 0;\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (((mask >> i) & 1) > 0)\\n                {\\n                    count++;\\n                    sum += nums[l + i];\\n                }\\n            }\\n\\n            dict[count].Add(sum);\\n        }\\n\\n        return dict;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998507,
                "title": "c-meet-in-the-middle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nMeet in the middle. \\n\\n1. Split initial array into two of the same length\\n2. Generate all possible sums of `0, 1, 2, ..., n` items for each of the array\\n3. For each number of items `i`, for each possible sum of `i` items of one array try to find the best sum of `i` items in the other array (binary search) such that `Sum(left) - leftSum(i items) - Sum(right) + rightSum(i items)` is as small as possible\\n\\n# Code\\n```\\npublic class Solution {\\n\\n    private static int[][] PossibleSums(int[] array) {\\n        List<HashSet<int>> data = Enumerable\\n           .Range(0, array.Length + 1)\\n           .Select(_ => new HashSet<int>())\\n           .ToList();\\n\\n        for (int mask = 0; mask < 1 << array.Length; ++mask) {\\n            int sum = 0;\\n            int index = 0;\\n\\n            for (int bits = mask, i = 0; bits > 0; bits /= 2, ++i) {\\n                index += (bits % 2); \\n                sum += (bits % 2) * array[i];\\n            }\\n\\n            data[index].Add(sum);\\n        }\\n\\n        return data\\n            .Select(item => item.OrderBy(x => x).ToArray())\\n            .ToArray();\\n    }\\n\\n    public int MinimumDifference(int[] nums) {\\n        int[] left = nums.Take(nums.Length / 2).ToArray();\\n        int[] right = nums.Skip(nums.Length / 2).ToArray();\\n\\n        int leftSum = left.Sum();\\n        int rightSum = right.Sum();\\n\\n        int result = Math.Abs(leftSum - rightSum);\\n\\n        var leftSums = PossibleSums(left);\\n        var rightSums = PossibleSums(right);\\n\\n        for (int i = 0; i < leftSums.Length; ++i) {\\n            int[] lArr = leftSums[i];\\n            int[] rArr = rightSums[i];\\n\\n            for (int l = 0; l < lArr.Length; ++l) {\\n                int AA = leftSum - lArr[l];\\n                int BB = rightSum + lArr[l];\\n\\n                int toFind = (BB - AA) / 2;\\n\\n                int index = Array.BinarySearch(rArr, toFind);\\n\\n                if (index >= 0) \\n                    result = Math.Min(result, Math.Abs(AA - BB + 2 * rArr[index]));    \\n                else {\\n                    int index1 = Math.Clamp(~index, 0, rArr.Length - 1);\\n                    int index2 = Math.Clamp(~index + 1, 0, rArr.Length - 1);\\n\\n                    result = Math.Min(result, Math.Abs(AA - BB + 2 * rArr[index1]));  \\n                    result = Math.Min(result, Math.Abs(AA - BB + 2 * rArr[index2])); \\n                }  \\n            }\\n        }  \\n\\n        return result;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    private static int[][] PossibleSums(int[] array) {\\n        List<HashSet<int>> data = Enumerable\\n           .Range(0, array.Length + 1)\\n           .Select(_ => new HashSet<int>())\\n           .ToList();\\n\\n        for (int mask = 0; mask < 1 << array.Length; ++mask) {\\n            int sum = 0;\\n            int index = 0;\\n\\n            for (int bits = mask, i = 0; bits > 0; bits /= 2, ++i) {\\n                index += (bits % 2); \\n                sum += (bits % 2) * array[i];\\n            }\\n\\n            data[index].Add(sum);\\n        }\\n\\n        return data\\n            .Select(item => item.OrderBy(x => x).ToArray())\\n            .ToArray();\\n    }\\n\\n    public int MinimumDifference(int[] nums) {\\n        int[] left = nums.Take(nums.Length / 2).ToArray();\\n        int[] right = nums.Skip(nums.Length / 2).ToArray();\\n\\n        int leftSum = left.Sum();\\n        int rightSum = right.Sum();\\n\\n        int result = Math.Abs(leftSum - rightSum);\\n\\n        var leftSums = PossibleSums(left);\\n        var rightSums = PossibleSums(right);\\n\\n        for (int i = 0; i < leftSums.Length; ++i) {\\n            int[] lArr = leftSums[i];\\n            int[] rArr = rightSums[i];\\n\\n            for (int l = 0; l < lArr.Length; ++l) {\\n                int AA = leftSum - lArr[l];\\n                int BB = rightSum + lArr[l];\\n\\n                int toFind = (BB - AA) / 2;\\n\\n                int index = Array.BinarySearch(rArr, toFind);\\n\\n                if (index >= 0) \\n                    result = Math.Min(result, Math.Abs(AA - BB + 2 * rArr[index]));    \\n                else {\\n                    int index1 = Math.Clamp(~index, 0, rArr.Length - 1);\\n                    int index2 = Math.Clamp(~index + 1, 0, rArr.Length - 1);\\n\\n                    result = Math.Min(result, Math.Abs(AA - BB + 2 * rArr[index1]));  \\n                    result = Math.Min(result, Math.Abs(AA - BB + 2 * rArr[index2])); \\n                }  \\n            }\\n        }  \\n\\n        return result;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993700,
                "title": "meet-in-the-middle-solution-in-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length,sum=0;\\n        for(int val:nums){\\n            sum+=val;\\n        }\\n        List<List<Integer>> l1 = new ArrayList<>();\\n        List<TreeSet<Integer>> l2 = new ArrayList<>();\\n        int half = n/2;\\n        for(int i=0;i<(1<<half);i++){\\n            l1.add(new ArrayList<>());\\n            l2.add(new TreeSet<>());\\n        }\\n        for(int i=0;i<(1<<half);i++){\\n            int sum1=0,sum2=0,count=0;\\n            for(int j=0;j<half;j++){\\n                if((i&(1<<j)) > 0){\\n                    count++;\\n                    sum1+=nums[j];\\n                    sum2+=nums[half+j];\\n                }\\n            }\\n            l1.get(count).add(sum1);\\n            l2.get(count).add(sum2);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for(int size1=0;size1<(1<<half);size1++){\\n            for(int x:l1.get(size1)){\\n               int size2 = n/2-size1;\\n               int target = (sum/2 - x);\\n               Integer y1 = l2.get(size2).floor(target);\\n               Integer y2 = l2.get(size2).ceiling(target);\\n               if(y1 !=null){\\n                   int s1 = x+y1.intValue();\\n                   res = Math.min(res,Math.abs(s1-(sum-s1)));\\n               }\\n               if(y2 !=null){\\n                   int s1 = x+y2.intValue();\\n                   res = Math.min(res,Math.abs(s1-(sum-s1)));\\n               }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length,sum=0;\\n        for(int val:nums){\\n            sum+=val;\\n        }\\n        List<List<Integer>> l1 = new ArrayList<>();\\n        List<TreeSet<Integer>> l2 = new ArrayList<>();\\n        int half = n/2;\\n        for(int i=0;i<(1<<half);i++){\\n            l1.add(new ArrayList<>());\\n            l2.add(new TreeSet<>());\\n        }\\n        for(int i=0;i<(1<<half);i++){\\n            int sum1=0,sum2=0,count=0;\\n            for(int j=0;j<half;j++){\\n                if((i&(1<<j)) > 0){\\n                    count++;\\n                    sum1+=nums[j];\\n                    sum2+=nums[half+j];\\n                }\\n            }\\n            l1.get(count).add(sum1);\\n            l2.get(count).add(sum2);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for(int size1=0;size1<(1<<half);size1++){\\n            for(int x:l1.get(size1)){\\n               int size2 = n/2-size1;\\n               int target = (sum/2 - x);\\n               Integer y1 = l2.get(size2).floor(target);\\n               Integer y2 = l2.get(size2).ceiling(target);\\n               if(y1 !=null){\\n                   int s1 = x+y1.intValue();\\n                   res = Math.min(res,Math.abs(s1-(sum-s1)));\\n               }\\n               if(y2 !=null){\\n                   int s1 = x+y2.intValue();\\n                   res = Math.min(res,Math.abs(s1-(sum-s1)));\\n               }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993697,
                "title": "meet-in-the-middle-solution-in-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length,sum=0;\\n        for(int val:nums){\\n            sum+=val;\\n        }\\n        List<List<Integer>> l1 = new ArrayList<>();\\n        List<TreeSet<Integer>> l2 = new ArrayList<>();\\n        int half = n/2;\\n        for(int i=0;i<(1<<half);i++){\\n            l1.add(new ArrayList<>());\\n            l2.add(new TreeSet<>());\\n        }\\n        for(int i=0;i<(1<<half);i++){\\n            int sum1=0,sum2=0,count=0;\\n            for(int j=0;j<half;j++){\\n                if((i&(1<<j)) > 0){\\n                    count++;\\n                    sum1+=nums[j];\\n                    sum2+=nums[half+j];\\n                }\\n            }\\n            l1.get(count).add(sum1);\\n            l2.get(count).add(sum2);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for(int size1=0;size1<(1<<half);size1++){\\n            for(int x:l1.get(size1)){\\n               int size2 = n/2-size1;\\n               int target = (sum/2 - x);\\n               Integer y1 = l2.get(size2).floor(target);\\n               Integer y2 = l2.get(size2).ceiling(target);\\n               if(y1 !=null){\\n                   int s1 = x+y1.intValue();\\n                   res = Math.min(res,Math.abs(s1-(sum-s1)));\\n               }\\n               if(y2 !=null){\\n                   int s1 = x+y2.intValue();\\n                   res = Math.min(res,Math.abs(s1-(sum-s1)));\\n               }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length,sum=0;\\n        for(int val:nums){\\n            sum+=val;\\n        }\\n        List<List<Integer>> l1 = new ArrayList<>();\\n        List<TreeSet<Integer>> l2 = new ArrayList<>();\\n        int half = n/2;\\n        for(int i=0;i<(1<<half);i++){\\n            l1.add(new ArrayList<>());\\n            l2.add(new TreeSet<>());\\n        }\\n        for(int i=0;i<(1<<half);i++){\\n            int sum1=0,sum2=0,count=0;\\n            for(int j=0;j<half;j++){\\n                if((i&(1<<j)) > 0){\\n                    count++;\\n                    sum1+=nums[j];\\n                    sum2+=nums[half+j];\\n                }\\n            }\\n            l1.get(count).add(sum1);\\n            l2.get(count).add(sum2);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for(int size1=0;size1<(1<<half);size1++){\\n            for(int x:l1.get(size1)){\\n               int size2 = n/2-size1;\\n               int target = (sum/2 - x);\\n               Integer y1 = l2.get(size2).floor(target);\\n               Integer y2 = l2.get(size2).ceiling(target);\\n               if(y1 !=null){\\n                   int s1 = x+y1.intValue();\\n                   res = Math.min(res,Math.abs(s1-(sum-s1)));\\n               }\\n               if(y2 !=null){\\n                   int s1 = x+y2.intValue();\\n                   res = Math.min(res,Math.abs(s1-(sum-s1)));\\n               }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979038,
                "title": "java-meet-in-the-middle-very-clear-and-concise",
                "content": "```\\nclass Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        int[]a = new int[n/2],b = new int[n/2];\\n        int totalsum = 0;\\n        for(int i=0;i<n/2;i++) {\\n            a[i] = nums[i];\\n            b[i] = nums[i + n/2];\\n            totalsum += a[i] + b[i];\\n        }\\n        ArrayList<Integer>[] leftSets = genRecursive(a);\\n        ArrayList<Integer>[] rightSets = genRecursive(b);\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int size = 0; size <= n/2; size++) {\\n            for(int leftSum : leftSets[size]) {\\n                int target = totalsum/2 - leftSum;\\n                // search target in right, with size n/2 - size\\n                int floor = search(rightSets[n/2 - size], target);\\n                int currSum = leftSum + floor;\\n                ans = Math.min(ans, Math.abs(totalsum - 2*currSum));\\n            }\\n        }\\n        return ans;        \\n    }\\n    \\n    public int search(ArrayList<Integer> a, int t) {\\n        int l=0,r=a.size()-1,ans=0;\\n        boolean found = false;\\n        while(l<=r) {\\n            int m = (l+r)>>1;\\n            if(a.get(m) <= t) {\\n            \\tfound = true;\\n                ans = a.get(m);\\n                l = m+1;\\n            } else {\\n                r=m-1;\\n            }\\n        }\\n        if(found) return ans;\\n        \\n        \\n        l=0;r=a.size()-1;\\n        while(l<=r) {\\n            int m = (l+r)>>1;\\n            if(a.get(m) >= t) {\\n                ans = a.get(m);\\n                r = m-1;\\n            } else {\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n    }  \\n    \\n    public ArrayList<Integer>[] genRecursive(int[]a) {\\n        ArrayList<Integer>[] ans = new ArrayList[a.length+1];\\n        for(int i=0;i<ans.length;i++)ans[i] = new ArrayList<>();\\n        dfs(0,0,0,a,ans);\\n        for(int i=0;i<ans.length;i++)Collections.sort(ans[i]);\\n        return ans;\\n    }\\n    \\n    public void dfs(int i, int size, int sum, int[]a, ArrayList<Integer>[] ans) {\\n        if(i==a.length) {\\n            ans[size].add(sum);\\n            return;\\n        }\\n        dfs(i+1, size, sum, a, ans);\\n        dfs(i+1, size+1, sum+a[i], a, ans);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        int[]a = new int[n/2],b = new int[n/2];\\n        int totalsum = 0;\\n        for(int i=0;i<n/2;i++) {\\n            a[i] = nums[i];\\n            b[i] = nums[i + n/2];\\n            totalsum += a[i] + b[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2912761,
                "title": "dart-implementation-o-2-n-ln-2-n-o-n-2-n-where-n-2-15",
                "content": "# Intuition\\nI follow the hints and the meet in the middle approach. the rest is simple.\\n\\n# Approach\\nOne tricky thing came up in one of the test cases - is that the total sum/2 might be decimal (non integer). As a result I changed my code to store target sum as double and solution was immediately accepted.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N * 2^N) \\n\\n- Space complexity:\\nO(2^N) to store all sums\\n\\n# Code\\n```\\n\\nclass Solution {\\n  void dfs(List<int> nums, int end, int i, int k, int sum, List<Set<int>> res) {\\n    if (i == end) {\\n      res[k].add(sum);\\n      return;\\n    }\\n    dfs(nums, end, i + 1, k + 1, sum + nums[i], res);\\n    dfs(nums, end, i + 1, k, sum, res);\\n  }\\n\\n  static const double BIG_NUM = 1000000000;\\n\\n  int leftBoundIndex(List<int> sorted, double target) {\\n    int l = 0;\\n    int r = sorted.length;\\n    while (l < r) {\\n      int mid = (l + r) ~/ 2; //floor\\n      if (target > sorted[mid])\\n        l = mid + 1;\\n      else\\n        r = mid;\\n    }\\n    return l;\\n  }\\n\\n  int minimumDifference(List<int> nums) {\\n    int N = nums.length ~/ 2;\\n    double total = nums.reduce((a, b) => a + b) / 2;\\n    final s1 = List<Set<int>>.generate(N + 1, (index) => Set<int>());\\n    final s2 = List<Set<int>>.generate(N + 1, (index) => Set<int>());\\n    //void dfs(List<int> nums, int end, int i, int k, int sum, List<Set<int>> res)\\n    dfs(\\n        nums,\\n        N,\\n        0, //i\\n        0, // k\\n        0, // sum\\n        s1); // res\\n    dfs(\\n        nums,\\n        N * 2,\\n        N, //i\\n        0, //k\\n        0, //sum\\n        s2);\\n    final a2 =\\n        List<List<int>>.generate(N + 1, (index) => s2[index].toList()..sort());\\n    double diff = BIG_NUM;\\n    for (int k = 0; k <= N; k++) {\\n      for (var v1 in s1[k]) {\\n        final l2 = a2[N - k];\\n        int cmpIndex = leftBoundIndex(l2, total - v1);\\n        if (cmpIndex < l2.length)\\n          diff = min(diff, (total - (v1 + l2[cmpIndex])).abs());\\n      }\\n    }\\n    return (diff * 2).toInt();\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\n\\nclass Solution {\\n  void dfs(List<int> nums, int end, int i, int k, int sum, List<Set<int>> res) {\\n    if (i == end) {\\n      res[k].add(sum);\\n      return;\\n    }\\n    dfs(nums, end, i + 1, k + 1, sum + nums[i], res);\\n    dfs(nums, end, i + 1, k, sum, res);\\n  }\\n\\n  static const double BIG_NUM = 1000000000;\\n\\n  int leftBoundIndex(List<int> sorted, double target) {\\n    int l = 0;\\n    int r = sorted.length;\\n    while (l < r) {\\n      int mid = (l + r) ~/ 2; //floor\\n      if (target > sorted[mid])\\n        l = mid + 1;\\n      else\\n        r = mid;\\n    }\\n    return l;\\n  }\\n\\n  int minimumDifference(List<int> nums) {\\n    int N = nums.length ~/ 2;\\n    double total = nums.reduce((a, b) => a + b) / 2;\\n    final s1 = List<Set<int>>.generate(N + 1, (index) => Set<int>());\\n    final s2 = List<Set<int>>.generate(N + 1, (index) => Set<int>());\\n    //void dfs(List<int> nums, int end, int i, int k, int sum, List<Set<int>> res)\\n    dfs(\\n        nums,\\n        N,\\n        0, //i\\n        0, // k\\n        0, // sum\\n        s1); // res\\n    dfs(\\n        nums,\\n        N * 2,\\n        N, //i\\n        0, //k\\n        0, //sum\\n        s2);\\n    final a2 =\\n        List<List<int>>.generate(N + 1, (index) => s2[index].toList()..sort());\\n    double diff = BIG_NUM;\\n    for (int k = 0; k <= N; k++) {\\n      for (var v1 in s1[k]) {\\n        final l2 = a2[N - k];\\n        int cmpIndex = leftBoundIndex(l2, total - v1);\\n        if (cmpIndex < l2.length)\\n          diff = min(diff, (total - (v1 + l2[cmpIndex])).abs());\\n      }\\n    }\\n    return (diff * 2).toInt();\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898003,
                "title": "python-minimum-difference-best-of-luck",
                "content": "\\n\\n# Code\\n```\\nimport bisect\\nimport math\\nimport sys\\n\\nclass Solution(object):\\n    def minimumDifference(self, nums):\\n        n, n2, res = len(nums) // 2, len(nums) // 4, float(\\'inf\\')\\n\\n        def dfs(i, end, k, s, sums):\\n            if i == end or k >= n2:\\n                sums[k].append(s)\\n                return sums\\n            return (dfs(i + 1, end, k, s, sums), dfs(i + 1, end, k + 1, s + nums[i], sums))[0]\\n        sum1, sum2 = sum(nums[:n]), sum(nums[n:])\\n        s1 = dfs(0, n, 0, 0, [[] for _ in range(n2 + 1)])\\n        s2 = dfs(n, n * 2, 0, 0, [[] for _ in range(n2 + 1)])\\n        for k in range(n2 + 1):\\n            s2[k].sort()\\n            for s1k in s1[k]:\\n                comp, diff = (sum1 + sum2) // 2 - \\\\\\n                    (sum1 - s1k), sum1 - sum2 - s1k * 2\\n                j = bisect.bisect_left(s2[k], comp)\\n                if j < len(s2[k]):\\n                    res = min(res, abs(diff + s2[k][j] * 2))\\n                if j > 0:\\n                    res = min(res, abs(diff + s2[k][j - 1] * 2))\\n        return res\\n\\nif __name__ == \"__main__\":\\n\\n    print(Solution().minimumDifference([3, 9, 7, 3]))\\n    print(Solution().minimumDifference([-36, 36]))\\n    print(Solution().minimumDifference([2, -1, 0, 4, -2, -9]))\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport bisect\\nimport math\\nimport sys\\n\\nclass Solution(object):\\n    def minimumDifference(self, nums):\\n        n, n2, res = len(nums) // 2, len(nums) // 4, float(\\'inf\\')\\n\\n        def dfs(i, end, k, s, sums):\\n            if i == end or k >= n2:\\n                sums[k].append(s)\\n                return sums\\n            return (dfs(i + 1, end, k, s, sums), dfs(i + 1, end, k + 1, s + nums[i], sums))[0]\\n        sum1, sum2 = sum(nums[:n]), sum(nums[n:])\\n        s1 = dfs(0, n, 0, 0, [[] for _ in range(n2 + 1)])\\n        s2 = dfs(n, n * 2, 0, 0, [[] for _ in range(n2 + 1)])\\n        for k in range(n2 + 1):\\n            s2[k].sort()\\n            for s1k in s1[k]:\\n                comp, diff = (sum1 + sum2) // 2 - \\\\\\n                    (sum1 - s1k), sum1 - sum2 - s1k * 2\\n                j = bisect.bisect_left(s2[k], comp)\\n                if j < len(s2[k]):\\n                    res = min(res, abs(diff + s2[k][j] * 2))\\n                if j > 0:\\n                    res = min(res, abs(diff + s2[k][j - 1] * 2))\\n        return res\\n\\nif __name__ == \"__main__\":\\n\\n    print(Solution().minimumDifference([3, 9, 7, 3]))\\n    print(Solution().minimumDifference([-36, 36]))\\n    print(Solution().minimumDifference([2, -1, 0, 4, -2, -9]))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893515,
                "title": "easy-to-understand-c-code-using-power-sets",
                "content": "```\\n// Another approach to generate powerSets\\n\\nclass Solution {\\npublic: \\n    using ll = long long int;\\n   \\n    int minimumDifference(vector<int>& nums) {\\n        ll target = accumulate(begin(nums),end(nums),0);\\n        int n = nums.size()/2;\\n        vector<vector<ll>> leftArr(n+1);\\n        vector<vector<ll>> rightArr(n+1);\\n        \\n        int powerSet = (1 << n);\\n        for (int mask=0; mask < powerSet; mask++) {\\n            int numOnes = 0;\\n            ll lsum = 0; ll rsum = 0;\\n            for (int i = 0; i < n; i++) {\\n                if(mask&(1<<i)) {\\n                    lsum += nums[i];\\n                    rsum += nums[i+n];\\n                    numOnes++;\\n                }\\n            }\\n            leftArr[numOnes].push_back(lsum);\\n            rightArr[numOnes].push_back(rsum);\\n        }\\n      \\n        \\n        // sort for easy binary search\\n        for (int i = 0; i < n+1; i++) {\\n            sort(begin(leftArr[i]),end(leftArr[i]));\\n            sort(begin(rightArr[i]),end(rightArr[i]));\\n        }\\n        \\n        ll res = INT_MAX;\\n        ll halfTarget = target/2;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (auto &s1 : leftArr[i]) {\\n                // check nearest sum on right side for given left subarray\\n                auto s2 = lower_bound(begin(rightArr[n-i]),end(rightArr[n-i]),(halfTarget-s1));\\n                if (s2 == rightArr[n-i].end())\\n                    s2--;\\n                \\n                ll lsum = s1 + *s2;\\n                ll rsum = target-lsum;\\n                res = min(res,abs(lsum-rsum));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic: \\n    using ll = long long int;\\n    // compute 2^n sets for the given n/2 array\\n    void populateArr(vector<int> &nums, int start, vector<vector<ll>> &arr) {\\n        int n = nums.size()/2;\\n        int sz = 1;\\n        vector<vector<ll>> prev;\\n        for (int i = start; i < start+n; i++) {\\n            prev = arr;\\n            for (int k = 1; k <= n; k++) {\\n                for (auto &sum : prev[k-1]) {\\n                    arr[k].push_back(sum+nums[i]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int minimumDifference(vector<int>& nums) {\\n        ll target = accumulate(begin(nums),end(nums),0);\\n        int n = nums.size()/2;\\n        vector<vector<ll>> leftArr(n+1);\\n        vector<vector<ll>> rightArr(n+1);\\n        // push 0 sum for null set\\n        leftArr[0].push_back(0);\\n        rightArr[0].push_back(0);\\n        \\n        // take out all n sets from each left and right part of total array\\n        populateArr(nums,0,leftArr);\\n        populateArr(nums,n,rightArr);\\n        \\n        // sort for easy binary search\\n        for (int i = 0; i < n+1; i++) {\\n            sort(begin(leftArr[i]),end(leftArr[i]));\\n            sort(begin(rightArr[i]),end(rightArr[i]));\\n        }\\n        \\n        ll res = INT_MAX;\\n        ll halfTarget = target/2;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (auto &s1 : leftArr[i]) {\\n                // check nearest sum on right side for given left subarray\\n                auto s2 = lower_bound(begin(rightArr[n-i]),end(rightArr[n-i]),(halfTarget-s1));\\n                if (s2 == rightArr[n-i].end())\\n                    s2--;\\n                \\n                ll lsum = s1 + *s2;\\n                ll rsum = target-lsum;\\n                res = min(res,abs(lsum-rsum));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Another approach to generate powerSets\\n\\nclass Solution {\\npublic: \\n    using ll = long long int;\\n   \\n    int minimumDifference(vector<int>& nums) {\\n        ll target = accumulate(begin(nums),end(nums),0);\\n        int n = nums.size()/2;\\n        vector<vector<ll>> leftArr(n+1);\\n        vector<vector<ll>> rightArr(n+1);\\n        \\n        int powerSet = (1 << n);\\n        for (int mask=0; mask < powerSet; mask++) {\\n            int numOnes = 0;\\n            ll lsum = 0; ll rsum = 0;\\n            for (int i = 0; i < n; i++) {\\n                if(mask&(1<<i)) {\\n                    lsum += nums[i];\\n                    rsum += nums[i+n];\\n                    numOnes++;\\n                }\\n            }\\n            leftArr[numOnes].push_back(lsum);\\n            rightArr[numOnes].push_back(rsum);\\n        }\\n      \\n        \\n        // sort for easy binary search\\n        for (int i = 0; i < n+1; i++) {\\n            sort(begin(leftArr[i]),end(leftArr[i]));\\n            sort(begin(rightArr[i]),end(rightArr[i]));\\n        }\\n        \\n        ll res = INT_MAX;\\n        ll halfTarget = target/2;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (auto &s1 : leftArr[i]) {\\n                // check nearest sum on right side for given left subarray\\n                auto s2 = lower_bound(begin(rightArr[n-i]),end(rightArr[n-i]),(halfTarget-s1));\\n                if (s2 == rightArr[n-i].end())\\n                    s2--;\\n                \\n                ll lsum = s1 + *s2;\\n                ll rsum = target-lsum;\\n                res = min(res,abs(lsum-rsum));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic: \\n    using ll = long long int;\\n    // compute 2^n sets for the given n/2 array\\n    void populateArr(vector<int> &nums, int start, vector<vector<ll>> &arr) {\\n        int n = nums.size()/2;\\n        int sz = 1;\\n        vector<vector<ll>> prev;\\n        for (int i = start; i < start+n; i++) {\\n            prev = arr;\\n            for (int k = 1; k <= n; k++) {\\n                for (auto &sum : prev[k-1]) {\\n                    arr[k].push_back(sum+nums[i]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int minimumDifference(vector<int>& nums) {\\n        ll target = accumulate(begin(nums),end(nums),0);\\n        int n = nums.size()/2;\\n        vector<vector<ll>> leftArr(n+1);\\n        vector<vector<ll>> rightArr(n+1);\\n        // push 0 sum for null set\\n        leftArr[0].push_back(0);\\n        rightArr[0].push_back(0);\\n        \\n        // take out all n sets from each left and right part of total array\\n        populateArr(nums,0,leftArr);\\n        populateArr(nums,n,rightArr);\\n        \\n        // sort for easy binary search\\n        for (int i = 0; i < n+1; i++) {\\n            sort(begin(leftArr[i]),end(leftArr[i]));\\n            sort(begin(rightArr[i]),end(rightArr[i]));\\n        }\\n        \\n        ll res = INT_MAX;\\n        ll halfTarget = target/2;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (auto &s1 : leftArr[i]) {\\n                // check nearest sum on right side for given left subarray\\n                auto s2 = lower_bound(begin(rightArr[n-i]),end(rightArr[n-i]),(halfTarget-s1));\\n                if (s2 == rightArr[n-i].end())\\n                    s2--;\\n                \\n                ll lsum = s1 + *s2;\\n                ll rsum = target-lsum;\\n                res = min(res,abs(lsum-rsum));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873108,
                "title": "python-simple-meet-in-the-middle-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2**(n//2)*log(2**(n//2)))\\n\\n- Space complexity: O(2**(n//2))\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDifference(self, nums):\\n        def subset_sums(ans):\\n            d = defaultdict(set)\\n\\n            for i in range(1,len(ans)):\\n                d[i] = sorted(set([sum(j) for j in combinations(ans,i)]))\\n            return d\\n\\n        n = len(nums)\\n\\n        total, l, r = sum(nums), nums[:n//2], nums[n//2:]\\n        d1, d2, min_diff = subset_sums(l), subset_sums(r), abs(sum(l)-sum(r))\\n\\n        for k in d1:\\n            left, right = d1[k], d2[n//2-k]\\n            for x in left:\\n                i = bisect.bisect_left(right,total//2-x)\\n\\n                if i<len(right):\\n                    min_diff = min(min_diff,abs((right[i]+x)*2-total))\\n                if i>0:\\n                    min_diff = min(min_diff,abs((right[i-1]+x)*2-total))\\n\\n        return min_diff\\n\\n\\n\\n\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums):\\n        def subset_sums(ans):\\n            d = defaultdict(set)\\n\\n            for i in range(1,len(ans)):\\n                d[i] = sorted(set([sum(j) for j in combinations(ans,i)]))\\n            return d\\n\\n        n = len(nums)\\n\\n        total, l, r = sum(nums), nums[:n//2], nums[n//2:]\\n        d1, d2, min_diff = subset_sums(l), subset_sums(r), abs(sum(l)-sum(r))\\n\\n        for k in d1:\\n            left, right = d1[k], d2[n//2-k]\\n            for x in left:\\n                i = bisect.bisect_left(right,total//2-x)\\n\\n                if i<len(right):\\n                    min_diff = min(min_diff,abs((right[i]+x)*2-total))\\n                if i>0:\\n                    min_diff = min(min_diff,abs((right[i-1]+x)*2-total))\\n\\n        return min_diff\\n\\n\\n\\n\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853581,
                "title": "c-simple-to-understand-bit-masking",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        n=n/2;\\n        int total=0;\\n        for(int i=0;i<2*n;i++)\\n        {\\n            total+=nums[i];\\n        }\\n        \\n        vector<vector<int>> adj(16);\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            int cnt=0,sum=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    sum+=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            adj[cnt].push_back(sum);\\n        }\\n        \\n        int ans=INT_MAX;\\n        int hsum=total/2;\\n        \\n        vector<int> vec(n);\\n        for(int i=n;i<2*n;i++)\\n        {\\n            vec[i-n]=nums[i];\\n        }\\n        for(int i=0;i<16;i++)\\n        {\\n            sort(adj[i].begin(),adj[i].end());\\n        }\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            int cc=0,ss=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    ss+=vec[j];\\n                    cc++;\\n                }\\n            }\\n            int x=hsum-ss;\\n            int y=n-cc;\\n            \\n            if(y==0)\\n            {\\n                ans=min(ans,abs(total-2*ss));\\n                continue;\\n            }\\n            int ind=lower_bound(adj[y].begin(),adj[y].end(),x)-adj[y].begin();\\n            vector<int>&temp=adj[y];\\n            \\n            if(ind<temp.size())\\n            {\\n                ss+=temp[ind];\\n                ans=min(ans,abs(total-2*ss));\\n                ss-=temp[ind];\\n            }\\n            if(ind!=0)\\n            {\\n                ind--;\\n                ss+=temp[ind];\\n                ans=min(ans,abs(total-2*ss));\\n                ss-=temp[ind];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        n=n/2;\\n        int total=0;\\n        for(int i=0;i<2*n;i++)\\n        {\\n            total+=nums[i];\\n        }\\n        \\n        vector<vector<int>> adj(16);\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            int cnt=0,sum=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    sum+=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            adj[cnt].push_back(sum);\\n        }\\n        \\n        int ans=INT_MAX;\\n        int hsum=total/2;\\n        \\n        vector<int> vec(n);\\n        for(int i=n;i<2*n;i++)\\n        {\\n            vec[i-n]=nums[i];\\n        }\\n        for(int i=0;i<16;i++)\\n        {\\n            sort(adj[i].begin(),adj[i].end());\\n        }\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            int cc=0,ss=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    ss+=vec[j];\\n                    cc++;\\n                }\\n            }\\n            int x=hsum-ss;\\n            int y=n-cc;\\n            \\n            if(y==0)\\n            {\\n                ans=min(ans,abs(total-2*ss));\\n                continue;\\n            }\\n            int ind=lower_bound(adj[y].begin(),adj[y].end(),x)-adj[y].begin();\\n            vector<int>&temp=adj[y];\\n            \\n            if(ind<temp.size())\\n            {\\n                ss+=temp[ind];\\n                ans=min(ans,abs(total-2*ss));\\n                ss-=temp[ind];\\n            }\\n            if(ind!=0)\\n            {\\n                ind--;\\n                ss+=temp[ind];\\n                ans=min(ans,abs(total-2*ss));\\n                ss-=temp[ind];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838935,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     \\n    public int minimumDifference(int[] nums) {\\n    int total= 0;\\n        for(int i : nums){\\n            total+=i;\\n        }\\n        int target = total/2, min = Integer.MAX_VALUE, val = min;\\n        HashMap<Integer, ArrayList<Integer>> hm1 = new HashMap<>();\\n        HashMap<Integer, ArrayList<Integer>> hm2 = new HashMap<>();\\n        int half = nums.length/2;\\n        for(int i = 0 ; i<=half ; i++){\\n            hm1.put(i,new ArrayList<Integer>());\\n            hm2.put(i,new ArrayList<Integer>());\\n        }\\n        solve(nums,0,0,0,half,hm1);\\n        solve(nums,half,0,0,nums.length,hm2);\\n        for(int i = 0 ; i<=half ; i++){\\n            ArrayList<Integer> list1 = hm1.get(i);\\n            ArrayList<Integer> list2 = hm2.get(half-i);\\n            Collections.sort(list1);\\n            Collections.sort(list2);\\n            int j = 0 , k = list2.size()-1;\\n            while(j<list1.size() && k>=0){\\n                int sum = list1.get(j) + list2.get(k);\\n                if(sum==target){\\n                    return Math.abs(total-2*sum);\\n                }else if(sum>target){\\n                    k--;\\n                }else{\\n                    j++;\\n                }\\n                int diff = Math.abs(sum-target);\\n                if(diff<min){\\n                    min = diff;\\n                    val = sum;\\n                }\\n            }\\n            \\n        }\\n        return Math.abs(total - 2*val);\\n    }\\n    \\n    public void solve(int []nums,int i, int sum, int count, int high, HashMap<Integer, ArrayList<Integer>> hm){\\n        if(i==high){\\n            hm.get(count).add(sum);\\n            return;\\n        } \\n        solve(nums,i+1,sum+nums[i],count+1,high,hm);\\n        solve(nums,i+1,sum,count,high,hm);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     \\n    public int minimumDifference(int[] nums) {\\n    int total= 0;\\n        for(int i : nums){\\n            total+=i;\\n        }\\n        int target = total/2, min = Integer.MAX_VALUE, val = min;\\n        HashMap<Integer, ArrayList<Integer>> hm1 = new HashMap<>();\\n        HashMap<Integer, ArrayList<Integer>> hm2 = new HashMap<>();\\n        int half = nums.length/2;\\n        for(int i = 0 ; i<=half ; i++){\\n            hm1.put(i,new ArrayList<Integer>());\\n            hm2.put(i,new ArrayList<Integer>());\\n        }\\n        solve(nums,0,0,0,half,hm1);\\n        solve(nums,half,0,0,nums.length,hm2);\\n        for(int i = 0 ; i<=half ; i++){\\n            ArrayList<Integer> list1 = hm1.get(i);\\n            ArrayList<Integer> list2 = hm2.get(half-i);\\n            Collections.sort(list1);\\n            Collections.sort(list2);\\n            int j = 0 , k = list2.size()-1;\\n            while(j<list1.size() && k>=0){\\n                int sum = list1.get(j) + list2.get(k);\\n                if(sum==target){\\n                    return Math.abs(total-2*sum);\\n                }else if(sum>target){\\n                    k--;\\n                }else{\\n                    j++;\\n                }\\n                int diff = Math.abs(sum-target);\\n                if(diff<min){\\n                    min = diff;\\n                    val = sum;\\n                }\\n            }\\n            \\n        }\\n        return Math.abs(total - 2*val);\\n    }\\n    \\n    public void solve(int []nums,int i, int sum, int count, int high, HashMap<Integer, ArrayList<Integer>> hm){\\n        if(i==high){\\n            hm.get(count).add(sum);\\n            return;\\n        } \\n        solve(nums,i+1,sum+nums[i],count+1,high,hm);\\n        solve(nums,i+1,sum,count,high,hm);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829586,
                "title": "solution-with-bitmasking-approach-on-finding-subsets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func minimumDifference(_ nums: [Int]) -> Int {\\n        let count = nums.count\\n        let half = count / 2\\n        let sum = nums.reduce(0,+)\\n        let leftArray = Array(nums[..<half])\\n        let rightArray = Array(nums[half...])\\n        let leftSum = leftArray.reduce(0,+)\\n        let rightSum = rightArray.reduce(0,+)\\n        let halfSum = sum/2\\n\\n        let tuple = getLeftRightSubsetSumDict(nums)\\n        var leftSubsetSum = tuple.0\\n        var rightSubsetSum = tuple.1\\n        var result = abs(leftSum - rightSum)\\n\\n        for i in 1..<half {\\n            let leftSums = leftSubsetSum[i]!\\n            let sortedRightArray = rightSubsetSum[half - i]!.sorted()\\n\\n            for j in leftSums {\\n                let remainingSum = halfSum - j\\n                let closestRightVal = findClosestNumber(sortedRightArray, remainingSum)\\n\\n                for q in [closestRightVal, closestRightVal + 1] {\\n                    if q >= 0 && q < sortedRightArray.count {\\n                        let lSum = j + sortedRightArray[q]\\n                        let rSum = sum - lSum\\n\\n                        \\n                        result = min(result, abs(lSum - rSum))\\n                    }\\n                    if result == 0 {\\n                        return result\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result\\n    }\\n\\n    func findClosestNumber(_ nums: [Int], _ k: Int) -> Int {\\n        return binarySearchClosestNumber(nums, k,  0, nums.count)\\n    }\\n\\n    func binarySearchClosestNumber(_ nums: [Int], _ k: Int, _ l: Int, _ u: Int) -> Int {\\n        if l == u || l == u-1 { return l }\\n\\n        let mid = (u-l)/2 + l\\n\\n        if k < nums[mid] {\\n            return binarySearchClosestNumber(nums, k, l, mid-1)\\n        } else {\\n            return binarySearchClosestNumber(nums, k, mid, u)\\n        }\\n    }\\n\\n    func getLeftRightSubsetSumDict(_ nums: [Int]) -> ([Int: [Int]], [Int: [Int]]) {\\n        var leftSubsetSum: [Int: [Int]] = [:]\\n        var rightSubsetSum: [Int: [Int]] = [:]\\n        let half = nums.count / 2\\n\\n        for mask in 1 ..< (1 << half) {\\n            var idx = 0\\n            var lSum = 0\\n            var rSum = 0\\n            for i in 0 ..< half {\\n                if (mask & (1 << i)) != 0 {\\n                    idx += 1\\n                    lSum += nums[i]\\n                    rSum += nums[i + half]\\n                }\\n            }\\n            leftSubsetSum[idx, default: []] += [lSum]\\n            rightSubsetSum[idx, default: []] += [rSum]\\n        }\\n\\n        return(leftSubsetSum, rightSubsetSum)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumDifference(_ nums: [Int]) -> Int {\\n        let count = nums.count\\n        let half = count / 2\\n        let sum = nums.reduce(0,+)\\n        let leftArray = Array(nums[..<half])\\n        let rightArray = Array(nums[half...])\\n        let leftSum = leftArray.reduce(0,+)\\n        let rightSum = rightArray.reduce(0,+)\\n        let halfSum = sum/2\\n\\n        let tuple = getLeftRightSubsetSumDict(nums)\\n        var leftSubsetSum = tuple.0\\n        var rightSubsetSum = tuple.1\\n        var result = abs(leftSum - rightSum)\\n\\n        for i in 1..<half {\\n            let leftSums = leftSubsetSum[i]!\\n            let sortedRightArray = rightSubsetSum[half - i]!.sorted()\\n\\n            for j in leftSums {\\n                let remainingSum = halfSum - j\\n                let closestRightVal = findClosestNumber(sortedRightArray, remainingSum)\\n\\n                for q in [closestRightVal, closestRightVal + 1] {\\n                    if q >= 0 && q < sortedRightArray.count {\\n                        let lSum = j + sortedRightArray[q]\\n                        let rSum = sum - lSum\\n\\n                        \\n                        result = min(result, abs(lSum - rSum))\\n                    }\\n                    if result == 0 {\\n                        return result\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result\\n    }\\n\\n    func findClosestNumber(_ nums: [Int], _ k: Int) -> Int {\\n        return binarySearchClosestNumber(nums, k,  0, nums.count)\\n    }\\n\\n    func binarySearchClosestNumber(_ nums: [Int], _ k: Int, _ l: Int, _ u: Int) -> Int {\\n        if l == u || l == u-1 { return l }\\n\\n        let mid = (u-l)/2 + l\\n\\n        if k < nums[mid] {\\n            return binarySearchClosestNumber(nums, k, l, mid-1)\\n        } else {\\n            return binarySearchClosestNumber(nums, k, mid, u)\\n        }\\n    }\\n\\n    func getLeftRightSubsetSumDict(_ nums: [Int]) -> ([Int: [Int]], [Int: [Int]]) {\\n        var leftSubsetSum: [Int: [Int]] = [:]\\n        var rightSubsetSum: [Int: [Int]] = [:]\\n        let half = nums.count / 2\\n\\n        for mask in 1 ..< (1 << half) {\\n            var idx = 0\\n            var lSum = 0\\n            var rSum = 0\\n            for i in 0 ..< half {\\n                if (mask & (1 << i)) != 0 {\\n                    idx += 1\\n                    lSum += nums[i]\\n                    rSum += nums[i + half]\\n                }\\n            }\\n            leftSubsetSum[idx, default: []] += [lSum]\\n            rightSubsetSum[idx, default: []] += [rSum]\\n        }\\n\\n        return(leftSubsetSum, rightSubsetSum)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817583,
                "title": "shortest-code-for-meet-in-the-middle-combined-with-binary-search",
                "content": "`maskL = 1 0 1 1 1 0 1`, all set bits are part of left-side and rest are considered part of right-side\\n`maskR = 1 0 0 0 1 0 0`, we will take maskR such that total elements left-side and right-side from maskR and maskL are resp. equal.\\n\\n`setL + not-setR  \\u2248 setR + not-setL`, we just rearrange \\n`setL - not-setL  \\u2248 setR - not-setR`, benefit of this is for every part from L we can binary search closest matching in R.\\n\\n`L[i]` = array of all `setL - not-setL` differences with exactly `i` set bits\\n`R[i]` = array of all `setR - not-setR` differences with exactly `i` set bits\\n\\nWe just brute-force for `i` setbits in `L[i]` we binary search best fit in `R[n-i]` and find the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = (int)nums.size()/2; n++; \\n        vector<vector<int>> L(n),R(n); n--;\\n        // fill Left side ---------------------------------------\\n        for(int i=0;i<(1<<n);i++){\\n            int cnt=0,sumb=0,sumw=0;\\n            for(int j=0;j<n;j++)if((i>>j)&1)cnt++,sumb+=nums[j];else sumw+=nums[j];\\n            L[cnt].push_back(sumb-sumw);\\n        }\\n        for(int i=0;i<n;i++)sort(L[i].begin(),L[i].end());\\n\\t\\t\\n        // fill Right side -------------------------------------\\n        for(int i=0;i<(1<<n);i++){\\n            int cnt=0,sumb=0,sumw=0;\\n            for(int j=0;j<n;j++)if((i>>j)&1)cnt++,sumb+=nums[n+j];else sumw+=nums[n+j];\\n            R[cnt].push_back(sumw-sumb);\\n        }\\n        for(int i=0;i<n;i++)sort(R[i].begin(),R[i].end());\\n        \\n        // ----------- solve ------------------------\\n        int ans=2e9;\\n        \\n        for(int i=0;i<n;i++)for(int valnow : L[i]){\\n            int pos = int(lower_bound(R[n-i].begin(),R[n-i].end(),valnow)-R[n-i].begin());\\n            for(int del : {-2,-1,0,1,2})if(pos+del>=0 && pos+del<(int)R[n-i].size()){\\n                ans = min(ans,abs(valnow-R[j][pos+del]));\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n        int n = (int)nums.size()/2; n++; \\n        vector<vector<int>> L(n),R(n); n--;\\n        // fill Left side ---------------------------------------\\n        for(int i=0;i<(1<<n);i++){\\n            int cnt=0,sumb=0,sumw=0;\\n            for(int j=0;j<n;j++)if((i>>j)&1)cnt++,sumb+=nums[j];else sumw+=nums[j];\\n            L[cnt].push_back(sumb-sumw);\\n        }\\n        for(int i=0;i<n;i++)sort(L[i].begin(),L[i].end());\\n\\t\\t\\n        // fill Right side -------------------------------------\\n        for(int i=0;i<(1<<n);i++){\\n            int cnt=0,sumb=0,sumw=0;\\n            for(int j=0;j<n;j++)if((i>>j)&1)cnt++,sumb+=nums[n+j];else sumw+=nums[n+j];\\n            R[cnt].push_back(sumw-sumb);\\n        }\\n        for(int i=0;i<n;i++)sort(R[i].begin(),R[i].end());\\n        \\n        // ----------- solve ------------------------\\n        int ans=2e9;\\n        \\n        for(int i=0;i<n;i++)for(int valnow : L[i]){\\n            int pos = int(lower_bound(R[n-i].begin(),R[n-i].end(),valnow)-R[n-i].begin());\\n            for(int del : {-2,-1,0,1,2})if(pos+del>=0 && pos+del<(int)R[n-i].size()){\\n                ans = min(ans,abs(valnow-R[j][pos+del]));\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813209,
                "title": "c-meet-in-the-middle",
                "content": "# Intuition\\nPorted from Java: https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/solutions/1513541/java-meet-in-the-middle-and-two-pointers-time-o-n-2-n-2-space-o-2-n-2/\\n# Approach\\nMeet in the middle is a search technique that splits the problem into two, solves them individually and then merge them. We can apply it to this problem as follows:\\n\\n1-Split the set of integers into 2 subsets say $$temp1$$ and $$temp2$$. $$temp1$$ having first $$L/2$$ integers and $$temp2$$ having the rest.\\n```\\nint L = nums.Length;\\nvar temp1 = new int[L/2];\\nvar temp2 = new int[L - L/2];\\nArray.Copy(nums, 0, temp1, 0,  L / 2);\\nArray.Copy(nums, L/2, temp2, 0, L-L/2);\\n```\\n2-Find all possible results  (sets[i][]) of $$subsetSum(len == i) - subsetSum(len == n - i)$$. \\n```\\nint[][] diff1 = Generate(temp1);\\nint[][] diff2 = Generate(temp2);\\n```\\n3-Now merge these 2 subproblems. Explore all combinations from array diff1 and diff2 such that their difference is closer to zero. \\n```\\n for (int len = 0; len <= L / 2; len++) {\\n    int[] left = diff1[len];\\n    int[] right = diff2[len];\\n\\n    int l = 0;\\n    int r = 0;\\n\\n    while(l < left.Length && r < left.Length) { ...\\n\\n```\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumDifference(int[] nums) {\\n        int L = nums.Length;\\n        var temp1 = new int[L/2];\\n        var temp2 = new int[L - L/2];\\n        Array.Copy(nums, 0, temp1, 0,  L / 2);\\n        Array.Copy(nums, L/2, temp2, 0, L-L/2);\\n        int[][] diff1 = Generate(temp1);\\n        int[][] diff2 = Generate(temp2);\\n\\n        int min = Int32.MaxValue;\\n        for (int len = 0; len <= L / 2; len++) {\\n            int[] left = diff1[len];\\n            int[] right = diff2[len];\\n\\n            int l = 0;\\n            int r = 0;\\n\\n            while(l < left.Length && r < left.Length) {\\n                //arrays are already sorted so we move one pointer at a time to make the diff closer to 0\\n                int diff = left[l] - right[r];\\n                min = Math.Min(min, Math.Abs(diff));\\n                if (diff < 0) \\n                {\\n                    l++;\\n                }\\n                else if (diff > 0)\\n                {\\n                    r++;\\n                } \\n                else\\n                {\\n                    return 0;\\n                } \\n            }\\n        }\\n\\n        return min;\\n    }\\n\\n    private int[][] Generate(int[] arr) { //generate sets[i][]: all the results of subsetSum(len == i) - subsetSum(len == n - i)\\n        int n = arr.Length;\\n        int[][] ans = new int[n + 1][]; //n + 1 for length can be 0\\n\\n        int combo = 1;\\n        ans[0] = new int[combo]; //when len is 0, there is only one possibility\\n        for (int i = 1; i <= n; i++) { //how many combos there are when len is i\\n            combo = combo * (n - i + 1) / i;\\n            ans[i] = new int[combo];\\n        }\\n\\n        int total = 0;\\n        foreach (int i in arr)\\n        {\\n            total += i;\\n        } \\n\\n        int limit = 1 << n; //using bits to represent the combos: 1 means the number at that index is chosen to form the subset\\n        int[] counter = new int[n + 1]; //used to keep the current index for each length\\n        for (int i = 0; i < limit; i++) {\\n            int subSum = 0;\\n            for (int j = 0; j < n; j++) {\\n                if ((i >> j & 1) == 1) subSum += arr[j];\\n            }\\n\\n            int rest = total - subSum;\\n            //instead of storing the subSum we store the difference to avoid binary search later\\n            //(sub1 - rest1) - (sub2 - rest2) = (sub1 + rest2) - (sub2 + rest1) = what the prob is asking for\\n            //(sub1 + rest2) and (sub2 + rest1) are of the same length\\n\\n            int lenOfSub = BitCount(i);\\n            ans[lenOfSub][counter[lenOfSub]++] = subSum - rest;\\n        }\\n\\n        foreach (int[] a in ans) \\n        {\\n            Array.Sort(a);\\n\\n        }\\n\\n        return ans;\\n    }\\n    public static int BitCount(int n)\\n    {\\n        var count = 0;\\n        while (n != 0)\\n        {\\n            count++;\\n            n &= (n - 1); //walking through all the bits which are set to one\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nint L = nums.Length;\\nvar temp1 = new int[L/2];\\nvar temp2 = new int[L - L/2];\\nArray.Copy(nums, 0, temp1, 0,  L / 2);\\nArray.Copy(nums, L/2, temp2, 0, L-L/2);\\n```\n```\\nint[][] diff1 = Generate(temp1);\\nint[][] diff2 = Generate(temp2);\\n```\n```\\n for (int len = 0; len <= L / 2; len++) {\\n    int[] left = diff1[len];\\n    int[] right = diff2[len];\\n\\n    int l = 0;\\n    int r = 0;\\n\\n    while(l < left.Length && r < left.Length) { ...\\n\\n```\n```\\npublic class Solution {\\n    public int MinimumDifference(int[] nums) {\\n        int L = nums.Length;\\n        var temp1 = new int[L/2];\\n        var temp2 = new int[L - L/2];\\n        Array.Copy(nums, 0, temp1, 0,  L / 2);\\n        Array.Copy(nums, L/2, temp2, 0, L-L/2);\\n        int[][] diff1 = Generate(temp1);\\n        int[][] diff2 = Generate(temp2);\\n\\n        int min = Int32.MaxValue;\\n        for (int len = 0; len <= L / 2; len++) {\\n            int[] left = diff1[len];\\n            int[] right = diff2[len];\\n\\n            int l = 0;\\n            int r = 0;\\n\\n            while(l < left.Length && r < left.Length) {\\n                //arrays are already sorted so we move one pointer at a time to make the diff closer to 0\\n                int diff = left[l] - right[r];\\n                min = Math.Min(min, Math.Abs(diff));\\n                if (diff < 0) \\n                {\\n                    l++;\\n                }\\n                else if (diff > 0)\\n                {\\n                    r++;\\n                } \\n                else\\n                {\\n                    return 0;\\n                } \\n            }\\n        }\\n\\n        return min;\\n    }\\n\\n    private int[][] Generate(int[] arr) { //generate sets[i][]: all the results of subsetSum(len == i) - subsetSum(len == n - i)\\n        int n = arr.Length;\\n        int[][] ans = new int[n + 1][]; //n + 1 for length can be 0\\n\\n        int combo = 1;\\n        ans[0] = new int[combo]; //when len is 0, there is only one possibility\\n        for (int i = 1; i <= n; i++) { //how many combos there are when len is i\\n            combo = combo * (n - i + 1) / i;\\n            ans[i] = new int[combo];\\n        }\\n\\n        int total = 0;\\n        foreach (int i in arr)\\n        {\\n            total += i;\\n        } \\n\\n        int limit = 1 << n; //using bits to represent the combos: 1 means the number at that index is chosen to form the subset\\n        int[] counter = new int[n + 1]; //used to keep the current index for each length\\n        for (int i = 0; i < limit; i++) {\\n            int subSum = 0;\\n            for (int j = 0; j < n; j++) {\\n                if ((i >> j & 1) == 1) subSum += arr[j];\\n            }\\n\\n            int rest = total - subSum;\\n            //instead of storing the subSum we store the difference to avoid binary search later\\n            //(sub1 - rest1) - (sub2 - rest2) = (sub1 + rest2) - (sub2 + rest1) = what the prob is asking for\\n            //(sub1 + rest2) and (sub2 + rest1) are of the same length\\n\\n            int lenOfSub = BitCount(i);\\n            ans[lenOfSub][counter[lenOfSub]++] = subSum - rest;\\n        }\\n\\n        foreach (int[] a in ans) \\n        {\\n            Array.Sort(a);\\n\\n        }\\n\\n        return ans;\\n    }\\n    public static int BitCount(int n)\\n    {\\n        var count = 0;\\n        while (n != 0)\\n        {\\n            count++;\\n            n &= (n - 1); //walking through all the bits which are set to one\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808271,
                "title": "short-python-solution",
                "content": "# Code\\n```\\nimport numpy as np\\nclass Solution:\\n    def split (self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums) \\n        dp = [ [] for _ in range(n + 1) ]\\n        pw = (1 << (n - 1))\\n        sm = sum(nums)\\n        for i in range(pw) :\\n            x = sum(nums[j] for j in range(len(nums)) if i & (1 << j))\\n            dp[i.bit_count()].append(sm - 2 * x)\\n            dp[n - i.bit_count()].append(-(sm - 2 * x))\\n        for i in range(len(dp)) :\\n            dp[i].sort()\\n        return dp    \\n\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        a = self.split(nums[0:int(n/2)])\\n        b = self.split(nums[int(n/2):n])\\n        mn = 100000000\\n        for i1 in range(len(a)) :\\n            i2 = int(n/2) - i1\\n            r = len(b[i2]) - 1\\n            for j1 in range(len(a[i1])) :\\n                if len(b[i2]) == 0 or b[i2][len(b[i2]) - 1] + a[i1][j1] < 0 :\\n                    continue\\n                l = bisect.bisect_left(b[i2], -a[i1][j1])\\n                if mn > a[i1][j1] + b[i2][l] :\\n                    mn = a[i1][j1] + b[i2][l]\\n        return mn\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n    def split (self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums) \\n        dp = [ [] for _ in range(n + 1) ]\\n        pw = (1 << (n - 1))\\n        sm = sum(nums)\\n        for i in range(pw) :\\n            x = sum(nums[j] for j in range(len(nums)) if i & (1 << j))\\n            dp[i.bit_count()].append(sm - 2 * x)\\n            dp[n - i.bit_count()].append(-(sm - 2 * x))\\n        for i in range(len(dp)) :\\n            dp[i].sort()\\n        return dp    \\n\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        a = self.split(nums[0:int(n/2)])\\n        b = self.split(nums[int(n/2):n])\\n        mn = 100000000\\n        for i1 in range(len(a)) :\\n            i2 = int(n/2) - i1\\n            r = len(b[i2]) - 1\\n            for j1 in range(len(a[i1])) :\\n                if len(b[i2]) == 0 or b[i2][len(b[i2]) - 1] + a[i1][j1] < 0 :\\n                    continue\\n                l = bisect.bisect_left(b[i2], -a[i1][j1])\\n                if mn > a[i1][j1] + b[i2][l] :\\n                    mn = a[i1][j1] + b[i2][l]\\n        return mn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759189,
                "title": "memoized-solution-not-working-for-a-certain-test-case",
                "content": "My solution is not working for test case: \\nInput: [76,8,45,20,74,84,28,1]\\nOutput: 0\\nExpected: 2\\n\\nCan anyone tell me what\\'s the issue here? Also according to me expected should be 0, as one subset could be [76,8,84] = 168 and other subset will be [45,20,74,28,1] = 168 which will give 0 difference. \\n\\nWould appreciate all help here!\\n\\n```class Solution {\\n    public int minimumDifference(int[] nums) {\\n        Map<String, Integer> myMap = new HashMap<>();\\n        int totalSum = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            totalSum+=nums[i];\\n        }\\n        return recurse(nums, nums.length-1, 0, totalSum, myMap);\\n    }\\n    \\n    public int recurse(int[] nums, int i, int sumSoFar, int totalSum, Map<String, Integer> myMap) {\\n        String key = i + \"->\" + sumSoFar;\\n        if (i<0) {\\n            if (sumSoFar!=0) {\\n                myMap.put(key, Math.abs(totalSum-2*(sumSoFar)));\\n                return myMap.get(key);                \\n            }\\n            else {\\n                return 999999;\\n            }\\n        }\\n\\n        if (myMap.containsKey(key)) {\\n            return myMap.get(key);\\n        }\\n\\n        int take = recurse(nums, i-1, sumSoFar + nums[i], totalSum, myMap);\\n        int dontTake = recurse(nums, i-1, sumSoFar, totalSum, myMap);\\n\\n        myMap.put(key, Math.min(take, dontTake));\\n        return myMap.get(key);\\n    }\\n}```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public int minimumDifference(int[] nums) {\\n        Map<String, Integer> myMap = new HashMap<>();\\n        int totalSum = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            totalSum+=nums[i];\\n        }\\n        return recurse(nums, nums.length-1, 0, totalSum, myMap);\\n    }\\n    \\n    public int recurse(int[] nums, int i, int sumSoFar, int totalSum, Map<String, Integer> myMap) {\\n        String key = i + \"->\" + sumSoFar;\\n        if (i<0) {\\n            if (sumSoFar!=0) {\\n                myMap.put(key, Math.abs(totalSum-2*(sumSoFar)));\\n                return myMap.get(key);                \\n            }\\n            else {\\n                return 999999;\\n            }\\n        }\\n\\n        if (myMap.containsKey(key)) {\\n            return myMap.get(key);\\n        }\\n\\n        int take = recurse(nums, i-1, sumSoFar + nums[i], totalSum, myMap);\\n        int dontTake = recurse(nums, i-1, sumSoFar, totalSum, myMap);\\n\\n        myMap.put(key, Math.min(take, dontTake));\\n        return myMap.get(key);\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2723862,
                "title": "python-solution-binary-search-meet-in-the-middle",
                "content": "The goal can be set to seek a subsequence for its sum as **half of input list sum**\\nIn this way, the problem is the same as [Leetcode 1755. Closest Subsequence Sum](https://leetcode.com/problems/closest-subsequence-sum/)\\nThe only difference is the target subsequence with **half of elements** in the input list.\\nWe can implement meet-in-the-middle algorithm to solve this problem.\\n\\n```\\ndef minimumDifference(self, nums: List[int]) -> int:\\n\\tdef sub_sum(cans):\\n\\t\\td = defaultdict(set)  # key:element number, value:possible sum\\n\\t\\tfor i in range(1, len(cans)):\\n\\t\\t\\td[i] = sorted(set([sum(comb) for comb in combinations(cans, i)]))\\n\\t\\treturn d\\n\\n\\ts, l, r = sum(nums), nums[:len(nums)//2], nums[len(nums)//2:]\\n\\td1, d2, ans = sub_sum(l), sub_sum(r), abs(sum(l)-sum(r))\\n\\tfor k in d1:\\n\\t\\tleft, right = d1[k], d2[len(nums)//2-k]\\n\\t\\tfor x in left:\\n\\t\\t\\ti = bisect.bisect_left(right, s//2-x)\\n\\t\\t\\tif i<len(right):\\n\\t\\t\\t\\tans = min(ans, abs((right[i]+x)*2-s))\\n\\t\\t\\tif i>0:\\n\\t\\t\\t\\tans = min(ans, abs((right[i-1]+x)*2-s))\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef minimumDifference(self, nums: List[int]) -> int:\\n\\tdef sub_sum(cans):\\n\\t\\td = defaultdict(set)  # key:element number, value:possible sum\\n\\t\\tfor i in range(1, len(cans)):\\n\\t\\t\\td[i] = sorted(set([sum(comb) for comb in combinations(cans, i)]))\\n\\t\\treturn d\\n\\n\\ts, l, r = sum(nums), nums[:len(nums)//2], nums[len(nums)//2:]\\n\\td1, d2, ans = sub_sum(l), sub_sum(r), abs(sum(l)-sum(r))\\n\\tfor k in d1:\\n\\t\\tleft, right = d1[k], d2[len(nums)//2-k]\\n\\t\\tfor x in left:\\n\\t\\t\\ti = bisect.bisect_left(right, s//2-x)\\n\\t\\t\\tif i<len(right):\\n\\t\\t\\t\\tans = min(ans, abs((right[i]+x)*2-s))\\n\\t\\t\\tif i>0:\\n\\t\\t\\t\\tans = min(ans, abs((right[i-1]+x)*2-s))\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2723502,
                "title": "scala-brute-force-recursion-divide-conquer-binary-search",
                "content": "```\\nobject Solution {\\n    def minimumDifferenceBF(nums: Array[Int]): Int = {\\n        /* thought process\\n        1. we don\\'t know what would be minimum , so let\\'s guess\\n        2. how to guess? try them all\\n        3. how to try? Dynamic Programming with memoization\\n        4. what to memoize? not sure\\n        5. it turns out DP does not work for this problem\\n        6. try brute force then\\n        7. how to make brute force more efficient? divide and conquer?\\n        8. generate all possible sum from 2*N elements is too much , let\\'s try just do N elemens at a time\\n        9. split the array in two equal size, assemble part1 from these two arrays, part2=totalSum-part1\\n        10. our goal is to have part1-part2 -> 0, that is part1==part2, ie part1=totalSum/2 \\n        */\\n        //brute force\\n        import scala.collection.mutable.ArrayBuffer\\n        val chosen=ArrayBuffer[Int]()\\n        var minDiff=Integer.MAX_VALUE\\n        var total:Long=nums.sum.toLong\\n        def helper(items:Int=0,ind: Int=0, sum:Long=0, current:ArrayBuffer[Int]=chosen) :Unit ={\\n            if (ind==nums.length || items==nums.size/2) {\\n                if (items==nums.length/2) {\\n                    minDiff=minDiff.min(math.abs(total-sum-sum).toInt)\\n                    println(s\"found: $sum - ${total-sum}, diff=$minDiff, chosen=$chosen\")\\n                }\\n            }\\n            else if (items<nums.size/2) {\\n               current+=nums(ind)\\n               helper(items+1, ind+1, sum+nums(ind))\\n               current.dropRightInPlace(1)\\n               helper(items, ind+1, sum)\\n            }\\n        }\\n        helper()\\n        minDiff\\n    }\\n    \\n    //Similar and simpler than LC#1755 (Hard) which is the base for this \\n    //Here, we want to pick n elements out of 2n from nums such that the absolution difference of the two groups is as close to 0 as possible. If we solve this problem naively, we are facing a 2n choose n time complexity which can be as large as 10^8 when n == 15.  We can apply a trick here to trade space for time. We evenly divide nums into 2 length-n vectors half0 (first half) and half1 (second half). For the first half, we compute all combinations of length 0, 1, ..., n which takes 2^n ops to finish (n*2^n more precisely). For each group, we save these outcomes in a sorted array. We do the same ops for the 2nd half. When we pick cnt numbers from the 2nd half, we need to go to the group corresponding to n-cnt from the 1st half to find the proper partition such that when combing the two the total difference is the closest to 0. This can be achieved by binary search which is the reason why we sort the numbers of each group from the 1st half.\\n    //let s=arraySum, a=partialSumOfArray1, b=remainingSumOfArray1, c=sumOfArray2, where s=(a+b)+c , the goal is to minimize abs((a+b)-c). since c=s-a-b, to eliminate c, we have abs((a+b)-c)=abs(2(a+b)-s)), when abs(...)=0, we have 2(a+b)=s => (a+b)=s/2\\n    //bug1: forgot to sort arr2 after all possible sum has been generated, this mess up with binsearch\\n    //bug2: when calculating abs(total-left-right), I used goal*2, which is not total when total is odd\\n    def minimumDifference(nums: Array[Int]): Int = {\\n         import scala.collection.mutable.{Set,ArrayBuffer} //{} required for importing multiple classes in one statement\\n        var minDiff=java.lang.Long.MAX_VALUE //Long.MaxValue is scala type, use java.lang.Long for MAX_VALUE\\n        val goal:Long=nums.sum.toLong/2\\n        val total=nums.sum.toLong\\n        val arr1,arr2=Array.fill[ArrayBuffer[Long]](nums.length/2+1)(ArrayBuffer[Long]()) //note multiple var declaration in the same line, arr1.eq(arr2)==false and arr1.equals(arr2)==false for Array\\n        def genSum(i:Int=0,e:Int=nums.length/2, sum:Long=0, elems:Int, arr: Array[ArrayBuffer[Long]] ):Unit={\\n            if (i==e)  arr(elems)+=sum  //e is the STOP sign\\n            else {\\n                genSum(i+1, e, sum+nums(i),elems+1, arr)\\n                genSum(i+1, e, sum,elems,arr)\\n            } \\n        }\\n        genSum(0,nums.length/2,0,0,arr1)\\n        genSum(nums.length/2,nums.length,0,0,arr2)\\n        for (ab <-arr2)  ab.sortInPlace\\n        object Bound extends Enumeration {\\n            type Bound=Value\\n            val Lower,Upper=Value\\n        }\\n        import Bound._\\n        //be careful that Array.search(x) does not return lower_bound or upper_bound in Scala, Array(1,2,2,2,3).search(2) returns Found(2), not Found(1)\\n        def binsearch(bucket: Int,t:Long,bound:Bound) = {\\n            arr2(bucket).search(t) match {\\n                case i:scala.collection.Searching.InsertionPoint =>  arr2(bucket)((i.insertionPoint+(if (bound==Upper) 0 else -1)).min(arr2(bucket).length-1).max(0))\\n                case f:scala.collection.Searching.Found =>  arr2(bucket)(f.insertionPoint)\\n            }\\n        }\\n        //println(s\"goal=$goal,minDiff=$minDiff\")\\n        //println(s\"arr1=${arr1.mkString(\",\")}, arr2=${arr2.mkString(\",\")}\")\\n        for (i <- 0 to nums.length/2) { //iterate over a hash Set\\n            val remainder=nums.length/2-i\\n            for (s <- arr1(i)) {\\n                val lower=binsearch(remainder,goal-s,Lower)\\n                val upper=binsearch(remainder,goal-s,Upper)\\n                //bug use math.abs(s+lower-goal*2+s+lower) where goal*2!=total when total%2==1\\n                minDiff=math.min(math.abs(s+lower-total+s+lower).min(math.abs(s+upper-total+s+upper)),minDiff)\\n                //println(s\"trying: i=$i, remainder=$remainder, s=$s,lower=$lower,higher=$upper,s+lower=${s+lower}, s+upper=${s+upper},minDiff=$minDiff\")  \\n            }\\n        }\\n        minDiff.toInt\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    def minimumDifferenceBF(nums: Array[Int]): Int = {\\n        /* thought process\\n        1. we don\\'t know what would be minimum , so let\\'s guess\\n        2. how to guess? try them all\\n        3. how to try? Dynamic Programming with memoization\\n        4. what to memoize? not sure\\n        5. it turns out DP does not work for this problem\\n        6. try brute force then\\n        7. how to make brute force more efficient? divide and conquer?\\n        8. generate all possible sum from 2*N elements is too much , let\\'s try just do N elemens at a time\\n        9. split the array in two equal size, assemble part1 from these two arrays, part2=totalSum-part1\\n        10. our goal is to have part1-part2 -> 0, that is part1==part2, ie part1=totalSum/2 \\n        */\\n        //brute force\\n        import scala.collection.mutable.ArrayBuffer\\n        val chosen=ArrayBuffer[Int]()\\n        var minDiff=Integer.MAX_VALUE\\n        var total:Long=nums.sum.toLong\\n        def helper(items:Int=0,ind: Int=0, sum:Long=0, current:ArrayBuffer[Int]=chosen) :Unit ={\\n            if (ind==nums.length || items==nums.size/2) {\\n                if (items==nums.length/2) {\\n                    minDiff=minDiff.min(math.abs(total-sum-sum).toInt)\\n                    println(s\"found: $sum - ${total-sum}, diff=$minDiff, chosen=$chosen\")\\n                }\\n            }\\n            else if (items<nums.size/2) {\\n               current+=nums(ind)\\n               helper(items+1, ind+1, sum+nums(ind))\\n               current.dropRightInPlace(1)\\n               helper(items, ind+1, sum)\\n            }\\n        }\\n        helper()\\n        minDiff\\n    }\\n    \\n    //Similar and simpler than LC#1755 (Hard) which is the base for this \\n    //Here, we want to pick n elements out of 2n from nums such that the absolution difference of the two groups is as close to 0 as possible. If we solve this problem naively, we are facing a 2n choose n time complexity which can be as large as 10^8 when n == 15.  We can apply a trick here to trade space for time. We evenly divide nums into 2 length-n vectors half0 (first half) and half1 (second half). For the first half, we compute all combinations of length 0, 1, ..., n which takes 2^n ops to finish (n*2^n more precisely). For each group, we save these outcomes in a sorted array. We do the same ops for the 2nd half. When we pick cnt numbers from the 2nd half, we need to go to the group corresponding to n-cnt from the 1st half to find the proper partition such that when combing the two the total difference is the closest to 0. This can be achieved by binary search which is the reason why we sort the numbers of each group from the 1st half.\\n    //let s=arraySum, a=partialSumOfArray1, b=remainingSumOfArray1, c=sumOfArray2, where s=(a+b)+c , the goal is to minimize abs((a+b)-c). since c=s-a-b, to eliminate c, we have abs((a+b)-c)=abs(2(a+b)-s)), when abs(...)=0, we have 2(a+b)=s => (a+b)=s/2\\n    //bug1: forgot to sort arr2 after all possible sum has been generated, this mess up with binsearch\\n    //bug2: when calculating abs(total-left-right), I used goal*2, which is not total when total is odd\\n    def minimumDifference(nums: Array[Int]): Int = {\\n         import scala.collection.mutable.{Set,ArrayBuffer} //{} required for importing multiple classes in one statement\\n        var minDiff=java.lang.Long.MAX_VALUE //Long.MaxValue is scala type, use java.lang.Long for MAX_VALUE\\n        val goal:Long=nums.sum.toLong/2\\n        val total=nums.sum.toLong\\n        val arr1,arr2=Array.fill[ArrayBuffer[Long]](nums.length/2+1)(ArrayBuffer[Long]()) //note multiple var declaration in the same line, arr1.eq(arr2)==false and arr1.equals(arr2)==false for Array\\n        def genSum(i:Int=0,e:Int=nums.length/2, sum:Long=0, elems:Int, arr: Array[ArrayBuffer[Long]] ):Unit={\\n            if (i==e)  arr(elems)+=sum  //e is the STOP sign\\n            else {\\n                genSum(i+1, e, sum+nums(i),elems+1, arr)\\n                genSum(i+1, e, sum,elems,arr)\\n            } \\n        }\\n        genSum(0,nums.length/2,0,0,arr1)\\n        genSum(nums.length/2,nums.length,0,0,arr2)\\n        for (ab <-arr2)  ab.sortInPlace\\n        object Bound extends Enumeration {\\n            type Bound=Value\\n            val Lower,Upper=Value\\n        }\\n        import Bound._\\n        //be careful that Array.search(x) does not return lower_bound or upper_bound in Scala, Array(1,2,2,2,3).search(2) returns Found(2), not Found(1)\\n        def binsearch(bucket: Int,t:Long,bound:Bound) = {\\n            arr2(bucket).search(t) match {\\n                case i:scala.collection.Searching.InsertionPoint =>  arr2(bucket)((i.insertionPoint+(if (bound==Upper) 0 else -1)).min(arr2(bucket).length-1).max(0))\\n                case f:scala.collection.Searching.Found =>  arr2(bucket)(f.insertionPoint)\\n            }\\n        }\\n        //println(s\"goal=$goal,minDiff=$minDiff\")\\n        //println(s\"arr1=${arr1.mkString(\",\")}, arr2=${arr2.mkString(\",\")}\")\\n        for (i <- 0 to nums.length/2) { //iterate over a hash Set\\n            val remainder=nums.length/2-i\\n            for (s <- arr1(i)) {\\n                val lower=binsearch(remainder,goal-s,Lower)\\n                val upper=binsearch(remainder,goal-s,Upper)\\n                //bug use math.abs(s+lower-goal*2+s+lower) where goal*2!=total when total%2==1\\n                minDiff=math.min(math.abs(s+lower-total+s+lower).min(math.abs(s+upper-total+s+upper)),minDiff)\\n                //println(s\"trying: i=$i, remainder=$remainder, s=$s,lower=$lower,higher=$upper,s+lower=${s+lower}, s+upper=${s+upper},minDiff=$minDiff\")  \\n            }\\n        }\\n        minDiff.toInt\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698185,
                "title": "1st-place-in-runtime-210ms-beat-100-java-dfs-sliding-window-of-sorted-sum-matrix",
                "content": "// split nums[] in half at first.\\n    //             Then use DFS to compute all subset_sum of length from 0 to N/2, this roughly takes O(2^N/2) overrall\\n    //             Next sort each generated subset_sum array, there are total 2^N/2 subarrays of each half array, so this takes roughly O((N/2)*log(2^(N/2))) overrall\\n    //             Then use Sliding Window by storing all half_size subarray sums in sorted matrix format ---\\n    //                 --- and choose sub1_sum[k] + sub2_sum[binomial/2 - k] that\\'s closest to target, this takes O(2^(N/2)) overrall\\n    // In conlusion, tc = O((N/2)*log(2^(N/2))), sc = O(max(binomial, N))\\n\\t\\n    static int count;\\n    public int minimumDifference(int[] nums) {    \\n        int N = nums.length;\\n        int total = Arrays.stream(nums).sum();\\n        double target = total/2.0; \\n        int[] sub1 = Arrays.copyOfRange(nums, 0, N/2);\\n        int[] sub2 = Arrays.copyOfRange(nums, N/2, N);\\n        N/=2; \\n        \\n        int binomial = 1;\\n        double global_minDiff = 1e9;\\n        for (int k = 0; k <= N; k++) {\\n            //generate sub1_sums of len k\\n            int[] sub1_sum_k_len = new int[binomial];\\n            dfs(sub1, 0, k, N, 0, sub1_sum_k_len);\\n            Arrays.sort(sub1_sum_k_len);\\n            count = 0; // reset\\n            //generate sub1_sums of len N-k\\n            int[] sub2_sum_k_len = new int[binomial];\\n            dfs(sub2, 0, N-k, N, 0, sub2_sum_k_len);\\n            Arrays.sort(sub2_sum_k_len);\\n            count = 0; // reset\\n            \\n            double min_diff = minDiffToTarget(target, sub1_sum_k_len, sub2_sum_k_len);\\n\\n            if (min_diff == 0) return 0;\\n            \\n            global_minDiff = Math.min(global_minDiff, min_diff);\\n            \\n            binomial = binomial*(N-k)/(k+1);\\n        }\\n        \\n        \\n        return (int) (2 * global_minDiff);\\n    }\\n    \\n    private void dfs(int[] sub, int start, int k, int N, int curr_sum,  int[] res) {\\n        if (k == 0) {\\n            res[count++] = curr_sum;\\n            return;\\n        }\\n        for (int i = start; i <= N-k; i++) \\n            dfs(sub, i+1, k-1, N, curr_sum+sub[i], res);\\n    }\\n    \\n    // both arrays are sorted, a.length == b.length, O(N)\\n    private double minDiffToTarget(double tar, int[] a, int[] b) {\\n        int N = a.length;\\n        if (tar < a[0]+b[0]) return a[0]+b[0]-tar; // tar < smallest\\n        if (tar > a[N-1]+b[N-1]) return tar-a[N-1]-b[N-1]; // tar > largest\\n        \\n        double res = 1e9;\\n        int c = N-1;\\n        for (int r = 0; r < N; r++) {\\n            while (c >= 0 && ((double) a[r] + b[c]) > tar) c--;\\n            if (c >= 0 && ((double) a[r] + b[c]) == tar) return 0;\\n            double firstSmaller = (c < 0) ?  -1e9 : (double) (a[r] + b[c]);\\n            double firstLarger = (c == N-1) ?  1e9 : (double) (a[r] + b[c+1]);\\n\\n            res = Math.min(res, Math.min(tar-firstSmaller, firstLarger-tar));\\n            \\n            if (c < 0) break; // remainings > tar\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "Greedy",
                    "Depth-First Search"
                ],
                "code": "// split nums[] in half at first.\\n    //             Then use DFS to compute all subset_sum of length from 0 to N/2, this roughly takes O(2^N/2) overrall\\n    //             Next sort each generated subset_sum array, there are total 2^N/2 subarrays of each half array, so this takes roughly O((N/2)*log(2^(N/2))) overrall\\n    //             Then use Sliding Window by storing all half_size subarray sums in sorted matrix format ---\\n    //                 --- and choose sub1_sum[k] + sub2_sum[binomial/2 - k] that\\'s closest to target, this takes O(2^(N/2)) overrall\\n    // In conlusion, tc = O((N/2)*log(2^(N/2))), sc = O(max(binomial, N))\\n\\t\\n    static int count;\\n    public int minimumDifference(int[] nums) {    \\n        int N = nums.length;\\n        int total = Arrays.stream(nums).sum();\\n        double target = total/2.0; \\n        int[] sub1 = Arrays.copyOfRange(nums, 0, N/2);\\n        int[] sub2 = Arrays.copyOfRange(nums, N/2, N);\\n        N/=2; \\n        \\n        int binomial = 1;\\n        double global_minDiff = 1e9;\\n        for (int k = 0; k <= N; k++) {\\n            //generate sub1_sums of len k\\n            int[] sub1_sum_k_len = new int[binomial];\\n            dfs(sub1, 0, k, N, 0, sub1_sum_k_len);\\n            Arrays.sort(sub1_sum_k_len);\\n            count = 0; // reset\\n            //generate sub1_sums of len N-k\\n            int[] sub2_sum_k_len = new int[binomial];\\n            dfs(sub2, 0, N-k, N, 0, sub2_sum_k_len);\\n            Arrays.sort(sub2_sum_k_len);\\n            count = 0; // reset\\n            \\n            double min_diff = minDiffToTarget(target, sub1_sum_k_len, sub2_sum_k_len);\\n\\n            if (min_diff == 0) return 0;\\n            \\n            global_minDiff = Math.min(global_minDiff, min_diff);\\n            \\n            binomial = binomial*(N-k)/(k+1);\\n        }\\n        \\n        \\n        return (int) (2 * global_minDiff);\\n    }\\n    \\n    private void dfs(int[] sub, int start, int k, int N, int curr_sum,  int[] res) {\\n        if (k == 0) {\\n            res[count++] = curr_sum;\\n            return;\\n        }\\n        for (int i = start; i <= N-k; i++) \\n            dfs(sub, i+1, k-1, N, curr_sum+sub[i], res);\\n    }\\n    \\n    // both arrays are sorted, a.length == b.length, O(N)\\n    private double minDiffToTarget(double tar, int[] a, int[] b) {\\n        int N = a.length;\\n        if (tar < a[0]+b[0]) return a[0]+b[0]-tar; // tar < smallest\\n        if (tar > a[N-1]+b[N-1]) return tar-a[N-1]-b[N-1]; // tar > largest\\n        \\n        double res = 1e9;\\n        int c = N-1;\\n        for (int r = 0; r < N; r++) {\\n            while (c >= 0 && ((double) a[r] + b[c]) > tar) c--;\\n            if (c >= 0 && ((double) a[r] + b[c]) == tar) return 0;\\n            double firstSmaller = (c < 0) ?  -1e9 : (double) (a[r] + b[c]);\\n            double firstLarger = (c == N-1) ?  1e9 : (double) (a[r] + b[c+1]);\\n\\n            res = Math.min(res, Math.min(tar-firstSmaller, firstLarger-tar));\\n            \\n            if (c < 0) break; // remainings > tar\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2697721,
                "title": "how-to-understand-the-solution",
                "content": "Whatever methods you used to solve the problem, from the mathmatic view all possibles will be iterated, if not there may miss the right answers.\\n\\nIn the tips there mentioned split the numbers to 2 group, actually it splited to 4. Let\\'s explain it by a testCase.\\n```\\nint[] nums = [2,-1,0,4,-2,-9]; // Total numbers is 6\\n// split to 2 group: [2,-1,0] and [4,-2,-9]\\n// let\\'s focus on the left side first.\\n// when left side split to 2 groups  [[-1],[-3,-1,3],[-3,1,3],[1]], be careful, this split isn\\'t equal length, but all possible splits.\\nint[][] lefts =  [[-1],[-3,-1,3],[-3,1,3],[1]];\\n// left\\'s left takes zero element: left_left - left_rigth = 0 - (2 + -1 + 0) = -1\\uFF0Cone combination\\n// left\\'s left takes 1 element, 2 - \\uFF08-1 + 0\\uFF09 = 3\\uFF0C-1 - (2 +0) = -3, 0 - (2 + -1) = 1, 3 combinations\\n// left\\'s left takes 2 elements, 3 combinations.\\n// left\\'s left takes 3 elements\\uFF0C1 combinations.\\n\\n// Do the same to the right side.\\nint[][] rights = [[7],[-11,3,15],[-15,-3,11],[-7]]\\n\\n```\\nNow we have 2 same size 2D arrays.\\n```\\nint[][] lefts  =  [[-1],[-3,-1,3],[-3,1,3],[1]];\\nint[][] rights =  [[7],[-11,3,15],[-15,-3,11],[-7]]\\n```\\nNow we take the **SAME INDEX** from the 2 2D arrays, for the taken two 1D arrays, for the every elements in it to calcualte the diff and find the smallest diff.\\nAs I mentioned at the begining, let\\'s count the all possible combinations, 1x1 + 3 x 3 + 3 x 3 + 1 x 1 = 20\\uFF0Cit\\'s equal to brute force, 6!/(6-3)x!3 = 20, but has more effective ways to compare them.\\n\\n**But why this method is right?**\\n```\\n// initial question:  \\nint diff = sum_left - sum_right;\\n// transform to:\\nint diff = (sum_left_left - sum_left_rigth) - (sum_right_left - sum_right_right);\\n//  then:\\nint diff = (sum_left_left + sum_right_right) - (sum_left_right + sum_right_left);\\n```\\nIt means for every comparity we take exactly half of the numbers to sum.\\n0,3  => 3,0 when left side takes 0, right side takes 3 \\n1,2 =>  2,1 when left side takes 1, right side takes 2\\n2,1 =>  1,2 ...\\n3,0 =>  0,3 ...\\n\\nDo I explain it right?\\n\\n",
                "solutionTags": [],
                "code": "```\\nint[] nums = [2,-1,0,4,-2,-9]; // Total numbers is 6\\n// split to 2 group: [2,-1,0] and [4,-2,-9]\\n// let\\'s focus on the left side first.\\n// when left side split to 2 groups  [[-1],[-3,-1,3],[-3,1,3],[1]], be careful, this split isn\\'t equal length, but all possible splits.\\nint[][] lefts =  [[-1],[-3,-1,3],[-3,1,3],[1]];\\n// left\\'s left takes zero element: left_left - left_rigth = 0 - (2 + -1 + 0) = -1\\uFF0Cone combination\\n// left\\'s left takes 1 element, 2 - \\uFF08-1 + 0\\uFF09 = 3\\uFF0C-1 - (2 +0) = -3, 0 - (2 + -1) = 1, 3 combinations\\n// left\\'s left takes 2 elements, 3 combinations.\\n// left\\'s left takes 3 elements\\uFF0C1 combinations.\\n\\n// Do the same to the right side.\\nint[][] rights = [[7],[-11,3,15],[-15,-3,11],[-7]]\\n\\n```\n```\\nint[][] lefts  =  [[-1],[-3,-1,3],[-3,1,3],[1]];\\nint[][] rights =  [[7],[-11,3,15],[-15,-3,11],[-7]]\\n```\n```\\n// initial question:  \\nint diff = sum_left - sum_right;\\n// transform to:\\nint diff = (sum_left_left - sum_left_rigth) - (sum_right_left - sum_right_right);\\n//  then:\\nint diff = (sum_left_left + sum_right_right) - (sum_left_right + sum_right_left);\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1567126,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 1565471,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 1727230,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 1937780,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 1567678,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 1984355,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 2010153,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 1916739,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 1898605,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 2065737,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 1567126,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 1565471,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 1727230,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 1937780,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 1567678,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 1984355,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 2010153,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 1916739,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 1898605,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 2065737,
                "content": [
                    {
                        "username": "guptakeshav24",
                        "content": "s = [76,8,45,20,74,84,28,1]\\n\\nthis array can be segregated into 2 arrays\\ns1 = [28,20,74,45,1]\\ns2 = [76,8,84]\\n\\nsum(s)  = 336\\nsum(s1) = 168\\nsum(s2) = 168\\n\\ndifference = 0\\n\\nexpected difference = 2"
                    },
                    {
                        "username": "amanmadhukar",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "sj_ism",
                        "content": "Also if difference =2, and we are having element =1 by giving 1 to another array difference can be made = 0"
                    },
                    {
                        "username": "_drigger",
                        "content": "partition should be equal"
                    },
                    {
                        "username": "abheeee309",
                        "content": "Read the question properly. We are asked to divide the array into to equal arrays with minimum absolute difference."
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "equal partition??\\n"
                    },
                    {
                        "username": "user7869CQ",
                        "content": "The partition sizes should be equal. Here you are taking unequal partitions"
                    },
                    {
                        "username": "fate3439",
                        "content": "Basically, we know the standard dfs+backtracking based subset finding algorithm usually runs in `2^n` complexity when the array is of size `n`. In this question, you are allowed to early stop your subset searching when reaching `n/2` elements in the current set, in theory reducing the total cost considerably. \\n\\nHowever, it does not. When picking only `n/2` elements, our runtime complexity should be around `n chose n/2`, this complexity rougly equivalent to `4^(n/2) = 2^n`, based on some simple math in this wikipedia page [Central Binomial](https://en.wikipedia.org/wiki/Central_binomial_coefficient). Therefore, although intuitively we are doing early stopping and ignoring subsets < n/2 size and subsets > n/2 size, we did not gain any boost in terms of complexity, the total run time is still bounded by the central binomial, which is `2^n = 2^30`, and obviously gives TLE. For top voted solutions where you split arrays into half and compute subsets from there, you are always guaranteed a runtime around `2^(n/2) * n = 2^15 * 15 << 2^30`. \\n\\n**Another good remark is that it is essential to speed up the search for optimal right subset when left is fixed**, if you go full stupid by iterating all possible right sets, you will have this complexity of length `k` left set: `(n chose k) * (n chose n - k)`, when you summ this up over k, you are essentially getting `2n chose n = 4^n` complexity again.  To understand why the above holds, considering you are chosing k items from left set and n - k items from right, and you enumerate all k values. This [post](https://math.stackexchange.com/questions/148583/combinatorial-proof-of-summation-of-sum-limits-k-0n-n-choose-k2-2n) is also helpful.\\n\\nWhen using binary search, we are taking `n - k` complexity for every possible left set, and we have `2^n` total number of left sets, so the complexity of finding optimal left,right subset is also bounded by `\\\\sum_{2^n left sets} (n - k) < 2^n * n`. For building the subsets and sorting all len k subsets, the cost is:\\n\\n`\\\\sum_k  (n chose k) log (n chose k) < \\\\sum_k  (n chose k) log(2^n) = n \\\\sum_k (n chose k) = n * 2^n` \\n\\n**Thus the final total complexity is bounded by `n * 2^n` which is much much less than `4^n` from naive subset search.**"
                    },
                    {
                        "username": "hallenstal",
                        "content": "not sure I follow the argument. in principle it is about how many ways you can combine n/2 elements of the set of n. select the combination so that sum(set of n/2) is as close to sum(set n)/2. in my book this would mean n!/(n/2)! possible combinations. "
                    },
                    {
                        "username": "etgulli",
                        "content": "I tried this but I\\'m getting TLE, can you help?\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "martinsumeh95",
                        "content": "even chatGPT COULDN\\'T SOLVE THIS ONE LOL\\n"
                    },
                    {
                        "username": "kartikkankurte",
                        "content": "[@Aqdas_Ali](/Aqdas_Ali) Two Sum easily"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Does it solve anything?\\n"
                    },
                    {
                        "username": "Prasuma",
                        "content": "The testcase `[76,8,45,20,74,84,28,1]` has a solution of `0` but expected minimum is `2`.\\n* 76 + 8 + 84 = 168\\n* 45 + 20 + 74 + 28 + 1 = 168"
                    },
                    {
                        "username": "cbsmct",
                        "content": "They need to be equally sized arrays"
                    },
                    {
                        "username": "hallenstal",
                        "content": "the arrays should be of equal size. yours have length 3 and 5 and thus not equal size."
                    },
                    {
                        "username": "animeshnath",
                        "content": "I also judged by seeing the constraints that we need a Brute force algorithm such as Meet in the middle (as 2 ^ 30 would be exceeding), but what if this comes in the interview. I am trying to understand how can we try to further optimise it. Maybe, can we try DP or greedy? Please advise"
                    },
                    {
                        "username": "etgulli",
                        "content": "Even Meet in the middle is giving TLE, can you help.\\nhttps://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/888467659/"
                    },
                    {
                        "username": "algoacer",
                        "content": "Wasted a ton of time, the dp solution won't work because the question asked to divide the array into two equal halves. Size n and n, so use meet in the middle approach, even the hint given is incorrect here. Upvote this comment comrades.\n\nDp code is: \n\n\nclass Solution {\npublic:\n    int minimumDifference(vector<int>& arr) {\n        int totSum = 0; int n=arr.size();\n        int min_ele=INT_MAX;\n        for (int i = 0; i < n; i++) {\n            min_ele=min(min_ele, arr[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i]+=abs(min_ele);\n        }\n        for (int i = 0; i < n; i++) {\n            totSum+=arr[i];\n        }\n\n\n        vector < vector < bool >> dp(n, vector < bool > (totSum + 1, false));\n\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n\n        if (arr[0] <= totSum)\n            dp[0][arr[0]] = true;\n\n        for (int ind = 1; ind < n; ind++) {\n            for (int target = 1; target <= totSum; target++) {\n\n                bool notTaken = dp[ind - 1][target];\n\n                bool taken = false;\n                if (arr[ind] <= target)\n                    taken = dp[ind - 1][target - arr[ind]];\n\n                dp[ind][target] = notTaken || taken;\n            }\n        }\n\n        int mini = 1e9;\n        for (int i = 0; i <= totSum/2; i++) {\n            if (dp[n - 1][i] == true) {\n            int diff = abs(totSum-i-i);\n            mini = min(mini, diff);\n            }\n        }\n        return mini;\n    }\n};"
                    },
                    {
                        "username": "Bajaj2O",
                        "content": "[@janis__](/janis__) https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/submissions/1044478073/    meet in the middle also giving tle. can you tell whats wrong here.\n\nps: tried 2d vector instead of map and it worked"
                    },
                    {
                        "username": "janis__",
                        "content": "Your DP approach calculates all possible sums for subsets, but the problem requires splitting the array into two equal halves, so consider using a \"meet in the middle\" approach to efficiently handle both halves and find the minimum difference."
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "Hello I am new to DP and somehow stumbled upon this question. I tried solving this question by generating all subsets of N/2 size and storing the sum of all N/2 size subsets in a HashMap<Integer,Integer>[][] dp. I am getting TLE in 134 test case. Can someone explain to me why that is happening?\nHere is the code\n\n https://onlinegdb.com/R4L5gDJrK"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "I\\'m using unordered maps to memoize recurssive solution but still i\\'m getting TLE, so my question is Can we actually solve this question using DP? is it a overlapping subproblems ? or am i missing something here "
                    },
                    {
                        "username": "janis__",
                        "content": "While DP is useful for overlapping subproblems, if you\\'re still getting TLE with memoization, it\\'s possible that the problem\\'s constraints are too large or the problem might not have significant overlapping subproblems, so consider optimizing your approach or exploring non-DP solutions.\\n"
                    },
                    {
                        "username": "evan-dayy",
                        "content": "I have a maybe stupid question, why we don't sort the nums, and then using sliding window to pick n-continous element in the middle (if we get the this, we can get the other half), and always try to find the minimum of the this.half - other.half?\n\n \n `class Solution {\n    public int minimumDifference(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n + 1];\n        Arrays.sort(nums);\n        for(int i = 0; i < n; i ++) {\n            prefix[i + 1] = nums[i] + prefix[i];\n        }\n        int total = prefix[prefix.length - 1];\n        int half = n / 2;\n        int i = 0, j = half;\n        int res = Integer.MAX_VALUE;\n        for( ; half < n + 1; half++, i++){\n            int curr = prefix[half] - prefix[i];\n            res = Math.min(res, Math.abs(total - curr - curr));\n        }\n        return res;\n\n    }\n}`\nAnyone can explain this? Thanks! "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting disrupts the original order, invalidating the equal-sized subset requirement."
                    },
                    {
                        "username": "bfeng9",
                        "content": "counter example: [-9,-5, -1, 0, 5, 9]"
                    },
                    {
                        "username": "biller897",
                        "content": "Can you do Ex. 3 with this approach"
                    },
                    {
                        "username": "chiragqatar",
                        "content": "Why cant you use the same approach as https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1 using DP array for pick and not pick?"
                    }
                ]
            },
            {
                "id": 2063715,
                "content": [
                    {
                        "username": "packle",
                        "content": "python meet in the middle w/ dict TLE, lazy fix is reducing sorting by using bisect.insort() instead of append while generating combinations"
                    },
                    {
                        "username": "percy_98",
                        "content": "Chat GPT 4  fail on this problem  miserably , it is constantly trying to give final answer but it stuck in loop as it is trying to correct with provided test cases  realizing answer is wrong for unit test cases then  it is correcting code and then checking and  failing again. What I can see it is trying to use DP :)   WOW !"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Test cases are written wrongly here. For the following input i.e., \\n[1,2,7,3]\\n\\nMy output is as follows : \\n[1,2,3] , [7]\\nMin Diff = {1}\\n\\nExpected test case output is {3}"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t consider all possible partitions; adjust to evaluate every possible split."
                    },
                    {
                        "username": "hallenstal",
                        "content": "Length of array should equal\\n"
                    },
                    {
                        "username": "guru_1826",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n         int n = nums.size();\\n         int T_sum = 0;\\n         for(int i = 0; i < n; i++){\\n            T_sum += nums[i];\\n         }\\n         \\n         \\n            \\n             vector<vector<bool>> dp(n+1, vector<bool>(T_sum+1, 0));\\n             // return f(n-1, arr, k, dp);\\n                for(int i = 0; i < n+1; i++){\\n                    dp[i][0] = true;\\n                }\\n                \\n                \\n                for(int i = 1; i < n+1; i++){\\n                    for (int j = 1; j < T_sum + 1; j++) {\\n                        int notTake = dp[i - 1][j];\\n                        int take = false;\\n                        if (j - nums[i-1] >= 0)\\n                        take = dp[i - 1][j - nums[i-1]];\\n\\n                        dp[i][j] = take || notTake;\\n                    }\\n                }\\n\\n               int mini = 1e9;\\n                for(int i = 0; i <= (T_sum)/2; i++){\\n                    if(dp[n][i]){\\n                        mini  = min(mini, abs(T_sum - 2*i));\\n                    }\\n                }\\n                return mini;\\n         \\n    }\\n};\\n\\nwhy is this code not working?\\n"
                    },
                    {
                        "username": "liayn15",
                        "content": "Why can\\'t we just sort it and to make a set we take elements from start and end till we have n/2 elements? "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting changes the original order of the array, which violates the problem\\'s constraint of selecting continuous subarrays. By taking elements from start and end post-sorting, you\\'re not ensuring that the selected elements form a continuous subarray in the original array."
                    },
                    {
                        "username": "vivek__khajuria",
                        "content": "Can somebody help me in this problem ?\\n\\nclass Solution {\\npublic:\\n     bool isSubsetSum(vector<int>&arr, int sum, vector<int>&v){\\n   int  n=arr.size();\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<sum/2+1;j++){\\n\\n                 if(j==0){\\n                    dp[i][j]=true;\\n                }\\n\\n                if(i==0){\\n                    dp[i][j]=false;\\n                }\\n\\n               \\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=sum;j++)\\n            {\\n                if(arr[i-1]<=j)\\n                {\\n                    dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n                }\\n                else\\n                dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n         for(int i=0;i<sum/2+1;i++)\\n         {\\n             if(dp[n][i]==1)\\n             v.push_back(i);\\n         }\\n        return 0;\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int>v;\\n        \\n             int n=nums.size(),total=0;\\n         for(int i=0;i<nums.size();i++){\\n            total+=nums[i];\\n         }\\n\\n          if(total==0){\\n            int sum=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]<0)nums[i]=-nums[i];\\n                sum+=nums[i];\\n            }\\n            return sum;\\n          }\\n          if(total<0)return 0;\\n          \\n         \\n      \\n        bool ans=isSubsetSum(nums,total,v);\\n        int mini=INT_MAX;\\n        for(int i=0;i<v.size();i++)\\n         {\\n            if(total-2*v[i]<mini)\\n             mini=total-2*v[i];\\n         }\\n        return mini;\\n    }\\n\\n};"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "bhai what would be sum + 1 it will be greater than your dp size which is not permissible, the maximum permissible space for a data structure in no more than 1e7 "
                    },
                    {
                        "username": "arbaazghameria",
                        "content": "I cant help with the negative values can anyone please help me out? \\n\\nheres my code\\n\\nclass Solution {\\n    boolean[][] dp;\\n    public int minimumDifference(int[] nums) {\\n        int totsum=0;\\n        for(int i:nums){\\n            totsum+=i;\\n        }\\n        SubsetSum(nums,totsum);\\n        int minn=Integer.MAX_VALUE;\\n        for(int i=0;i<dp[0].length/2;i++){\\n            if(dp[nums.length][i]){\\n                minn=Math.min(minn,totsum-(2*(i)));\\n            }\\n            \\n        }\\n        return minn;\\n    }\\n     public void SubsetSum(int[] arr,int target){\\n        dp=new boolean[arr.length+1][target+1];\\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<dp[0].length;j++){\\n                if(j==0){\\n                    dp[i][j]=true;\\n                    continue;\\n                }\\n                if(i==0){\\n                    dp[i][j]=false;\\n                    continue;\\n                }\\n                if(arr[i-1]>j)  dp[i][j]=dp[i-1][j];\\n                else dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "hallenstal",
                        "content": "nums = [n-min(nums) for n in nums] \\nThen all nums>0"
                    },
                    {
                        "username": "Dextr2709",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n\\n        int n= nums.size();\\n        int sum = 0;\\n        for (int i=0; i< n; i++) {\\n            sum += nums[i];\\n        }\\n\\n        int t[n+1][sum+1];\\n\\n        for (int i =0; i<n; i++){\\n            t[i][0] = true;\\n        }\\n\\n        for (int j = 0; j<sum; j++) {\\n            t[0][j] = false;\\n        }\\n\\n        for (int i =1; i<n; i++){\\n            for(int j =1; j<sum; j++){\\n\\n                if(nums[i] <= j) {\\n                    t[i][j] = t[i-1][j-nums[i]] || t[i-1][j];\\n                }\\n\\n                else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n                \\n\\n            }\\n        }\\n\\n        vector<int> v;\\n\\n        for(int j = 0; j<sum; j++){\\n            if (t[n][j]==true){\\n                v.push_back(j);\\n            }\\n        }\\n\\n        int mn = INT_MAX;\\n        for (int i=0; i<v.size(); i++){\\n            mn = min(mn, sum - 2*v[i]);\\n        }\\n\\n        return mn;\\n\\n\\n\\n\\n    }\\n};\\n\\n\\ncan someone help me to figure out the reason why its throwing run-time error. I am relatively new to programming so if someone can spare minute or two to answer it, it will be very helpful."
                    },
                    {
                        "username": "SayanK",
                        "content": "This question includes negative elements in the array. So when you ask for indices j, it might even be negative. for example, [-1, 2, -2] then the sum is -1. So it will give out of bounds error.\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "could it be solve by newton\\'s method f(x)  when sort array nums ?"
                    },
                    {
                        "username": "janis__",
                        "content": "Newton\\'s method is used for finding successively better approximations to the roots of a real-valued function. It\\'s not directly applicable to the problem of finding a minimum difference in a sorted array, as the problem isn\\'t about root-finding."
                    },
                    {
                        "username": "aadarshdixit874",
                        "content": "class Solution {\\n    void FastIO()\\n{\\nios_base::sync_with_stdio(0);\\ncin.tie(0);\\ncout.tie(0);\\n}\\nvoid f(int i,int j,int size,vector<int>part1[],int sum,vector<int>nums){\\n    if(i==j+1) {\\n        part1[size].push_back(sum);\\n        return;\\n    }\\n    f(i+1,j,size+1,part1,sum+nums[i],nums);\\n    f(i+1,j,size,part1,sum,nums);\\n    return;\\n}\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n      int n = (nums.size())/2;\\n      vector<int>part1[n+1];\\n      vector<int>part2[n+1];\\n      int sum =0;\\n     f(0,n-1,0,part1,0,nums);\\n     f(n,2*n -1,0,part2,0,nums);\\n     for(int i=0;i<2*n;i++) {\\n         sum+=nums[i];\\n     } \\n    int temp1 = sum/2;\\n    // cout<<part2[0].size()<<endl;\\n    for(int i=1;i<=n;i++){\\n        sort(part2[i].begin(),part2[i].end());\\n    }\\n\\n    int ans = INT_MAX;\\n    ans=  min(ans,abs(sum-2*(part1[n][0])));\\n       ans=  min(ans,abs(sum-2*(part2[n][0])));\\n\\n    for(int i=1;i<=n;i++){\\n        for(auto &it:part1[i]){\\n            auto it1 = lower_bound(part2[n-i].begin(),part2[n-i].end(),temp1-it);\\n            if(it1!=part2[n-i].end()){\\n                 ans = min(ans,abs(sum-2*((*it1)+it)));\\n            }      \\n        }\\n    }\\n    return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\nwhy this code give tle \\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The code\\'s nested loops and recursive calls cause exponential time complexity, leading to a time limit exceeded (TLE) error on large inputs."
                    }
                ]
            },
            {
                "id": 2058495,
                "content": [
                    {
                        "username": "packle",
                        "content": "python meet in the middle w/ dict TLE, lazy fix is reducing sorting by using bisect.insort() instead of append while generating combinations"
                    },
                    {
                        "username": "percy_98",
                        "content": "Chat GPT 4  fail on this problem  miserably , it is constantly trying to give final answer but it stuck in loop as it is trying to correct with provided test cases  realizing answer is wrong for unit test cases then  it is correcting code and then checking and  failing again. What I can see it is trying to use DP :)   WOW !"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Test cases are written wrongly here. For the following input i.e., \\n[1,2,7,3]\\n\\nMy output is as follows : \\n[1,2,3] , [7]\\nMin Diff = {1}\\n\\nExpected test case output is {3}"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t consider all possible partitions; adjust to evaluate every possible split."
                    },
                    {
                        "username": "hallenstal",
                        "content": "Length of array should equal\\n"
                    },
                    {
                        "username": "guru_1826",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n         int n = nums.size();\\n         int T_sum = 0;\\n         for(int i = 0; i < n; i++){\\n            T_sum += nums[i];\\n         }\\n         \\n         \\n            \\n             vector<vector<bool>> dp(n+1, vector<bool>(T_sum+1, 0));\\n             // return f(n-1, arr, k, dp);\\n                for(int i = 0; i < n+1; i++){\\n                    dp[i][0] = true;\\n                }\\n                \\n                \\n                for(int i = 1; i < n+1; i++){\\n                    for (int j = 1; j < T_sum + 1; j++) {\\n                        int notTake = dp[i - 1][j];\\n                        int take = false;\\n                        if (j - nums[i-1] >= 0)\\n                        take = dp[i - 1][j - nums[i-1]];\\n\\n                        dp[i][j] = take || notTake;\\n                    }\\n                }\\n\\n               int mini = 1e9;\\n                for(int i = 0; i <= (T_sum)/2; i++){\\n                    if(dp[n][i]){\\n                        mini  = min(mini, abs(T_sum - 2*i));\\n                    }\\n                }\\n                return mini;\\n         \\n    }\\n};\\n\\nwhy is this code not working?\\n"
                    },
                    {
                        "username": "liayn15",
                        "content": "Why can\\'t we just sort it and to make a set we take elements from start and end till we have n/2 elements? "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting changes the original order of the array, which violates the problem\\'s constraint of selecting continuous subarrays. By taking elements from start and end post-sorting, you\\'re not ensuring that the selected elements form a continuous subarray in the original array."
                    },
                    {
                        "username": "vivek__khajuria",
                        "content": "Can somebody help me in this problem ?\\n\\nclass Solution {\\npublic:\\n     bool isSubsetSum(vector<int>&arr, int sum, vector<int>&v){\\n   int  n=arr.size();\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<sum/2+1;j++){\\n\\n                 if(j==0){\\n                    dp[i][j]=true;\\n                }\\n\\n                if(i==0){\\n                    dp[i][j]=false;\\n                }\\n\\n               \\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=sum;j++)\\n            {\\n                if(arr[i-1]<=j)\\n                {\\n                    dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n                }\\n                else\\n                dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n         for(int i=0;i<sum/2+1;i++)\\n         {\\n             if(dp[n][i]==1)\\n             v.push_back(i);\\n         }\\n        return 0;\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int>v;\\n        \\n             int n=nums.size(),total=0;\\n         for(int i=0;i<nums.size();i++){\\n            total+=nums[i];\\n         }\\n\\n          if(total==0){\\n            int sum=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]<0)nums[i]=-nums[i];\\n                sum+=nums[i];\\n            }\\n            return sum;\\n          }\\n          if(total<0)return 0;\\n          \\n         \\n      \\n        bool ans=isSubsetSum(nums,total,v);\\n        int mini=INT_MAX;\\n        for(int i=0;i<v.size();i++)\\n         {\\n            if(total-2*v[i]<mini)\\n             mini=total-2*v[i];\\n         }\\n        return mini;\\n    }\\n\\n};"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "bhai what would be sum + 1 it will be greater than your dp size which is not permissible, the maximum permissible space for a data structure in no more than 1e7 "
                    },
                    {
                        "username": "arbaazghameria",
                        "content": "I cant help with the negative values can anyone please help me out? \\n\\nheres my code\\n\\nclass Solution {\\n    boolean[][] dp;\\n    public int minimumDifference(int[] nums) {\\n        int totsum=0;\\n        for(int i:nums){\\n            totsum+=i;\\n        }\\n        SubsetSum(nums,totsum);\\n        int minn=Integer.MAX_VALUE;\\n        for(int i=0;i<dp[0].length/2;i++){\\n            if(dp[nums.length][i]){\\n                minn=Math.min(minn,totsum-(2*(i)));\\n            }\\n            \\n        }\\n        return minn;\\n    }\\n     public void SubsetSum(int[] arr,int target){\\n        dp=new boolean[arr.length+1][target+1];\\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<dp[0].length;j++){\\n                if(j==0){\\n                    dp[i][j]=true;\\n                    continue;\\n                }\\n                if(i==0){\\n                    dp[i][j]=false;\\n                    continue;\\n                }\\n                if(arr[i-1]>j)  dp[i][j]=dp[i-1][j];\\n                else dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "hallenstal",
                        "content": "nums = [n-min(nums) for n in nums] \\nThen all nums>0"
                    },
                    {
                        "username": "Dextr2709",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n\\n        int n= nums.size();\\n        int sum = 0;\\n        for (int i=0; i< n; i++) {\\n            sum += nums[i];\\n        }\\n\\n        int t[n+1][sum+1];\\n\\n        for (int i =0; i<n; i++){\\n            t[i][0] = true;\\n        }\\n\\n        for (int j = 0; j<sum; j++) {\\n            t[0][j] = false;\\n        }\\n\\n        for (int i =1; i<n; i++){\\n            for(int j =1; j<sum; j++){\\n\\n                if(nums[i] <= j) {\\n                    t[i][j] = t[i-1][j-nums[i]] || t[i-1][j];\\n                }\\n\\n                else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n                \\n\\n            }\\n        }\\n\\n        vector<int> v;\\n\\n        for(int j = 0; j<sum; j++){\\n            if (t[n][j]==true){\\n                v.push_back(j);\\n            }\\n        }\\n\\n        int mn = INT_MAX;\\n        for (int i=0; i<v.size(); i++){\\n            mn = min(mn, sum - 2*v[i]);\\n        }\\n\\n        return mn;\\n\\n\\n\\n\\n    }\\n};\\n\\n\\ncan someone help me to figure out the reason why its throwing run-time error. I am relatively new to programming so if someone can spare minute or two to answer it, it will be very helpful."
                    },
                    {
                        "username": "SayanK",
                        "content": "This question includes negative elements in the array. So when you ask for indices j, it might even be negative. for example, [-1, 2, -2] then the sum is -1. So it will give out of bounds error.\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "could it be solve by newton\\'s method f(x)  when sort array nums ?"
                    },
                    {
                        "username": "janis__",
                        "content": "Newton\\'s method is used for finding successively better approximations to the roots of a real-valued function. It\\'s not directly applicable to the problem of finding a minimum difference in a sorted array, as the problem isn\\'t about root-finding."
                    },
                    {
                        "username": "aadarshdixit874",
                        "content": "class Solution {\\n    void FastIO()\\n{\\nios_base::sync_with_stdio(0);\\ncin.tie(0);\\ncout.tie(0);\\n}\\nvoid f(int i,int j,int size,vector<int>part1[],int sum,vector<int>nums){\\n    if(i==j+1) {\\n        part1[size].push_back(sum);\\n        return;\\n    }\\n    f(i+1,j,size+1,part1,sum+nums[i],nums);\\n    f(i+1,j,size,part1,sum,nums);\\n    return;\\n}\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n      int n = (nums.size())/2;\\n      vector<int>part1[n+1];\\n      vector<int>part2[n+1];\\n      int sum =0;\\n     f(0,n-1,0,part1,0,nums);\\n     f(n,2*n -1,0,part2,0,nums);\\n     for(int i=0;i<2*n;i++) {\\n         sum+=nums[i];\\n     } \\n    int temp1 = sum/2;\\n    // cout<<part2[0].size()<<endl;\\n    for(int i=1;i<=n;i++){\\n        sort(part2[i].begin(),part2[i].end());\\n    }\\n\\n    int ans = INT_MAX;\\n    ans=  min(ans,abs(sum-2*(part1[n][0])));\\n       ans=  min(ans,abs(sum-2*(part2[n][0])));\\n\\n    for(int i=1;i<=n;i++){\\n        for(auto &it:part1[i]){\\n            auto it1 = lower_bound(part2[n-i].begin(),part2[n-i].end(),temp1-it);\\n            if(it1!=part2[n-i].end()){\\n                 ans = min(ans,abs(sum-2*((*it1)+it)));\\n            }      \\n        }\\n    }\\n    return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\nwhy this code give tle \\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The code\\'s nested loops and recursive calls cause exponential time complexity, leading to a time limit exceeded (TLE) error on large inputs."
                    }
                ]
            },
            {
                "id": 2010460,
                "content": [
                    {
                        "username": "packle",
                        "content": "python meet in the middle w/ dict TLE, lazy fix is reducing sorting by using bisect.insort() instead of append while generating combinations"
                    },
                    {
                        "username": "percy_98",
                        "content": "Chat GPT 4  fail on this problem  miserably , it is constantly trying to give final answer but it stuck in loop as it is trying to correct with provided test cases  realizing answer is wrong for unit test cases then  it is correcting code and then checking and  failing again. What I can see it is trying to use DP :)   WOW !"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Test cases are written wrongly here. For the following input i.e., \\n[1,2,7,3]\\n\\nMy output is as follows : \\n[1,2,3] , [7]\\nMin Diff = {1}\\n\\nExpected test case output is {3}"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t consider all possible partitions; adjust to evaluate every possible split."
                    },
                    {
                        "username": "hallenstal",
                        "content": "Length of array should equal\\n"
                    },
                    {
                        "username": "guru_1826",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n         int n = nums.size();\\n         int T_sum = 0;\\n         for(int i = 0; i < n; i++){\\n            T_sum += nums[i];\\n         }\\n         \\n         \\n            \\n             vector<vector<bool>> dp(n+1, vector<bool>(T_sum+1, 0));\\n             // return f(n-1, arr, k, dp);\\n                for(int i = 0; i < n+1; i++){\\n                    dp[i][0] = true;\\n                }\\n                \\n                \\n                for(int i = 1; i < n+1; i++){\\n                    for (int j = 1; j < T_sum + 1; j++) {\\n                        int notTake = dp[i - 1][j];\\n                        int take = false;\\n                        if (j - nums[i-1] >= 0)\\n                        take = dp[i - 1][j - nums[i-1]];\\n\\n                        dp[i][j] = take || notTake;\\n                    }\\n                }\\n\\n               int mini = 1e9;\\n                for(int i = 0; i <= (T_sum)/2; i++){\\n                    if(dp[n][i]){\\n                        mini  = min(mini, abs(T_sum - 2*i));\\n                    }\\n                }\\n                return mini;\\n         \\n    }\\n};\\n\\nwhy is this code not working?\\n"
                    },
                    {
                        "username": "liayn15",
                        "content": "Why can\\'t we just sort it and to make a set we take elements from start and end till we have n/2 elements? "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting changes the original order of the array, which violates the problem\\'s constraint of selecting continuous subarrays. By taking elements from start and end post-sorting, you\\'re not ensuring that the selected elements form a continuous subarray in the original array."
                    },
                    {
                        "username": "vivek__khajuria",
                        "content": "Can somebody help me in this problem ?\\n\\nclass Solution {\\npublic:\\n     bool isSubsetSum(vector<int>&arr, int sum, vector<int>&v){\\n   int  n=arr.size();\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<sum/2+1;j++){\\n\\n                 if(j==0){\\n                    dp[i][j]=true;\\n                }\\n\\n                if(i==0){\\n                    dp[i][j]=false;\\n                }\\n\\n               \\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=sum;j++)\\n            {\\n                if(arr[i-1]<=j)\\n                {\\n                    dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n                }\\n                else\\n                dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n         for(int i=0;i<sum/2+1;i++)\\n         {\\n             if(dp[n][i]==1)\\n             v.push_back(i);\\n         }\\n        return 0;\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int>v;\\n        \\n             int n=nums.size(),total=0;\\n         for(int i=0;i<nums.size();i++){\\n            total+=nums[i];\\n         }\\n\\n          if(total==0){\\n            int sum=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]<0)nums[i]=-nums[i];\\n                sum+=nums[i];\\n            }\\n            return sum;\\n          }\\n          if(total<0)return 0;\\n          \\n         \\n      \\n        bool ans=isSubsetSum(nums,total,v);\\n        int mini=INT_MAX;\\n        for(int i=0;i<v.size();i++)\\n         {\\n            if(total-2*v[i]<mini)\\n             mini=total-2*v[i];\\n         }\\n        return mini;\\n    }\\n\\n};"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "bhai what would be sum + 1 it will be greater than your dp size which is not permissible, the maximum permissible space for a data structure in no more than 1e7 "
                    },
                    {
                        "username": "arbaazghameria",
                        "content": "I cant help with the negative values can anyone please help me out? \\n\\nheres my code\\n\\nclass Solution {\\n    boolean[][] dp;\\n    public int minimumDifference(int[] nums) {\\n        int totsum=0;\\n        for(int i:nums){\\n            totsum+=i;\\n        }\\n        SubsetSum(nums,totsum);\\n        int minn=Integer.MAX_VALUE;\\n        for(int i=0;i<dp[0].length/2;i++){\\n            if(dp[nums.length][i]){\\n                minn=Math.min(minn,totsum-(2*(i)));\\n            }\\n            \\n        }\\n        return minn;\\n    }\\n     public void SubsetSum(int[] arr,int target){\\n        dp=new boolean[arr.length+1][target+1];\\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<dp[0].length;j++){\\n                if(j==0){\\n                    dp[i][j]=true;\\n                    continue;\\n                }\\n                if(i==0){\\n                    dp[i][j]=false;\\n                    continue;\\n                }\\n                if(arr[i-1]>j)  dp[i][j]=dp[i-1][j];\\n                else dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "hallenstal",
                        "content": "nums = [n-min(nums) for n in nums] \\nThen all nums>0"
                    },
                    {
                        "username": "Dextr2709",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n\\n        int n= nums.size();\\n        int sum = 0;\\n        for (int i=0; i< n; i++) {\\n            sum += nums[i];\\n        }\\n\\n        int t[n+1][sum+1];\\n\\n        for (int i =0; i<n; i++){\\n            t[i][0] = true;\\n        }\\n\\n        for (int j = 0; j<sum; j++) {\\n            t[0][j] = false;\\n        }\\n\\n        for (int i =1; i<n; i++){\\n            for(int j =1; j<sum; j++){\\n\\n                if(nums[i] <= j) {\\n                    t[i][j] = t[i-1][j-nums[i]] || t[i-1][j];\\n                }\\n\\n                else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n                \\n\\n            }\\n        }\\n\\n        vector<int> v;\\n\\n        for(int j = 0; j<sum; j++){\\n            if (t[n][j]==true){\\n                v.push_back(j);\\n            }\\n        }\\n\\n        int mn = INT_MAX;\\n        for (int i=0; i<v.size(); i++){\\n            mn = min(mn, sum - 2*v[i]);\\n        }\\n\\n        return mn;\\n\\n\\n\\n\\n    }\\n};\\n\\n\\ncan someone help me to figure out the reason why its throwing run-time error. I am relatively new to programming so if someone can spare minute or two to answer it, it will be very helpful."
                    },
                    {
                        "username": "SayanK",
                        "content": "This question includes negative elements in the array. So when you ask for indices j, it might even be negative. for example, [-1, 2, -2] then the sum is -1. So it will give out of bounds error.\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "could it be solve by newton\\'s method f(x)  when sort array nums ?"
                    },
                    {
                        "username": "janis__",
                        "content": "Newton\\'s method is used for finding successively better approximations to the roots of a real-valued function. It\\'s not directly applicable to the problem of finding a minimum difference in a sorted array, as the problem isn\\'t about root-finding."
                    },
                    {
                        "username": "aadarshdixit874",
                        "content": "class Solution {\\n    void FastIO()\\n{\\nios_base::sync_with_stdio(0);\\ncin.tie(0);\\ncout.tie(0);\\n}\\nvoid f(int i,int j,int size,vector<int>part1[],int sum,vector<int>nums){\\n    if(i==j+1) {\\n        part1[size].push_back(sum);\\n        return;\\n    }\\n    f(i+1,j,size+1,part1,sum+nums[i],nums);\\n    f(i+1,j,size,part1,sum,nums);\\n    return;\\n}\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n      int n = (nums.size())/2;\\n      vector<int>part1[n+1];\\n      vector<int>part2[n+1];\\n      int sum =0;\\n     f(0,n-1,0,part1,0,nums);\\n     f(n,2*n -1,0,part2,0,nums);\\n     for(int i=0;i<2*n;i++) {\\n         sum+=nums[i];\\n     } \\n    int temp1 = sum/2;\\n    // cout<<part2[0].size()<<endl;\\n    for(int i=1;i<=n;i++){\\n        sort(part2[i].begin(),part2[i].end());\\n    }\\n\\n    int ans = INT_MAX;\\n    ans=  min(ans,abs(sum-2*(part1[n][0])));\\n       ans=  min(ans,abs(sum-2*(part2[n][0])));\\n\\n    for(int i=1;i<=n;i++){\\n        for(auto &it:part1[i]){\\n            auto it1 = lower_bound(part2[n-i].begin(),part2[n-i].end(),temp1-it);\\n            if(it1!=part2[n-i].end()){\\n                 ans = min(ans,abs(sum-2*((*it1)+it)));\\n            }      \\n        }\\n    }\\n    return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\nwhy this code give tle \\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The code\\'s nested loops and recursive calls cause exponential time complexity, leading to a time limit exceeded (TLE) error on large inputs."
                    }
                ]
            },
            {
                "id": 2005456,
                "content": [
                    {
                        "username": "packle",
                        "content": "python meet in the middle w/ dict TLE, lazy fix is reducing sorting by using bisect.insort() instead of append while generating combinations"
                    },
                    {
                        "username": "percy_98",
                        "content": "Chat GPT 4  fail on this problem  miserably , it is constantly trying to give final answer but it stuck in loop as it is trying to correct with provided test cases  realizing answer is wrong for unit test cases then  it is correcting code and then checking and  failing again. What I can see it is trying to use DP :)   WOW !"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Test cases are written wrongly here. For the following input i.e., \\n[1,2,7,3]\\n\\nMy output is as follows : \\n[1,2,3] , [7]\\nMin Diff = {1}\\n\\nExpected test case output is {3}"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t consider all possible partitions; adjust to evaluate every possible split."
                    },
                    {
                        "username": "hallenstal",
                        "content": "Length of array should equal\\n"
                    },
                    {
                        "username": "guru_1826",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n         int n = nums.size();\\n         int T_sum = 0;\\n         for(int i = 0; i < n; i++){\\n            T_sum += nums[i];\\n         }\\n         \\n         \\n            \\n             vector<vector<bool>> dp(n+1, vector<bool>(T_sum+1, 0));\\n             // return f(n-1, arr, k, dp);\\n                for(int i = 0; i < n+1; i++){\\n                    dp[i][0] = true;\\n                }\\n                \\n                \\n                for(int i = 1; i < n+1; i++){\\n                    for (int j = 1; j < T_sum + 1; j++) {\\n                        int notTake = dp[i - 1][j];\\n                        int take = false;\\n                        if (j - nums[i-1] >= 0)\\n                        take = dp[i - 1][j - nums[i-1]];\\n\\n                        dp[i][j] = take || notTake;\\n                    }\\n                }\\n\\n               int mini = 1e9;\\n                for(int i = 0; i <= (T_sum)/2; i++){\\n                    if(dp[n][i]){\\n                        mini  = min(mini, abs(T_sum - 2*i));\\n                    }\\n                }\\n                return mini;\\n         \\n    }\\n};\\n\\nwhy is this code not working?\\n"
                    },
                    {
                        "username": "liayn15",
                        "content": "Why can\\'t we just sort it and to make a set we take elements from start and end till we have n/2 elements? "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting changes the original order of the array, which violates the problem\\'s constraint of selecting continuous subarrays. By taking elements from start and end post-sorting, you\\'re not ensuring that the selected elements form a continuous subarray in the original array."
                    },
                    {
                        "username": "vivek__khajuria",
                        "content": "Can somebody help me in this problem ?\\n\\nclass Solution {\\npublic:\\n     bool isSubsetSum(vector<int>&arr, int sum, vector<int>&v){\\n   int  n=arr.size();\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<sum/2+1;j++){\\n\\n                 if(j==0){\\n                    dp[i][j]=true;\\n                }\\n\\n                if(i==0){\\n                    dp[i][j]=false;\\n                }\\n\\n               \\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=sum;j++)\\n            {\\n                if(arr[i-1]<=j)\\n                {\\n                    dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n                }\\n                else\\n                dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n         for(int i=0;i<sum/2+1;i++)\\n         {\\n             if(dp[n][i]==1)\\n             v.push_back(i);\\n         }\\n        return 0;\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int>v;\\n        \\n             int n=nums.size(),total=0;\\n         for(int i=0;i<nums.size();i++){\\n            total+=nums[i];\\n         }\\n\\n          if(total==0){\\n            int sum=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]<0)nums[i]=-nums[i];\\n                sum+=nums[i];\\n            }\\n            return sum;\\n          }\\n          if(total<0)return 0;\\n          \\n         \\n      \\n        bool ans=isSubsetSum(nums,total,v);\\n        int mini=INT_MAX;\\n        for(int i=0;i<v.size();i++)\\n         {\\n            if(total-2*v[i]<mini)\\n             mini=total-2*v[i];\\n         }\\n        return mini;\\n    }\\n\\n};"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "bhai what would be sum + 1 it will be greater than your dp size which is not permissible, the maximum permissible space for a data structure in no more than 1e7 "
                    },
                    {
                        "username": "arbaazghameria",
                        "content": "I cant help with the negative values can anyone please help me out? \\n\\nheres my code\\n\\nclass Solution {\\n    boolean[][] dp;\\n    public int minimumDifference(int[] nums) {\\n        int totsum=0;\\n        for(int i:nums){\\n            totsum+=i;\\n        }\\n        SubsetSum(nums,totsum);\\n        int minn=Integer.MAX_VALUE;\\n        for(int i=0;i<dp[0].length/2;i++){\\n            if(dp[nums.length][i]){\\n                minn=Math.min(minn,totsum-(2*(i)));\\n            }\\n            \\n        }\\n        return minn;\\n    }\\n     public void SubsetSum(int[] arr,int target){\\n        dp=new boolean[arr.length+1][target+1];\\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<dp[0].length;j++){\\n                if(j==0){\\n                    dp[i][j]=true;\\n                    continue;\\n                }\\n                if(i==0){\\n                    dp[i][j]=false;\\n                    continue;\\n                }\\n                if(arr[i-1]>j)  dp[i][j]=dp[i-1][j];\\n                else dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "hallenstal",
                        "content": "nums = [n-min(nums) for n in nums] \\nThen all nums>0"
                    },
                    {
                        "username": "Dextr2709",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n\\n        int n= nums.size();\\n        int sum = 0;\\n        for (int i=0; i< n; i++) {\\n            sum += nums[i];\\n        }\\n\\n        int t[n+1][sum+1];\\n\\n        for (int i =0; i<n; i++){\\n            t[i][0] = true;\\n        }\\n\\n        for (int j = 0; j<sum; j++) {\\n            t[0][j] = false;\\n        }\\n\\n        for (int i =1; i<n; i++){\\n            for(int j =1; j<sum; j++){\\n\\n                if(nums[i] <= j) {\\n                    t[i][j] = t[i-1][j-nums[i]] || t[i-1][j];\\n                }\\n\\n                else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n                \\n\\n            }\\n        }\\n\\n        vector<int> v;\\n\\n        for(int j = 0; j<sum; j++){\\n            if (t[n][j]==true){\\n                v.push_back(j);\\n            }\\n        }\\n\\n        int mn = INT_MAX;\\n        for (int i=0; i<v.size(); i++){\\n            mn = min(mn, sum - 2*v[i]);\\n        }\\n\\n        return mn;\\n\\n\\n\\n\\n    }\\n};\\n\\n\\ncan someone help me to figure out the reason why its throwing run-time error. I am relatively new to programming so if someone can spare minute or two to answer it, it will be very helpful."
                    },
                    {
                        "username": "SayanK",
                        "content": "This question includes negative elements in the array. So when you ask for indices j, it might even be negative. for example, [-1, 2, -2] then the sum is -1. So it will give out of bounds error.\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "could it be solve by newton\\'s method f(x)  when sort array nums ?"
                    },
                    {
                        "username": "janis__",
                        "content": "Newton\\'s method is used for finding successively better approximations to the roots of a real-valued function. It\\'s not directly applicable to the problem of finding a minimum difference in a sorted array, as the problem isn\\'t about root-finding."
                    },
                    {
                        "username": "aadarshdixit874",
                        "content": "class Solution {\\n    void FastIO()\\n{\\nios_base::sync_with_stdio(0);\\ncin.tie(0);\\ncout.tie(0);\\n}\\nvoid f(int i,int j,int size,vector<int>part1[],int sum,vector<int>nums){\\n    if(i==j+1) {\\n        part1[size].push_back(sum);\\n        return;\\n    }\\n    f(i+1,j,size+1,part1,sum+nums[i],nums);\\n    f(i+1,j,size,part1,sum,nums);\\n    return;\\n}\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n      int n = (nums.size())/2;\\n      vector<int>part1[n+1];\\n      vector<int>part2[n+1];\\n      int sum =0;\\n     f(0,n-1,0,part1,0,nums);\\n     f(n,2*n -1,0,part2,0,nums);\\n     for(int i=0;i<2*n;i++) {\\n         sum+=nums[i];\\n     } \\n    int temp1 = sum/2;\\n    // cout<<part2[0].size()<<endl;\\n    for(int i=1;i<=n;i++){\\n        sort(part2[i].begin(),part2[i].end());\\n    }\\n\\n    int ans = INT_MAX;\\n    ans=  min(ans,abs(sum-2*(part1[n][0])));\\n       ans=  min(ans,abs(sum-2*(part2[n][0])));\\n\\n    for(int i=1;i<=n;i++){\\n        for(auto &it:part1[i]){\\n            auto it1 = lower_bound(part2[n-i].begin(),part2[n-i].end(),temp1-it);\\n            if(it1!=part2[n-i].end()){\\n                 ans = min(ans,abs(sum-2*((*it1)+it)));\\n            }      \\n        }\\n    }\\n    return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\nwhy this code give tle \\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The code\\'s nested loops and recursive calls cause exponential time complexity, leading to a time limit exceeded (TLE) error on large inputs."
                    }
                ]
            },
            {
                "id": 1996777,
                "content": [
                    {
                        "username": "packle",
                        "content": "python meet in the middle w/ dict TLE, lazy fix is reducing sorting by using bisect.insort() instead of append while generating combinations"
                    },
                    {
                        "username": "percy_98",
                        "content": "Chat GPT 4  fail on this problem  miserably , it is constantly trying to give final answer but it stuck in loop as it is trying to correct with provided test cases  realizing answer is wrong for unit test cases then  it is correcting code and then checking and  failing again. What I can see it is trying to use DP :)   WOW !"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Test cases are written wrongly here. For the following input i.e., \\n[1,2,7,3]\\n\\nMy output is as follows : \\n[1,2,3] , [7]\\nMin Diff = {1}\\n\\nExpected test case output is {3}"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t consider all possible partitions; adjust to evaluate every possible split."
                    },
                    {
                        "username": "hallenstal",
                        "content": "Length of array should equal\\n"
                    },
                    {
                        "username": "guru_1826",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n         int n = nums.size();\\n         int T_sum = 0;\\n         for(int i = 0; i < n; i++){\\n            T_sum += nums[i];\\n         }\\n         \\n         \\n            \\n             vector<vector<bool>> dp(n+1, vector<bool>(T_sum+1, 0));\\n             // return f(n-1, arr, k, dp);\\n                for(int i = 0; i < n+1; i++){\\n                    dp[i][0] = true;\\n                }\\n                \\n                \\n                for(int i = 1; i < n+1; i++){\\n                    for (int j = 1; j < T_sum + 1; j++) {\\n                        int notTake = dp[i - 1][j];\\n                        int take = false;\\n                        if (j - nums[i-1] >= 0)\\n                        take = dp[i - 1][j - nums[i-1]];\\n\\n                        dp[i][j] = take || notTake;\\n                    }\\n                }\\n\\n               int mini = 1e9;\\n                for(int i = 0; i <= (T_sum)/2; i++){\\n                    if(dp[n][i]){\\n                        mini  = min(mini, abs(T_sum - 2*i));\\n                    }\\n                }\\n                return mini;\\n         \\n    }\\n};\\n\\nwhy is this code not working?\\n"
                    },
                    {
                        "username": "liayn15",
                        "content": "Why can\\'t we just sort it and to make a set we take elements from start and end till we have n/2 elements? "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting changes the original order of the array, which violates the problem\\'s constraint of selecting continuous subarrays. By taking elements from start and end post-sorting, you\\'re not ensuring that the selected elements form a continuous subarray in the original array."
                    },
                    {
                        "username": "vivek__khajuria",
                        "content": "Can somebody help me in this problem ?\\n\\nclass Solution {\\npublic:\\n     bool isSubsetSum(vector<int>&arr, int sum, vector<int>&v){\\n   int  n=arr.size();\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<sum/2+1;j++){\\n\\n                 if(j==0){\\n                    dp[i][j]=true;\\n                }\\n\\n                if(i==0){\\n                    dp[i][j]=false;\\n                }\\n\\n               \\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=sum;j++)\\n            {\\n                if(arr[i-1]<=j)\\n                {\\n                    dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n                }\\n                else\\n                dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n         for(int i=0;i<sum/2+1;i++)\\n         {\\n             if(dp[n][i]==1)\\n             v.push_back(i);\\n         }\\n        return 0;\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int>v;\\n        \\n             int n=nums.size(),total=0;\\n         for(int i=0;i<nums.size();i++){\\n            total+=nums[i];\\n         }\\n\\n          if(total==0){\\n            int sum=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]<0)nums[i]=-nums[i];\\n                sum+=nums[i];\\n            }\\n            return sum;\\n          }\\n          if(total<0)return 0;\\n          \\n         \\n      \\n        bool ans=isSubsetSum(nums,total,v);\\n        int mini=INT_MAX;\\n        for(int i=0;i<v.size();i++)\\n         {\\n            if(total-2*v[i]<mini)\\n             mini=total-2*v[i];\\n         }\\n        return mini;\\n    }\\n\\n};"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "bhai what would be sum + 1 it will be greater than your dp size which is not permissible, the maximum permissible space for a data structure in no more than 1e7 "
                    },
                    {
                        "username": "arbaazghameria",
                        "content": "I cant help with the negative values can anyone please help me out? \\n\\nheres my code\\n\\nclass Solution {\\n    boolean[][] dp;\\n    public int minimumDifference(int[] nums) {\\n        int totsum=0;\\n        for(int i:nums){\\n            totsum+=i;\\n        }\\n        SubsetSum(nums,totsum);\\n        int minn=Integer.MAX_VALUE;\\n        for(int i=0;i<dp[0].length/2;i++){\\n            if(dp[nums.length][i]){\\n                minn=Math.min(minn,totsum-(2*(i)));\\n            }\\n            \\n        }\\n        return minn;\\n    }\\n     public void SubsetSum(int[] arr,int target){\\n        dp=new boolean[arr.length+1][target+1];\\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<dp[0].length;j++){\\n                if(j==0){\\n                    dp[i][j]=true;\\n                    continue;\\n                }\\n                if(i==0){\\n                    dp[i][j]=false;\\n                    continue;\\n                }\\n                if(arr[i-1]>j)  dp[i][j]=dp[i-1][j];\\n                else dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "hallenstal",
                        "content": "nums = [n-min(nums) for n in nums] \\nThen all nums>0"
                    },
                    {
                        "username": "Dextr2709",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n\\n        int n= nums.size();\\n        int sum = 0;\\n        for (int i=0; i< n; i++) {\\n            sum += nums[i];\\n        }\\n\\n        int t[n+1][sum+1];\\n\\n        for (int i =0; i<n; i++){\\n            t[i][0] = true;\\n        }\\n\\n        for (int j = 0; j<sum; j++) {\\n            t[0][j] = false;\\n        }\\n\\n        for (int i =1; i<n; i++){\\n            for(int j =1; j<sum; j++){\\n\\n                if(nums[i] <= j) {\\n                    t[i][j] = t[i-1][j-nums[i]] || t[i-1][j];\\n                }\\n\\n                else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n                \\n\\n            }\\n        }\\n\\n        vector<int> v;\\n\\n        for(int j = 0; j<sum; j++){\\n            if (t[n][j]==true){\\n                v.push_back(j);\\n            }\\n        }\\n\\n        int mn = INT_MAX;\\n        for (int i=0; i<v.size(); i++){\\n            mn = min(mn, sum - 2*v[i]);\\n        }\\n\\n        return mn;\\n\\n\\n\\n\\n    }\\n};\\n\\n\\ncan someone help me to figure out the reason why its throwing run-time error. I am relatively new to programming so if someone can spare minute or two to answer it, it will be very helpful."
                    },
                    {
                        "username": "SayanK",
                        "content": "This question includes negative elements in the array. So when you ask for indices j, it might even be negative. for example, [-1, 2, -2] then the sum is -1. So it will give out of bounds error.\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "could it be solve by newton\\'s method f(x)  when sort array nums ?"
                    },
                    {
                        "username": "janis__",
                        "content": "Newton\\'s method is used for finding successively better approximations to the roots of a real-valued function. It\\'s not directly applicable to the problem of finding a minimum difference in a sorted array, as the problem isn\\'t about root-finding."
                    },
                    {
                        "username": "aadarshdixit874",
                        "content": "class Solution {\\n    void FastIO()\\n{\\nios_base::sync_with_stdio(0);\\ncin.tie(0);\\ncout.tie(0);\\n}\\nvoid f(int i,int j,int size,vector<int>part1[],int sum,vector<int>nums){\\n    if(i==j+1) {\\n        part1[size].push_back(sum);\\n        return;\\n    }\\n    f(i+1,j,size+1,part1,sum+nums[i],nums);\\n    f(i+1,j,size,part1,sum,nums);\\n    return;\\n}\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n      int n = (nums.size())/2;\\n      vector<int>part1[n+1];\\n      vector<int>part2[n+1];\\n      int sum =0;\\n     f(0,n-1,0,part1,0,nums);\\n     f(n,2*n -1,0,part2,0,nums);\\n     for(int i=0;i<2*n;i++) {\\n         sum+=nums[i];\\n     } \\n    int temp1 = sum/2;\\n    // cout<<part2[0].size()<<endl;\\n    for(int i=1;i<=n;i++){\\n        sort(part2[i].begin(),part2[i].end());\\n    }\\n\\n    int ans = INT_MAX;\\n    ans=  min(ans,abs(sum-2*(part1[n][0])));\\n       ans=  min(ans,abs(sum-2*(part2[n][0])));\\n\\n    for(int i=1;i<=n;i++){\\n        for(auto &it:part1[i]){\\n            auto it1 = lower_bound(part2[n-i].begin(),part2[n-i].end(),temp1-it);\\n            if(it1!=part2[n-i].end()){\\n                 ans = min(ans,abs(sum-2*((*it1)+it)));\\n            }      \\n        }\\n    }\\n    return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\nwhy this code give tle \\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The code\\'s nested loops and recursive calls cause exponential time complexity, leading to a time limit exceeded (TLE) error on large inputs."
                    }
                ]
            },
            {
                "id": 1965451,
                "content": [
                    {
                        "username": "packle",
                        "content": "python meet in the middle w/ dict TLE, lazy fix is reducing sorting by using bisect.insort() instead of append while generating combinations"
                    },
                    {
                        "username": "percy_98",
                        "content": "Chat GPT 4  fail on this problem  miserably , it is constantly trying to give final answer but it stuck in loop as it is trying to correct with provided test cases  realizing answer is wrong for unit test cases then  it is correcting code and then checking and  failing again. What I can see it is trying to use DP :)   WOW !"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Test cases are written wrongly here. For the following input i.e., \\n[1,2,7,3]\\n\\nMy output is as follows : \\n[1,2,3] , [7]\\nMin Diff = {1}\\n\\nExpected test case output is {3}"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t consider all possible partitions; adjust to evaluate every possible split."
                    },
                    {
                        "username": "hallenstal",
                        "content": "Length of array should equal\\n"
                    },
                    {
                        "username": "guru_1826",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n         int n = nums.size();\\n         int T_sum = 0;\\n         for(int i = 0; i < n; i++){\\n            T_sum += nums[i];\\n         }\\n         \\n         \\n            \\n             vector<vector<bool>> dp(n+1, vector<bool>(T_sum+1, 0));\\n             // return f(n-1, arr, k, dp);\\n                for(int i = 0; i < n+1; i++){\\n                    dp[i][0] = true;\\n                }\\n                \\n                \\n                for(int i = 1; i < n+1; i++){\\n                    for (int j = 1; j < T_sum + 1; j++) {\\n                        int notTake = dp[i - 1][j];\\n                        int take = false;\\n                        if (j - nums[i-1] >= 0)\\n                        take = dp[i - 1][j - nums[i-1]];\\n\\n                        dp[i][j] = take || notTake;\\n                    }\\n                }\\n\\n               int mini = 1e9;\\n                for(int i = 0; i <= (T_sum)/2; i++){\\n                    if(dp[n][i]){\\n                        mini  = min(mini, abs(T_sum - 2*i));\\n                    }\\n                }\\n                return mini;\\n         \\n    }\\n};\\n\\nwhy is this code not working?\\n"
                    },
                    {
                        "username": "liayn15",
                        "content": "Why can\\'t we just sort it and to make a set we take elements from start and end till we have n/2 elements? "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting changes the original order of the array, which violates the problem\\'s constraint of selecting continuous subarrays. By taking elements from start and end post-sorting, you\\'re not ensuring that the selected elements form a continuous subarray in the original array."
                    },
                    {
                        "username": "vivek__khajuria",
                        "content": "Can somebody help me in this problem ?\\n\\nclass Solution {\\npublic:\\n     bool isSubsetSum(vector<int>&arr, int sum, vector<int>&v){\\n   int  n=arr.size();\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<sum/2+1;j++){\\n\\n                 if(j==0){\\n                    dp[i][j]=true;\\n                }\\n\\n                if(i==0){\\n                    dp[i][j]=false;\\n                }\\n\\n               \\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=sum;j++)\\n            {\\n                if(arr[i-1]<=j)\\n                {\\n                    dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n                }\\n                else\\n                dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n         for(int i=0;i<sum/2+1;i++)\\n         {\\n             if(dp[n][i]==1)\\n             v.push_back(i);\\n         }\\n        return 0;\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int>v;\\n        \\n             int n=nums.size(),total=0;\\n         for(int i=0;i<nums.size();i++){\\n            total+=nums[i];\\n         }\\n\\n          if(total==0){\\n            int sum=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]<0)nums[i]=-nums[i];\\n                sum+=nums[i];\\n            }\\n            return sum;\\n          }\\n          if(total<0)return 0;\\n          \\n         \\n      \\n        bool ans=isSubsetSum(nums,total,v);\\n        int mini=INT_MAX;\\n        for(int i=0;i<v.size();i++)\\n         {\\n            if(total-2*v[i]<mini)\\n             mini=total-2*v[i];\\n         }\\n        return mini;\\n    }\\n\\n};"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "bhai what would be sum + 1 it will be greater than your dp size which is not permissible, the maximum permissible space for a data structure in no more than 1e7 "
                    },
                    {
                        "username": "arbaazghameria",
                        "content": "I cant help with the negative values can anyone please help me out? \\n\\nheres my code\\n\\nclass Solution {\\n    boolean[][] dp;\\n    public int minimumDifference(int[] nums) {\\n        int totsum=0;\\n        for(int i:nums){\\n            totsum+=i;\\n        }\\n        SubsetSum(nums,totsum);\\n        int minn=Integer.MAX_VALUE;\\n        for(int i=0;i<dp[0].length/2;i++){\\n            if(dp[nums.length][i]){\\n                minn=Math.min(minn,totsum-(2*(i)));\\n            }\\n            \\n        }\\n        return minn;\\n    }\\n     public void SubsetSum(int[] arr,int target){\\n        dp=new boolean[arr.length+1][target+1];\\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<dp[0].length;j++){\\n                if(j==0){\\n                    dp[i][j]=true;\\n                    continue;\\n                }\\n                if(i==0){\\n                    dp[i][j]=false;\\n                    continue;\\n                }\\n                if(arr[i-1]>j)  dp[i][j]=dp[i-1][j];\\n                else dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "hallenstal",
                        "content": "nums = [n-min(nums) for n in nums] \\nThen all nums>0"
                    },
                    {
                        "username": "Dextr2709",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n\\n        int n= nums.size();\\n        int sum = 0;\\n        for (int i=0; i< n; i++) {\\n            sum += nums[i];\\n        }\\n\\n        int t[n+1][sum+1];\\n\\n        for (int i =0; i<n; i++){\\n            t[i][0] = true;\\n        }\\n\\n        for (int j = 0; j<sum; j++) {\\n            t[0][j] = false;\\n        }\\n\\n        for (int i =1; i<n; i++){\\n            for(int j =1; j<sum; j++){\\n\\n                if(nums[i] <= j) {\\n                    t[i][j] = t[i-1][j-nums[i]] || t[i-1][j];\\n                }\\n\\n                else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n                \\n\\n            }\\n        }\\n\\n        vector<int> v;\\n\\n        for(int j = 0; j<sum; j++){\\n            if (t[n][j]==true){\\n                v.push_back(j);\\n            }\\n        }\\n\\n        int mn = INT_MAX;\\n        for (int i=0; i<v.size(); i++){\\n            mn = min(mn, sum - 2*v[i]);\\n        }\\n\\n        return mn;\\n\\n\\n\\n\\n    }\\n};\\n\\n\\ncan someone help me to figure out the reason why its throwing run-time error. I am relatively new to programming so if someone can spare minute or two to answer it, it will be very helpful."
                    },
                    {
                        "username": "SayanK",
                        "content": "This question includes negative elements in the array. So when you ask for indices j, it might even be negative. for example, [-1, 2, -2] then the sum is -1. So it will give out of bounds error.\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "could it be solve by newton\\'s method f(x)  when sort array nums ?"
                    },
                    {
                        "username": "janis__",
                        "content": "Newton\\'s method is used for finding successively better approximations to the roots of a real-valued function. It\\'s not directly applicable to the problem of finding a minimum difference in a sorted array, as the problem isn\\'t about root-finding."
                    },
                    {
                        "username": "aadarshdixit874",
                        "content": "class Solution {\\n    void FastIO()\\n{\\nios_base::sync_with_stdio(0);\\ncin.tie(0);\\ncout.tie(0);\\n}\\nvoid f(int i,int j,int size,vector<int>part1[],int sum,vector<int>nums){\\n    if(i==j+1) {\\n        part1[size].push_back(sum);\\n        return;\\n    }\\n    f(i+1,j,size+1,part1,sum+nums[i],nums);\\n    f(i+1,j,size,part1,sum,nums);\\n    return;\\n}\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n      int n = (nums.size())/2;\\n      vector<int>part1[n+1];\\n      vector<int>part2[n+1];\\n      int sum =0;\\n     f(0,n-1,0,part1,0,nums);\\n     f(n,2*n -1,0,part2,0,nums);\\n     for(int i=0;i<2*n;i++) {\\n         sum+=nums[i];\\n     } \\n    int temp1 = sum/2;\\n    // cout<<part2[0].size()<<endl;\\n    for(int i=1;i<=n;i++){\\n        sort(part2[i].begin(),part2[i].end());\\n    }\\n\\n    int ans = INT_MAX;\\n    ans=  min(ans,abs(sum-2*(part1[n][0])));\\n       ans=  min(ans,abs(sum-2*(part2[n][0])));\\n\\n    for(int i=1;i<=n;i++){\\n        for(auto &it:part1[i]){\\n            auto it1 = lower_bound(part2[n-i].begin(),part2[n-i].end(),temp1-it);\\n            if(it1!=part2[n-i].end()){\\n                 ans = min(ans,abs(sum-2*((*it1)+it)));\\n            }      \\n        }\\n    }\\n    return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\nwhy this code give tle \\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The code\\'s nested loops and recursive calls cause exponential time complexity, leading to a time limit exceeded (TLE) error on large inputs."
                    }
                ]
            },
            {
                "id": 1964842,
                "content": [
                    {
                        "username": "packle",
                        "content": "python meet in the middle w/ dict TLE, lazy fix is reducing sorting by using bisect.insort() instead of append while generating combinations"
                    },
                    {
                        "username": "percy_98",
                        "content": "Chat GPT 4  fail on this problem  miserably , it is constantly trying to give final answer but it stuck in loop as it is trying to correct with provided test cases  realizing answer is wrong for unit test cases then  it is correcting code and then checking and  failing again. What I can see it is trying to use DP :)   WOW !"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Test cases are written wrongly here. For the following input i.e., \\n[1,2,7,3]\\n\\nMy output is as follows : \\n[1,2,3] , [7]\\nMin Diff = {1}\\n\\nExpected test case output is {3}"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t consider all possible partitions; adjust to evaluate every possible split."
                    },
                    {
                        "username": "hallenstal",
                        "content": "Length of array should equal\\n"
                    },
                    {
                        "username": "guru_1826",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n         int n = nums.size();\\n         int T_sum = 0;\\n         for(int i = 0; i < n; i++){\\n            T_sum += nums[i];\\n         }\\n         \\n         \\n            \\n             vector<vector<bool>> dp(n+1, vector<bool>(T_sum+1, 0));\\n             // return f(n-1, arr, k, dp);\\n                for(int i = 0; i < n+1; i++){\\n                    dp[i][0] = true;\\n                }\\n                \\n                \\n                for(int i = 1; i < n+1; i++){\\n                    for (int j = 1; j < T_sum + 1; j++) {\\n                        int notTake = dp[i - 1][j];\\n                        int take = false;\\n                        if (j - nums[i-1] >= 0)\\n                        take = dp[i - 1][j - nums[i-1]];\\n\\n                        dp[i][j] = take || notTake;\\n                    }\\n                }\\n\\n               int mini = 1e9;\\n                for(int i = 0; i <= (T_sum)/2; i++){\\n                    if(dp[n][i]){\\n                        mini  = min(mini, abs(T_sum - 2*i));\\n                    }\\n                }\\n                return mini;\\n         \\n    }\\n};\\n\\nwhy is this code not working?\\n"
                    },
                    {
                        "username": "liayn15",
                        "content": "Why can\\'t we just sort it and to make a set we take elements from start and end till we have n/2 elements? "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting changes the original order of the array, which violates the problem\\'s constraint of selecting continuous subarrays. By taking elements from start and end post-sorting, you\\'re not ensuring that the selected elements form a continuous subarray in the original array."
                    },
                    {
                        "username": "vivek__khajuria",
                        "content": "Can somebody help me in this problem ?\\n\\nclass Solution {\\npublic:\\n     bool isSubsetSum(vector<int>&arr, int sum, vector<int>&v){\\n   int  n=arr.size();\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<sum/2+1;j++){\\n\\n                 if(j==0){\\n                    dp[i][j]=true;\\n                }\\n\\n                if(i==0){\\n                    dp[i][j]=false;\\n                }\\n\\n               \\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=sum;j++)\\n            {\\n                if(arr[i-1]<=j)\\n                {\\n                    dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n                }\\n                else\\n                dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n         for(int i=0;i<sum/2+1;i++)\\n         {\\n             if(dp[n][i]==1)\\n             v.push_back(i);\\n         }\\n        return 0;\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int>v;\\n        \\n             int n=nums.size(),total=0;\\n         for(int i=0;i<nums.size();i++){\\n            total+=nums[i];\\n         }\\n\\n          if(total==0){\\n            int sum=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]<0)nums[i]=-nums[i];\\n                sum+=nums[i];\\n            }\\n            return sum;\\n          }\\n          if(total<0)return 0;\\n          \\n         \\n      \\n        bool ans=isSubsetSum(nums,total,v);\\n        int mini=INT_MAX;\\n        for(int i=0;i<v.size();i++)\\n         {\\n            if(total-2*v[i]<mini)\\n             mini=total-2*v[i];\\n         }\\n        return mini;\\n    }\\n\\n};"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "bhai what would be sum + 1 it will be greater than your dp size which is not permissible, the maximum permissible space for a data structure in no more than 1e7 "
                    },
                    {
                        "username": "arbaazghameria",
                        "content": "I cant help with the negative values can anyone please help me out? \\n\\nheres my code\\n\\nclass Solution {\\n    boolean[][] dp;\\n    public int minimumDifference(int[] nums) {\\n        int totsum=0;\\n        for(int i:nums){\\n            totsum+=i;\\n        }\\n        SubsetSum(nums,totsum);\\n        int minn=Integer.MAX_VALUE;\\n        for(int i=0;i<dp[0].length/2;i++){\\n            if(dp[nums.length][i]){\\n                minn=Math.min(minn,totsum-(2*(i)));\\n            }\\n            \\n        }\\n        return minn;\\n    }\\n     public void SubsetSum(int[] arr,int target){\\n        dp=new boolean[arr.length+1][target+1];\\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<dp[0].length;j++){\\n                if(j==0){\\n                    dp[i][j]=true;\\n                    continue;\\n                }\\n                if(i==0){\\n                    dp[i][j]=false;\\n                    continue;\\n                }\\n                if(arr[i-1]>j)  dp[i][j]=dp[i-1][j];\\n                else dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "hallenstal",
                        "content": "nums = [n-min(nums) for n in nums] \\nThen all nums>0"
                    },
                    {
                        "username": "Dextr2709",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n\\n        int n= nums.size();\\n        int sum = 0;\\n        for (int i=0; i< n; i++) {\\n            sum += nums[i];\\n        }\\n\\n        int t[n+1][sum+1];\\n\\n        for (int i =0; i<n; i++){\\n            t[i][0] = true;\\n        }\\n\\n        for (int j = 0; j<sum; j++) {\\n            t[0][j] = false;\\n        }\\n\\n        for (int i =1; i<n; i++){\\n            for(int j =1; j<sum; j++){\\n\\n                if(nums[i] <= j) {\\n                    t[i][j] = t[i-1][j-nums[i]] || t[i-1][j];\\n                }\\n\\n                else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n                \\n\\n            }\\n        }\\n\\n        vector<int> v;\\n\\n        for(int j = 0; j<sum; j++){\\n            if (t[n][j]==true){\\n                v.push_back(j);\\n            }\\n        }\\n\\n        int mn = INT_MAX;\\n        for (int i=0; i<v.size(); i++){\\n            mn = min(mn, sum - 2*v[i]);\\n        }\\n\\n        return mn;\\n\\n\\n\\n\\n    }\\n};\\n\\n\\ncan someone help me to figure out the reason why its throwing run-time error. I am relatively new to programming so if someone can spare minute or two to answer it, it will be very helpful."
                    },
                    {
                        "username": "SayanK",
                        "content": "This question includes negative elements in the array. So when you ask for indices j, it might even be negative. for example, [-1, 2, -2] then the sum is -1. So it will give out of bounds error.\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "could it be solve by newton\\'s method f(x)  when sort array nums ?"
                    },
                    {
                        "username": "janis__",
                        "content": "Newton\\'s method is used for finding successively better approximations to the roots of a real-valued function. It\\'s not directly applicable to the problem of finding a minimum difference in a sorted array, as the problem isn\\'t about root-finding."
                    },
                    {
                        "username": "aadarshdixit874",
                        "content": "class Solution {\\n    void FastIO()\\n{\\nios_base::sync_with_stdio(0);\\ncin.tie(0);\\ncout.tie(0);\\n}\\nvoid f(int i,int j,int size,vector<int>part1[],int sum,vector<int>nums){\\n    if(i==j+1) {\\n        part1[size].push_back(sum);\\n        return;\\n    }\\n    f(i+1,j,size+1,part1,sum+nums[i],nums);\\n    f(i+1,j,size,part1,sum,nums);\\n    return;\\n}\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n      int n = (nums.size())/2;\\n      vector<int>part1[n+1];\\n      vector<int>part2[n+1];\\n      int sum =0;\\n     f(0,n-1,0,part1,0,nums);\\n     f(n,2*n -1,0,part2,0,nums);\\n     for(int i=0;i<2*n;i++) {\\n         sum+=nums[i];\\n     } \\n    int temp1 = sum/2;\\n    // cout<<part2[0].size()<<endl;\\n    for(int i=1;i<=n;i++){\\n        sort(part2[i].begin(),part2[i].end());\\n    }\\n\\n    int ans = INT_MAX;\\n    ans=  min(ans,abs(sum-2*(part1[n][0])));\\n       ans=  min(ans,abs(sum-2*(part2[n][0])));\\n\\n    for(int i=1;i<=n;i++){\\n        for(auto &it:part1[i]){\\n            auto it1 = lower_bound(part2[n-i].begin(),part2[n-i].end(),temp1-it);\\n            if(it1!=part2[n-i].end()){\\n                 ans = min(ans,abs(sum-2*((*it1)+it)));\\n            }      \\n        }\\n    }\\n    return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\nwhy this code give tle \\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The code\\'s nested loops and recursive calls cause exponential time complexity, leading to a time limit exceeded (TLE) error on large inputs."
                    }
                ]
            },
            {
                "id": 1960345,
                "content": [
                    {
                        "username": "packle",
                        "content": "python meet in the middle w/ dict TLE, lazy fix is reducing sorting by using bisect.insort() instead of append while generating combinations"
                    },
                    {
                        "username": "percy_98",
                        "content": "Chat GPT 4  fail on this problem  miserably , it is constantly trying to give final answer but it stuck in loop as it is trying to correct with provided test cases  realizing answer is wrong for unit test cases then  it is correcting code and then checking and  failing again. What I can see it is trying to use DP :)   WOW !"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Test cases are written wrongly here. For the following input i.e., \\n[1,2,7,3]\\n\\nMy output is as follows : \\n[1,2,3] , [7]\\nMin Diff = {1}\\n\\nExpected test case output is {3}"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t consider all possible partitions; adjust to evaluate every possible split."
                    },
                    {
                        "username": "hallenstal",
                        "content": "Length of array should equal\\n"
                    },
                    {
                        "username": "guru_1826",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n         int n = nums.size();\\n         int T_sum = 0;\\n         for(int i = 0; i < n; i++){\\n            T_sum += nums[i];\\n         }\\n         \\n         \\n            \\n             vector<vector<bool>> dp(n+1, vector<bool>(T_sum+1, 0));\\n             // return f(n-1, arr, k, dp);\\n                for(int i = 0; i < n+1; i++){\\n                    dp[i][0] = true;\\n                }\\n                \\n                \\n                for(int i = 1; i < n+1; i++){\\n                    for (int j = 1; j < T_sum + 1; j++) {\\n                        int notTake = dp[i - 1][j];\\n                        int take = false;\\n                        if (j - nums[i-1] >= 0)\\n                        take = dp[i - 1][j - nums[i-1]];\\n\\n                        dp[i][j] = take || notTake;\\n                    }\\n                }\\n\\n               int mini = 1e9;\\n                for(int i = 0; i <= (T_sum)/2; i++){\\n                    if(dp[n][i]){\\n                        mini  = min(mini, abs(T_sum - 2*i));\\n                    }\\n                }\\n                return mini;\\n         \\n    }\\n};\\n\\nwhy is this code not working?\\n"
                    },
                    {
                        "username": "liayn15",
                        "content": "Why can\\'t we just sort it and to make a set we take elements from start and end till we have n/2 elements? "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting changes the original order of the array, which violates the problem\\'s constraint of selecting continuous subarrays. By taking elements from start and end post-sorting, you\\'re not ensuring that the selected elements form a continuous subarray in the original array."
                    },
                    {
                        "username": "vivek__khajuria",
                        "content": "Can somebody help me in this problem ?\\n\\nclass Solution {\\npublic:\\n     bool isSubsetSum(vector<int>&arr, int sum, vector<int>&v){\\n   int  n=arr.size();\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<sum/2+1;j++){\\n\\n                 if(j==0){\\n                    dp[i][j]=true;\\n                }\\n\\n                if(i==0){\\n                    dp[i][j]=false;\\n                }\\n\\n               \\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=sum;j++)\\n            {\\n                if(arr[i-1]<=j)\\n                {\\n                    dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n                }\\n                else\\n                dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n         for(int i=0;i<sum/2+1;i++)\\n         {\\n             if(dp[n][i]==1)\\n             v.push_back(i);\\n         }\\n        return 0;\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int>v;\\n        \\n             int n=nums.size(),total=0;\\n         for(int i=0;i<nums.size();i++){\\n            total+=nums[i];\\n         }\\n\\n          if(total==0){\\n            int sum=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]<0)nums[i]=-nums[i];\\n                sum+=nums[i];\\n            }\\n            return sum;\\n          }\\n          if(total<0)return 0;\\n          \\n         \\n      \\n        bool ans=isSubsetSum(nums,total,v);\\n        int mini=INT_MAX;\\n        for(int i=0;i<v.size();i++)\\n         {\\n            if(total-2*v[i]<mini)\\n             mini=total-2*v[i];\\n         }\\n        return mini;\\n    }\\n\\n};"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "bhai what would be sum + 1 it will be greater than your dp size which is not permissible, the maximum permissible space for a data structure in no more than 1e7 "
                    },
                    {
                        "username": "arbaazghameria",
                        "content": "I cant help with the negative values can anyone please help me out? \\n\\nheres my code\\n\\nclass Solution {\\n    boolean[][] dp;\\n    public int minimumDifference(int[] nums) {\\n        int totsum=0;\\n        for(int i:nums){\\n            totsum+=i;\\n        }\\n        SubsetSum(nums,totsum);\\n        int minn=Integer.MAX_VALUE;\\n        for(int i=0;i<dp[0].length/2;i++){\\n            if(dp[nums.length][i]){\\n                minn=Math.min(minn,totsum-(2*(i)));\\n            }\\n            \\n        }\\n        return minn;\\n    }\\n     public void SubsetSum(int[] arr,int target){\\n        dp=new boolean[arr.length+1][target+1];\\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<dp[0].length;j++){\\n                if(j==0){\\n                    dp[i][j]=true;\\n                    continue;\\n                }\\n                if(i==0){\\n                    dp[i][j]=false;\\n                    continue;\\n                }\\n                if(arr[i-1]>j)  dp[i][j]=dp[i-1][j];\\n                else dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "hallenstal",
                        "content": "nums = [n-min(nums) for n in nums] \\nThen all nums>0"
                    },
                    {
                        "username": "Dextr2709",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n\\n        int n= nums.size();\\n        int sum = 0;\\n        for (int i=0; i< n; i++) {\\n            sum += nums[i];\\n        }\\n\\n        int t[n+1][sum+1];\\n\\n        for (int i =0; i<n; i++){\\n            t[i][0] = true;\\n        }\\n\\n        for (int j = 0; j<sum; j++) {\\n            t[0][j] = false;\\n        }\\n\\n        for (int i =1; i<n; i++){\\n            for(int j =1; j<sum; j++){\\n\\n                if(nums[i] <= j) {\\n                    t[i][j] = t[i-1][j-nums[i]] || t[i-1][j];\\n                }\\n\\n                else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n                \\n\\n            }\\n        }\\n\\n        vector<int> v;\\n\\n        for(int j = 0; j<sum; j++){\\n            if (t[n][j]==true){\\n                v.push_back(j);\\n            }\\n        }\\n\\n        int mn = INT_MAX;\\n        for (int i=0; i<v.size(); i++){\\n            mn = min(mn, sum - 2*v[i]);\\n        }\\n\\n        return mn;\\n\\n\\n\\n\\n    }\\n};\\n\\n\\ncan someone help me to figure out the reason why its throwing run-time error. I am relatively new to programming so if someone can spare minute or two to answer it, it will be very helpful."
                    },
                    {
                        "username": "SayanK",
                        "content": "This question includes negative elements in the array. So when you ask for indices j, it might even be negative. for example, [-1, 2, -2] then the sum is -1. So it will give out of bounds error.\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "could it be solve by newton\\'s method f(x)  when sort array nums ?"
                    },
                    {
                        "username": "janis__",
                        "content": "Newton\\'s method is used for finding successively better approximations to the roots of a real-valued function. It\\'s not directly applicable to the problem of finding a minimum difference in a sorted array, as the problem isn\\'t about root-finding."
                    },
                    {
                        "username": "aadarshdixit874",
                        "content": "class Solution {\\n    void FastIO()\\n{\\nios_base::sync_with_stdio(0);\\ncin.tie(0);\\ncout.tie(0);\\n}\\nvoid f(int i,int j,int size,vector<int>part1[],int sum,vector<int>nums){\\n    if(i==j+1) {\\n        part1[size].push_back(sum);\\n        return;\\n    }\\n    f(i+1,j,size+1,part1,sum+nums[i],nums);\\n    f(i+1,j,size,part1,sum,nums);\\n    return;\\n}\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n      int n = (nums.size())/2;\\n      vector<int>part1[n+1];\\n      vector<int>part2[n+1];\\n      int sum =0;\\n     f(0,n-1,0,part1,0,nums);\\n     f(n,2*n -1,0,part2,0,nums);\\n     for(int i=0;i<2*n;i++) {\\n         sum+=nums[i];\\n     } \\n    int temp1 = sum/2;\\n    // cout<<part2[0].size()<<endl;\\n    for(int i=1;i<=n;i++){\\n        sort(part2[i].begin(),part2[i].end());\\n    }\\n\\n    int ans = INT_MAX;\\n    ans=  min(ans,abs(sum-2*(part1[n][0])));\\n       ans=  min(ans,abs(sum-2*(part2[n][0])));\\n\\n    for(int i=1;i<=n;i++){\\n        for(auto &it:part1[i]){\\n            auto it1 = lower_bound(part2[n-i].begin(),part2[n-i].end(),temp1-it);\\n            if(it1!=part2[n-i].end()){\\n                 ans = min(ans,abs(sum-2*((*it1)+it)));\\n            }      \\n        }\\n    }\\n    return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\nwhy this code give tle \\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The code\\'s nested loops and recursive calls cause exponential time complexity, leading to a time limit exceeded (TLE) error on large inputs."
                    }
                ]
            },
            {
                "id": 1936830,
                "content": [
                    {
                        "username": "packle",
                        "content": "python meet in the middle w/ dict TLE, lazy fix is reducing sorting by using bisect.insort() instead of append while generating combinations"
                    },
                    {
                        "username": "percy_98",
                        "content": "Chat GPT 4  fail on this problem  miserably , it is constantly trying to give final answer but it stuck in loop as it is trying to correct with provided test cases  realizing answer is wrong for unit test cases then  it is correcting code and then checking and  failing again. What I can see it is trying to use DP :)   WOW !"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Test cases are written wrongly here. For the following input i.e., \\n[1,2,7,3]\\n\\nMy output is as follows : \\n[1,2,3] , [7]\\nMin Diff = {1}\\n\\nExpected test case output is {3}"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t consider all possible partitions; adjust to evaluate every possible split."
                    },
                    {
                        "username": "hallenstal",
                        "content": "Length of array should equal\\n"
                    },
                    {
                        "username": "guru_1826",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n         int n = nums.size();\\n         int T_sum = 0;\\n         for(int i = 0; i < n; i++){\\n            T_sum += nums[i];\\n         }\\n         \\n         \\n            \\n             vector<vector<bool>> dp(n+1, vector<bool>(T_sum+1, 0));\\n             // return f(n-1, arr, k, dp);\\n                for(int i = 0; i < n+1; i++){\\n                    dp[i][0] = true;\\n                }\\n                \\n                \\n                for(int i = 1; i < n+1; i++){\\n                    for (int j = 1; j < T_sum + 1; j++) {\\n                        int notTake = dp[i - 1][j];\\n                        int take = false;\\n                        if (j - nums[i-1] >= 0)\\n                        take = dp[i - 1][j - nums[i-1]];\\n\\n                        dp[i][j] = take || notTake;\\n                    }\\n                }\\n\\n               int mini = 1e9;\\n                for(int i = 0; i <= (T_sum)/2; i++){\\n                    if(dp[n][i]){\\n                        mini  = min(mini, abs(T_sum - 2*i));\\n                    }\\n                }\\n                return mini;\\n         \\n    }\\n};\\n\\nwhy is this code not working?\\n"
                    },
                    {
                        "username": "liayn15",
                        "content": "Why can\\'t we just sort it and to make a set we take elements from start and end till we have n/2 elements? "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting changes the original order of the array, which violates the problem\\'s constraint of selecting continuous subarrays. By taking elements from start and end post-sorting, you\\'re not ensuring that the selected elements form a continuous subarray in the original array."
                    },
                    {
                        "username": "vivek__khajuria",
                        "content": "Can somebody help me in this problem ?\\n\\nclass Solution {\\npublic:\\n     bool isSubsetSum(vector<int>&arr, int sum, vector<int>&v){\\n   int  n=arr.size();\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<sum/2+1;j++){\\n\\n                 if(j==0){\\n                    dp[i][j]=true;\\n                }\\n\\n                if(i==0){\\n                    dp[i][j]=false;\\n                }\\n\\n               \\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=sum;j++)\\n            {\\n                if(arr[i-1]<=j)\\n                {\\n                    dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n                }\\n                else\\n                dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n         for(int i=0;i<sum/2+1;i++)\\n         {\\n             if(dp[n][i]==1)\\n             v.push_back(i);\\n         }\\n        return 0;\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int>v;\\n        \\n             int n=nums.size(),total=0;\\n         for(int i=0;i<nums.size();i++){\\n            total+=nums[i];\\n         }\\n\\n          if(total==0){\\n            int sum=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]<0)nums[i]=-nums[i];\\n                sum+=nums[i];\\n            }\\n            return sum;\\n          }\\n          if(total<0)return 0;\\n          \\n         \\n      \\n        bool ans=isSubsetSum(nums,total,v);\\n        int mini=INT_MAX;\\n        for(int i=0;i<v.size();i++)\\n         {\\n            if(total-2*v[i]<mini)\\n             mini=total-2*v[i];\\n         }\\n        return mini;\\n    }\\n\\n};"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "bhai what would be sum + 1 it will be greater than your dp size which is not permissible, the maximum permissible space for a data structure in no more than 1e7 "
                    },
                    {
                        "username": "arbaazghameria",
                        "content": "I cant help with the negative values can anyone please help me out? \\n\\nheres my code\\n\\nclass Solution {\\n    boolean[][] dp;\\n    public int minimumDifference(int[] nums) {\\n        int totsum=0;\\n        for(int i:nums){\\n            totsum+=i;\\n        }\\n        SubsetSum(nums,totsum);\\n        int minn=Integer.MAX_VALUE;\\n        for(int i=0;i<dp[0].length/2;i++){\\n            if(dp[nums.length][i]){\\n                minn=Math.min(minn,totsum-(2*(i)));\\n            }\\n            \\n        }\\n        return minn;\\n    }\\n     public void SubsetSum(int[] arr,int target){\\n        dp=new boolean[arr.length+1][target+1];\\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<dp[0].length;j++){\\n                if(j==0){\\n                    dp[i][j]=true;\\n                    continue;\\n                }\\n                if(i==0){\\n                    dp[i][j]=false;\\n                    continue;\\n                }\\n                if(arr[i-1]>j)  dp[i][j]=dp[i-1][j];\\n                else dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "hallenstal",
                        "content": "nums = [n-min(nums) for n in nums] \\nThen all nums>0"
                    },
                    {
                        "username": "Dextr2709",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n\\n        int n= nums.size();\\n        int sum = 0;\\n        for (int i=0; i< n; i++) {\\n            sum += nums[i];\\n        }\\n\\n        int t[n+1][sum+1];\\n\\n        for (int i =0; i<n; i++){\\n            t[i][0] = true;\\n        }\\n\\n        for (int j = 0; j<sum; j++) {\\n            t[0][j] = false;\\n        }\\n\\n        for (int i =1; i<n; i++){\\n            for(int j =1; j<sum; j++){\\n\\n                if(nums[i] <= j) {\\n                    t[i][j] = t[i-1][j-nums[i]] || t[i-1][j];\\n                }\\n\\n                else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n                \\n\\n            }\\n        }\\n\\n        vector<int> v;\\n\\n        for(int j = 0; j<sum; j++){\\n            if (t[n][j]==true){\\n                v.push_back(j);\\n            }\\n        }\\n\\n        int mn = INT_MAX;\\n        for (int i=0; i<v.size(); i++){\\n            mn = min(mn, sum - 2*v[i]);\\n        }\\n\\n        return mn;\\n\\n\\n\\n\\n    }\\n};\\n\\n\\ncan someone help me to figure out the reason why its throwing run-time error. I am relatively new to programming so if someone can spare minute or two to answer it, it will be very helpful."
                    },
                    {
                        "username": "SayanK",
                        "content": "This question includes negative elements in the array. So when you ask for indices j, it might even be negative. for example, [-1, 2, -2] then the sum is -1. So it will give out of bounds error.\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "could it be solve by newton\\'s method f(x)  when sort array nums ?"
                    },
                    {
                        "username": "janis__",
                        "content": "Newton\\'s method is used for finding successively better approximations to the roots of a real-valued function. It\\'s not directly applicable to the problem of finding a minimum difference in a sorted array, as the problem isn\\'t about root-finding."
                    },
                    {
                        "username": "aadarshdixit874",
                        "content": "class Solution {\\n    void FastIO()\\n{\\nios_base::sync_with_stdio(0);\\ncin.tie(0);\\ncout.tie(0);\\n}\\nvoid f(int i,int j,int size,vector<int>part1[],int sum,vector<int>nums){\\n    if(i==j+1) {\\n        part1[size].push_back(sum);\\n        return;\\n    }\\n    f(i+1,j,size+1,part1,sum+nums[i],nums);\\n    f(i+1,j,size,part1,sum,nums);\\n    return;\\n}\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n      int n = (nums.size())/2;\\n      vector<int>part1[n+1];\\n      vector<int>part2[n+1];\\n      int sum =0;\\n     f(0,n-1,0,part1,0,nums);\\n     f(n,2*n -1,0,part2,0,nums);\\n     for(int i=0;i<2*n;i++) {\\n         sum+=nums[i];\\n     } \\n    int temp1 = sum/2;\\n    // cout<<part2[0].size()<<endl;\\n    for(int i=1;i<=n;i++){\\n        sort(part2[i].begin(),part2[i].end());\\n    }\\n\\n    int ans = INT_MAX;\\n    ans=  min(ans,abs(sum-2*(part1[n][0])));\\n       ans=  min(ans,abs(sum-2*(part2[n][0])));\\n\\n    for(int i=1;i<=n;i++){\\n        for(auto &it:part1[i]){\\n            auto it1 = lower_bound(part2[n-i].begin(),part2[n-i].end(),temp1-it);\\n            if(it1!=part2[n-i].end()){\\n                 ans = min(ans,abs(sum-2*((*it1)+it)));\\n            }      \\n        }\\n    }\\n    return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\nwhy this code give tle \\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The code\\'s nested loops and recursive calls cause exponential time complexity, leading to a time limit exceeded (TLE) error on large inputs."
                    }
                ]
            },
            {
                "id": 1928278,
                "content": [
                    {
                        "username": "packle",
                        "content": "python meet in the middle w/ dict TLE, lazy fix is reducing sorting by using bisect.insort() instead of append while generating combinations"
                    },
                    {
                        "username": "percy_98",
                        "content": "Chat GPT 4  fail on this problem  miserably , it is constantly trying to give final answer but it stuck in loop as it is trying to correct with provided test cases  realizing answer is wrong for unit test cases then  it is correcting code and then checking and  failing again. What I can see it is trying to use DP :)   WOW !"
                    },
                    {
                        "username": "akacool0744",
                        "content": "Test cases are written wrongly here. For the following input i.e., \\n[1,2,7,3]\\n\\nMy output is as follows : \\n[1,2,3] , [7]\\nMin Diff = {1}\\n\\nExpected test case output is {3}"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t consider all possible partitions; adjust to evaluate every possible split."
                    },
                    {
                        "username": "hallenstal",
                        "content": "Length of array should equal\\n"
                    },
                    {
                        "username": "guru_1826",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n         int n = nums.size();\\n         int T_sum = 0;\\n         for(int i = 0; i < n; i++){\\n            T_sum += nums[i];\\n         }\\n         \\n         \\n            \\n             vector<vector<bool>> dp(n+1, vector<bool>(T_sum+1, 0));\\n             // return f(n-1, arr, k, dp);\\n                for(int i = 0; i < n+1; i++){\\n                    dp[i][0] = true;\\n                }\\n                \\n                \\n                for(int i = 1; i < n+1; i++){\\n                    for (int j = 1; j < T_sum + 1; j++) {\\n                        int notTake = dp[i - 1][j];\\n                        int take = false;\\n                        if (j - nums[i-1] >= 0)\\n                        take = dp[i - 1][j - nums[i-1]];\\n\\n                        dp[i][j] = take || notTake;\\n                    }\\n                }\\n\\n               int mini = 1e9;\\n                for(int i = 0; i <= (T_sum)/2; i++){\\n                    if(dp[n][i]){\\n                        mini  = min(mini, abs(T_sum - 2*i));\\n                    }\\n                }\\n                return mini;\\n         \\n    }\\n};\\n\\nwhy is this code not working?\\n"
                    },
                    {
                        "username": "liayn15",
                        "content": "Why can\\'t we just sort it and to make a set we take elements from start and end till we have n/2 elements? "
                    },
                    {
                        "username": "janis__",
                        "content": "Sorting changes the original order of the array, which violates the problem\\'s constraint of selecting continuous subarrays. By taking elements from start and end post-sorting, you\\'re not ensuring that the selected elements form a continuous subarray in the original array."
                    },
                    {
                        "username": "vivek__khajuria",
                        "content": "Can somebody help me in this problem ?\\n\\nclass Solution {\\npublic:\\n     bool isSubsetSum(vector<int>&arr, int sum, vector<int>&v){\\n   int  n=arr.size();\\n        int dp[n+1][sum+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<sum/2+1;j++){\\n\\n                 if(j==0){\\n                    dp[i][j]=true;\\n                }\\n\\n                if(i==0){\\n                    dp[i][j]=false;\\n                }\\n\\n               \\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=sum;j++)\\n            {\\n                if(arr[i-1]<=j)\\n                {\\n                    dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n                }\\n                else\\n                dp[i][j]=dp[i-1][j];\\n            }\\n        }\\n         for(int i=0;i<sum/2+1;i++)\\n         {\\n             if(dp[n][i]==1)\\n             v.push_back(i);\\n         }\\n        return 0;\\n    }\\n    int minimumDifference(vector<int>& nums) {\\n        vector<int>v;\\n        \\n             int n=nums.size(),total=0;\\n         for(int i=0;i<nums.size();i++){\\n            total+=nums[i];\\n         }\\n\\n          if(total==0){\\n            int sum=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]<0)nums[i]=-nums[i];\\n                sum+=nums[i];\\n            }\\n            return sum;\\n          }\\n          if(total<0)return 0;\\n          \\n         \\n      \\n        bool ans=isSubsetSum(nums,total,v);\\n        int mini=INT_MAX;\\n        for(int i=0;i<v.size();i++)\\n         {\\n            if(total-2*v[i]<mini)\\n             mini=total-2*v[i];\\n         }\\n        return mini;\\n    }\\n\\n};"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "bhai what would be sum + 1 it will be greater than your dp size which is not permissible, the maximum permissible space for a data structure in no more than 1e7 "
                    },
                    {
                        "username": "arbaazghameria",
                        "content": "I cant help with the negative values can anyone please help me out? \\n\\nheres my code\\n\\nclass Solution {\\n    boolean[][] dp;\\n    public int minimumDifference(int[] nums) {\\n        int totsum=0;\\n        for(int i:nums){\\n            totsum+=i;\\n        }\\n        SubsetSum(nums,totsum);\\n        int minn=Integer.MAX_VALUE;\\n        for(int i=0;i<dp[0].length/2;i++){\\n            if(dp[nums.length][i]){\\n                minn=Math.min(minn,totsum-(2*(i)));\\n            }\\n            \\n        }\\n        return minn;\\n    }\\n     public void SubsetSum(int[] arr,int target){\\n        dp=new boolean[arr.length+1][target+1];\\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<dp[0].length;j++){\\n                if(j==0){\\n                    dp[i][j]=true;\\n                    continue;\\n                }\\n                if(i==0){\\n                    dp[i][j]=false;\\n                    continue;\\n                }\\n                if(arr[i-1]>j)  dp[i][j]=dp[i-1][j];\\n                else dp[i][j]=dp[i-1][j]||dp[i-1][j-arr[i-1]];\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "hallenstal",
                        "content": "nums = [n-min(nums) for n in nums] \\nThen all nums>0"
                    },
                    {
                        "username": "Dextr2709",
                        "content": "class Solution {\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n\\n        int n= nums.size();\\n        int sum = 0;\\n        for (int i=0; i< n; i++) {\\n            sum += nums[i];\\n        }\\n\\n        int t[n+1][sum+1];\\n\\n        for (int i =0; i<n; i++){\\n            t[i][0] = true;\\n        }\\n\\n        for (int j = 0; j<sum; j++) {\\n            t[0][j] = false;\\n        }\\n\\n        for (int i =1; i<n; i++){\\n            for(int j =1; j<sum; j++){\\n\\n                if(nums[i] <= j) {\\n                    t[i][j] = t[i-1][j-nums[i]] || t[i-1][j];\\n                }\\n\\n                else {\\n                    t[i][j] = t[i-1][j];\\n                }\\n                \\n\\n            }\\n        }\\n\\n        vector<int> v;\\n\\n        for(int j = 0; j<sum; j++){\\n            if (t[n][j]==true){\\n                v.push_back(j);\\n            }\\n        }\\n\\n        int mn = INT_MAX;\\n        for (int i=0; i<v.size(); i++){\\n            mn = min(mn, sum - 2*v[i]);\\n        }\\n\\n        return mn;\\n\\n\\n\\n\\n    }\\n};\\n\\n\\ncan someone help me to figure out the reason why its throwing run-time error. I am relatively new to programming so if someone can spare minute or two to answer it, it will be very helpful."
                    },
                    {
                        "username": "SayanK",
                        "content": "This question includes negative elements in the array. So when you ask for indices j, it might even be negative. for example, [-1, 2, -2] then the sum is -1. So it will give out of bounds error.\\n"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "could it be solve by newton\\'s method f(x)  when sort array nums ?"
                    },
                    {
                        "username": "janis__",
                        "content": "Newton\\'s method is used for finding successively better approximations to the roots of a real-valued function. It\\'s not directly applicable to the problem of finding a minimum difference in a sorted array, as the problem isn\\'t about root-finding."
                    },
                    {
                        "username": "aadarshdixit874",
                        "content": "class Solution {\\n    void FastIO()\\n{\\nios_base::sync_with_stdio(0);\\ncin.tie(0);\\ncout.tie(0);\\n}\\nvoid f(int i,int j,int size,vector<int>part1[],int sum,vector<int>nums){\\n    if(i==j+1) {\\n        part1[size].push_back(sum);\\n        return;\\n    }\\n    f(i+1,j,size+1,part1,sum+nums[i],nums);\\n    f(i+1,j,size,part1,sum,nums);\\n    return;\\n}\\npublic:\\n    int minimumDifference(vector<int>& nums) {\\n      int n = (nums.size())/2;\\n      vector<int>part1[n+1];\\n      vector<int>part2[n+1];\\n      int sum =0;\\n     f(0,n-1,0,part1,0,nums);\\n     f(n,2*n -1,0,part2,0,nums);\\n     for(int i=0;i<2*n;i++) {\\n         sum+=nums[i];\\n     } \\n    int temp1 = sum/2;\\n    // cout<<part2[0].size()<<endl;\\n    for(int i=1;i<=n;i++){\\n        sort(part2[i].begin(),part2[i].end());\\n    }\\n\\n    int ans = INT_MAX;\\n    ans=  min(ans,abs(sum-2*(part1[n][0])));\\n       ans=  min(ans,abs(sum-2*(part2[n][0])));\\n\\n    for(int i=1;i<=n;i++){\\n        for(auto &it:part1[i]){\\n            auto it1 = lower_bound(part2[n-i].begin(),part2[n-i].end(),temp1-it);\\n            if(it1!=part2[n-i].end()){\\n                 ans = min(ans,abs(sum-2*((*it1)+it)));\\n            }      \\n        }\\n    }\\n    return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\nwhy this code give tle \\n"
                    },
                    {
                        "username": "janis__",
                        "content": "The code\\'s nested loops and recursive calls cause exponential time complexity, leading to a time limit exceeded (TLE) error on large inputs."
                    }
                ]
            }
        ]
    }
]