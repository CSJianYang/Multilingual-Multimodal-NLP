[
    {
        "title": "Count Number of Ways to Place Houses",
        "question_content": "There is a street with n * 2 plots, where there are n plots on each side of the street. The plots on each side are numbered from 1 to n. On each plot, a house can be placed.\nReturn the number of ways houses can be placed such that no two houses are adjacent to each other on the same side of the street. Since the answer may be very large, return it modulo 109 + 7.\nNote that if a house is placed on the ith plot on one side of the street, a house can also be placed on the ith plot on the other side of the street.\n&nbsp;\nExample 1:\n\nInput: n = 1\nOutput: 4\nExplanation: \nPossible arrangements:\n1. All plots are empty.\n2. A house is placed on one side of the street.\n3. A house is placed on the other side of the street.\n4. Two houses are placed, one on each side of the street.\n\nExample 2:\n\nInput: n = 2\nOutput: 9\nExplanation: The 9 possible arrangements are shown in the diagram above.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 104",
        "solutions": [
            {
                "id": 2198118,
                "title": "easy-c-with-explanation-dp",
                "content": "house represents no. of ways street ending with house\\nspace represents no. of ways street ending with space\\nLets think of no. of ways of placing houses on one side, \\n**For n=1** \\nWe have only one space, either it is house or a space, so house=1 and space=1, total = house+space.\\n    \\n**For n=2**\\nwe can put a house if previous ending is space, so house = space (i.e prev spaces)\\nwe can put a space whatever the previous ending may be, so space = total (i.e prev total)\\nIn this way we can continue our loop upto n, Now this answer is for one side.\\n    \\nFor the other side, we have the same possible ways, so for each way on one side can correspond to any of the total ways on other side.\\nSo our answer is  = (total*total)\\n\\n**Time complexity: O(n), Space complexity: O(1)**\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll mod = 1e9+7;\\n    int countHousePlacements(int n) {\\n        ll house=1, space=1;\\n        ll total = house+space;\\n        for(int i=2;i<=n;i++){\\n\\t        house = space;\\n\\t        space = total;\\n\\t        total = (house+space)%mod;\\n\\t    }\\n\\t    return (total*total)%mod;\\n    }\\n};\\n```\\n**Upvote if it helps!**\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll mod = 1e9+7;\\n    int countHousePlacements(int n) {\\n        ll house=1, space=1;\\n        ll total = house+space;\\n        for(int i=2;i<=n;i++){\\n\\t        house = space;\\n\\t        space = total;\\n\\t        total = (house+space)%mod;\\n\\t    }\\n\\t    return (total*total)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198137,
                "title": "simple-fibonacci-series",
                "content": "The opposite sides are independent to each other. So, the total number of ways would be the product of no.of ways of one side and another side.\\n\\nLet\\'s try to write the result for some numbers:\\n```\\n1 -> 4 (2*2)\\n2 -> 9 (3*3)\\n3 -> 25 (5*5)\\n4 -> 64 (8*8)\\n```\\n\\nIf you observe carefully, a **fibonacci type sequence** is formed.\\n\\nCODE:\\n```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        if(n==1):return 4\\n        if(n==2):return 9\\n        \\n        MOD=pow(10,9)+7\\n        \\n        prev_prev=2\\n        prev=3\\n        for i in range(3,n+1):\\n            current=prev+prev_prev\\n            prev_prev=prev\\n            prev=current\\n            \\n        return (prev*prev)%MOD\\n```\\n\\n**Upvote if it helps!**\\n",
                "solutionTags": [],
                "code": "```\\n1 -> 4 (2*2)\\n2 -> 9 (3*3)\\n3 -> 25 (5*5)\\n4 -> 64 (8*8)\\n```\n```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        if(n==1):return 4\\n        if(n==2):return 9\\n        \\n        MOD=pow(10,9)+7\\n        \\n        prev_prev=2\\n        prev=3\\n        for i in range(3,n+1):\\n            current=prev+prev_prev\\n            prev_prev=prev\\n            prev=current\\n            \\n        return (prev*prev)%MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199005,
                "title": "dp-recursion-memoization-tabulation",
                "content": "For every cell we have 2 options:\\n1. fill it (house present)\\n2. leave it empty (house absent)\\n\\nSo, if the cell is filled - its adjacent cell is bound to be kept empty.\\nBut if the cell is empty - its adjacent cell can be either filled or left empty.\\n\\n**Recursion:**\\n```\\nclass Solution {\\n    long long MOD = 1000000007;\\npublic:\\n    int countHousePlacements(int n) {\\n        long long ways_for_one_side = (Recursion(n, 0) + Recursion(n, 1)) % MOD; // 0 == empty, 1 == filled\\n        \\n        return (ways_for_one_side * ways_for_one_side) % MOD;\\n    }\\n    \\n    long long Recursion(int n, bool is_filled)\\n    {\\n        if (n == 1)\\n            return 1;\\n        \\n        if (is_filled)\\n            return Recursion(n - 1, !is_filled);\\n        else\\n            return (Recursion(n - 1, !is_filled) + Recursion(n - 1, is_filled)) % MOD;\\n    }\\n};\\n```\\n\\n**Memoization:**\\n```\\nclass Solution {\\n    long long MOD = 1000000007;\\n    vector<vector<int>> dp;\\npublic:\\n    int countHousePlacements(int n) {\\n        dp.resize(n + 1, vector<int> (2, -1));\\n        long long ways_for_one_side = (Memoization(n, 0) + Memoization(n, 1)) % MOD;\\n        \\n        return (ways_for_one_side * ways_for_one_side) % MOD;\\n    }\\n    \\n    long long Memoization(int n, bool is_filled)\\n    {\\n        if (n == 1)\\n            return 1;\\n        \\n        if (dp[n][is_filled] != -1)\\n            return dp[n][is_filled];\\n        \\n        if (is_filled)\\n            return dp[n][1] = Memoization(n - 1, !is_filled);\\n        else\\n            return dp[n][0] = (Memoization(n - 1, !is_filled) + Memoization(n - 1, is_filled)) % MOD;\\n    }\\n};\\n```\\n\\n**Tabulation:**\\n```\\nclass Solution{\\n    long long MOD = 1000000007;\\npublic:\\n    int countHousePlacements(int n)\\n    {\\n        vector<int> filled(n + 1);\\n        vector<int> space(n + 1);\\n        \\n        filled[1] = 1;\\n        space[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++)\\n        {\\n            filled[i] = space[i - 1];\\n            space[i] = (filled[i - 1] + space[i - 1]) % MOD;\\n        }  \\n\\n        long long total = (filled[n] + space[n]) % MOD;\\n        long long res = (total * total) % MOD;\\n       \\n        return res;\\n    }\\n};\\n```\\n\\nHope this helps! :)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    long long MOD = 1000000007;\\npublic:\\n    int countHousePlacements(int n) {\\n        long long ways_for_one_side = (Recursion(n, 0) + Recursion(n, 1)) % MOD; // 0 == empty, 1 == filled\\n        \\n        return (ways_for_one_side * ways_for_one_side) % MOD;\\n    }\\n    \\n    long long Recursion(int n, bool is_filled)\\n    {\\n        if (n == 1)\\n            return 1;\\n        \\n        if (is_filled)\\n            return Recursion(n - 1, !is_filled);\\n        else\\n            return (Recursion(n - 1, !is_filled) + Recursion(n - 1, is_filled)) % MOD;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    long long MOD = 1000000007;\\n    vector<vector<int>> dp;\\npublic:\\n    int countHousePlacements(int n) {\\n        dp.resize(n + 1, vector<int> (2, -1));\\n        long long ways_for_one_side = (Memoization(n, 0) + Memoization(n, 1)) % MOD;\\n        \\n        return (ways_for_one_side * ways_for_one_side) % MOD;\\n    }\\n    \\n    long long Memoization(int n, bool is_filled)\\n    {\\n        if (n == 1)\\n            return 1;\\n        \\n        if (dp[n][is_filled] != -1)\\n            return dp[n][is_filled];\\n        \\n        if (is_filled)\\n            return dp[n][1] = Memoization(n - 1, !is_filled);\\n        else\\n            return dp[n][0] = (Memoization(n - 1, !is_filled) + Memoization(n - 1, is_filled)) % MOD;\\n    }\\n};\\n```\n```\\nclass Solution{\\n    long long MOD = 1000000007;\\npublic:\\n    int countHousePlacements(int n)\\n    {\\n        vector<int> filled(n + 1);\\n        vector<int> space(n + 1);\\n        \\n        filled[1] = 1;\\n        space[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++)\\n        {\\n            filled[i] = space[i - 1];\\n            space[i] = (filled[i - 1] + space[i - 1]) % MOD;\\n        }  \\n\\n        long long total = (filled[n] + space[n]) % MOD;\\n        long long res = (total * total) % MOD;\\n       \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198269,
                "title": "java-c-python-fibo-sequence-o-logn",
                "content": "# **Explanation**\\nInspired by @lordofmountain\\nOne side has no effect to the other.\\nThe number of way on one side is fibo sequence.\\nreturn `fibo * fibo` in the end.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int countHousePlacements(int n) {\\n        int a = 1, b = 1, c = 2, mod = (int)1e9 + 7;\\n        for (int i = 0; i < n; ++i) {\\n            c = (a + b) % mod;\\n            a = b;\\n            b = c;\\n        }\\n        return (int)(1L * b * b % mod);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int countHousePlacements(int n) {\\n        int a = 1, b = 1, c = 2, mod = 1e9 + 7;\\n        for (int i = 0; i < n; ++i) {\\n            c = (a + b) % mod;\\n            a = b;\\n            b = c;\\n        }\\n        return 1L * b * b % mod;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countHousePlacements(self, n):\\n        a, b, mod = 1, 1, 10**9 + 7\\n        for i in range(n):\\n            a, b = b, (a + b) % mod\\n        return b * b % mod\\n```\\n<br>\\n\\n# **Solution 2: Fast Pow**\\nTime `O(logn)`\\nSpace `O(1)`\\n\\n**Python**\\n```py\\n    def fib(self, n: int) -> int:\\n        a, b, c, d, mod = 1, 1, 0, 1, 10 ** 9 + 7\\n        while n:\\n            if n & 1:\\n                a, b = a * c + b * d, a * d + b * c + b * d\\n                n -= 1\\n            else:\\n                c, d = c * c + d * d, 2 * c * d + d * d\\n                n >>= 1\\n            a, b, c, d = a % mod, b % mod, c % mod, d % mod\\n        return a\\n\\n    def countHousePlacements(self, n):\\n        return self.fib(n + 1) ** 2 % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int countHousePlacements(int n) {\\n        int a = 1, b = 1, c = 2, mod = (int)1e9 + 7;\\n        for (int i = 0; i < n; ++i) {\\n            c = (a + b) % mod;\\n            a = b;\\n            b = c;\\n        }\\n        return (int)(1L * b * b % mod);\\n    }\\n```\n```cpp\\n    int countHousePlacements(int n) {\\n        int a = 1, b = 1, c = 2, mod = 1e9 + 7;\\n        for (int i = 0; i < n; ++i) {\\n            c = (a + b) % mod;\\n            a = b;\\n            b = c;\\n        }\\n        return 1L * b * b % mod;\\n    }\\n```\n```py\\n    def countHousePlacements(self, n):\\n        a, b, mod = 1, 1, 10**9 + 7\\n        for i in range(n):\\n            a, b = b, (a + b) % mod\\n        return b * b % mod\\n```\n```py\\n    def fib(self, n: int) -> int:\\n        a, b, c, d, mod = 1, 1, 0, 1, 10 ** 9 + 7\\n        while n:\\n            if n & 1:\\n                a, b = a * c + b * d, a * d + b * c + b * d\\n                n -= 1\\n            else:\\n                c, d = c * c + d * d, 2 * c * d + d * d\\n                n >>= 1\\n            a, b, c, d = a % mod, b % mod, c % mod, d % mod\\n        return a\\n\\n    def countHousePlacements(self, n):\\n        return self.fib(n + 1) ** 2 % (10 ** 9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2198119,
                "title": "house-robber-2",
                "content": "I did not realize it at first, but placement on one side does not affect the other.\\n\\nSo, we can just count number arrangements on one side, and return the square of that number.\\n\\nCounting arrangement is similar to [198. House Robber](https://leetcode.com/problems/house-robber/), but here it\\'s simpler as we do not have to rob those houses, only count.\\n\\n**C++**\\n```cpp\\nint countHousePlacements(int n) {\\n    int placed = 0, empty = 1, res = 1, mod = 1000000007;\\n    for (int i = 1; i <= n; ++i) {\\n        placed = empty;\\n        empty = res;\\n        res = (placed + empty) % mod;\\n    }\\n    return ((long long)res * res) % mod;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countHousePlacements(int n) {\\n    int placed = 0, empty = 1, res = 1, mod = 1000000007;\\n    for (int i = 1; i <= n; ++i) {\\n        placed = empty;\\n        empty = res;\\n        res = (placed + empty) % mod;\\n    }\\n    return ((long long)res * res) % mod;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198193,
                "title": "c-short-and-easy-with-dp",
                "content": "Let `dp[i]` be the number of ways to place `0..i` house on the side of a street with i plots of land. \\n\\nSo the result will be the combination of the two sides of the street `dp[n] * dp[n]`\\nWhich `dp[i] = dp[i-1] + dp[i-2]`\\n\\n```C++\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        vector<long long> dp(n + 10);\\n        int mod = 1e9 + 7;\\n        dp[0] = 1, dp[1] = 2;\\n        for (int i = 2; i <= n; ++i)\\n            dp[i] = (dp[i - 1] + dp[i - 2]) % mod;\\n        return dp[n] * dp[n] % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        vector<long long> dp(n + 10);\\n        int mod = 1e9 + 7;\\n        dp[0] = 1, dp[1] = 2;\\n        for (int i = 2; i <= n; ++i)\\n            dp[i] = (dp[i - 1] + dp[i - 2]) % mod;\\n        return dp[n] * dp[n] % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198744,
                "title": "python-with-explanation-fibonacci-dp-o-1-space",
                "content": "\\nSince two sides of plots are independent of each other, we can just calculate the number of ways to place houses on one side first, and multiply it by itself to get the final result.\\n\\nSuppose we have n plots for one side:\\n\\n![image](https://assets.leetcode.com/users/images/135d95fe-3c07-46f5-8408-a16e38885943_1656219491.6367002.png)\\n\\n\\nFrom above illustration, we can get the following result:\\n`dp[n] = dp[n-2] + dp[n-1]`\\n\\nThis is exactly the fibonacci number: [509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)\\n\\n\\nMy python implementation is as follows:\\n\\n```\\ndef countHousePlacements(self, n: int) -> int:\\n\\ta, b = 1, 2\\n\\tfor i in range(1, n):\\n\\t\\ta, b = b, a + b\\n\\treturn (b ** 2) % (10**9 + 7)\\n```\\n\\n**Complexity Analysis**\\n* Time complexity: O(n)\\n* Space complexity: O(1)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef countHousePlacements(self, n: int) -> int:\\n\\ta, b = 1, 2\\n\\tfor i in range(1, n):\\n\\t\\ta, b = b, a + b\\n\\treturn (b ** 2) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2198117,
                "title": "clean-python-dp",
                "content": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        \\n        \\n        @lru_cache(None)\\n        def rec(i, k):\\n            \\n            # i is the index of the house \\n            # k is the state of last house, 1 if there was a house on the last index else 0\\n            \\n            if i>=n:\\n                return 1\\n            \\n            elif k==0:\\n                return rec(i+1,1) + rec(i+1,0)\\n            \\n            else:\\n                return rec(i+1,0)\\n        \\n        \\n        \\n        #l1 are the combinations possible in lane 1, the final answer will be the square \\n\\t\\t#of of l1 as for every combination of l1 there will be \"l1\" combinations in lane2.\\n        \\n        l1 = rec(1,0) + rec(1,1)\\n        \\n        \\n        mod = 10**9 +7\\n        return pow(l1, 2, mod) #use this when there is mod involved along with power \\n            \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        \\n        \\n        @lru_cache(None)\\n        def rec(i, k):\\n            \\n            # i is the index of the house \\n            # k is the state of last house, 1 if there was a house on the last index else 0\\n            \\n            if i>=n:\\n                return 1\\n            \\n            elif k==0:\\n                return rec(i+1,1) + rec(i+1,0)\\n            \\n            else:\\n                return rec(i+1,0)\\n        \\n        \\n        \\n        #l1 are the combinations possible in lane 1, the final answer will be the square \\n\\t\\t#of of l1 as for every combination of l1 there will be \"l1\" combinations in lane2.\\n        \\n        l1 = rec(1,0) + rec(1,1)\\n        \\n        \\n        mod = 10**9 +7\\n        return pow(l1, 2, mod) #use this when there is mod involved along with power \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198256,
                "title": "split-into-two-parts-and-multiply-intuition-memoized-and-dp-both-solutions",
                "content": "\\n**Intution**\\n\\nThe Observation:\\n> Both Streets are of same size and opposite houses are allowed\\n\\nWe can take advantage of above fact and just count ways of putting the houses in **n plots** over a single street and those ways will pair with every ways corresponding to opoosite street which will be having the same number of houses.\\n\\n**Number of ways of placing house on street1 == Number of ways of placing house on street2**\\n\\nIf the question would have restricted from not allowing opposite houses then the question would be harder.\\n\\n# C++\\tMemoized\\n\\tlong long mod= 1e9+7;\\n    long dp[10001];\\n    long func(int n){\\n        if(n<0) return 1;\\n        if(dp[n]>=0) return dp[n];\\n        return dp[n]= (func(n-1)+func(n-2))%mod;\\n    }\\n    \\n    int countHousePlacements(int n) {\\n        memset(dp,-1,sizeof dp);\\n        long long cnt=func(n-1);\\n        return (cnt*cnt)%mod;\\n    }\\n\\t\\n# C++ DP\\n    long long mod= 1e9+7;\\n    int countHousePlacements(int n) {\\n        long dp[n+1];\\n        dp[0]=1; dp[1]=2;\\n        for(int i=2;i<=n;i++) dp[i]= (dp[i-1]+dp[i-2])%mod;\\n        return (dp[n]*dp[n])%mod;\\n    }\\n# C++ DP+SPACE OPTIMISED\\nWe can see in the above approach that we are always dependent upon last two states , so why we are using whole array. \\nWE can simply use two variable and track the value of last two states.\\n\\n    long long mod= 1e9+7;\\n    int countHousePlacements(int n) {\\n        long first=1, second=2;\\n        for(int i=2;i<=n;i++){\\n            long current= (first+second)%mod;\\n            first=second;\\n            second=current;\\n        }\\n        return (second*second)%mod;\\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "\\n**Intution**\\n\\nThe Observation:\\n> Both Streets are of same size and opposite houses are allowed\\n\\nWe can take advantage of above fact and just count ways of putting the houses in **n plots** over a single street and those ways will pair with every ways corresponding to opoosite street which will be having the same number of houses.\\n\\n**Number of ways of placing house on street1 == Number of ways of placing house on street2**\\n\\nIf the question would have restricted from not allowing opposite houses then the question would be harder.\\n\\n# C++\\tMemoized\\n\\tlong long mod= 1e9+7;\\n    long dp[10001];\\n    long func(int n){\\n        if(n<0) return 1;\\n        if(dp[n]>=0) return dp[n];\\n        return dp[n]= (func(n-1)+func(n-2))%mod;\\n    }\\n    \\n    int countHousePlacements(int n) {\\n        memset(dp,-1,sizeof dp);\\n        long long cnt=func(n-1);\\n        return (cnt*cnt)%mod;\\n    }\\n\\t\\n# C++ DP\\n    long long mod= 1e9+7;\\n    int countHousePlacements(int n) {\\n        long dp[n+1];\\n        dp[0]=1; dp[1]=2;\\n        for(int i=2;i<=n;i++) dp[i]= (dp[i-1]+dp[i-2])%mod;\\n        return (dp[n]*dp[n])%mod;\\n    }\\n# C++ DP+SPACE OPTIMISED\\nWe can see in the above approach that we are always dependent upon last two states , so why we are using whole array. \\nWE can simply use two variable and track the value of last two states.\\n\\n    long long mod= 1e9+7;\\n    int countHousePlacements(int n) {\\n        long first=1, second=2;\\n        for(int i=2;i<=n;i++){\\n            long current= (first+second)%mod;\\n            first=second;\\n            second=current;\\n        }\\n        return (second*second)%mod;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2198333,
                "title": "memorization-tabulation-space-optimisation",
                "content": "0 -> house was not placed on current side plot in previous index \\n     1 -> house was placed on current side plot in previous index \\n \\n     state : left right\\n     0 ->     0   0 \\n     1 ->     0   1\\n     2 ->     1   0\\n     3 ->     1   1\\n\\t \\n\\t \\n\\t\\n **Recursion + Memorisation :**\\n\\t \\n     `class Solution {\\n       public:\\n          int mod=(1e9+7);\\n          int countWays(int n,int state,vector<vector<int>> &dp){\\n          if(n<=0) return 1;\\n        \\n          if(dp[n][state]!=-1) return dp[n][state]%mod;\\n        \\n          int a=0,b=0,c=0,d=0;\\n        \\n          if(state!=2 && state!=3)\\n          a=countWays(n-1,2,dp);\\n        \\n          if(state!=1 && state!=3)\\n          b=countWays(n-1,1,dp);\\n        \\n          if(state==0)\\n          c=countWays(n-1,3,dp);\\n\\n          d=countWays(n-1,0,dp);\\n          return dp[n][state]=(((a+b)%mod+c)%mod+d)%mod;\\n    }\\n    int countHousePlacements(int n) {\\n        vector<vector<int>> dp(n+1,vector<int>(4,-1));\\n        return countWays(n,0,dp)%mod;\\n    }\\n     };`\\n\\nTC: O( n * 4)\\nSC: O( n * 4) +O( n )\\n\\n\\n**Tabulation :**\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=(1e9+7);\\n    int countHousePlacements(int n) {\\n        vector<vector<int>> dp(n+1,vector<int>(4,0));\\n        dp[0][0]=1;\\n        dp[0][1]=1;       \\n        dp[0][2]=1;\\n        dp[0][3]=1;\\n\\n        for(int i=1;i<=n;i++){\\n            for(int state=0;state<=3;state++){\\n                  int a=0,b=0,c=0,d=0;\\n        \\n                  if(state!=2 && state!=3)\\n                  a=dp[i-1][2];\\n\\n                  if(state!=1 && state!=3)\\n                  b=dp[i-1][1];\\n\\n                  if(state==0)\\n                  c=dp[i-1][3];\\n\\n                  d=dp[i-1][0];\\n                \\n                  dp[i][state]=(((a+b)%mod+c)%mod+d)%mod;\\n            }\\n          }\\n        return dp[n][0];\\n    }\\n};\\n```\\nTC: O( n * 4)\\nSC: O( n * 4)\\n\\n**Space Optimised Dp:**\\n```\\nclass Solution {\\npublic:\\n    int mod=(1e9+7);\\n    int countHousePlacements(int n) {\\n        vector<int> prev(4,1);\\n        for(int i=1;i<=n;i++){\\n            vector<int> curr(4,0);\\n            for(int state=0;state<=3;state++){\\n                  int a=0,b=0,c=0,d=0;\\n        \\n                  if(state!=2 && state!=3)\\n                  a=prev[2];\\n\\n                  if(state!=1 && state!=3)\\n                  b=prev[1];\\n\\n                  if(state==0)\\n                  c=prev[3];\\n\\n                  d=prev[0];\\n                \\n                  curr[state]=(((a+b)%mod+c)%mod+d)%mod;\\n            }\\n            prev=curr;\\n          }\\n        return prev[0];\\n    }\\n};\\n```\\nTC: O( n * 4)\\nSC: O( 2 * 4 )\\n\\n**Please upvote if it helps \\uD83D\\uDE0A**\\n**Thanks Striver for teaching DP so well**\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=(1e9+7);\\n    int countHousePlacements(int n) {\\n        vector<vector<int>> dp(n+1,vector<int>(4,0));\\n        dp[0][0]=1;\\n        dp[0][1]=1;       \\n        dp[0][2]=1;\\n        dp[0][3]=1;\\n\\n        for(int i=1;i<=n;i++){\\n            for(int state=0;state<=3;state++){\\n                  int a=0,b=0,c=0,d=0;\\n        \\n                  if(state!=2 && state!=3)\\n                  a=dp[i-1][2];\\n\\n                  if(state!=1 && state!=3)\\n                  b=dp[i-1][1];\\n\\n                  if(state==0)\\n                  c=dp[i-1][3];\\n\\n                  d=dp[i-1][0];\\n                \\n                  dp[i][state]=(((a+b)%mod+c)%mod+d)%mod;\\n            }\\n          }\\n        return dp[n][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod=(1e9+7);\\n    int countHousePlacements(int n) {\\n        vector<int> prev(4,1);\\n        for(int i=1;i<=n;i++){\\n            vector<int> curr(4,0);\\n            for(int state=0;state<=3;state++){\\n                  int a=0,b=0,c=0,d=0;\\n        \\n                  if(state!=2 && state!=3)\\n                  a=prev[2];\\n\\n                  if(state!=1 && state!=3)\\n                  b=prev[1];\\n\\n                  if(state==0)\\n                  c=prev[3];\\n\\n                  d=prev[0];\\n                \\n                  curr[state]=(((a+b)%mod+c)%mod+d)%mod;\\n            }\\n            prev=curr;\\n          }\\n        return prev[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198710,
                "title": "easy-java-with-complete-explanation-dp-100-faster",
                "content": "**Approach**\\nThe question is similar to the question \" Count subsets such that no adjacent elements are included\".\\n->An element would be included only when previous element is not included.\\n->An element can be excluded anytime. It does\\'nt matter if previous element is included or not.\\n\\nLets talk about the arrangements on one side of the road.\\nThere are n plots numbered [1,n] on which houses(similar) can be placed.\\nLets talk  about possible arrangements for n ranging from [1,n].\\n\\n**For n==1,** ( _ )\\nIf we place a house \"H\".\\nIf we don\\'t place a house \" _\"\\n\\n**For n==2**( _ _ )\\nThe second plot can have a house and cannot have a house.\\nIf plot 2  have a house then it is possible only when plot 1 do not have a house. Correct?(Question constraint)\\nAnd if plot 2 does not have a house then it is possible that plot 1 may have a house or may not have a house.\\nSo the possible arrangements are:-\\n_ H                (plot 2 has a house)\\n_ _\\nH _                (plot 2 do not have a house). \\n\\n**For n==3** ( _ _ _ )\\nI\\'ll disscuss till here, then we would disscuss what pattern do we see.\\n1) If plot 3  have a house then it is possible only when plot 2 does not have a house. Correct?(Question constraint). \\nSo number of arrangements if plot 3 have a house would be equal to the number of arrangements if plot 2 do not have a house. (Think about it).\\nSo we had arrangements for plot 2 not having a house as : - { _ _ , H _ }\\nSo arrangements for plot 3 having a house would be 3  getting appended to those arrangements. { _ _ H , H _ H}.\\n\\n  2. And if plot 3 does not have a house then it is possible that plot 2 may have a house or may not have a house.\\nSo number of arrangemenrs if plot 3 does not have a house would be equal to the sum of arrangements :\\n1)If plot 2 have a house \\n2)If plot 2 does not have a house. \\ni.e all the possible arrangements for plot 2. (Since plot three has no house)\\n{ _ _ _ , H _ _ , _ H _ }.\\n\\nThrefore total arrangement for n = 3 would be 2 + 3 = 5.\\n\\n\\n\\n**Using a 2-D array for calculating possible arrangements for any n i.e applying DP based on the observation\"\"\\n\\n**1) Storage:-** We would have a 2-D array with only two rows. Columns would range from 1->n and row as 0&1.\\n   **Meaning**:- For any column i, \\n   Row 0 tells us the number of possible arrangements when there is a house at ith plot. \\n   Row 1 tells us the number of possible arrangements when there is not a house at ith plot.\\n   \\n   **2)Direction:-** We would solve from left to right . As n=1 is smaller problem.\\n   \\n   **3)Solving:-**\\n  \\n   For i=1, dp[0][1] = 1; and dp[1][1] = 1. (Obviously).\\n   For i = 2,\\n   dp[0][2] tells all possible arrangements if plot 2 has a house. This is nothing but all possible arrangements when 1 do not have a house. (Disscussed above) .\\n   Therefore dp[0][2]  = dp[1][1];\\n   \\n   dp[1][2] tells all possible arrangements if plot 2 does not have a house. This is nothing but all possible arrangements when 1 do not have a house + 1 have a house (Disscussed above) .\\n   Therefore dp[1][2]  = dp[1][1] + dp[0][1];\\n   \\n   Can you see the pattern ???\\n   \\n   For i == 3,\\n    dp[0][3] tells all possible arrangements if plot 3 has a house. This is nothing but all possible arrangements when plot 2 do not have a house. (Disscussed above) .\\n   Therefore dp[0][3]  = dp[1][2];\\n   \\n   dp[1][3] tells all possible arrangements if plot 3 does not have a house. This is nothing but all possible arrangements when 2 do not have a house + 2 have a house (Disscussed above) .\\n   Therefore dp[1][3]  = dp[1][2] + dp[0][2];\\n   \\n   I hope you have seen the pattern. \\n   \\n **  **For i= i,\\n   dp[0][i] = dp[1][i-1]\\n   dp[1][i] = dp[1][i-1] + dp[0][i-1].**\\n   \\n   However, the question does not end here. We have two such sides. \\n   Don\\'t worry. The answer would be (totalways for one side) ^2. Because for every way \"ways\" , we can have same no of \"ways\" for the second plot. \\n   \\n   Here\\'s the code for the problem\\n   \\n   ```\\n    public int countHousePlacements(int n) {\\n        int[][] dp = new int[2][n+1];\\n        dp[0][1] = 1;\\n        dp[1][1] = 1;\\n        for(int i = 2 ; i < dp[0].length ; i++){\\n            dp[0][i] = dp[1][i-1]%mod;\\n            dp[1][i] = (dp[0][i-1]%mod + dp[1][i-1]%mod)%mod;\\n        }\\n        long ways = (dp[0][n]+dp[1][n])%mod;\\n        return (int)((ways*ways)%mod);\\n\\t\\t}\\n\\t\\n   Below is optimized DP , i.e. Since we only require two variables (analysis) , we can remove this 2-D space complexity.\\n   \\n    class Solution {\\n    int mod = (int)1e9 + 7;\\n    public int countHousePlacements(int n) {\\n        long no = 1;\\n        long yes = 1;\\n        for(int i = 2 ; i<=n ; i++){\\n            long newyes  = no%mod;\\n            long newno = (no%mod + yes%mod)%mod;\\n            no = newno;\\n            yes = newyes;\\n        }\\n        long ways = (yes+no)%mod;\\n        return (int)((ways*ways)%mod);\\n    }\\n}\\n```\\n\\n   \\n   \\n   \\n   \\n   \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int countHousePlacements(int n) {\\n        int[][] dp = new int[2][n+1];\\n        dp[0][1] = 1;\\n        dp[1][1] = 1;\\n        for(int i = 2 ; i < dp[0].length ; i++){\\n            dp[0][i] = dp[1][i-1]%mod;\\n            dp[1][i] = (dp[0][i-1]%mod + dp[1][i-1]%mod)%mod;\\n        }\\n        long ways = (dp[0][n]+dp[1][n])%mod;\\n        return (int)((ways*ways)%mod);\\n\\t\\t}\\n\\t\\n   Below is optimized DP , i.e. Since we only require two variables (analysis) , we can remove this 2-D space complexity.\\n   \\n    class Solution {\\n    int mod = (int)1e9 + 7;\\n    public int countHousePlacements(int n) {\\n        long no = 1;\\n        long yes = 1;\\n        for(int i = 2 ; i<=n ; i++){\\n            long newyes  = no%mod;\\n            long newno = (no%mod + yes%mod)%mod;\\n            no = newno;\\n            yes = newyes;\\n        }\\n        long ways = (yes+no)%mod;\\n        return (int)((ways*ways)%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198206,
                "title": "count-number-of-ways-to-place-houses-java-solution",
                "content": "```\\nclass Solution {\\n    int mod = (int)1e9+7;\\n    public int countHousePlacements(int n) {\\n        \\n        if(n == 1)\\n            return 4;\\n        if(n == 2)\\n            return 9;\\n        long a = 2;\\n        long b = 3;\\n        if(n==1)\\n            return (int)(a%mod);\\n        if(n==2)\\n            return (int)(b%mod);\\n        long c=0;\\n        for(int i=3;i<=n;i++)\\n        {\\n            c = (a+b)%mod;\\n            a=b%mod;\\n            b=c%mod;\\n        }\\n        \\n        return (int)((c*c)%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)1e9+7;\\n    public int countHousePlacements(int n) {\\n        \\n        if(n == 1)\\n            return 4;\\n        if(n == 2)\\n            return 9;\\n        long a = 2;\\n        long b = 3;\\n        if(n==1)\\n            return (int)(a%mod);\\n        if(n==2)\\n            return (int)(b%mod);\\n        long c=0;\\n        for(int i=3;i<=n;i++)\\n        {\\n            c = (a+b)%mod;\\n            a=b%mod;\\n            b=c%mod;\\n        }\\n        \\n        return (int)((c*c)%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2216251,
                "title": "easy-python-fibonacci-no-dp-w-explanation-beats-80",
                "content": "![image](https://assets.leetcode.com/users/images/b6e798ab-f43d-43e6-950c-b09487833a9d_1656562087.0694184.png)\\n\\n```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        # Calculate basic fibonacci first\\n\\t\\ta,b=0,1\\n        for i in range(n+1):  #Since we need the square of the next number, so n+1. Eg : ans for 3 is 5^2.\\n            a,b=b,a+b\\n        return (b*b)%((10**9)+7) \\n\\t\\t#Return the fibb b*b and add the condition given in question directly. Simply modulo your answer to (10^9)+7\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        # Calculate basic fibonacci first\\n\\t\\ta,b=0,1\\n        for i in range(n+1):  #Since we need the square of the next number, so n+1. Eg : ans for 3 is 5^2.\\n            a,b=b,a+b\\n        return (b*b)%((10**9)+7) \\n\\t\\t#Return the fibb b*b and add the condition given in question directly. Simply modulo your answer to (10^9)+7\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198850,
                "title": "c-easy-and-best-approach",
                "content": "\\'\\'\\'\\n\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        long long ans=0;\\n        long long prepre=1;\\n        long long pre=1;\\n        long long mod=1e9+7;\\n        for(int i=0;i<n;i++){\\n            ans=(pre+prepre)%mod;\\n            prepre=pre;\\n            pre=ans;\\n        }\\n        return (int)((ans*ans)%mod);\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        long long ans=0;\\n        long long prepre=1;\\n        long long pre=1;\\n        long long mod=1e9+7;\\n        for(int i=0;i<n;i++){\\n            ans=(pre+prepre)%mod;\\n            prepre=pre;\\n            pre=ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2198527,
                "title": "understand-the-pattern-to-get-the-approach-code-with-comments",
                "content": "When you try to find the answers for first 4 n-values, you will get :\\nn->square of number->ans\\n1-> \\t         2\\t->\\t  4\\n2\\t\\t->\\t     3\\t->       9\\n3\\t->\\t    5\\t->       25\\t\\n4\\t->\\t    8\\t->\\t       64\\n\\nSo,if you want to find for n=3, you have add two previous square of number.\\nSo it\\'s basically a fibonacii series.\\nUse fibonacci approach to find n-value andd then square the value using power modulo function as its value is very large.\\n\\n TC : O(n)    for calculating dp[n].\\n SC : O(n)    for dp array\\n \\n Code :\\n```\\nclass Solution {\\npublic:\\n    long long power(int n,int x,long long mod){     //power modulo function to calculate square\\n        long long ans=1;\\n        while(x>0){\\n            if(x%2){\\n                ans*=n;\\n                ans%=mod;\\n                x--;\\n            }\\n            else{\\n                ans*=n;\\n                ans%=mod;\\n                x/=2;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int countHousePlacements(int n) {\\n        long long mod=1e9+7;\\n        long long dp[n+1];\\n        dp[0]=1,dp[1]=2;\\n        for(long long i=2;i<=n;i++)    //calculating fibonacci series\\n            dp[i]=(dp[i-1]+dp[i-2])%mod;\\n        return power(dp[n],2,mod);       //squaring the number and returning answer\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long power(int n,int x,long long mod){     //power modulo function to calculate square\\n        long long ans=1;\\n        while(x>0){\\n            if(x%2){\\n                ans*=n;\\n                ans%=mod;\\n                x--;\\n            }\\n            else{\\n                ans*=n;\\n                ans%=mod;\\n                x/=2;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int countHousePlacements(int n) {\\n        long long mod=1e9+7;\\n        long long dp[n+1];\\n        dp[0]=1,dp[1]=2;\\n        for(long long i=2;i<=n;i++)    //calculating fibonacci series\\n            dp[i]=(dp[i-1]+dp[i-2])%mod;\\n        return power(dp[n],2,mod);       //squaring the number and returning answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198296,
                "title": "using-fibonacci-number-square",
                "content": "```\\nclass Solution {\\npublic:\\n    int m = 1000000007;\\n    int countHousePlacements(int n) {\\n        long long a = 1, b = 1, c;\\n        \\n        while(n--){\\n            c = (a + b) % m;\\n            a = b;\\n            b = c;\\n        }\\n        \\n        c = (c * c) % m;\\n            \\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m = 1000000007;\\n    int countHousePlacements(int n) {\\n        long long a = 1, b = 1, c;\\n        \\n        while(n--){\\n            c = (a + b) % m;\\n            a = b;\\n            b = c;\\n        }\\n        \\n        c = (c * c) % m;\\n            \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198157,
                "title": "easy-dp-solution-fibonacci-pattern-java",
                "content": "Idea is at each place we have 2 choices either place a house at current place or don\\'t place a house at current place.\\nSo traverse both the possiblities and their sum of both the ways will be answer for that iteration.\\n\\n```\\nclass Solution {\\n    long m = 1000000007;\\n    long[] dp;\\n    \\n    public int countHousePlacements(int n) {\\n        this.dp = new long[n+1];\\n        Arrays.fill(this.dp, -1);\\n        long ans = this.solve(n);\\n        return (int)((ans* ans)%this.m);\\n        \\n    }\\n    \\n    // Returns all possible ways we can palce houses in N palces\\n    public long solve(int n){\\n        \\n        // base case (no place left to place a new home)\\n        if(n <= 0){\\n            return 1;\\n        }\\n        \\n        // Early return\\n        if(dp[n] != -1){\\n            return this.dp[n];\\n        }\\n        \\n        long usedCurrPlace = 1L * this.solve(n-2);\\n        long notUsedCurrPlace = 1L * this.solve(n-1);\\n        \\n        return this.dp[n] = (usedCurrPlace + notUsedCurrPlace)%this.m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    long m = 1000000007;\\n    long[] dp;\\n    \\n    public int countHousePlacements(int n) {\\n        this.dp = new long[n+1];\\n        Arrays.fill(this.dp, -1);\\n        long ans = this.solve(n);\\n        return (int)((ans* ans)%this.m);\\n        \\n    }\\n    \\n    // Returns all possible ways we can palce houses in N palces\\n    public long solve(int n){\\n        \\n        // base case (no place left to place a new home)\\n        if(n <= 0){\\n            return 1;\\n        }\\n        \\n        // Early return\\n        if(dp[n] != -1){\\n            return this.dp[n];\\n        }\\n        \\n        long usedCurrPlace = 1L * this.solve(n-2);\\n        long notUsedCurrPlace = 1L * this.solve(n-1);\\n        \\n        return this.dp[n] = (usedCurrPlace + notUsedCurrPlace)%this.m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322002,
                "title": "c-noob-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long fib(long long n,vector<int>&dp)\\n{\\n    if (n == 1)\\n        return 2;\\n    if (n==2){\\n        return 3;\\n    }\\n    if(dp[n]!=-1){\\n        return dp[n]; \\n    }\\n    return dp[n]=(fib(n-1,dp) + fib(n-2,dp))%mod;\\n}\\n    int countHousePlacements(int n) {\\n        vector<int>dp(n+1,-1);\\n       long long int ans=fib(n,dp)%mod; \\n        return (ans*ans)%mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long fib(long long n,vector<int>&dp)\\n{\\n    if (n == 1)\\n        return 2;\\n    if (n==2){\\n        return 3;\\n    }\\n    if(dp[n]!=-1){\\n        return dp[n]; \\n    }\\n    return dp[n]=(fib(n-1,dp) + fib(n-2,dp))%mod;\\n}\\n    int countHousePlacements(int n) {\\n        vector<int>dp(n+1,-1);\\n       long long int ans=fib(n,dp)%mod; \\n        return (ans*ans)%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209805,
                "title": "recurrence-relation-notebook-explanation",
                "content": "**Here is my explanation- **\\n\\n![image](https://assets.leetcode.com/users/images/fd281920-3b2e-4231-bc40-b6ce63462a62_1656422027.580178.jpeg)\\n![image](https://assets.leetcode.com/users/images/a601137b-1fad-4d95-84af-73089feabff6_1656422021.713805.jpeg)\\nHere is the code for the above explanation - \\n\\n```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        \\n         long mod = 1000000007;\\n         long prevA = 1;\\n         long prevB = 1;\\n         long prevC = 1;\\n         long prevD = 1;\\n         long total = 4;\\n         long tempA, tempB, tempC, tempD;\\n        for(int i = 2;i<=n;i++){\\n            tempA=prevA%mod;\\n            tempB=prevB%mod;\\n            tempC=prevC%mod;\\n            tempD=prevD%mod;\\n            prevA=total%mod;\\n            prevB=(tempA%mod+tempC%mod)%mod;\\n            prevC=(tempA%mod+tempB%mod)%mod;\\n            prevD=tempA%mod;\\n            total = (prevA%mod+prevB%mod+prevC%mod+prevD%mod)%mod;\\n        }\\n        return (int)total;\\n    }\\n}\\n```\\n\\n**Comment if any doubt.. and Do upvote if you understand the solution .**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        \\n         long mod = 1000000007;\\n         long prevA = 1;\\n         long prevB = 1;\\n         long prevC = 1;\\n         long prevD = 1;\\n         long total = 4;\\n         long tempA, tempB, tempC, tempD;\\n        for(int i = 2;i<=n;i++){\\n            tempA=prevA%mod;\\n            tempB=prevB%mod;\\n            tempC=prevC%mod;\\n            tempD=prevD%mod;\\n            prevA=total%mod;\\n            prevB=(tempA%mod+tempC%mod)%mod;\\n            prevC=(tempA%mod+tempB%mod)%mod;\\n            prevD=tempA%mod;\\n            total = (prevA%mod+prevB%mod+prevC%mod+prevD%mod)%mod;\\n        }\\n        return (int)total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207716,
                "title": "dynamic-programming",
                "content": "**** vector<vector<long long >> dp(N+1,vector<long long>(2,0));\\n\\t  *  dp[0][0]=1;dp[0][1]=1;\\n\\t    long long mod=1000000007;\\n\\t    for(int i=1;i<=N;i++){\\n\\t        dp[i][0]=(dp[i-1][0]+dp[i-1][1])%mod;\\n\\t        dp[i][1]=dp[i-1][0];\\n\\t    }\\n\\t    return (dp[N][0]*dp[N][0])%mod;",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "**** vector<vector<long long >> dp(N+1,vector<long long>(2,0));\\n\\t  *  dp[0][0]=1;dp[0][1]=1;\\n\\t    long long mod=1000000007;\\n\\t    for(int i=1;i<=N;i++){\\n\\t        dp[i][0]=(dp[i-1][0]+dp[i-1][1])%mod;\\n\\t        dp[i][1]=dp[i-1][0];\\n\\t    }\\n\\t    return (dp[N][0]*dp[N][0])%mod;",
                "codeTag": "Unknown"
            },
            {
                "id": 2202547,
                "title": "easy-dp-kotlin-solution-faster-than-100",
                "content": "Kotlin code:\\n```\\n    fun countHousePlacements(n: Int): Int {\\n        val mod = 1000000007\\n        val street = LongArray(n + 1)\\n        street[0] = 1\\n        street[1] = 2\\n        for (i in 2..n) {\\n            street[i] = ((street[i - 1] % mod) + (street[i - 2] % mod)) % mod\\n        }\\n        val count = street[n]\\n        return ((((count) % mod) * ((count) % mod)) % mod).toInt()\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    fun countHousePlacements(n: Int): Int {\\n        val mod = 1000000007\\n        val street = LongArray(n + 1)\\n        street[0] = 1\\n        street[1] = 2\\n        for (i in 2..n) {\\n            street[i] = ((street[i - 1] % mod) + (street[i - 2] % mod)) % mod\\n        }\\n        val count = street[n]\\n        return ((((count) % mod) * ((count) % mod)) % mod).toInt()\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200319,
                "title": "javascript",
                "content": "```\\nconst countHousePlacements = function(n) {\\n  const MOD = 1000000007n\\n  let house = 1n\\n  let space = 1n\\n  let total = house + space\\n\\n  for (let i = 2; i < n + 1; i++) {\\n    house = space\\n    space = total\\n    total = (house + space) % MOD\\n  }\\n\\n  return (total * total) % MOD\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst countHousePlacements = function(n) {\\n  const MOD = 1000000007n\\n  let house = 1n\\n  let space = 1n\\n  let total = house + space\\n\\n  for (let i = 2; i < n + 1; i++) {\\n    house = space\\n    space = total\\n    total = (house + space) % MOD\\n  }\\n\\n  return (total * total) % MOD\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198470,
                "title": "c-dp-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    \\n    // state -> index, placed before or not\\n    long long dp[10003][2];\\n    int n;\\n    \\n    int rec(int level,int prev){\\n        // if taken choices for all index \\n        if(level == n){\\n            return 1;\\n        }\\n        if(dp[level][prev] !=-1) return dp[level][prev];\\n        long long ans = 0;\\n        \\n        // if previously not placed we can place here or not place also\\n        if(prev == 0){\\n            ans+=rec(level+1,0);\\n            ans%=mod;\\n            ans+=rec(level+1,1);\\n            ans%=mod;\\n        }\\n        // if previously places we shouldnt place here\\n        if(prev == 1){\\n            ans+=rec(level+1,0);\\n            ans%=mod;\\n        }\\n        return dp[level][prev]  =ans;\\n    }\\n    \\n    int countHousePlacements(int _n) {\\n        n = _n;\\n        memset(dp,-1,sizeof(dp));\\n        long long ans = rec(0,0);\\n        ans%=mod;\\n        \\n        // if answer for one side is ans then its same for other side, and final answer is ans*ans\\n        ans*=ans;\\n        ans%=mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    \\n    // state -> index, placed before or not\\n    long long dp[10003][2];\\n    int n;\\n    \\n    int rec(int level,int prev){\\n        // if taken choices for all index \\n        if(level == n){\\n            return 1;\\n        }\\n        if(dp[level][prev] !=-1) return dp[level][prev];\\n        long long ans = 0;\\n        \\n        // if previously not placed we can place here or not place also\\n        if(prev == 0){\\n            ans+=rec(level+1,0);\\n            ans%=mod;\\n            ans+=rec(level+1,1);\\n            ans%=mod;\\n        }\\n        // if previously places we shouldnt place here\\n        if(prev == 1){\\n            ans+=rec(level+1,0);\\n            ans%=mod;\\n        }\\n        return dp[level][prev]  =ans;\\n    }\\n    \\n    int countHousePlacements(int _n) {\\n        n = _n;\\n        memset(dp,-1,sizeof(dp));\\n        long long ans = rec(0,0);\\n        ans%=mod;\\n        \\n        // if answer for one side is ans then its same for other side, and final answer is ans*ans\\n        ans*=ans;\\n        ans%=mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198220,
                "title": "fibonacci-python-beginner-friendly",
                "content": "The only idea here is to understand the pattern that it is a fibonacci series.\\n\\nn =1 --> 4\\nn =2 --> 9\\nn =3 --> 25\\n\\nwhich means\\n1->2 squares\\n2->3 squares\\n3->5 squares\\n\\nthus 3rd element was composed of 1st+2nd.\\n\\n\\n\\n```\\n\\n\\t\\tdp = [-1]*(n+2)\\n        dp[0] = 1\\n        dp[1] = 2\\n        \\n        for i in range(2,n+1):\\n            dp[i] = dp[i-1]+dp[i-2]\\n        \\n        return dp[n]*dp[n] % (10**9 + 7)\\n\\n```\\n\\n\\nPS: Uploaded it on my channel too.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\n\\t\\tdp = [-1]*(n+2)\\n        dp[0] = 1\\n        dp[1] = 2\\n        \\n        for i in range(2,n+1):\\n            dp[i] = dp[i-1]+dp[i-2]\\n        \\n        return dp[n]*dp[n] % (10**9 + 7)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198213,
                "title": "python-2d-dp",
                "content": "1. This problem can be solved using recursion, but will lead to TLE for large values of n.\\n2. We can use DP for that purpose.\\n3. Somewhat similar to [Biweekly Contest 81\\'s 2318. Number of Distinct Roll Sequences Problem](https://leetcode.com/problems/number-of-distinct-roll-sequences/).\\n4. 2D DP array stores results of with 2 properties that are: `[Current_plot_number] & [Can_we_build_on_this_plot]`\\n```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        dp = [[-1] * 2 for _ in range(n)]\\n        def helper(plot, can_build):\\n            if plot == n:\\n                return 1\\n            if dp[plot][can_build] == -1:\\n                ans = 0\\n                if not can_build: \\n\\t\\t\\t\\t\\tans += helper(plot + 1, True) # If we cannot build then we can build on the next plot/\\n                else: \\n\\t\\t\\t\\t\\tans += helper(plot + 1, False) + helper(plot + 1, True) # If we can build then we have an option to either build or not to build.\\n                dp[plot][can_build] = ans\\n            return dp[plot][can_build]\\n        helper(0, True)\\n        return (dp[0][1] ** 2) % 1000000007 # We use dp[0][1] as we started at plot 0 and we could have built on that plot due to lack of any previous plots.\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        dp = [[-1] * 2 for _ in range(n)]\\n        def helper(plot, can_build):\\n            if plot == n:\\n                return 1\\n            if dp[plot][can_build] == -1:\\n                ans = 0\\n                if not can_build: \\n\\t\\t\\t\\t\\tans += helper(plot + 1, True) # If we cannot build then we can build on the next plot/\\n                else: \\n\\t\\t\\t\\t\\tans += helper(plot + 1, False) + helper(plot + 1, True) # If we can build then we have an option to either build or not to build.\\n                dp[plot][can_build] = ans\\n            return dp[plot][can_build]\\n        helper(0, True)\\n        return (dp[0][1] ** 2) % 1000000007 # We use dp[0][1] as we started at plot 0 and we could have built on that plot due to lack of any previous plots.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198202,
                "title": "c-easy-to-understand-fibonacci",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n            int m = 1e9+7;\\n        if(n == 1)\\n            return 4;\\n        if(n == 2)\\n            return 9;\\n        long long int a = 2;\\n        long long int b = 3;\\n        int i = 2;\\n        long long int c;\\n        while(i<n)\\n        {\\n             c = (a%m+b%m)%m;\\n             a = b;\\n             b = c;\\n             i++;\\n        }\\n        return ((c%m)*(c%m))%m;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n            int m = 1e9+7;\\n        if(n == 1)\\n            return 4;\\n        if(n == 2)\\n            return 9;\\n        long long int a = 2;\\n        long long int b = 3;\\n        int i = 2;\\n        long long int c;\\n        while(i<n)\\n        {\\n             c = (a%m+b%m)%m;\\n             a = b;\\n             b = c;\\n             i++;\\n        }\\n        return ((c%m)*(c%m))%m;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192488,
                "title": "c-solution-fibonacci-series",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        if(n== 1) return 4;\\n        if(n== 2) return 9;\\n        \\n        int one= 2,two=3,temp, M= 1e9+7;\\n        n-=2;\\n        while(n--){\\n            temp= two;\\n            two= (one+two)%M;\\n            one= temp;\\n        }\\n        \\n        return (1LL*two*two) % M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        if(n== 1) return 4;\\n        if(n== 2) return 9;\\n        \\n        int one= 2,two=3,temp, M= 1e9+7;\\n        n-=2;\\n        while(n--){\\n            temp= two;\\n            two= (one+two)%M;\\n            one= temp;\\n        }\\n        \\n        return (1LL*two*two) % M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356692,
                "title": "o-n-simple-fibonacci-sequence",
                "content": "\\n\\n\\t\\t\\t\\tprivate static final int MOD = 1000000007;\\n\\t\\t\\t\\tpublic int countHousePlacements(int n) {\\n\\t\\t\\t\\t\\t\\tlong a = 1, b = 1, ans = 1;\\n\\t\\t\\t\\t\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\t\\t\\t\\t\\t\\tans = a+b;\\n\\t\\t\\t\\t\\t\\t\\t\\tb = a%MOD;\\n\\t\\t\\t\\t\\t\\t\\t\\ta = ans%MOD;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn (int)(ans*ans%MOD);      \\n\\t\\t\\t\\t}",
                "solutionTags": [],
                "code": "\\n\\n\\t\\t\\t\\tprivate static final int MOD = 1000000007;\\n\\t\\t\\t\\tpublic int countHousePlacements(int n) {\\n\\t\\t\\t\\t\\t\\tlong a = 1, b = 1, ans = 1;\\n\\t\\t\\t\\t\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\t\\t\\t\\t\\t\\tans = a+b;\\n\\t\\t\\t\\t\\t\\t\\t\\tb = a%MOD;\\n\\t\\t\\t\\t\\t\\t\\t\\ta = ans%MOD;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn (int)(ans*ans%MOD);      \\n\\t\\t\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2322011,
                "title": "c-very-basic-soo-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        if(n==1)return 4;\\n        if(n==2)return 9;\\n        long long a=2,b=3;\\n        long long c=0;\\n        for(int i=3;i<=n;i++){\\n            c=(a+b)%1000000007;\\n            a=b;\\n            b=c;\\n        }\\n        return c*c%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        if(n==1)return 4;\\n        if(n==2)return 9;\\n        long long a=2,b=3;\\n        long long c=0;\\n        for(int i=3;i<=n;i++){\\n            c=(a+b)%1000000007;\\n            a=b;\\n            b=c;\\n        }\\n        return c*c%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208842,
                "title": "c-recursion-memoization-tabulation-dynamic-programming",
                "content": "Recursion ( TLE )\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int placedHouses(int n){\\n        if(n<=0) return 1;\\n        int ans=0;\\n        ans+=placedHouses(n-2)%mod+placedHouses(n-1)%mod;\\n        return ans%mod;\\n    }\\n    int countHousePlacements(int n) {\\n        long long ans= placedHouses(n)%mod;\\n        ans = (ans%mod*ans%mod)%mod;\\n        return ans;\\n    }\\n};\\n```\\n\\nRecursion + Memoization ( Accepted )\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int dp[10001];\\n    int placedHouses(int n){\\n        if(n<=0) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int ans=0;\\n        ans+=placedHouses(n-2)%mod+placedHouses(n-1)%mod;\\n        return dp[n]=ans%mod;\\n    }\\n    int countHousePlacements(int n) {\\n        memset(dp,-1,sizeof dp);\\n        long long ans= placedHouses(n)%mod;\\n        ans = (ans%mod*ans%mod)%mod;\\n        return ans;\\n    }\\n};\\n```\\nTabulation ( Accepted )\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int countHousePlacements(int n) {\\n        long long dp[n+1];\\n        dp[0]=1;\\n        dp[1]=2;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=(dp[i-1]%mod+dp[i-2]%mod)%mod;\\n        }\\n        long long ans=(dp[n]%mod*dp[n]%mod)%mod;\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int placedHouses(int n){\\n        if(n<=0) return 1;\\n        int ans=0;\\n        ans+=placedHouses(n-2)%mod+placedHouses(n-1)%mod;\\n        return ans%mod;\\n    }\\n    int countHousePlacements(int n) {\\n        long long ans= placedHouses(n)%mod;\\n        ans = (ans%mod*ans%mod)%mod;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int dp[10001];\\n    int placedHouses(int n){\\n        if(n<=0) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int ans=0;\\n        ans+=placedHouses(n-2)%mod+placedHouses(n-1)%mod;\\n        return dp[n]=ans%mod;\\n    }\\n    int countHousePlacements(int n) {\\n        memset(dp,-1,sizeof dp);\\n        long long ans= placedHouses(n)%mod;\\n        ans = (ans%mod*ans%mod)%mod;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int countHousePlacements(int n) {\\n        long long dp[n+1];\\n        dp[0]=1;\\n        dp[1]=2;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=(dp[i-1]%mod+dp[i-2]%mod)%mod;\\n        }\\n        long long ans=(dp[n]%mod*dp[n]%mod)%mod;\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203485,
                "title": "c-easy-solution-fibonacci-series",
                "content": "**If you observe, you will found solution Based on Fibonacci Series**\\n\\n```\\nTest Cases:\\n1 -> 4 (2*2)\\n2 -> 9 (3*3)\\n3 -> 25 (5*5)\\n4 -> 64 (8*8)\\n```\\n\\n\\n```\\nFor n=1, we have following cases:\\n1. Both Side Plot Empty - 1 Case\\n2. One House on Either Side - 2 Case\\n3. One Plot on Each Side - 1 Case\\n\\nSo for n=1, Total ways are 4\\n```\\n\\n```\\nFor n=2,we have two plots both side, so we have following cases:\\n1. Both side\\'s Plot Empty(All for Empty) - 1 Case\\n2. 1 House on Each Position - 4 Cases\\n3. 1 house on 1st plot of first side then we have two cases 1 on either first place or second place \\nof opposite side and 1 house on 2nd plot of first side similarly we have two cases for opposide side Total 4 Cases\\n\\nSo for n=2, Total ways are 9\\n```\\n**If You Have Further Doubt Please Comment Below**\\n\\n**C++ Easy Solution**\\n```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        long a=1,b=1,mod=1e9+7;\\n        long temp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            temp=(a+b)%mod;\\n            a=b%mod;\\n            b=temp%mod;\\n        }\\n        return ((temp%mod)*(temp%mod))%mod;\\n    }\\n};\\n```\\n\\n**If You Find it Hepful Kindly UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nTest Cases:\\n1 -> 4 (2*2)\\n2 -> 9 (3*3)\\n3 -> 25 (5*5)\\n4 -> 64 (8*8)\\n```\n```\\nFor n=1, we have following cases:\\n1. Both Side Plot Empty - 1 Case\\n2. One House on Either Side - 2 Case\\n3. One Plot on Each Side - 1 Case\\n\\nSo for n=1, Total ways are 4\\n```\n```\\nFor n=2,we have two plots both side, so we have following cases:\\n1. Both side\\'s Plot Empty(All for Empty) - 1 Case\\n2. 1 House on Each Position - 4 Cases\\n3. 1 house on 1st plot of first side then we have two cases 1 on either first place or second place \\nof opposite side and 1 house on 2nd plot of first side similarly we have two cases for opposide side Total 4 Cases\\n\\nSo for n=2, Total ways are 9\\n```\n```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        long a=1,b=1,mod=1e9+7;\\n        long temp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            temp=(a+b)%mod;\\n            a=b%mod;\\n            b=temp%mod;\\n        }\\n        return ((temp%mod)*(temp%mod))%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201167,
                "title": "100-faster-c-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    int dp[10002];\\n    long long solve(int n){\\n        if(n==1) return 2;\\n        if(n==2) return 3;\\n        if(dp[n] != -1) return dp[n];\\n        long long mod = (1e9+7);\\n        return dp[n] = (solve(n-2) + solve(n-1)) % mod; \\n        \\n    }\\n    int countHousePlacements(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        long long int ans = solve(n);\\n        long long mod = (1e9+7);\\n        return (ans*ans) % mod;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int dp[10002];\\n    long long solve(int n){\\n        if(n==1) return 2;\\n        if(n==2) return 3;\\n        if(dp[n] != -1) return dp[n];\\n        long long mod = (1e9+7);\\n        return dp[n] = (solve(n-2) + solve(n-1)) % mod; \\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2200586,
                "title": "c-simple-fibonacci-series-dp-100-faster-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long findfib(int n){\\n        if(n<=1)return 1;\\n        long long x=1,y=1, f;\\n        for(int i=2;i<=n;i++){\\n            f=(x+y)%mod;\\n            x=y;\\n            y=f;\\n        }\\n        return (long long)f;\\n    }\\n    int countHousePlacements(int n) {\\n        long long f=findfib(n+1);\\n        return (f*f)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long findfib(int n){\\n        if(n<=1)return 1;\\n        long long x=1,y=1, f;\\n        for(int i=2;i<=n;i++){\\n            f=(x+y)%mod;\\n            x=y;\\n            y=f;\\n        }\\n        return (long long)f;\\n    }\\n    int countHousePlacements(int n) {\\n        long long f=findfib(n+1);\\n        return (f*f)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198737,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach :- 1 Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    long long mod = 1e9 + 7;\\n    \\n    int dp[10004];\\n    \\n    int helper(int i, int n)\\n    {\\n        if(i > n)\\n            return 1;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        // either we include or exclude\\n        \\n        int include = helper(i + 2, n);\\n        \\n        int exclude = helper(i + 1, n);\\n        \\n        return dp[i] = (include % mod + exclude % mod) % mod;\\n    }\\n    \\n    int countHousePlacements(int n) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // find the no of ways for one side of street\\n        \\n        int ans = helper(1, n);\\n        \\n        return (ans % mod * ans % mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod = 1e9 + 7;\\n    \\n    int dp[10004];\\n    \\n    int helper(int i, int n)\\n    {\\n        if(i > n)\\n            return 1;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        // either we include or exclude\\n        \\n        int include = helper(i + 2, n);\\n        \\n        int exclude = helper(i + 1, n);\\n        \\n        return dp[i] = (include % mod + exclude % mod) % mod;\\n    }\\n    \\n    int countHousePlacements(int n) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // find the no of ways for one side of street\\n        \\n        int ans = helper(1, n);\\n        \\n        return (ans % mod * ans % mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198695,
                "title": "java-dp-simple-solution",
                "content": "```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        long[] put = new long[n+1], notPut = new long[n+1];\\n        put[1] = 1;\\n        notPut[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            put[i] = notPut[i-1]%1000000007;\\n            notPut[i] = (notPut[i-1] + put[i-1])%1000000007;\\n        }\\n        return (int)((put[n]+notPut[n])*(put[n]+notPut[n])%1000000007);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        long[] put = new long[n+1], notPut = new long[n+1];\\n        put[1] = 1;\\n        notPut[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            put[i] = notPut[i-1]%1000000007;\\n            notPut[i] = (notPut[i-1] + put[i-1])%1000000007;\\n        }\\n        return (int)((put[n]+notPut[n])*(put[n]+notPut[n])%1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198540,
                "title": "java-dp-faster-than-100-easiest-explanation",
                "content": "# \\uD83C\\uDFAF ``Consider 2 rows and N columns ``\\n# **\\uD83D\\uDCCC Intuition : To place houses in any column we need to be aware of how many houses are placed in the previous column (in order to avoid 2 consecutive houses in the same row)**\\n\\n &nbsp; &nbsp;   &nbsp;   &nbsp;   &nbsp;   &nbsp;   &nbsp;   &nbsp;   &nbsp;   **i** &nbsp;  **j**\\n0 : [ - - - - a x - - ]       \\n1 : [ - - - - b y - - ]     \\n2 : [ - - - - c z - - ]      \\n\\n**a** denotes \\uD83D\\uDC49\\uD83C\\uDFFB no of ways to place houses from 0th to ith column such that 0 houses were placed in ith column\\n**b** denotes \\uD83D\\uDC49\\uD83C\\uDFFB no of ways to place houses from 0th to ith column such that 1 houses were placed in ith column\\n**c** denotes \\uD83D\\uDC49\\uD83C\\uDFFB no of ways to place houses from 0th to ith column such that 2 houses were placed in ith column\\n\\nNow for **jth column**\\nx = a + b + c        // to place 0 house take -> **all possibilities of previous column**\\ny = 2 * a + b        // to place 1 house we can either place 1 at top or 1 at bottom so  **twice of \\'a\\'**\\nz = a                    // to place 2 house previous column must be empty so take **only a**\\n\\n\\n\\n **Bottom Up DP**\\n\\n```\\nclass Solution {\\n\\n    public int countHousePlacements(int n) {\\n        long[][] dp = new long[3][n+1];\\n        long mod = 1000000007;\\n        \\n        dp[0][0] = 1;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[0][i] += dp[0][i-1];  dp[0][i] %= mod;\\n            dp[0][i] += dp[1][i-1];  dp[0][i] %= mod;\\n            dp[0][i] += dp[2][i-1];  dp[0][i] %= mod;\\n            \\n            dp[1][i] += 2 * dp[0][i-1];  dp[1][i] %= mod;\\n            dp[1][i] += dp[1][i-1];  dp[1][i] %= mod;\\n            \\n            dp[2][i] += dp[0][i-1];  dp[2][i] %= mod;\\n        }\\n        \\n        long total = 0;\\n        total += dp[0][n]; total %= mod;\\n        total += dp[1][n]; total %= mod;\\n        total += dp[2][n]; total %= mod;\\n        \\n        return (int) total;   \\n    }\\n}\\n```\\n\\n\\n**Top-Down Recursive DP**\\n\\n```\\nclass Solution {\\n    \\n    long[][] dp;\\n    long mod;\\n    public long count(int n, int last)\\n    {\\n        if(n==0) return 1;\\n        else if(dp[n][last]!=-1) return dp[n][last];\\n        long count=0;\\n        if(last==0){\\n            count += count(n-1,2);\\n            count = count % mod;\\n            count += 2 *  count(n-1,1);\\n            count = count % mod;\\n            count += count(n-1,0);\\n            count = count % mod;\\n        }\\n        else if(last==1){\\n            count += count(n-1,1);\\n            count = count % mod;\\n            count += count(n-1,0);\\n            count = count % mod;\\n        }\\n        else count = count(n-1,0);\\n        \\n        count = count % mod;\\n        \\n        return dp[n][last] = count;\\n    }\\n    public int countHousePlacements(int n) {\\n        dp = new long[n+1][3];\\n        mod = 1000000007;\\n        for(int i=0;i<=n;i++) Arrays.fill(dp[i],-1);\\n        long ans = count(n,0);\\n        return (int) ans;\\n    }\\n}\\n```\\n\\n</br>\\nHope this helps! :)\\n\\n\\uD83C\\uDFAF Upvote if you liked the approach \\uD83D\\uDE0A\\uD83D\\uDE04",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int countHousePlacements(int n) {\\n        long[][] dp = new long[3][n+1];\\n        long mod = 1000000007;\\n        \\n        dp[0][0] = 1;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[0][i] += dp[0][i-1];  dp[0][i] %= mod;\\n            dp[0][i] += dp[1][i-1];  dp[0][i] %= mod;\\n            dp[0][i] += dp[2][i-1];  dp[0][i] %= mod;\\n            \\n            dp[1][i] += 2 * dp[0][i-1];  dp[1][i] %= mod;\\n            dp[1][i] += dp[1][i-1];  dp[1][i] %= mod;\\n            \\n            dp[2][i] += dp[0][i-1];  dp[2][i] %= mod;\\n        }\\n        \\n        long total = 0;\\n        total += dp[0][n]; total %= mod;\\n        total += dp[1][n]; total %= mod;\\n        total += dp[2][n]; total %= mod;\\n        \\n        return (int) total;   \\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    long[][] dp;\\n    long mod;\\n    public long count(int n, int last)\\n    {\\n        if(n==0) return 1;\\n        else if(dp[n][last]!=-1) return dp[n][last];\\n        long count=0;\\n        if(last==0){\\n            count += count(n-1,2);\\n            count = count % mod;\\n            count += 2 *  count(n-1,1);\\n            count = count % mod;\\n            count += count(n-1,0);\\n            count = count % mod;\\n        }\\n        else if(last==1){\\n            count += count(n-1,1);\\n            count = count % mod;\\n            count += count(n-1,0);\\n            count = count % mod;\\n        }\\n        else count = count(n-1,0);\\n        \\n        count = count % mod;\\n        \\n        return dp[n][last] = count;\\n    }\\n    public int countHousePlacements(int n) {\\n        dp = new long[n+1][3];\\n        mod = 1000000007;\\n        for(int i=0;i<=n;i++) Arrays.fill(dp[i],-1);\\n        long ans = count(n,0);\\n        return (int) ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198538,
                "title": "house-robber",
                "content": "This is similar to [House Robber](http://https://leetcode.com/problems/house-robber/) but instead of finding maximum profit such that no two adjacent houses are robbed, we are asked to rob set of ```n``` houses such that no two houses are adjacent. And since both lanes are similar total number of ways will be ```ways1*ways1```. we are doing the same thing in both quesitons.",
                "solutionTags": [],
                "code": "```n```\n```ways1*ways1```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198491,
                "title": "beats-100-java-solution",
                "content": "```class Solution {\\n    public int countHousePlacements(int n) {\\n        long[] dp=new long[n+1];\\n        dp[0]=1;\\n        dp[1]=2;\\n        long mod=(long)(Math.pow(10,9)+7);\\n        for(int i=2;i<=n;i++){\\n            dp[i]=(dp[i-1]+dp[i-2])%mod;\\n        }\\n        \\n        return (int)((dp[n]*dp[n])%mod);\\n    }\\n    \\n}```\\n\\nExplanation: \\nEach side would be symmetrical, which means if left side there x ways of placing houses, on the other side would also have the same ways of placing. The answer would be x*x mod 1000000007.  If we look at just one side, how many ways could we place? \\nWe could not put two adjacent houses, so case 1: based on n-2 ways, we place number n.  \\ncase 2: if we choose the n-1 which is adjacent to n, then n-2 should be empty, \\nAddition of case 1 and 2 would be # of ways on only one side. The last step is to square it.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    public int countHousePlacements(int n) {\\n        long[] dp=new long[n+1];\\n        dp[0]=1;\\n        dp[1]=2;\\n        long mod=(long)(Math.pow(10,9)+7);\\n        for(int i=2;i<=n;i++){\\n            dp[i]=(dp[i-1]+dp[i-2])%mod;\\n        }\\n        \\n        return (int)((dp[n]*dp[n])%mod);\\n    }\\n    \\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2198434,
                "title": "c-easy-solution-dp-fibonacci-series",
                "content": "We can solve this question very simply using basic combinatorics.\\nhttps://stackoverflow.com/questions/10644755/finding-total-ways-of-selecting-items-such-that-no-two-are-consecutive\\n*We can choose from n items such that no two items are consecutive,\\nSo total possible ways will become*\\n*NC1 + (N-1)C2 + (N-2)C3 + ... + (N-K+1)CK,*\\n*which is sum of first N Fibonacci numbers (1,1,2,3,5,...).\\nAlso, Sum of first N Fibonacci numbers = F(n+2) - 1*\\n```\\nclass Solution {\\npublic:\\n    unsigned long long mod = 1000000007;\\n    unsigned long long fib(unsigned long long n){\\n        unsigned long long a = -1, b = 1, c = 0;\\n        for(unsigned long long i = 0 ; i <= n ; i++){\\n            c = (a+b) % mod;\\n            a = b;\\n            b = c;\\n        }\\n        return c % mod;\\n    }\\n    int countHousePlacements(int n) {\\n        unsigned long long comb = fib(n+2);\\n        unsigned long long ans = comb*comb;\\n        return ans % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unsigned long long mod = 1000000007;\\n    unsigned long long fib(unsigned long long n){\\n        unsigned long long a = -1, b = 1, c = 0;\\n        for(unsigned long long i = 0 ; i <= n ; i++){\\n            c = (a+b) % mod;\\n            a = b;\\n            b = c;\\n        }\\n        return c % mod;\\n    }\\n    int countHousePlacements(int n) {\\n        unsigned long long comb = fib(n+2);\\n        unsigned long long ans = comb*comb;\\n        return ans % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198338,
                "title": "easy-java-backtracking-memoization-solution",
                "content": "Intuition - \\nIf we know the total number of ways to place houses on either side individually, multiplying them will give us the number of ways to place houses on both sides.\\n\\nHere, we just calculate the total number of ways to place n houses along one side of a street such that no two houses are adjacent to each other. The same will be the number of ways to place houses on other side. So to find total ways, just multiply these two values.\\n\\n```\\n\\n\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countHousePlacements(int n) {\\n        Long[][] dp = new Long[2][n];\\n        long ans = dfs(n, 0, false, dp);\\n        return (int)((ans*ans)%mod);\\n    }\\n    \\n    public long dfs(int n, int curr, boolean prev, Long[][] dp) {\\n        if(curr==n) return 1;\\n        \\n        int row = prev ? 1 : 0;\\n        if(dp[row][curr]!=null) return dp[row][curr];\\n        \\n        long count = 0;\\n        \\n        if(!prev) {\\n            count+=dfs(n, curr+1, true, dp)%mod;\\n            count+=dfs(n, curr+1, false, dp)%mod;\\n        }\\n        else count += dfs(n, curr+1, false, dp)%mod;\\n        \\n        dp[row][curr] = count;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countHousePlacements(int n) {\\n        Long[][] dp = new Long[2][n];\\n        long ans = dfs(n, 0, false, dp);\\n        return (int)((ans*ans)%mod);\\n    }\\n    \\n    public long dfs(int n, int curr, boolean prev, Long[][] dp) {\\n        if(curr==n) return 1;\\n        \\n        int row = prev ? 1 : 0;\\n        if(dp[row][curr]!=null) return dp[row][curr];\\n        \\n        long count = 0;\\n        \\n        if(!prev) {\\n            count+=dfs(n, curr+1, true, dp)%mod;\\n            count+=dfs(n, curr+1, false, dp)%mod;\\n        }\\n        else count += dfs(n, curr+1, false, dp)%mod;\\n        \\n        dp[row][curr] = count;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198311,
                "title": "house-robber-memoization-tabulation-space-optimization",
                "content": "\\n\\n**memoization**\\n```\\nclass Solution {\\n    int M = 1e9+7;\\n    int fn(int n, vector<long long> &dp){\\n        if(n <= 0)\\n            return 0;\\n        \\n        if(dp[n] != -1) return dp[n];\\n        \\n        int pick = 1 + fn(n-2,dp);\\n        int notpick = fn(n-1,dp);\\n        \\n        return dp[n] = (pick + notpick)%M;\\n        \\n    }\\npublic:\\n    int countHousePlacements(int n) {\\n        vector<long long> dp(n+1, -1);\\n        \\n        long long ans = fn(n, dp);\\n        \\n\\n        ans += (ans + (ans*ans))%M;\\n   \\n        return (ans+1)%M; // + 1 for no house case\\n    }\\n};\\n```\\n\\n\\n**tabulation**\\n\\n```\\nclass Solution {\\n    int M = 1e9+7;\\npublic:\\n    int countHousePlacements(int n) {\\n        vector<long long> dp(n+1, 0);\\n        \\n        dp[1] = 1;\\n        for(int i = 2;i <= n;i++){\\n            int pick = 1 + dp[i-2];\\n            int notpick = dp[i-1];\\n            \\n            dp[i] = (pick + notpick)%M;\\n        }\\n        \\n        long long ans =  dp[n];\\n\\n        ans += (ans + (ans*ans))%M;\\n       \\n        return (ans+1)%M;\\n    }\\n};\\n```\\n\\n**space optimization**\\n\\n```\\nclass Solution {\\n    int M = 1e9+7;\\npublic:\\n    int countHousePlacements(int n) {\\n        int prev1 = 1 , prev2 , curr;\\n    \\n        for(int i = 2;i <= n;i++){\\n            int pick = 1 + prev2;\\n            int notpick = prev1;\\n            \\n            curr = (pick + notpick)%M;\\n            \\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n        \\n        long long ans =  prev1;\\n\\n        ans += (ans + (ans*ans))%M;\\n       \\n        return (ans+1)%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int M = 1e9+7;\\n    int fn(int n, vector<long long> &dp){\\n        if(n <= 0)\\n            return 0;\\n        \\n        if(dp[n] != -1) return dp[n];\\n        \\n        int pick = 1 + fn(n-2,dp);\\n        int notpick = fn(n-1,dp);\\n        \\n        return dp[n] = (pick + notpick)%M;\\n        \\n    }\\npublic:\\n    int countHousePlacements(int n) {\\n        vector<long long> dp(n+1, -1);\\n        \\n        long long ans = fn(n, dp);\\n        \\n\\n        ans += (ans + (ans*ans))%M;\\n   \\n        return (ans+1)%M; // + 1 for no house case\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int M = 1e9+7;\\npublic:\\n    int countHousePlacements(int n) {\\n        vector<long long> dp(n+1, 0);\\n        \\n        dp[1] = 1;\\n        for(int i = 2;i <= n;i++){\\n            int pick = 1 + dp[i-2];\\n            int notpick = dp[i-1];\\n            \\n            dp[i] = (pick + notpick)%M;\\n        }\\n        \\n        long long ans =  dp[n];\\n\\n        ans += (ans + (ans*ans))%M;\\n       \\n        return (ans+1)%M;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int M = 1e9+7;\\npublic:\\n    int countHousePlacements(int n) {\\n        int prev1 = 1 , prev2 , curr;\\n    \\n        for(int i = 2;i <= n;i++){\\n            int pick = 1 + prev2;\\n            int notpick = prev1;\\n            \\n            curr = (pick + notpick)%M;\\n            \\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n        \\n        long long ans =  prev1;\\n\\n        ans += (ans + (ans*ans))%M;\\n       \\n        return (ans+1)%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198285,
                "title": "dp-c",
                "content": "```\\n// We have basically 2 choices whether to place the house on current plot or not\\nclass Solution {\\nprivate:\\n    int mod=1e9+7;\\n    int dp[10001];\\n    #define ll long long\\n    ll solve1(int i,int n)    //Calculate total ways to place houses on one side of road\\n    {\\n        if(i>=n)\\n            return 1;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        return dp[i]=(solve1(i+1,n)+solve1(i+2,n))%mod; \\n    }\\npublic:\\n    Solution(){memset(dp,-1,sizeof(dp));}\\n    int countHousePlacements(int n) {\\n        ll ans=solve1(0,n);\\n        ans=(ans*ans)%mod;    //total ways to place 2 houses=(total ways to place 1 house * total ways to place 1 house)\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// We have basically 2 choices whether to place the house on current plot or not\\nclass Solution {\\nprivate:\\n    int mod=1e9+7;\\n    int dp[10001];\\n    #define ll long long\\n    ll solve1(int i,int n)    //Calculate total ways to place houses on one side of road\\n    {\\n        if(i>=n)\\n            return 1;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        return dp[i]=(solve1(i+1,n)+solve1(i+2,n))%mod; \\n    }\\npublic:\\n    Solution(){memset(dp,-1,sizeof(dp));}\\n    int countHousePlacements(int n) {\\n        ll ans=solve1(0,n);\\n        ans=(ans*ans)%mod;    //total ways to place 2 houses=(total ways to place 1 house * total ways to place 1 house)\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198271,
                "title": "easy-c-fibonacci-number",
                "content": "Number of house placements will be equal to the square of fibonacci of (n+2).\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n\\n    int countHousePlacements(int n) {\\n        n=n+2;\\n        long long fibo[n + 1];\\n        fibo[0] = 0, fibo[1] = 1;\\n        int ans=0;\\n        for (int i = 2; i <= n; i++)\\n        {\\n            fibo[i] = (fibo[i - 1] + fibo[i - 2])%mod;\\n            ans= (fibo[i] * fibo[i])%mod;\\n        }\\n\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n\\n    int countHousePlacements(int n) {\\n        n=n+2;\\n        long long fibo[n + 1];\\n        fibo[0] = 0, fibo[1] = 1;\\n        int ans=0;\\n        for (int i = 2; i <= n; i++)\\n        {\\n            fibo[i] = (fibo[i - 1] + fibo[i - 2])%mod;\\n            ans= (fibo[i] * fibo[i])%mod;\\n        }\\n\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198266,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        if(n==1)\\n            return 4;\\n        int m=1000000007;\\n        int a=1,b=1,c=0,d=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            c=a%m;\\n            d=b%m;\\n            b=((c%m)+(d%m))%m;\\n            a=d%m;\\n        }\\n        long s=((a%m)+(b%m))%m;\\n        s=((s%m)*(s%m))%m;\\n        return (int)s;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countHousePlacements(int n) {\\n        if(n==1)\\n            return 4;\\n        int m=1000000007;\\n        int a=1,b=1,c=0,d=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            c=a%m;\\n            d=b%m;\\n            b=((c%m)+(d%m))%m;\\n            a=d%m;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2198265,
                "title": "python-simple-solution-o-n-time-complexity-basic-approach-dp",
                "content": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        pre,ppre = 2,1\\n        if n==1:\\n            return 4\\n        for i in range(1,n):\\n            temp = pre+ppre \\n            ppre = pre \\n            pre = temp \\n        return ((pre)**2)%((10**9) + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        pre,ppre = 2,1\\n        if n==1:\\n            return 4\\n        for i in range(1,n):\\n            temp = pre+ppre \\n            ppre = pre \\n            pre = temp \\n        return ((pre)**2)%((10**9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198132,
                "title": "java-solution-using-fibonacci-sequence",
                "content": "```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        long f0 = 1;\\n        long f1 = 2;\\n        for (int i = 2; i <= n; i++) {\\n            long f2 = (f0 + f1) % (long) (Math.pow(10, 9) + 7);\\n            f0 = f1;\\n            f1 = f2;\\n        }\\n        return (int) ((f1 * f1) % (long) (Math.pow(10, 9) + 7));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        long f0 = 1;\\n        long f1 = 2;\\n        for (int i = 2; i <= n; i++) {\\n            long f2 = (f0 + f1) % (long) (Math.pow(10, 9) + 7);\\n            f0 = f1;\\n            f1 = f2;\\n        }\\n        return (int) ((f1 * f1) % (long) (Math.pow(10, 9) + 7));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888526,
                "title": "python-simple-dp-from-index-0-to-n",
                "content": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        # the two sides of the roads are identical. We just need to count one side\\n        self.dp = collections.defaultdict(lambda: None)\\n        self.dp[0, 0] = 1  # the number cases not building house at index 0\\n        self.dp[0, 1] = 2  # total cases: including building house and not building house at index 0\\n        \\n        idx = 1\\n        while idx < n:\\n            self.dp[idx, 0] = self.dp[idx - 1, 1]\\n            self.dp[idx, 1] = self.dp[idx - 1, 1] + self.dp[idx - 1, 0]\\n            idx += 1\\n        \\n        return (self.dp[n - 1, 1] * self.dp[n - 1, 1]) % 1000000007\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        # the two sides of the roads are identical. We just need to count one side\\n        self.dp = collections.defaultdict(lambda: None)\\n        self.dp[0, 0] = 1  # the number cases not building house at index 0\\n        self.dp[0, 1] = 2  # total cases: including building house and not building house at index 0\\n        \\n        idx = 1\\n        while idx < n:\\n            self.dp[idx, 0] = self.dp[idx - 1, 1]\\n            self.dp[idx, 1] = self.dp[idx - 1, 1] + self.dp[idx - 1, 0]\\n            idx += 1\\n        \\n        return (self.dp[n - 1, 1] * self.dp[n - 1, 1]) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690620,
                "title": "c-dp-time-o-n-space-o-1",
                "content": "# Intuition\\n![\\u672A\\u547D\\u540D\\u7684\\u767D\\u677F.png](https://assets.leetcode.com/users/images/ff01275a-c453-4443-ab98-dffeaad66221_1665496322.1606414.png)\\n\\n\\nFocus on one side of street.\\n`h` = place a house\\n`e` = leave it empty\\nThe first plot, we can `h` or `e`, 2 ways.\\nThe second plot, we can only `e` if we previously place a house. If we previously leave an empty plot, we can `h` or `e`.\\nAnd so on.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nObserve the pattern.\\nWhen `n = 1`, we have `1h + 1e` ways.\\nWhen `n = 2`, we have `1h + 2e` ways.\\nWhen `n = 3`, we have `2h + 3e` ways.\\nWhen `n = 4`, we have `3h + 5e` ways.\\nAnd so on.\\n\\nThe new `h` is the old `e`.\\nAnd the new `e` is the old `h` + old `e`.\\n\\nThe result for the `n` plots is just right stored in the new `e`.\\nBe aware that the above calculation is for one side of street.\\nWe have to return `result * result` ways as the finally answer for two sides of street.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int countHousePlacements(int n) {\\n    int house = 1, empty = 1, mod = 1e9 + 7;\\n    for (int i = 0; i < n; i++) {\\n      int tmp = house;\\n      house = empty;\\n      empty = (tmp + empty) % mod;\\n    }\\n    return (long)empty * empty % mod;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int countHousePlacements(int n) {\\n    int house = 1, empty = 1, mod = 1e9 + 7;\\n    for (int i = 0; i < n; i++) {\\n      int tmp = house;\\n      house = empty;\\n      empty = (tmp + empty) % mod;\\n    }\\n    return (long)empty * empty % mod;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641361,
                "title": "cpp-fibonacci",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countHousePlacements(int n) {\\n\\t\\t\\tif(n == 1) return 4;\\n\\t\\t\\tif(n == 2) return 9;\\n\\t\\t\\tint a = 3,b = 2;\\n\\t\\t\\tn-=2;\\n\\t\\t\\twhile(n){\\n\\t\\t\\t\\tint t = (a+b)%((long)1e9+7);\\n\\t\\t\\t\\tb = a;\\n\\t\\t\\t\\ta = t;\\n\\t\\t\\t\\tn--;\\n\\t\\t\\t}\\n\\t\\t\\treturn (a%((long)1e9+7))*(a%((long)1e9+7))%((long)1e9+7);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint countHousePlacements(int n) {\\n\\t\\t\\tif(n == 1) return 4;\\n\\t\\t\\tif(n == 2) return 9;\\n\\t\\t\\tint a = 3,b = 2;\\n\\t\\t\\tn-=2;\\n\\t\\t\\twhile(n){\\n\\t\\t\\t\\tint t = (a+b)%((long)1e9+7);\\n\\t\\t\\t\\tb = a;\\n\\t\\t\\t\\ta = t;\\n\\t\\t\\t\\tn--;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2596813,
                "title": "java-easy-dp-tabulation",
                "content": "class Solution {\\n\\n    public int countHousePlacements(int n) {\\n        long mod = 1000000007;\\n        long placed = 1;\\n        long unplaced = 1;\\n        for(int i = 2; i<=n; i++){\\n            long newPlaced = unplaced;\\n            long newUnplaced = placed + unplaced;\\n            placed = newPlaced%mod;\\n            unplaced = newUnplaced%mod;\\n        }\\n        long ans = (placed+unplaced)%mod;\\n        long val = (ans*ans)%mod;\\n        return (int)val;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\n    public int countHousePlacements(int n) {\\n        long mod = 1000000007;\\n        long placed = 1;\\n        long unplaced = 1;\\n        for(int i = 2; i<=n; i++){\\n            long newPlaced = unplaced;\\n            long newUnplaced = placed + unplaced;\\n            placed = newPlaced%mod;\\n            unplaced = newUnplaced%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2513512,
                "title": "2320-python",
                "content": "\\tclass Solution:\\n\\t\\tdef countHousePlacements(self, n: int) -> int:\\n\\t\\t\\tdp = [0]*n\\n\\t\\t\\tif n == 1:\\n\\t\\t\\t\\treturn 4\\n\\t\\t\\tdp[0] = 2\\n\\t\\t\\tdp[1] = 3\\n\\t\\t\\tmod = int(1e9+7)\\n\\t\\t\\tfor i in range(2,n):\\n\\t\\t\\t\\tdp[i] = (dp[i-1] + dp[i-2])%mod\\n\\n\\t\\t\\treturn (dp[-1]**2)%mod",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef countHousePlacements(self, n: int) -> int:\\n\\t\\t\\tdp = [0]*n\\n\\t\\t\\tif n == 1:\\n\\t\\t\\t\\treturn 4\\n\\t\\t\\tdp[0] = 2\\n\\t\\t\\tdp[1] = 3\\n\\t\\t\\tmod = int(1e9+7)\\n\\t\\t\\tfor i in range(2,n):\\n\\t\\t\\t\\tdp[i] = (dp[i-1] + dp[i-2])%mod\\n\\n\\t\\t\\treturn (dp[-1]**2)%mod",
                "codeTag": "Java"
            },
            {
                "id": 2417851,
                "title": "python-recursion-memoization-notes",
                "content": "```\\n/*\\nwe can easily solve this problem using recursive implementation\\nlet\\'s say n = 5\\nthen we have to find all the combinations:\\n\\nOn one side of street\\ncombinations  = combinations when we are placing 0 house\\n                + combinations when we are placing 1 house\\n                + combinations when we are placing 2 house\\n                \\ntotal combinations = combinations * combinations \\n\\nBase case, when house to place = 0, ways will always be 1\\n           when house to place = 1, ways will alwasy be equal to number of plots\\n           when house to place = 2, we will recursively evalute the answer\\nThe below approach is giving TLE unfortunately\\n*/\\n```\\n```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        lookup = {}\\n        def fun(n, houses):\\n            if (n, houses) in lookup:\\n                return lookup[(n, houses)]\\n            if houses > math.ceil(n/2) or n < 0:\\n                return 0\\n            if houses == 0:\\n                return 1\\n            if houses == 1:\\n                return n\\n            total_ways = 0\\n            for i in range(1, n+1):\\n                # ways when house is placed on ith plot\\n                ways = fun(n-(i+1), houses-1)\\n                lookup[(n-(i+1), houses-1)] = ways\\n                total_ways+=ways\\n            lookup[(n, houses)] = total_ways\\n            return total_ways % (10**9+7)\\n        \\n        total_ways = 0\\n        for i in range(math.floor(n/2)+2):\\n            ways = fun(n, i)\\n            print(\\'for i = {}, ways = {}\\'.format(i, ways))\\n            total_ways = (total_ways + ways)\\n        return (total_ways * total_ways) % (10**9+7)\\n```\\n    \\n```\\n/*\\n\\toptimized approach:\\n\\tTry coming up with a DP solution for one side of the street.\\n\\tThe DP for one side of the street will bear resemblance to the Fibonacci sequence.\\n\\tIntution:\\n\\tlet\\'s say n = 5, then we have two choices, either we place a house at plot 1 and find the\\n\\ttotal combinations for n = 3\\n\\tor, we don\\'t place a house at plot 1 and find the total combinations for n = 4\\n\\tf(5) = f(3) [when house is placed at first plot] + f(4) [when house is not placed at first plot]\\n\\tThe number of different arrangements on both side of the street is the same.\\n*/\\n```\\n```\\ndef countHousePlacements(self, n: int) -> int:\\n\\tlookup = {1: 2, 2: 3}\\n\\tdef fun(n):\\n\\t\\tif n in lookup:\\n\\t\\t\\treturn lookup[n]\\n\\t\\tways = fun(n-1) + fun(n-2)\\n\\t\\tlookup[n] = ways\\n\\t\\treturn lookup[n]\\n\\tways = fun(n)\\n\\treturn (ways * ways) % (10**9+7)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n/*\\nwe can easily solve this problem using recursive implementation\\nlet\\'s say n = 5\\nthen we have to find all the combinations:\\n\\nOn one side of street\\ncombinations  = combinations when we are placing 0 house\\n                + combinations when we are placing 1 house\\n                + combinations when we are placing 2 house\\n                \\ntotal combinations = combinations * combinations \\n\\nBase case, when house to place = 0, ways will always be 1\\n           when house to place = 1, ways will alwasy be equal to number of plots\\n           when house to place = 2, we will recursively evalute the answer\\nThe below approach is giving TLE unfortunately\\n*/\\n```\n```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        lookup = {}\\n        def fun(n, houses):\\n            if (n, houses) in lookup:\\n                return lookup[(n, houses)]\\n            if houses > math.ceil(n/2) or n < 0:\\n                return 0\\n            if houses == 0:\\n                return 1\\n            if houses == 1:\\n                return n\\n            total_ways = 0\\n            for i in range(1, n+1):\\n                # ways when house is placed on ith plot\\n                ways = fun(n-(i+1), houses-1)\\n                lookup[(n-(i+1), houses-1)] = ways\\n                total_ways+=ways\\n            lookup[(n, houses)] = total_ways\\n            return total_ways % (10**9+7)\\n        \\n        total_ways = 0\\n        for i in range(math.floor(n/2)+2):\\n            ways = fun(n, i)\\n            print(\\'for i = {}, ways = {}\\'.format(i, ways))\\n            total_ways = (total_ways + ways)\\n        return (total_ways * total_ways) % (10**9+7)\\n```\n```\\n/*\\n\\toptimized approach:\\n\\tTry coming up with a DP solution for one side of the street.\\n\\tThe DP for one side of the street will bear resemblance to the Fibonacci sequence.\\n\\tIntution:\\n\\tlet\\'s say n = 5, then we have two choices, either we place a house at plot 1 and find the\\n\\ttotal combinations for n = 3\\n\\tor, we don\\'t place a house at plot 1 and find the total combinations for n = 4\\n\\tf(5) = f(3) [when house is placed at first plot] + f(4) [when house is not placed at first plot]\\n\\tThe number of different arrangements on both side of the street is the same.\\n*/\\n```\n```\\ndef countHousePlacements(self, n: int) -> int:\\n\\tlookup = {1: 2, 2: 3}\\n\\tdef fun(n):\\n\\t\\tif n in lookup:\\n\\t\\t\\treturn lookup[n]\\n\\t\\tways = fun(n-1) + fun(n-2)\\n\\t\\tlookup[n] = ways\\n\\t\\treturn lookup[n]\\n\\tways = fun(n)\\n\\treturn (ways * ways) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335637,
                "title": "c-dp-with-easy-explaination",
                "content": "\\'\\'\\'\\n\\t\\n\\t\\n\\tclass Solution {\\n    public:\\n    int mod = 1e9+7;\\n    int solve(int n,vector<int>& dp)\\n    {\\n        if(n==1) return 2;\\n        if(n==2) return 3;\\n        if(dp[n]!=-1) return dp[n];\\n        return dp[n] = (solve(n-1,dp)%mod + solve(n-2,dp)%mod)%mod;\\n    }\\n    int countHousePlacements(int n) {\\n        vector<int> dp(n+1,-1);\\n        long long one_side = solve(n,dp);\\n        long long ans = (one_side*one_side)%mod;\\n        return ans;\\n    }\\n\\t\\'\\'\\'\\n};\\n\\'\\'\\'\\nWhen You come to any house you have two options either you keep your house there or you dont.\\nSuppose you decide to not keep a house there then the number of ways of doing this will be the number of ways you can keep a house just at the the index before that.\\nNow suppose you decide to keep a house their so obviously you cannnot keep a house at the index just before instead you will have to keep at index-2;\\nSo we can sum that f(n) = f(n-1) + f(n-2)\\nA simple Fibbonacci sequence;",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n    int mod = 1e9+7;\\n    int solve(int n,vector<int>& dp)\\n    {\\n        if(n==1) return 2;\\n        if(n==2) return 3;\\n        if(dp[n]!=-1) return dp[n];\\n        return dp[n] = (solve(n-1,dp)%mod + solve(n-2,dp)%mod)%mod;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2323304,
                "title": "loop-and-calculate-by-using-previous-results",
                "content": "We need to calucalate the result for one side and multiply it by itself.\\nthese are results for one side:\\n*n result choices*\\n1\\t**2** 0\\t1\\n2\\t**3** 00 01 10\\n3\\t**5** 000 100 010 001 101\\n4\\t**8** 0000 1000 0100 0010 0001 1010 1001 0101\\t\\t\\n5\\t**13** 00000 10000 01000 00100 00010 00001 10100 10010 10001 01010 01001 00101 10101\\n6\\t**21** 000000 100000 010000 001000 000100 000010 000001 101000 100100 100010 100001 010100 010010 010001 001010 001001 000101 101010 101001 100101 010101 \\n****\\nso it means the result for one side result(n)=result(n-2)+result(n-1)\\n\\n```\\npublic class Solution {\\n    private const long mod =(long)(1e9 + 7);\\n    public int CountHousePlacements(int n) {\\n        long result=2,pre1=1,pre2=1;\\n        for(int i=0;i<n;i++){\\n            result=(pre1+pre2) % mod;\\n            pre2=pre1;\\n            pre1=result;\\n        }\\n        return (int)((result*result) % mod);\\n    }\\n}\\n```\\n\\nO(n)\\n![image](https://assets.leetcode.com/users/images/12422592-bb51-47d2-bb63-f07e0cf9dc9a_1658606796.8172107.png)\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    private const long mod =(long)(1e9 + 7);\\n    public int CountHousePlacements(int n) {\\n        long result=2,pre1=1,pre2=1;\\n        for(int i=0;i<n;i++){\\n            result=(pre1+pre2) % mod;\\n            pre2=pre1;\\n            pre1=result;\\n        }\\n        return (int)((result*result) % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285343,
                "title": "c-dynamic-programming-recursive-dp",
                "content": "class Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    \\n    long long f(int i, int check, vector <vector <int>> &dp){\\n        \\n        if(i < 0) return 0;\\n        \\n        if(i == 0){\\n            return 1;\\n        }\\n        \\n        if(dp[i][check] != -1) return dp[i][check];\\n        \\n        long long ans = 0;\\n        \\n        int right = 0;\\n        \\n        int left = f(i-1, 0, dp);\\n        if(check == 0) right = f(i-1, 1, dp); \\n        \\n        \\n        return dp[i][check] = (left % mod + right % mod) % mod;\\n    }\\n    \\n    int countHousePlacements(int n) {\\n        \\n        vector <vector <int>> dp(n+1, vector <int> (2, -1));\\n        long long k = f(n, 0, dp) % mod;\\n        \\n        return (k*k) % mod;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    \\n    long long f(int i, int check, vector <vector <int>> &dp){\\n        \\n        if(i < 0) return 0;\\n        \\n        if(i == 0){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2248263,
                "title": "c-clean-code-dp-memoization-pattern",
                "content": "Since we have only restriction on one side, we just need to find out house robber equivalent solution and square it, because number of ways to arrange non consecutively on one side is equal to that of another.\\n\\n```\\n//Recursion + Memoization \\nclass Solution {\\npublic:\\n    int util(vector<int>&dp,int n)\\n    {\\n        if(n<=0)return 1; // for every arrangement we are incrementing by 1\\n        if(dp[n]!=-1)return dp[n];\\n        int choose=util(dp,n-2);\\n        int notChoose=util(dp,n-1);\\n        int mod=1e9+7;\\n        long long int ans=(choose+notChoose)%mod;\\n        return dp[n]=ans;\\n    }\\n    int countHousePlacements(int n) {\\n        int mod=1e9+7;\\n        vector<int>dp(n+1,-1);\\n        long long int ans=(1LL*util(dp,n)*util(dp,n))%mod;\\n        return ans;\\n    }\\n};\\n\\n```\\n\\nFibonacci Series solution\\n```\\n//Following the pattern it is related to square and fibonacci series\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        int mod=1e9+7;\\n        vector<long long>fib{1,1};\\n        for(int i=0;i<n;i++)\\n        {\\n            fib.push_back((fib[fib.size()-1]+fib[fib.size()-2])%mod);\\n        }\\n        long long int ans=(fib[n+1]*fib[n+1])%mod;\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n//Recursion + Memoization \\nclass Solution {\\npublic:\\n    int util(vector<int>&dp,int n)\\n    {\\n        if(n<=0)return 1; // for every arrangement we are incrementing by 1\\n        if(dp[n]!=-1)return dp[n];\\n        int choose=util(dp,n-2);\\n        int notChoose=util(dp,n-1);\\n        int mod=1e9+7;\\n        long long int ans=(choose+notChoose)%mod;\\n        return dp[n]=ans;\\n    }\\n    int countHousePlacements(int n) {\\n        int mod=1e9+7;\\n        vector<int>dp(n+1,-1);\\n        long long int ans=(1LL*util(dp,n)*util(dp,n))%mod;\\n        return ans;\\n    }\\n};\\n\\n```\n```\\n//Following the pattern it is related to square and fibonacci series\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        int mod=1e9+7;\\n        vector<long long>fib{1,1};\\n        for(int i=0;i<n;i++)\\n        {\\n            fib.push_back((fib[fib.size()-1]+fib[fib.size()-2])%mod);\\n        }\\n        long long int ans=(fib[n+1]*fib[n+1])%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2244525,
                "title": "python-dp-implementation-o-1-space",
                "content": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        a=1\\n        b=2\\n        if n==1:\\n            return 4\\n        if n==2:\\n            return 9\\n        for i in range(n-1):\\n            a,b=b,a+b\\n        \\n        return (b**2)%1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        a=1\\n        b=2\\n        if n==1:\\n            return 4\\n        if n==2:\\n            return 9\\n        for i in range(n-1):\\n            a,b=b,a+b\\n        \\n        return (b**2)%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2244089,
                "title": "c-fibonacci-series-visual-reprsentation",
                "content": "```\\n/*\\n\\nn = 1\\n0, 1    --> 2\\n\\nn = 2\\n00, 01, 10  --> 3\\n\\nn = 3\\n000, 001, 010, 100, 101 -->5\\n\\nn = 4\\n0000, 0001, 0010, 0100, 1000, 0101, 1010, 1001 --> 8\\n\\nAbove generated pattern is for fibonacci series\\n\\nNow, square them for the other side combination.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    long long mod = 1e9+7;\\n    int countHousePlacements(int n) {\\n        long long first = 2, second = 3;\\n        if (n == 1)\\n            return pow (first, 2);\\n        if (n == 2)\\n            return pow (second, 2);\\n        long long num = 0;\\n        for (int i = 3; i <= n; ++i){\\n            num = (first + second) % mod;\\n            first = second;\\n            second = num;\\n        }\\n        return (num*num) % mod;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n\\nn = 1\\n0, 1    --> 2\\n\\nn = 2\\n00, 01, 10  --> 3\\n\\nn = 3\\n000, 001, 010, 100, 101 -->5\\n\\nn = 4\\n0000, 0001, 0010, 0100, 1000, 0101, 1010, 1001 --> 8\\n\\nAbove generated pattern is for fibonacci series\\n\\nNow, square them for the other side combination.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    long long mod = 1e9+7;\\n    int countHousePlacements(int n) {\\n        long long first = 2, second = 3;\\n        if (n == 1)\\n            return pow (first, 2);\\n        if (n == 2)\\n            return pow (second, 2);\\n        long long num = 0;\\n        for (int i = 3; i <= n; ++i){\\n            num = (first + second) % mod;\\n            first = second;\\n            second = num;\\n        }\\n        return (num*num) % mod;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242728,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        if(n == 1) {\\n            return 4;\\n        }\\n        \\n        int t, a = 2, b = 3;\\n        long long int mod = 1000000007;\\n        \\n        while(n > 2) {\\n            t = (a + b) % mod;\\n            a = b;\\n            b = t;\\n            n--;\\n        }\\n        return ( (b % mod) * (b % mod) ) % mod;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        if(n == 1) {\\n            return 4;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2229148,
                "title": "ruby-one-liner-rust-port",
                "content": "```\\n# @param {Integer} n\\n# @return {Integer}\\ndef count_house_placements(n)\\n  (1..n).reduce([1, 1]) { |(a, b), _| [a + b, a] }[0] ** 2 % 1_000_000_007\\nend\\n```\\n\\n```\\nconst M: u64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn count_house_placements(n: i32) -> i32 {\\n       ((0..n).fold((1u64, 1), |(a, b), _| ((a + b) % M, a)).0.pow(2) % M) as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer} n\\n# @return {Integer}\\ndef count_house_placements(n)\\n  (1..n).reduce([1, 1]) { |(a, b), _| [a + b, a] }[0] ** 2 % 1_000_000_007\\nend\\n```\n```\\nconst M: u64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn count_house_placements(n: i32) -> i32 {\\n       ((0..n).fold((1u64, 1), |(a, b), _| ((a + b) % M, a)).0.pow(2) % M) as i32\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2226371,
                "title": "practice-recursion-using-two-states",
                "content": "```\\nclass Solution {\\n\\tstatic Long dp[][];\\n\\tpublic static final int max = (int) Math.pow(10, 9) + 7;\\n\\n\\tpublic int countHousePlacements(int n) {\\n\\t\\tdp = new Long[n + 1][2];\\n\\t\\tlong ans = countHousePlacements(n, 0) + countHousePlacements(n, 1);\\n\\t\\treturn (int) ((ans * ans) % max);\\n\\t}\\n\\n\\tpublic long countHousePlacements(int n, int canPlaceHouse) {\\n\\t\\tif (n == 1)\\n\\t\\t\\treturn 1;\\n\\t\\tif (dp[n][canPlaceHouse] != null)\\n\\t\\t\\treturn dp[n][canPlaceHouse];\\n\\t\\tlong ways = 0;\\n\\t\\t// we can place house\\n\\t\\tif (canPlaceHouse == 0) {\\n\\t\\t\\tways = countHousePlacements(n - 1, 1) % max + countHousePlacements(n - 1, 0) % max;\\n\\t\\t} else {\\n\\t\\t\\tways = countHousePlacements(n - 1, 0) % max;\\n\\t\\t}\\n\\t\\treturn dp[n][canPlaceHouse] = ways;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\tstatic Long dp[][];\\n\\tpublic static final int max = (int) Math.pow(10, 9) + 7;\\n\\n\\tpublic int countHousePlacements(int n) {\\n\\t\\tdp = new Long[n + 1][2];\\n\\t\\tlong ans = countHousePlacements(n, 0) + countHousePlacements(n, 1);\\n\\t\\treturn (int) ((ans * ans) % max);\\n\\t}\\n\\n\\tpublic long countHousePlacements(int n, int canPlaceHouse) {\\n\\t\\tif (n == 1)\\n\\t\\t\\treturn 1;\\n\\t\\tif (dp[n][canPlaceHouse] != null)\\n\\t\\t\\treturn dp[n][canPlaceHouse];\\n\\t\\tlong ways = 0;\\n\\t\\t// we can place house\\n\\t\\tif (canPlaceHouse == 0) {\\n\\t\\t\\tways = countHousePlacements(n - 1, 1) % max + countHousePlacements(n - 1, 0) % max;\\n\\t\\t} else {\\n\\t\\t\\tways = countHousePlacements(n - 1, 0) % max;\\n\\t\\t}\\n\\t\\treturn dp[n][canPlaceHouse] = ways;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222044,
                "title": "easy-cpp-explanation-fib-series",
                "content": "# Idea:\\n**If current plot has house then previous plot must have the space.\\nif current plot has space then previous plot can have house or space.**\\n\\nWe can apply same login on the another side also.\\nfinal ans = (ans of one side * ans of another side)\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        ll mod = 1000000007;\\n        \\n        ll space = 1, house = 1;\\n        ll totalWays = space + house;\\n        \\n        for(int i=2; i<=n; i++) {\\n\\t\\t\\t//If current plot has house\\n            house = space;\\n\\t\\t\\t//If current plot has space\\n            space = totalWays;\\n            totalWays = (space + house) % mod;\\n        }\\n        \\n        return (totalWays * totalWays) % mod;\\n        \\n\\t\\t//please upvote\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        ll mod = 1000000007;\\n        \\n        ll space = 1, house = 1;\\n        ll totalWays = space + house;\\n        \\n        for(int i=2; i<=n; i++) {\\n\\t\\t\\t//If current plot has house\\n            house = space;\\n\\t\\t\\t//If current plot has space\\n            space = totalWays;\\n            totalWays = (space + house) % mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2210385,
                "title": "java-solution-using-dp-fibonacci-series-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        if(n==1)    return 4;\\n        if(n==2)    return 9;\\n        long[] fibo = new long[n+1];\\n        fibo[1] = 2;\\n        fibo[2] = 3;\\n        long mod = (int)Math.pow(10,9) + 7;\\n        for(int i=3;i<=n;i++){\\n            fibo[i] = (fibo[i-1]+fibo[i-2])%mod;\\n        }\\n        return (int)(fibo[n]*fibo[n]%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        if(n==1)    return 4;\\n        if(n==2)    return 9;\\n        long[] fibo = new long[n+1];\\n        fibo[1] = 2;\\n        fibo[2] = 3;\\n        long mod = (int)Math.pow(10,9) + 7;\\n        for(int i=3;i<=n;i++){\\n            fibo[i] = (fibo[i-1]+fibo[i-2])%mod;\\n        }\\n        return (int)(fibo[n]*fibo[n]%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205765,
                "title": "c-beginner-friendly-observation-fibonacci-series-explained",
                "content": "TRY TO SEE PATTERNS\\u2026 \\n\\nIf N=1  , ans=4   i.e. 2x2\\n   N=2 ,  ans=9   i.e. 3x3\\n   N=3 ,  ans=25 i.e. 5x5\\n   N=4 ,  ans=64 i.e. 8x8\\n   N=5 ,  ans=169 i.e. 13x13\\n   \\u2026\\u2026\\u2026\\u2026..\\n   \\u2026\\u2026\\u2026\\u2026\\u2026\\u2026\\u2026\\n   \\u2026\\u2026\\u2026\\u2026\\u2026\\u2026\\u2026\\u2026\\u2026\\u2026  pattern goes on\\u2026.\\n\\n \\n\\n \\n\\n **We can clearly see, \\n F[1]=2;\\n F[2]=3;\\n F[N]=F[N-1]+F[N-2], \\n and the final result being F[N]*F[N]**\\n \\n```\\nclass Solution {\\npublic:\\n    long long int dp[10001];\\n    int mod=1000000007;\\n    int countHousePlacements(int n) {\\n        memset(dp,0,sizeof(dp));\\n        dp[1]=2;\\n        dp[2]=3;\\n        for(int i=3;i<=n;i++){\\n            dp[i]=dp[i-1]%mod+dp[i-2]%mod;\\n        }\\n        return (dp[n]%mod*dp[n]%mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int dp[10001];\\n    int mod=1000000007;\\n    int countHousePlacements(int n) {\\n        memset(dp,0,sizeof(dp));\\n        dp[1]=2;\\n        dp[2]=3;\\n        for(int i=3;i<=n;i++){\\n            dp[i]=dp[i-1]%mod+dp[i-2]%mod;\\n        }\\n        return (dp[n]%mod*dp[n]%mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201374,
                "title": "c-fibonacci-clean-and-concise-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        long long ans,mod=1e9 + 7;\\n        long long a=1,b=1,p;\\n        for(int i=0;i<n;i++)\\n        {\\n            p=a;\\n            a=(a+b)%mod;\\n            b=p;\\n        }\\n        ans= (a*a)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        long long ans,mod=1e9 + 7;\\n        long long a=1,b=1,p;\\n        for(int i=0;i<n;i++)\\n        {\\n            p=a;\\n            a=(a+b)%mod;\\n            b=p;\\n        }\\n        ans= (a*a)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200548,
                "title": "easy-c-solution-with-beginner-friendly-explanation",
                "content": "class Solution {\\npublic:\\n    int MOD = 1000000007;\\n    int countHousePlacements(int n) {\\n        \\n        // First we will calculate the no. of ways for only one side.\\n        \\n        // For 0 no. of plots, we cannot place anything, so for it the ans is zero.\\n        \\n        long long  oldcountspace = 1; // For 1 no. of plots, we can have one space. \\n        long long  oldcountbuilding = 1; // For 1 no. of plots, we can have one building.  \\n        \\n        \\n        // Down below -- i is the no. of plots till n.\\n        // Now for each i we will calculate no. of ways in which sequence is ending with a space or a building.\\n        \\n        // Ex :\\n        // 1(No. of plots) - S (ending with space)\\n        // 1 - B (ending with building)\\n        \\n        // 2 -  SS BS (added space to previous ways)\\n        // 2 - SB (can only add building if last one has space)\\n        \\n        // 3 - SSS BSS SBS\\n        // 3 -  SSB BSB\\n        \\n        // ans so on\\n        \\n        // Here the observation is that we can only add buildings if at the last recent place doesn\\'t have building.\\n        // But for space no condition is there, hence we can add space to both the ways.\\n        \\n        \\n      \\n        // In here, i am just calculating the newValues, and later assigning them to older values so that thet can be used again for further calculation.\\n        // I have just omitted the dp table for better space complexity.\\n        for (int i = 2; i <= n ; i++){\\n            long long  newcountspace = (oldcountspace + oldcountbuilding) % MOD;    \\n            long long  newcountBuilding = (oldcountspace) % MOD;\\n            \\n            \\n            oldcountspace = (newcountspace) % MOD;\\n            oldcountbuilding = (newcountBuilding) % MOD;\\n        }\\n        \\n\\t\\t// At the end, we will add both ways that are ending with a space and that are ending with a building.\\n\\t\\t// Then we will square the ans as for each way of placing on one side, there are the same no. of ways for other side also.\\n        return (((oldcountspace + oldcountbuilding) % MOD)  * ((oldcountspace + oldcountbuilding) % MOD)) % MOD;\\n    }\\n    \\n    \\n    // Do upvote if you understood the solution.\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int MOD = 1000000007;\\n    int countHousePlacements(int n) {\\n        \\n        // First we will calculate the no. of ways for only one side.\\n        \\n        // For 0 no. of plots, we cannot place anything, so for it the ans is zero.\\n        \\n        long long  oldcountspace = 1; // For 1 no. of plots, we can have one space. \\n        long long  oldcountbuilding = 1; // For 1 no. of plots, we can have one building.  \\n        \\n        \\n        // Down below -- i is the no. of plots till n.\\n        // Now for each i we will calculate no. of ways in which sequence is ending with a space or a building.\\n        \\n        // Ex :\\n        // 1(No. of plots) - S (ending with space)\\n        // 1 - B (ending with building)\\n        \\n        // 2 -  SS BS (added space to previous ways)\\n        // 2 - SB (can only add building if last one has space)\\n        \\n        // 3 - SSS BSS SBS\\n        // 3 -  SSB BSB\\n        \\n        // ans so on\\n        \\n        // Here the observation is that we can only add buildings if at the last recent place doesn\\'t have building.\\n        // But for space no condition is there, hence we can add space to both the ways.\\n        \\n        \\n      \\n        // In here, i am just calculating the newValues, and later assigning them to older values so that thet can be used again for further calculation.\\n        // I have just omitted the dp table for better space complexity.\\n        for (int i = 2; i <= n ; i++){\\n            long long  newcountspace = (oldcountspace + oldcountbuilding) % MOD;    \\n            long long  newcountBuilding = (oldcountspace) % MOD;\\n            \\n            \\n            oldcountspace = (newcountspace) % MOD;\\n            oldcountbuilding = (newcountBuilding) % MOD;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2200037,
                "title": "easy-approach-squared-fibonacci-series-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        \\n        long modulo = 1000000007;\\n        vector<long> vect(n+5);\\n        vect[1] = 2, vect[2] = 3;\\n        for(int i=3; i<=n; i++){\\n            vect[i] = (vect[i-1] + vect[i-2]) % modulo;\\n        }\\n        return (vect[n] * vect[n]) % modulo;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        \\n        long modulo = 1000000007;\\n        vector<long> vect(n+5);\\n        vect[1] = 2, vect[2] = 3;\\n        for(int i=3; i<=n; i++){\\n            vect[i] = (vect[i-1] + vect[i-2]) % modulo;\\n        }\\n        return (vect[n] * vect[n]) % modulo;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199035,
                "title": "java-dp-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countHousePlacements(int n) \\n    {\\n        int MOD = 1000000007;\\n        long[] dp = new long[n];\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            long place = (i + 2 >= n)? 1 : dp[i + 2];\\n            long notPlace = (i + 1 >= n)? 1 : dp[i + 1];\\n            dp[i] = (place + notPlace) % MOD;\\n        }\\n        long ans = dp[0];\\n        return (int)((ans * ans) % MOD);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countHousePlacements(int n) \\n    {\\n        int MOD = 1000000007;\\n        long[] dp = new long[n];\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            long place = (i + 2 >= n)? 1 : dp[i + 2];\\n            long notPlace = (i + 1 >= n)? 1 : dp[i + 1];\\n            dp[i] = (place + notPlace) % MOD;\\n        }\\n        long ans = dp[0];\\n        return (int)((ans * ans) % MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198987,
                "title": "java-simple-dp-solution",
                "content": "```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        long m=1000000007;\\n        long dp[]=new long[n+1];\\n        dp[0]=1;\\n        dp[1]=2;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=(dp[i-1]+dp[i-2])%m;\\n        }\\n        return (int)((dp[n]*dp[n])%m);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        long m=1000000007;\\n        long dp[]=new long[n+1];\\n        dp[0]=1;\\n        dp[1]=2;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=(dp[i-1]+dp[i-2])%m;\\n        }\\n        return (int)((dp[n]*dp[n])%m);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198974,
                "title": "c-dp-solution-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    \\n    int countHousePlacements(int n) \\n    {\\n        vector<vector<long long>> dp(n+1, vector<long long> (3,-1));\\n        \\n        long long res = f(n,0,true,dp)%mod; \\n        res = (res%mod * res%mod)%mod; // the total permutations will be squared because there are two streets and we found out total ways for one of them\\n        \\n        res%= mod;\\n        \\n        return res;\\n    }\\n    \\n    int f(int n, int index, bool ctake,vector<vector<long long>>& dp)\\n    {\\n        if(index == n)\\n        {\\n           return 1; // we have reached the end of the street\\n        }\\n        \\n        if(dp[index][ctake]!=-1)\\n        {\\n            return dp[index][ctake];\\n        }\\n        \\n        long long sum = 0;\\n        if(ctake)\\n        {\\n            sum = (sum + f(n,index+1,false,dp)%mod)%mod; // if we can place the house here\\n        }\\n        \\n        sum = (sum +  f(n,index+1,true,dp)%mod)%mod; // if we don\\'t place the house here\\n        \\n        return dp[index][ctake] = sum; // storing \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    \\n    int countHousePlacements(int n) \\n    {\\n        vector<vector<long long>> dp(n+1, vector<long long> (3,-1));\\n        \\n        long long res = f(n,0,true,dp)%mod; \\n        res = (res%mod * res%mod)%mod; // the total permutations will be squared because there are two streets and we found out total ways for one of them\\n        \\n        res%= mod;\\n        \\n        return res;\\n    }\\n    \\n    int f(int n, int index, bool ctake,vector<vector<long long>>& dp)\\n    {\\n        if(index == n)\\n        {\\n           return 1; // we have reached the end of the street\\n        }\\n        \\n        if(dp[index][ctake]!=-1)\\n        {\\n            return dp[index][ctake];\\n        }\\n        \\n        long long sum = 0;\\n        if(ctake)\\n        {\\n            sum = (sum + f(n,index+1,false,dp)%mod)%mod; // if we can place the house here\\n        }\\n        \\n        sum = (sum +  f(n,index+1,true,dp)%mod)%mod; // if we don\\'t place the house here\\n        \\n        return dp[index][ctake] = sum; // storing \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198967,
                "title": "easy-c-code-memoization-fibonacci",
                "content": "**Approach 1 - Recursion + Memoization**\\n\\n*Time Complexity = O(N)\\nSpace Complexity = O(N)*\\n```\\nclass Solution {\\npublic:\\n    \\n    long long int mod = 1e9+7; // Initalized modulo m globally so it can be used in every function\\n    \\n    int solve(int index, int n, vector<int> &dp){\\n        \\n        if(index >= n){ // base case if index becomes greater\\n            return 1;\\n        }\\n        \\n        if(dp[index] != -1) return dp[index]; // if particular case is solved, just return. No need to solve again\\n        \\n        int take = 0 + solve(index + 2 , n , dp); \\n        // If \\'0\\'th index is taken we cannot take \\'1\\'st index, we can only take \\'i + 2\\'th index\\n        \\n        int notTake = solve(index + 1 , n , dp);\\n        //If \\'0\\'th index is not taken we can take the \\'1\\'st index\\n        \\n        return dp[index] = (take % mod + notTake % mod) % mod;\\n        // modulo m is taken of integer overflows\\n        // How to take modulo m of two numbers in addition\\n        // say you have number \\'a\\' and \\'b\\' and you want to inquire that number doesn\\'t overflow\\n        // a + b = ((a % mod) + (b % mod))%mod\\n    }\\n    int countHousePlacements(int n) {\\n        \\n        vector<int> dp(n, -1); // DP array for memoization\\n        \\n        int ans = solve(0 , n , dp); // recursion call with memoization\\n        \\n        return ((ans % mod) * (ans % mod)) % mod;\\n        // a * b = ((a % mod) * (b % mod))%mod\\n    }\\n};\\n```\\n\\n\\n\\n**Approach 2 - Fibonacci Implementation**\\n*Time Complexity = O(N)\\nSpace Complexity = O(1)*\\n\\n```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    int countHousePlacements(int N) {\\n        // if N = 1 total number of ways are 4 = 2*2\\n        // if N = 2 total number of ways are 9 = 3*3\\n        // if N = 3 total number of ways are 25 = 5*5\\n        // this forms a fibonacci series -> 2, 3, 5, 8, ... => current number = sum of previous two numbers\\n        \\n        if(N==1) return 2*2; \\n\\t    if(N==2) return 3*3;\\n        \\n\\t    long long  first=2;\\n\\t    long long  second=3;\\n\\t    long long  third;\\n        \\n\\t    for(int i=2 ; i<N ; i++)\\n\\t    {\\n\\t        third = ((first % mod) + (second % mod)) % mod;\\n\\t        first = second % mod;\\n\\t        second = third % mod;\\n\\t    }\\n\\t    long long int ans= ((third % mod) * (third % mod))%mod;\\n\\t    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long int mod = 1e9+7; // Initalized modulo m globally so it can be used in every function\\n    \\n    int solve(int index, int n, vector<int> &dp){\\n        \\n        if(index >= n){ // base case if index becomes greater\\n            return 1;\\n        }\\n        \\n        if(dp[index] != -1) return dp[index]; // if particular case is solved, just return. No need to solve again\\n        \\n        int take = 0 + solve(index + 2 , n , dp); \\n        // If \\'0\\'th index is taken we cannot take \\'1\\'st index, we can only take \\'i + 2\\'th index\\n        \\n        int notTake = solve(index + 1 , n , dp);\\n        //If \\'0\\'th index is not taken we can take the \\'1\\'st index\\n        \\n        return dp[index] = (take % mod + notTake % mod) % mod;\\n        // modulo m is taken of integer overflows\\n        // How to take modulo m of two numbers in addition\\n        // say you have number \\'a\\' and \\'b\\' and you want to inquire that number doesn\\'t overflow\\n        // a + b = ((a % mod) + (b % mod))%mod\\n    }\\n    int countHousePlacements(int n) {\\n        \\n        vector<int> dp(n, -1); // DP array for memoization\\n        \\n        int ans = solve(0 , n , dp); // recursion call with memoization\\n        \\n        return ((ans % mod) * (ans % mod)) % mod;\\n        // a * b = ((a % mod) * (b % mod))%mod\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9+7;\\n    int countHousePlacements(int N) {\\n        // if N = 1 total number of ways are 4 = 2*2\\n        // if N = 2 total number of ways are 9 = 3*3\\n        // if N = 3 total number of ways are 25 = 5*5\\n        // this forms a fibonacci series -> 2, 3, 5, 8, ... => current number = sum of previous two numbers\\n        \\n        if(N==1) return 2*2; \\n\\t    if(N==2) return 3*3;\\n        \\n\\t    long long  first=2;\\n\\t    long long  second=3;\\n\\t    long long  third;\\n        \\n\\t    for(int i=2 ; i<N ; i++)\\n\\t    {\\n\\t        third = ((first % mod) + (second % mod)) % mod;\\n\\t        first = second % mod;\\n\\t        second = third % mod;\\n\\t    }\\n\\t    long long int ans= ((third % mod) * (third % mod))%mod;\\n\\t    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198712,
                "title": "python-fibonacci-explanation",
                "content": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        \"\"\"\\n        Explanation:\\n        Consider there are `n` slots and let T(n) be the number of choices to select.\\n        Now if the first slot is left empty, then there are n-1 empty slots and T(n-1) options\\n        But if a house is placed on first slot, then we cannot place it on the second slot so there are only n-2 slots left and thus T(n-2) options.\\n        \\n        Therefore T(n) = T(n-1) + T(n-2)\\n        which is basically fibonaaci relation ship\\n        \\n        \"\"\"\\n        a = 1\\n        b = 1\\n        if n == 0:\\n            return a\\n        if n == 1:\\n            return (a+b) ** 2\\n        arr = [1,4]\\n        MOD = 10**9 + 7\\n        \\n        for i in range(2, n+1, 1):\\n            a, b = b, (a+b)%MOD\\n            arr.append((a+b)**2 % MOD)\\n        return arr[n]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        \"\"\"\\n        Explanation:\\n        Consider there are `n` slots and let T(n) be the number of choices to select.\\n        Now if the first slot is left empty, then there are n-1 empty slots and T(n-1) options\\n        But if a house is placed on first slot, then we cannot place it on the second slot so there are only n-2 slots left and thus T(n-2) options.\\n        \\n        Therefore T(n) = T(n-1) + T(n-2)\\n        which is basically fibonaaci relation ship\\n        \\n        \"\"\"\\n        a = 1\\n        b = 1\\n        if n == 0:\\n            return a\\n        if n == 1:\\n            return (a+b) ** 2\\n        arr = [1,4]\\n        MOD = 10**9 + 7\\n        \\n        for i in range(2, n+1, 1):\\n            a, b = b, (a+b)%MOD\\n            arr.append((a+b)**2 % MOD)\\n        return arr[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198546,
                "title": "c-memoization-with-explanation",
                "content": "The question boils down to number of ways we can place houses in an array of n indices such that no two houses are adjacent.\\nSince for either street we will have same number of ways to place no adjacent houses, the ans will be sqaure of the number of ways.\\nNow for each index we have two options:-\\n->We place a house in that index\\n->We donot place a house\\nIf we place a house then we cannot place another house adjacent to it so we reduce index by 2.\\nIf we dont place a house then we can place a house in the next index. so we reduce index by 1.\\n**Base Case**:-\\nIf we reach index 0, then we have 2 options, either to place a house in it or not.\\nif we reach negative index then we have only 1 way i.e. cannot pick it.\\n\\nFinally we return the sum of all possible ways.\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int recur(int ind,vector<long long>& dp){\\n        if(ind==0){\\n            return 2;\\n        }\\n        if(ind<0){\\n            return 1;\\n        }\\n        if(dp[ind]!=-1){\\n            return dp[ind];\\n        }\\n        return dp[ind]=(recur(ind-1,dp)+recur(ind-2,dp))%mod;\\n    }\\n    int countHousePlacements(int n) {\\n        vector<long long> dp(n,-1);\\n        long long x=recur(n-1,dp);\\n        return (x*x)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int recur(int ind,vector<long long>& dp){\\n        if(ind==0){\\n            return 2;\\n        }\\n        if(ind<0){\\n            return 1;\\n        }\\n        if(dp[ind]!=-1){\\n            return dp[ind];\\n        }\\n        return dp[ind]=(recur(ind-1,dp)+recur(ind-2,dp))%mod;\\n    }\\n    int countHousePlacements(int n) {\\n        vector<long long> dp(n,-1);\\n        long long x=recur(n-1,dp);\\n        return (x*x)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198452,
                "title": "c-fib-dp",
                "content": "\\ttypedef long long ll;\\n\\t#define mod 1000000007\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countHousePlacements(int n) {\\n\\t\\t\\tll dp[10001];\\n\\t\\t\\tdp[1] = 2;\\n\\t\\t\\tdp[2] = 3;\\n\\t\\t\\tfor(int i=3;i<=n;i++) dp[i] = (dp[i-1] + dp[i-2])%mod;\\n\\t\\t\\treturn (dp[n]*dp[n])%mod;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint countHousePlacements(int n) {\\n\\t\\t\\tll dp[10001];\\n\\t\\t\\tdp[1] = 2;\\n\\t\\t\\tdp[2] = 3;\\n\\t\\t\\tfor(int i=3;i<=n;i++) dp[i] = (dp[i-1] + dp[i-2])%mod;\\n\\t\\t\\treturn (dp[n]*dp[n])%mod;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2198414,
                "title": "short-python-dp-solution",
                "content": "a: number of cases w/o house placed on the current plot\\nb: number of cases w/ house placed on the current plot\\n```\\na = b = 1\\nfor _ in range(n - 1):\\n\\ta, b = a + b, a\\nreturn (a + b) ** 2 % (10 ** 9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\na = b = 1\\nfor _ in range(n - 1):\\n\\ta, b = a + b, a\\nreturn (a + b) ** 2 % (10 ** 9 + 7)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198408,
                "title": "c-fibonacci-dp",
                "content": "Upvote if it helps :)\\n```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n         int mod=1000000007;\\n         vector<long long> v(n+1,0);\\n         v[0]=1;\\n         v[1]=2;\\n         for(int i=2;i<=n;i++)\\n         {\\n             v[i]=(v[i-1]+v[i-2])%mod;\\n         }\\n        long long res=v[n];\\n        return (res*res)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n         int mod=1000000007;\\n         vector<long long> v(n+1,0);\\n         v[0]=1;\\n         v[1]=2;\\n         for(int i=2;i<=n;i++)\\n         {\\n             v[i]=(v[i-1]+v[i-2])%mod;\\n         }\\n        long long res=v[n];\\n        return (res*res)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198315,
                "title": "python-easy-solution-fibonacci-pattern-o-n",
                "content": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        prev, pprev = 2,1\\n        for i in range(1,n):\\n            temp = pprev+prev\\n            pprev= prev\\n            prev = temp\\n        return (prev**2)%(10**9+7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        prev, pprev = 2,1\\n        for i in range(1,n):\\n            temp = pprev+prev\\n            pprev= prev\\n            prev = temp\\n        return (prev**2)%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198294,
                "title": "c-pick-not-pick-dp",
                "content": "```\\nlong long int helper( int n,vector<long long int> &dp){\\n    if(n == 1) return dp[n] = 2;  \\n    if(n == 2) return dp[n] =  3;       \\n    if(dp[n] != -1) return dp[n];\\n\\n    \\n       long long int pick,npick,mod = (1e9+7);\\n\\n       pick = helper(n-2,dp)%mod;\\n       npick = helper(n-1,dp)%mod;\\n            \\n       return dp[n] = (pick+npick)%mod;\\n} \\n    int countHousePlacements(int N) \\n    {\\n     vector<long long int> dp(N+1,-1);\\n     helper(N,dp);\\n     long long int mod = (1e9+7);\\n     return (dp[N]*dp[N])%mod;    \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nlong long int helper( int n,vector<long long int> &dp){\\n    if(n == 1) return dp[n] = 2;  \\n    if(n == 2) return dp[n] =  3;       \\n    if(dp[n] != -1) return dp[n];\\n\\n    \\n       long long int pick,npick,mod = (1e9+7);\\n\\n       pick = helper(n-2,dp)%mod;\\n       npick = helper(n-1,dp)%mod;\\n            \\n       return dp[n] = (pick+npick)%mod;\\n} \\n    int countHousePlacements(int N) \\n    {\\n     vector<long long int> dp(N+1,-1);\\n     helper(N,dp);\\n     long long int mod = (1e9+7);\\n     return (dp[N]*dp[N])%mod;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198261,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int m=1e9+7,ub;\\n    int dp[10001][2][2];\\n    int countHousePlacements(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        ub=n;\\n        return helper(1,false,false);\\n    }\\n   long helper(int idx,int up,int low ){\\n        if(idx==ub+1)\\n            return 1;\\n        if(dp[idx][up][low]!=-1)\\n            return dp[idx][up][low];\\n        long ans=0;\\n        if(up==false && low==false){\\n           ans= helper(idx+1,true,true)+ helper(idx+1,true,false)+ helper(idx+1,false,true)+helper(idx+1,false,false);\\n        }\\n        else if(up && !low){\\n           ans= helper(idx+1,false,true)+ helper(idx+1,false,false);\\n        }\\n        else if(!up && low){\\n           ans= helper(idx+1,true,false)+helper(idx+1,false,false);            \\n        }\\n        else\\n           ans+= helper(idx+1,false,false);            \\n        ans%=m;\\n        dp[idx][up][low]=ans;\\n       return ans;\\n    }\\n};\\n```\\nDo UPVOTE if it helps :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m=1e9+7,ub;\\n    int dp[10001][2][2];\\n    int countHousePlacements(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        ub=n;\\n        return helper(1,false,false);\\n    }\\n   long helper(int idx,int up,int low ){\\n        if(idx==ub+1)\\n            return 1;\\n        if(dp[idx][up][low]!=-1)\\n            return dp[idx][up][low];\\n        long ans=0;\\n        if(up==false && low==false){\\n           ans= helper(idx+1,true,true)+ helper(idx+1,true,false)+ helper(idx+1,false,true)+helper(idx+1,false,false);\\n        }\\n        else if(up && !low){\\n           ans= helper(idx+1,false,true)+ helper(idx+1,false,false);\\n        }\\n        else if(!up && low){\\n           ans= helper(idx+1,true,false)+helper(idx+1,false,false);            \\n        }\\n        else\\n           ans+= helper(idx+1,false,false);            \\n        ans%=m;\\n        dp[idx][up][low]=ans;\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198180,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    long long fun(int n,vector<long long>& dp)\\n    {       \\n        if(n<=0) return 1;     \\n        if(dp[n]!=-1) return dp[n];\\n        \\n        long long res=0;\\n        \\n        res=(res%mod+fun(n-1,dp)%mod)%mod;\\n        res=(res%mod+fun(n-2,dp)%mod)%mod;\\n        \\n        return dp[n]=res;\\n    }\\n    \\n    int countHousePlacements(int n) {\\n        vector<long long> dp(n+1,-1);\\n        long long x=fun(n,dp);\\n        \\n        x=((x%mod)*1LL*(x%mod))%mod;\\n        \\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    long long fun(int n,vector<long long>& dp)\\n    {       \\n        if(n<=0) return 1;     \\n        if(dp[n]!=-1) return dp[n];\\n        \\n        long long res=0;\\n        \\n        res=(res%mod+fun(n-1,dp)%mod)%mod;\\n        res=(res%mod+fun(n-2,dp)%mod)%mod;\\n        \\n        return dp[n]=res;\\n    }\\n    \\n    int countHousePlacements(int n) {\\n        vector<long long> dp(n+1,-1);\\n        long long x=fun(n,dp);\\n        \\n        x=((x%mod)*1LL*(x%mod))%mod;\\n        \\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198178,
                "title": "simply-squares-of-fibonacci-number-c",
                "content": "\\nSimply Squares of fibonacci number . \\n```\\nclass Solution {\\npublic:\\n    int m = 1000000007;\\n    int countHousePlacements(int n) {\\n        long long aa = 1, bb = 1, c;\\n        \\n        while(n--){\\n            c = (aa + bb) % m;\\n            aa = bb;\\n            bb = c;\\n        }\\n        \\n        c = (c * c) % m;\\n            \\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m = 1000000007;\\n    int countHousePlacements(int n) {\\n        long long aa = 1, bb = 1, c;\\n        \\n        while(n--){\\n            c = (aa + bb) % m;\\n            aa = bb;\\n            bb = c;\\n        }\\n        \\n        c = (c * c) % m;\\n            \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198153,
                "title": "cpp-easy-fibonacci-o-n-o-1",
                "content": "````\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll mod=1e9+7;\\n    int countHousePlacements(int n) {  \\n\\t   ll a = 1;\\n       ll b = 1;\\n       ll c = 0;\\n       for(int i=0;i<n;i++){\\n           c = (a + b)%mod;\\n           a = b%mod;\\n           b = c%mod;\\n       }\\n       c = c*c;\\n       c = c % mod;  \\n       return c;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll mod=1e9+7;\\n    int countHousePlacements(int n) {  \\n\\t   ll a = 1;\\n       ll b = 1;\\n       ll c = 0;\\n       for(int i=0;i<n;i++){\\n           c = (a + b)%mod;\\n           a = b%mod;\\n           b = c%mod;\\n       }\\n       c = c*c;\\n       c = c % mod;  \\n       return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094037,
                "title": "simple-python-solution-using-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe key to this problem is recognizing that the solution sequence grows in a fibonacci type way. Specifically for input n the result will be fib(n+1)**2 (modded out) where fib(n) is the n-th fibonacci number (assumming fib(0) = fib(1) = 1).\\n\\nThis pattern arises as each side of the road is independent of the other, so we simply square the possibilities of one side to get the total combinations, and the combinations of one side of the road follow the fibonacci sequence.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculating the fibonacci sequence manually is a slow and computationally expensive process. Using recursion leads to the same values getting computer over and over again. Thus, using memoization to store the values of fib allows for the function to not waste time repeating computations, drastically improving performance. Here we use a pre-built memoization tool from the functools library, but we can easily do this manually.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this algorithm is O(n) since we need to compute the n-th fibonacci number. Since we use memoization, this involves computing each value for fib from 0-n once (beats 95.60%).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity here is a bit complicated, but generally O(n) as we are simply storing the value of each fibonacci number from 0-n. We could save space by not performing memoization and not using recursion, but this would drastically increase the computation time (beats 26.37%).\\n# Code\\n```\\nfrom functools import cache\\n@cache\\ndef fib(n):\\n    if n == 0 or n == 1:\\n        return 1\\n    return fib(n-1) + fib(n-2)\\nclass Solution:\\n\\n    def countHousePlacements(self, n: int) -> int:\\n        return fib(n+1)**2 % (10**9+7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import cache\\n@cache\\ndef fib(n):\\n    if n == 0 or n == 1:\\n        return 1\\n    return fib(n-1) + fib(n-2)\\nclass Solution:\\n\\n    def countHousePlacements(self, n: int) -> int:\\n        return fib(n+1)**2 % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043098,
                "title": "easy-to-understand-dp-approach-with-recursive-definition",
                "content": "# Code\\n```\\nfunc countHousePlacements(n int) int {\\n    ans := make([][]int, n+1)\\n    for i := 1; i<=n; i++ {\\n        if i == 1 {\\n            ans[i] = []int{4,2,2,1}\\n        } else {\\n            ans[i] = make([]int,4)\\n            ans[i][0] = (ans[i-1][0] + ans[i-1][1] + ans[i-1][2] + ans[i-1][3]) % 1000000007\\n            ans[i][1] = (ans[i-1][0] + ans[i-1][2]) % 1000000007\\n            ans[i][2] = (ans[i-1][0] + ans[i-1][1]) % 1000000007\\n            ans[i][3] = ans[i-1][0]\\n        }\\n    }\\n    return ans[n][0]\\n}\\n\\n/*func ways(prev, remaining int) int {\\n    ans := 0\\n    if remaining == 1 {\\n        if prev == 0 {\\n            ans = 4\\n        } else if prev == 1 {\\n            ans = 2\\n        } else if prev == 2 {\\n            ans = 2\\n        } else {\\n            ans = 1\\n        }\\n    } else {\\n        if prev == 0 {\\n            ans =  ways(0, remaining-1) + ways(1, remaining-1) + ways(2, remaining-1) + ways(3, remaining-1)        \\n        } else if prev == 1 {\\n            ans = ways(2, remaining-1) + ways(0, remaining-1)\\n        } else if prev == 2 {\\n            ans = ways(1, remaining-1) + ways(0, remaining-1)\\n        } else {\\n            ans = ways(0, remaining-1)\\n        }\\n    }\\n\\n    return ans\\n}*/\\n\\n// 0 => 1,2,3,0\\n// 1 => 2,0\\n// 2 => 1,0\\n// 3 => 0\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countHousePlacements(n int) int {\\n    ans := make([][]int, n+1)\\n    for i := 1; i<=n; i++ {\\n        if i == 1 {\\n            ans[i] = []int{4,2,2,1}\\n        } else {\\n            ans[i] = make([]int,4)\\n            ans[i][0] = (ans[i-1][0] + ans[i-1][1] + ans[i-1][2] + ans[i-1][3]) % 1000000007\\n            ans[i][1] = (ans[i-1][0] + ans[i-1][2]) % 1000000007\\n            ans[i][2] = (ans[i-1][0] + ans[i-1][1]) % 1000000007\\n            ans[i][3] = ans[i-1][0]\\n        }\\n    }\\n    return ans[n][0]\\n}\\n\\n/*func ways(prev, remaining int) int {\\n    ans := 0\\n    if remaining == 1 {\\n        if prev == 0 {\\n            ans = 4\\n        } else if prev == 1 {\\n            ans = 2\\n        } else if prev == 2 {\\n            ans = 2\\n        } else {\\n            ans = 1\\n        }\\n    } else {\\n        if prev == 0 {\\n            ans =  ways(0, remaining-1) + ways(1, remaining-1) + ways(2, remaining-1) + ways(3, remaining-1)        \\n        } else if prev == 1 {\\n            ans = ways(2, remaining-1) + ways(0, remaining-1)\\n        } else if prev == 2 {\\n            ans = ways(1, remaining-1) + ways(0, remaining-1)\\n        } else {\\n            ans = ways(0, remaining-1)\\n        }\\n    }\\n\\n    return ans\\n}*/\\n\\n// 0 => 1,2,3,0\\n// 1 => 2,0\\n// 2 => 1,0\\n// 3 => 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015894,
                "title": "0ms-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAchieve fibbinocci pattern and then sqaure it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize an array dp with base cases to avoid redundant calculations using a flag, and return the square of the count modulo a constant mod.\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass Solution {\\n    public static int mod = 1000000007;\\n    static boolean flag = false;\\n    static long[] dp = new long[10001];\\n    \\n    static {\\n        dp[0] = (long)1;\\n        dp[1] = (long)2;\\n    }\\n\\n    static int countHousePlacements(int n) {\\n\\n        if (!flag) {\\n            for (int i = 2; i <= 10000; i++) {\\n                dp[i] = dp[i - 1]%mod + dp[i - 2]%mod;\\n            }\\n            flag = true;\\n        }\\n        long ans = (int)((dp[n]) % mod);\\n        \\n        return (int)((ans * ans) % mod);\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        one = 1\\n        two = 2 # 1, 1, 2, 3, 5\\n        \\n        for i in range(2, n+1):\\n            one, two = two, one + two\\n\\n        return (two ** 2) % (10**9 + 7)            \\n```\\n\\n\\n\\n# Credits\\n `@codingoptimize ` - `Java`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public static int mod = 1000000007;\\n    static boolean flag = false;\\n    static long[] dp = new long[10001];\\n    \\n    static {\\n        dp[0] = (long)1;\\n        dp[1] = (long)2;\\n    }\\n\\n    static int countHousePlacements(int n) {\\n\\n        if (!flag) {\\n            for (int i = 2; i <= 10000; i++) {\\n                dp[i] = dp[i - 1]%mod + dp[i - 2]%mod;\\n            }\\n            flag = true;\\n        }\\n        long ans = (int)((dp[n]) % mod);\\n        \\n        return (int)((ans * ans) % mod);\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        one = 1\\n        two = 2 # 1, 1, 2, 3, 5\\n        \\n        for i in range(2, n+1):\\n            one, two = two, one + two\\n\\n        return (two ** 2) % (10**9 + 7)            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001997,
                "title": "easy-dp-cpp",
                "content": "# Intuition\\nTo count the number of ways to place houses on the street such that no two houses are adjacent, you can use dynamic programming. The intuition is that you can build the solution for n plots based on the solutions for n-1 and n-2 plots.\\n\\n# Approach\\nYour approach is to use dynamic programming to calculate the number of ways to place houses. You initialize a vector `dp` to store the number of ways for each number of plots from 0 to n. You start with the base cases `dp[0] = 1` and `dp[1] = 2` because there is one way to have no houses (empty plots) and two ways to have one house (either on the left or right side).\\n\\nThen, you iterate from `i = 2` to `n`, and for each `i`, you calculate `dp[i]` as the sum of `dp[i-1]` and `dp[i-2]`, which represents the number of ways to place houses without adjacent houses on one side of the street.\\n\\nFinally, you return the square of `dp[n]` modulo `1e9+7`, as there are two sides of the street, and you want to count the total ways for both sides.\\n\\n# Complexity\\n- Time complexity: Your loop runs for `n` iterations, making it a linear time complexity, O(n).\\n- Space complexity: Your space complexity is O(n) because you are using a vector of size n+1 to store the intermediate results.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        int mod=1e9+7;\\n        vector<long long>dp(n+1,0);\\n        dp[0]=1;\\n        dp[1]=2;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=(dp[i-1]+dp[i-2])%mod;\\n        }\\n        return (dp[n]*dp[n])%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        int mod=1e9+7;\\n        vector<long long>dp(n+1,0);\\n        dp[0]=1;\\n        dp[1]=2;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=(dp[i-1]+dp[i-2])%mod;\\n        }\\n        return (dp[n]*dp[n])%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969531,
                "title": "dp-c-easy-to-understand",
                "content": "# Approach\\nDP\\n\\n# Complexity\\n- Time complexity:\\n`O(n)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod = (int) 1e9 + 7;\\n    void add(int &x, const int &y) {\\n        x += y;\\n        if (x >= mod) {\\n            x -= mod;\\n        }\\n    }\\n    int countHousePlacements(int n) {\\n        vector<vector<vector<int>>> dp(2, vector<vector<int>>(2, vector<int> (n, -1)));\\n        function <int(int, int, int)> cal = [&] (int pos, int lhs, int rhs) {\\n            if (pos >= n) {\\n                return 1;\\n            }\\n            int &memo = dp[rhs][lhs][pos];\\n            if (memo != -1) {\\n                return memo;\\n            }\\n\\n            int sum = 0;\\n            if (!lhs) {\\n                add(sum, cal(pos + 1, 0, 1));\\n            }\\n            if (!rhs) {\\n                add(sum ,cal(pos + 1, 1, 0));\\n            }\\n            if (!lhs && !rhs) {\\n                add(sum, cal(pos + 1, 1, 1));\\n            }\\n            add(sum, cal(pos + 1, 0, 0));\\n\\n            return memo = sum;\\n        };\\n\\n        return cal(0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = (int) 1e9 + 7;\\n    void add(int &x, const int &y) {\\n        x += y;\\n        if (x >= mod) {\\n            x -= mod;\\n        }\\n    }\\n    int countHousePlacements(int n) {\\n        vector<vector<vector<int>>> dp(2, vector<vector<int>>(2, vector<int> (n, -1)));\\n        function <int(int, int, int)> cal = [&] (int pos, int lhs, int rhs) {\\n            if (pos >= n) {\\n                return 1;\\n            }\\n            int &memo = dp[rhs][lhs][pos];\\n            if (memo != -1) {\\n                return memo;\\n            }\\n\\n            int sum = 0;\\n            if (!lhs) {\\n                add(sum, cal(pos + 1, 0, 1));\\n            }\\n            if (!rhs) {\\n                add(sum ,cal(pos + 1, 1, 0));\\n            }\\n            if (!lhs && !rhs) {\\n                add(sum, cal(pos + 1, 1, 1));\\n            }\\n            add(sum, cal(pos + 1, 0, 0));\\n\\n            return memo = sum;\\n        };\\n\\n        return cal(0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908495,
                "title": "c-beats-100-simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n)\\n    {\\n        if(n<=2){return (n+1)*(n+1);}\\n        int x = 2;int y = 3;\\n        for(int i=3;i<=n;i++)\\n        {\\n            int z = (x+y)%(1000000007);\\n            x = y;\\n            y = z;\\n        }\\n        long long yres = y;\\n        yres*=yres;\\n        return yres%(1000000007);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n)\\n    {\\n        if(n<=2){return (n+1)*(n+1);}\\n        int x = 2;int y = 3;\\n        for(int i=3;i<=n;i++)\\n        {\\n            int z = (x+y)%(1000000007);\\n            x = y;\\n            y = z;\\n        }\\n        long long yres = y;\\n        yres*=yres;\\n        return yres%(1000000007);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835097,
                "title": "c-fibonacci-squared",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all we can easily see that, both sides of the streets are *independent*, that\\'s why if we know solution for the one side of the street with `n` locations, the final solution will `solution(n) * solution(n)`.  \\n\\nTo solve for just one side of the road, we can see that\\n\\n```\\nsolution[k] = solution[k - 1] + solution[k - 2]\\n                    ^                   ^\\n          (when we skip k location)     |\\n                         (when we build on k location)   \\n```\\n\\nwhich is the formula for *Fibonacci number*. So\\n\\n```\\nSolution(n) = Fibo(n)\\nFinalSolution(n) = Fibo(n) * Fibo(n)\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple loop to compute `n`th Fibonacci number, sqaure of it is the answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountHousePlacements(int n) {\\n        const int mod = 1_000_000_007;\\n\\n        long a = 0;\\n        long b = 1;\\n\\n        for (int i = 0; i <= n; ++i)\\n            (a, b) = (b, (a + b) % mod);\\n\\n        return (int)((b * b) % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nsolution[k] = solution[k - 1] + solution[k - 2]\\n                    ^                   ^\\n          (when we skip k location)     |\\n                         (when we build on k location)   \\n```\n```\\nSolution(n) = Fibo(n)\\nFinalSolution(n) = Fibo(n) * Fibo(n)\\n```\n```\\npublic class Solution {\\n    public int CountHousePlacements(int n) {\\n        const int mod = 1_000_000_007;\\n\\n        long a = 0;\\n        long b = 1;\\n\\n        for (int i = 0; i <= n; ++i)\\n            (a, b) = (b, (a + b) % mod);\\n\\n        return (int)((b * b) % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798647,
                "title": "fibonacci-squared",
                "content": "**linear fibo**\\n```\\nint countHousePlacements(int n)\\n{\\n\\tint b{1}, a{1};\\n\\tfor( ; n--; a = exchange(b, (a+b)%1000000007));\\n\\treturn 1ll*b*b%1000000007;\\n}\\n```\\n**logarithmic fibo**\\n**RECURSION (left to right):**\\n\\n```\\nclass Solution\\n{\\n    const long long p = 1000000007;\\npublic:\\n    pair<long long, long long> F(int n)\\n    {\\n        if(!n) return {0ll,1ll};\\n        const auto & [x, y] = F(n/2);\\n        auto a = (x*x+2*x*y)%p,\\n             b = (x*x+  y*y)%p;\\n        return n&1 ? pair{(a+b)%p, a} : pair{a, b};\\n    }\\n    \\n    int countHousePlacements(int n)\\n    {      \\n        const auto & [f, _] = F(n+2);\\n        return f*f%p;\\n    }\\n};\\n```\\n**ITERATION(right to left):**\\n\\n![image](https://assets.leetcode.com/users/images/5569250c-a3e1-41de-b601-0d76585d95f6_1690045885.1683857.png)\\n\\n```\\nint countHousePlacements(int n)\\n{      \\n\\tlong long a{}, b{1}, c{1}, d{}, p{1000000007};       \\n\\tfor(n+=2; n; n>>=1)\\n\\t{\\n\\t\\tif(n&1) \\n\\t\\t{\\n\\t\\t\\tlong long a_ = (a*(c+d)+b*c)%p,\\n\\t\\t\\t\\t\\t  b_ = (a*c+b*d)%p;\\n\\t\\t\\ta=a_, b=b_;    \\n\\t\\t}\\n\\t\\tlong long c_ = c*(c+2*d)%p,\\n\\t\\t\\t\\t  d_ = (c*c+d*d)%p;\\n\\t\\tc=c_, d=d_;\\n\\t}\\n\\treturn a*a%p;\\n}\\n```\\nhttps://www.nayuki.io/page/fast-fibonacci-algorithms\\nhttps://en.wikibooks.org/wiki/Algorithm_Implementation/Mathematics/Fibonacci_Number_Program\\n[50. Pow(x, n)](https://leetcode.com/problems/powx-n/discuss/1076605/2-strategies-many-variations)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint countHousePlacements(int n)\\n{\\n\\tint b{1}, a{1};\\n\\tfor( ; n--; a = exchange(b, (a+b)%1000000007));\\n\\treturn 1ll*b*b%1000000007;\\n}\\n```\n```\\nclass Solution\\n{\\n    const long long p = 1000000007;\\npublic:\\n    pair<long long, long long> F(int n)\\n    {\\n        if(!n) return {0ll,1ll};\\n        const auto & [x, y] = F(n/2);\\n        auto a = (x*x+2*x*y)%p,\\n             b = (x*x+  y*y)%p;\\n        return n&1 ? pair{(a+b)%p, a} : pair{a, b};\\n    }\\n    \\n    int countHousePlacements(int n)\\n    {      \\n        const auto & [f, _] = F(n+2);\\n        return f*f%p;\\n    }\\n};\\n```\n```\\nint countHousePlacements(int n)\\n{      \\n\\tlong long a{}, b{1}, c{1}, d{}, p{1000000007};       \\n\\tfor(n+=2; n; n>>=1)\\n\\t{\\n\\t\\tif(n&1) \\n\\t\\t{\\n\\t\\t\\tlong long a_ = (a*(c+d)+b*c)%p,\\n\\t\\t\\t\\t\\t  b_ = (a*c+b*d)%p;\\n\\t\\t\\ta=a_, b=b_;    \\n\\t\\t}\\n\\t\\tlong long c_ = c*(c+2*d)%p,\\n\\t\\t\\t\\t  d_ = (c*c+d*d)%p;\\n\\t\\tc=c_, d=d_;\\n\\t}\\n\\treturn a*a%p;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795351,
                "title": "java-0-1-knapsack-dp-memoization",
                "content": "# Complexity\\n- Time complexity: $$O(n * 2 * 2)$$ (Recursion)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n * 2 * 2)$$ (DP) + $$O(n)$$ (Recursion Stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private final int mod = (int) 1e9 + 7;\\n    private Long[][][] dp;\\n\\n    public int countHousePlacements(int n) {\\n        dp = new Long[n][2][2];\\n        return (int)(solve(0, false, false, n) % mod);    \\n    }\\n\\n    private long solve(int idx, boolean prevUpLane, boolean prevDownLane, int n) {\\n        if(idx == n) return 1;\\n        if(dp[idx][prevUpLane ? 1 : 0][prevDownLane ? 1 : 0] != null) {\\n            return dp[idx][prevUpLane ? 1 : 0][prevDownLane ? 1 : 0];\\n        }\\n        long ways = 0;\\n        if(!prevUpLane && !prevDownLane) {\\n            ways += solve(idx + 1, true, false, n) + solve(idx + 1, false, true, n) \\n                    + solve(idx + 1, true, true, n);\\n        }\\n        else if(!prevUpLane && prevDownLane) {\\n            ways += solve(idx + 1, true, false, n);\\n        }\\n        else if(prevUpLane && !prevDownLane) {\\n            ways += solve(idx + 1, false, true, n);\\n        }\\n        ways += solve(idx + 1, false, false, n);\\n        return dp[idx][prevUpLane ? 1 : 0][prevDownLane ? 1 : 0] = ways % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private final int mod = (int) 1e9 + 7;\\n    private Long[][][] dp;\\n\\n    public int countHousePlacements(int n) {\\n        dp = new Long[n][2][2];\\n        return (int)(solve(0, false, false, n) % mod);    \\n    }\\n\\n    private long solve(int idx, boolean prevUpLane, boolean prevDownLane, int n) {\\n        if(idx == n) return 1;\\n        if(dp[idx][prevUpLane ? 1 : 0][prevDownLane ? 1 : 0] != null) {\\n            return dp[idx][prevUpLane ? 1 : 0][prevDownLane ? 1 : 0];\\n        }\\n        long ways = 0;\\n        if(!prevUpLane && !prevDownLane) {\\n            ways += solve(idx + 1, true, false, n) + solve(idx + 1, false, true, n) \\n                    + solve(idx + 1, true, true, n);\\n        }\\n        else if(!prevUpLane && prevDownLane) {\\n            ways += solve(idx + 1, true, false, n);\\n        }\\n        else if(prevUpLane && !prevDownLane) {\\n            ways += solve(idx + 1, false, true, n);\\n        }\\n        ways += solve(idx + 1, false, false, n);\\n        return dp[idx][prevUpLane ? 1 : 0][prevDownLane ? 1 : 0] = ways % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763658,
                "title": "c-python-dynamic-programming-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/8fc6dc64-034a-46d9-97dc-9473eea95bbf_1689330015.8009634.png)\\n\\nWe can only consider one side, and return the answer afer square because two sides are independent.\\ntc is O(n), sc is O(1)\\n\\n### python\\n```python\\nmod = int(1e9+7)\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n\\t\\n\\t\\t# dp_0 is number of ways to position i without a house\\n\\t\\t# dp_1 is number of ways to position i with a house\\n\\t\\t\\n\\t\\t# if there has no house at position n, position n-1 can be no house or with a house\\n\\t\\t# if there has a house at position n, position n-1 must be no house\\n\\t\\t\\n\\t\\t# First, dp[1][0] is 1, dp[1][1] is 1.\\n        dp_0 = dp_1 = 1\\n\\t\\t\\n        for i in range(2, n+1):\\n            tmp = dp_0\\n            dp_0 = (dp_0 + dp_1) % mod\\n            dp_1 = tmp;\\n\\n        return (dp_0 + dp_1) ** 2 % mod\\n```\\n\\n### c++\\n```cpp\\nconst int mod = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        int dp_0 = 1, dp_1 = 1;\\n        for (int i = 2, tmp; i <= n; i++) {\\n            tmp = dp_0;\\n            dp_0 = (dp_0 + dp_1) % mod;\\n            dp_1 = tmp;\\n        }\\n        long s = dp_0 + dp_1;\\n        return s * s % mod; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```python\\nmod = int(1e9+7)\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n\\t\\n\\t\\t# dp_0 is number of ways to position i without a house\\n\\t\\t# dp_1 is number of ways to position i with a house\\n\\t\\t\\n\\t\\t# if there has no house at position n, position n-1 can be no house or with a house\\n\\t\\t# if there has a house at position n, position n-1 must be no house\\n\\t\\t\\n\\t\\t# First, dp[1][0] is 1, dp[1][1] is 1.\\n        dp_0 = dp_1 = 1\\n\\t\\t\\n        for i in range(2, n+1):\\n            tmp = dp_0\\n            dp_0 = (dp_0 + dp_1) % mod\\n            dp_1 = tmp;\\n\\n        return (dp_0 + dp_1) ** 2 % mod\\n```\n```cpp\\nconst int mod = 1e9 + 7;\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        int dp_0 = 1, dp_1 = 1;\\n        for (int i = 2, tmp; i <= n; i++) {\\n            tmp = dp_0;\\n            dp_0 = (dp_0 + dp_1) % mod;\\n            dp_1 = tmp;\\n        }\\n        long s = dp_0 + dp_1;\\n        return s * s % mod; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741208,
                "title": "java-recurssion-and-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    int mod=(int)(1e9+7);\\n    public int countHousePlacements(int n) {\\n        int dp[]=new int[n];\\n        Arrays.fill(dp,-1);\\n        long ans = wayys(0 , n ,dp);\\n\\n        return (int) (((ans % mod) * (ans % mod)) % mod);\\n    }\\n    public int wayys(int idx,int n,int[]dp){\\n        if(idx>=n){\\n            return  1;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        int take=wayys(idx+2,n,dp);\\n        int nottake=wayys(idx+1,n,dp);\\n        return  dp[idx]=((take%mod)+(nottake%mod))%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    int mod=(int)(1e9+7);\\n    public int countHousePlacements(int n) {\\n        int dp[]=new int[n];\\n        Arrays.fill(dp,-1);\\n        long ans = wayys(0 , n ,dp);\\n\\n        return (int) (((ans % mod) * (ans % mod)) % mod);\\n    }\\n    public int wayys(int idx,int n,int[]dp){\\n        if(idx>=n){\\n            return  1;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        int take=wayys(idx+2,n,dp);\\n        int nottake=wayys(idx+1,n,dp);\\n        return  dp[idx]=((take%mod)+(nottake%mod))%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710848,
                "title": "c-commented-and-explained",
                "content": "# Intuition\\nThe problem requires counting the number of valid house placements, where adjacent houses cannot be taken. We can use dynamic programming with memoization to solve this problem efficiently.\\n# Approach\\nCreate a recursive helper function helper that takes the current index ind, a flag house (indicating whether the previous house was taken or not), a 2D dp array for memoization, and the total number of houses n.\\nIf ind reaches n, it means all houses have been considered, and a valid placement has been found. In this case, return 1.\\nIf the result for the current state (ind, house) is already calculated and stored in dp, return it.\\nOtherwise, calculate the result for the current state:\\nOption 1: Not taking the current house. Recursively call helper(ind + 1, 1, dp, n) to calculate the number of valid placements for the next house with the house flag set to 1 (indicating the previous house was taken).\\nOption 2: Taking the current house. If house is 1 (indicating the previous house was taken), recursively call helper(ind + 1, 0, dp, n) to calculate the number of valid placements for the next house with the house flag set to 0 (indicating the previous house was not taken).\\nThe result for the current state (ind, house) is the sum of the results from the above two options.\\nStore the result in dp for future use and return it.\\nIn the countHousePlacements function:\\n\\nInitialize a 2D dp array with dimensions (n + 1) x 2 and fill it with -1 values to store the results of subproblems.\\nCall the helper function with initial parameters ind = 0, house = 1, dp, and n.\\nTake the modulo mod of the calculated result to prevent overflow and store it in the ans variable.\\nCalculate the final result as (ans * ans) % mod, which represents the count of house placements modulo mod.\\nReturn the final result.\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution is O(n), where n is the total number of houses. This is because the helper function is called for each house only once, and the results are memoized in the dp array.\\n\\n\\n- Space complexity:\\nThe space complexity is O(n) as we are using a 2D dp array of dimensions (n + 1) x 2 to store the results of subproblems.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n    int helper(int ind, int house, vector<vector<int>>&dp,int n)\\n    {\\n        if(ind==n)//if we have considered all the houses return 1;\\n        {\\n            return 1;\\n        }\\n        if(dp[ind][house]!=-1)//memoization\\n        return dp[ind][house];\\n\\n        int nt=helper(ind+1,1,dp,n);//setting house to 1, that means we can take the house next time as this time we haven\\'t taken it.\\n        int t=0;\\n        if(house==1)//if house is availabe to take then only we move to the take part.\\n        {\\n            t=helper(ind+1,0,dp,n);//taken the house so exhausted it, make house to 0.\\n        }\\n        return dp[ind][house]=(t+nt)%mod;//add all possibilities we get.\\n    }\\n    int countHousePlacements(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(2,-1));//dp for n (no of houses ) and flag(house taken or not taken so 0 or 1)\\n        long long ans=helper(0,1,dp,n)%mod;\\n        return (ans*ans)%mod;//we are multiplying ans with ans because we will get the same possibility of placing the houses on either side.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\n    int helper(int ind, int house, vector<vector<int>>&dp,int n)\\n    {\\n        if(ind==n)//if we have considered all the houses return 1;\\n        {\\n            return 1;\\n        }\\n        if(dp[ind][house]!=-1)//memoization\\n        return dp[ind][house];\\n\\n        int nt=helper(ind+1,1,dp,n);//setting house to 1, that means we can take the house next time as this time we haven\\'t taken it.\\n        int t=0;\\n        if(house==1)//if house is availabe to take then only we move to the take part.\\n        {\\n            t=helper(ind+1,0,dp,n);//taken the house so exhausted it, make house to 0.\\n        }\\n        return dp[ind][house]=(t+nt)%mod;//add all possibilities we get.\\n    }\\n    int countHousePlacements(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(2,-1));//dp for n (no of houses ) and flag(house taken or not taken so 0 or 1)\\n        long long ans=helper(0,1,dp,n)%mod;\\n        return (ans*ans)%mod;//we are multiplying ans with ans because we will get the same possibility of placing the houses on either side.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701823,
                "title": "similar-to-fibonacci-series",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOn caculating manually the values : \\nn = 0 -> 1^2\\nn = 1 -> 2^2\\nn = 2 -> 3^2\\nn = 3 -> 5^2\\nn = 4 -> 8^2\\n...\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int check(int n, vector<int> &dp) {\\n        if (n <= 1)\\n            return n+1;\\n        if (dp[n] != -1)   \\n            return dp[n]%1000000007;\\n            \\n        return dp[n] = (check(n-1, dp) + check(n-2, dp))%1000000007;\\n    }\\n    int countHousePlacements(int n) {\\n        vector<int> dp(n+1, -1);\\n        long long ans = check(n, dp);\\n        return (ans*ans)%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(int n, vector<int> &dp) {\\n        if (n <= 1)\\n            return n+1;\\n        if (dp[n] != -1)   \\n            return dp[n]%1000000007;\\n            \\n        return dp[n] = (check(n-1, dp) + check(n-2, dp))%1000000007;\\n    }\\n    int countHousePlacements(int n) {\\n        vector<int> dp(n+1, -1);\\n        long long ans = check(n, dp);\\n        return (ans*ans)%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698206,
                "title": "c-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe number of possible ways of placing houses in one side of the row is the same as on the other side. To calculate how many different arangements there are, taking both sides into consideration, the number of arangements per side are multiplied together.\\n\\nThis is $$both\\\\_sides(n) = one\\\\_side(n)^2$$. The function $$both\\\\_sides(n)$$ is our answer.\\n\\nLets define some functions:\\n\\n$$free\\\\_parcel(n)$$: number of **arrangements** with a parcel of size $$n$$ where the last parcel is free.\\n$$occ\\\\_parcel(n)$$: number of **arrangements** with a parcel of size $$n$$ where the last parcel is occupied.\\n\\n$$free\\\\_parcel(n) = free\\\\_parcel(n-1) + occ\\\\_parcel(n-1)$$\\n$$occ\\\\_parcel(n) = free\\\\_parcel(n-1)$$ This to avoid having arrangements with two adjacent houses.\\n\\n\\n\\n$$one\\\\_side(n) = free\\\\_parcel(n) + occ\\\\_parcel(n)$$\\n\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursive approach. A binary power function is used to comply with the MOD requirement.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    static const int MOD = 1e9 + 7;\\n\\n    int binpow(ll a, ll b) {\\n        if (b == 0) return 1;\\n        if (b & 1) {\\n            return (a * binpow(a, b-1)) % MOD;\\n        } else {\\n            ll r = binpow(a, b/2);\\n            return (r * r) % MOD;\\n        }\\n    }\\n\\n    pair<ll, ll> get_free_used(int n) {\\n        if (n == 1) return {1, 1};\\n        auto x = get_free_used(n-1);\\n        return {(x.second + x.first) % MOD, x.first}; \\n    }\\n\\n    int countHousePlacements(int n) {\\n        auto x = get_free_used(n);\\n        return binpow((x.first + x.second) % MOD, 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    static const int MOD = 1e9 + 7;\\n\\n    int binpow(ll a, ll b) {\\n        if (b == 0) return 1;\\n        if (b & 1) {\\n            return (a * binpow(a, b-1)) % MOD;\\n        } else {\\n            ll r = binpow(a, b/2);\\n            return (r * r) % MOD;\\n        }\\n    }\\n\\n    pair<ll, ll> get_free_used(int n) {\\n        if (n == 1) return {1, 1};\\n        auto x = get_free_used(n-1);\\n        return {(x.second + x.first) % MOD, x.first}; \\n    }\\n\\n    int countHousePlacements(int n) {\\n        auto x = get_free_used(n);\\n        return binpow((x.first + x.second) % MOD, 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696739,
                "title": "simple-c-solution-recursion-memoization-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nlong long hope(int index1,int &n,vector<long long>&dp){\\n    if(index1>=n)return 1;\\n   // if(dp[index1][index2]!=-1)return dp[index1][index2];\\n   if(dp[index1]!=-1)return dp[index1];\\n    long long way1=0;\\n    long long way2=0;\\n    /*\\n    if(index1<n && index2<n){\\n        way1=hope(index1+2,index2+2,n,dp)%mod;\\n        way2=hope(index1+2,index2+1,n,dp)%mod;\\n        way3=hope(index1+1,index2+2,n,dp)%mod;\\n        way4=hope(index1+1,index2+1,n,dp)%mod;\\n    }\\n    else if(index1<n && index2>=n){\\n        way1=hope(index1+2,index2+1,n,dp)%mod;\\n        way2=hope(index1+1,index2+1,n,dp)%mod;\\n    }\\n        else if(index2<n && index1>=n){\\n        way1=hope(index1+1,index2+2,n,dp)%mod;\\n        way2=hope(index1+1,index2+1,n,dp)%mod;\\n    }\\n    */\\n    way1=hope(index1+1,n,dp)%mod;\\n    way2=hope(index1+2,n,dp)%mod;\\n    return dp[index1]=(way1+way2)%mod;\\n}\\n    int countHousePlacements(int n) {\\n\\n        //vector<vector<long long>>dp(2*n,vector<long long>(2*n,-1));\\n        vector<long long>dp(n+3,-1);\\n        long long res=hope(0,n,dp)%mod;\\n        long long answer=((res%mod)*(res%mod))%mod;\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nlong long hope(int index1,int &n,vector<long long>&dp){\\n    if(index1>=n)return 1;\\n   // if(dp[index1][index2]!=-1)return dp[index1][index2];\\n   if(dp[index1]!=-1)return dp[index1];\\n    long long way1=0;\\n    long long way2=0;\\n    /*\\n    if(index1<n && index2<n){\\n        way1=hope(index1+2,index2+2,n,dp)%mod;\\n        way2=hope(index1+2,index2+1,n,dp)%mod;\\n        way3=hope(index1+1,index2+2,n,dp)%mod;\\n        way4=hope(index1+1,index2+1,n,dp)%mod;\\n    }\\n    else if(index1<n && index2>=n){\\n        way1=hope(index1+2,index2+1,n,dp)%mod;\\n        way2=hope(index1+1,index2+1,n,dp)%mod;\\n    }\\n        else if(index2<n && index1>=n){\\n        way1=hope(index1+1,index2+2,n,dp)%mod;\\n        way2=hope(index1+1,index2+1,n,dp)%mod;\\n    }\\n    */\\n    way1=hope(index1+1,n,dp)%mod;\\n    way2=hope(index1+2,n,dp)%mod;\\n    return dp[index1]=(way1+way2)%mod;\\n}\\n    int countHousePlacements(int n) {\\n\\n        //vector<vector<long long>>dp(2*n,vector<long long>(2*n,-1));\\n        vector<long long>dp(n+3,-1);\\n        long long res=hope(0,n,dp)%mod;\\n        long long answer=((res%mod)*(res%mod))%mod;\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685481,
                "title": "java-math-solution-beats-80-runtime-100-memory",
                "content": "# Intuition\\nManually calculating the first few test cases gives us outputs of 4, 9, 25, and 64 for inputs 1, 2, 3, and 4, respectively. Taking the square root of these outputs yields 2, 3, 5, and 8. This looks like the Fibonacci sequence. Thus, we need to map our inputs correctly to the proper term in the Fibonacci sequence, and the square of that term will be our answer. It also helps that the Fibonacci sequence holds true under any mod. \\n\\n# Approach\\nWe can set up a helper method to find the proper Fibonacci term. Afterwards, we simply square and return the answer mod 1000000007. Gang gang gang!\\n\\n# Complexity\\nTime complexity is linear since `fiboMod()` iterates from N to 2 just once. Space complexity is O(1) since `fiboMod()` only uses an array of size 2. \\n\\n# Code\\n```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        long out = fiboMod(n);\\n        out *= out;\\n        out %= 1000000007;\\n        return (int)out;\\n    }\\n\\n    static long fiboMod(int x) {\\n        int[] dp = new int[]{2, 3};\\n        if (x < 3) { return dp[x-1]; }\\n        int temp;\\n        while (x > 2) {\\n            temp = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] += temp;\\n            dp[1] %= 1000000007;\\n            x--;\\n        }\\n        return dp[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        long out = fiboMod(n);\\n        out *= out;\\n        out %= 1000000007;\\n        return (int)out;\\n    }\\n\\n    static long fiboMod(int x) {\\n        int[] dp = new int[]{2, 3};\\n        if (x < 3) { return dp[x-1]; }\\n        int temp;\\n        while (x > 2) {\\n            temp = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] += temp;\\n            dp[1] %= 1000000007;\\n            x--;\\n        }\\n        return dp[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645636,
                "title": "fastest-linear-in-speed-constant-in-memory-super-easy",
                "content": "This question is analog to https://leetcode.com/problems/climbing-stairs/ \\n\\nWe can either place a house on the top, bottom, or both depending on where they are placed on the previous column. \\n\\n# Code\\n```\\n#include <cstring>\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        int mod =1e9 + 7;\\n        unsigned long long int dp[4];\\n        // memset(dp, 1, sizeof (dp));\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n        dp[3] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            unsigned long long int s0 = (dp[0] + dp[1] + dp[2] + dp[3]) % mod;\\n            unsigned long long int s1 = (dp[0] + dp[2]) % mod;\\n            unsigned long long int s2 = (dp[0] + dp[1]) % mod;\\n            unsigned long long int s3 = dp[0];\\n\\n            dp[0] = s0 % mod;\\n            dp[1] = s1 % mod;\\n            dp[2] = s2 % mod;\\n            dp[3] = s3 % mod;\\n        }\\n        \\n        unsigned long long int result = 0;\\n        for (auto x : dp) {\\n            result += x;\\n        }\\n        return result % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <cstring>\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        int mod =1e9 + 7;\\n        unsigned long long int dp[4];\\n        // memset(dp, 1, sizeof (dp));\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n        dp[3] = 1;\\n        for (int i = 2; i <= n; i++) {\\n            unsigned long long int s0 = (dp[0] + dp[1] + dp[2] + dp[3]) % mod;\\n            unsigned long long int s1 = (dp[0] + dp[2]) % mod;\\n            unsigned long long int s2 = (dp[0] + dp[1]) % mod;\\n            unsigned long long int s3 = dp[0];\\n\\n            dp[0] = s0 % mod;\\n            dp[1] = s1 % mod;\\n            dp[2] = s2 % mod;\\n            dp[3] = s3 % mod;\\n        }\\n        \\n        unsigned long long int result = 0;\\n        for (auto x : dp) {\\n            result += x;\\n        }\\n        return result % mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3584021,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        x,y=2,1\\n        for i in range(1,n):\\n            z=x+y\\n            y,x=x,z\\n        return (x**2)%(10**9+7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        x,y=2,1\\n        for i in range(1,n):\\n            z=x+y\\n            y,x=x,z\\n        return (x**2)%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549961,
                "title": "3-lines-c-fibonacci",
                "content": "# Intuition\\nResult = Fibonacci(n)^2\\n\\n# Approach\\nFibonacci iteration is:\\n```\\nfor(int i = 0; i<=n; i++)\\n{\\n    var c = a + b;\\n    b = a;\\n    a = c;\\n}\\n```\\nOr using cortege:\\n```\\nwhile(n--!=0) ( a , b ) = ( a+b , a );\\n```\\n \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountHousePlacements(int n) {\\n        (int m, long a, long b) = (1000000007,1,1);\\n        while(n--!=0) (a,b) = ((a+b)%m,a);\\n        return (int)((a*a)%m);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nfor(int i = 0; i<=n; i++)\\n{\\n    var c = a + b;\\n    b = a;\\n    a = c;\\n}\\n```\n```\\nwhile(n--!=0) ( a , b ) = ( a+b , a );\\n```\n```\\npublic class Solution {\\n    public int CountHousePlacements(int n) {\\n        (int m, long a, long b) = (1000000007,1,1);\\n        while(n--!=0) (a,b) = ((a+b)%m,a);\\n        return (int)((a*a)%m);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517156,
                "title": "fibobacci-like-seq-ez-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int md = 1e9 + 7;\\n    long long int mulmod(long long int a, long long int b, long long int mod) {\\n    long long int res = 0; \\n    a = a % mod;\\n    while (b > 0)\\n    {\\n        if (b % 2 == 1) {\\n            res = (res + a) % mod;\\n        }\\n        a = (a * 2) % mod;\\n        b /= 2;\\n    }\\n    return res % mod;\\n    }\\n    int countHousePlacements(int n) {\\n        vector<int> dp(n + 1, 0);\\n        long long int ans = 0;\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        for (int i = 0; i <= n; ++i) {\\n            if (i > 1) {\\n                dp[i] = (dp[i - 1] + dp[i - 2] + 1) % md;\\n            }\\n        }\\n        return mulmod(dp[n] + 1, dp[n] + 1, md);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int md = 1e9 + 7;\\n    long long int mulmod(long long int a, long long int b, long long int mod) {\\n    long long int res = 0; \\n    a = a % mod;\\n    while (b > 0)\\n    {\\n        if (b % 2 == 1) {\\n            res = (res + a) % mod;\\n        }\\n        a = (a * 2) % mod;\\n        b /= 2;\\n    }\\n    return res % mod;\\n    }\\n    int countHousePlacements(int n) {\\n        vector<int> dp(n + 1, 0);\\n        long long int ans = 0;\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        for (int i = 0; i <= n; ++i) {\\n            if (i > 1) {\\n                dp[i] = (dp[i - 1] + dp[i - 2] + 1) % md;\\n            }\\n        }\\n        return mulmod(dp[n] + 1, dp[n] + 1, md);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461809,
                "title": "python-squares-of-fibonacci-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNoticed that the answers to test cases were squares of Fibonacci numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind (n+2)th Fib number, square it and take mod 10**9 + 7\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) for finding the Fib number\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        #1,1,2,3,5,8,13,21,34,55\\n\\n        def find_fib(i):\\n            a, b = 1, 1\\n\\n            for j in range(i):\\n                a, b = b, a+b\\n            return b\\n\\n        return (find_fib(n)**2) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        #1,1,2,3,5,8,13,21,34,55\\n\\n        def find_fib(i):\\n            a, b = 1, 1\\n\\n            for j in range(i):\\n                a, b = b, a+b\\n            return b\\n\\n        return (find_fib(n)**2) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402048,
                "title": "c-memoization-explicit-description",
                "content": "# Intuition\\nThe use of two plots is a red herring.\\nThe problem we must actually solve, is the number of ways in which we can place houses on a row of plots of length n.\\nThis is somewhat similar to Fibonacci.\\n\\nOnce we calculate the ways in which we can place houses on one row, to get the possibilities for two rows, we just do $$n ^ 2$$.\\n\\n# Approach\\nWe make use of the following rules:\\n- A building can only be placed after a space\\n- An empty space can be placed after a building, or an empty space\\n\\n```\\nn = 1\\nS // Place Space\\nB // Place Building\\n\\nn = 2\\n// Try to place Space. Can place after Space\\nS  S\\n// or after Building.\\nS  B\\n\\n// Try to place Building. Can only place after Space\\nB  S\\n\\nn = 3\\nS  S S\\nS  S B\\n\\nS  B S\\n\\nB  S S\\nB  S B\\n\\nn = ???\\nS <- countEndsWithSpace(n - 1)\\nS <- countEndsWithBuilding(n - 1)\\n\\nB <- countEndsWithSpace(n - 1)\\n-------\\n// to get total placement ways for n, \\n// we add the ways in which we can place,\\n// ending with a Space and ending with a Building\\ncountEndsWithSpace(n) + countEndsWithBuilding(n)\\n\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountHousePlacements(int n) {\\n        // declare modulo number and local function to apply it\\n        var modulo = (Convert.ToInt32(1e9) + 7);\\n\\n        long ApplyModulo(long n) {\\n            var small = n % modulo;\\n            // if number is negative, return positive instead by adding modulo number again\\n            if (small <= 0) return modulo + small;\\n            return small;\\n        }\\n\\n        // use dictionaries to memoize results of recursive formula\\n        // NOTE: the values themselves are long, will not fit into int\\n        var countEndBuilding = new Dictionary<int, long>();\\n        var countEndSpace = new Dictionary<int, long>();\\n        countEndBuilding[1] = 1;\\n        countEndSpace[1] = 1;\\n\\n        long EndBuildingRecurse(int n) {\\n            // if result is already memoized, return it directly\\n            if (countEndBuilding.TryGetValue(n, out var value)) return value;\\n            \\n            // calculate number of ways we can place\\n            // for ending with building, it depends just on ending with space for n - 1\\n            var ways = ApplyModulo(EndSpaceRecurse(n - 1));\\n            \\n            // memoize result once obtained\\n            countEndBuilding.Add(n, ways);\\n            return ways;\\n        }\\n\\n        long EndSpaceRecurse(int n) {\\n            if (countEndSpace.TryGetValue(n, out var value)) return value;\\n            \\n            // for ending with space, we add ways ending with space and ending with building for n - 1\\n            var ways = \\n                ApplyModulo(EndSpaceRecurse(n - 1)) \\n                    + \\n                ApplyModulo(EndBuildingRecurse(n - 1));\\n            \\n            countEndSpace.Add(n, ways);\\n            return ways;\\n        }\\n\\n        var result = EndSpaceRecurse(n) + EndBuildingRecurse(n);\\n\\n        result = ApplyModulo(result);\\n\\n        // multiply result by itself in order to obtain the ways of placing for two rows of houses\\n        result = ApplyModulo(result * result);\\n        return Convert.ToInt32(result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nn = 1\\nS // Place Space\\nB // Place Building\\n\\nn = 2\\n// Try to place Space. Can place after Space\\nS  S\\n// or after Building.\\nS  B\\n\\n// Try to place Building. Can only place after Space\\nB  S\\n\\nn = 3\\nS  S S\\nS  S B\\n\\nS  B S\\n\\nB  S S\\nB  S B\\n\\nn = ???\\nS <- countEndsWithSpace(n - 1)\\nS <- countEndsWithBuilding(n - 1)\\n\\nB <- countEndsWithSpace(n - 1)\\n-------\\n// to get total placement ways for n, \\n// we add the ways in which we can place,\\n// ending with a Space and ending with a Building\\ncountEndsWithSpace(n) + countEndsWithBuilding(n)\\n\\n```\n```\\npublic class Solution {\\n    public int CountHousePlacements(int n) {\\n        // declare modulo number and local function to apply it\\n        var modulo = (Convert.ToInt32(1e9) + 7);\\n\\n        long ApplyModulo(long n) {\\n            var small = n % modulo;\\n            // if number is negative, return positive instead by adding modulo number again\\n            if (small <= 0) return modulo + small;\\n            return small;\\n        }\\n\\n        // use dictionaries to memoize results of recursive formula\\n        // NOTE: the values themselves are long, will not fit into int\\n        var countEndBuilding = new Dictionary<int, long>();\\n        var countEndSpace = new Dictionary<int, long>();\\n        countEndBuilding[1] = 1;\\n        countEndSpace[1] = 1;\\n\\n        long EndBuildingRecurse(int n) {\\n            // if result is already memoized, return it directly\\n            if (countEndBuilding.TryGetValue(n, out var value)) return value;\\n            \\n            // calculate number of ways we can place\\n            // for ending with building, it depends just on ending with space for n - 1\\n            var ways = ApplyModulo(EndSpaceRecurse(n - 1));\\n            \\n            // memoize result once obtained\\n            countEndBuilding.Add(n, ways);\\n            return ways;\\n        }\\n\\n        long EndSpaceRecurse(int n) {\\n            if (countEndSpace.TryGetValue(n, out var value)) return value;\\n            \\n            // for ending with space, we add ways ending with space and ending with building for n - 1\\n            var ways = \\n                ApplyModulo(EndSpaceRecurse(n - 1)) \\n                    + \\n                ApplyModulo(EndBuildingRecurse(n - 1));\\n            \\n            countEndSpace.Add(n, ways);\\n            return ways;\\n        }\\n\\n        var result = EndSpaceRecurse(n) + EndBuildingRecurse(n);\\n\\n        result = ApplyModulo(result);\\n\\n        // multiply result by itself in order to obtain the ways of placing for two rows of houses\\n        result = ApplyModulo(result * result);\\n        return Convert.ToInt32(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382817,
                "title": "easy-and-neat-clean-code-java-beats-100-dp",
                "content": "# Intuition\\nsimilar to house robber, can\\'t rob two consecutive houses.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n//IDEA : consider one side, and do square of it(symmtery)\\nclass Solution {\\n    final int MOD = (int) 1e9 + 7;\\n    public int countHousePlacements(int n) {\\n        int dp[] = new int[n + 2];\\n        dp[0] = dp[1] = 1;\\n        for (int i = 2; i < n + 2; i++)\\n            dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;\\n        return (int) ((dp[n + 1] * 1L * dp[n + 1]) % MOD);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n//IDEA : consider one side, and do square of it(symmtery)\\nclass Solution {\\n    final int MOD = (int) 1e9 + 7;\\n    public int countHousePlacements(int n) {\\n        int dp[] = new int[n + 2];\\n        dp[0] = dp[1] = 1;\\n        for (int i = 2; i < n + 2; i++)\\n            dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;\\n        return (int) ((dp[n + 1] * 1L * dp[n + 1]) % MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368389,
                "title": "java-solution-no-time-taken-one-line-code-0-sec",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    long m = 1000000007;\\n    long[] dp;\\n    \\n    public int countHousePlacements(int n) {\\n        this.dp = new long[n+1];\\n        Arrays.fill(this.dp, -1);\\n        long ans = this.solve(n);\\n        return (int)((ans* ans)%this.m);\\n        \\n    }\\n    \\n    // Returns all possible ways we can palce houses in N palces\\n    public long solve(int n){\\n        \\n        // base case (no place left to place a new home)\\n        if(n <= 0){\\n            return 1;\\n        }\\n        \\n        // Early return\\n        if(dp[n] != -1){\\n            return this.dp[n];\\n        }\\n        \\n        long usedCurrPlace = 1L * this.solve(n-2);\\n        long notUsedCurrPlace = 1L * this.solve(n-1);\\n        \\n        return this.dp[n] = (usedCurrPlace + notUsedCurrPlace)%this.m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long m = 1000000007;\\n    long[] dp;\\n    \\n    public int countHousePlacements(int n) {\\n        this.dp = new long[n+1];\\n        Arrays.fill(this.dp, -1);\\n        long ans = this.solve(n);\\n        return (int)((ans* ans)%this.m);\\n        \\n    }\\n    \\n    // Returns all possible ways we can palce houses in N palces\\n    public long solve(int n){\\n        \\n        // base case (no place left to place a new home)\\n        if(n <= 0){\\n            return 1;\\n        }\\n        \\n        // Early return\\n        if(dp[n] != -1){\\n            return this.dp[n];\\n        }\\n        \\n        long usedCurrPlace = 1L * this.solve(n-2);\\n        long notUsedCurrPlace = 1L * this.solve(n-1);\\n        \\n        return this.dp[n] = (usedCurrPlace + notUsedCurrPlace)%this.m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244780,
                "title": "c-fibonacci-o-n-0ms",
                "content": "# Intuition\\nFibonacci series\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int countHousePlacements(int n) {\\n        int num = findNum(n);\\n        return ((long long)num * num) % mod;\\n    }\\n\\n    int findNum(int n) {\\n        if(n == 1 || n == 2)\\n            return n+1;\\n            \\n        int a = 2, b = 3, c;\\n\\n        for(int i=2; i<n; i++) {\\n            c = (a+b) % mod;\\n            a = b;\\n            b = c;\\n        }\\n        return c;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int countHousePlacements(int n) {\\n        int num = findNum(n);\\n        return ((long long)num * num) % mod;\\n    }\\n\\n    int findNum(int n) {\\n        if(n == 1 || n == 2)\\n            return n+1;\\n            \\n        int a = 2, b = 3, c;\\n\\n        for(int i=2; i<n; i++) {\\n            c = (a+b) % mod;\\n            a = b;\\n            b = c;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220114,
                "title": "clean-code-recursion-memorization-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nint helper(int i,vector<int>&dp)\\n{\\n    if(i==0) return 1;\\n    if(i<0) return 0;\\n    if(dp[i]!=-1) return dp[i];\\n    long long int take=helper(i-2,dp)%mod;\\n    long long int non_take=helper(i-1,dp)%mod;\\n    return dp[i]= (take+non_take)%mod;\\n}\\n\\n    int countHousePlacements(int n) {\\n        vector<int>dp(n+2,-1);\\n        long long int a=helper(n+1,dp);\\n        return (a*a)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod=1e9+7;\\nint helper(int i,vector<int>&dp)\\n{\\n    if(i==0) return 1;\\n    if(i<0) return 0;\\n    if(dp[i]!=-1) return dp[i];\\n    long long int take=helper(i-2,dp)%mod;\\n    long long int non_take=helper(i-1,dp)%mod;\\n    return dp[i]= (take+non_take)%mod;\\n}\\n\\n    int countHousePlacements(int n) {\\n        vector<int>dp(n+2,-1);\\n        long long int a=helper(n+1,dp);\\n        return (a*a)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213038,
                "title": "python-very-simple-solution-three-methods-o-n-time-o-1-space-96",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        mod= 10**9 + 7\\n        if n==1:return 4\\n\\n        #space opt\\n        a = 1\\n        b = 2\\n        c=0\\n        for i in range(2,n+1):\\n           c = a+b\\n           a=b\\n           b=c\\n        return (b*b) % mod\\n\\n\\n\\n        #tabulation\\n        # dp= [ -1 for _ in range(n+1)]\\n\\n        # dp[0] = 1\\n        # dp[1] = 2\\n\\n        # for i in range(2,n+1):\\n        #     dp[i] = dp[i-1]+dp[i-2]\\n        # return (dp[n]*dp[n]) % mod\\n\\n\\n\\n\\n        #memoization\\n        # memo=dict()\\n        # def f(i):\\n        #     if i==0:return 1\\n        #     if i==1:return 2\\n        #     if i in memo:\\n        #         return memo[i]\\n        #     memo[i] = f(i-1) + f(i-2)\\n        #     return memo[i]\\n\\n        # return ( f(n)**2 ) % mod\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        mod= 10**9 + 7\\n        if n==1:return 4\\n\\n        #space opt\\n        a = 1\\n        b = 2\\n        c=0\\n        for i in range(2,n+1):\\n           c = a+b\\n           a=b\\n           b=c\\n        return (b*b) % mod\\n\\n\\n\\n        #tabulation\\n        # dp= [ -1 for _ in range(n+1)]\\n\\n        # dp[0] = 1\\n        # dp[1] = 2\\n\\n        # for i in range(2,n+1):\\n        #     dp[i] = dp[i-1]+dp[i-2]\\n        # return (dp[n]*dp[n]) % mod\\n\\n\\n\\n\\n        #memoization\\n        # memo=dict()\\n        # def f(i):\\n        #     if i==0:return 1\\n        #     if i==1:return 2\\n        #     if i in memo:\\n        #         return memo[i]\\n        #     memo[i] = f(i-1) + f(i-2)\\n        #     return memo[i]\\n\\n        # return ( f(n)**2 ) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182715,
                "title": "no-dp-recurrence-relation-tc-o-n-sc-o-1",
                "content": "# Approach\\nLet $p$ denote the position on the street dividing the plots. So there are $p = n$ positions. At each position there may be one, two or zero houses. \\n\\nWe consider the case where there is just one position, i.e. $n = 1$. In this scenario there may be one house on either side or no houses, leading to a total of 4 configurations. We define variables $f_0$, $f_1$ and $f_2$ which contain the number of acceptable configurations for a street of size $n$ with zero houses at $p = n$, one house at $n$ or two houses at $n$. The total of possible acceptable configurations is then given by the following recurrence relation:\\n\\n$f_0^n = f_0^{n - 1} + f_1^{n - 1} + f_2^{n - 1}$\\n$f_1^n = 2f_0^{n - 1} + f_1^{n - 1}$\\n$f_2^n = f_0^{n - 1}$\\n\\nFor $n > 1$ and with the base cases:\\n\\n$f_0^1 = 1$\\n$f_1^1 = 2$\\n$f_2^1 = 1$\\n\\nThe recurrence relation provides the desired result by construction.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nconst int MOD = 1000000007;\\n\\nclass Solution {\\n\\npublic:\\n    int countHousePlacements(int n) {\\n\\n        int f0 = 1;\\n        int f1 = 2;\\n        int f2 = 1;\\n\\n        for(int k = 2; k <= n; k++) {\\n            int d0 = f0;\\n            int d1 = f1;\\n            int d2 = f2;\\n\\n            f0 = ((d0 + d1) % MOD + d2) % MOD;\\n            f1 = ((2 * d0 % MOD) + d1) % MOD;\\n            f2 = d0 % MOD;\\n        }\\n\\n        return (((f0 + f1) % MOD + f2) % MOD) % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nconst int MOD = 1000000007;\\n\\nclass Solution {\\n\\npublic:\\n    int countHousePlacements(int n) {\\n\\n        int f0 = 1;\\n        int f1 = 2;\\n        int f2 = 1;\\n\\n        for(int k = 2; k <= n; k++) {\\n            int d0 = f0;\\n            int d1 = f1;\\n            int d2 = f2;\\n\\n            f0 = ((d0 + d1) % MOD + d2) % MOD;\\n            f1 = ((2 * d0 % MOD) + d1) % MOD;\\n            f2 = d0 % MOD;\\n        }\\n\\n        return (((f0 + f1) % MOD + f2) % MOD) % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173331,
                "title": "fibonacci-series-based-dp-solution",
                "content": "# Intuition\\n  intuition: solve for 1 side of the road\\n  n = 1 option 1: empty, option 2: slot occupied [result for one side = 2]\\n  result = 4 for both sides of the road\\n  n = 2 option 1: empty, option2: 1st slot occupied, option2: 2nd slot occupied [result for one side = 3]\\n  result = 9 for both sides of the road\\n  n = 3 option 1: empty, option 2: 1st slot, option 3: 2nd slot, option 4: 3rd slot, option 5: 1st slot and 3rd slot [result for one side = 5]\\n  result = 25 for both sides of the road\\n  n = 4 ......... [result for one side = 8]\\n  result = 64 for both sides of the road, \\n\\n# Approach\\nIntuition formulates into a fibonacci series as and there are 2 plots so multiply the answer to itself to get total answer for `n`\\n  result[n] == (fib[n+2])^2\\n \\n    example: n=1, result[1] = (fib[1+2])^2 = since fib[3] = 2 and result = 4\\n    n = 2 result[2] = 9 (fib[2+2])^2 = since fib[4] = 3 and result = 9\\n    n = 3 result[3] = 25, (fib[3+2])^2 = since fib[5] = 5 and result = 25\\n    n = 4 result[4] = 64, (fib[4+2])^2 = since fib[6] = 8 and result = 64\\n  \\nDefine a fibonacci function which is space optimized and use that to calculate for any number of plots\\n\\n# Complexity\\n- Time complexity: \\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n   public int countHousePlacements(int n)\\n   {\\n     int val = fibonacci(n);\\n     return (int)(1L * val * val % 1000000007);\\n   }\\n\\n   public int fibonacci(int n)\\n   {\\n     // base case\\n     // solve one side of the road\\n     // space optimization\\n     int emptySlot = 1;\\n     int placedSlot = 1;\\n     int ways = placedSlot + emptySlot;\\n\\n     for (int i=2; i<=n; i++)\\n     {\\n       placedSlot = emptySlot;\\n       emptySlot = ways;\\n       ways = (placedSlot + emptySlot) % 1000000007;\\n     }\\n\\n     return ways;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n   public int countHousePlacements(int n)\\n   {\\n     int val = fibonacci(n);\\n     return (int)(1L * val * val % 1000000007);\\n   }\\n\\n   public int fibonacci(int n)\\n   {\\n     // base case\\n     // solve one side of the road\\n     // space optimization\\n     int emptySlot = 1;\\n     int placedSlot = 1;\\n     int ways = placedSlot + emptySlot;\\n\\n     for (int i=2; i<=n; i++)\\n     {\\n       placedSlot = emptySlot;\\n       emptySlot = ways;\\n       ways = (placedSlot + emptySlot) % 1000000007;\\n     }\\n\\n     return ways;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164938,
                "title": "fibonacci-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m = 1000000007;\\n    int countHousePlacements(int n) {\\n        long long a = 1, b = 1, c;\\n        \\n        while(n--){\\n            c = (a + b) % m;\\n            a = b;\\n            b = c;\\n        }\\n        \\n        c = (c * c) % m;\\n            \\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m = 1000000007;\\n    int countHousePlacements(int n) {\\n        long long a = 1, b = 1, c;\\n        \\n        while(n--){\\n            c = (a + b) % m;\\n            a = b;\\n            b = c;\\n        }\\n        \\n        c = (c * c) % m;\\n            \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148576,
                "title": "c-dfs-memoization-with-comments-for-each-case",
                "content": "```\\nclass Solution {\\npublic:\\n    // 3 possibilities for dfs memoization\\n    // previous tile had up and down taken, case 0\\n    // previous tile had up taken, case 1\\n    // previous tile had down taken, case 2\\n    // previous tile had nothing taken, case 3\\n    long dfs(int caseNum, int i, int& n, vector<vector<int>>& v){\\n        if (i > n) return 1;\\n        if (v[caseNum][i] != -1) return v[caseNum][i];\\n        long value = 0;\\n        if (caseNum == 0)\\n            value = dfs(3, i + 1, n, v);\\n        else if (caseNum == 1){\\n            value = dfs(1, i + 1, n, v) +\\n                    dfs(3, i + 1, n, v);\\n        }\\n        else if (caseNum == 2){\\n            value = dfs(1, i + 1, n, v) +\\n                    dfs(3, i + 1, n, v);\\n        }\\n        else{\\n            value = dfs(0, i + 1, n, v) + dfs(1, i + 1, n, v)\\n                  + dfs(2, i + 1, n, v) + dfs(3, i + 1, n, v);\\n        }\\n        return v[caseNum][i] = value % 1000000007;\\n    }\\n    int countHousePlacements(int n) {\\n        vector<vector<int>> v(4, vector<int>(n + 1, -1));\\n        return dfs(3, 1, n, v);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // 3 possibilities for dfs memoization\\n    // previous tile had up and down taken, case 0\\n    // previous tile had up taken, case 1\\n    // previous tile had down taken, case 2\\n    // previous tile had nothing taken, case 3\\n    long dfs(int caseNum, int i, int& n, vector<vector<int>>& v){\\n        if (i > n) return 1;\\n        if (v[caseNum][i] != -1) return v[caseNum][i];\\n        long value = 0;\\n        if (caseNum == 0)\\n            value = dfs(3, i + 1, n, v);\\n        else if (caseNum == 1){\\n            value = dfs(1, i + 1, n, v) +\\n                    dfs(3, i + 1, n, v);\\n        }\\n        else if (caseNum == 2){\\n            value = dfs(1, i + 1, n, v) +\\n                    dfs(3, i + 1, n, v);\\n        }\\n        else{\\n            value = dfs(0, i + 1, n, v) + dfs(1, i + 1, n, v)\\n                  + dfs(2, i + 1, n, v) + dfs(3, i + 1, n, v);\\n        }\\n        return v[caseNum][i] = value % 1000000007;\\n    }\\n    int countHousePlacements(int n) {\\n        vector<vector<int>> v(4, vector<int>(n + 1, -1));\\n        return dfs(3, 1, n, v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139818,
                "title": "easy-solution-c-recursion-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long solution(int n, vector<long long> &dp)\\n    {\\n        if(n<=0)\\n        return 0;\\n        if(dp[n]!=-1)\\n        return dp[n];\\n        long long place=0;\\n        long long notPlace=0;\\n        place=solution(n-2, dp);\\n        notPlace=solution(n-1, dp);\\n        long long ans=(place+notPlace+1)%(1000000000+7);\\n        dp[n]=ans;\\n        return ans;\\n    }\\n\\n\\n    int countHousePlacements(int n) {\\n        vector<long long>dp(n+1, -1);\\n        long  long ans=solution(n, dp)%(1000000000+7);\\n        return ((ans+1)*(ans+1))%(1000000000+7);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long solution(int n, vector<long long> &dp)\\n    {\\n        if(n<=0)\\n        return 0;\\n        if(dp[n]!=-1)\\n        return dp[n];\\n        long long place=0;\\n        long long notPlace=0;\\n        place=solution(n-2, dp);\\n        notPlace=solution(n-1, dp);\\n        long long ans=(place+notPlace+1)%(1000000000+7);\\n        dp[n]=ans;\\n        return ans;\\n    }\\n\\n\\n    int countHousePlacements(int n) {\\n        vector<long long>dp(n+1, -1);\\n        long  long ans=solution(n, dp)%(1000000000+7);\\n        return ((ans+1)*(ans+1))%(1000000000+7);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132451,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint mod;\\n    int rec(int ind,int n,vector<long long>&dp)\\n    {\\n        if (ind>n) return 1;\\n        if (dp[ind]!=-1) return dp[ind];\\n        long long pick=rec(ind+2,n,dp)%mod;\\n        long long notPick=rec(ind+1,n,dp)%mod;\\n        long long ans=(pick+notPick+mod)%mod;\\n        return dp[ind]=ans;\\n    }\\n    int countHousePlacements(int n) \\n    {\\n        mod=1e9+7;\\n        vector<long long>dp(n+1,-1);\\n        long long ans=(rec(1,n,dp)%mod);\\n        ans=(ans*ans+mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mod;\\n    int rec(int ind,int n,vector<long long>&dp)\\n    {\\n        if (ind>n) return 1;\\n        if (dp[ind]!=-1) return dp[ind];\\n        long long pick=rec(ind+2,n,dp)%mod;\\n        long long notPick=rec(ind+1,n,dp)%mod;\\n        long long ans=(pick+notPick+mod)%mod;\\n        return dp[ind]=ans;\\n    }\\n    int countHousePlacements(int n) \\n    {\\n        mod=1e9+7;\\n        vector<long long>dp(n+1,-1);\\n        long long ans=(rec(1,n,dp)%mod);\\n        ans=(ans*ans+mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121653,
                "title": "c-easy-fast-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(int n,int i,vector<int> &dp)\\n    {\\n        if(i>n)\\n        return 1;\\n        \\n        if(dp[i]!=-1)\\n        return dp[i];\\n\\n        int take=solve(n,i+2,dp)%mod;\\n        int nottake=solve(n,i+1,dp)%mod;\\n\\n        return dp[i]=(take%mod+nottake%mod)%mod;\\n    }\\n    int countHousePlacements(int n) {\\n        \\n        vector<int> dp(n+1,-1);\\n        long long count=solve(n,1,dp);\\n        count=(count%mod*count%mod)%mod;\\n        return count%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(int n,int i,vector<int> &dp)\\n    {\\n        if(i>n)\\n        return 1;\\n        \\n        if(dp[i]!=-1)\\n        return dp[i];\\n\\n        int take=solve(n,i+2,dp)%mod;\\n        int nottake=solve(n,i+1,dp)%mod;\\n\\n        return dp[i]=(take%mod+nottake%mod)%mod;\\n    }\\n    int countHousePlacements(int n) {\\n        \\n        vector<int> dp(n+1,-1);\\n        long long count=solve(n,1,dp);\\n        count=(count%mod*count%mod)%mod;\\n        return count%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105431,
                "title": "o-n-dp-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe two sides hold no restrictions towards each other. Only restriction lies along the same row. Therefore, we can find the solution for one row. Then square it, because the other row is independent and has equal number of possibilities. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n$$j = 0,1$$\\n0 -> No house at plot $$i$$\\n1 -> House at plot $$i$$\\nwhere $$i \\\\in [1, n]$$\\n\\n$$mem[i][j] =$$ Number of ways of $$j$$ happening at plot $$i$$\\n\\n1. We can have no house at plot $$i$$ for all the possibilities of $$mem[i-1]$$, i.e,  \\n$$mem[i][0] = mem[i-1][0] + mem[i-1][1]$$\\n2. We can have house at plot $$i$$ only when there is no house in previous plot, i.e,\\n$$mem[i][1] = mem[i-1][0]$$\\n3. Smallest subsolution is $$mem[1] = [1,1]$$ because there is only one way there is no house in the first plot, and only one way there is a house in the first plot. \\n\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$2*O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    \"\"\"Exponential solution commented out\"\"\"\\n    def __init__(self):\\n        self.c = 0 # only for the exponential solution\\n        self.mem = {}\\n    # def countHousePlacements(self, n: int) -> int:\\n    #     def count(n_plot, isOccupied, isNextOccupied):\\n    #         print(n_plot, isOccupied, isNextOccupied)\\n    #         if n_plot == 1:\\n    #             if not (isOccupied and isNextOccupied):\\n    #                 self.c += 1\\n    #                 print(\\'c=\\',self.c)\\n    #         elif not (isOccupied and isNextOccupied):\\n    #             count(n_plot - 1, 0, isOccupied) \\n    #             count(n_plot - 1, 1, isOccupied)\\n    #         return\\n\\n    #     count(n, 0, 0)\\n    #     count(n, 1, 0)\\n    #     return int(self.c**2 % (10e7))\\n    \"\"\" Linear time \"\"\"\\n    def countHousePlacements(self, n: int) -> int:\\n        self.mem[1] = [1,1] # either 0 or 1\\n        for i in range(2,n+1):\\n            z = sum(self.mem[i-1])\\n            o = self.mem[i-1][0]\\n            self.mem[i] = [z, o]\\n\\n        ans = sum(self.mem[n])\\n        ans **= 2\\n        return ans % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"Exponential solution commented out\"\"\"\\n    def __init__(self):\\n        self.c = 0 # only for the exponential solution\\n        self.mem = {}\\n    # def countHousePlacements(self, n: int) -> int:\\n    #     def count(n_plot, isOccupied, isNextOccupied):\\n    #         print(n_plot, isOccupied, isNextOccupied)\\n    #         if n_plot == 1:\\n    #             if not (isOccupied and isNextOccupied):\\n    #                 self.c += 1\\n    #                 print(\\'c=\\',self.c)\\n    #         elif not (isOccupied and isNextOccupied):\\n    #             count(n_plot - 1, 0, isOccupied) \\n    #             count(n_plot - 1, 1, isOccupied)\\n    #         return\\n\\n    #     count(n, 0, 0)\\n    #     count(n, 1, 0)\\n    #     return int(self.c**2 % (10e7))\\n    \"\"\" Linear time \"\"\"\\n    def countHousePlacements(self, n: int) -> int:\\n        self.mem[1] = [1,1] # either 0 or 1\\n        for i in range(2,n+1):\\n            z = sum(self.mem[i-1])\\n            o = self.mem[i-1][0]\\n            self.mem[i] = [z, o]\\n\\n        ans = sum(self.mem[n])\\n        ans **= 2\\n        return ans % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048477,
                "title": "easy-and-short-java-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Note that both the sides of road are independent problems, i.e. position of house on left side does not affect right side and vice-versa.\\n2. So solve them independently, also note that the answers of both side will be same, let say x, => final answer = x*x\\n3. At every index i, we have 2 choices, either to put a house if i-1 does not have any house, or to not put a house at i.\\n4. these 2 are the 2 dp states to consider here.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        long[] dp = new long[n+1];\\n        int mod = (int)1e9+7;\\n        dp[0] = 1;\\n        dp[1] = 2;\\n        for(int i=2;i<=n;i++){\\n            dp[i] = dp[i-1];\\n            if(i-2>=0)dp[i] +=dp[i-2];\\n            dp[i]%=mod;\\n        }\\n        return (int)(dp[n]*dp[n]%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        long[] dp = new long[n+1];\\n        int mod = (int)1e9+7;\\n        dp[0] = 1;\\n        dp[1] = 2;\\n        for(int i=2;i<=n;i++){\\n            dp[i] = dp[i-1];\\n            if(i-2>=0)dp[i] +=dp[i-2];\\n            dp[i]%=mod;\\n        }\\n        return (int)(dp[n]*dp[n]%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021922,
                "title": "simple-java-dp-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        int[] dp = new int[n + 1];\\n        int mod = 1000000007;\\n        dp[0] = 1;\\n        dp[1] = 2;\\n        for (int i = 2; i <= n; i++) {\\n            dp[i] = (dp[i - 1] + dp[i - 2]) % mod;\\n        }\\n        return (int) (1L * dp[n] * dp[n] % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        int[] dp = new int[n + 1];\\n        int mod = 1000000007;\\n        dp[0] = 1;\\n        dp[1] = 2;\\n        for (int i = 2; i <= n; i++) {\\n            dp[i] = (dp[i - 1] + dp[i - 2]) % mod;\\n        }\\n        return (int) (1L * dp[n] * dp[n] % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964517,
                "title": "js",
                "content": "## Runtime 118 ms -> Beats 64.71%\\n## Memory 47.1 MB -> Beats 70.59%\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\n\\nvar countHousePlacements = function(n) {\\n  const mood = BigInt(10**9+7);\\n  let last = 2n;\\n  let lastLast = 1n;\\n  let answer = last;\\n\\n  for (let ind = 2; ind <= n; ind++) {\\n    answer = (last+lastLast)% mood;\\n    lastLast = last;\\n    last = answer;\\n  }\\n  return (answer * answer) % mood;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\n\\nvar countHousePlacements = function(n) {\\n  const mood = BigInt(10**9+7);\\n  let last = 2n;\\n  let lastLast = 1n;\\n  let answer = last;\\n\\n  for (let ind = 2; ind <= n; ind++) {\\n    answer = (last+lastLast)% mood;\\n    lastLast = last;\\n    last = answer;\\n  }\\n  return (answer * answer) % mood;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2962625,
                "title": "easy-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we see that for n=0, we take two var old zero(oz) & old one(oo) i.e. the no of binary strings ending in 0 and 1 respectively. (for n=1)\\noo=1,oz=1\\noo=\"1\",oz=\"0\"\\nwe dont need two consecutive ones-\\nnoz=\"00,10\"\\nnoo=\"01\"\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        long oo=1;\\n        long oz=1;\\n        long m=1000000007;\\n        for(long i=1;i<n;i++){\\n            long nz=oo;\\n            long no=(oz+oo)%m;\\n\\n            oz=nz;\\n            oo=no;\\n        }\\n        long val=oo+oz;\\n        val=val*val;\\n        val=val%m;\\n        return (int)val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        long oo=1;\\n        long oz=1;\\n        long m=1000000007;\\n        for(long i=1;i<n;i++){\\n            long nz=oo;\\n            long no=(oz+oo)%m;\\n\\n            oz=nz;\\n            oo=no;\\n        }\\n        long val=oo+oz;\\n        val=val*val;\\n        val=val%m;\\n        return (int)val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945342,
                "title": "simple-fibonacci-solution-o-n",
                "content": "# Intuition\\nJust observe the pattern\\n\\n# Approach\\nfibonacci series\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9 + 7; \\n    long long int dp[10001];\\n    int countHousePlacements(int n) {\\n        if(n==1)\\n            return 4;\\n        \\n        dp[0]=2;\\n        dp[1]=3;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=(dp[i-1] + dp[i-2])%(mod);\\n        }\\n        //dp[n] = (long long int)pow(dp[n-1], 2)%(mod);\\n        return (dp[n-1]*dp[n-1])%(mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int mod = 1e9 + 7; \\n    long long int dp[10001];\\n    int countHousePlacements(int n) {\\n        if(n==1)\\n            return 4;\\n        \\n        dp[0]=2;\\n        dp[1]=3;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=(dp[i-1] + dp[i-2])%(mod);\\n        }\\n        //dp[n] = (long long int)pow(dp[n-1], 2)%(mod);\\n        return (dp[n-1]*dp[n-1])%(mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923426,
                "title": "c-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDP\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        if(n == 1)\\n            return 4;\\n        if(n == 2)\\n            return 9;\\n        int mod = 1e9+7;\\n        vector<long> dp(n + 1);\\n        dp[1] = 2;\\n        dp[2] = 3;\\n        for(int i = 3; i <= n; i++)\\n            dp[i] = ((dp[i - 1] + dp[i - 2]) % mod);\\n        return (dp[n]) * (dp[n]) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        if(n == 1)\\n            return 4;\\n        if(n == 2)\\n            return 9;\\n        int mod = 1e9+7;\\n        vector<long> dp(n + 1);\\n        dp[1] = 2;\\n        dp[2] = 3;\\n        for(int i = 3; i <= n; i++)\\n            dp[i] = ((dp[i - 1] + dp[i - 2]) % mod);\\n        return (dp[n]) * (dp[n]) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904701,
                "title": "js-easy-solution-absolute-100",
                "content": "\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countHousePlacements = function (n) {\\n    const mod = 10 ** 9 + 7;\\n    const memo = [];\\n    memo[0] = 1;\\n    memo[1] = 4;\\n    memo[2] = 9;\\n    if (n <= 2) return memo[n];\\n    for (let i = 3; i <= n; i++) {\\n        const res = ((memo[2] + memo[1]) * 2 - memo[0] + mod) % mod;\\n        memo[0] = memo[1];\\n        memo[1] = memo[2];\\n        memo[2] = res;\\n    }\\n    return memo[2];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countHousePlacements = function (n) {\\n    const mod = 10 ** 9 + 7;\\n    const memo = [];\\n    memo[0] = 1;\\n    memo[1] = 4;\\n    memo[2] = 9;\\n    if (n <= 2) return memo[n];\\n    for (let i = 3; i <= n; i++) {\\n        const res = ((memo[2] + memo[1]) * 2 - memo[0] + mod) % mod;\\n        memo[0] = memo[1];\\n        memo[1] = memo[2];\\n        memo[2] = res;\\n    }\\n    return memo[2];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2904390,
                "title": "c-simple-solution-by-fibonaccii-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        if(n==1){\\n            return 4;\\n        }\\n        if(n==2){\\n            return 9;\\n        }\\n        long long a=3;\\n        long long b=2;\\n        int mod=1e9+7;\\n        for(int i=3;i<=n;i++){\\n            a=(a+b)%mod;\\n            b=a-b;\\n        }\\n        int ans=(a*a)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        if(n==1){\\n            return 4;\\n        }\\n        if(n==2){\\n            return 9;\\n        }\\n        long long a=3;\\n        long long b=2;\\n        int mod=1e9+7;\\n        for(int i=3;i<=n;i++){\\n            a=(a+b)%mod;\\n            b=a-b;\\n        }\\n        int ans=(a*a)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904163,
                "title": "c-fibonacci-simple-and-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        typedef long long ll;\\n        ll a,b,c,mod;mod=1000000007;\\n        a=b=1;\\n        c=a+b;\\n        for(int i=2;i<=n;i++)\\n        {\\n            a=b;\\n            b=c;\\n            c=(a+b)%mod;\\n        }\\n        return (c*c)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        typedef long long ll;\\n        ll a,b,c,mod;mod=1000000007;\\n        a=b=1;\\n        c=a+b;\\n        for(int i=2;i<=n;i++)\\n        {\\n            a=b;\\n            b=c;\\n            c=(a+b)%mod;\\n        }\\n        return (c*c)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821680,
                "title": "java-100-3ms-matrix-multi",
                "content": "java\\n```\\nclass Solution {\\n    long MOD = 1000000007;\\n    public int countHousePlacements(int n) {\\n    \\tlong[][] multi = new long[][]{{1,1},{1,0}};\\n    \\tlong[][] uint = new long[][] {{1,0},{0,1}};\\n    \\t++n;\\n    \\twhile( n > 0) {\\n    \\t\\tif((n & 1) == 1) {\\n    \\t\\t\\tuint = multiMat(multi,uint);\\n    \\t\\t}\\n    \\t\\tn >>= 1;\\n    \\t\\tmulti = multiMat(multi,multi);\\n    \\t}\\n    \\treturn (int)(uint[0][0] * uint[0][0] % MOD);\\n    }\\n    \\n    private long[][] multiMat(long[][] A, long[][] B) {\\n    \\tlong[][] ans = new long[2][2];\\n    \\tint n = A.length;\\n    \\tfor(int i = 0; i < n; ++i) {\\n    \\t\\tfor(int j = 0; j < n; ++j) {\\n    \\t\\t\\tans[i][j] = (A[i][0] * B[0][j] + A[i][1] * B[1][j]) % MOD;\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    long MOD = 1000000007;\\n    public int countHousePlacements(int n) {\\n    \\tlong[][] multi = new long[][]{{1,1},{1,0}};\\n    \\tlong[][] uint = new long[][] {{1,0},{0,1}};\\n    \\t++n;\\n    \\twhile( n > 0) {\\n    \\t\\tif((n & 1) == 1) {\\n    \\t\\t\\tuint = multiMat(multi,uint);\\n    \\t\\t}\\n    \\t\\tn >>= 1;\\n    \\t\\tmulti = multiMat(multi,multi);\\n    \\t}\\n    \\treturn (int)(uint[0][0] * uint[0][0] % MOD);\\n    }\\n    \\n    private long[][] multiMat(long[][] A, long[][] B) {\\n    \\tlong[][] ans = new long[2][2];\\n    \\tint n = A.length;\\n    \\tfor(int i = 0; i < n; ++i) {\\n    \\t\\tfor(int j = 0; j < n; ++j) {\\n    \\t\\t\\tans[i][j] = (A[i][0] * B[0][j] + A[i][1] * B[1][j]) % MOD;\\n    \\t\\t}\\n    \\t}\\n    \\treturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801120,
                "title": "c-solution-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        long long N = 1000000007;\\n        vector<long long> dp1(n+1);\\n        vector<long long> dp2(n+1);\\n        dp1[1] = dp2[1] = 1;\\n        for(int i=2;i<=n;i++){\\n            dp1[i] = dp2[i-1];\\n            dp2[i] = (dp1[i-1] + dp2[i-1])%N;\\n        }\\n        long long total = (dp1[n]+dp2[n])%N;\\n        return (total*total)%N;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        long long N = 1000000007;\\n        vector<long long> dp1(n+1);\\n        vector<long long> dp2(n+1);\\n        dp1[1] = dp2[1] = 1;\\n        for(int i=2;i<=n;i++){\\n            dp1[i] = dp2[i-1];\\n            dp2[i] = (dp1[i-1] + dp2[i-1])%N;\\n        }\\n        long long total = (dp1[n]+dp2[n])%N;\\n        return (total*total)%N;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770553,
                "title": "dp-solution-simple-fast-easy",
                "content": "class Solution {\\npublic:\\n\\n    int countHousePlacements(int n) {\\n        if(n==1)\\n            return 4;\\n        if(n==2)\\n            return 9;\\n        int mod=pow(10,9)+7;\\n        vector<long long>dp(n+1);\\n        dp[0]=2;\\n        dp[1]=3;\\n        for(int i=2;i<=n;i++)\\n        {\\n        dp[i]=(dp[i-1]%mod)+(dp[i-2]%mod);\\n        }\\n        return ((dp[n-1]*dp[n-1])%mod);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countHousePlacements(int n) {\\n        if(n==1)\\n            return 4;\\n        if(n==2)\\n            return 9;\\n        int mod=pow(10,9)+7;\\n        vector<long long>dp(n+1);\\n        dp[0]=2;\\n        dp[1]=3;\\n        for(int i=2;i<=n;i++)\\n        {\\n        dp[i]=(dp[i-1]%mod)+(dp[i-2]%mod);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2742778,
                "title": "both-memo-recursion-table",
                "content": "table\\n```\\nclass Solution {\\npublic:\\n    long long mod = 1e9 + 7;\\n    \\n    int dp[10004];\\n    int helper(int n){\\n        \\n        dp[0]=1,dp[1]=2;\\n        for(int i=2;i<=n;i++){\\n            dp[i]+=dp[i-1]%mod;\\n            dp[i]+=dp[i-2]%mod;\\n        }\\n        return dp[n]%mod;\\n    }\\n    int countHousePlacements(int n) {\\n        memset(dp,0,sizeof(dp));\\n        int ans = helper(n);\\n        \\n        return (ans % mod * ans % mod) % mod;\\n    }\\n};\\n\\n```\\n\\nmemo-\\n\\n```\\n\\nclass Solution {\\npublic:\\n    long long mod = 1e9 + 7;\\n    \\n    int dp[10004];\\n    int helper(int i,int n){\\n        if(i>n)\\n            return 1;\\n        // ans++;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        int include=helper(i+1,n);\\n        int exclude=helper(i+2,n);\\n        return dp[i]=(include%mod+exclude%mod)%mod;\\n    }\\n    int countHousePlacements(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = helper(1, n);\\n        \\n        return (ans % mod * ans % mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod = 1e9 + 7;\\n    \\n    int dp[10004];\\n    int helper(int n){\\n        \\n        dp[0]=1,dp[1]=2;\\n        for(int i=2;i<=n;i++){\\n            dp[i]+=dp[i-1]%mod;\\n            dp[i]+=dp[i-2]%mod;\\n        }\\n        return dp[n]%mod;\\n    }\\n    int countHousePlacements(int n) {\\n        memset(dp,0,sizeof(dp));\\n        int ans = helper(n);\\n        \\n        return (ans % mod * ans % mod) % mod;\\n    }\\n};\\n\\n```\n```\\n\\nclass Solution {\\npublic:\\n    long long mod = 1e9 + 7;\\n    \\n    int dp[10004];\\n    int helper(int i,int n){\\n        if(i>n)\\n            return 1;\\n        // ans++;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        int include=helper(i+1,n);\\n        int exclude=helper(i+2,n);\\n        return dp[i]=(include%mod+exclude%mod)%mod;\\n    }\\n    int countHousePlacements(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = helper(1, n);\\n        \\n        return (ans % mod * ans % mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742363,
                "title": "c-dp-o-n-time-2-solutions",
                "content": "**For Both Methods Space Complexity is - O(n)**\\n**1st Method**\\nHere we are using extra space.\\nSpace Complexity - O(2 * n)\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int countHousePlacements(int n) {\\n        // dp[i][0] -> number of ways till ith pos not considering the current house\\n        // dp[i][1] -> number of ways till ith pos considering the current house\\n        vector<vector<int>> dp(n, vector<int> (2, 0));\\n        dp[0][0] = dp[0][1] = 1;\\n        for(int i = 1; i < n; i++) {\\n            dp[i][1] = dp[i - 1][0];\\n\\t\\t\\t// If we are not considering current house\\n            dp[i][0] = (dp[i - 1][1] + dp[i - 1][0]) % mod;\\n        }\\n\\t\\t// For one side, ans is sum of both ways i.e., if last house is condidered and if it is not\\n        long long ans = (dp[n - 1][0] + dp[n - 1][1]) % mod;\\n\\t\\t// For both sides we multiply the ans with ans\\n        return (ans * ans) % mod;\\n    }\\n};\\n```\\n**2nd Method**\\nThis method is same as above. Instead of extra space we work with variables as for each iteration, we just need the record of previous iteration.\\nTime Complexity - O(1)\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int countHousePlacements(int n) {\\n        int take = 1, not_take = 1;\\n        for(int i = 1; i < n; i++) {\\n            int cur_take = not_take;\\n            int cur_not_take = (take + not_take) % mod;\\n            take = cur_take;\\n            not_take = cur_not_take;\\n        }\\n        long long ans = (take + not_take) % mod;\\n        return (ans * ans) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int countHousePlacements(int n) {\\n        // dp[i][0] -> number of ways till ith pos not considering the current house\\n        // dp[i][1] -> number of ways till ith pos considering the current house\\n        vector<vector<int>> dp(n, vector<int> (2, 0));\\n        dp[0][0] = dp[0][1] = 1;\\n        for(int i = 1; i < n; i++) {\\n            dp[i][1] = dp[i - 1][0];\\n\\t\\t\\t// If we are not considering current house\\n            dp[i][0] = (dp[i - 1][1] + dp[i - 1][0]) % mod;\\n        }\\n\\t\\t// For one side, ans is sum of both ways i.e., if last house is condidered and if it is not\\n        long long ans = (dp[n - 1][0] + dp[n - 1][1]) % mod;\\n\\t\\t// For both sides we multiply the ans with ans\\n        return (ans * ans) % mod;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int countHousePlacements(int n) {\\n        int take = 1, not_take = 1;\\n        for(int i = 1; i < n; i++) {\\n            int cur_take = not_take;\\n            int cur_not_take = (take + not_take) % mod;\\n            take = cur_take;\\n            not_take = cur_not_take;\\n        }\\n        long long ans = (take + not_take) % mod;\\n        return (ans * ans) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732047,
                "title": "python-recursive-solution-using-the-count-of-each-type-of-previous-element",
                "content": "**Four tuple solution**\\n\\nFor `n = 1`, there are four pictures of how things can look. We can call them `00`, `01`, `10`, and `11`. All of these are valid configurations, so that `f(1) = (1, 1, 1, 1)`. Note that you can imagine the street separating them like `0|0`, `0|1`, `1|0`, `1|1`.\\n\\nFor `n = 2`, there are four possible configurations of how the newest column/row (leftmost/bottommost, whatever) looks. Again, they are `00`, `01`, `10`, and `11`. We want to use `f(1)` to find `f(2)`.\\n\\nLet\\'s start with `00`. This is a valid configuration to add to any previous configuration, so for `n=2`, `f(2-1) = (1, 1, 1, 1)`, which makes `4` total configurations valid for `00`. So for `n=2`, there are `4` `00` configurations.\\n\\nNext let\\'s try `01`. This is a valid configuration to add to a previous configuration of `00` or `10`. Note that for `01` or `11`, we would have houses adjacent to each other on the same side of the street. So for `01`, the valid combinations are the total of the valid combinations previously ending with `00` or `10`, which is `1+1` or `2`.\\n\\nSimilarly, by symmetry, for `10`, we get `2` combinations, corresponding to `00` or `01`.\\n\\nFinally, for `11`, the only valid previous combination is `00`, so we get `1`.\\n\\nAdding these up, we get `4+2+2+1=9` which is the right answer for `n=2`.\\n\\nIn general, let `f(n)` return a `tuple` of four `int`s corresponding to `00`, `01`, `10`, and `11`.\\n\\nIf `n == 1` then return `(1, 1, 1, 1)`.\\n\\nOtherwise, let `a0, b0, c0, d0 = f(n - 1)`, where `a0` is the # of `00`, `b0` is the # of `01`, `c0` is the # of `10`, and `d0` is the # of `11`.\\n\\nThen:\\n\\n* `a1 = a0 + b0 + c0 + d0`\\n* `b1 = a0 + c0`\\n* `c1 = a0 + b0`\\n* `d1 = a0`\\n\\nThen return `(a1, b1, c1, d1)`.\\n\\nFinally, we compute `f(n)`, and sum the tuple modulo `10 ** 9 + 7`.\\n\\n```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        \\n        # (00, 01, 10, 11)\\n        def f(n: int) -> (int, int, int, int):\\n            if n == 1:\\n                return (1, 1, 1, 1)\\n            a0, b0, c0, d0 = f(n - 1)\\n            \\n            a1 = a0 + b0 + c0 + d0\\n            b1 = a0 + c0\\n            c1 = a0 + b0\\n            d1 = a0\\n            \\n            return (a1, b1, c1, d1)\\n        \\n        answer_tuple = f(n)\\n        return sum(answer_tuple) % ( 10 ** 9 + 7 )\\n```\\n\\n**Two tuple solution**\\n\\nWe can simplify this problem if we note that each of the sides of the street are independent of each other. So instead of tracking configurations `00`, `01`, `10`, and `11`, we could just track configurations `0` and `1` for one side of the street. The other side is totally independent, so if we know the number of configurations for one side is `f(n)`, then the total number is just `f(n) ** 2`.\\n\\nUsing the same logic as before:\\n\\n* `a1 = a0 + b0`\\n* `b1 = a0`\\n\\n```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:        \\n        \\n        # (0, 1)\\n        def f(n: int) -> (int, int):\\n            if n == 1:\\n                return (1, 1)\\n            a0, b0 = f(n - 1)\\n            \\n            a1 = a0 + b0\\n            b1 = a0\\n            \\n            return (a1, b1)\\n        \\n        answer_tuple = f(n)\\n        return sum(answer_tuple) ** 2 % ( 10 ** 9 + 7 )\\n```\\n\\n**No tuple solution**\\n\\nImagine we returned the sum of the tuple from `f` instead of the tuple.\\n\\nNow we can note that `f(1)=2`, `f(2)=3`, `f(3)=5`, `f(4)=8`. It seems like there may be a fibonacci recurrence relationship, and there is.\\n\\nWe want the following to be true: `f(n) = f(n - 1) + f(n - 2)`.\\n\\nWhy is that true?\\n\\nLet `f(n) = a_n + b_n`, where `a_n` is the `0` term and `b_n` is the `1` term.\\n\\nUsing the relationship defined in the two-tuple solution, `a_n = f(n - 1) = a_nminus1 + b_nminus1`.\\n\\nWhat about `b_n`?\\n\\nWell `b_n = a_nminus1`, but by induction, `a_nminus1 = a_nminus2 + b_nminus2 = f(n - 2)`.\\n\\nSo `f(n) = f(n - 1) + f(n - 2)`.\\n\\n```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:        \\n        \\n        @cache\\n        def f(n: int) -> int:\\n            if n == 1:\\n                return 2\\n            if n == 2:\\n                return 3\\n            return f(n - 1) + f(n - 2)\\n        \\n        return f(n) ** 2 % ( 10 ** 9 + 7 )\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        \\n        # (00, 01, 10, 11)\\n        def f(n: int) -> (int, int, int, int):\\n            if n == 1:\\n                return (1, 1, 1, 1)\\n            a0, b0, c0, d0 = f(n - 1)\\n            \\n            a1 = a0 + b0 + c0 + d0\\n            b1 = a0 + c0\\n            c1 = a0 + b0\\n            d1 = a0\\n            \\n            return (a1, b1, c1, d1)\\n        \\n        answer_tuple = f(n)\\n        return sum(answer_tuple) % ( 10 ** 9 + 7 )\\n```\n```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:        \\n        \\n        # (0, 1)\\n        def f(n: int) -> (int, int):\\n            if n == 1:\\n                return (1, 1)\\n            a0, b0 = f(n - 1)\\n            \\n            a1 = a0 + b0\\n            b1 = a0\\n            \\n            return (a1, b1)\\n        \\n        answer_tuple = f(n)\\n        return sum(answer_tuple) ** 2 % ( 10 ** 9 + 7 )\\n```\n```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:        \\n        \\n        @cache\\n        def f(n: int) -> int:\\n            if n == 1:\\n                return 2\\n            if n == 2:\\n                return 3\\n            return f(n - 1) + f(n - 2)\\n        \\n        return f(n) ** 2 % ( 10 ** 9 + 7 )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688247,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n      long mod=1000000007;\\n      long dp[]=new long[n+1];\\n      dp[0]=1;\\n      dp[1]=2;\\n      for(int i=2;i<=n;i++){\\n          dp[i]=(dp[i-1]+dp[i-2])%mod;\\n      }  \\n      return (int)((dp[n]*dp[n])%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n      long mod=1000000007;\\n      long dp[]=new long[n+1];\\n      dp[0]=1;\\n      dp[1]=2;\\n      for(int i=2;i<=n;i++){\\n          dp[i]=(dp[i-1]+dp[i-2])%mod;\\n      }  \\n      return (int)((dp[n]*dp[n])%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641605,
                "title": "python-simple-dp-solution-o-n-time-o-1-space-beats-80",
                "content": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        # endingInHouses represents number of ways street ending with house\\n        # endingInSpaces represents number of ways street ending with space\\n        # Lets think of number of ways of placing houses on one side,\\n        endingInHouses, endingInSpaces, MOD = 1, 1, 1000000007\\n        totalWays = (endingInHouses + endingInSpaces) % MOD\\n        for numEmptyPlots in range(2, n + 1):\\n            # we can put a house if previous ending is space\\n            endingInHouses = endingInSpaces\\n            # we can put a space whatever the previous ending may be\\n            endingInSpaces = totalWays\\n            totalWays = (endingInHouses + endingInSpaces) % MOD\\n        # For the other side, we have the same possible ways, so for each way on one side can correspond to any of the total ways on other side.\\n        return (totalWays * totalWays) % MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        # endingInHouses represents number of ways street ending with house\\n        # endingInSpaces represents number of ways street ending with space\\n        # Lets think of number of ways of placing houses on one side,\\n        endingInHouses, endingInSpaces, MOD = 1, 1, 1000000007\\n        totalWays = (endingInHouses + endingInSpaces) % MOD\\n        for numEmptyPlots in range(2, n + 1):\\n            # we can put a house if previous ending is space\\n            endingInHouses = endingInSpaces\\n            # we can put a space whatever the previous ending may be\\n            endingInSpaces = totalWays\\n            totalWays = (endingInHouses + endingInSpaces) % MOD\\n        # For the other side, we have the same possible ways, so for each way on one side can correspond to any of the total ways on other side.\\n        return (totalWays * totalWays) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622106,
                "title": "down-to-top-dp-fibonacci",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define mod 1000000007\\n    int countHousePlacements(int n) {\\n        vector<ll>dp(n+1,0);\\n        dp[0]=1;\\n        dp[1]=2;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=0+dp[i-1];\\n            if(i>=2)\\n                dp[i]+=dp[i-2];\\n            dp[i]%=mod;\\n        }\\n        return (dp[n]%mod*dp[n]%mod)%mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define mod 1000000007\\n    int countHousePlacements(int n) {\\n        vector<ll>dp(n+1,0);\\n        dp[0]=1;\\n        dp[1]=2;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=0+dp[i-1];\\n            if(i>=2)\\n                dp[i]+=dp[i-2];\\n            dp[i]%=mod;\\n        }\\n        return (dp[n]%mod*dp[n]%mod)%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617967,
                "title": "solutions-with-bottom-up-and-top-down",
                "content": "**SOLN. WITH BOTTOM-UP**\\n```\\nclass Solution {\\n    long MOD = 1000000007;\\n    public int countHousePlacements(int n) {\\n        long select = 1;\\n        long notSelect = 1;\\n        \\n        for(int i = 0; i < n; i++){\\n            long temp = notSelect;\\n            notSelect = (notSelect + select) % MOD;\\n            select = temp;\\n        }\\n\\n        return (int) (notSelect * notSelect % MOD);\\n    }\\n}\\n```\\n\\n**SOLN. WITH TOP-DOWN**\\n```\\nclass Solution {\\n    long MOD = 1000000007;\\n    public int countHousePlacements(int n) {\\n        Long dp[] = new Long[n];\\n        \\n        long result = f(0, n, dp);\\n        return (int) (result * result % MOD);\\n    }\\n    \\n    private long f(int i, int n, Long[] dp){\\n        if(i >= n) return 1;\\n        \\n        if(dp[i] != null) return dp[i];\\n        \\n        return dp[i] = (f(i + 2, n, dp) + f(i + 1, n, dp)) % MOD;\\n        \\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long MOD = 1000000007;\\n    public int countHousePlacements(int n) {\\n        long select = 1;\\n        long notSelect = 1;\\n        \\n        for(int i = 0; i < n; i++){\\n            long temp = notSelect;\\n            notSelect = (notSelect + select) % MOD;\\n            select = temp;\\n        }\\n\\n        return (int) (notSelect * notSelect % MOD);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    long MOD = 1000000007;\\n    public int countHousePlacements(int n) {\\n        Long dp[] = new Long[n];\\n        \\n        long result = f(0, n, dp);\\n        return (int) (result * result % MOD);\\n    }\\n    \\n    private long f(int i, int n, Long[] dp){\\n        if(i >= n) return 1;\\n        \\n        if(dp[i] != null) return dp[i];\\n        \\n        return dp[i] = (f(i + 2, n, dp) + f(i + 1, n, dp)) % MOD;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611315,
                "title": "c-fastest-submission-tabulation-space-optimization",
                "content": "TC: O(N)\\nSC: O(1)\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int countHousePlacements(int n) {\\n        \\n        long long prev1=1,prev2=1,curr;\\n        for(int i=2;i<n+2;i++){\\n            curr = (prev1 + prev2 )%mod;\\n            prev2=prev1;\\n            prev1=curr;\\n        }\\n            \\n        return (prev1 * prev1)%mod;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int countHousePlacements(int n) {\\n        \\n        long long prev1=1,prev2=1,curr;\\n        for(int i=2;i<n+2;i++){\\n            curr = (prev1 + prev2 )%mod;\\n            prev2=prev1;\\n            prev1=curr;\\n        }\\n            \\n        return (prev1 * prev1)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int countHousePlacements(int n) {\\n        \\n        long long prev1=1,prev2=1,curr;\\n        for(int i=2;i<n+2;i++){\\n            curr = (prev1 + prev2 )%mod;\\n            prev2=prev1;\\n            prev1=curr;\\n        }\\n            \\n        return (prev1 * prev1)%mod;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int countHousePlacements(int n) {\\n        \\n        long long prev1=1,prev2=1,curr;\\n        for(int i=2;i<n+2;i++){\\n            curr = (prev1 + prev2 )%mod;\\n            prev2=prev1;\\n            prev1=curr;\\n        }\\n            \\n        return (prev1 * prev1)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611264,
                "title": "c-easy-solution-0-1-knapsack-variation-dp",
                "content": "TC: O(N)\\nSC: O(N) + Auxilaiy Stack Space O(N)\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    long long solve(int i,vector<long long>&dp){\\n        //base case\\n        if(i<=0)\\n            return 1;\\n        \\n        //check the cache\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        //pick or not pick\\n        long long notpick = solve(i-1,dp);\\n        long long pick    = solve(i-2,dp);\\n        \\n        return dp[i] = (pick%mod + notpick %mod )%mod;\\n    }\\n    int countHousePlacements(int n) {\\n        \\n        vector<long long>dp(n+1,-1);\\n        long long ans= solve(n,dp)%mod;\\n        return (ans%mod  * ans%mod)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    long long solve(int i,vector<long long>&dp){\\n        //base case\\n        if(i<=0)\\n            return 1;\\n        \\n        //check the cache\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        //pick or not pick\\n        long long notpick = solve(i-1,dp);\\n        long long pick    = solve(i-2,dp);\\n        \\n        return dp[i] = (pick%mod + notpick %mod )%mod;\\n    }\\n    int countHousePlacements(int n) {\\n        \\n        vector<long long>dp(n+1,-1);\\n        long long ans= solve(n,dp)%mod;\\n        return (ans%mod  * ans%mod)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602542,
                "title": "javascript-is-there-a-way-to-get-the-final-result-without-using-bigint",
                "content": "When calculating the final result, I used Bigint to get the results of `(sum ^ 2) % MOD`. I read some other solutions and they all used this similar method. So wondering if there is a way to get the final result without using Bigint?\\n\\n```\\nvar countHousePlacements = function(n) {\\n    const MOD = 1e9 + 7;\\n    \\n    const dp = new Array(n).fill().map(() => new Array(2));\\n    dp[0][0] = 1;\\n    dp[0][1] = 1;\\n    \\n    for (let i = 1; i < n; i++) {\\n        dp[i][0] = (dp[i - 1][1] + dp[i - 1][0]) % MOD;\\n        dp[i][1] = dp[i - 1][0];\\n    }\\n\\n    const sum = BigInt(dp[n - 1][0]) + BigInt(dp[n - 1][1]);\\n    return Number((sum * sum) % BigInt(MOD));\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar countHousePlacements = function(n) {\\n    const MOD = 1e9 + 7;\\n    \\n    const dp = new Array(n).fill().map(() => new Array(2));\\n    dp[0][0] = 1;\\n    dp[0][1] = 1;\\n    \\n    for (let i = 1; i < n; i++) {\\n        dp[i][0] = (dp[i - 1][1] + dp[i - 1][0]) % MOD;\\n        dp[i][1] = dp[i - 1][0];\\n    }\\n\\n    const sum = BigInt(dp[n - 1][0]) + BigInt(dp[n - 1][1]);\\n    return Number((sum * sum) % BigInt(MOD));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2596087,
                "title": "c-recursion-memoization-tabulation-spaceoptimization",
                "content": "# Method -1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/91f933ff-8329-4ea7-983f-850a7aadf951_1663578796.2728143.png)\\n\\n**T->O(n) && S->O(n) [Recursion StackSpace]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint mod=1e9+7;\\n\\t\\tint f(int i,int n){\\n\\t\\t\\tif(i>=n+1) return 1;\\n\\t\\t\\tint place=f(i+2,n);\\n\\t\\t\\tint notplace=f(i+1,n);\\n\\t\\t\\treturn (place+notplace)%mod;\\n\\t\\t}\\n\\n\\t\\tint countHousePlacements(int n) {\\n\\t\\t\\tlong long a=f(1,n);\\n\\t\\t\\treturn (long long)(a*a)%mod;\\n\\t\\t}\\n\\t};\\n\\n# Method - 2 [Memoization] \\n\\n![image](https://assets.leetcode.com/users/images/cd6f2568-7503-40c8-b761-c254a6e9839c_1663574897.711473.png)\\n\\n**T->O(n) && S->O(n) + O(n) [Recursion Stackspace]**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tlong long mod=1e9+7;\\n\\t\\t\\tint f(int i,int n,vector<int>& dp){\\n\\t\\t\\t\\tif(i>=n+1) return 1;\\n\\t\\t\\t\\tif(dp[i]!=-1) return dp[i];\\n\\t\\t\\t\\tint place=f(i+2,n,dp);\\n\\t\\t\\t\\tint notplace=f(i+1,n,dp);\\n\\t\\t\\t\\treturn dp[i]=(place+notplace)%mod;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint countHousePlacements(int n) {\\n\\t\\t\\t\\tvector<int> dp(n+1,-1);\\n\\t\\t\\t\\tlong long a=f(1,n,dp);\\n\\t\\t\\t\\treturn ((long long)(a*a))%mod;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n# Method -3 [Tabulation]\\t\\n\\n![image](https://assets.leetcode.com/users/images/f6ee7d59-8a8f-4bb6-b623-44ce24737ee3_1663579177.3149905.png)\\n\\n**T->O(n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long mod=1e9+7;\\n\\t\\tint countHousePlacements(int n) {\\n\\t\\t\\tvector<int> dp(n+3,1);\\n\\t\\t\\tfor(int i=n;i>0;i--){\\n\\t\\t\\t\\tint place=dp[i+2];\\n\\t\\t\\t\\tint notplace=dp[i+1];\\n\\t\\t\\t\\tdp[i]=(place+notplace)%mod;\\n\\t\\t\\t}\\n\\t\\t\\treturn ((long long)(dp[1]*dp[1]))%mod;\\n\\t\\t}\\n\\t};\\n\\t\\n# Method - 4 [SpaceOptimization]\\t\\n![image](https://assets.leetcode.com/users/images/a1ddc8cf-ebb5-47b7-bba4-d771143c21e6_1663579705.0908558.png)\\n\\n**T->O(n) && S->O(1)**\\n\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    int countHousePlacements(int n) {\\n        long long last1=1,last2=1,curr;\\n        for(int i=n;i>0;i--){\\n            curr=(last1+last2)%mod;\\n            last2=last1;\\n            last1=curr;\\n        }\\n        return (long long)(curr*curr)%mod;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint mod=1e9+7;\\n\\t\\tint f(int i,int n){\\n\\t\\t\\tif(i>=n+1) return 1;\\n\\t\\t\\tint place=f(i+2,n);\\n\\t\\t\\tint notplace=f(i+1,n);\\n\\t\\t\\treturn (place+notplace)%mod;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2577954,
                "title": "c-dp-readable-code",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    ll f(int i, int n, vector <ll> &dp){\\n        if(i >= n) return 1;\\n        if(dp[i] != -1) return dp[i];\\n        \\n        ll place = f(i+2, n, dp);\\n        ll notPlace = f(i+1, n, dp);\\n        \\n        return dp[i] = (place + notPlace)%MOD;\\n    }\\n    int countHousePlacements(int n) {\\n        vector <ll> dp(n+1, -1);\\n        ll temp = f(0, n, dp)%MOD;\\n        ll ans = (temp*temp)%MOD;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    ll f(int i, int n, vector <ll> &dp){\\n        if(i >= n) return 1;\\n        if(dp[i] != -1) return dp[i];\\n        \\n        ll place = f(i+2, n, dp);\\n        ll notPlace = f(i+1, n, dp);\\n        \\n        return dp[i] = (place + notPlace)%MOD;\\n    }\\n    int countHousePlacements(int n) {\\n        vector <ll> dp(n+1, -1);\\n        ll temp = f(0, n, dp)%MOD;\\n        ll ans = (temp*temp)%MOD;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565538,
                "title": "python-simple-loop",
                "content": "If we let the number of ways to place the houses on both sides of the streets be *H*(*n*), then *H*(*n*) = *F*\\xB2(*n*+*2*), where *F*(*n*) is the *n*th Fibonacci number. Each side of the street obeys the recurrence *H*(*n*) = *H*(*n* \\u2012 1) + *H*(*n* \\u2012 2), which is the same as the Fibonacci sequence, but with the initial condition *H*(1) = 2. (The latter follows because there are two ways to place the houses in the case of a single lot: either the lot has a house or the lot is left empty.)\\n```\\nclass Solution:\\n    def __init__ (self):\\n        self.MODULUS = 10**9 + 7\\n        \\n    def countHousePlacements(self, n: int) -> int:\\n        return self.fib(n+2)**2 % self.MODULUS\\n\\n    def fib(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        elif n == 1:\\n            return 1\\n        \\n        f1 = 0\\n        f2 = 1\\n        k = 2\\n        while k <= n:\\n            f1, f2 = (f1 + f2) % self.MODULUS, f1\\n            \\n            k += 1\\n            \\n        return (f1 + f2) % self.MODULUS\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__ (self):\\n        self.MODULUS = 10**9 + 7\\n        \\n    def countHousePlacements(self, n: int) -> int:\\n        return self.fib(n+2)**2 % self.MODULUS\\n\\n    def fib(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        elif n == 1:\\n            return 1\\n        \\n        f1 = 0\\n        f2 = 1\\n        k = 2\\n        while k <= n:\\n            f1, f2 = (f1 + f2) % self.MODULUS, f1\\n            \\n            k += 1\\n            \\n        return (f1 + f2) % self.MODULUS\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556690,
                "title": "java-dp-solution-with-explanation",
                "content": "class Solution {\\n\\n    public int countHousePlacements(int n) {\\n        // pB - count of ways in previous plot such that at the end building is present\\n        // pP - count of ways in previous plot such that at the end is plot is present\\n        // cB - ways in which we can have building at current spot\\n        // cP - ways in which we can have plot at current spot\\n        \\n        // two buildings cannot be side by side (Rule)\\n       \\n        // solving for upper side of road\\n        long pB = 1;\\n        long pP = 1;\\n        \\n        for(int i = 2; i <= n; i++) {\\n            long cB = pP;\\n            long cP = pB + pP;\\n            \\n            pB = cB  % 1000000007;\\n            pP = cP  % 1000000007;\\n        }\\n        long ways = (pB + pP);\\n        // same order can used at other side of road so\\n        long res = (ways * ways) % 1000000007;\\n        // System.out.println(res);\\n        \\n        return (int)res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\n    public int countHousePlacements(int n) {\\n        // pB - count of ways in previous plot such that at the end building is present\\n        // pP - count of ways in previous plot such that at the end is plot is present\\n        // cB - ways in which we can have building at current spot\\n        // cP - ways in which we can have plot at current spot\\n        \\n        // two buildings cannot be side by side (Rule)\\n       \\n        // solving for upper side of road\\n        long pB = 1;\\n        long pP = 1;\\n        \\n        for(int i = 2; i <= n; i++) {\\n            long cB = pP;\\n            long cP = pB + pP;\\n            \\n            pB = cB  % 1000000007;\\n            pP = cP  % 1000000007;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2541239,
                "title": "python-easy-dp-like-fibonacci",
                "content": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        dp = defaultdict(int)\\n        def find(i):\\n            if i==1:\\n                return 2\\n            if i==2:\\n                return 3\\n            if i not in dp:\\n                dp[i] = find(i-1)+find(i-2)\\n            return dp[i]\\n            \\n        return find(n)**2%1000000007\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        dp = defaultdict(int)\\n        def find(i):\\n            if i==1:\\n                return 2\\n            if i==2:\\n                return 3\\n            if i not in dp:\\n                dp[i] = find(i-1)+find(i-2)\\n            return dp[i]\\n            \\n        return find(n)**2%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526444,
                "title": "c-simple-dp",
                "content": "```\\n#define ll long long\\n\\n\\n// F(i) = count for n*2 street for i-th index\\n// G(i) = count for n*1 street for i-th index\\n// F(i) = G(i)*G(i)\\n// G(i) = G(i-1)+G(i-2)\\n\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        if (n == 1) {\\n            return 4;\\n        }\\n        ll count = 0;\\n        ll mod = 1e9+7;\\n        ll a = 1; // G(i-2)\\n        ll b = 2; // G(i-1)\\n        for (int i = 2; i < n; i++) {\\n            ll c = (a+b)%mod;\\n            a = b;\\n            b = c;\\n        }\\n        return ((a+b)%mod * (a+b)%mod)%mod; // F(i)\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n\\n\\n// F(i) = count for n*2 street for i-th index\\n// G(i) = count for n*1 street for i-th index\\n// F(i) = G(i)*G(i)\\n// G(i) = G(i-1)+G(i-2)\\n\\nclass Solution {\\npublic:\\n    int countHousePlacements(int n) {\\n        if (n == 1) {\\n            return 4;\\n        }\\n        ll count = 0;\\n        ll mod = 1e9+7;\\n        ll a = 1; // G(i-2)\\n        ll b = 2; // G(i-1)\\n        for (int i = 2; i < n; i++) {\\n            ll c = (a+b)%mod;\\n            a = b;\\n            b = c;\\n        }\\n        return ((a+b)%mod * (a+b)%mod)%mod; // F(i)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522818,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        long building = 1;\\n        long space = 1;\\n        for (int i = 2; i <= n; i++) {\\n            long nBuilding = (int)space;\\n            long nSpace = (space + building) % 1000000007;\\n            \\n            building = nBuilding;\\n            space = (int)nSpace;\\n        }\\n        \\n        long total = (building + space)*(building + space) % 1000000007;\\n        return (int)total;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countHousePlacements(int n) {\\n        long building = 1;\\n        long space = 1;\\n        for (int i = 2; i <= n; i++) {\\n            long nBuilding = (int)space;\\n            long nSpace = (space + building) % 1000000007;\\n            \\n            building = nBuilding;\\n            space = (int)nSpace;\\n        }\\n        \\n        long total = (building + space)*(building + space) % 1000000007;\\n        return (int)total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516682,
                "title": "python-simple-dynamic-programming",
                "content": "\\n    def countHousePlacements(self, n):\\n        if n <= 2:\\n            return (n+1)*(n+1)\\n        \\n        dp = [0]*n\\n        \\n        dp[0], dp[1] = 2, 3\\n        \\n        for i in range(2,n):\\n            dp[i] = dp[i-1] + dp[i-2]\\n            \\n        return pow(dp[-1],2,10**9+7)",
                "solutionTags": [],
                "code": "\\n    def countHousePlacements(self, n):\\n        if n <= 2:\\n            return (n+1)*(n+1)\\n        \\n        dp = [0]*n\\n        \\n        dp[0], dp[1] = 2, 3\\n        \\n        for i in range(2,n):\\n            dp[i] = dp[i-1] + dp[i-2]\\n            \\n        return pow(dp[-1],2,10**9+7)",
                "codeTag": "Python3"
            },
            {
                "id": 2510983,
                "title": "c",
                "content": "```\\n int countHousePlacements(int n) {\\n       if(n==1)\\n           return 2*2;\\n        if(n==2)\\n            return 3*3;\\n        long mod=1000000007;\\n        long house[n+1];\\n        house[0]=-1;\\n        house[1]=2;\\n        house[2]=3;\\n        for(int i=3;i<=n;i++)\\n            house[i]=(house[i-1]+house[i-2])%mod;\\n        long ans=((house[n]%mod * house[n]%mod)%mod);\\n        return int(ans);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int countHousePlacements(int n) {\\n       if(n==1)\\n           return 2*2;\\n        if(n==2)\\n            return 3*3;\\n        long mod=1000000007;\\n        long house[n+1];\\n        house[0]=-1;\\n        house[1]=2;\\n        house[2]=3;\\n        for(int i=3;i<=n;i++)\\n            house[i]=(house[i-1]+house[i-2])%mod;\\n        long ans=((house[n]%mod * house[n]%mod)%mod);\\n        return int(ans);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2496466,
                "title": "easy-python-solution-using-fibonacci-series-logic",
                "content": "**Runtime: 163 ms, faster than 77.15% of Python3\\nMemory Usage: 13.9 MB, less than 61.94%**\\n\\n**Here by simple obervation of i/p and o/p we could infer that this is a modification of a fibonacci series problem where \\nif i/p=1-->o/p=4\\nif i/p=2-->o/p=9=3^2\\nif i/p=3-->o/p=25=5^2\\nif i/p=4-->o/p=64=8^2\\nif i/p=5-->o/p=169=13^2\\nif i/p=6-->o/p=221=21^2\\nso, if n is the input the output is square of the nth rof the fibonacci series \\nHence use the following logic to get desired output  **\\n\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        f=0\\n        s=1\\n        t=f+s\\n        \\n        for i in range(0,n+1):\\n            t=f+s\\n            f=s\\n            s=t\\n        ans=t*t\\n        \\n        return ans%1000000007\\n\\n",
                "solutionTags": [],
                "code": "**Runtime: 163 ms, faster than 77.15% of Python3\\nMemory Usage: 13.9 MB, less than 61.94%**\\n\\n**Here by simple obervation of i/p and o/p we could infer that this is a modification of a fibonacci series problem where \\nif i/p=1-->o/p=4\\nif i/p=2-->o/p=9=3^2\\nif i/p=3-->o/p=25=5^2\\nif i/p=4-->o/p=64=8^2\\nif i/p=5-->o/p=169=13^2\\nif i/p=6-->o/p=221=21^2\\nso, if n is the input the output is square of the nth rof the fibonacci series \\nHence use the following logic to get desired output  **\\n\\nclass Solution:\\n    def countHousePlacements(self, n: int) -> int:\\n        f=0\\n        s=1\\n        t=f+s\\n        \\n        for i in range(0,n+1):\\n            t=f+s\\n            f=s\\n            s=t\\n        ans=t*t\\n        \\n        return ans%1000000007\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2496380,
                "title": "java-simple-observation",
                "content": "```\\nclass Solution {\\n    int MOD=1000000007;\\n    public int countHousePlacements(int n) {\\n        long one=1;\\n        long zero=1;\\n        for(int i=2;i<=n;i++){\\n            long temp=one;\\n            long temp2=(one+zero)%MOD;\\n            one=zero;\\n            zero=temp2;\\n        }\\n        long ans=(zero+one)%MOD;\\n        long mult=(ans*ans)%MOD;\\n        return (int)(mult);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int MOD=1000000007;\\n    public int countHousePlacements(int n) {\\n        long one=1;\\n        long zero=1;\\n        for(int i=2;i<=n;i++){\\n            long temp=one;\\n            long temp2=(one+zero)%MOD;\\n            one=zero;\\n            zero=temp2;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1988868,
                "content": [
                    {
                        "username": "pratik9113_",
                        "content": "it is done by fibbonacci for n = 1,2,3,4,5:  output : 4,9,25,64,169  respectively are the square of 2,3,5,8,13 and they are actually square of this number \\nit could be an approach but not efficient to test all the cases bcz we have a limit of n = 10 to power 4\\n"
                    },
                    {
                        "username": "dm_102",
                        "content": "Don\\'t You think Adjacent Sides Must Be specified Properly? \\nI mean For Ex : \\n\\nSide 1 : \\n1 2 3\\nSide 2 :  \\n3 1 2\\n\\nHere, Side 1 & 2 Are Adjacent to each other on Diff. Sides \\nSo Solution  : (Can be All Possible Permutations - No. Of adjacent Houses)\\nHere in above scenario 1&2 houses are adjacent so answer may be : (9p3 - possible adjacent) ; p->permutation\\n"
                    },
                    {
                        "username": "Ajay_Babu_Anantharaman",
                        "content": "Same as Fibonacci series, in iterative method small change is it starts from [1,2] and square the result value and modulo with 10**9 + 7"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Calculate number of ways to place houses in way and just square it\\nbecause for each house in on line there can be n combination of house in other side."
                    }
                ]
            },
            {
                "id": 1976049,
                "content": [
                    {
                        "username": "pratik9113_",
                        "content": "it is done by fibbonacci for n = 1,2,3,4,5:  output : 4,9,25,64,169  respectively are the square of 2,3,5,8,13 and they are actually square of this number \\nit could be an approach but not efficient to test all the cases bcz we have a limit of n = 10 to power 4\\n"
                    },
                    {
                        "username": "dm_102",
                        "content": "Don\\'t You think Adjacent Sides Must Be specified Properly? \\nI mean For Ex : \\n\\nSide 1 : \\n1 2 3\\nSide 2 :  \\n3 1 2\\n\\nHere, Side 1 & 2 Are Adjacent to each other on Diff. Sides \\nSo Solution  : (Can be All Possible Permutations - No. Of adjacent Houses)\\nHere in above scenario 1&2 houses are adjacent so answer may be : (9p3 - possible adjacent) ; p->permutation\\n"
                    },
                    {
                        "username": "Ajay_Babu_Anantharaman",
                        "content": "Same as Fibonacci series, in iterative method small change is it starts from [1,2] and square the result value and modulo with 10**9 + 7"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Calculate number of ways to place houses in way and just square it\\nbecause for each house in on line there can be n combination of house in other side."
                    }
                ]
            },
            {
                "id": 1967916,
                "content": [
                    {
                        "username": "pratik9113_",
                        "content": "it is done by fibbonacci for n = 1,2,3,4,5:  output : 4,9,25,64,169  respectively are the square of 2,3,5,8,13 and they are actually square of this number \\nit could be an approach but not efficient to test all the cases bcz we have a limit of n = 10 to power 4\\n"
                    },
                    {
                        "username": "dm_102",
                        "content": "Don\\'t You think Adjacent Sides Must Be specified Properly? \\nI mean For Ex : \\n\\nSide 1 : \\n1 2 3\\nSide 2 :  \\n3 1 2\\n\\nHere, Side 1 & 2 Are Adjacent to each other on Diff. Sides \\nSo Solution  : (Can be All Possible Permutations - No. Of adjacent Houses)\\nHere in above scenario 1&2 houses are adjacent so answer may be : (9p3 - possible adjacent) ; p->permutation\\n"
                    },
                    {
                        "username": "Ajay_Babu_Anantharaman",
                        "content": "Same as Fibonacci series, in iterative method small change is it starts from [1,2] and square the result value and modulo with 10**9 + 7"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Calculate number of ways to place houses in way and just square it\\nbecause for each house in on line there can be n combination of house in other side."
                    }
                ]
            },
            {
                "id": 1920463,
                "content": [
                    {
                        "username": "pratik9113_",
                        "content": "it is done by fibbonacci for n = 1,2,3,4,5:  output : 4,9,25,64,169  respectively are the square of 2,3,5,8,13 and they are actually square of this number \\nit could be an approach but not efficient to test all the cases bcz we have a limit of n = 10 to power 4\\n"
                    },
                    {
                        "username": "dm_102",
                        "content": "Don\\'t You think Adjacent Sides Must Be specified Properly? \\nI mean For Ex : \\n\\nSide 1 : \\n1 2 3\\nSide 2 :  \\n3 1 2\\n\\nHere, Side 1 & 2 Are Adjacent to each other on Diff. Sides \\nSo Solution  : (Can be All Possible Permutations - No. Of adjacent Houses)\\nHere in above scenario 1&2 houses are adjacent so answer may be : (9p3 - possible adjacent) ; p->permutation\\n"
                    },
                    {
                        "username": "Ajay_Babu_Anantharaman",
                        "content": "Same as Fibonacci series, in iterative method small change is it starts from [1,2] and square the result value and modulo with 10**9 + 7"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "Calculate number of ways to place houses in way and just square it\\nbecause for each house in on line there can be n combination of house in other side."
                    }
                ]
            }
        ]
    }
]