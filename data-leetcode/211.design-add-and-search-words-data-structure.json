[
    {
        "title": "Design Add and Search Words Data Structure",
        "question_content": "Design a data structure that supports adding new words and finding if a string matches any previously added string.\nImplement the WordDictionary class:\n\n\tWordDictionary()&nbsp;Initializes the object.\n\tvoid addWord(word) Adds word to the data structure, it can be matched later.\n\tbool search(word)&nbsp;Returns true if there is any string in the data structure that matches word&nbsp;or false otherwise. word may contain dots '.' where dots can be matched with any letter.\n\n&nbsp;\nExample:\n\nInput\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\nOutput\n[null,null,null,null,false,true,true,true]\nExplanation\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\"bad\");\nwordDictionary.addWord(\"dad\");\nwordDictionary.addWord(\"mad\");\nwordDictionary.search(\"pad\"); // return False\nwordDictionary.search(\"bad\"); // return True\nwordDictionary.search(\".ad\"); // return True\nwordDictionary.search(\"b..\"); // return True\n\n&nbsp;\nConstraints:\n\n\t1 <= word.length <= 25\n\tword in addWord consists of lowercase English letters.\n\tword in search consist of '.' or lowercase English letters.\n\tThere will be at most 2 dots in word for search queries.\n\tAt most 104 calls will be made to addWord and search.",
        "solutions": [
            {
                "id": 1725327,
                "title": "java-c-python-a-very-well-detailed-explanation",
                "content": "```\\nWhat the question is saying, \\nWe have to design a data structure that supports adding new words and finding if a string matches any previously added string.\\n```\\n\\n**So, to design a DS we only need to support 3 function\\'s for this data structure.**\\n\\n* One is the **constructor** that\\'s gonna intialize the object.\\n* One is **Adding** the **word\\'s**, but all of them are lower case from **a to z**\\n* One is **Searching** a **word**, and the word can contains any character from **a - z**. But there is **1 additional character** it contains, **\".\"** character `[And what they told \".\" character is a wild card, can match any character easily in the string]`\\n\\n**The brute force way to solve this problem** is pretty simple, \"*having a list of words & then just for every search we would just see, if this search match any of the word in input list*.\" **[But it\\'s not an efficient way]**\\n\\nLet\\'s talk about, **efficient way to solve this problem**. And for that we require **Trie data structure** a.k.a **Prefix tree**\\n\\nLet\\'s understand **Trie first**,\\n**Trie** is basically a **tree** that has some kind of **root node** & each node can have up to **26 children in this problem**. Because we have **lower case character from a to z**. So, basically each **node represent\\'s a single character**. And each node could have up to 26 additional children:\\n\\n![image](https://assets.leetcode.com/users/images/f713156d-16ed-4f90-86f3-9e49c91cff9d_1643345343.9775767.png)\\n\\nAnd basically word in this example means, let\\'s take **\"a\"** having child **\"b\" -> with \"c\"**, so that\\'s will be a **single word**. And if we insert the word **\"abc\"** in our **trie**, so basically how\\'s it looks like:\\n\\n![image](https://assets.leetcode.com/users/images/09de3579-2be4-43a2-8fba-4b6c1c268cf4_1643359099.5805793.png)\\n\\nOne additional thing we have to say is, for a particular node such as **\"c\"** this is the **end of the word**. Because if we **added another word** example:- **\"ab\"**. So, we don\\'t add them back again as if you notice they are already available to us, we just **gonna re-use** these characters. So, we have 2 word\\'s along this **path \"abc\" & \"ab\"**\\nBasically, all words start with **\"a\"** are gonna be here, that\\'s what it make it **efficient**. That\\'s why it\\'s called **prefix tree**.\\n\\n`Now, you have understood how Trie aka Prefix Tree work.`\\n\\nNow let\\'s take an example & build our tree,\\n**Input**\\n```\\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\\n```\\n**Output**\\n```\\n[null,null,null,null,false,true,true,true]\\n```\\n* The first word we add is **\"bad\". \"b\" -> \"a\" -> \"d\"**\\n\\n* Next we adding another word **\"dad\"**. So, we have to start with **different path**. As, these two word\\'s have a **different prefix**. One start with **\"b\"** and one start with **\"d\"**. So, let\\'s add it: **\"d\" -> \"a\" -> \"d\"**\\n\\n* We have one last word before we start searching, this one gonna be **\"mad\"**. So, we don\\'t have **\"m\"**, then let\\'s add it: **\"m\" -> \"a\" -> \"d\"**\\n\\n![image](https://assets.leetcode.com/users/images/dbb4b468-4cd3-4347-aa88-328c6ff70bee_1643341320.915674.gif)\\n\\nSo far we have **3 word\\'s** and all of them end with different **\"d\"**. But they all **3 of them have different prefix** that\\'s why they are along different path\\'s.\\n\\n![image](https://assets.leetcode.com/users/images/e5e9489e-632b-4536-9596-4fddf1ddeb5c_1643341419.4522402.png)\\n\\n`Now let\\'s go for searching path:-`\\n\\n* So, first word we gonna search for **\"pad\"**. We gonna **start** at **beginning**. First we gonna try are there any **\"p\"** in this. That means immediately we **return false** as **\"pad\"** doesn\\'t exist in our input.\\n\\n* Now, we search another word **\"bad\"**. So, we **start at the root** and see there are any **\"b\"**. Yes, we have **\"b\"**. now we check does this **\"b\"** have a child **\"a\"**, yes it does. Now last character **\"d\"** does **\"a\"** has a child **\"d\"**, yes it does have. Lastly we have to say the last character **\"d\"** is in our **trie**, which designated as the end of the word. Sice it\\'s **marked red**. Therefore, we **return true** for this input **\"bad\"**\\n\\n\\n* Now, in this search we have **\".ad\"**, the dot **\".\"** character matches any character. So, we start at the root and go to any of the path and to do that we have to use **DFS or backtracking approach**. So, let\\'s say first path we decided **\"b\"**. now we check does this **\"b\"** have a child **\"a\"**, yes it does. Now last character **\"d\"** does **\"a\"** has a child **\"d\"**, yes it does have. Lastly we have to say the last character **\"d\"** in our trie, is designated as the end of the word. Therefore, we **return true** for this input **\".ad\"**\\n\\n\\n* One last search, In this we have **\"b..\"**. So, we start at the root and see there are any **\"b\"**. Yes, we have **\"b\"**. Now we check do we have any character to go below for our current dot **\".\"**, yes we have **\"a\"**. Now we are looking for any character for our last **dot \".\"** Yes we have **\"d\"** & it is end of the word. Therefore, we **return true** for this input **\"b..\"**\\n\\nNow understand this ***VISUALLY, it\\'s not super hard.***\\n\\n![image](https://assets.leetcode.com/users/images/ddecc948-77d6-45d6-bcd3-83f7b9ace6ff_1643343393.560126.gif)\\n\\n\\n**Now, let\\'s code it up:**\\n\\n**Java**\\n```\\nclass WordDictionary {\\n    private WordDictionary[] children;\\n    boolean isEndOfWord;\\n    // Initialize your data structure here. \\n    public WordDictionary() {\\n        children = new WordDictionary[26];\\n        isEndOfWord = false;\\n    }\\n    \\n    // Adds a word into the data structure. \\n    public void addWord(String word) {\\n        WordDictionary curr = this;\\n        for(char c: word.toCharArray()){\\n            if(curr.children[c - \\'a\\'] == null)\\n                curr.children[c - \\'a\\'] = new WordDictionary();\\n            curr = curr.children[c - \\'a\\'];\\n        }\\n        curr.isEndOfWord = true;\\n    }\\n    \\n    // Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. \\n    public boolean search(String word) {\\n        WordDictionary curr = this;\\n        for(int i = 0; i < word.length(); ++i){\\n            char c = word.charAt(i);\\n            if(c == \\'.\\'){\\n                for(WordDictionary ch: curr.children)\\n                    if(ch != null && ch.search(word.substring(i+1))) return true;\\n                return false;\\n            }\\n            if(curr.children[c - \\'a\\'] == null) return false;\\n            curr = curr.children[c - \\'a\\'];\\n        }\\n        return curr != null && curr.isEndOfWord;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass WordDictionary {\\n    vector<WordDictionary*> children;\\n    bool isEndOfWord;\\npublic:\\n    // Initialize your data structure here. \\n    WordDictionary(): isEndOfWord(false){\\n        children = vector<WordDictionary*>(26, nullptr);\\n    }\\n    \\n    // Adds a word into the data structure. \\n    void addWord(string word) {\\n        WordDictionary *curr = this;\\n        for(char c: word){\\n            if(curr->children[c - \\'a\\'] == nullptr)\\n                curr->children[c - \\'a\\'] = new WordDictionary();\\n            curr = curr->children[c - \\'a\\'];\\n        }\\n        curr->isEndOfWord = true;\\n    }\\n    \\n    // Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. \\n    bool search(string word) {\\n        WordDictionary *curr = this;\\n        for(int i = 0; i < word.length(); ++i){\\n            char c = word[i];\\n            if(c == \\'.\\'){\\n                for(auto ch: curr->children)\\n                    if(ch && ch->search(word.substr(i+1))) return true;\\n                return false;\\n            }\\n            if(curr->children[c - \\'a\\'] == nullptr) return false;\\n            curr = curr->children[c - \\'a\\'];\\n        }\\n        return curr && curr->isEndOfWord;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \\n        # Initialize your data structure here.\\n        self.children = [None]*26\\n        self.isEndOfWord = False\\n        \\n\\n    def addWord(self, word: str) -> None:\\n\\n        # Adds a word into the data structure.\\n        curr = self\\n        for c in word:\\n            if curr.children[ord(c) - ord(\\'a\\')] == None:\\n                curr.children[ord(c) - ord(\\'a\\')] = WordDictionary()\\n            curr = curr.children[ord(c) - ord(\\'a\\')]\\n        \\n        curr.isEndOfWord = True;\\n        \\n\\n    def search(self, word: str) -> bool:\\n\\n        # Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        curr = self\\n        for i in range(len(word)):\\n            c = word[i]\\n            if c == \\'.\\':\\n                for ch in curr.children:\\n                    if ch != None and ch.search(word[i+1:]): return True\\n                return False\\n            \\n            if curr.children[ord(c) - ord(\\'a\\')] == None: return False\\n            curr = curr.children[ord(c) - ord(\\'a\\')]\\n        \\n        return curr != None and curr.isEndOfWord\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(M) for well defined words, But in worse case BigO(M.26^N)\\n\\n* **Space Complexity :-** BigO(1) for well defined words, But for worst case BigO(M)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nWhat the question is saying, \\nWe have to design a data structure that supports adding new words and finding if a string matches any previously added string.\\n```\n```\\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\\n```\n```\\n[null,null,null,null,false,true,true,true]\\n```\n```\\nclass WordDictionary {\\n    private WordDictionary[] children;\\n    boolean isEndOfWord;\\n    // Initialize your data structure here. \\n    public WordDictionary() {\\n        children = new WordDictionary[26];\\n        isEndOfWord = false;\\n    }\\n    \\n    // Adds a word into the data structure. \\n    public void addWord(String word) {\\n        WordDictionary curr = this;\\n        for(char c: word.toCharArray()){\\n            if(curr.children[c - \\'a\\'] == null)\\n                curr.children[c - \\'a\\'] = new WordDictionary();\\n            curr = curr.children[c - \\'a\\'];\\n        }\\n        curr.isEndOfWord = true;\\n    }\\n    \\n    // Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. \\n    public boolean search(String word) {\\n        WordDictionary curr = this;\\n        for(int i = 0; i < word.length(); ++i){\\n            char c = word.charAt(i);\\n            if(c == \\'.\\'){\\n                for(WordDictionary ch: curr.children)\\n                    if(ch != null && ch.search(word.substring(i+1))) return true;\\n                return false;\\n            }\\n            if(curr.children[c - \\'a\\'] == null) return false;\\n            curr = curr.children[c - \\'a\\'];\\n        }\\n        return curr != null && curr.isEndOfWord;\\n    }\\n}\\n```\n```\\nclass WordDictionary {\\n    vector<WordDictionary*> children;\\n    bool isEndOfWord;\\npublic:\\n    // Initialize your data structure here. \\n    WordDictionary(): isEndOfWord(false){\\n        children = vector<WordDictionary*>(26, nullptr);\\n    }\\n    \\n    // Adds a word into the data structure. \\n    void addWord(string word) {\\n        WordDictionary *curr = this;\\n        for(char c: word){\\n            if(curr->children[c - \\'a\\'] == nullptr)\\n                curr->children[c - \\'a\\'] = new WordDictionary();\\n            curr = curr->children[c - \\'a\\'];\\n        }\\n        curr->isEndOfWord = true;\\n    }\\n    \\n    // Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. \\n    bool search(string word) {\\n        WordDictionary *curr = this;\\n        for(int i = 0; i < word.length(); ++i){\\n            char c = word[i];\\n            if(c == \\'.\\'){\\n                for(auto ch: curr->children)\\n                    if(ch && ch->search(word.substr(i+1))) return true;\\n                return false;\\n            }\\n            if(curr->children[c - \\'a\\'] == nullptr) return false;\\n            curr = curr->children[c - \\'a\\'];\\n        }\\n        return curr && curr->isEndOfWord;\\n    }\\n};\\n```\n```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \\n        # Initialize your data structure here.\\n        self.children = [None]*26\\n        self.isEndOfWord = False\\n        \\n\\n    def addWord(self, word: str) -> None:\\n\\n        # Adds a word into the data structure.\\n        curr = self\\n        for c in word:\\n            if curr.children[ord(c) - ord(\\'a\\')] == None:\\n                curr.children[ord(c) - ord(\\'a\\')] = WordDictionary()\\n            curr = curr.children[ord(c) - ord(\\'a\\')]\\n        \\n        curr.isEndOfWord = True;\\n        \\n\\n    def search(self, word: str) -> bool:\\n\\n        # Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        curr = self\\n        for i in range(len(word)):\\n            c = word[i]\\n            if c == \\'.\\':\\n                for ch in curr.children:\\n                    if ch != None and ch.search(word[i+1:]): return True\\n                return False\\n            \\n            if curr.children[ord(c) - ord(\\'a\\')] == None: return False\\n            curr = curr.children[ord(c) - ord(\\'a\\')]\\n        \\n        return curr != None and curr.isEndOfWord\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59554,
                "title": "my-simple-and-clean-java-code",
                "content": "Using backtrack to check each character of word to search.\\n\\n    public class WordDictionary {\\n        public class TrieNode {\\n            public TrieNode[] children = new TrieNode[26];\\n            public String item = \"\";\\n        }\\n        \\n        private TrieNode root = new TrieNode();\\n    \\n        public void addWord(String word) {\\n            TrieNode node = root;\\n            for (char c : word.toCharArray()) {\\n                if (node.children[c - 'a'] == null) {\\n                    node.children[c - 'a'] = new TrieNode();\\n                }\\n                node = node.children[c - 'a'];\\n            }\\n            node.item = word;\\n        }\\n    \\n        public boolean search(String word) {\\n            return match(word.toCharArray(), 0, root);\\n        }\\n        \\n        private boolean match(char[] chs, int k, TrieNode node) {\\n            if (k == chs.length) return !node.item.equals(\"\");   \\n            if (chs[k] != '.') {\\n                return node.children[chs[k] - 'a'] != null && match(chs, k + 1, node.children[chs[k] - 'a']);\\n            } else {\\n                for (int i = 0; i < node.children.length; i++) {\\n                    if (node.children[i] != null) {\\n                        if (match(chs, k + 1, node.children[i])) {\\n                            return true;\\n                        }\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Backtracking",
                    "Trie"
                ],
                "code": "Using backtrack to check each character of word to search.\\n\\n    public class WordDictionary {\\n        public class TrieNode {\\n            public TrieNode[] children = new TrieNode[26];\\n            public String item = \"\";\\n        }\\n        \\n        private TrieNode root = new TrieNode();\\n    \\n        public void addWord(String word) {\\n            TrieNode node = root;\\n            for (char c : word.toCharArray()) {\\n                if (node.children[c - 'a'] == null) {\\n                    node.children[c - 'a'] = new TrieNode();\\n                }\\n                node = node.children[c - 'a'];\\n            }\\n            node.item = word;\\n        }\\n    \\n        public boolean search(String word) {\\n            return match(word.toCharArray(), 0, root);\\n        }\\n        \\n        private boolean match(char[] chs, int k, TrieNode node) {\\n            if (k == chs.length) return !node.item.equals(\"\");   \\n            if (chs[k] != '.') {\\n                return node.children[chs[k] - 'a'] != null && match(chs, k + 1, node.children[chs[k] - 'a']);\\n            } else {\\n                for (int i = 0; i < node.children.length; i++) {\\n                    if (node.children[i] != null) {\\n                        if (match(chs, k + 1, node.children[i])) {\\n                            return true;\\n                        }\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 59725,
                "title": "python-easy-to-follow-solution-using-trie",
                "content": "    \\n\\n    class TrieNode():\\n        def __init__(self):\\n            self.children = collections.defaultdict(TrieNode)\\n            self.isWord = False\\n        \\n    class WordDictionary(object):\\n        def __init__(self):\\n            self.root = TrieNode()\\n\\n        def addWord(self, word):\\n            node = self.root\\n            for w in word:\\n                node = node.children[w]\\n            node.isWord = True\\n\\n        def search(self, word):\\n            node = self.root\\n            self.res = False\\n            self.dfs(node, word)\\n            return self.res\\n        \\n        def dfs(self, node, word):\\n            if not word:\\n                if node.isWord:\\n                    self.res = True\\n                return \\n            if word[0] == \".\":\\n                for n in node.children.values():\\n                    self.dfs(n, word[1:])\\n            else:\\n                node = node.children.get(word[0])\\n                if not node:\\n                    return \\n                self.dfs(node, word[1:])",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "    \\n\\n    class TrieNode():\\n        def __init__(self):\\n            self.children = collections.defaultdict(TrieNode)\\n            self.isWord = False\\n        \\n    class WordDictionary(object):\\n        def __init__(self):\\n            self.root = TrieNode()\\n\\n        def addWord(self, word):\\n            node = self.root\\n            for w in word:\\n                node = node.children[w]\\n            node.isWord = True\\n\\n        def search(self, word):\\n            node = self.root\\n            self.res = False\\n            self.dfs(node, word)\\n            return self.res\\n        \\n        def dfs(self, node, word):\\n            if not word:\\n                if node.isWord:\\n                    self.res = True\\n                return \\n            if word[0] == \".\":\\n                for n in node.children.values():\\n                    self.dfs(n, word[1:])\\n            else:\\n                node = node.children.get(word[0])\\n                if not node:\\n                    return \\n                self.dfs(node, word[1:])",
                "codeTag": "Java"
            },
            {
                "id": 59552,
                "title": "c-trie",
                "content": "This is a vanilla application of Trie. The main difficulty lies in how to deal with the `.` character. I use a naive solution in this place: each time when I reach a `.`, I simply traverse all the children of the current node and recursively search the remaining substring starting from each of those children.\\n\\n```cpp\\nclass TrieNode {\\npublic:\\n    bool word;\\n    TrieNode* children[26];\\n    TrieNode() {\\n        word = false;\\n        memset(children, NULL, sizeof(children));\\n    }\\n};\\n\\nclass WordDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    WordDictionary() {\\n        \\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            if (!node -> children[c - \\'a\\']) {\\n                node -> children[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node -> children[c - \\'a\\'];\\n        }\\n        node -> word = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word) {\\n        return search(word.c_str(), root);\\n    }\\nprivate:\\n    TrieNode* root = new TrieNode();\\n    \\n    bool search(const char* word, TrieNode* node) {\\n        for (int i = 0; word[i] && node; i++) {\\n            if (word[i] != \\'.\\') {\\n                node = node -> children[word[i] - \\'a\\'];\\n            } else {\\n                TrieNode* tmp = node;\\n                for (int j = 0; j < 26; j++) {\\n                    node = tmp -> children[j];\\n                    if (search(word + i + 1, node)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return node && node -> word;\\n    }\\n};\\n ```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```cpp\\nclass TrieNode {\\npublic:\\n    bool word;\\n    TrieNode* children[26];\\n    TrieNode() {\\n        word = false;\\n        memset(children, NULL, sizeof(children));\\n    }\\n};\\n\\nclass WordDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    WordDictionary() {\\n        \\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        TrieNode* node = root;\\n        for (char c : word) {\\n            if (!node -> children[c - \\'a\\']) {\\n                node -> children[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node -> children[c - \\'a\\'];\\n        }\\n        node -> word = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word) {\\n        return search(word.c_str(), root);\\n    }\\nprivate:\\n    TrieNode* root = new TrieNode();\\n    \\n    bool search(const char* word, TrieNode* node) {\\n        for (int i = 0; word[i] && node; i++) {\\n            if (word[i] != \\'.\\') {\\n                node = node -> children[word[i] - \\'a\\'];\\n            } else {\\n                TrieNode* tmp = node;\\n                for (int j = 0; j < 26; j++) {\\n                    node = tmp -> children[j];\\n                    if (search(word + i + 1, node)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return node && node -> word;\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 774530,
                "title": "python-trie-solution-with-dfs-explained",
                "content": "In this problem, we need to use **Trie** data structure. For more details go to the problem **208. Implement Trie (Prefix Tree)**. \\n\\nSo, what we have here? \\n1. `TrieNode` class with two values: dictionary of children and flag, if this node is end of some word.\\n2. Now, we need to implement `addWord(self, word)` function: we add symbol by symbol, and go deepere and deeper in our Trie. In the end we note our node as end node.\\n3. Now, about `search(self, word)` function. Here we use `dfs(node, i)` with backtracking, because we can have symbol `.` in our word (here `node` is link to Trie node and `i` is index of letter in `word`). So we need to check all options: we go to all possible children and call `dfs` recursively. If we found not `.`, but just some letter, we check if we have this letter as children, and if we have, we go deeper. If we are out of letters, that is `i == len(word)`, we return `True` if current `end_node` is equal to `1` and false in opposite case. Finally, we return `False` if we can not go deeper, but we still have letters.\\n4. Now, we just return `dfs(self.root, 0)`.\\n\\n**Complexity**: Easy part is space complexity, it is `O(M)`, where `M` is sum of lengths of all words in our Trie. This is upper bound: in practice it will be less than `M` and it depends, how much words are intersected. The worst time complexity is also `O(M)`, potentially we can visit all our Trie, if we have pattern like `.....`. For words without `.`, time complexity will be `O(h)`, where `h` is height of Trie. For words with several letters and several `.`, we have something in the middle.\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end_node = 0\\n        \\nclass WordDictionary:\\n    def __init__(self):\\n        self.root = TrieNode()      \\n\\n    def addWord(self, word):\\n        root = self.root\\n        for symbol in word:\\n            root = root.children.setdefault(symbol, TrieNode())\\n        root.end_node = 1\\n        \\n    def search(self, word):\\n        def dfs(node, i):\\n            if i == len(word): return node.end_node\\n               \\n            if word[i] == \".\":\\n                for child in node.children:\\n                    if dfs(node.children[child], i+1): return True\\n                    \\n            if word[i] in node.children:\\n                return dfs(node.children[word[i]], i+1)\\n            \\n            return False\\n    \\n        return dfs(self.root, 0)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end_node = 0\\n        \\nclass WordDictionary:\\n    def __init__(self):\\n        self.root = TrieNode()      \\n\\n    def addWord(self, word):\\n        root = self.root\\n        for symbol in word:\\n            root = root.children.setdefault(symbol, TrieNode())\\n        root.end_node = 1\\n        \\n    def search(self, word):\\n        def dfs(node, i):\\n            if i == len(word): return node.end_node\\n               \\n            if word[i] == \".\":\\n                for child in node.children:\\n                    if dfs(node.children[child], i+1): return True\\n                    \\n            if word[i] in node.children:\\n                return dfs(node.children[word[i]], i+1)\\n            \\n            return False\\n    \\n        return dfs(self.root, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59564,
                "title": "c-62ms-beats-100",
                "content": "**Solution 1**\\n\\nHash Table, 62ms, 100%.\\n```\\nclass WordDictionary {\\npublic:\\n    WordDictionary() {}\\n    \\n    void addWord(string word) {\\n        words[word.size()].push_back(word);\\n    }\\n    \\n    bool search(string word) {\\n        for(auto s: words[word.size()]) if(isEqual(s, word)) return true;\\n        return false;\\n    }\\n    \\nprivate:\\n    unordered_map<int, vector<string>>words;\\n    \\n    bool isEqual(string a, string b){\\n        for(int i = 0; i < a.size(); i++){\\n            if(b[i] == '.') continue;\\n            if(a[i] != b[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n***\\n**Solution 2**\\n\\nTrie, 88ms.\\n```\\nstruct TrieNode{\\n    bool isKey;\\n    TrieNode* next[26];\\n    TrieNode():isKey(false){\\n        memset(next, NULL, sizeof(next));\\n    }\\n};\\n\\nclass WordDictionary {\\npublic:\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        TrieNode* node = root;\\n        for(auto c: word){\\n            if(!node->next[c - 'a']) node->next[c - 'a'] = new TrieNode();\\n            node = node->next[c - 'a'];\\n        }\\n        node->isKey = true;\\n    }\\n    \\n    bool search(string word) {\\n        return helper(word, root);\\n    }\\n\\nprivate:\\n    TrieNode* root;\\n    \\n    bool helper(string word, TrieNode* node){\\n        for(int i = 0; i < word.size(); i++){\\n            char c = word[i];\\n            if(c != '.'){\\n                if(!node->next[c - 'a']) return false;\\n                node = node->next[c - 'a'];\\n            }\\n            else{\\n                bool found = false;\\n                int j = 0;\\n                for(; j < 26; j++){\\n                    if(node->next[j]) found |= helper(word.substr(i + 1), node->next[j]);\\n                    if(found) return true;\\n                }\\n                if(j == 26) return false;\\n            }\\n        }\\n        return node->isKey;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass WordDictionary {\\npublic:\\n    WordDictionary() {}\\n    \\n    void addWord(string word) {\\n        words[word.size()].push_back(word);\\n    }\\n    \\n    bool search(string word) {\\n        for(auto s: words[word.size()]) if(isEqual(s, word)) return true;\\n        return false;\\n    }\\n    \\nprivate:\\n    unordered_map<int, vector<string>>words;\\n    \\n    bool isEqual(string a, string b){\\n        for(int i = 0; i < a.size(); i++){\\n            if(b[i] == '.') continue;\\n            if(a[i] != b[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nstruct TrieNode{\\n    bool isKey;\\n    TrieNode* next[26];\\n    TrieNode():isKey(false){\\n        memset(next, NULL, sizeof(next));\\n    }\\n};\\n\\nclass WordDictionary {\\npublic:\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        TrieNode* node = root;\\n        for(auto c: word){\\n            if(!node->next[c - 'a']) node->next[c - 'a'] = new TrieNode();\\n            node = node->next[c - 'a'];\\n        }\\n        node->isKey = true;\\n    }\\n    \\n    bool search(string word) {\\n        return helper(word, root);\\n    }\\n\\nprivate:\\n    TrieNode* root;\\n    \\n    bool helper(string word, TrieNode* node){\\n        for(int i = 0; i < word.size(); i++){\\n            char c = word[i];\\n            if(c != '.'){\\n                if(!node->next[c - 'a']) return false;\\n                node = node->next[c - 'a'];\\n            }\\n            else{\\n                bool found = false;\\n                int j = 0;\\n                for(; j < 26; j++){\\n                    if(node->next[j]) found |= helper(word.substr(i + 1), node->next[j]);\\n                    if(found) return true;\\n                }\\n                if(j == 26) return false;\\n            }\\n        }\\n        return node->isKey;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313638,
                "title": "java-c-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am Giving away my premium content videos related to computer science and data science and also will be sharing well-structured assignments and study materials to clear interviews at top companies to my first 1000 Subscribers. So, **DON\\'T FORGET** to Subscribe\\n\\n**Click Here to Subscribe \\uD83D\\uDC49 https://www.youtube.com/@techwired8/?sub_confirmation=1**\\n\\n**Java:**\\n```\\nclass TrieNode {\\n    Map<Character, TrieNode> children;\\n    boolean isWord;\\n    \\n    public TrieNode() {\\n        children = new HashMap<>();\\n        isWord = false;\\n    }\\n}\\n\\nclass WordDictionary {\\n    private TrieNode root;\\n\\n    public WordDictionary() {\\n        root = new TrieNode();\\n    }\\n\\n    public void addWord(String word) {\\n        TrieNode node = root;\\n        // Traverse the trie for each character in the word\\n        for (int i = 0; i < word.length(); i++) {\\n            char c = word.charAt(i);\\n            // If the current node does not have a child with character c,\\n            // create a new node and add it as a child of the current node\\n            if (!node.children.containsKey(c)) {\\n                node.children.put(c, new TrieNode());\\n            }\\n            // Move to the child node corresponding to character c\\n            node = node.children.get(c);\\n        }\\n        // Mark the last node as a word node\\n        node.isWord = true;\\n    }\\n\\n    public boolean search(String word) {\\n        return searchHelper(root, word, 0);\\n    }\\n\\n    private boolean searchHelper(TrieNode node, String word, int index) {\\n        // If we have reached the end of the word,\\n        // check if the current node is a word node\\n        if (index == word.length()) {\\n            return node.isWord;\\n        }\\n        char c = word.charAt(index);\\n        if (c == \\'.\\') {\\n            // If the current character is a dot, we need to check all children of the current node\\n            // recursively by skipping over the dot character and moving to the next character of the word\\n            for (TrieNode child : node.children.values()) {\\n                if (searchHelper(child, word, index + 1)) {\\n                    return true;\\n                }\\n            }\\n            // If no child node matches the remaining characters of the word,\\n            // return false\\n            return false;\\n        } else {\\n            // If the current character is not a dot, move to the child node\\n            // corresponding to that character and continue recursively\\n            TrieNode child = node.children.get(c);\\n            if (child == null) {\\n                // If there is no child node corresponding to the current character,\\n                // return false\\n                return false;\\n            }\\n            return searchHelper(child, word, index + 1);\\n        }\\n    }\\n}\\n\\n```\\n\\n**C++:**\\n```\\n\\nclass TrieNode {\\npublic:\\n    unordered_map<char, TrieNode*> children;\\n    bool isWord;\\n    \\n    TrieNode() {\\n        isWord = false;\\n    }\\n};\\n\\nclass WordDictionary {\\nprivate:\\n    TrieNode* root;\\n\\npublic:\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n\\n    void addWord(string word) {\\n        TrieNode* node = root;\\n        // Traverse the trie for each character in the word\\n        for (int i = 0; i < word.length(); i++) {\\n            char c = word[i];\\n            // If the current node does not have a child with character c,\\n            // create a new node and add it as a child of the current node\\n            if (node->children.find(c) == node->children.end()) {\\n                node->children[c] = new TrieNode();\\n            }\\n            // Move to the child node corresponding to character c\\n            node = node->children[c];\\n        }\\n        // Mark the last node as a word node\\n        node->isWord = true;\\n    }\\n\\n    bool search(string word) {\\n        return searchHelper(root, word, 0);\\n    }\\n\\n    bool searchHelper(TrieNode* node, string& word, int index) {\\n        // If we have reached the end of the word,\\n        // check if the current node is a word node\\n        if (index == word.length()) {\\n            return node->isWord;\\n        }\\n        char c = word[index];\\n        if (c == \\'.\\') {\\n            // If the current character is a dot, we need to check all children of the current node\\n            // recursively by skipping over the dot character and moving to the next character of the word\\n            for (auto& p : node->children) {\\n                if (searchHelper(p.second, word, index + 1)) {\\n                    return true;\\n                }\\n            }\\n            // If no child node matches the remaining characters of the word,\\n            // return false\\n            return false;\\n        } else {\\n            // If the current character is not a dot, move to the child node\\n            // corresponding to that character and continue recursively\\n            if (node->children.find(c) == node->children.end()) {\\n                // If there is no child node corresponding to the current character,\\n                // return false\\n                return false;\\n            }\\n            TrieNode* child = node->children[c];\\n            return searchHelper(child, word, index + 1);\\n        }\\n    }\\n};\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\n    Map<Character, TrieNode> children;\\n    boolean isWord;\\n    \\n    public TrieNode() {\\n        children = new HashMap<>();\\n        isWord = false;\\n    }\\n}\\n\\nclass WordDictionary {\\n    private TrieNode root;\\n\\n    public WordDictionary() {\\n        root = new TrieNode();\\n    }\\n\\n    public void addWord(String word) {\\n        TrieNode node = root;\\n        // Traverse the trie for each character in the word\\n        for (int i = 0; i < word.length(); i++) {\\n            char c = word.charAt(i);\\n            // If the current node does not have a child with character c,\\n            // create a new node and add it as a child of the current node\\n            if (!node.children.containsKey(c)) {\\n                node.children.put(c, new TrieNode());\\n            }\\n            // Move to the child node corresponding to character c\\n            node = node.children.get(c);\\n        }\\n        // Mark the last node as a word node\\n        node.isWord = true;\\n    }\\n\\n    public boolean search(String word) {\\n        return searchHelper(root, word, 0);\\n    }\\n\\n    private boolean searchHelper(TrieNode node, String word, int index) {\\n        // If we have reached the end of the word,\\n        // check if the current node is a word node\\n        if (index == word.length()) {\\n            return node.isWord;\\n        }\\n        char c = word.charAt(index);\\n        if (c == \\'.\\') {\\n            // If the current character is a dot, we need to check all children of the current node\\n            // recursively by skipping over the dot character and moving to the next character of the word\\n            for (TrieNode child : node.children.values()) {\\n                if (searchHelper(child, word, index + 1)) {\\n                    return true;\\n                }\\n            }\\n            // If no child node matches the remaining characters of the word,\\n            // return false\\n            return false;\\n        } else {\\n            // If the current character is not a dot, move to the child node\\n            // corresponding to that character and continue recursively\\n            TrieNode child = node.children.get(c);\\n            if (child == null) {\\n                // If there is no child node corresponding to the current character,\\n                // return false\\n                return false;\\n            }\\n            return searchHelper(child, word, index + 1);\\n        }\\n    }\\n}\\n\\n```\n```\\n\\nclass TrieNode {\\npublic:\\n    unordered_map<char, TrieNode*> children;\\n    bool isWord;\\n    \\n    TrieNode() {\\n        isWord = false;\\n    }\\n};\\n\\nclass WordDictionary {\\nprivate:\\n    TrieNode* root;\\n\\npublic:\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n\\n    void addWord(string word) {\\n        TrieNode* node = root;\\n        // Traverse the trie for each character in the word\\n        for (int i = 0; i < word.length(); i++) {\\n            char c = word[i];\\n            // If the current node does not have a child with character c,\\n            // create a new node and add it as a child of the current node\\n            if (node->children.find(c) == node->children.end()) {\\n                node->children[c] = new TrieNode();\\n            }\\n            // Move to the child node corresponding to character c\\n            node = node->children[c];\\n        }\\n        // Mark the last node as a word node\\n        node->isWord = true;\\n    }\\n\\n    bool search(string word) {\\n        return searchHelper(root, word, 0);\\n    }\\n\\n    bool searchHelper(TrieNode* node, string& word, int index) {\\n        // If we have reached the end of the word,\\n        // check if the current node is a word node\\n        if (index == word.length()) {\\n            return node->isWord;\\n        }\\n        char c = word[index];\\n        if (c == \\'.\\') {\\n            // If the current character is a dot, we need to check all children of the current node\\n            // recursively by skipping over the dot character and moving to the next character of the word\\n            for (auto& p : node->children) {\\n                if (searchHelper(p.second, word, index + 1)) {\\n                    return true;\\n                }\\n            }\\n            // If no child node matches the remaining characters of the word,\\n            // return false\\n            return false;\\n        } else {\\n            // If the current character is not a dot, move to the child node\\n            // corresponding to that character and continue recursively\\n            if (node->children.find(c) == node->children.end()) {\\n                // If there is no child node corresponding to the current character,\\n                // return false\\n                return false;\\n            }\\n            TrieNode* child = node->children[c];\\n            return searchHelper(child, word, index + 1);\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59576,
                "title": "tree-solutions-18-20-lines",
                "content": "    class WordDictionary:\\n    \\n        def __init__(self):\\n            self.root = {}\\n        \\n        def addWord(self, word):\\n            node = self.root\\n            for char in word:\\n                node = node.setdefault(char, {})\\n            node[None] = None\\n    \\n        def search(self, word):\\n            def find(word, node):\\n                if not word:\\n                    return None in node\\n                char, word = word[0], word[1:]\\n                if char != '.':\\n                    return char in node and find(word, node[char])\\n                return any(find(word, kid) for kid in node.values() if kid)\\n            return find(word, self.root)\\n\\nAn iterative alternative for the `search` method:\\n\\n        def search(self, word):\\n            nodes = [self.root]\\n            for char in word:\\n                nodes = [kid\\n                         for node in nodes\\n                         for key, kid in node.items()\\n                         if char in (key, '.') and kid]\\n            return any(None in node for node in nodes)\\n\\nAnd one that's a bit longer but faster:\\n\\n        def search(self, word):\\n            nodes = [self.root]\\n            for char in word:\\n                nodes = [kid for node in nodes for kid in\\n                         ([node[char]] if char in node else\\n                          filter(None, node.values()) if char == '.' else [])]\\n            return any(None in node for node in nodes)\\n\\nAnd a neat version where I append my end-marker to the word to simplify the final check:\\n\\n    class WordDictionary:\\n    \\n        def __init__(self):\\n            self.root = {}\\n        \\n        def addWord(self, word):\\n            node = self.root\\n            for char in word:\\n                node = node.setdefault(char, {})\\n            node['$'] = None\\n    \\n        def search(self, word):\\n            nodes = [self.root]\\n            for char in word + '$':\\n                nodes = [kid for node in nodes for kid in\\n                         ([node[char]] if char in node else\\n                          filter(None, node.values()) if char == '.' else [])]\\n            return bool(nodes)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class WordDictionary:\\n    \\n        def __init__(self):\\n            self.root = {}\\n        \\n        def addWord(self, word):\\n            node = self.root\\n            for char in word:\\n                node = node.setdefault(char, {})\\n            node[None] = None\\n    \\n        def search(self, word):\\n            def find(word, node):\\n                if not word:\\n                    return None in node\\n                char, word = word[0], word[1:]\\n                if char != '.':\\n                    return char in node and find(word, node[char])\\n                return any(find(word, kid) for kid in node.values() if kid)\\n            return find(word, self.root)\\n\\nAn iterative alternative for the `search` method:\\n\\n        def search(self, word):\\n            nodes = [self.root]\\n            for char in word:\\n                nodes = [kid\\n                         for node in nodes\\n                         for key, kid in node.items()\\n                         if char in (key, '.') and kid]\\n            return any(None in node for node in nodes)\\n\\nAnd one that's a bit longer but faster:\\n\\n        def search(self, word):\\n            nodes = [self.root]\\n            for char in word:\\n                nodes = [kid for node in nodes for kid in\\n                         ([node[char]] if char in node else\\n                          filter(None, node.values()) if char == '.' else [])]\\n            return any(None in node for node in nodes)\\n\\nAnd a neat version where I append my end-marker to the word to simplify the final check:\\n\\n    class WordDictionary:\\n    \\n        def __init__(self):\\n            self.root = {}\\n        \\n        def addWord(self, word):\\n            node = self.root\\n            for char in word:\\n                node = node.setdefault(char, {})\\n            node['$'] = None\\n    \\n        def search(self, word):\\n            nodes = [self.root]\\n            for char in word + '$':\\n                nodes = [kid for node in nodes for kid in\\n                         ([node[char]] if char in node else\\n                          filter(None, node.values()) if char == '.' else [])]\\n            return bool(nodes)",
                "codeTag": "Java"
            },
            {
                "id": 1725030,
                "title": "c-easy-explanation-beat-100-solution",
                "content": "\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB Friend\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that motivates me to create a better post like this \\u270D\\uFE0F\\n![image](https://assets.leetcode.com/users/images/2e9bb660-8a4b-467c-9abe-fa960504c1c1_1643331756.5386825.png)\\n\\n____________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________\\n\\n#### \\u2714\\uFE0F **Question Conclusion**\\nDesign a data structure that supports adding new words and finding if a string matches any previously added string.\\nImplement the WordDictionary class:\\n1. WordDictionary() Initializes the object.\\n2. void addWord(word) Adds word to the data structure, it can be matched later.\\n3. bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots \\'.\\' where dots can be matched with any letter.\\n\\n#### \\u2714\\uFE0F **Solution - I (Optimal Approach)**\\n##### **Intuition :-**\\n* Here we are using unordered_map to store index as the size of word and vector of string to store words of same sizes.\\n* To insert a word we just need to push the word at  `words[word.size()].push_back(word)`.\\n* For search operation we just need to search at `words[word.size()]`.\\n* As we have a wild operator. which can be equal to any alphabet thus we need to create a function `bool isEqual(string word1, string word2)` so that it can ignore the particular character while comparing with other characters Eg:- \"a . c\" == \"a b c\\' or vice versa \"a b c\" == \"a . c\".\\n##### **Code :-**\\n```\\nclass WordDictionary\\n{\\n     unordered_map<int, vector<string>> words;\\n\\n     bool isEqual(string word1, string word2)\\n     {\\n          for (int i = 0; i < word1.size(); i++)\\n          {\\n               if (word2[i] == \\'.\\')\\n                    continue;\\n               if (word1[i] != word2[i])\\n                    return false;\\n          }\\n          return true;\\n     }\\n\\npublic:\\n     WordDictionary() {}\\n\\n     void addWord(string word)\\n     {\\n          words[word.size()].push_back(word);\\n     }\\n\\n     bool search(string word)\\n     {\\n          for (auto &&s : words[word.size()])\\n               if (isEqual(s, word))\\n                    return true;\\n          return false;\\n     }\\n};\\n```\\n**Time Complexity** : `O(N * word.size())`, all words can be of the same size thus will need a traversal of vector once. \\n**Space Complexity** : `O(N)`, N number of words are stored.\\n_____________________________________________________________________________________________________________\\n_____________________________________________________________________________________________________________\\n\\n\\uD83D\\uDCBBIf there are any suggestions/questions in my post, comment your approach below \\uD83D\\uDC47",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass WordDictionary\\n{\\n     unordered_map<int, vector<string>> words;\\n\\n     bool isEqual(string word1, string word2)\\n     {\\n          for (int i = 0; i < word1.size(); i++)\\n          {\\n               if (word2[i] == \\'.\\')\\n                    continue;\\n               if (word1[i] != word2[i])\\n                    return false;\\n          }\\n          return true;\\n     }\\n\\npublic:\\n     WordDictionary() {}\\n\\n     void addWord(string word)\\n     {\\n          words[word.size()].push_back(word);\\n     }\\n\\n     bool search(string word)\\n     {\\n          for (auto &&s : words[word.size()])\\n               if (isEqual(s, word))\\n                    return true;\\n          return false;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313633,
                "title": "python-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am Giving away my premium content videos related to computer science and data science and also will be sharing well-structured assignments and study materials to clear interviews at top companies to my first 1000 Subscribers. So, **DON\\'T FORGET** to Subscribe\\n\\nhttps://www.youtube.com/@techwired8/?sub_confirmation=1\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n        \\nclass WordDictionary:\\n    def __init__(self):\\n        self.root = TrieNode()      \\n\\n    def addWord(self, word):\\n        current_node = self.root\\n        for character in word:\\n            current_node = current_node.children.setdefault(character, TrieNode())\\n        current_node.is_word = True\\n        \\n    def search(self, word):\\n        def dfs(node, index):\\n            if index == len(word):\\n                return node.is_word\\n               \\n            if word[index] == \".\":\\n                for child in node.children.values():\\n                    if dfs(child, index+1):\\n                        return True\\n                    \\n            if word[index] in node.children:\\n                return dfs(node.children[word[index]], index+1)\\n            \\n            return False\\n    \\n        return dfs(self.root, 0)\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n        \\nclass WordDictionary:\\n    def __init__(self):\\n        self.root = TrieNode()      \\n\\n    def addWord(self, word):\\n        current_node = self.root\\n        for character in word:\\n            current_node = current_node.children.setdefault(character, TrieNode())\\n        current_node.is_word = True\\n        \\n    def search(self, word):\\n        def dfs(node, index):\\n            if index == len(word):\\n                return node.is_word\\n               \\n            if word[index] == \".\":\\n                for child in node.children.values():\\n                    if dfs(child, index+1):\\n                        return True\\n                    \\n            if word[index] in node.children:\\n                return dfs(node.children[word[index]], index+1)\\n            \\n            return False\\n    \\n        return dfs(self.root, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622355,
                "title": "do-you-have-tle-add-this-one-thing-to-your-code",
                "content": "Hello!\\n\\nIf you get TLE, then consider storing length of the current longest word.\\nIn search method you can return False if word is longer than current longest word.\\n\\nExample of modified code from NeetCode:\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}  # a : TrieNode\\n        self.word = False\\n\\n\\nclass WordDictionary:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.max_word_length = 0\\n\\n    def addWord(self, word: str) -> None:\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.word = True\\n        \\n        self.max_word_length = max(self.max_word_length, len(word))\\n\\n    def search(self, word: str) -> bool:\\n        if len(word) > self.max_word_length:\\n            return False\\n        \\n        def dfs(j, root):\\n            cur = root\\n\\n            for i in range(j, len(word)):\\n                c = word[i]\\n                if c == \".\":\\n                    for child in cur.children.values():\\n                        if dfs(i + 1, child):\\n                            return True\\n                    return False\\n                else:\\n                    if c not in cur.children:\\n                        return False\\n                    cur = cur.children[c]\\n            return cur.word\\n\\n        return dfs(0, self.root)\\n```\\nPlease upvote if it helped you :))",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}  # a : TrieNode\\n        self.word = False\\n\\n\\nclass WordDictionary:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.max_word_length = 0\\n\\n    def addWord(self, word: str) -> None:\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.word = True\\n        \\n        self.max_word_length = max(self.max_word_length, len(word))\\n\\n    def search(self, word: str) -> bool:\\n        if len(word) > self.max_word_length:\\n            return False\\n        \\n        def dfs(j, root):\\n            cur = root\\n\\n            for i in range(j, len(word)):\\n                c = word[i]\\n                if c == \".\":\\n                    for child in cur.children.values():\\n                        if dfs(i + 1, child):\\n                            return True\\n                    return False\\n                else:\\n                    if c not in cur.children:\\n                        return False\\n                    cur = cur.children[c]\\n            return cur.word\\n\\n        return dfs(0, self.root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59669,
                "title": "java-solution-easy-understand",
                "content": "    public class WordDictionary {\\n        \\n        Map<Integer, List<String>> map = new HashMap<Integer, List<String>>();\\n        // Adds a word into the data structure.\\n        public void addWord(String word) {\\n            int index = word.length();\\n            if(!map.containsKey(index)){\\n                List<String> list = new ArrayList<String>();\\n                list.add(word);\\n                map.put(index, list);\\n            }else{\\n                map.get(index).add(word);\\n            }\\n            \\n        }\\n    \\n        // Returns if the word is in the data structure. A word could\\n        // contain the dot character '.' to represent any one letter.\\n        public boolean search(String word) {\\n            int index = word.length();\\n            if(!map.containsKey(index)){\\n                return false;\\n            }\\n            List<String> list = map.get(index);\\n            if(isWords(word)){\\n                return list.contains(word);\\n            }\\n            for(String s : list){\\n                if(isSame(s, word)){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        boolean isWords(String s){\\n            for(int i = 0; i < s.length(); i++){\\n                if(!Character.isLetter(s.charAt(i))){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        \\n        boolean isSame(String a, String search){\\n            if(a.length() != search.length()){\\n                return false;\\n            }\\n            for(int i = 0; i < a.length(); i++){\\n                if(search.charAt(i) != '.' && search.charAt(i) != a.charAt(i)){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public class WordDictionary {\\n        \\n        Map<Integer, List<String>> map = new HashMap<Integer, List<String>>();\\n        // Adds a word into the data structure.\\n        public void addWord(String word) {\\n            int index = word.length();\\n            if(!map.containsKey(index)){\\n                List<String> list = new ArrayList<String>();\\n                list.add(word);\\n                map.put(index, list);\\n            }else{\\n                map.get(index).add(word);\\n            }\\n            \\n        }\\n    \\n        // Returns if the word is in the data structure. A word could\\n        // contain the dot character '.' to represent any one letter.\\n        public boolean search(String word) {\\n            int index = word.length();\\n            if(!map.containsKey(index)){\\n                return false;\\n            }\\n            List<String> list = map.get(index);\\n            if(isWords(word)){\\n                return list.contains(word);\\n            }\\n            for(String s : list){\\n                if(isSame(s, word)){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        boolean isWords(String s){\\n            for(int i = 0; i < s.length(); i++){\\n                if(!Character.isLetter(s.charAt(i))){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        \\n        boolean isSame(String a, String search){\\n            if(a.length() != search.length()){\\n                return false;\\n            }\\n            for(int i = 0; i < a.length(); i++){\\n                if(search.charAt(i) != '.' && search.charAt(i) != a.charAt(i)){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 59733,
                "title": "using-regular-expressions-ac-315-ms",
                "content": "With dots representing any letter, this problem is basically *begging* for a regular expression solution :-)\\n\\n    class WordDictionary:\\n    \\n        def __init__(self):\\n            self.words = \\'#\\'\\n        \\n        def addWord(self, word):\\n            self.words += word + \\'#\\'\\n    \\n        def search(self, word):\\n            return bool(re.search(\\'#\\' + word + \\'#\\', self.words))\\n\\nAnother way (added Jan 2020):\\n```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.words = collections.defaultdict(set)\\n    \\n    def addWord(self, word):\\n        self.words[len(word)].add(word)\\n\\n    def search(self, word):\\n        return any(map(re.compile(word).match,\\n                       self.words[len(word)]))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.words = collections.defaultdict(set)\\n    \\n    def addWord(self, word):\\n        self.words[len(word)].add(word)\\n\\n    def search(self, word):\\n        return any(map(re.compile(word).match,\\n                       self.words[len(word)]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59718,
                "title": "easy-to-understand-java-solution-using-trie-and-recursion-with-explanation",
                "content": "    public class WordDictionary {\\n        private class TrieNode {\\n            private boolean isWord;\\n            private HashMap<Character, TrieNode> childList;\\n            \\n            public TrieNode() {\\n                isWord = false;\\n                childList = new HashMap<Character, TrieNode>();\\n            }\\n        }\\n        \\n        private TrieNode root = new TrieNode();\\n    \\n        // Adds a word into the data structure.\\n        public void addWord(String word) {\\n            TrieNode curr = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                if (!curr.childList.containsKey(word.charAt(i))) {\\n                    curr.childList.put(word.charAt(i), new TrieNode());\\n                }\\n                curr = curr.childList.get(word.charAt(i));\\n            }\\n            curr.isWord = true;\\n        }\\n    \\n        // Returns if the word is in the data structure. A word could\\n        // contain the dot character '.' to represent any one letter.\\n        public boolean search(String word) {\\n            return searchHelper(root, 0, word);\\n        }\\n        \\n        private boolean searchHelper(TrieNode node, int pos, String word) {\\n            //if the word has all been scanned, return\\n            if (pos == word.length()) {\\n                return node.isWord;\\n            }\\n            //reach the leaf before finishing scanning the word\\n            if (node.childList.size() == 0) {\\n                return false;\\n            }\\n            \\n            //if the character at current position is '.', \\n            //recursive check whether the remaing word is in the trie\\n            if (word.charAt(pos) == '.') {\\n                for (Character c : node.childList.keySet()) {\\n                    if (searchHelper(node.childList.get(c), pos + 1, word)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n            //if character at position 'pos' is neither equal to the node nor '.', return false\\n            if (!node.childList.containsKey(word.charAt(pos))) {\\n                return false;\\n            }\\n            \\n            //if character at current position matches the node, \\n            //recursively search the remaining word\\n            return searchHelper(node.childList.get(word.charAt(pos)), pos + 1, word);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public class WordDictionary {\\n        private class TrieNode {\\n            private boolean isWord;\\n            private HashMap<Character, TrieNode> childList;\\n            \\n            public TrieNode() {\\n                isWord = false;\\n                childList = new HashMap<Character, TrieNode>();\\n            }\\n        }\\n        \\n        private TrieNode root = new TrieNode();\\n    \\n        // Adds a word into the data structure.\\n        public void addWord(String word) {\\n            TrieNode curr = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                if (!curr.childList.containsKey(word.charAt(i))) {\\n                    curr.childList.put(word.charAt(i), new TrieNode());\\n                }\\n                curr = curr.childList.get(word.charAt(i));\\n            }\\n            curr.isWord = true;\\n        }\\n    \\n        // Returns if the word is in the data structure. A word could\\n        // contain the dot character '.' to represent any one letter.\\n        public boolean search(String word) {\\n            return searchHelper(root, 0, word);\\n        }\\n        \\n        private boolean searchHelper(TrieNode node, int pos, String word) {\\n            //if the word has all been scanned, return\\n            if (pos == word.length()) {\\n                return node.isWord;\\n            }\\n            //reach the leaf before finishing scanning the word\\n            if (node.childList.size() == 0) {\\n                return false;\\n            }\\n            \\n            //if the character at current position is '.', \\n            //recursive check whether the remaing word is in the trie\\n            if (word.charAt(pos) == '.') {\\n                for (Character c : node.childList.keySet()) {\\n                    if (searchHelper(node.childList.get(c), pos + 1, word)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n            //if character at position 'pos' is neither equal to the node nor '.', return false\\n            if (!node.childList.containsKey(word.charAt(pos))) {\\n                return false;\\n            }\\n            \\n            //if character at current position matches the node, \\n            //recursively search the remaining word\\n            return searchHelper(node.childList.get(word.charAt(pos)), pos + 1, word);\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 59549,
                "title": "python-168ms-beat-100-solution",
                "content": "    class WordDictionary(object):\\n        def __init__(self):\\n            self.word_dict = collections.defaultdict(list)\\n            \\n    \\n        def addWord(self, word):\\n            if word:\\n                self.word_dict[len(word)].append(word)\\n    \\n        def search(self, word):\\n            if not word:\\n                return False\\n            if '.' not in word:\\n                return word in self.word_dict[len(word)]\\n            for v in self.word_dict[len(word)]:\\n                # match xx.xx.x with yyyyyyy\\n                for i, ch in enumerate(word):\\n                    if ch != v[i] and ch != '.':\\n                        break\\n                else:\\n                    return True\\n            return False\\n\\nThe search function could be done in a more pythonic way, but I see that performance has suffered so I just wrote the raw logic by myself.",
                "solutionTags": [],
                "code": "    class WordDictionary(object):\\n        def __init__(self):\\n            self.word_dict = collections.defaultdict(list)\\n            \\n    \\n        def addWord(self, word):\\n            if word:\\n                self.word_dict[len(word)].append(word)\\n    \\n        def search(self, word):\\n            if not word:\\n                return False\\n            if '.' not in word:\\n                return word in self.word_dict[len(word)]\\n            for v in self.word_dict[len(word)]:\\n                # match xx.xx.x with yyyyyyy\\n                for i, ch in enumerate(word):\\n                    if ch != v[i] and ch != '.':\\n                        break\\n                else:\\n                    return True\\n            return False\\n\\nThe search function could be done in a more pythonic way, but I see that performance has suffered so I just wrote the raw logic by myself.",
                "codeTag": "Java"
            },
            {
                "id": 59720,
                "title": "python-solution-recursive-version-dfs",
                "content": "\\nclass TrieNode(object):\\n\\n    def __init__(self):\\n        self.word = False\\n        self.children = {}\\n\\nclass WordDictionary(object):\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def addWord(self, word):\\n        node = self.root\\n        for c in word:\\n            if c not in node.children:\\n                node.children[c] = TrieNode()\\n            node = node.children[c]\\n        node.word = True\\n\\n    def search(self, word):\\n        return self.searchFrom(self.root, word)\\n\\n    def searchFrom(self, node, word):\\n        for i in xrange(len(word)):\\n            c = word[i]\\n            if c == '.':\\n                for k in node.children:\\n                    if self.searchFrom(node.children[k], word[i+1:]):\\n                        return True\\n                return False\\n            elif c not in node.children:\\n                return False\\n            node = node.children[c]\\n        return node.word",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "\\nclass TrieNode(object):\\n\\n    def __init__(self):\\n        self.word = False\\n        self.children = {}\\n\\nclass WordDictionary(object):\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def addWord(self, word):\\n        node = self.root\\n        for c in word:\\n            if c not in node.children:\\n                node.children[c] = TrieNode()\\n            node = node.children[c]\\n        node.word = True\\n\\n    def search(self, word):\\n        return self.searchFrom(self.root, word)\\n\\n    def searchFrom(self, node, word):\\n        for i in xrange(len(word)):\\n            c = word[i]\\n            if c == '.':\\n                for k in node.children:\\n                    if self.searchFrom(node.children[k], word[i+1:]):\\n                        return True\\n                return False\\n            elif c not in node.children:\\n                return False\\n            node = node.children[c]\\n        return node.word",
                "codeTag": "Java"
            },
            {
                "id": 1725207,
                "title": "java-simulation-complete-explanation-brute-force-optimised-solution",
                "content": "****\\nPlease upvote if the explanation helps, as it keeps up the motivation to provide such posts.\\n**Edit : Added code simulation at the end**\\n****\\n\\nExplanation Flow : \\n* Given statements\\n* Observations\\n* Approach 1 - HashMap\\n* Approach 2 - Trie\\n* Modular Code\\n* Complete Code\\n\\n\\n**\\u2714\\uFE0F Given statements :**\\n\\n- Design a data structure that supports `adding new words` and `finding` if a string matches any previously added string.\\n- `word` in addWord consists lower-case English letters.\\n- `word` in search consist of  \\'.\\' or lower-case English letters\\n\\n**\\u2714\\uFE0FObservations :** \\n\\nThe only difficulty we will have is to handle `\\'.\\'` character.\\n\\nOne idea is to use a hashmap, where we map the `length of word -> List of word`. Following is the code for this approach :\\n\\n```\\nclass WordDictionary {\\n\\n    private HashMap<Integer, Set<String>> map;\\n\\n    public WordDictionary() {\\n        this.map = new HashMap<>();\\n    }\\n\\n    public void addWord(String word) {\\n\\t\\n        int l = word.length();\\n        if (!this.map.containsKey(l)) {\\n            this.map.put(l, new HashSet());\\n        }\\n        this.map.get(l).add(word);\\n    }\\n\\t/* get list of words that have same length and match \"word\" with every word in the list*/\\n    public boolean search(String word) {\\n        int l = word.length();\\n        if (this.map.containsKey(l)) {\\n            for (String w : this.map.get(l)) {\\n                int i = 0;\\n                while ((i < l) && (w.charAt(i) == word.charAt(i) || word.charAt(i) == \\'.\\')) {\\n                    i++;\\n                }\\n                if (i == l) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n**\\u2714\\uFE0F Complexity Analysis:**\\n* TC : `O(n * m)`, where `n` is the number of words and `m` is length of word we need to search.\\n* SC : `O(n)`\\n\\n**\\u2714\\uFE0F Optimisation :** \\n\\nAn efficient data structure to use here would be `Trie` because\\n* it provides better space optimisation as it stores common prefixes rather than complete words.\\n( unlike hashmap )\\n* Trie supports `search`, `insert` and delete operations in O(L) time where L is the length of the key.\\n \\n`Note :` The search space of Trie is much smaller than the Map based approach but still the worst case of both solutions are the same.\\n\\nI have broken down the code is modules : \\n\\n**TrieNode structure:**\\n\\n```\\nclass Node {\\n    HashMap<Character, Node> children;\\n    boolean isEnd;\\n    Node() {\\n        this.children = new HashMap<>();\\n        this.isEnd = false; // by default it is false\\n    }\\n}\\n```\\n****\\n**addWord function :** \\n\\nIf you are familier with Trie this logic is same, if not, here is a one line explanation to it : \\n\\nAt each step, we need to check, if the child node to add is already present. If yes, go one step down else add it into the trie and then go one step down.\\n[ Please refer this great article on Tries : https://leetcode.com/problems/implement-trie-prefix-tree/solution/ ]\\n\\n```\\n\\tpublic void addWord(String word) {\\n\\t\\n        Node curr = this.root;\\n        for(char ch : word.toCharArray()) {\\n            if(!curr.children.containsKey(ch))\\n                curr.children.put(ch, new Node());\\n            curr = curr.children.get(ch);\\n        }\\n        curr.isEnd = true;\\n    }\\n```\\n\\n****\\n**searchWord :**\\n\\nThere are two posibility for a character :\\n1. ch == `\\'.\\'`\\n2. `a` <= ch <= `z`\\n\\nIf `ch` is `.` then, we need to look for the word ahead, in the trie. For eg: If we are at `curr` in Trie and need to search for `.ab` then, we need to search for `ab` in all possible path of `curr` i.e. in `curr.children.keySet()`.  [ see simulation ]\\n\\nIf `ch` is a character[`a`, `z`]  then, it is a simple implementation to just check whether that `ch` exists or not.\\n\\n****\\n**Simulation:**\\nImages link ( If simulation speed is not aligned ) : https://drive.google.com/drive/folders/1INnKnTLryB4yaknIx04_WohE6XsYu2He?usp=sharing\\n\\n` `\\n![image](https://assets.leetcode.com/users/images/a5278370-e5a0-4286-919f-46ce97858d6d_1643345130.5155442.gif)\\n\\n****\\n\\n```\\npublic boolean search(String word) {\\n        return search(word, this.root, 0);\\n    }\\n    \\n    private boolean search(String word, Node curr, int index) {\\n        \\n        for(int i=index;i<word.length();i++) {\\n            char ch = word.charAt(i);\\n            if(ch == \\'.\\') {\\n                // look for the word ahead\\n                for(char c : curr.children.keySet()) {\\n                    Node trieNode = curr.children.get(c);\\n                    if(search(word, trieNode, i+1))\\n                        return true;\\n                }\\n                return false;\\n            } else {\\n                if(!curr.children.containsKey(ch))\\n                    return false;\\n                curr = curr.children.get(ch);\\n            }\\n        }\\n        return curr.isEnd;\\n    }\\n```\\n\\n****\\n\\n**\\u2714\\uFE0F Complete Code :** \\n\\n```\\nclass Node {\\n    HashMap<Character, Node> children;\\n    boolean isEnd;\\n    Node() {\\n        this.children = new HashMap<>();\\n        this.isEnd = false;\\n    }\\n}\\n\\nclass WordDictionary {\\n\\n    private Node root;\\n    \\n    public WordDictionary() {\\n        this.root = new Node();\\n    }\\n    \\n    public void addWord(String word) {\\n        Node curr = this.root;\\n        \\n        for(char ch : word.toCharArray()) {\\n            if(!curr.children.containsKey(ch))\\n                curr.children.put(ch, new Node());\\n            curr = curr.children.get(ch);\\n        }\\n        curr.isEnd = true;\\n    }\\n    \\n    public boolean search(String word) {\\n        return search(word, this.root, 0);\\n    }\\n    \\n    private boolean search(String word, Node curr, int index) {\\n        \\n        for(int i=index;i<word.length();i++) {\\n            char ch = word.charAt(i);\\n            if(ch == \\'.\\') {\\n                // look for the word ahead\\n                for(char c : curr.children.keySet()) {\\n                    Node trieNode = curr.children.get(c);\\n                    if(search(word, trieNode, i+1))\\n                        return true;\\n                }\\n                return false;\\n            } else {\\n                if(!curr.children.containsKey(ch))\\n                    return false;\\n                curr = curr.children.get(ch);\\n            }\\n        }\\n        return curr.isEnd;\\n    }\\n}\\n```\\n\\n**\\u2714\\uFE0F Complexity Analysis :** \\n* TC : `O(\\u2211 L)` + `O(26^X)`, where `L` is the length of words we are inserting in Trie, `X` is the length of word we are searching.\\n* SC : `O(\\u2211 L)`",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass WordDictionary {\\n\\n    private HashMap<Integer, Set<String>> map;\\n\\n    public WordDictionary() {\\n        this.map = new HashMap<>();\\n    }\\n\\n    public void addWord(String word) {\\n\\t\\n        int l = word.length();\\n        if (!this.map.containsKey(l)) {\\n            this.map.put(l, new HashSet());\\n        }\\n        this.map.get(l).add(word);\\n    }\\n\\t/* get list of words that have same length and match \"word\" with every word in the list*/\\n    public boolean search(String word) {\\n        int l = word.length();\\n        if (this.map.containsKey(l)) {\\n            for (String w : this.map.get(l)) {\\n                int i = 0;\\n                while ((i < l) && (w.charAt(i) == word.charAt(i) || word.charAt(i) == \\'.\\')) {\\n                    i++;\\n                }\\n                if (i == l) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Node {\\n    HashMap<Character, Node> children;\\n    boolean isEnd;\\n    Node() {\\n        this.children = new HashMap<>();\\n        this.isEnd = false; // by default it is false\\n    }\\n}\\n```\n```\\n\\tpublic void addWord(String word) {\\n\\t\\n        Node curr = this.root;\\n        for(char ch : word.toCharArray()) {\\n            if(!curr.children.containsKey(ch))\\n                curr.children.put(ch, new Node());\\n            curr = curr.children.get(ch);\\n        }\\n        curr.isEnd = true;\\n    }\\n```\n```\\npublic boolean search(String word) {\\n        return search(word, this.root, 0);\\n    }\\n    \\n    private boolean search(String word, Node curr, int index) {\\n        \\n        for(int i=index;i<word.length();i++) {\\n            char ch = word.charAt(i);\\n            if(ch == \\'.\\') {\\n                // look for the word ahead\\n                for(char c : curr.children.keySet()) {\\n                    Node trieNode = curr.children.get(c);\\n                    if(search(word, trieNode, i+1))\\n                        return true;\\n                }\\n                return false;\\n            } else {\\n                if(!curr.children.containsKey(ch))\\n                    return false;\\n                curr = curr.children.get(ch);\\n            }\\n        }\\n        return curr.isEnd;\\n    }\\n```\n```\\nclass Node {\\n    HashMap<Character, Node> children;\\n    boolean isEnd;\\n    Node() {\\n        this.children = new HashMap<>();\\n        this.isEnd = false;\\n    }\\n}\\n\\nclass WordDictionary {\\n\\n    private Node root;\\n    \\n    public WordDictionary() {\\n        this.root = new Node();\\n    }\\n    \\n    public void addWord(String word) {\\n        Node curr = this.root;\\n        \\n        for(char ch : word.toCharArray()) {\\n            if(!curr.children.containsKey(ch))\\n                curr.children.put(ch, new Node());\\n            curr = curr.children.get(ch);\\n        }\\n        curr.isEnd = true;\\n    }\\n    \\n    public boolean search(String word) {\\n        return search(word, this.root, 0);\\n    }\\n    \\n    private boolean search(String word, Node curr, int index) {\\n        \\n        for(int i=index;i<word.length();i++) {\\n            char ch = word.charAt(i);\\n            if(ch == \\'.\\') {\\n                // look for the word ahead\\n                for(char c : curr.children.keySet()) {\\n                    Node trieNode = curr.children.get(c);\\n                    if(search(word, trieNode, i+1))\\n                        return true;\\n                }\\n                return false;\\n            } else {\\n                if(!curr.children.containsKey(ch))\\n                    return false;\\n                curr = curr.children.get(ch);\\n            }\\n        }\\n        return curr.isEnd;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59687,
                "title": "trie-tree-java-solution-very-easy-to-understand",
                "content": "This solution uses Trier tree and DFS to search '.' case.\\n\\n    1, first build the standard trier tree root.\\n    2, add the word into the tree.\\n    3, basic search for normal character 'a'-'z' and DFS for the '.'\\n\\nHere is the solution, it is fast that beat 80%-90% solutions.\\n\\n    public class WordDictionary {\\n    \\n        // Adds a word into the data structure.\\n        Trier root = new Trier();\\n        public void addWord(String word) {\\n            Trier pointer = root;\\n            for(int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                if (pointer.children[c-'a'] == null) {\\n                    pointer.children[c-'a'] = new Trier();\\n                    pointer = pointer.children[c-'a'];\\n                } else {\\n                    pointer = pointer.children[c-'a'];\\n                }\\n            }\\n            pointer.flag = true;\\n        }\\n    \\n        // Returns if the word is in the data structure. A word could\\n        // contain the dot character '.' to represent any one letter.\\n        public boolean search(String word) {\\n            Trier pointer = root;\\n            return helper(word,0,pointer);\\n        }\\n        private boolean helper(String word, int start, Trier cur) {\\n            if (start == word.length()) {\\n                if (cur.flag) {\\n                    return true;\\n                } else {\\n                    return false;\\n                }\\n            }\\n            char c = word.charAt(start);\\n            if (c == '.') {\\n                for (int i = 0; i < 26; i++) {\\n                    if (cur.children[i] != null) {\\n                        if (helper(word,start+1,cur.children[i])) {\\n                            return true;\\n                        }\\n                    }\\n                }\\n            } else {\\n                if (cur.children[c-'a'] == null) {\\n                    return false;\\n                } else {\\n                    return helper(word,start+1,cur.children[c-'a']);\\n                }\\n            }\\n            return false;\\n        }\\n        class Trier {\\n            Trier[] children;\\n            char c;\\n            boolean flag;\\n            public Trier() {\\n                children = new Trier[26];\\n                flag = false;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "This solution uses Trier tree and DFS to search '.' case.\\n\\n    1, first build the standard trier tree root.\\n    2, add the word into the tree.\\n    3, basic search for normal character 'a'-'z' and DFS for the '.'\\n\\nHere is the solution, it is fast that beat 80%-90% solutions.\\n\\n    public class WordDictionary {\\n    \\n        // Adds a word into the data structure.\\n        Trier root = new Trier();\\n        public void addWord(String word) {\\n            Trier pointer = root;\\n            for(int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                if (pointer.children[c-'a'] == null) {\\n                    pointer.children[c-'a'] = new Trier();\\n                    pointer = pointer.children[c-'a'];\\n                } else {\\n                    pointer = pointer.children[c-'a'];\\n                }\\n            }\\n            pointer.flag = true;\\n        }\\n    \\n        // Returns if the word is in the data structure. A word could\\n        // contain the dot character '.' to represent any one letter.\\n        public boolean search(String word) {\\n            Trier pointer = root;\\n            return helper(word,0,pointer);\\n        }\\n        private boolean helper(String word, int start, Trier cur) {\\n            if (start == word.length()) {\\n                if (cur.flag) {\\n                    return true;\\n                } else {\\n                    return false;\\n                }\\n            }\\n            char c = word.charAt(start);\\n            if (c == '.') {\\n                for (int i = 0; i < 26; i++) {\\n                    if (cur.children[i] != null) {\\n                        if (helper(word,start+1,cur.children[i])) {\\n                            return true;\\n                        }\\n                    }\\n                }\\n            } else {\\n                if (cur.children[c-'a'] == null) {\\n                    return false;\\n                } else {\\n                    return helper(word,start+1,cur.children[c-'a']);\\n                }\\n            }\\n            return false;\\n        }\\n        class Trier {\\n            Trier[] children;\\n            char c;\\n            boolean flag;\\n            public Trier() {\\n                children = new Trier[26];\\n                flag = false;\\n            }\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3313896,
                "title": "python-3-t-m-100-99",
                "content": "[UPDATED 5/12/2023]\\n\\nSince the initial post, this problem\\'s constraints and test cases were amended such that, as two WLB comments below correctly point out, the code I posted initially TLEs now.\\n\\nI had another version (now posted below) which was initially slower than the initial post, but now is the faster code. (Well, at least it doesn\\'t TLE...)\\n\\nIs it a better solution? It is now, based on the new constraints and test cases. Was it a better solution before those changes? I don\\'t know for sure, but xyztNull\\'s excellent comment below addresses that matter.\\n```\\n```\\nInitial post, which now TLEs:\\n```\\nclass WordDictionary:\\n        def __init__(self):\\n\\n            self.words = defaultdict(list)\\n\\n\\n        def addWord(self, word: str) -> None:\\n\\n            self.words[len(word)].append(word)\\n\\n\\n        def search(self, word: str) -> bool:\\n\\n            n = len(word)\\n\\n            if \\'.\\' in word:\\n                \\n                for w in self.words[n]:\\n                    if all(word[i] in (w[i], \\'.\\') for i in range(n)):\\n                        return True\\n\\n                else: return False\\n\\n            return word in self.words[n]\\n```\\n[https://leetcode.com/problems/design-add-and-search-words-data-structure/submissions/629354737/](http://)\\n\\n\\n\\nThe initially slower code, now faster:\\n```\\nclass Node:\\n    \\n    def __init__(self):\\n        \\n        self.d = defaultdict(Node)\\n        self.EOW = False\\n        \\n\\nclass WordDictionary:\\n    \\n    def __init__(self):\\n        self.words = Node()\\n        \\n\\n    def addWord(self, word: str) -> None:\\n        \\n        cur = self.words\\n        for ch in word: cur = cur.d[ch]\\n        cur.EOW = True\\n\\n\\n    def search(self, word: str) -> bool:\\n        \\n        return self.dfs(word, self.words)   \\n\\n    \\n    def dfs(self, word: str, node: Node, i = 0) -> bool:\\n        \\n        if not node         : return False\\n        if i == len(word)   : return node.EOW\\n\\n        if word[i] == \\'.\\'   : return any(\\n                                (self.dfs(word, child, i+1)\\n                                for child in node.d.values()))\\n\\n        return self.dfs(word, node.d.get(word[i]), i+1)\\n```\\n[https://leetcode.com/problems/design-add-and-search-words-data-structure/submissions/949187192/]()",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n```\n```\\nclass WordDictionary:\\n        def __init__(self):\\n\\n            self.words = defaultdict(list)\\n\\n\\n        def addWord(self, word: str) -> None:\\n\\n            self.words[len(word)].append(word)\\n\\n\\n        def search(self, word: str) -> bool:\\n\\n            n = len(word)\\n\\n            if \\'.\\' in word:\\n                \\n                for w in self.words[n]:\\n                    if all(word[i] in (w[i], \\'.\\') for i in range(n)):\\n                        return True\\n\\n                else: return False\\n\\n            return word in self.words[n]\\n```\n```\\nclass Node:\\n    \\n    def __init__(self):\\n        \\n        self.d = defaultdict(Node)\\n        self.EOW = False\\n        \\n\\nclass WordDictionary:\\n    \\n    def __init__(self):\\n        self.words = Node()\\n        \\n\\n    def addWord(self, word: str) -> None:\\n        \\n        cur = self.words\\n        for ch in word: cur = cur.d[ch]\\n        cur.EOW = True\\n\\n\\n    def search(self, word: str) -> bool:\\n        \\n        return self.dfs(word, self.words)   \\n\\n    \\n    def dfs(self, word: str, node: Node, i = 0) -> bool:\\n        \\n        if not node         : return False\\n        if i == len(word)   : return node.EOW\\n\\n        if word[i] == \\'.\\'   : return any(\\n                                (self.dfs(word, child, i+1)\\n                                for child in node.d.values()))\\n\\n        return self.dfs(word, node.d.get(word[i]), i+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59694,
                "title": "c-using-trie-and-dfs-for-search-easy-understand-solution",
                "content": "     struct Trie {\\n         vector<Trie *> child;\\n         bool isWord;\\n         Trie() : isWord(false), child(vector<Trie *>(26, nullptr)) {}\\n     };\\n     Trie *root;\\n     WordDictionary() : root(new Trie()) {}\\n\\n    void addWord(string word) {\\n        const int size_w = word.size();\\n        Trie *cur = root;\\n        for (int i = 0; i < size_w; i++) {\\n            int index = word[i] - 'a';\\n            if (!cur->child[index]) cur->child[index] = new Trie();\\n            cur = cur->child[index];\\n        }\\n        cur->isWord = true;\\n    }\\n\\n    bool search(string word) {\\n        return search(word.c_str(), root);\\n    }\\n    bool search(const char *ch, TrieNode *cur) {\\n        if (!cur) return false;\\n        if (*ch == '\\\\0') return cur->isWord;\\n        if (*ch != '.') {\\n             return search(ch+1, cur->child[*ch - 'a']);\\n        } else {\\n            for (int i = 0; i <= 25; i++) {\\n                if (search(ch+1, cur->child[i])) return true;\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "     struct Trie {\\n         vector<Trie *> child;\\n         bool isWord;\\n         Trie() : isWord(false), child(vector<Trie *>(26, nullptr)) {}\\n     };\\n     Trie *root;\\n     WordDictionary() : root(new Trie()) {}\\n\\n    void addWord(string word) {\\n        const int size_w = word.size();\\n        Trie *cur = root;\\n        for (int i = 0; i < size_w; i++) {\\n            int index = word[i] - 'a';\\n            if (!cur->child[index]) cur->child[index] = new Trie();\\n            cur = cur->child[index];\\n        }\\n        cur->isWord = true;\\n    }\\n\\n    bool search(string word) {\\n        return search(word.c_str(), root);\\n    }\\n    bool search(const char *ch, TrieNode *cur) {\\n        if (!cur) return false;\\n        if (*ch == '\\\\0') return cur->isWord;\\n        if (*ch != '.') {\\n             return search(ch+1, cur->child[*ch - 'a']);\\n        } else {\\n            for (int i = 0; i <= 25; i++) {\\n                if (search(ch+1, cur->child[i])) return true;\\n            }\\n            return false;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 443857,
                "title": "resources-listed-commented-trie-map-simple-recursive-javascript-implementation",
                "content": "**Please do upvote, it motivates me to write more such posts\\uD83D\\uDE03**\\n\\n```\\n\\n// This class shows each and every node of trie\\n\\nclass Node{\\n    constructor(){\\n        this.keys = new Map();\\n        this.end = false;\\n    }\\n    setEnd(){this.end = true;}\\n    isEnd(){return this.end}\\n}\\n\\n// Simple initialization of the WordDictionary class\\n\\nvar WordDictionary = function() {\\n    this.root = new Node();\\n};\\n\\n// This just adds the word to the dictionary\\n\\nWordDictionary.prototype.addWord = function(word) {\\n    let node = this.root;\\n    function rec(node, word){\\n        if(word){\\n            if(!node.keys.has(word[0]))\\n                node.keys.set(word[0], new Node());\\n            return rec(node.keys.get(word[0]), word.substr(1));\\n        }\\n        else node.setEnd();\\n    }\\n    rec(node, word)\\n    return true;\\n};\\n\\n// This is the main recursive function where all of the magic is happening\\n\\nWordDictionary.prototype.search = function(word) {\\n    let node = this.root;\\n    function rec(node, word){\\n\\t\\n\\t\\t// returns false if the node doesn\\'t exist\\n        if(!node) return false;\\n\\t\\t\\n\\t\\t// if the word exist\\n        if(word){\\n\\t\\t\\n\\t\\t\\t//skipping any calculation if the word[0] is . \\n        \\n\\t\\t\\tif(word[0]===\\'.\\'){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Since we don\\'t know what should be the next node so, need to go through all of them one by one\\n                let out = false;\\n                for(let val of node.keys.keys()){\\n\\t\\t\\t\\t\\t// Any one of the nodes will return true for the upcoming character in word after .\\n\\t\\t\\t\\t\\t// So, taking an OR operation\\n                    out = out || rec(node.keys.get(val), word.substr(1));\\n                }\\n                return out;\\n            }\\n            else if(node.keys.has(word[0])){\\n\\t\\t\\t\\t// If the node has encountered a word then the simple stuff\\n                return rec(node.keys.get(word[0]), word.substr(1));\\n            }\\n\\t\\t\\t// otherwise return false when the above two are false\\n            else{ return false}\\n            \\n        }\\n\\t\\t// If the word doesn\\'t exist but it could have existed so just checking if the node is the end node and returning the result\\n        else return node.isEnd();\\n    }\\n\\t\\n    return rec(node, word);\\n};\\n\\n\\n```\\n\\n**Following are some of the resources regarding *Trie***\\n***JS based implementation of Trie*****Must checkout**\\n[https://www.youtube.com/watch?v=7XmS8McW_1U](http://)\\n\\n\\n***For more info about trie DS, you can watch the following video***\\n*Copyright(For the following video): Tushar Roy*\\n[https://www.youtube.com/watch?v=AXjmTQ8LEoI](http://)\\n\\n \\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n\\n// This class shows each and every node of trie\\n\\nclass Node{\\n    constructor(){\\n        this.keys = new Map();\\n        this.end = false;\\n    }\\n    setEnd(){this.end = true;}\\n    isEnd(){return this.end}\\n}\\n\\n// Simple initialization of the WordDictionary class\\n\\nvar WordDictionary = function() {\\n    this.root = new Node();\\n};\\n\\n// This just adds the word to the dictionary\\n\\nWordDictionary.prototype.addWord = function(word) {\\n    let node = this.root;\\n    function rec(node, word){\\n        if(word){\\n            if(!node.keys.has(word[0]))\\n                node.keys.set(word[0], new Node());\\n            return rec(node.keys.get(word[0]), word.substr(1));\\n        }\\n        else node.setEnd();\\n    }\\n    rec(node, word)\\n    return true;\\n};\\n\\n// This is the main recursive function where all of the magic is happening\\n\\nWordDictionary.prototype.search = function(word) {\\n    let node = this.root;\\n    function rec(node, word){\\n\\t\\n\\t\\t// returns false if the node doesn\\'t exist\\n        if(!node) return false;\\n\\t\\t\\n\\t\\t// if the word exist\\n        if(word){\\n\\t\\t\\n\\t\\t\\t//skipping any calculation if the word[0] is . \\n        \\n\\t\\t\\tif(word[0]===\\'.\\'){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Since we don\\'t know what should be the next node so, need to go through all of them one by one\\n                let out = false;\\n                for(let val of node.keys.keys()){\\n\\t\\t\\t\\t\\t// Any one of the nodes will return true for the upcoming character in word after .\\n\\t\\t\\t\\t\\t// So, taking an OR operation\\n                    out = out || rec(node.keys.get(val), word.substr(1));\\n                }\\n                return out;\\n            }\\n            else if(node.keys.has(word[0])){\\n\\t\\t\\t\\t// If the node has encountered a word then the simple stuff\\n                return rec(node.keys.get(word[0]), word.substr(1));\\n            }\\n\\t\\t\\t// otherwise return false when the above two are false\\n            else{ return false}\\n            \\n        }\\n\\t\\t// If the word doesn\\'t exist but it could have existed so just checking if the node is the end node and returning the result\\n        else return node.isEnd();\\n    }\\n\\t\\n    return rec(node, word);\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59633,
                "title": "my-java-trie-based-solution",
                "content": "    public class WordDictionary {\\n        WordNode root = new WordNode();\\n    \\tpublic void addWord(String word) {\\n    \\t\\tchar chars[] = word.toCharArray();\\n            addWord(chars, 0, root);\\n        }\\n    \\t\\n    \\tprivate void addWord(char[] chars, int index, WordNode parent) {\\n    \\t\\tchar c = chars[index];\\n    \\t\\tint idx = c-'a';\\n            WordNode node = parent.children[idx];\\n            if (node == null){\\n            \\tnode = new WordNode();\\n            \\tparent.children[idx]=node;\\n            }\\n            if (chars.length == index+1){\\n            \\tnode.isLeaf=true;\\n            \\treturn;\\n            }\\n            addWord(chars, ++index, node);\\n        }\\n    \\n    \\n        public boolean search(String word) {\\n        \\treturn search(word.toCharArray(), 0, root);\\t\\t\\t\\t     \\n        }\\n        \\n        private boolean search(char[] chars, int index, WordNode parent){\\n        \\tif (index == chars.length){\\n        \\t\\tif (parent.isLeaf){\\n        \\t\\t\\treturn true;\\n        \\t\\t}\\n        \\t\\treturn false;\\n        \\t}\\n        \\tWordNode[] childNodes = parent.children;\\n        \\tchar c = chars[index];\\n        \\tif (c == '.'){\\n    \\t    \\tfor (int i=0;i<childNodes.length;i++){\\n    \\t    \\t\\tWordNode n = childNodes[i];\\n    \\t    \\t\\tif (n !=null){\\n    \\t    \\t\\t\\tboolean b = search(chars, index+1, n);\\n    \\t    \\t\\t\\tif (b){\\n    \\t    \\t\\t\\t\\treturn true;\\n    \\t    \\t\\t\\t}\\n    \\t    \\t\\t}\\n    \\t    \\t}\\n    \\t    \\treturn false;\\n        \\t}\\n        \\tWordNode node = childNodes[c-'a'];\\n        \\tif (node == null){\\n        \\t\\treturn false;\\n        \\t}\\n        \\treturn search(chars, ++index, node);\\n        }\\n        \\n    \\n        \\n        private class WordNode{\\n        \\tboolean isLeaf;\\n        \\tWordNode[] children = new WordNode[26];\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public class WordDictionary {\\n        WordNode root = new WordNode();\\n    \\tpublic void addWord(String word) {\\n    \\t\\tchar chars[] = word.toCharArray();\\n            addWord(chars, 0, root);\\n        }\\n    \\t\\n    \\tprivate void addWord(char[] chars, int index, WordNode parent) {\\n    \\t\\tchar c = chars[index];\\n    \\t\\tint idx = c-'a';\\n            WordNode node = parent.children[idx];\\n            if (node == null){\\n            \\tnode = new WordNode();\\n            \\tparent.children[idx]=node;\\n            }\\n            if (chars.length == index+1){\\n            \\tnode.isLeaf=true;\\n            \\treturn;\\n            }\\n            addWord(chars, ++index, node);\\n        }\\n    \\n    \\n        public boolean search(String word) {\\n        \\treturn search(word.toCharArray(), 0, root);\\t\\t\\t\\t     \\n        }\\n        \\n        private boolean search(char[] chars, int index, WordNode parent){\\n        \\tif (index == chars.length){\\n        \\t\\tif (parent.isLeaf){\\n        \\t\\t\\treturn true;\\n        \\t\\t}\\n        \\t\\treturn false;\\n        \\t}\\n        \\tWordNode[] childNodes = parent.children;\\n        \\tchar c = chars[index];\\n        \\tif (c == '.'){\\n    \\t    \\tfor (int i=0;i<childNodes.length;i++){\\n    \\t    \\t\\tWordNode n = childNodes[i];\\n    \\t    \\t\\tif (n !=null){\\n    \\t    \\t\\t\\tboolean b = search(chars, index+1, n);\\n    \\t    \\t\\t\\tif (b){\\n    \\t    \\t\\t\\t\\treturn true;\\n    \\t    \\t\\t\\t}\\n    \\t    \\t\\t}\\n    \\t    \\t}\\n    \\t    \\treturn false;\\n        \\t}\\n        \\tWordNode node = childNodes[c-'a'];\\n        \\tif (node == null){\\n        \\t\\treturn false;\\n        \\t}\\n        \\treturn search(chars, ++index, node);\\n        }\\n        \\n    \\n        \\n        private class WordNode{\\n        \\tboolean isLeaf;\\n        \\tWordNode[] children = new WordNode[26];\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1725057,
                "title": "python3-trie-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe most efficient underlying data structure here would be the Trie. First of all, it will let us economize space by storing reusable prefixes instead of whole words. Second, the time complexity for the search will be defined by the length of the word and not by the number of words in the storage. The only downside I see here, when we search, we have to deal with `.` symbol which can signify any character and that means we have to remember all possible characters in the current level of the trie during the traversing. On every level of trie, we can have up to 26 letters, and considering the maximum word length is 500, in the case of search call with all `.` characters in the worst case, the algorithm can eat up 26^500 space in memory.\\n\\nTime: **O(N)** - for add and for search\\nSpace: **O(26^N)** - for search\\n\\nRuntime: 220 ms, faster than **93.62%** of Python3 online submissions for Design Add and Search Words Data Structure.\\nMemory Usage: 25.5 MB, less than **62.45%** of Python3 online submissions for Design Add and Search Words Data Structure.\\n\\n```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.trie = dict()\\n\\n    def addWord(self, word: str) -> None:\\n        node = self.trie\\n        for ch in word + \\'\\uD83C\\uDF3B\\':\\n            if ch not in node:\\n                node[ch] = dict()\\n\\n            node = node[ch]\\n\\n    def search(self, word: str) -> bool:\\n        nodes = [self.trie]\\n        for ch in word + \\'\\uD83C\\uDF3B\\':\\n            newNodes = []\\n            for node in nodes:\\n                if ch == \\'.\\': \\n                    newNodes += [v for v in node.values()]\\n                elif ch in node: \\n                    newNodes.append(node[ch])\\n\\n            if not newNodes:\\n                return False\\n\\n            nodes = newNodes\\n            \\n        return True\\n```\\n\\n*`\\uD83C\\uDF3B` - means end of the word*\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.trie = dict()\\n\\n    def addWord(self, word: str) -> None:\\n        node = self.trie\\n        for ch in word + \\'\\uD83C\\uDF3B\\':\\n            if ch not in node:\\n                node[ch] = dict()\\n\\n            node = node[ch]\\n\\n    def search(self, word: str) -> bool:\\n        nodes = [self.trie]\\n        for ch in word + \\'\\uD83C\\uDF3B\\':\\n            newNodes = []\\n            for node in nodes:\\n                if ch == \\'.\\': \\n                    newNodes += [v for v in node.values()]\\n                elif ch in node: \\n                    newNodes.append(node[ch])\\n\\n            if not newNodes:\\n                return False\\n\\n            nodes = newNodes\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524723,
                "title": "trie-explained-line-by-line-c",
                "content": "I tried to explain everything that goes through my mind while I\\'m solving this problem, please if that helped you, upvote my discuss, if not, please tell me what I should improve.\\n\\nEdit: Sometimes it can give TLE, if that happen, try to submit again.\\n```\\n// First we need to create our TrieNode class\\nclass TrieNode\\n{\\npublic:\\n    bool is_leaf;\\n\\t // as we only need to store lower case english letters, we only need an array with 26 size\\n\\t // it\\'s a good trick to use when we need to store only letters, because we can do it with O(1) in space for each node\\n\\t // so, we have a linked list, where which node will store only a character.\\n    TrieNode* children[26];\\n    TrieNode()\\n    {\\n        is_leaf = false; // it\\'ll be used to define if you get the word or not\\n\\t\\t// because if you get is_leaf = true, it means that you got all the word\\n\\t\\t\\n\\t\\t// all children will be initialize being 0\\n\\t\\t// it\\'s the same as use a loop, like: for (int i = 0; i < 26; i++) children[i] = 0;\\n        memset(children, 0, sizeof(children)); \\n    }\\n};\\n\\nclass WordDictionary\\n{\\npublic:\\n    /** Initialize your data structure here. */\\n    WordDictionary()\\n    {\\n        root = new TrieNode();\\n    }\\n\\n    /** Adds a word into the data structure. */\\n    void addWord(string word)\\n    {\\n        TrieNode *node = root;\\n        for (char c : word)\\n        {\\n\\t\\t\\t// if we already have put a specific letter in a specific level, we don\\'t need to create another node\\n\\t\\t\\t// for example, in \\'dog\\' and \\'dag\\', as we have \\'d\\' in the same position, \\n\\t\\t\\t// we can use the same node which store \\'d\\' to be the parent of \\'o\\' and \\'a\\'\\n            if (!node->children[c - \\'a\\'])\\n                node->children[c - \\'a\\'] = new TrieNode();\\n            node = node->children[c - \\'a\\'];\\n        }\\n\\t\\t// as we achieved the last node, this will be our leaf node\\n        node->is_leaf = true;\\n    }\\n\\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word)\\n    {\\n\\t\\t// we want a search function which has other parameters, so we\\'ll create a private search function\\n        return search(word, root, 0);\\n    }\\n\\nprivate:\\n    TrieNode *root; // our private root\\n\\n    bool search(string word, TrieNode *node, int pos)\\n    {\\n\\t\\t// in our recursion, first we need to code our stop condition\\n        if(pos == word.size())\\n            return node->is_leaf;\\n       \\n\\t   // if there\\'s no \\'.\\', we can just iterate in our linked list\\n        if (word[pos] != \\'.\\'){\\n            node = node->children[word[pos] - \\'a\\'];\\n\\t\\t\\t// this \\'node\\' before the search is to avoid unnecessary recursion calls (if node is null, the linked list was ended up)\\n\\t\\t\\t// we increment our \\'pos\\' by 1, in order to search the next character, if it exists\\n            return node && search(word, node, pos + 1);\\n        }\\n        \\n\\t\\t// if there\\'s a \\'.\\', we need to force iteration in all possible cases\\n        for (int i = 0; i < 26; i++)\\n\\t\\t\\t// \\'node->children[i]\\' is here to avoid unnecessary recursion calls (if this node->children[i] is null, the linked list was ended up)\\n            if(node->children[i] && search(word, node->children[i], pos + 1))\\n                return true;\\n        return false;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\n// First we need to create our TrieNode class\\nclass TrieNode\\n{\\npublic:\\n    bool is_leaf;\\n\\t // as we only need to store lower case english letters, we only need an array with 26 size\\n\\t // it\\'s a good trick to use when we need to store only letters, because we can do it with O(1) in space for each node\\n\\t // so, we have a linked list, where which node will store only a character.\\n    TrieNode* children[26];\\n    TrieNode()\\n    {\\n        is_leaf = false; // it\\'ll be used to define if you get the word or not\\n\\t\\t// because if you get is_leaf = true, it means that you got all the word\\n\\t\\t\\n\\t\\t// all children will be initialize being 0\\n\\t\\t// it\\'s the same as use a loop, like: for (int i = 0; i < 26; i++) children[i] = 0;\\n        memset(children, 0, sizeof(children)); \\n    }\\n};\\n\\nclass WordDictionary\\n{\\npublic:\\n    /** Initialize your data structure here. */\\n    WordDictionary()\\n    {\\n        root = new TrieNode();\\n    }\\n\\n    /** Adds a word into the data structure. */\\n    void addWord(string word)\\n    {\\n        TrieNode *node = root;\\n        for (char c : word)\\n        {\\n\\t\\t\\t// if we already have put a specific letter in a specific level, we don\\'t need to create another node\\n\\t\\t\\t// for example, in \\'dog\\' and \\'dag\\', as we have \\'d\\' in the same position, \\n\\t\\t\\t// we can use the same node which store \\'d\\' to be the parent of \\'o\\' and \\'a\\'\\n            if (!node->children[c - \\'a\\'])\\n                node->children[c - \\'a\\'] = new TrieNode();\\n            node = node->children[c - \\'a\\'];\\n        }\\n\\t\\t// as we achieved the last node, this will be our leaf node\\n        node->is_leaf = true;\\n    }\\n\\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word)\\n    {\\n\\t\\t// we want a search function which has other parameters, so we\\'ll create a private search function\\n        return search(word, root, 0);\\n    }\\n\\nprivate:\\n    TrieNode *root; // our private root\\n\\n    bool search(string word, TrieNode *node, int pos)\\n    {\\n\\t\\t// in our recursion, first we need to code our stop condition\\n        if(pos == word.size())\\n            return node->is_leaf;\\n       \\n\\t   // if there\\'s no \\'.\\', we can just iterate in our linked list\\n        if (word[pos] != \\'.\\'){\\n            node = node->children[word[pos] - \\'a\\'];\\n\\t\\t\\t// this \\'node\\' before the search is to avoid unnecessary recursion calls (if node is null, the linked list was ended up)\\n\\t\\t\\t// we increment our \\'pos\\' by 1, in order to search the next character, if it exists\\n            return node && search(word, node, pos + 1);\\n        }\\n        \\n\\t\\t// if there\\'s a \\'.\\', we need to force iteration in all possible cases\\n        for (int i = 0; i < 26; i++)\\n\\t\\t\\t// \\'node->children[i]\\' is here to avoid unnecessary recursion calls (if this node->children[i] is null, the linked list was ended up)\\n            if(node->children[i] && search(word, node->children[i], pos + 1))\\n                return true;\\n        return false;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59701,
                "title": "python-solution-hashtable-196ms",
                "content": "Use dictionary `self.len2words`, key is length, value is word.\\n\\n    class WordDictionary(object):\\n        def __init__(self):\\n            self.len2words = collections.defaultdict(list) \\n    \\n        def addWord(self, word):\\n            self.len2words[len(word)].append(word)\\n    \\n        def search(self, word):\\n            words = self.len2words[len(word)]\\n            for i, char in enumerate(word):\\n                words = [w for w in words if char in ('.', w[i])]\\n                if not words: return False\\n            return True",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "Use dictionary `self.len2words`, key is length, value is word.\\n\\n    class WordDictionary(object):\\n        def __init__(self):\\n            self.len2words = collections.defaultdict(list) \\n    \\n        def addWord(self, word):\\n            self.len2words[len(word)].append(word)\\n    \\n        def search(self, word):\\n            words = self.len2words[len(word)]\\n            for i, char in enumerate(word):\\n                words = [w for w in words if char in ('.', w[i])]\\n                if not words: return False\\n            return True",
                "codeTag": "Java"
            },
            {
                "id": 3314739,
                "title": "c-vector-very-easy-to-understand",
                "content": "# *Pls upvote if you like my solution!*\\n\\n# Approach\\nJust adding all the elements(string) in a vector and when search() is called traversing every element of vector from start and check whether the given string is equal to the string in the vector.\\n\\n- **void addWord(string word)**:- Push the string in the vector.\\n- **bool search(string word)**:- Traverse through the whole string and check whether **v[i]==word** (for this first check if there size is equal then proceed for checking each and every element just the catch is that if **\\'.\\'** occcurs then consider the **ith element** as equal). \\nif **count==word.size()** return true else check for next element in the vector. At last return false if any of the above condition doesn\\'t matches.\\n\\n# Code\\n```\\nclass WordDictionary {\\npublic:\\n    vector<string> v;\\n    WordDictionary() {\\n        \\n    }\\n    \\n    void addWord(string word) {\\n        v.push_back(word);\\n    }\\n    \\n    bool search(string word) {\\n        int count=0;\\n        int n=word.size();\\n        for(int i=0; i<v.size(); i++){\\n            if(n==v[i].size()){\\n                for(int j=0; j<n; j++){\\n                    if(v[i][j]==word[j]||word[j]==\\'.\\'){\\n                        count++;\\n                    }\\n                    else{\\n                        count=0;\\n                        break;\\n                    }\\n                }\\n                if(count==n) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Design"
                ],
                "code": "# *Pls upvote if you like my solution!*\\n\\n# Approach\\nJust adding all the elements(string) in a vector and when search() is called traversing every element of vector from start and check whether the given string is equal to the string in the vector.\\n\\n- **void addWord(string word)**:- Push the string in the vector.\\n- **bool search(string word)**:- Traverse through the whole string and check whether **v[i]==word** (for this first check if there size is equal then proceed for checking each and every element just the catch is that if **\\'.\\'** occcurs then consider the **ith element** as equal). \\nif **count==word.size()** return true else check for next element in the vector. At last return false if any of the above condition doesn\\'t matches.\\n\\n# Code\\n```\\nclass WordDictionary {\\npublic:\\n    vector<string> v;\\n    WordDictionary() {\\n        \\n    }\\n    \\n    void addWord(string word) {\\n        v.push_back(word);\\n    }\\n    \\n    bool search(string word) {\\n        int count=0;\\n        int n=word.size();\\n        for(int i=0; i<v.size(); i++){\\n            if(n==v[i].size()){\\n                for(int j=0; j<n; j++){\\n                    if(v[i][j]==word[j]||word[j]==\\'.\\'){\\n                        count++;\\n                    }\\n                    else{\\n                        count=0;\\n                        break;\\n                    }\\n                }\\n                if(count==n) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 499657,
                "title": "javascript-solution-trie-dfs",
                "content": "### The idea\\n1. Store words as `trie`\\n2. Traverse `trie` using dfs\\n``` javascript\\n/**\\n * Initialize your data structure here.\\n */\\nvar WordDictionary = function() {\\n    this.trie = {};\\n};\\n\\n/**\\n * Adds a word into the data structure. \\n * @param {string} word\\n * @return {void}\\n */\\nWordDictionary.prototype.addWord = function(word) {\\n    let root = this.trie;\\n    for (let i=0;i<word.length;i++) {\\n        if (root[word[i]]==null) root[word[i]] = {};\\n        root = root[word[i]];\\n    }\\n    root.isEnd = true;  \\n};\\n\\n/**\\n * Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. \\n * @param {string} word\\n * @return {boolean}\\n */\\nWordDictionary.prototype.search = function(word) {\\n    return this.dfs(word, 0, this.trie);\\n};\\n\\nWordDictionary.prototype.dfs = function(word, index, node) {\\n    if (index == word.length) return node.isEnd == true;\\n    \\n    if (word[index] == \\'.\\') {\\n        for (let key in node) {\\n            if (this.dfs(word, index + 1, node[key])) return true;\\n        }\\n        \\n    } else {\\n        if (node[word[index]]!=null) {\\n            return this.dfs(word, index + 1, node[word[index]]);\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n/** \\n * Your WordDictionary object will be instantiated and called as such:\\n * var obj = new WordDictionary()\\n * obj.addWord(word)\\n * var param_2 = obj.search(word)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * Initialize your data structure here.\\n */\\nvar WordDictionary = function() {\\n    this.trie = {};\\n};\\n\\n/**\\n * Adds a word into the data structure. \\n * @param {string} word\\n * @return {void}\\n */\\nWordDictionary.prototype.addWord = function(word) {\\n    let root = this.trie;\\n    for (let i=0;i<word.length;i++) {\\n        if (root[word[i]]==null) root[word[i]] = {};\\n        root = root[word[i]];\\n    }\\n    root.isEnd = true;  \\n};\\n\\n/**\\n * Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. \\n * @param {string} word\\n * @return {boolean}\\n */\\nWordDictionary.prototype.search = function(word) {\\n    return this.dfs(word, 0, this.trie);\\n};\\n\\nWordDictionary.prototype.dfs = function(word, index, node) {\\n    if (index == word.length) return node.isEnd == true;\\n    \\n    if (word[index] == \\'.\\') {\\n        for (let key in node) {\\n            if (this.dfs(word, index + 1, node[key])) return true;\\n        }\\n        \\n    } else {\\n        if (node[word[index]]!=null) {\\n            return this.dfs(word, index + 1, node[word[index]]);\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n/** \\n * Your WordDictionary object will be instantiated and called as such:\\n * var obj = new WordDictionary()\\n * obj.addWord(word)\\n * var param_2 = obj.search(word)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3314943,
                "title": "day-78-trie-dfs-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\n![image.png](https://assets.leetcode.com/users/images/45ddd666-115b-4cd2-acdb-35cb946e8c91_1679207569.355929.png)\\n\\n**The code implements a WordDictionary using a Trie data structure. The addWord() function inserts words into the Trie by traversing the tree level by level and creating new nodes as necessary. The search() function searches for a given word in the Trie. It calls a helper function searchHelper() which recursively traverses the Trie, checking each character of the word against the children of the current node.**\\n\\n**If the current character is a \".\", the searchHelper() function recursively searches all children nodes, and returns true if any of them contain the remaining characters of the word. Otherwise, it continues the search along the appropriate child node based on the current character of the word. If the end of the word is reached, it returns whether the current node represents a complete word or not.**\\n\\n**In essence, the algorithm allows for searching words in a dictionary that may contain \".\" (wildcards) that can match any character.**\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Define a TrieNode class with a boolean flag \\'isWordCompleted\\' and an array \\'children\\' of TrieNode pointers, each representing a child node for a given character.\\n2. Define a WordDictionary class that contains a TrieNode pointer \\'root\\' representing the root node of the trie.\\n3. Implement the constructor for the WordDictionary class that initializes the root node to a new TrieNode object.\\n4. Implement a function \\'addWord\\' that takes a string \\'word\\' as input and adds it to the trie. It starts at the root node and iterates through each character of the input word, checking if the corresponding child node exists. If the child node does not exist, a new TrieNode object is created and added as a child node. Once all the characters of the word have been added to the trie, the \\'isWordCompleted\\' flag of the final TrieNode is set to true.\\n5. Implement a function \\'searchHelper\\' that takes a string \\'word\\', an integer \\'index\\' representing the current character index in the word, and a TrieNode pointer \\'newRoot\\' representing the current node being searched. The function recursively searches through the trie, checking if the current character in the word matches any child nodes of the current node. If the character is a \\'.\\', the function recursively searches all child nodes. If the end of the word is reached, the function returns true if the \\'isWordCompleted\\' flag of the final TrieNode is true.\\n6. Implement a function \\'search\\' that takes a string \\'word\\' as input and returns a boolean representing whether or not the word is present in the trie. This function simply calls \\'searchHelper\\' with the input word, starting from the root node.\\n\\n**Overall, this algorithm represents a trie data structure that can be used to store and search for words efficiently.**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass TrieNode {\\npublic:\\n    TrieNode* children[26];\\n    bool isWordCompleted;\\n\\n    TrieNode() {\\n        memset(children, 0, sizeof(children));\\n        isWordCompleted = false;\\n    }\\n};\\n\\nclass WordDictionary {\\npublic:\\n    TrieNode* root;\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        TrieNode* newRoot = root;\\n        for (char ch : word) {\\n            int alphabetIndex = ch - \\'a\\';\\n            if (newRoot -> children[alphabetIndex] == NULL) {\\n                newRoot -> children[alphabetIndex] = new TrieNode();\\n            }\\n            newRoot = newRoot -> children[alphabetIndex];\\n        }\\n        newRoot -> isWordCompleted = true;\\n    }\\n    \\n    bool searchHelper(string word, int index, TrieNode* newRoot) {\\n        if (index == word.length())\\n            return newRoot -> isWordCompleted;\\n        char ch = word[index];\\n        if (ch == \\'.\\') {\\n            for (int i = 0; i < 26; i++) {\\n                if (newRoot -> children[i] != NULL && searchHelper(word, index + 1, newRoot -> children[i])) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else {\\n            if (newRoot -> children[ch - \\'a\\'] == NULL) {\\n                return false;\\n            }\\n            return (searchHelper(word, index + 1, newRoot -> children[ch - \\'a\\']));\\n        }\\n    }\\n\\n    bool search(string word) {\\n        return searchHelper(word, 0, root);\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```\\n```Java []\\nclass TrieNode {\\n    TrieNode[] children;\\n    boolean isWordCompleted;\\n\\n    TrieNode() {\\n        children = new TrieNode[26];\\n        isWordCompleted = false;\\n    }\\n}\\n\\nclass WordDictionary {\\n    TrieNode root;\\n\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    void addWord(String word) {\\n        TrieNode newRoot = root;\\n        for (char ch : word.toCharArray()) {\\n            int alphabetIndex = ch - \\'a\\';\\n            if (newRoot.children[alphabetIndex] == null) {\\n                newRoot.children[alphabetIndex] = new TrieNode();\\n            }\\n            newRoot = newRoot.children[alphabetIndex];\\n        }\\n        newRoot.isWordCompleted = true;\\n    }\\n    \\n    boolean searchHelper(String word, int index, TrieNode newRoot) {\\n        if (index == word.length())\\n            return newRoot.isWordCompleted;\\n        char ch = word.charAt(index);\\n        if (ch == \\'.\\') {\\n            for (int i = 0; i < 26; i++) {\\n                if (newRoot.children[i] != null && searchHelper(word, index + 1, newRoot.children[i])) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else {\\n            if (newRoot.children[ch - \\'a\\'] == null) {\\n                return false;\\n            }\\n            return searchHelper(word, index + 1, newRoot.children[ch - \\'a\\']);\\n        }\\n    }\\n\\n    boolean search(String word) {\\n        return searchHelper(word, 0, root);\\n    }\\n}\\n\\n```\\n```Python []\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = [None] * 26\\n        self.isWordCompleted = False\\n\\nclass WordDictionary:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def addWord(self, word: str) -> None:\\n        newRoot = self.root\\n        for ch in word:\\n            alphabetIndex = ord(ch) - ord(\\'a\\')\\n            if newRoot.children[alphabetIndex] is None:\\n                newRoot.children[alphabetIndex] = TrieNode()\\n            newRoot = newRoot.children[alphabetIndex]\\n        newRoot.isWordCompleted = True\\n    \\n    def searchHelper(self, word: str, index: int, newRoot: TrieNode) -> bool:\\n        if index == len(word):\\n            return newRoot.isWordCompleted\\n        ch = word[index]\\n        if ch == \\'.\\':\\n            for i in range(26):\\n                if newRoot.children[i] is not None and self.searchHelper(word, index + 1, newRoot.children[i]):\\n                    return True\\n            return False\\n        else:\\n            alphabetIndex = ord(ch) - ord(\\'a\\')\\n            if newRoot.children[alphabetIndex] is None:\\n                return False\\n            return self.searchHelper(word, index + 1, newRoot.children[alphabetIndex])\\n\\n    def search(self, word: str) -> bool:\\n        return self.searchHelper(word, 0, self.root)\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time complexity :**\\n\\nThe time complexity of the addWord function is O(k), where k is the length of the word being added. This is because we are traversing through the characters of the word and creating new nodes in the Trie for each character. Therefore, the total time complexity of adding n words of total length m is O(m*n).\\n\\nThe time complexity of the search function depends on the length of the input word and the size of the Trie. In the worst case, we have to search through all the nodes of the Trie, which is O(26^k), where k is the length of the input word. Therefore, the time complexity of the search function is O(26^k), where k is the length of the input word.\\n\\nHowever, in the best case, we can return early if the prefix of the input word does not exist in the Trie, which can reduce the time complexity significantly. Moreover, if the input word contains \\'.\\', we need to search through all possible child nodes of the current node, which is 26 in this case. Therefore, the actual time complexity of the search function can be much less than the worst-case scenario.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity :**\\n\\nThe space complexity of the Trie is O(nm), where n is the number of words and m is the average length of the words. This is because we are creating a new node for each character of each word. Therefore, the total number of nodes in the Trie is proportional to nm. However, in the worst case, when all the words have no common prefix, the space complexity can be as high as O(26^m), where m is the length of the longest word. Therefore, the space complexity of the Trie depends on the input data and can be very high in certain cases.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```C++ []\\nclass TrieNode {\\npublic:\\n    TrieNode* children[26];\\n    bool isWordCompleted;\\n\\n    TrieNode() {\\n        memset(children, 0, sizeof(children));\\n        isWordCompleted = false;\\n    }\\n};\\n\\nclass WordDictionary {\\npublic:\\n    TrieNode* root;\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        TrieNode* newRoot = root;\\n        for (char ch : word) {\\n            int alphabetIndex = ch - \\'a\\';\\n            if (newRoot -> children[alphabetIndex] == NULL) {\\n                newRoot -> children[alphabetIndex] = new TrieNode();\\n            }\\n            newRoot = newRoot -> children[alphabetIndex];\\n        }\\n        newRoot -> isWordCompleted = true;\\n    }\\n    \\n    bool searchHelper(string word, int index, TrieNode* newRoot) {\\n        if (index == word.length())\\n            return newRoot -> isWordCompleted;\\n        char ch = word[index];\\n        if (ch == \\'.\\') {\\n            for (int i = 0; i < 26; i++) {\\n                if (newRoot -> children[i] != NULL && searchHelper(word, index + 1, newRoot -> children[i])) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else {\\n            if (newRoot -> children[ch - \\'a\\'] == NULL) {\\n                return false;\\n            }\\n            return (searchHelper(word, index + 1, newRoot -> children[ch - \\'a\\']));\\n        }\\n    }\\n\\n    bool search(string word) {\\n        return searchHelper(word, 0, root);\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```\n```Java []\\nclass TrieNode {\\n    TrieNode[] children;\\n    boolean isWordCompleted;\\n\\n    TrieNode() {\\n        children = new TrieNode[26];\\n        isWordCompleted = false;\\n    }\\n}\\n\\nclass WordDictionary {\\n    TrieNode root;\\n\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    void addWord(String word) {\\n        TrieNode newRoot = root;\\n        for (char ch : word.toCharArray()) {\\n            int alphabetIndex = ch - \\'a\\';\\n            if (newRoot.children[alphabetIndex] == null) {\\n                newRoot.children[alphabetIndex] = new TrieNode();\\n            }\\n            newRoot = newRoot.children[alphabetIndex];\\n        }\\n        newRoot.isWordCompleted = true;\\n    }\\n    \\n    boolean searchHelper(String word, int index, TrieNode newRoot) {\\n        if (index == word.length())\\n            return newRoot.isWordCompleted;\\n        char ch = word.charAt(index);\\n        if (ch == \\'.\\') {\\n            for (int i = 0; i < 26; i++) {\\n                if (newRoot.children[i] != null && searchHelper(word, index + 1, newRoot.children[i])) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else {\\n            if (newRoot.children[ch - \\'a\\'] == null) {\\n                return false;\\n            }\\n            return searchHelper(word, index + 1, newRoot.children[ch - \\'a\\']);\\n        }\\n    }\\n\\n    boolean search(String word) {\\n        return searchHelper(word, 0, root);\\n    }\\n}\\n\\n```\n```Python []\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = [None] * 26\\n        self.isWordCompleted = False\\n\\nclass WordDictionary:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def addWord(self, word: str) -> None:\\n        newRoot = self.root\\n        for ch in word:\\n            alphabetIndex = ord(ch) - ord(\\'a\\')\\n            if newRoot.children[alphabetIndex] is None:\\n                newRoot.children[alphabetIndex] = TrieNode()\\n            newRoot = newRoot.children[alphabetIndex]\\n        newRoot.isWordCompleted = True\\n    \\n    def searchHelper(self, word: str, index: int, newRoot: TrieNode) -> bool:\\n        if index == len(word):\\n            return newRoot.isWordCompleted\\n        ch = word[index]\\n        if ch == \\'.\\':\\n            for i in range(26):\\n                if newRoot.children[i] is not None and self.searchHelper(word, index + 1, newRoot.children[i]):\\n                    return True\\n            return False\\n        else:\\n            alphabetIndex = ord(ch) - ord(\\'a\\')\\n            if newRoot.children[alphabetIndex] is None:\\n                return False\\n            return self.searchHelper(word, index + 1, newRoot.children[alphabetIndex])\\n\\n    def search(self, word: str) -> bool:\\n        return self.searchHelper(word, 0, self.root)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073983,
                "title": "javascript-using-trie-and-dfs-heavily-commented-clear-solution",
                "content": "```\\nfunction Node () {\\n    // children object to store children nodes\\n    this.children = {};\\n    \\n    // boolean to check if the current node represents a letter that is the ending of a word\\n    this.isWordEnding = false;\\n    \\n    // note: you might also want to store this.char here for debugging purposes or for different problems.\\n}\\n\\nvar WordDictionary = function() {\\n    // the root is a node itself.\\n    this.root = new Node();\\n};\\n\\nWordDictionary.prototype.addWord = function(word) {\\n    // we will traverse the trie starting from the root node and add nodes for each letter in word.\\n    let currentNode = this.root;\\n    \\n    for (const char of word) {\\n        // if a node exists for a given letter then don\\'t do anything.\\n        // if not create a new node for that letter.\\n        currentNode.children[char] = currentNode.children[char] || new Node();\\n        \\n        // move on to the next node.\\n        currentNode = currentNode.children[char];\\n    }\\n    \\n    // after looping, the currentNode variable will point to the node representing the last letter of word.\\n    // so we mark that node as a word ending.\\n    currentNode.isWordEnding = true;\\n};\\n\\nWordDictionary.prototype.search = function(word) {\\n    // helper function to call recursively\\n    const searchHelper = (currentNode, i) => {\\n        \\n        // if we reach the i that\\'s the length of word and currentNode is a word ending, word exists.\\n        if (i === word.length) return currentNode.isWordEnding\\n        \\n        const char = word[i]\\n        \\n        // if char is a dot, that means we can match it with any letter.\\n        // to do that programmatically, we go through all of the children of the current node. why?\\n        // we don\\'t know which, if any, of the children can use the dot to make the given string.\\n        // so we go through all of them and check if any of them can return true.\\n        if (char === \\'.\\') {\\n            for (const char of Object.keys(currentNode.children)) {\\n                const child = currentNode.children[char];\\n                if (searchHelper(child, i + 1)) return true\\n            }\\n            \\n            // if no child can make use of the dot to come up with the given word,\\n            // then even the alternative version (e.g \\'pad\\') \\n            // of the given string (e.g \\'pa.\\') doesn\\'t exist in our dictionary.\\n            return false\\n        } \\n        \\n        // if char isn\\'t a dot, it\\'s more straightforward...\\n        else {\\n            // looking for a letter that should come after another and can\\'t find it?\\n            // that means the word doesn\\'t exist in our dictionary so return false.\\n            if (!(char in currentNode.children)) return false\\n            \\n            // go on to the next node in our dictionary and the next letter in the word\\n            return searchHelper(currentNode.children[char], i + 1)\\n        }\\n    }\\n    \\n    // we call this function by starting at our root node with the index for the first letter in the string\\n    return searchHelper(this.root, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nfunction Node () {\\n    // children object to store children nodes\\n    this.children = {};\\n    \\n    // boolean to check if the current node represents a letter that is the ending of a word\\n    this.isWordEnding = false;\\n    \\n    // note: you might also want to store this.char here for debugging purposes or for different problems.\\n}\\n\\nvar WordDictionary = function() {\\n    // the root is a node itself.\\n    this.root = new Node();\\n};\\n\\nWordDictionary.prototype.addWord = function(word) {\\n    // we will traverse the trie starting from the root node and add nodes for each letter in word.\\n    let currentNode = this.root;\\n    \\n    for (const char of word) {\\n        // if a node exists for a given letter then don\\'t do anything.\\n        // if not create a new node for that letter.\\n        currentNode.children[char] = currentNode.children[char] || new Node();\\n        \\n        // move on to the next node.\\n        currentNode = currentNode.children[char];\\n    }\\n    \\n    // after looping, the currentNode variable will point to the node representing the last letter of word.\\n    // so we mark that node as a word ending.\\n    currentNode.isWordEnding = true;\\n};\\n\\nWordDictionary.prototype.search = function(word) {\\n    // helper function to call recursively\\n    const searchHelper = (currentNode, i) => {\\n        \\n        // if we reach the i that\\'s the length of word and currentNode is a word ending, word exists.\\n        if (i === word.length) return currentNode.isWordEnding\\n        \\n        const char = word[i]\\n        \\n        // if char is a dot, that means we can match it with any letter.\\n        // to do that programmatically, we go through all of the children of the current node. why?\\n        // we don\\'t know which, if any, of the children can use the dot to make the given string.\\n        // so we go through all of them and check if any of them can return true.\\n        if (char === \\'.\\') {\\n            for (const char of Object.keys(currentNode.children)) {\\n                const child = currentNode.children[char];\\n                if (searchHelper(child, i + 1)) return true\\n            }\\n            \\n            // if no child can make use of the dot to come up with the given word,\\n            // then even the alternative version (e.g \\'pad\\') \\n            // of the given string (e.g \\'pa.\\') doesn\\'t exist in our dictionary.\\n            return false\\n        } \\n        \\n        // if char isn\\'t a dot, it\\'s more straightforward...\\n        else {\\n            // looking for a letter that should come after another and can\\'t find it?\\n            // that means the word doesn\\'t exist in our dictionary so return false.\\n            if (!(char in currentNode.children)) return false\\n            \\n            // go on to the next node in our dictionary and the next letter in the word\\n            return searchHelper(currentNode.children[char], i + 1)\\n        }\\n    }\\n    \\n    // we call this function by starting at our root node with the index for the first letter in the string\\n    return searchHelper(this.root, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774214,
                "title": "c-trie-clean-easy-to-read-solution",
                "content": "```\\nclass TrieNode {\\npublic:\\n    bool isWord;\\n    unordered_map<char, TrieNode*> children;\\n    \\n    TrieNode() {\\n        isWord = false;\\n    }\\n};\\n\\nclass WordDictionary {\\n    TrieNode *root;\\n    \\n    void addWordToTrie(string word) {\\n        auto cur = root;\\n        \\n        for (auto ch : word) {\\n            if (!cur->children.count(ch))\\n                cur->children[ch] = new TrieNode();\\n            \\n            cur = cur->children[ch];\\n        }\\n        \\n        cur->isWord = true;\\n    }\\n    \\n    bool searchTrie(TrieNode* cur, int i, string word) {\\n        if (i == word.length())\\n            return cur->isWord;\\n        \\n        if (word[i] != \\'.\\') {\\n\\t\\t\\t// normal letter\\n            if (!cur->children.count(word[i]))\\n                return false;\\n\\n            return searchTrie(cur->children[word[i]], i + 1, word);   \\n        }\\n        \\n\\t\\t// \\'.\\' encountered. Perform DFS in all children branches\\n        for (auto it : cur->children) {\\n            if (searchTrie(it.second, i + 1, word))\\n                return true;               \\n        }\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        addWordToTrie(word);\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word) {\\n        return searchTrie(root, 0, word);\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\npublic:\\n    bool isWord;\\n    unordered_map<char, TrieNode*> children;\\n    \\n    TrieNode() {\\n        isWord = false;\\n    }\\n};\\n\\nclass WordDictionary {\\n    TrieNode *root;\\n    \\n    void addWordToTrie(string word) {\\n        auto cur = root;\\n        \\n        for (auto ch : word) {\\n            if (!cur->children.count(ch))\\n                cur->children[ch] = new TrieNode();\\n            \\n            cur = cur->children[ch];\\n        }\\n        \\n        cur->isWord = true;\\n    }\\n    \\n    bool searchTrie(TrieNode* cur, int i, string word) {\\n        if (i == word.length())\\n            return cur->isWord;\\n        \\n        if (word[i] != \\'.\\') {\\n\\t\\t\\t// normal letter\\n            if (!cur->children.count(word[i]))\\n                return false;\\n\\n            return searchTrie(cur->children[word[i]], i + 1, word);   \\n        }\\n        \\n\\t\\t// \\'.\\' encountered. Perform DFS in all children branches\\n        for (auto it : cur->children) {\\n            if (searchTrie(it.second, i + 1, word))\\n                return true;               \\n        }\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        addWordToTrie(word);\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word) {\\n        return searchTrie(root, 0, word);\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 59550,
                "title": "share-my-javascript-solution",
                "content": "```\\nvar TrieNode = function() {\\n    this.children = {};\\n    this.isEnd = false;\\n};\\n\\n/**\\n * Initialize your data structure here.\\n */\\nvar WordDictionary = function() {\\n    this.root = new TrieNode();\\n};\\n\\n/**\\n * Adds a word into the data structure. \\n * @param {string} word\\n * @return {void}\\n */\\nWordDictionary.prototype.addWord = function(word) {\\n    var current = this.root;\\n    \\n    for (let i = 0; i < word.length; i++) {\\n        if (!(word[i] in current.children)) {\\n            current.children[word[i]] = new TrieNode();\\n        }\\n        current = current.children[word[i]];\\n    }\\n    \\n    current.isEnd = true;\\n};\\n\\n/**\\n * Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. \\n * @param {string} word\\n * @return {boolean}\\n */\\nWordDictionary.prototype.search = function(word) {\\n    var search = function(current, level) {\\n        // Cannot search for the word\\n        if (!current || (level === word.length && !current.isEnd)) {\\n            return false;\\n        }\\n        \\n        if (level === word.length && current.isEnd) {\\n            return true;\\n        }\\n        \\n        if (word[level] === '.') {\\n            for (let i = 0; i < 26; i++) {\\n                var ch = String.fromCharCode(97 + i);\\n                \\n                if (search(current.children[ch], level + 1)) {\\n                    return true;\\n                }\\n            }\\n            \\n            return false;\\n        }\\n        \\n        return search(current.children[word[level]], level + 1);\\n    };\\n    \\n    return search(this.root, 0);\\n};\\n\\n/** \\n * Your WordDictionary object will be instantiated and called as such:\\n * var obj = Object.create(WordDictionary).createNew()\\n * obj.addWord(word)\\n * var param_2 = obj.search(word)\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nvar TrieNode = function() {\\n    this.children = {};\\n    this.isEnd = false;\\n};\\n\\n/**\\n * Initialize your data structure here.\\n */\\nvar WordDictionary = function() {\\n    this.root = new TrieNode();\\n};\\n\\n/**\\n * Adds a word into the data structure. \\n * @param {string} word\\n * @return {void}\\n */\\nWordDictionary.prototype.addWord = function(word) {\\n    var current = this.root;\\n    \\n    for (let i = 0; i < word.length; i++) {\\n        if (!(word[i] in current.children)) {\\n            current.children[word[i]] = new TrieNode();\\n        }\\n        current = current.children[word[i]];\\n    }\\n    \\n    current.isEnd = true;\\n};\\n\\n/**\\n * Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. \\n * @param {string} word\\n * @return {boolean}\\n */\\nWordDictionary.prototype.search = function(word) {\\n    var search = function(current, level) {\\n        // Cannot search for the word\\n        if (!current || (level === word.length && !current.isEnd)) {\\n            return false;\\n        }\\n        \\n        if (level === word.length && current.isEnd) {\\n            return true;\\n        }\\n        \\n        if (word[level] === '.') {\\n            for (let i = 0; i < 26; i++) {\\n                var ch = String.fromCharCode(97 + i);\\n                \\n                if (search(current.children[ch], level + 1)) {\\n                    return true;\\n                }\\n            }\\n            \\n            return false;\\n        }\\n        \\n        return search(current.children[word[level]], level + 1);\\n    };\\n    \\n    return search(this.root, 0);\\n};\\n\\n/** \\n * Your WordDictionary object will be instantiated and called as such:\\n * var obj = Object.create(WordDictionary).createNew()\\n * obj.addWord(word)\\n * var param_2 = obj.search(word)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3313687,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo support the search of a string with dots, we can use a trie data structure. We will traverse the trie in a depth-first manner, looking for a matching character or dot at each node. If we find a dot, we will recursively explore all child nodes. If we reach the end of the word and the last node is marked as the end of a word, we have found a match.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a trie data structure to store the words. While adding a word to the trie, we can iterate through each character in the word and add it to the trie if it is not already present. We also mark the last node of the word as an end-of-word node. For searching a word in the trie, we traverse through each character of the word and see if it matches a character in the trie. If the character is a dot (.), we recursively search for the remaining part of the word in all the child nodes of the current node. If the character is not a dot, we traverse to the corresponding child node in the trie. If we reach the end of the word and the last node is an end-of-word node, then the word is present in the trie.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity for adding a word to the trie is O(n), where n is the length of the word. The time complexity for searching a word in the trie is O(n * m), where n is the length of the word and m is the number of nodes in the trie. However, the number of nodes in the trie is bounded by the total number of characters in all the words added to the trie, which is at most 26 * n * m. Therefore, the worst-case time complexity for searching a word in the trie is O(n * m).\\n\\n\\n- Space complexity:\\nThe space complexity of the trie is O(26 * n * m), where n is the maximum length of the words and m is the number of words in the trie. This is because each node in the trie has 26 children and each character in each word is represented by a node in the trie.\\n\\n\\n\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\nclass TrieNode {\\n    boolean isEndOfWord;\\n    TrieNode[] children;\\n\\n    public TrieNode() {\\n        isEndOfWord = false;\\n        children = new TrieNode[26];\\n    }\\n}\\n\\nclass WordDictionary {\\n    private TrieNode root;\\n\\n    public WordDictionary() {\\n        root = new TrieNode();\\n    }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = root;\\n        for (char c : word.toCharArray()) {\\n            if (curr.children[c - \\'a\\'] == null) {\\n                curr.children[c - \\'a\\'] = new TrieNode();\\n            }\\n            curr = curr.children[c - \\'a\\'];\\n        }\\n        curr.isEndOfWord = true;\\n    }\\n\\n    public boolean search(String word) {\\n        return searchHelper(word, 0, root);\\n    }\\n\\n    private boolean searchHelper(String word, int index, TrieNode curr) {\\n        if (index == word.length()) {\\n            return curr.isEndOfWord;\\n        }\\n\\n        char c = word.charAt(index);\\n\\n        if (c == \\'.\\') {\\n            for (TrieNode child : curr.children) {\\n                if (child != null && searchHelper(word, index + 1, child)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        } else {\\n            TrieNode child = curr.children[c - \\'a\\'];\\n            if (child == null) {\\n                return false;\\n            }\\n            return searchHelper(word, index + 1, child);\\n        }\\n    }\\n}\\n\\n\\n```\\n```Python []\\nclass WordDictionary(object):\\n    def __init__(self):\\n        self.words = {}\\n\\n    def addWord(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: None\\n        \"\"\"\\n        curr = self.words\\n        for c in word:\\n            if c not in curr:\\n                curr[c] = {}\\n            curr = curr[c]\\n        curr[\\'$\\'] = True\\n\\n    def search(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        return self.dfs(self.words, word)\\n\\n    def dfs(self, node, word):\\n        if not word:\\n            return \\'$\\' in node\\n        c = word[0]\\n        if c == \\'.\\':\\n            for child in node:\\n                if child != \\'$\\' and self.dfs(node[child], word[1:]):\\n                    return True\\n        elif c in node:\\n            return self.dfs(node[c], word[1:])\\n        return False\\n\\n\\n```\\n```C++ []\\nclass TrieNode {\\npublic:\\n    bool isEndOfWord;\\n    TrieNode* children[26];\\n\\n    TrieNode() {\\n        isEndOfWord = false;\\n        for (int i = 0; i < 26; i++) {\\n            children[i] = nullptr;\\n        }\\n    }\\n};\\n\\nclass WordDictionary {\\nprivate:\\n    TrieNode* root;\\n\\npublic:\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n\\n    void addWord(string word) {\\n        TrieNode* curr = root;\\n        for (char c : word) {\\n            if (curr->children[c - \\'a\\'] == nullptr) {\\n                curr->children[c - \\'a\\'] = new TrieNode();\\n            }\\n            curr = curr->children[c - \\'a\\'];\\n        }\\n        curr->isEndOfWord = true;\\n    }\\n\\n    bool search(string word) {\\n        return searchHelper(word, 0, root);\\n    }\\n\\n    bool searchHelper(string word, int index, TrieNode* curr) {\\n        if (index == word.length()) {\\n            return curr->isEndOfWord;\\n        }\\n\\n        char c = word[index];\\n\\n        if (c == \\'.\\') {\\n            for (int i = 0; i < 26; i++) {\\n                if (curr->children[i] != nullptr && searchHelper(word, index + 1, curr->children[i])) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        } else {\\n            if (curr->children[c - \\'a\\'] == nullptr) {\\n                return false;\\n            }\\n            return searchHelper(word, index + 1, curr->children[c - \\'a\\']);\\n        }\\n    }\\n};\\n\\n\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Depth-First Search",
                    "Design",
                    "Trie"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass TrieNode {\\n    boolean isEndOfWord;\\n    TrieNode[] children;\\n\\n    public TrieNode() {\\n        isEndOfWord = false;\\n        children = new TrieNode[26];\\n    }\\n}\\n\\nclass WordDictionary {\\n    private TrieNode root;\\n\\n    public WordDictionary() {\\n        root = new TrieNode();\\n    }\\n\\n    public void addWord(String word) {\\n        TrieNode curr = root;\\n        for (char c : word.toCharArray()) {\\n            if (curr.children[c - \\'a\\'] == null) {\\n                curr.children[c - \\'a\\'] = new TrieNode();\\n            }\\n            curr = curr.children[c - \\'a\\'];\\n        }\\n        curr.isEndOfWord = true;\\n    }\\n\\n    public boolean search(String word) {\\n        return searchHelper(word, 0, root);\\n    }\\n\\n    private boolean searchHelper(String word, int index, TrieNode curr) {\\n        if (index == word.length()) {\\n            return curr.isEndOfWord;\\n        }\\n\\n        char c = word.charAt(index);\\n\\n        if (c == \\'.\\') {\\n            for (TrieNode child : curr.children) {\\n                if (child != null && searchHelper(word, index + 1, child)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        } else {\\n            TrieNode child = curr.children[c - \\'a\\'];\\n            if (child == null) {\\n                return false;\\n            }\\n            return searchHelper(word, index + 1, child);\\n        }\\n    }\\n}\\n\\n\\n```\n```Python []\\nclass WordDictionary(object):\\n    def __init__(self):\\n        self.words = {}\\n\\n    def addWord(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: None\\n        \"\"\"\\n        curr = self.words\\n        for c in word:\\n            if c not in curr:\\n                curr[c] = {}\\n            curr = curr[c]\\n        curr[\\'$\\'] = True\\n\\n    def search(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        return self.dfs(self.words, word)\\n\\n    def dfs(self, node, word):\\n        if not word:\\n            return \\'$\\' in node\\n        c = word[0]\\n        if c == \\'.\\':\\n            for child in node:\\n                if child != \\'$\\' and self.dfs(node[child], word[1:]):\\n                    return True\\n        elif c in node:\\n            return self.dfs(node[c], word[1:])\\n        return False\\n\\n\\n```\n```C++ []\\nclass TrieNode {\\npublic:\\n    bool isEndOfWord;\\n    TrieNode* children[26];\\n\\n    TrieNode() {\\n        isEndOfWord = false;\\n        for (int i = 0; i < 26; i++) {\\n            children[i] = nullptr;\\n        }\\n    }\\n};\\n\\nclass WordDictionary {\\nprivate:\\n    TrieNode* root;\\n\\npublic:\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n\\n    void addWord(string word) {\\n        TrieNode* curr = root;\\n        for (char c : word) {\\n            if (curr->children[c - \\'a\\'] == nullptr) {\\n                curr->children[c - \\'a\\'] = new TrieNode();\\n            }\\n            curr = curr->children[c - \\'a\\'];\\n        }\\n        curr->isEndOfWord = true;\\n    }\\n\\n    bool search(string word) {\\n        return searchHelper(word, 0, root);\\n    }\\n\\n    bool searchHelper(string word, int index, TrieNode* curr) {\\n        if (index == word.length()) {\\n            return curr->isEndOfWord;\\n        }\\n\\n        char c = word[index];\\n\\n        if (c == \\'.\\') {\\n            for (int i = 0; i < 26; i++) {\\n                if (curr->children[i] != nullptr && searchHelper(word, index + 1, curr->children[i])) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        } else {\\n            if (curr->children[c - \\'a\\'] == nullptr) {\\n                return false;\\n            }\\n            return searchHelper(word, index + 1, curr->children[c - \\'a\\']);\\n        }\\n    }\\n};\\n\\n\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725450,
                "title": "trie-c-easy-to-understand-124-ms",
                "content": "1. We have used Trie to make the solution efficient as compared to bruteforce.\\n2. The idea here is to create a TrieNode class which has 26 elements which are english alphabets and a flag variable which indicates if the string has come to an end.\\n3. For the simplicity of the WordDictionary class we have included all the required function calls in the TrieNode Class.\\n\\nThe first word is the root and for adding more words we create a new Node and link it with previous. We make a comparison before creating a node for making sure that the word does not exist in the Trie.\\nFor searching we created a helper function in which we pass the node which is linked to the current word.\\nTo handle . in search we chck if our trie has any path available where the required output is possible.\\n\\n\\n```\\nclass TrieNode{\\n    public:\\n    TrieNode *links[26];\\n    bool flag = false;\\n    bool hasKey(char ch){\\n        return (links[ch-\\'a\\'] != NULL);\\n    }\\n    void put(char ch, TrieNode *node){\\n        links[ch - \\'a\\'] = node;\\n    }\\n    TrieNode *get(char ch){\\n        return links[ch - \\'a\\'];\\n    }\\n    void flagSwitch(){\\n        flag=true;\\n    }\\n    bool isEnd(){\\n        return flag == true;\\n    }\\n};\\n\\nclass WordDictionary {\\npublic:\\n    TrieNode *root;\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        TrieNode *node  = root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node->hasKey(word[i])){\\n                node->put(word[i],new TrieNode());\\n            }\\n            node = node->get(word[i]);\\n        }\\n        node->flagSwitch();\\n    }\\n    bool helper(string word, TrieNode *node){\\n        for(int i=0;i<word.length();i++){\\n            if(word[i]==\\'.\\'){\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\tThis piece of code is the key to solve this problem \\n\\t\\t\\t\\t\\tso what this line basically do is it checks if our string has any possibilty \\n\\t\\t\\t\\t\\tfor any character between a to z where we get our desired results. \\n\\t\\t\\t\\t\\tSo we just make a recursive call to the same function for \\n\\t\\t\\t\\t\\tevery possible character at the place of \".\"!\\n\\t\\t\\t\\t*/\\n                for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n                    if(node->hasKey(ch) && helper(word.substr(i+1),node->get(ch))) \\n                        return true;\\n                }\\n                return false;\\n            }\\n            else{\\n            if(!node->hasKey(word[i])){\\n                return false;\\n            }\\n            node = node->get(word[i]);\\n            }\\n        }\\n        if(node->isEnd()) {\\n            return true; \\n        }\\n        return false;     \\n    }\\n    \\n    bool search(string word) {\\n        TrieNode *node  = root;\\n        return helper(word,node);\\n    }\\n};\\n ```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode{\\n    public:\\n    TrieNode *links[26];\\n    bool flag = false;\\n    bool hasKey(char ch){\\n        return (links[ch-\\'a\\'] != NULL);\\n    }\\n    void put(char ch, TrieNode *node){\\n        links[ch - \\'a\\'] = node;\\n    }\\n    TrieNode *get(char ch){\\n        return links[ch - \\'a\\'];\\n    }\\n    void flagSwitch(){\\n        flag=true;\\n    }\\n    bool isEnd(){\\n        return flag == true;\\n    }\\n};\\n\\nclass WordDictionary {\\npublic:\\n    TrieNode *root;\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        TrieNode *node  = root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node->hasKey(word[i])){\\n                node->put(word[i],new TrieNode());\\n            }\\n            node = node->get(word[i]);\\n        }\\n        node->flagSwitch();\\n    }\\n    bool helper(string word, TrieNode *node){\\n        for(int i=0;i<word.length();i++){\\n            if(word[i]==\\'.\\'){\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\tThis piece of code is the key to solve this problem \\n\\t\\t\\t\\t\\tso what this line basically do is it checks if our string has any possibilty \\n\\t\\t\\t\\t\\tfor any character between a to z where we get our desired results. \\n\\t\\t\\t\\t\\tSo we just make a recursive call to the same function for \\n\\t\\t\\t\\t\\tevery possible character at the place of \".\"!\\n\\t\\t\\t\\t*/\\n                for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n                    if(node->hasKey(ch) && helper(word.substr(i+1),node->get(ch))) \\n                        return true;\\n                }\\n                return false;\\n            }\\n            else{\\n            if(!node->hasKey(word[i])){\\n                return false;\\n            }\\n            node = node->get(word[i]);\\n            }\\n        }\\n        if(node->isEnd()) {\\n            return true; \\n        }\\n        return false;     \\n    }\\n    \\n    bool search(string word) {\\n        TrieNode *node  = root;\\n        return helper(word,node);\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 59555,
                "title": "python-trie-with-defaultdict-trick",
                "content": "    from collections import defaultdict\\n    \\n    def _trie():\\n        return defaultdict(_trie)\\n    \\n    TERMINAL = None\\n    \\n    class WordDictionary(object):\\n        def __init__(self):\\n            self.trie = _trie()\\n    \\n        def addWord(self, word):\\n            trie = self.trie\\n            for letter in word:\\n                trie = trie[letter]\\n            trie[TERMINAL]\\n    \\n        def search(self, word, trie=None):\\n            if trie is None:\\n                trie = self.trie\\n            for i, letter in enumerate(word):\\n                if letter == '.':\\n                    return any(self.search(word[i+1:], t) for t in trie.itervalues())\\n                if letter in trie:\\n                    trie = trie[letter]\\n                else:\\n                    return False\\n            return TERMINAL in trie\\n\\nVery similar with the other trie-based solution but uses a less known `defaultdict` trick to make tries easier to build.",
                "solutionTags": [],
                "code": "    from collections import defaultdict\\n    \\n    def _trie():\\n        return defaultdict(_trie)\\n    \\n    TERMINAL = None\\n    \\n    class WordDictionary(object):\\n        def __init__(self):\\n            self.trie = _trie()\\n    \\n        def addWord(self, word):\\n            trie = self.trie\\n            for letter in word:\\n                trie = trie[letter]\\n            trie[TERMINAL]\\n    \\n        def search(self, word, trie=None):\\n            if trie is None:\\n                trie = self.trie\\n            for i, letter in enumerate(word):\\n                if letter == '.':\\n                    return any(self.search(word[i+1:], t) for t in trie.itervalues())\\n                if letter in trie:\\n                    trie = trie[letter]\\n                else:\\n                    return False\\n            return TERMINAL in trie\\n\\nVery similar with the other trie-based solution but uses a less known `defaultdict` trick to make tries easier to build.",
                "codeTag": "Java"
            },
            {
                "id": 1725301,
                "title": "python-7-lines-inverted-index-short-and-easy-to-understand",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n\\n```\\nclass WordDictionary(object):\\n\\n    def __init__(self):\\n        self.dict, self.len2word  = defaultdict(set), defaultdict(set)\\n\\n    def addWord(self, word):\\n        # self.dict: key is combination of index and character, value is a word set whose i-th letter is c\\n        for i, c in enumerate(word): self.dict[(i, c)].add(word)\\n        # self.len2word: key is length of word, value is a word set whose length is equal to key\\n        self.len2word[len(word)].add(word)\\n\\n    def search(self, word):\\n        ans = copy.deepcopy(self.len2word[len(word)])\\n        for i, c in enumerate(word):\\n            if c != \\'.\\': ans &= self.dict[(i, c)]\\n        return True if len(ans) else False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass WordDictionary(object):\\n\\n    def __init__(self):\\n        self.dict, self.len2word  = defaultdict(set), defaultdict(set)\\n\\n    def addWord(self, word):\\n        # self.dict: key is combination of index and character, value is a word set whose i-th letter is c\\n        for i, c in enumerate(word): self.dict[(i, c)].add(word)\\n        # self.len2word: key is length of word, value is a word set whose length is equal to key\\n        self.len2word[len(word)].add(word)\\n\\n    def search(self, word):\\n        ans = copy.deepcopy(self.len2word[len(word)])\\n        for i, c in enumerate(word):\\n            if c != \\'.\\': ans &= self.dict[(i, c)]\\n        return True if len(ans) else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495049,
                "title": "python-trie-solution-with-detailed-explanation",
                "content": "**Code:**\\n\\n```\\n\\nclass TrieNode:\\n    def __init__(self, val):\\n        self.val = val\\n        self.child = {}\\n        self.last = False\\n\\nclass WordDictionary: # this will serve as  the Trie class\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode(None)\\n        \\n    def addWord(self, word: str) -> None:\\n        \"\"\"\\n        Adds a word into the data structure.\\n        \"\"\"\\n        root = self.root\\n        for char in word:\\n            if char not in root.child:\\n                root.child[char] = TrieNode(char)\\n            root = root.child[char]\\n        root.last = True\\n        \\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        \"\"\"\\n        \\n        # -- helper\\n        def dfs(word, root):\\n            \\n            for i, char in enumerate(word):\\n\\n                if char == \".\":\\n                    for child in root.child:\\n                        childNode = root.child[child]\\n                        if dfs(word[i+1:], childNode):\\n                            return True\\n                    return False\\n\\n                else:\\n                    if char not in root.child:\\n                        return False\\n                    root = root.child[char]\\n                    \\n            return root.last\\n        \\n        \\n        # -- main\\n        root = self.root\\n        return dfs(word, root) # ----------- [1]\\n        \\n    \\n\\n                \\n        \\n        # NOTE [1]\\n        # --------\\n        # Why am I passing a root argumnet in addition to the word?\\n        # Since we might search words like:\\n        #       .ad\\n        #       ..d\\n        # We would want to begin the search from the first alphabetic letter\\n        # after ignoring the dot letters and for that we will need to call\\n        # the function recursively but in the recursive scenario, we don\\'t want\\n        # the trie traversal to happen from the root all over again. Instead,\\n        # we want to check the alphabetic part  only and the dots that preceds\\n        # that part are irrelevant\\n        \\n        \\n        # NOTE [2]\\n        # --------\\n        # What\\'s up with this additional check: char != \".\"?\\n        # Unlike the traditional trie find() function, the \\n        # fact that char is not in root.children is not enough to\\n        # return false in this particular example. Because our trie\\n        # in this . problem contains words that might begin with\\n        # dots -- see figure and thus we only dismiss the word as\\n        # not found if the first character of that word is both:\\n        #   1- Not found in the self.root.children. AND\\n        #   2- First char not a dot\\n        \\n        \\n        \\n# Your WordDictionary object will be instantiated and called as such:\\n# obj = WordDictionary()\\n# obj.addWord(word)\\n# param_2 = obj.search(word)\\n\\n                \\n        \\n        # NOTE [1]\\n        # --------\\n        # Why am I passing a root argumnet in addition to the word?\\n        # Since we might search words like:\\n        #       .ad\\n        #       ..d\\n        # We would want to begin the search from the first alphabetic letter\\n        # after ignoring the dot letters and for that we will need to call\\n        # the function recursively but in the recursive scenario, we don\\'t want\\n        # the trie traversal to happen from the root all over again. Instead,\\n        # we want to check the alphabetic part  only and the dots that preceds\\n        # that part are irrelevant\\n\\t\\t# SEE SKETCH BELOW FOR FURTHER UNDERSTANDING\\n        \\n        \\n        # NOTE [2]\\n        # --------\\n        # What\\'s up with this additional check: char != \".\"?\\n        # Unlike the traditional trie find() function, the \\n        # fact that char is not in root.children is not enough to\\n        # return false in this particular example. Because our trie\\n        # in this . problem contains words that might begin with\\n        # dots -- see figure and thus we only dismiss the word as\\n        # not found if the first character of that word is both:\\n        #   1- Not found in the self.root.children. AND\\n        #   2- First char not a dot\\n        \\n```\\n\\n![image](https://assets.leetcode.com/users/images/ee24d7d0-4d8b-44de-8137-9ccd3f35060f_1643254845.3624523.jpeg)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\n\\nclass TrieNode:\\n    def __init__(self, val):\\n        self.val = val\\n        self.child = {}\\n        self.last = False\\n\\nclass WordDictionary: # this will serve as  the Trie class\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode(None)\\n        \\n    def addWord(self, word: str) -> None:\\n        \"\"\"\\n        Adds a word into the data structure.\\n        \"\"\"\\n        root = self.root\\n        for char in word:\\n            if char not in root.child:\\n                root.child[char] = TrieNode(char)\\n            root = root.child[char]\\n        root.last = True\\n        \\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        \"\"\"\\n        \\n        # -- helper\\n        def dfs(word, root):\\n            \\n            for i, char in enumerate(word):\\n\\n                if char == \".\":\\n                    for child in root.child:\\n                        childNode = root.child[child]\\n                        if dfs(word[i+1:], childNode):\\n                            return True\\n                    return False\\n\\n                else:\\n                    if char not in root.child:\\n                        return False\\n                    root = root.child[char]\\n                    \\n            return root.last\\n        \\n        \\n        # -- main\\n        root = self.root\\n        return dfs(word, root) # ----------- [1]\\n        \\n    \\n\\n                \\n        \\n        # NOTE [1]\\n        # --------\\n        # Why am I passing a root argumnet in addition to the word?\\n        # Since we might search words like:\\n        #       .ad\\n        #       ..d\\n        # We would want to begin the search from the first alphabetic letter\\n        # after ignoring the dot letters and for that we will need to call\\n        # the function recursively but in the recursive scenario, we don\\'t want\\n        # the trie traversal to happen from the root all over again. Instead,\\n        # we want to check the alphabetic part  only and the dots that preceds\\n        # that part are irrelevant\\n        \\n        \\n        # NOTE [2]\\n        # --------\\n        # What\\'s up with this additional check: char != \".\"?\\n        # Unlike the traditional trie find() function, the \\n        # fact that char is not in root.children is not enough to\\n        # return false in this particular example. Because our trie\\n        # in this . problem contains words that might begin with\\n        # dots -- see figure and thus we only dismiss the word as\\n        # not found if the first character of that word is both:\\n        #   1- Not found in the self.root.children. AND\\n        #   2- First char not a dot\\n        \\n        \\n        \\n# Your WordDictionary object will be instantiated and called as such:\\n# obj = WordDictionary()\\n# obj.addWord(word)\\n# param_2 = obj.search(word)\\n\\n                \\n        \\n        # NOTE [1]\\n        # --------\\n        # Why am I passing a root argumnet in addition to the word?\\n        # Since we might search words like:\\n        #       .ad\\n        #       ..d\\n        # We would want to begin the search from the first alphabetic letter\\n        # after ignoring the dot letters and for that we will need to call\\n        # the function recursively but in the recursive scenario, we don\\'t want\\n        # the trie traversal to happen from the root all over again. Instead,\\n        # we want to check the alphabetic part  only and the dots that preceds\\n        # that part are irrelevant\\n\\t\\t# SEE SKETCH BELOW FOR FURTHER UNDERSTANDING\\n        \\n        \\n        # NOTE [2]\\n        # --------\\n        # What\\'s up with this additional check: char != \".\"?\\n        # Unlike the traditional trie find() function, the \\n        # fact that char is not in root.children is not enough to\\n        # return false in this particular example. Because our trie\\n        # in this . problem contains words that might begin with\\n        # dots -- see figure and thus we only dismiss the word as\\n        # not found if the first character of that word is both:\\n        #   1- Not found in the self.root.children. AND\\n        #   2- First char not a dot\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 390134,
                "title": "two-solutions-in-python-3-trie-and-dfs-set-beats-96",
                "content": "_Using a Dictionary of Sets:_ (beats ~96%)\\n```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.words = collections.defaultdict(set)\\n        \\n    def addWord(self, word: str) -> None:\\n    \\tself.words[len(word)].add(word)\\n        \\n    def search(self, word: str) -> bool:\\n    \\tfor w in self.words[len(word)]:\\n    \\t\\tfor i, c in enumerate(word):\\n    \\t\\t\\tif c not in [\\'.\\',w[i]]: break\\n    \\t\\telse: return True\\n    \\treturn False\\n\\t\\t\\n\\t\\t\\n```\\t\\t\\n_Using Trie and DFS:_\\n```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.root = {}\\n        \\n    def addWord(self, word: str) -> None:\\n        node = self.root\\n        for c in word:\\n            if c not in node: node[c] = {}\\n            node = node[c]\\n        node[\\'*\\'] = False\\n        \\n    def search(self, w: str) -> bool:\\n    \\tdef dfs(node, i):\\n    \\t\\tif node == False: return False\\n    \\t\\tif i == L: return \\'*\\' in node\\n    \\t\\tif w[i] != \\'.\\':\\n    \\t\\t\\tif w[i] not in node: return False\\n    \\t\\t\\treturn dfs(node[w[i]],i+1)\\n    \\t\\tfor j in node.values():\\n    \\t\\t\\tif dfs(j,i+1): return True\\n    \\t\\treturn False\\n    \\tnode, L = self.root, len(w)\\n    \\treturn dfs(node,0)\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Trie",
                    "Ordered Set"
                ],
                "code": "```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.words = collections.defaultdict(set)\\n        \\n    def addWord(self, word: str) -> None:\\n    \\tself.words[len(word)].add(word)\\n        \\n    def search(self, word: str) -> bool:\\n    \\tfor w in self.words[len(word)]:\\n    \\t\\tfor i, c in enumerate(word):\\n    \\t\\t\\tif c not in [\\'.\\',w[i]]: break\\n    \\t\\telse: return True\\n    \\treturn False\\n\\t\\t\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314437,
                "title": "c-trie-easy-to-understand",
                "content": "# Intuition\\nIt would be better to first understand [Implement Trie (Explanation)](https://leetcode.com/problems/implement-trie-prefix-tree/solutions/3306611/explained-with-example-easy-to-understand/) before attempting this problem. \\n\\nHere we will be using trie to store the words. Each node in the Trie represents a character, and the path from the root node to a particular node represents a string or word. The end of a word is marked by a flag in the last node of the word.\\n\\nTo search, if we encounter a \\'.\\', then we would skip that character and recursively search for the remaining characters. Else we would check whether the current alphabet exists or not. If not return false, else call recursion on remaining characters.\\n\\n\\n# Code\\n```\\nstruct TrieNode {\\n    bool end; // Flag to indicate whether this node represents the end of a word or not\\n    vector<TrieNode*>children=vector<TrieNode*>(26,nullptr); // Vector of pointers to child nodes for each possible character in the alphabet (26 lowercase English letters)\\n};\\n\\nclass WordDictionary {\\npublic:\\n    TrieNode* root;\\n    WordDictionary() {\\n        root=new TrieNode();\\n    }\\n    \\n    // Insert a word into the Trie\\n    void addWord(string word) {\\n        TrieNode* curr=root;\\n        for(char c:word){\\n            int index=c-\\'a\\';\\n            if(!curr->children[index]){\\n                curr->children[index]=new TrieNode();\\n            }\\n            curr=curr->children[index];\\n        }\\n        curr->end=true; // Mark the last node as the end of the word\\n    }\\n\\n    // Search for a word in the Trie\\n    bool pathSearch(string word, TrieNode* root, int index){\\n        if(index==word.size()) return root->end; // return true if the last node is marked as the end of a word\\n        TrieNode* node=root;\\n        char c=word[index];\\n        int idx=c-\\'a\\';\\n        if(c==\\'.\\'){   // if character is \\'.\\' check for remaining characters in all nodes\\n            for(int i=0;i<26;i++){\\n                if(node->children[i]){\\n                   bool search= pathSearch(word,node->children[i],index+1); \\n                   if(search) return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else{\\n            if(!node->children[idx])return false; // if the current character doesn\\'t exist return false\\n            return pathSearch(word,node->children[idx],index+1); // if current character exists check for remaining characters\\n        }\\n    }\\n    \\n    bool search(string word) {\\n        return pathSearch(word,root,0);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct TrieNode {\\n    bool end; // Flag to indicate whether this node represents the end of a word or not\\n    vector<TrieNode*>children=vector<TrieNode*>(26,nullptr); // Vector of pointers to child nodes for each possible character in the alphabet (26 lowercase English letters)\\n};\\n\\nclass WordDictionary {\\npublic:\\n    TrieNode* root;\\n    WordDictionary() {\\n        root=new TrieNode();\\n    }\\n    \\n    // Insert a word into the Trie\\n    void addWord(string word) {\\n        TrieNode* curr=root;\\n        for(char c:word){\\n            int index=c-\\'a\\';\\n            if(!curr->children[index]){\\n                curr->children[index]=new TrieNode();\\n            }\\n            curr=curr->children[index];\\n        }\\n        curr->end=true; // Mark the last node as the end of the word\\n    }\\n\\n    // Search for a word in the Trie\\n    bool pathSearch(string word, TrieNode* root, int index){\\n        if(index==word.size()) return root->end; // return true if the last node is marked as the end of a word\\n        TrieNode* node=root;\\n        char c=word[index];\\n        int idx=c-\\'a\\';\\n        if(c==\\'.\\'){   // if character is \\'.\\' check for remaining characters in all nodes\\n            for(int i=0;i<26;i++){\\n                if(node->children[i]){\\n                   bool search= pathSearch(word,node->children[i],index+1); \\n                   if(search) return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else{\\n            if(!node->children[idx])return false; // if the current character doesn\\'t exist return false\\n            return pathSearch(word,node->children[idx],index+1); // if current character exists check for remaining characters\\n        }\\n    }\\n    \\n    bool search(string word) {\\n        return pathSearch(word,root,0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193357,
                "title": "python-with-trie-and-bfs",
                "content": "Idea is to loop on next possible nodes (letters).\\nKeeping an array of `nodes` in search function and updating it with `next_nodes` in which we store the next possible node.\\nThen in the end of our search we may have more than 1 possible node, so we check if any of the node `is_word`. If yes then word is present and return `True`.\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.is_word = False\\n        self.children = {}\\n\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def addWord(self, word: str) -> None:\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = TrieNode()\\n            node = node.children[ch]\\n        node.is_word = True\\n\\n    def search(self, word: str) -> bool:\\n        nodes = [self.root]\\n        for ch in word:\\n            next_nodes = []\\n            for node in nodes:\\n                if ch in node.children:\\n                    next_nodes.append(node.children[ch])\\n                if ch == \\'.\\':\\n                    next_nodes.extend(node.children.values())\\n            nodes = next_nodes\\n        \\n        for node in nodes:\\n            if node.is_word:\\n                return True\\n        \\n        return False\\n```\\n\\nIf you like the solution, up-vote would be fantastic ;)",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.is_word = False\\n        self.children = {}\\n\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def addWord(self, word: str) -> None:\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = TrieNode()\\n            node = node.children[ch]\\n        node.is_word = True\\n\\n    def search(self, word: str) -> bool:\\n        nodes = [self.root]\\n        for ch in word:\\n            next_nodes = []\\n            for node in nodes:\\n                if ch in node.children:\\n                    next_nodes.append(node.children[ch])\\n                if ch == \\'.\\':\\n                    next_nodes.extend(node.children.values())\\n            nodes = next_nodes\\n        \\n        for node in nodes:\\n            if node.is_word:\\n                return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554197,
                "title": "c-solution-without-trie-108-ms",
                "content": "Hi all! I understand that this problem is probably designed especially to see if you know trie data structure. Ok. I\\'d like to confess from start that I don\\'t know much about this data structure and solve this problem as I\\'d do it at work. I just use here map with length of a word as a key and vector of words as a value. And somehow this solution works with 108 ms runtime and 29 mb space.\\n\\nAfter that I tried to solve this problem using trie and I couldn\\'t beat the previous result. I removed the code smart pointers for nodes for better performance accepting memory leaks -> result is still bad. Then I removed containers and used simple array -> the same. Then I took just a solution from the discussion, with memset and NULLs (omg), and it is still worse then my first solution.\\n\\nThe question is. What kind of solution interviewers wait from the candidate on this problem: unsafe, old-fashioned with memory leaks and slow but with trie or modern, robust and straight-forward WITHOUT trie?\\n\\nSolution is the following:\\n\\n```\\nclass WordDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    WordDictionary() {\\n        \\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        if (m_words.find(word.length()) == m_words.end()) {\\n            m_words[word.length()] = vector<string>();\\n        }\\n        \\n        m_words[word.length()].push_back(word);\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word) {\\n        if (m_words.find(word.length()) == m_words.end())\\n            return false;\\n        \\n        for (auto& stored_word : m_words[word.length()]) {\\n            \\n            bool word_is_matched = true;\\n            \\n            for (int i = 0; i < word.length(); ++i) {\\n                if (word[i] == \\'.\\')\\n                    continue;\\n                \\n                if (stored_word[i] != word[i]) {\\n                    word_is_matched = false;\\n                    break;\\n                }\\n            }\\n            \\n            if (word_is_matched)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\nprivate:\\n    unordered_map<size_t, vector<string>> m_words;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    WordDictionary() {\\n        \\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        if (m_words.find(word.length()) == m_words.end()) {\\n            m_words[word.length()] = vector<string>();\\n        }\\n        \\n        m_words[word.length()].push_back(word);\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word) {\\n        if (m_words.find(word.length()) == m_words.end())\\n            return false;\\n        \\n        for (auto& stored_word : m_words[word.length()]) {\\n            \\n            bool word_is_matched = true;\\n            \\n            for (int i = 0; i < word.length(); ++i) {\\n                if (word[i] == \\'.\\')\\n                    continue;\\n                \\n                if (stored_word[i] != word[i]) {\\n                    word_is_matched = false;\\n                    break;\\n                }\\n            }\\n            \\n            if (word_is_matched)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\nprivate:\\n    unordered_map<size_t, vector<string>> m_words;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324814,
                "title": "java-iterative-bfs",
                "content": "Seems like everybody prefers the faster recursion. But anyways, a BFS solution memorizing level:\\n\\n```    \\n    public class TrieNode {\\n        public TrieNode[] children = new TrieNode[26];\\n        public boolean isWord = false;\\n    }\\n    \\n    public TrieNode root = new TrieNode();\\n\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        \\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n        TrieNode node = root;\\n        for (char c : word.toCharArray()) {\\n            if (node.children[c - \\'a\\'] == null) {\\n                node.children[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node.children[c - \\'a\\'];\\n        }\\n        node.isWord = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public boolean search(String word) {\\n        TrieNode node = root;\\n        Queue<TrieNode> queue = new LinkedList<>();\\n        queue.offer(node);\\n        int level = 0;\\n        while (!queue.isEmpty() && level <= word.length()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                TrieNode current = queue.poll();\\n                \\n                if (level == word.length()) {\\n                    if (current.isWord) {\\n                        return true;\\n                    } else {\\n                        continue;\\n                    }\\n                }\\n                \\n                char c = word.charAt(level);\\n                \\n                if (c == \\'.\\') {\\n                    for (TrieNode t : current.children) {\\n                        if (t != null) {\\n                            queue.offer(t);\\n                        }\\n                    }\\n                } else if (current.children[c - \\'a\\'] != null) {\\n                    queue.offer(current.children[c - \\'a\\']);\\n                }\\n            }\\n            level++;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Trie",
                    "Iterator"
                ],
                "code": "```    \\n    public class TrieNode {\\n        public TrieNode[] children = new TrieNode[26];\\n        public boolean isWord = false;\\n    }\\n    \\n    public TrieNode root = new TrieNode();\\n\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        \\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n        TrieNode node = root;\\n        for (char c : word.toCharArray()) {\\n            if (node.children[c - \\'a\\'] == null) {\\n                node.children[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node.children[c - \\'a\\'];\\n        }\\n        node.isWord = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public boolean search(String word) {\\n        TrieNode node = root;\\n        Queue<TrieNode> queue = new LinkedList<>();\\n        queue.offer(node);\\n        int level = 0;\\n        while (!queue.isEmpty() && level <= word.length()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                TrieNode current = queue.poll();\\n                \\n                if (level == word.length()) {\\n                    if (current.isWord) {\\n                        return true;\\n                    } else {\\n                        continue;\\n                    }\\n                }\\n                \\n                char c = word.charAt(level);\\n                \\n                if (c == \\'.\\') {\\n                    for (TrieNode t : current.children) {\\n                        if (t != null) {\\n                            queue.offer(t);\\n                        }\\n                    }\\n                } else if (current.children[c - \\'a\\'] != null) {\\n                    queue.offer(current.children[c - \\'a\\']);\\n                }\\n            }\\n            level++;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59691,
                "title": "84ms-c-solution-depth-first-search",
                "content": "    class TrieNode {\\n    public:\\n        bool isComplete;\\n        TrieNode * ch[26];\\n        // Initialize your data structure here.\\n        TrieNode() {\\n            isComplete = false;\\n            for (int i = 0; i < 26; i++) ch[i] = NULL;\\n        }\\n    };\\n    \\n    class Trie {\\n    public:\\n        Trie() {\\n            root = new TrieNode();\\n        }\\n    \\n        // Inserts a word into the trie.\\n        void insert(string word) {\\n            // just insert one path from root node to the end\\n            TrieNode * p = root;\\n            for (auto c : word) {\\n                if (p->ch[c-'a'] == NULL) {\\n                    p->ch[c-'a'] = new TrieNode();\\n                }\\n                p = p->ch[c-'a'];\\n            }\\n            p->isComplete = true;\\n        }\\n    \\n        // Returns if the word is in the trie.\\n        bool search(string word) {\\n            return dfs(root, word, 0);\\n        }\\n        \\n        bool dfs(TrieNode* p, string& word, int startIndex) {\\n            if (p == NULL) return false;\\n            if (startIndex == word.length()) return p->isComplete;\\n            char c = word[startIndex];\\n            if (c == '.') {\\n                for (int i = 0; i < 26; i++) {\\n                    if (p->ch[i] != NULL) {\\n                        if (dfs(p->ch[i], word, startIndex + 1)) return true;\\n                    }\\n                }\\n                return false;\\n            } else {\\n                return dfs(p->ch[c - 'a'], word, startIndex + 1);\\n            }\\n        }\\n        \\n    private:\\n        TrieNode* root;\\n    };\\n    \\n    class WordDictionary {\\n        Trie trie;\\n    public:\\n    \\n        // Adds a word into the data structure.\\n        void addWord(string word) {\\n            trie.insert(word);\\n        }\\n    \\n        // Returns if the word is in the data structure. A word could\\n        // contain the dot character '.' to represent any one letter.\\n        bool search(string word) {\\n            return trie.search(word);\\n        }\\n        \\n    \\n    };",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "    class TrieNode {\\n    public:\\n        bool isComplete;\\n        TrieNode * ch[26];\\n        // Initialize your data structure here.\\n        TrieNode() {\\n            isComplete = false;\\n            for (int i = 0; i < 26; i++) ch[i] = NULL;\\n        }\\n    };\\n    \\n    class Trie {\\n    public:\\n        Trie() {\\n            root = new TrieNode();\\n        }\\n    \\n        // Inserts a word into the trie.\\n        void insert(string word) {\\n            // just insert one path from root node to the end\\n            TrieNode * p = root;\\n            for (auto c : word) {\\n                if (p->ch[c-'a'] == NULL) {\\n                    p->ch[c-'a'] = new TrieNode();\\n                }\\n                p = p->ch[c-'a'];\\n            }\\n            p->isComplete = true;\\n        }\\n    \\n        // Returns if the word is in the trie.\\n        bool search(string word) {\\n            return dfs(root, word, 0);\\n        }\\n        \\n        bool dfs(TrieNode* p, string& word, int startIndex) {\\n            if (p == NULL) return false;\\n            if (startIndex == word.length()) return p->isComplete;\\n            char c = word[startIndex];\\n            if (c == '.') {\\n                for (int i = 0; i < 26; i++) {\\n                    if (p->ch[i] != NULL) {\\n                        if (dfs(p->ch[i], word, startIndex + 1)) return true;\\n                    }\\n                }\\n                return false;\\n            } else {\\n                return dfs(p->ch[c - 'a'], word, startIndex + 1);\\n            }\\n        }\\n        \\n    private:\\n        TrieNode* root;\\n    };\\n    \\n    class WordDictionary {\\n        Trie trie;\\n    public:\\n    \\n        // Adds a word into the data structure.\\n        void addWord(string word) {\\n            trie.insert(word);\\n        }\\n    \\n        // Returns if the word is in the data structure. A word could\\n        // contain the dot character '.' to represent any one letter.\\n        bool search(string word) {\\n            return trie.search(word);\\n        }\\n        \\n    \\n    };",
                "codeTag": "Java"
            },
            {
                "id": 59705,
                "title": "java-19ms-solution-modified-trie-solution",
                "content": "1\\u3001use HashMap to categorized words by length.\\n\\n      Map<Integer,TrieNode>trieMap = new HashMap<Integer,TrieNode>();\\n\\n2\\u3001all words of the same length are put in to a trie.\\n \\nIn a normal trie solution,we can only search one letter per time, \\n\\nhowever,there are many cases where letters are continuously the same, say \"caaaab\"\\n\\nso we can condense these continuously duplicated letters into one trie node instead of multiple trie node\\n\\nHere is how TrieNode is defined:\\n\\n    class TrieNode{\\n\\t\\tTrieNode children[];\\n\\t\\tint len = 0;  //record the number of character that is continuously duplicated\\n\\t\\tpublic TrieNode(){\\n\\t\\t\\tchildren = new TrieNode[26];\\n\\t\\t}\\n\\t}\\n\\nthis helps to reduce the trie height and the search path \\n\\nPS:\\n \\nI was able to beat 100% percent of java submission( about 15ms) just using a small trick\\n\\nChange the type of trieMap to an array \\n\\n    TrieNode[]trieMap = new TrieNode[512];  //the maximum length of all testd words is about 500",
                "solutionTags": [
                    "Java"
                ],
                "code": "1\\u3001use HashMap to categorized words by length.\\n\\n      Map<Integer,TrieNode>trieMap = new HashMap<Integer,TrieNode>();\\n\\n2\\u3001all words of the same length are put in to a trie.\\n \\nIn a normal trie solution,we can only search one letter per time, \\n\\nhowever,there are many cases where letters are continuously the same, say \"caaaab\"\\n\\nso we can condense these continuously duplicated letters into one trie node instead of multiple trie node\\n\\nHere is how TrieNode is defined:\\n\\n    class TrieNode{\\n\\t\\tTrieNode children[];\\n\\t\\tint len = 0;  //record the number of character that is continuously duplicated\\n\\t\\tpublic TrieNode(){\\n\\t\\t\\tchildren = new TrieNode[26];\\n\\t\\t}\\n\\t}\\n\\nthis helps to reduce the trie height and the search path \\n\\nPS:\\n \\nI was able to beat 100% percent of java submission( about 15ms) just using a small trick\\n\\nChange the type of trieMap to an array \\n\\n    TrieNode[]trieMap = new TrieNode[512];  //the maximum length of all testd words is about 500",
                "codeTag": "Java"
            },
            {
                "id": 774178,
                "title": "java-trie-clean-code",
                "content": "***Prerequisites*** : [Leetcode Implement Trie Data Structure](https://github.com/abhisheksurve45/leetcode-may-2020#week-2)\\n\\n#### Solution : \\n\\n```\\n\\nclass WordDictionary {\\n    \\n    private static final int ALPHABETS = 26;\\n    \\n    /** TrieNode class contains child TrieNode and end to denote end of particular word  */\\n    private class TrieNode {\\n        private TrieNode[] child = new TrieNode[ALPHABETS];\\n        private boolean end;\\n    }\\n    \\n    private TrieNode root;\\n\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        this.root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n        TrieNode trieNode = root;\\n        for(Character c : word.toCharArray()){\\n            int index = c - \\'a\\';\\n            if(trieNode.child[index]== null){\\n                trieNode.child[index] = new TrieNode();\\n            }\\n            trieNode = trieNode.child[index];\\n        }\\n        trieNode.end = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public boolean search(String word) {\\n        return match(word.toCharArray(), root, 0);\\n    }\\n    \\n    private boolean match(char[] word,TrieNode node, int index) {\\n        \\n\\t\\t/** word is not present in trie, return false */\\n        if(node == null) return false;\\n        \\n\\t\\t/** word of exact length found in trie, return if it is a valid word (TrieNode.end) */\\n        if(index == word.length) return node.end;\\n        \\n        char ch = word[index];\\n        \\n        /* for \".\", run matching condition for every alphabet */\\n        if(ch == \\'.\\') {\\n            \\n            for(int i = 0; i< ALPHABETS ; i++) {\\n                if (node.child[i] != null && match(word, node.child[i], index+1)) {\\n                    return true;\\n                }\\n            }\\n             \\n        } else {\\n            /*  for normal character, check if child node is present & matches */\\n            return node.child[ch - \\'a\\'] != null && match(word, node.child[ch - \\'a\\'], index+1);\\n        }\\n        \\n        /* return false default  */\\n        return false;\\n        \\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */\\n \\n```\\n\\nPlease upvote!\\n\\n---\\nMore such solutions can be found here : [Github](https://github.com/abhisheksurve45/leetcode-aug-2020)\\n---",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\n\\nclass WordDictionary {\\n    \\n    private static final int ALPHABETS = 26;\\n    \\n    /** TrieNode class contains child TrieNode and end to denote end of particular word  */\\n    private class TrieNode {\\n        private TrieNode[] child = new TrieNode[ALPHABETS];\\n        private boolean end;\\n    }\\n    \\n    private TrieNode root;\\n\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        this.root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n        TrieNode trieNode = root;\\n        for(Character c : word.toCharArray()){\\n            int index = c - \\'a\\';\\n            if(trieNode.child[index]== null){\\n                trieNode.child[index] = new TrieNode();\\n            }\\n            trieNode = trieNode.child[index];\\n        }\\n        trieNode.end = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public boolean search(String word) {\\n        return match(word.toCharArray(), root, 0);\\n    }\\n    \\n    private boolean match(char[] word,TrieNode node, int index) {\\n        \\n\\t\\t/** word is not present in trie, return false */\\n        if(node == null) return false;\\n        \\n\\t\\t/** word of exact length found in trie, return if it is a valid word (TrieNode.end) */\\n        if(index == word.length) return node.end;\\n        \\n        char ch = word[index];\\n        \\n        /* for \".\", run matching condition for every alphabet */\\n        if(ch == \\'.\\') {\\n            \\n            for(int i = 0; i< ALPHABETS ; i++) {\\n                if (node.child[i] != null && match(word, node.child[i], index+1)) {\\n                    return true;\\n                }\\n            }\\n             \\n        } else {\\n            /*  for normal character, check if child node is present & matches */\\n            return node.child[ch - \\'a\\'] != null && match(word, node.child[ch - \\'a\\'], index+1);\\n        }\\n        \\n        /* return false default  */\\n        return false;\\n        \\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 290724,
                "title": "easy-to-read-length-based-set-solution",
                "content": "```py\\nfrom collections import defaultdict\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.words = defaultdict(set)\\n        \\n\\n    def addWord(self, word: str) -> None:\\n        \"\"\"\\n        Adds a word into the data structure.\\n        \"\"\"\\n        self.words[len(word)].add(word)\\n        \\n\\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        \"\"\"\\n        for other in self.words[len(word)]:\\n            any_mismatch = any(word[x] != \\'.\\' and word[x] != other[x] for x in range(len(word)))\\n            if not any_mismatch:\\n                return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py\\nfrom collections import defaultdict\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.words = defaultdict(set)\\n        \\n\\n    def addWord(self, word: str) -> None:\\n        \"\"\"\\n        Adds a word into the data structure.\\n        \"\"\"\\n        self.words[len(word)].add(word)\\n        \\n\\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        \"\"\"\\n        for other in self.words[len(word)]:\\n            any_mismatch = any(word[x] != \\'.\\' and word[x] != other[x] for x in range(len(word)))\\n            if not any_mismatch:\\n                return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 177806,
                "title": "python-solution-beats-100",
                "content": "```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.map = collections.defaultdict(set)\\n\\n    def addWord(self, word):\\n        \"\"\"\\n        Adds a word into the data structure.\\n        :type word: str\\n        :rtype: void\\n        \"\"\"\\n        k = len(word)\\n        self.map[k].add(word)\\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        k = len(word)\\n        \\n        p = self.map[k]\\n        if not p:\\n            return False\\n        if word in p:\\n            return True\\n        \\n        for i in range(k):\\n            if word[i] == \\'.\\':\\n                continue\\n            p = {x for x in p if x[i] == word[i]}\\n            if not p:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.map = collections.defaultdict(set)\\n\\n    def addWord(self, word):\\n        \"\"\"\\n        Adds a word into the data structure.\\n        :type word: str\\n        :rtype: void\\n        \"\"\"\\n        k = len(word)\\n        self.map[k].add(word)\\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        k = len(word)\\n        \\n        p = self.map[k]\\n        if not p:\\n            return False\\n        if word in p:\\n            return True\\n        \\n        for i in range(k):\\n            if word[i] == \\'.\\':\\n                continue\\n            p = {x for x in p if x[i] == word[i]}\\n            if not p:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726221,
                "title": "best-c-solution-with-easiest-explanation-trie-explained",
                "content": "\\n```\\nthe one obvious solution is adding the string into a set or may be unordered_set and for searching\\nany string you can use regex  but the time complexity of such kind of solution will be large and \\nthis is not the recommended solution if asked in interview\\nSo then, what should we do? We can use TRIE.\\nWAIT WHAT !!! WHAT THE HECK IS TRIE IS?? I am a beginner. I dont understand what trie is!!!!\\nWell your wait is over and today you will learn what trie is.\\n\\nWell TRIE is a fancy name of a data structure which contains an array of pointers pointing to nodes like \\nitself. Well, this is a lame way of putting it. But this will do the job as of now.\\nWhat i am saying is written in the below code:\\nstruct Trie{\\n        Trie *arr[26];  // an array of pointers pointing to the data type of Trie type\\n        bool isend;\\n        Trie(){    //constructor for initializing those pointers to NULL\\n            for(int i =0;i<26;i++){\\n                arr[i]=NULL;\\n            }\\n            isend=false;\\n        }\\n    };\\n\\t\\nWell, does this remind you of sort of linked list data structure?? No?? Just a sec, it isnt exaclty the same\\nbut it kinda resembles\\n\\nclass Node{--------------------------->struct Trie{\\n\\tint data;                                 bool isend;\\n\\tNode *next; ------------------------------>Trie *arr[26]; \\n\\t// the only diff is  in Node , we have 1 pointer and in trie we have an array of pointers.\\n}\\nwell as of now, you have understood the basic structure of TRIE, but how this is helping us to solve\\nthe solution. Lets understand\\n\\nThis is the representation of a trie with 26 pointers (why 26? bcoz there are 26 alphabets dude!!)\\n\\n               Root\\n\\t\\t\\t      |\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n----------------------------------------------------------------------------------------------------\\n\\nand now we want to store lets say \"bud\" in our trie. Initially all pointers are NULL and we will store\\n\" b u d\" character by character.\\n\\nSo first we will store \" b \". wo we will go to the pointer which is responsible for storing \" b \".\\nBut we have an array of pointers right, so how to access that index of the array which is pointing\\nto \" b \"?? Simple dude !!!  Do --->  word[i]-\\'a\\'  so \\'b\\'-\\'a\\' and it will give 1. Please do not ask me \\nhow this is possbile ?? ascii values pal !!!!!!! well i am not going to explain this to you :( !!\\nSo we will go to the index 1 which logically says that i am b and we will create a node and will\\nmake that pointer pointing to that new node. Just a sec, i hope you know that we need not to\\nstore this \"b\" right? bcoz that task is already taken care by the index of our pointer of arrays.\\n\\nNow our trie looks like this now :\\n                 Root\\n\\t\\t\\t      |\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n----|------------------------------------------------------------------------------------------------\\n    |\\n    |\\n   \\\\|/    this is our new node which is being pointed by b\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n----------------------------------------------------------------------------------------------------\\nSimilarly we can add \" u \", so now our trie looks like this :\\n===========================================================\\n\\n                 Root\\n\\t\\t\\t      |\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n----|------------------------------------------------------------------------------------------------\\n    |\\n    |\\n   \\\\|/    this is our new node which is being pointed by b\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n--------------------------------------------------------------------------------|--------------------\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t|\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t|\\n\\t\\t\\t\\t                                 a new node pointed by \" u \"   \\\\|/\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n----------------------------------------------------------------------------------------------------\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\nNow time to store \" d \" of \"bud\".So now our trie looks like this :\\n================================================================\\n\\n                 Root\\n\\t\\t\\t      |\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n----|------------------------------------------------------------------------------------------------\\n    |\\n    |\\n   \\\\|/    this is our new node which is being pointed by b\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n--------------------------------------------------------------------------------|--------------------\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t|\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t|\\n\\t\\t\\t\\t                                 a new node pointed by \" u \"   \\\\|/\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n------------|----------------------------------------------------------------------------------------\\n\\t\\t    |\\n\\t\\t\\t|\\n\\t\\t   \\\\|/ a new node pointed by \"d \"\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n----------------------------------------------------------------------------------------------------\\nheyy wait , isnt this the end of the string ? yes?? so set **isend** to true for node \\'d\\' (which is\\nbeing pointed by \"u\").\\nIn a similar manner you will do insertion of other elements. Do a dry run on your own, you\\nwill get it!! I am sure of it !!\\n\\nThis was the insertion part of it. But now how to search any element?\\nSimple just pick up the character , go to its index by doing word[i]-\\'a\\' and check\\nif it is null or not. if it is null, then that means that character is not present and return false\\notherwise go furthur to the node which is pointed by that node. \\nLets say if curr is the current node, then for moving further, do curr=curr->array_of_pointers[i] \\ni refers to the current character which we are looking for.\\nOk ok , i know , the next question is what to do if we have dot (.) , well in that case you need to check\\nall the characters and perform the same traversal steps. \\nOkayy, so far i think you have the prerequisite knowledge and now you can see the below code:\\n\\nstruct Trie{\\n        Trie *arr[26];    //nothing fancy, bunch of pointers \\n        bool isend;    // to mark the end of the string\\n        Trie(){    //constructor to initialize all pointers to null intitally\\n            for(int i =0;i<26;i++){\\n                arr[i]=NULL;\\n            }\\n            isend=false;\\n        }\\n    };\\n\\nclass WordDictionary {\\npublic:\\n    /* \\n    by reading the problem , one can easily guess that alternative solution is TRIE coz it\\n    is a perfect data structure when you are dealing with prefixes or sufixes.\\n    first things first , we need to create a TRIE \\n    */\\n    Trie *root;    //our mighty root node\\n    \\n    WordDictionary() {\\n        root=new Trie();      //creation of the root node\\n    }\\n    \\n    void addWord(string word) {\\n        Trie *curr=root;                   \\n        int length=word.size();\\n        int index;\\n        for(int i =0;i<length;i++){   //inserting the character one by one\\n            index=word[i]-\\'a\\';\\n            if(curr->arr[index]==NULL){       //if that character is not present, \\n\\t\\t\\t//then create a node and point to it and if it is already present (for example- you have inserted\\n\\t\\t\\t//\"bad\" and now you are inserting \"bud\", so b is already there, so you dont have to do anything\\n\\t\\t\\t//thats the beauty of trie\\n                curr->arr[index]=new Trie();\\n            }\\n            curr=curr->arr[index];\\n        }\\n        curr->isend=true; //marking the end of the string\\n    }\\n    \\n    bool searchUtilDFS(Trie *curr,string word){\\n        //Note : we only need to perform dfs when we encounter dot\\n        int length=word.size();\\n        int index;\\n        for(int i =0;i<length;i++){\\n            if(word[i]!=\\'.\\'){  //simply traverse the TRIE\\n                index=word[i]-\\'a\\';\\n                if(curr->arr[index]==NULL){\\n                    // that element doesnt exist\\n                    return false;\\n                }\\n                curr=curr->arr[index];\\n            }else{\\n                //we encounter the dot operator\\n                //so we need to consider all possibilities that is string starting from a,b,c,d,e....so on\\n                bool result=false;\\n                int j;\\n                for(j =0;j<26;j++){  // to traverse string starting from a, b ,c , d and so on\\n                    if(curr->arr[j]!=NULL)\\n                    result=result|searchUtilDFS(curr->arr[j],word.substr(i+1)); \\n                    if(result)return true;  \\n                }\\n                return false;\\n            }\\n        }\\n       return curr->isend; // why we are returing this coz lets suppose\\n\\t   //we have \" b u d d y \" stored in trie and we are searching for \" b u d \" \\n\\t   //it should return false correct??  so when we are at d, return curr->isend \\n\\t   // will return false as it is not the end of the string.\\n\\t   \\n    }\\n    bool search(string word) {\\n        //in searching part , we have to take care of the dot.\\n        //if we are encountering dot then we can have to take all possible cases that is all 26 alphabets\\n        //lets suppose we need to search a string like this b * d, so getting b is straight forward\\n        //however for the next part *, we have to check all 26 alphabets which can possibly have\\n        // d as the last character.\\n        //lets see the code\\n        Trie *curr=root;\\n        return searchUtilDFS(curr,word);\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n ```\\n \\n Thanks for reading the whole explanation. Apologies if you got lost somewhere but try to dry run and\\n you will have your way !!\\n If it helped, dont forget to upvote !!\\n Thanks !!!",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nthe one obvious solution is adding the string into a set or may be unordered_set and for searching\\nany string you can use regex  but the time complexity of such kind of solution will be large and \\nthis is not the recommended solution if asked in interview\\nSo then, what should we do? We can use TRIE.\\nWAIT WHAT !!! WHAT THE HECK IS TRIE IS?? I am a beginner. I dont understand what trie is!!!!\\nWell your wait is over and today you will learn what trie is.\\n\\nWell TRIE is a fancy name of a data structure which contains an array of pointers pointing to nodes like \\nitself. Well, this is a lame way of putting it. But this will do the job as of now.\\nWhat i am saying is written in the below code:\\nstruct Trie{\\n        Trie *arr[26];  // an array of pointers pointing to the data type of Trie type\\n        bool isend;\\n        Trie(){    //constructor for initializing those pointers to NULL\\n            for(int i =0;i<26;i++){\\n                arr[i]=NULL;\\n            }\\n            isend=false;\\n        }\\n    };\\n\\t\\nWell, does this remind you of sort of linked list data structure?? No?? Just a sec, it isnt exaclty the same\\nbut it kinda resembles\\n\\nclass Node{--------------------------->struct Trie{\\n\\tint data;                                 bool isend;\\n\\tNode *next; ------------------------------>Trie *arr[26]; \\n\\t// the only diff is  in Node , we have 1 pointer and in trie we have an array of pointers.\\n}\\nwell as of now, you have understood the basic structure of TRIE, but how this is helping us to solve\\nthe solution. Lets understand\\n\\nThis is the representation of a trie with 26 pointers (why 26? bcoz there are 26 alphabets dude!!)\\n\\n               Root\\n\\t\\t\\t      |\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n----------------------------------------------------------------------------------------------------\\n\\nand now we want to store lets say \"bud\" in our trie. Initially all pointers are NULL and we will store\\n\" b u d\" character by character.\\n\\nSo first we will store \" b \". wo we will go to the pointer which is responsible for storing \" b \".\\nBut we have an array of pointers right, so how to access that index of the array which is pointing\\nto \" b \"?? Simple dude !!!  Do --->  word[i]-\\'a\\'  so \\'b\\'-\\'a\\' and it will give 1. Please do not ask me \\nhow this is possbile ?? ascii values pal !!!!!!! well i am not going to explain this to you :( !!\\nSo we will go to the index 1 which logically says that i am b and we will create a node and will\\nmake that pointer pointing to that new node. Just a sec, i hope you know that we need not to\\nstore this \"b\" right? bcoz that task is already taken care by the index of our pointer of arrays.\\n\\nNow our trie looks like this now :\\n                 Root\\n\\t\\t\\t      |\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n----|------------------------------------------------------------------------------------------------\\n    |\\n    |\\n   \\\\|/    this is our new node which is being pointed by b\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n----------------------------------------------------------------------------------------------------\\nSimilarly we can add \" u \", so now our trie looks like this :\\n===========================================================\\n\\n                 Root\\n\\t\\t\\t      |\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n----|------------------------------------------------------------------------------------------------\\n    |\\n    |\\n   \\\\|/    this is our new node which is being pointed by b\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n--------------------------------------------------------------------------------|--------------------\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t|\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t|\\n\\t\\t\\t\\t                                 a new node pointed by \" u \"   \\\\|/\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n----------------------------------------------------------------------------------------------------\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\nNow time to store \" d \" of \"bud\".So now our trie looks like this :\\n================================================================\\n\\n                 Root\\n\\t\\t\\t      |\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n----|------------------------------------------------------------------------------------------------\\n    |\\n    |\\n   \\\\|/    this is our new node which is being pointed by b\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n--------------------------------------------------------------------------------|--------------------\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t|\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t|\\n\\t\\t\\t\\t                                 a new node pointed by \" u \"   \\\\|/\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n------------|----------------------------------------------------------------------------------------\\n\\t\\t    |\\n\\t\\t\\t|\\n\\t\\t   \\\\|/ a new node pointed by \"d \"\\n----------------------------------------------------------------------------------------------------\\na | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z\\n----------------------------------------------------------------------------------------------------\\nheyy wait , isnt this the end of the string ? yes?? so set **isend** to true for node \\'d\\' (which is\\nbeing pointed by \"u\").\\nIn a similar manner you will do insertion of other elements. Do a dry run on your own, you\\nwill get it!! I am sure of it !!\\n\\nThis was the insertion part of it. But now how to search any element?\\nSimple just pick up the character , go to its index by doing word[i]-\\'a\\' and check\\nif it is null or not. if it is null, then that means that character is not present and return false\\notherwise go furthur to the node which is pointed by that node. \\nLets say if curr is the current node, then for moving further, do curr=curr->array_of_pointers[i] \\ni refers to the current character which we are looking for.\\nOk ok , i know , the next question is what to do if we have dot (.) , well in that case you need to check\\nall the characters and perform the same traversal steps. \\nOkayy, so far i think you have the prerequisite knowledge and now you can see the below code:\\n\\nstruct Trie{\\n        Trie *arr[26];    //nothing fancy, bunch of pointers \\n        bool isend;    // to mark the end of the string\\n        Trie(){    //constructor to initialize all pointers to null intitally\\n            for(int i =0;i<26;i++){\\n                arr[i]=NULL;\\n            }\\n            isend=false;\\n        }\\n    };\\n\\nclass WordDictionary {\\npublic:\\n    /* \\n    by reading the problem , one can easily guess that alternative solution is TRIE coz it\\n    is a perfect data structure when you are dealing with prefixes or sufixes.\\n    first things first , we need to create a TRIE \\n    */\\n    Trie *root;    //our mighty root node\\n    \\n    WordDictionary() {\\n        root=new Trie();      //creation of the root node\\n    }\\n    \\n    void addWord(string word) {\\n        Trie *curr=root;                   \\n        int length=word.size();\\n        int index;\\n        for(int i =0;i<length;i++){   //inserting the character one by one\\n            index=word[i]-\\'a\\';\\n            if(curr->arr[index]==NULL){       //if that character is not present, \\n\\t\\t\\t//then create a node and point to it and if it is already present (for example- you have inserted\\n\\t\\t\\t//\"bad\" and now you are inserting \"bud\", so b is already there, so you dont have to do anything\\n\\t\\t\\t//thats the beauty of trie\\n                curr->arr[index]=new Trie();\\n            }\\n            curr=curr->arr[index];\\n        }\\n        curr->isend=true; //marking the end of the string\\n    }\\n    \\n    bool searchUtilDFS(Trie *curr,string word){\\n        //Note : we only need to perform dfs when we encounter dot\\n        int length=word.size();\\n        int index;\\n        for(int i =0;i<length;i++){\\n            if(word[i]!=\\'.\\'){  //simply traverse the TRIE\\n                index=word[i]-\\'a\\';\\n                if(curr->arr[index]==NULL){\\n                    // that element doesnt exist\\n                    return false;\\n                }\\n                curr=curr->arr[index];\\n            }else{\\n                //we encounter the dot operator\\n                //so we need to consider all possibilities that is string starting from a,b,c,d,e....so on\\n                bool result=false;\\n                int j;\\n                for(j =0;j<26;j++){  // to traverse string starting from a, b ,c , d and so on\\n                    if(curr->arr[j]!=NULL)\\n                    result=result|searchUtilDFS(curr->arr[j],word.substr(i+1)); \\n                    if(result)return true;  \\n                }\\n                return false;\\n            }\\n        }\\n       return curr->isend; // why we are returing this coz lets suppose\\n\\t   //we have \" b u d d y \" stored in trie and we are searching for \" b u d \" \\n\\t   //it should return false correct??  so when we are at d, return curr->isend \\n\\t   // will return false as it is not the end of the string.\\n\\t   \\n    }\\n    bool search(string word) {\\n        //in searching part , we have to take care of the dot.\\n        //if we are encountering dot then we can have to take all possible cases that is all 26 alphabets\\n        //lets suppose we need to search a string like this b * d, so getting b is straight forward\\n        //however for the next part *, we have to check all 26 alphabets which can possibly have\\n        // d as the last character.\\n        //lets see the code\\n        Trie *curr=root;\\n        return searchUtilDFS(curr,word);\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1725724,
                "title": "map-vector-c",
                "content": "```\\nclass WordDictionary {\\npublic:\\n    map<size_t, vector<string>> words;\\n    WordDictionary() {\\n        \\n    }\\n    bool my_find(string word) {\\n        vector<string> cand = words[word.size()];\\n        for (int i = 0; i < cand.size(); i++) {\\n            int j = 0;\\n            while (j < word.size()) {\\n                if (word[j] == cand[i][j] || word[j] == \\'.\\' || cand[i][j] == \\'.\\') {\\n                    j++;\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            if (j == word.size()) {\\n                return true;\\n            }\\n        }\\n            \\n        return false;\\n    }\\n    void addWord(string word) {\\n        words[word.size()].push_back(word);\\n    }\\n    \\n    bool search(string word) {\\n        return my_find(word);\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```\\n\\nFeel free to ask doubts.\\nAnd please share some suggestions.\\nHappy coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass WordDictionary {\\npublic:\\n    map<size_t, vector<string>> words;\\n    WordDictionary() {\\n        \\n    }\\n    bool my_find(string word) {\\n        vector<string> cand = words[word.size()];\\n        for (int i = 0; i < cand.size(); i++) {\\n            int j = 0;\\n            while (j < word.size()) {\\n                if (word[j] == cand[i][j] || word[j] == \\'.\\' || cand[i][j] == \\'.\\') {\\n                    j++;\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n            if (j == word.size()) {\\n                return true;\\n            }\\n        }\\n            \\n        return false;\\n    }\\n    void addWord(string word) {\\n        words[word.size()].push_back(word);\\n    }\\n    \\n    bool search(string word) {\\n        return my_find(word);\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205334,
                "title": "easy-js-solution-using-hashmap",
                "content": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar WordDictionary = function() {\\n    this.m = new Map(); // (length x, list of strings of length x)\\n    // T.C: O(1)\\n};\\n\\n/** \\n * @param {string} word\\n * @return {void}\\n */\\nWordDictionary.prototype.addWord = function(word) {\\n    let len = word.length;\\n    if (this.m.has(len)) {\\n        this.m.get(len).push(word);\\n    } else {\\n        this.m.set(len, [word]);\\n    }\\n    // T.C: O(1)\\n};\\n\\n/** \\n * @param {string} word\\n * @return {boolean}\\n */\\nWordDictionary.prototype.search = function(word) {\\n    let len = word.length;\\n    if (!this.m.has(len)) {\\n        return false;\\n    }\\n    let words = this.m.get(len);\\n    for (let i = 0; i < words.length; i++) {\\n        let match = true;\\n        for (let j = 0; j < words[i].length; j++) {\\n            if (word[j] !== \".\" && word[j] !== words[i][j]) {\\n                match = false;\\n                break;\\n            }\\n        }\\n        if (match) {\\n            return true;\\n        }\\n    }\\n    return false;\\n    // T.C: O(k*N), where k = length of word, N = # of words\\n};\\n\\n/** \\n * Your WordDictionary object will be instantiated and called as such:\\n * var obj = new WordDictionary()\\n * obj.addWord(word)\\n * var param_2 = obj.search(word)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar WordDictionary = function() {\\n    this.m = new Map(); // (length x, list of strings of length x)\\n    // T.C: O(1)\\n};\\n\\n/** \\n * @param {string} word\\n * @return {void}\\n */\\nWordDictionary.prototype.addWord = function(word) {\\n    let len = word.length;\\n    if (this.m.has(len)) {\\n        this.m.get(len).push(word);\\n    } else {\\n        this.m.set(len, [word]);\\n    }\\n    // T.C: O(1)\\n};\\n\\n/** \\n * @param {string} word\\n * @return {boolean}\\n */\\nWordDictionary.prototype.search = function(word) {\\n    let len = word.length;\\n    if (!this.m.has(len)) {\\n        return false;\\n    }\\n    let words = this.m.get(len);\\n    for (let i = 0; i < words.length; i++) {\\n        let match = true;\\n        for (let j = 0; j < words[i].length; j++) {\\n            if (word[j] !== \".\" && word[j] !== words[i][j]) {\\n                match = false;\\n                break;\\n            }\\n        }\\n        if (match) {\\n            return true;\\n        }\\n    }\\n    return false;\\n    // T.C: O(k*N), where k = length of word, N = # of words\\n};\\n\\n/** \\n * Your WordDictionary object will be instantiated and called as such:\\n * var obj = new WordDictionary()\\n * obj.addWord(word)\\n * var param_2 = obj.search(word)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866767,
                "title": "c-trie-dfs-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/design-add-and-search-words-data-structure/submissions/\\n    \\n    Idea is to use a Trie for adding the words. Now since we have a special char \\'.\\'\\n    which can match any single char, so we need to look into all possible cmb from that point.\\n    We can use DFS for searching, when we get \\'.\\' we do DFS for all the leaves nodes for\\n    the current level of Trie and check any of the DFS is able to find the complete pattern\\n    sequence.\\n*/\\n\\nclass WordDictionary {\\n    struct TrieNode {\\n        unordered_map<char, TrieNode*> leaves;\\n        bool is_string = false;\\n    };\\n    \\n    TrieNode *root_ = nullptr;\\npublic:\\n    /** Initialize your data structure here. */\\n    WordDictionary() {\\n        root_ = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    // TC: O(L)\\n    void addWord(string word) {\\n        TrieNode *root = root_;\\n        \\n        for(char &c: word) {\\n            // Create a node if it doesn\\'t exists for current char\\n            if(root->leaves.count(c) == 0)\\n                root->leaves[c] = new TrieNode();\\n            root = root->leaves[c];\\n        }\\n        // mark the end of string\\n        root->is_string = true;\\n    }\\n    \\n    // Searches for a word in Trie\\n    // TC: O(n * L), L: length of longest word\\n    // Worst case: when all the chars are . and all words in Trie are of same length\\n    bool searchWord(int idx, TrieNode *root, string &word) {\\n        // all the chars coevered, check if the current node marks\\n        // string end\\n        if(idx == word.size())\\n            return root->is_string;\\n        \\n        // if . char, match with all available chars at the current level\\n        if(word[idx] == \\'.\\') {\\n            for(auto it = root->leaves.begin(); it != root->leaves.end(); it++) {\\n                if(searchWord(idx+1, it->second, word))\\n                    return true;\\n            }\\n        }\\n        else if(root->leaves.count(word[idx]))\\n                return searchWord(idx+1, root->leaves[word[idx]], word);\\n        \\n        return false;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word) {\\n        return searchWord(0, root_, word);\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/design-add-and-search-words-data-structure/submissions/\\n    \\n    Idea is to use a Trie for adding the words. Now since we have a special char \\'.\\'\\n    which can match any single char, so we need to look into all possible cmb from that point.\\n    We can use DFS for searching, when we get \\'.\\' we do DFS for all the leaves nodes for\\n    the current level of Trie and check any of the DFS is able to find the complete pattern\\n    sequence.\\n*/\\n\\nclass WordDictionary {\\n    struct TrieNode {\\n        unordered_map<char, TrieNode*> leaves;\\n        bool is_string = false;\\n    };\\n    \\n    TrieNode *root_ = nullptr;\\npublic:\\n    /** Initialize your data structure here. */\\n    WordDictionary() {\\n        root_ = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    // TC: O(L)\\n    void addWord(string word) {\\n        TrieNode *root = root_;\\n        \\n        for(char &c: word) {\\n            // Create a node if it doesn\\'t exists for current char\\n            if(root->leaves.count(c) == 0)\\n                root->leaves[c] = new TrieNode();\\n            root = root->leaves[c];\\n        }\\n        // mark the end of string\\n        root->is_string = true;\\n    }\\n    \\n    // Searches for a word in Trie\\n    // TC: O(n * L), L: length of longest word\\n    // Worst case: when all the chars are . and all words in Trie are of same length\\n    bool searchWord(int idx, TrieNode *root, string &word) {\\n        // all the chars coevered, check if the current node marks\\n        // string end\\n        if(idx == word.size())\\n            return root->is_string;\\n        \\n        // if . char, match with all available chars at the current level\\n        if(word[idx] == \\'.\\') {\\n            for(auto it = root->leaves.begin(); it != root->leaves.end(); it++) {\\n                if(searchWord(idx+1, it->second, word))\\n                    return true;\\n            }\\n        }\\n        else if(root->leaves.count(word[idx]))\\n                return searchWord(idx+1, root->leaves[word[idx]], word);\\n        \\n        return false;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word) {\\n        return searchWord(0, root_, word);\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774544,
                "title": "javascript-clean-trie-solution",
                "content": "```javascript\\nclass Node {\\n    constructor() {\\n        this.children = new Map();\\n        this.end = false;\\n    }\\n}\\n\\nclass WordDictionary {\\n    constructor() {\\n        this.root = new Node();\\n    }\\n    \\n    addWord(word) {\\n        function add(node, i) {\\n            if(i === word.length) return node.end = true;\\n            if(!node.children.has(word[i])) node.children.set(word[i], new Node());\\n            add(node.children.get(word[i]), i+1);\\n        }\\n        add(this.root, 0);\\n    }\\n    \\n    search(word) {\\n        function find(node, i) {\\n            if(i === word.length && node.end) return true;\\n            if(i === word.length) return false;\\n            \\n            if(word[i] === \\'.\\') {\\n                for(let [key, next] of node.children) {\\n                    if(find(next, i+1)) return true;\\n                }\\n                return false;\\n            }\\n            if(!node.children.has(word[i])) return false;\\n            return find(node.children.get(word[i]), i+1);\\n        }\\n        return find(this.root, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nclass Node {\\n    constructor() {\\n        this.children = new Map();\\n        this.end = false;\\n    }\\n}\\n\\nclass WordDictionary {\\n    constructor() {\\n        this.root = new Node();\\n    }\\n    \\n    addWord(word) {\\n        function add(node, i) {\\n            if(i === word.length) return node.end = true;\\n            if(!node.children.has(word[i])) node.children.set(word[i], new Node());\\n            add(node.children.get(word[i]), i+1);\\n        }\\n        add(this.root, 0);\\n    }\\n    \\n    search(word) {\\n        function find(node, i) {\\n            if(i === word.length && node.end) return true;\\n            if(i === word.length) return false;\\n            \\n            if(word[i] === \\'.\\') {\\n                for(let [key, next] of node.children) {\\n                    if(find(next, i+1)) return true;\\n                }\\n                return false;\\n            }\\n            if(!node.children.has(word[i])) return false;\\n            return find(node.children.get(word[i]), i+1);\\n        }\\n        return find(this.root, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774524,
                "title": "unordered-maps-c-solution",
                "content": "```\\nclass WordDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<int,vector<string>> map;\\n    \\n    bool check(string a,string b)\\n    {\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==\\'.\\')\\n                continue;\\n            else if(a[i]!=b[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    \\n    \\n    WordDictionary() {\\n        \\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        \\n        int n=word.size();\\n        map[n].push_back(word);\\n        \\n        \\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word) {\\n        \\n        int n=word.size();\\n        for(string s : map[n])\\n        {\\n            if(check(word,s))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<int,vector<string>> map;\\n    \\n    bool check(string a,string b)\\n    {\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==\\'.\\')\\n                continue;\\n            else if(a[i]!=b[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    \\n    \\n    WordDictionary() {\\n        \\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        \\n        int n=word.size();\\n        map[n].push_back(word);\\n        \\n        \\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word) {\\n        \\n        int n=word.size();\\n        for(string s : map[n])\\n        {\\n            if(check(word,s))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774271,
                "title": "c-trie-solution-264-ms-solution",
                "content": "***Runtime: 264 ms, faster than 34.25% of C++ online submissions for Add and Search Word - Data structure design.\\nMemory Usage: 45.4 MB, less than 55.28% of C++ online submissions for Add and Search Word - Data structure design.***\\n```\\nclass TrieNode{\\n    public:\\n        vector<TrieNode*> next;\\n        bool isWord = false;\\n        TrieNode(){\\n            next.resize(26, NULL);\\n        }\\n};\\n\\nclass WordDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    TrieNode* root;\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        TrieNode* current = root;\\n        for(char ch:word){\\n            if(!current->next[ch - \\'a\\']){\\n                current->next[ch - \\'a\\'] = new TrieNode();\\n            }\\n            current = current->next[ch - \\'a\\'];\\n        }\\n        current->isWord = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word) {\\n        return searchHelper(word, root);\\n    }\\nprivate:\\n    \\n    bool searchHelper(string word, TrieNode* current) {\\n        for(int i = 0; i < word.size(); i++){\\n            char ch = word[i];\\n            if(ch != \\'.\\'){\\n                if(!current->next[ch - \\'a\\']) \\n                    return false;\\n                current = current->next[ch - \\'a\\'];\\n            }\\n            else{\\n                for(int j = 0; j < 26; j++){\\n                    if(current->next[j] && searchHelper(word.substr(i + 1), current->next[j])){\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n        return current->isWord;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass TrieNode{\\n    public:\\n        vector<TrieNode*> next;\\n        bool isWord = false;\\n        TrieNode(){\\n            next.resize(26, NULL);\\n        }\\n};\\n\\nclass WordDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    TrieNode* root;\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        TrieNode* current = root;\\n        for(char ch:word){\\n            if(!current->next[ch - \\'a\\']){\\n                current->next[ch - \\'a\\'] = new TrieNode();\\n            }\\n            current = current->next[ch - \\'a\\'];\\n        }\\n        current->isWord = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word) {\\n        return searchHelper(word, root);\\n    }\\nprivate:\\n    \\n    bool searchHelper(string word, TrieNode* current) {\\n        for(int i = 0; i < word.size(); i++){\\n            char ch = word[i];\\n            if(ch != \\'.\\'){\\n                if(!current->next[ch - \\'a\\']) \\n                    return false;\\n                current = current->next[ch - \\'a\\'];\\n            }\\n            else{\\n                for(int j = 0; j < 26; j++){\\n                    if(current->next[j] && searchHelper(word.substr(i + 1), current->next[j])){\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            }\\n        }\\n        return current->isWord;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739115,
                "title": "simplest-solution-possible-in-c-explanation-given",
                "content": "```\\n// Trie Solution provided\\nclass TrieNode{\\n  public:\\n    bool isEnd;\\n\\tvector<TrieNode*> dict;\\n    TrieNode(){\\n        isEnd = false;\\n        dict.resize(26,nullptr);\\n    }\\n};\\nclass WordDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    TrieNode* root;\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n\\t// Addition of word in the trie is fairly simple.\\n\\t// If you are not able to understand it, then solve the below question first :\\n\\t// https://leetcode.com/problems/implement-trie-prefix-tree/\\n    void addWord(string word) {\\n        TrieNode* itr = root;\\n        for(int i=0;i<word.length();i++){\\n            if(itr->dict[word[i]-\\'a\\']==nullptr){\\n                itr->dict[word[i]-\\'a\\'] = new TrieNode();\\n            }\\n            itr = itr->dict[word[i]-\\'a\\'];\\n        }\\n        itr->isEnd = true;\\n    }\\n\\n\\n\\t// Recursive function for searching the string in the trie.\\n    bool func(TrieNode* root, string word, int pos){\\n\\t\\t// When pos becomes equal to length of the word i.e. we are at the end of the string.\\n        if(word.length()==pos){\\n\\t\\t\\t// If the string is present in the trie then \"root\" will be at the end of the trie.\\n            if(root->isEnd)\\n                return true;\\n            return false;\\n        }\\n\\t\\t// If the character is not \\'.\\' then it is fairly simple.\\n\\t\\t// We just need to check whether the word[pos] is present in the trie or not.\\n        if(word[pos]!=\\'.\\'){\\n            if(root->dict[word[pos]-\\'a\\']!=nullptr)\\n                return func(root->dict[word[pos]-\\'a\\'], word,pos+1);\\n            else\\n                return false;\\n        }\\n        else{\\n\\t\\t\\t// Now, if we encounter \\'.\\' then we need to check every possible alphabet i.e. from a-z\\n\\t\\t\\t// If we find any alphabet which is present in the trie,\\n\\t\\t\\t// then we have to make the recursive call to the function with now --> pos + 1.\\n\\t\\t\\t// If we encounter null node then we will continue and check the rest of the alphabets.\\n            for(int i=0;i<26;i++){\\n                if(root->dict[i]==nullptr)\\n                    continue;\\n                else{\\n                    if(func(root->dict[i],word,pos+1))\\n                        return true;\\n                }\\n            }\\n        }\\n\\t\\t// If after checking everything, we don\\'t find the alphabet in the trie ->\\n        return false;\\n    }\\n    bool search(string word) {\\n        return func(root, word, 0);\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```\\n\\nIf  you are still facing problems, then do ask your questions int the **comment** section.\\nIf you have any other efficient ways, then do mention it in the **comment** section.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\n// Trie Solution provided\\nclass TrieNode{\\n  public:\\n    bool isEnd;\\n\\tvector<TrieNode*> dict;\\n    TrieNode(){\\n        isEnd = false;\\n        dict.resize(26,nullptr);\\n    }\\n};\\nclass WordDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    TrieNode* root;\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n\\t// Addition of word in the trie is fairly simple.\\n\\t// If you are not able to understand it, then solve the below question first :\\n\\t// https://leetcode.com/problems/implement-trie-prefix-tree/\\n    void addWord(string word) {\\n        TrieNode* itr = root;\\n        for(int i=0;i<word.length();i++){\\n            if(itr->dict[word[i]-\\'a\\']==nullptr){\\n                itr->dict[word[i]-\\'a\\'] = new TrieNode();\\n            }\\n            itr = itr->dict[word[i]-\\'a\\'];\\n        }\\n        itr->isEnd = true;\\n    }\\n\\n\\n\\t// Recursive function for searching the string in the trie.\\n    bool func(TrieNode* root, string word, int pos){\\n\\t\\t// When pos becomes equal to length of the word i.e. we are at the end of the string.\\n        if(word.length()==pos){\\n\\t\\t\\t// If the string is present in the trie then \"root\" will be at the end of the trie.\\n            if(root->isEnd)\\n                return true;\\n            return false;\\n        }\\n\\t\\t// If the character is not \\'.\\' then it is fairly simple.\\n\\t\\t// We just need to check whether the word[pos] is present in the trie or not.\\n        if(word[pos]!=\\'.\\'){\\n            if(root->dict[word[pos]-\\'a\\']!=nullptr)\\n                return func(root->dict[word[pos]-\\'a\\'], word,pos+1);\\n            else\\n                return false;\\n        }\\n        else{\\n\\t\\t\\t// Now, if we encounter \\'.\\' then we need to check every possible alphabet i.e. from a-z\\n\\t\\t\\t// If we find any alphabet which is present in the trie,\\n\\t\\t\\t// then we have to make the recursive call to the function with now --> pos + 1.\\n\\t\\t\\t// If we encounter null node then we will continue and check the rest of the alphabets.\\n            for(int i=0;i<26;i++){\\n                if(root->dict[i]==nullptr)\\n                    continue;\\n                else{\\n                    if(func(root->dict[i],word,pos+1))\\n                        return true;\\n                }\\n            }\\n        }\\n\\t\\t// If after checking everything, we don\\'t find the alphabet in the trie ->\\n        return false;\\n    }\\n    bool search(string word) {\\n        return func(root, word, 0);\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339954,
                "title": "javascript-beats-100-easy-to-understand",
                "content": "```\\nvar WordDictionary = function() {\\n\\t//using an obj to store added strings\\n    this.map = {}\\n};\\n\\n/**\\n * Adds a word into the data structure. \\n * @param {string} word\\n * @return {void}\\n */\\nWordDictionary.prototype.addWord = function(word) {\\n    //using the length of stings as index to avoid full traversal\\n    if (word.length in this.map) {\\n        this.map[word.length].push(word)\\n    } else {\\n        this.map[word.length] = [word]\\n    }\\n};\\n\\n/**\\n * Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. \\n * @param {string} word\\n * @return {boolean}\\n */\\nWordDictionary.prototype.search = function(word) {\\n    let len = word.length\\n    if (len in this.map) {\\n        for (let i = 0; i < this.map[len].length; i++) {\\n            for (var j = 0; j < len; j++) {\\n                //compare with the stored strings which have same length\\n                if (word[j] !== \\'.\\' && word[j] !== this.map[len][i][j]) {\\n                    break\\n                }\\n            }\\n            if (j === len) {\\n                return true\\n            }            \\n        }\\n    }\\n    return false\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar WordDictionary = function() {\\n\\t//using an obj to store added strings\\n    this.map = {}\\n};\\n\\n/**\\n * Adds a word into the data structure. \\n * @param {string} word\\n * @return {void}\\n */\\nWordDictionary.prototype.addWord = function(word) {\\n    //using the length of stings as index to avoid full traversal\\n    if (word.length in this.map) {\\n        this.map[word.length].push(word)\\n    } else {\\n        this.map[word.length] = [word]\\n    }\\n};\\n\\n/**\\n * Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. \\n * @param {string} word\\n * @return {boolean}\\n */\\nWordDictionary.prototype.search = function(word) {\\n    let len = word.length\\n    if (len in this.map) {\\n        for (let i = 0; i < this.map[len].length; i++) {\\n            for (var j = 0; j < len; j++) {\\n                //compare with the stored strings which have same length\\n                if (word[j] !== \\'.\\' && word[j] !== this.map[len][i][j]) {\\n                    break\\n                }\\n            }\\n            if (j === len) {\\n                return true\\n            }            \\n        }\\n    }\\n    return false\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3224552,
                "title": "211-beats-99-15-and-beats-97-15-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe WordDictionary class is a data structure that supports adding new words and searching if a string matches any previously added string.\\n\\nThe class has three methods:\\n\\n- __init__(self): Initializes the object and creates a defaultdict of sets to store the words. The keys of the dictionary are the length of the words, and the values are sets of words of that length.\\n- addWord(self, word: str) -> None: Adds a word to the data structure by inserting it into the set of words with the same length in the dictionary.\\n- search(self, word: str) -> bool: Searches for a word in the data structure. If the word doesn\\'t contain a dot character \\'.\\', it checks if the word exists in the set of words with the same length. If the word contains dots, it iterates over all words of the same length and checks if each character in the word matches the corresponding character in the word being searched, except for the dots.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n99.15%\\n\\n- Space complexity:\\nBeats\\n97.15%\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\" Initialize your data structure here. \"\"\"\\n        # create a defaultdict of sets to store the words\\n        # keys are word lengths, values are sets of words of that length\\n        self.dic = defaultdict(set)\\n\\n    def addWord(self, word: str) -> None:\\n        \"\"\" Adds a word into the data structure. \"\"\"\\n        # add the word to the set of words with the same length\\n        self.dic[len(word)].add(word)\\n\\n    def search(self, word: str) -> bool:\\n        \"\"\" Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. \"\"\"\\n        # if the word doesn\\'t contain dots, check if it exists in the set of words with the same length\\n        if \\'.\\' not in word:\\n            return word in self.dic[len(word)]\\n        # if the word contains dots, iterate over all words of the same length\\n        for v in self.dic[len(word)]:\\n            # check if each character in the word matches the corresponding character in the word being searched, except for the dots\\n            for i, ch in enumerate(word):\\n                if ch != v[i] and ch != \\'.\\':\\n                    break\\n            else:\\n                return True\\n        # if no matching word is found, return False\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Depth-First Search",
                    "Design"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\" Initialize your data structure here. \"\"\"\\n        # create a defaultdict of sets to store the words\\n        # keys are word lengths, values are sets of words of that length\\n        self.dic = defaultdict(set)\\n\\n    def addWord(self, word: str) -> None:\\n        \"\"\" Adds a word into the data structure. \"\"\"\\n        # add the word to the set of words with the same length\\n        self.dic[len(word)].add(word)\\n\\n    def search(self, word: str) -> bool:\\n        \"\"\" Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. \"\"\"\\n        # if the word doesn\\'t contain dots, check if it exists in the set of words with the same length\\n        if \\'.\\' not in word:\\n            return word in self.dic[len(word)]\\n        # if the word contains dots, iterate over all words of the same length\\n        for v in self.dic[len(word)]:\\n            # check if each character in the word matches the corresponding character in the word being searched, except for the dots\\n            for i, ch in enumerate(word):\\n                if ch != v[i] and ch != \\'.\\':\\n                    break\\n            else:\\n                return True\\n        # if no matching word is found, return False\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088327,
                "title": "simple-js-solution-w-comments-trie",
                "content": "```\\n/**\\n * *Time: O(M) - well defined words, words wihtout ...\\n * *Time: O(N x 26^M) - N = number of keys and 26^M for undefined words\\n * *Space: O(1) - well defined words\\n * *Space: O(M) - undefined words\\n */\\n// Runtime: 2153 ms, faster than 32.71% of JavaScript online submissions for Design Add and Search Words Data Structure.\\n// Memory Usage: 99.1 MB, less than 25.69% of JavaScript online submissions for Design Add and Search Words Data Structure.\\nclass WordDictionary {\\n  constructor() {\\n    this.root = {};\\n  }\\n\\n  addWord(word) {\\n    let node = this.root;\\n\\n    for (const char of word) {\\n      if (!node[char]) node[char] = {};\\n\\n      node = node[char];\\n    }\\n\\n    node.isEnd = true;\\n  }\\n\\n  search(word) {\\n    const traverse = (node, i) => {\\n      const char = word[i];\\n\\n      // reached end of word, check if word exists\\n      if (i === word.length) return node.isEnd || false;\\n\\n      // if wildcard, iterate every possible keys and check if word exists\\n      // if valid char exist, recursively check if other characters of the word exist\\n      // else return false\\n      if (char == \\'.\\') {\\n        for (const key in node) {\\n          if (traverse(node[key], i + 1)) return true;\\n        }\\n      } else if (node[char]) return traverse(node[char], i + 1);\\n\\n      return false;\\n    };\\n\\n    return traverse(this.root, 0);\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n/**\\n * *Time: O(M) - well defined words, words wihtout ...\\n * *Time: O(N x 26^M) - N = number of keys and 26^M for undefined words\\n * *Space: O(1) - well defined words\\n * *Space: O(M) - undefined words\\n */\\n// Runtime: 2153 ms, faster than 32.71% of JavaScript online submissions for Design Add and Search Words Data Structure.\\n// Memory Usage: 99.1 MB, less than 25.69% of JavaScript online submissions for Design Add and Search Words Data Structure.\\nclass WordDictionary {\\n  constructor() {\\n    this.root = {};\\n  }\\n\\n  addWord(word) {\\n    let node = this.root;\\n\\n    for (const char of word) {\\n      if (!node[char]) node[char] = {};\\n\\n      node = node[char];\\n    }\\n\\n    node.isEnd = true;\\n  }\\n\\n  search(word) {\\n    const traverse = (node, i) => {\\n      const char = word[i];\\n\\n      // reached end of word, check if word exists\\n      if (i === word.length) return node.isEnd || false;\\n\\n      // if wildcard, iterate every possible keys and check if word exists\\n      // if valid char exist, recursively check if other characters of the word exist\\n      // else return false\\n      if (char == \\'.\\') {\\n        for (const key in node) {\\n          if (traverse(node[key], i + 1)) return true;\\n        }\\n      } else if (node[char]) return traverse(node[char], i + 1);\\n\\n      return false;\\n    };\\n\\n    return traverse(this.root, 0);\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726631,
                "title": "c-trie-vs-hashmap-solutions-explained-100-time-40ms-99-space-30-7mb",
                "content": "Handbook example of a problem which is desperately screaming \"solve me witha trie!\" as you even glance to through the code template; and thus we will fulfill this heartfelt plea.\\n\\nLet\\'s start with declaring our `Trie` class, which will just contain two properties:\\n* `eow` will mark if the current node is an end of the word, defaulted to `false`;\\n* `children` is an array of `26` `Trie` pointers, defaulted to `NULL`.\\n\\nIn our class we will define just three variables:\\n* `root` and `curr` are `Trie` pointers we will use to handle creation and search of our trie;\\n* `res` is a boolean that we will use in our search routine.\\n\\nIn our constructor, we will just initialised `root` to point to an empty `Trie`.\\n\\n`addWord` will take a `word` (passed as a reference) and:\\n* set `curr` to point initially to `root`;\\n* for each character `c`:\\n\\t* reduce `c` to the `0 - 25` range, subtracting `\\'a\\'` from it;\\n\\t* check if we already have `curr->children[c]` and if not, create it as a new node;\\n\\t* move `curr` to be `curr->children[c]`;\\n* set `curr->eow` to `true`, to mark the last node of a word.\\n\\n\\'searchWord` will work more interestingly on the same logic, and we added another parameter to it, `start`, that will default to `0` so that we in this method we can:\\n* check for the first base case - when we start looking for a word, we will have to reset `res` to `false` and `curr` to `root`;\\n* check if we already found a valid match (ie: `res == true`), in which case we just `return` `res`;\\n* check if we are at the end of the word (ie: `start == word.size()`), in which case we just `return` if we are on an ending word node or not (ie: the value of `curr->eow`);\\n* if not, we start dealing with the general case and store `word[start]` into `c`;\\n* if `c == \\'.\\'`, we will have to deal with a wild card character, thus we will:\\n\\t* declare `origCurr` to store the initial value of `curr` here;\\n\\t* iterate through each `child` in `curr->children` and:\\n\\t\\t* `continue` if `child` is `NULL`;\\n\\t\\t* set `curr` to be `child`;\\n\\t\\t* update `res` to the result of calling `searchWord` with an increaed value of `start`;\\n\\t\\t* check if we already reached a match and thus `break` out of the `loop` if we found it (ie: `res == true`);\\n\\t* backtrack `curr` to its initial value `origCurr`;\\n\\t* `return` `res`;\\n* for any other character, we will instead decrease `c` again by `\\'a\\'` to make it fit in our `0 - 25` range;\\n* `return` `false` if no child matches `c` in `curr`;\\n* update `curr` otherwise to be `curr->children[c]`;\\n* `return` the result of  calling `searchWord` with an increaed value of `start`.\\n\\nThe code:\\n\\n```cpp\\nstruct Trie {\\n    bool eow = false;\\n    Trie *children[26] = {};\\n};\\n\\nclass WordDictionary {\\n    Trie *root, *curr;\\n    bool res;\\npublic:\\n    WordDictionary() {\\n        // initialising the trie\\n        root = new Trie;\\n    }\\n    \\n    void addWord(const string &word) {\\n        // adding word to the trie using curr as a pointer\\n        curr = root;\\n        for (char c: word) {\\n            c -= \\'a\\';\\n            if (!curr->children[c]) curr->children[c] = new Trie();\\n            curr = curr->children[c];\\n        }\\n        curr->eow = true;\\n    }\\n    \\n    bool search(const string &word, int start = 0) {\\n        // base case: we start the search and thus set res to false\\n        if (!start) {\\n            res = false;\\n            curr = root;\\n        }\\n        // base case: we already found a match, so we stop recursing\\n        if (res) return res;\\n        // base case: we are done parsing the string\\n        if (start == word.size()) return curr->eow;\\n        // general case:\\n        char c = word[start];\\n        // wild card character\\n        if (c == \\'.\\') {\\n            Trie *origCurr = curr;\\n            for (auto child: curr->children) {\\n                if (!child) continue;\\n                curr = child;\\n                res |= this->search(word, start + 1);\\n                // stopping if we found a result already\\n                if (res) break;\\n            }\\n            // backtracking curr\\n            curr = origCurr;\\n            return res;\\n        }\\n        // any other character\\n        c -= \\'a\\';\\n        if (!curr->children[c]) return false;\\n        curr = curr->children[c];\\n        return this->search(word, start + 1);\\n    }\\n};\\n```\\n\\nI wanted to go for the lolz and get a quick and dirty solution just mapping words by length first and starting letter later (and in case of queries starting with `\\'.\\'`, we will go through all the words of the same length of the query).\\n\\n`matches` is our helper function to handle also wild card characters (in the second string) and the rest is pretty straightforward.\\n\\nI thought I would get awful performance, but it turns out I went pretty close (52ms in this version vs 40ms in the previous really surprised to see I actually used much less memory this way (30.7MB vs 43MB in the previous version).\\n\\nI guess I might mitigate a bit for queries starting with `\\'.\\'` storing words also by their final letter and then picking the smaller vector, but I would definitely burn much more memory and use more time initially to store them, so it would really depend on how this DS is used (longer words, more frequent `\\'.\\'` inital starting characters, etc.):\\n\\n```cpp\\nclass WordDictionary {\\n    unordered_map<int, unordered_map<char, vector<string>>> store;\\n    bool matches(const string &s1, const string &s2) {\\n        for (int i = 0, lmt = s1.size(); i < lmt; i++) {\\n            if (s1[i] != s2[i] && s2[i] != \\'.\\') return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    WordDictionary() {}\\n    \\n    void addWord(const string &word) {\\n        store[word.size()][word[0]].push_back(word);\\n    }\\n    \\n    bool search(const string &word) {\\n        int wLen = word.size();\\n        if (store.find(wLen) == end(store)) return false;\\n        char c = word[0];\\n        // first case: wild card - checking every single word in that bucket\\n        if (c == \\'.\\') {\\n            for (auto &bucket: store[wLen]) {\\n                for (auto &item: bucket.second) if (matches(item, word)) return true;\\n            }\\n            return false;\\n        }\\n        // second case: generic character\\n        if (store[wLen].find(c) == end(store[wLen])) return false;\\n        auto &bucket = store[wLen][c];\\n        for (auto &item: bucket) if (matches(item, word)) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nstruct Trie {\\n    bool eow = false;\\n    Trie *children[26] = {};\\n};\\n\\nclass WordDictionary {\\n    Trie *root, *curr;\\n    bool res;\\npublic:\\n    WordDictionary() {\\n        // initialising the trie\\n        root = new Trie;\\n    }\\n    \\n    void addWord(const string &word) {\\n        // adding word to the trie using curr as a pointer\\n        curr = root;\\n        for (char c: word) {\\n            c -= \\'a\\';\\n            if (!curr->children[c]) curr->children[c] = new Trie();\\n            curr = curr->children[c];\\n        }\\n        curr->eow = true;\\n    }\\n    \\n    bool search(const string &word, int start = 0) {\\n        // base case: we start the search and thus set res to false\\n        if (!start) {\\n            res = false;\\n            curr = root;\\n        }\\n        // base case: we already found a match, so we stop recursing\\n        if (res) return res;\\n        // base case: we are done parsing the string\\n        if (start == word.size()) return curr->eow;\\n        // general case:\\n        char c = word[start];\\n        // wild card character\\n        if (c == \\'.\\') {\\n            Trie *origCurr = curr;\\n            for (auto child: curr->children) {\\n                if (!child) continue;\\n                curr = child;\\n                res |= this->search(word, start + 1);\\n                // stopping if we found a result already\\n                if (res) break;\\n            }\\n            // backtracking curr\\n            curr = origCurr;\\n            return res;\\n        }\\n        // any other character\\n        c -= \\'a\\';\\n        if (!curr->children[c]) return false;\\n        curr = curr->children[c];\\n        return this->search(word, start + 1);\\n    }\\n};\\n```\n```cpp\\nclass WordDictionary {\\n    unordered_map<int, unordered_map<char, vector<string>>> store;\\n    bool matches(const string &s1, const string &s2) {\\n        for (int i = 0, lmt = s1.size(); i < lmt; i++) {\\n            if (s1[i] != s2[i] && s2[i] != \\'.\\') return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    WordDictionary() {}\\n    \\n    void addWord(const string &word) {\\n        store[word.size()][word[0]].push_back(word);\\n    }\\n    \\n    bool search(const string &word) {\\n        int wLen = word.size();\\n        if (store.find(wLen) == end(store)) return false;\\n        char c = word[0];\\n        // first case: wild card - checking every single word in that bucket\\n        if (c == \\'.\\') {\\n            for (auto &bucket: store[wLen]) {\\n                for (auto &item: bucket.second) if (matches(item, word)) return true;\\n            }\\n            return false;\\n        }\\n        // second case: generic character\\n        if (store[wLen].find(c) == end(store[wLen])) return false;\\n        auto &bucket = store[wLen][c];\\n        for (auto &item: bucket) if (matches(item, word)) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726115,
                "title": "c-solution-beats-100-time-and-memory",
                "content": "**Explanation:**\\nHere, an unordered map of vectors is taken which is acting as a Hash Map. Words are stored with respect to their sizes in the corresponsing vector in the hashmap. We iterate particular vector corresponding to the size of the supplied word to search (hence decreasing the time complexity). The given word is checked with each of the strings of corresponding vector and if there\\'s no string that matches the character wrt to the *search criteria* then we return false else we return true.\\n\\n**Search Criteria:** \\n* If all the characters are same - return true\\n* If some characters are different but there is a \\'.\\' character in the supplied word instead of the given character in the correspnding string (of vector) - return true \\n* All other cases - return false\\n\\n**C++ Solution (beats 100% time and memory): **\\n\\n\\n```\\nunordered_map<int, vector<string>>m;\\n    WordDictionary() {\\n        \\n    }\\n    \\n    void addWord(string word) {\\n        m[word.length()].push_back(word);\\n    }\\n    \\n    bool search(string word) {\\n        bool flag = false;\\n        for(auto w: m[word.size()])\\n        {\\n                flag = true;\\n                for(int i=0;i<w.length();i++)\\n                {\\n                    if(w[i]!=word[i] && word[i]!=\\'.\\')\\n                    {\\n                        flag =false;\\n                        break;\\n                    }\\n                }\\n            if(flag)\\n                break;\\n        }\\n        if(flag) return true;\\n        return false;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nunordered_map<int, vector<string>>m;\\n    WordDictionary() {\\n        \\n    }\\n    \\n    void addWord(string word) {\\n        m[word.length()].push_back(word);\\n    }\\n    \\n    bool search(string word) {\\n        bool flag = false;\\n        for(auto w: m[word.size()])\\n        {\\n                flag = true;\\n                for(int i=0;i<w.length();i++)\\n                {\\n                    if(w[i]!=word[i] && word[i]!=\\'.\\')\\n                    {\\n                        flag =false;\\n                        break;\\n                    }\\n                }\\n            if(flag)\\n                break;\\n        }\\n        if(flag) return true;\\n        return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1725609,
                "title": "c-most-intuitive-hashing-solution",
                "content": "\\tclass WordDictionary {\\n\\tpublic:\\n\\t\\tunordered_map<int,vector<string>> mp;\\n\\t\\tWordDictionary() {\\n\\t\\t\\tmp.clear();\\n\\t\\t}\\n\\n\\t\\tvoid addWord(string word) {\\n\\t\\t\\t//add word to its corresponding key size\\n\\t\\t\\tmp[word.size()].push_back(word);\\n\\t\\t}\\n\\n\\t\\t//comparing my search word with all other words having same length\\n\\t\\tbool check(string &s, string &p){\\n\\t\\t\\tfor(int i=0;i<p.length();i++){\\n\\t\\t\\t\\tif(p[i]==\\'.\\') continue;\\n\\t\\t\\t\\tif(p[i]!=s[i]) return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tbool search(string word) {\\n\\t\\t\\t//if any word of same length does not exist return false\\n\\t\\t\\tif(mp.find(word.size())==mp.end())  return false;\\n\\t\\t\\tvector<string> v=mp[word.size()];\\n\\t\\t\\tfor(auto it: v){\\n\\t\\t\\t\\tif(check(it,word)) return true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};\\n\\n\\t**If you like this and if it was helpful DO UPVOTE**",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tclass WordDictionary {\\n\\tpublic:\\n\\t\\tunordered_map<int,vector<string>> mp;\\n\\t\\tWordDictionary() {\\n\\t\\t\\tmp.clear();\\n\\t\\t}\\n\\n\\t\\tvoid addWord(string word) {\\n\\t\\t\\t//add word to its corresponding key size\\n\\t\\t\\tmp[word.size()].push_back(word);\\n\\t\\t}\\n\\n\\t\\t//comparing my search word with all other words having same length\\n\\t\\tbool check(string &s, string &p){\\n\\t\\t\\tfor(int i=0;i<p.length();i++){\\n\\t\\t\\t\\tif(p[i]==\\'.\\') continue;\\n\\t\\t\\t\\tif(p[i]!=s[i]) return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tbool search(string word) {\\n\\t\\t\\t//if any word of same length does not exist return false\\n\\t\\t\\tif(mp.find(word.size())==mp.end())  return false;\\n\\t\\t\\tvector<string> v=mp[word.size()];\\n\\t\\t\\tfor(auto it: v){\\n\\t\\t\\t\\tif(check(it,word)) return true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};\\n\\n\\t**If you like this and if it was helpful DO UPVOTE**",
                "codeTag": "Java"
            },
            {
                "id": 1500834,
                "title": "intuition-explained-trie-backtracking-c-clean-code",
                "content": "**Intuition :** \\n\\n* Idea is to insert new word into Trie with `addWord`. Similar to `insert` function in **[Trie Implementation](https://leetcode.com/problems/implement-trie-prefix-tree/)**\\n* To `search` word we will search in similar was as done in standard Trie `search`. Catch here is the case when character in word is `.`\\n* To handle this, we need to try all possible characters from `a to z` , by recusively doing checks. This is a backtracking based approach where we `pick -> try -> unpick` certains element. \\n* And when we reach the end of the word, simply check if current Trie node has `isEnd` flag set as *True or False*\\n\\n# Code:\\n\\n```\\nstruct Node {    // Trie Structure\\n    Node* arr[26];\\n    bool isEnd = false;\\n    \\n    bool contains(char ch) {\\n        return arr[ch-\\'a\\'] != NULL;\\n    }\\n    \\n    void put(char ch, Node* newNode) {\\n        arr[ch-\\'a\\'] = newNode;\\n    }\\n    \\n    Node* getNext(char ch) {\\n        return arr[ch-\\'a\\'];\\n    }\\n    \\n    void setEnd() {\\n        isEnd = true;\\n    }\\n    \\n    bool getEnd() {\\n        return isEnd;\\n    }\\n    \\n};\\n\\nclass WordDictionary {\\n    Node* root;\\npublic:\\n    WordDictionary() {\\n        root = new Node();\\n    }\\n    \\n    void addWord(string word) {  // Insert word into Trie\\n        Node* temp = root;\\n        for(auto& ch : word) {\\n            if(!temp->contains(ch)) {\\n                temp->put(ch, new Node());\\n            }\\n            temp = temp->getNext(ch);\\n        }\\n        temp->setEnd();\\n    }\\n    \\n    bool check(Node* node, string& word, int idx=0) {\\n        if(!node) return false;\\n        if(idx == word.size()) return node->getEnd();\\n        \\n        if(word[idx] == \\'.\\') {\\n            for(char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n                if(!node->contains(ch)) continue;\\n                if(check(node->getNext(ch), word, idx+1)) return true;\\n            }\\n        }\\n        else if(node->contains(word[idx])) {\\n             return check(node->getNext(word[idx]), word, idx+1);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool search(string word) {\\n        return check(root, word);\\n    }\\n};\\n```\\n\\n***If you find this solution helpful, please do upvote :)***",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nstruct Node {    // Trie Structure\\n    Node* arr[26];\\n    bool isEnd = false;\\n    \\n    bool contains(char ch) {\\n        return arr[ch-\\'a\\'] != NULL;\\n    }\\n    \\n    void put(char ch, Node* newNode) {\\n        arr[ch-\\'a\\'] = newNode;\\n    }\\n    \\n    Node* getNext(char ch) {\\n        return arr[ch-\\'a\\'];\\n    }\\n    \\n    void setEnd() {\\n        isEnd = true;\\n    }\\n    \\n    bool getEnd() {\\n        return isEnd;\\n    }\\n    \\n};\\n\\nclass WordDictionary {\\n    Node* root;\\npublic:\\n    WordDictionary() {\\n        root = new Node();\\n    }\\n    \\n    void addWord(string word) {  // Insert word into Trie\\n        Node* temp = root;\\n        for(auto& ch : word) {\\n            if(!temp->contains(ch)) {\\n                temp->put(ch, new Node());\\n            }\\n            temp = temp->getNext(ch);\\n        }\\n        temp->setEnd();\\n    }\\n    \\n    bool check(Node* node, string& word, int idx=0) {\\n        if(!node) return false;\\n        if(idx == word.size()) return node->getEnd();\\n        \\n        if(word[idx] == \\'.\\') {\\n            for(char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n                if(!node->contains(ch)) continue;\\n                if(check(node->getNext(ch), word, idx+1)) return true;\\n            }\\n        }\\n        else if(node->contains(word[idx])) {\\n             return check(node->getNext(word[idx]), word, idx+1);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool search(string word) {\\n        return check(root, word);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844319,
                "title": "python-iterative-bfs-trie-with-comments",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = dict()\\n        self.is_word = False\\n\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.root = TrieNode() # instantiate Trie data structure\\n\\n    def addWord(self, word: str) -> None:\\n        node = self.root\\n        for char in word:\\n\\t\\t    # add a character to the children of node if it doesn\\'t already exist in the children dictionary, then traverse to this child node\\n            node = node.children.setdefault(char, TrieNode()) \\n        node.is_word = True\\n        \\n    def search(self, word: str) -> bool:\\n        queue = [self.root]\\n        for char in word: \\n            tmp = [] # append new nodes to this temporary queue\\n            for node in queue: # for a sinlge char, bfs over the possible nodes (due to the wildcard \\'.\\')\\n                if char == \\'.\\': # if the char is a wildcard, append all child nodes into a queue to bfs at next iteration.\\n                    for child in node.children:\\n                        tmp.append(node.children[child])\\n                elif node.children.get(char): # if the char is found, keep going deeper into its children\\n\\t\\t\\t\\t\\t# Keep adding to tmp array when wildcard \\'.\\' results in nodes with the same char appearing. \\n\\t\\t\\t\\t\\t# e.g., suppose adding two words \\'abc\\' and \\'cbd\\'. When searching for \\'.bc\\', \\n\\t\\t\\t\\t\\t# both word nodes will be appended as candidates at the node.children[\\'b\\']\\n                    tmp.append(node.children[char]) \\n            queue = tmp # the newly appended queue to bfs over in the next iteration\\n        return any([node.is_word for node in queue])    \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Trie",
                    "Iterator"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = dict()\\n        self.is_word = False\\n\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.root = TrieNode() # instantiate Trie data structure\\n\\n    def addWord(self, word: str) -> None:\\n        node = self.root\\n        for char in word:\\n\\t\\t    # add a character to the children of node if it doesn\\'t already exist in the children dictionary, then traverse to this child node\\n            node = node.children.setdefault(char, TrieNode()) \\n        node.is_word = True\\n        \\n    def search(self, word: str) -> bool:\\n        queue = [self.root]\\n        for char in word: \\n            tmp = [] # append new nodes to this temporary queue\\n            for node in queue: # for a sinlge char, bfs over the possible nodes (due to the wildcard \\'.\\')\\n                if char == \\'.\\': # if the char is a wildcard, append all child nodes into a queue to bfs at next iteration.\\n                    for child in node.children:\\n                        tmp.append(node.children[child])\\n                elif node.children.get(char): # if the char is found, keep going deeper into its children\\n\\t\\t\\t\\t\\t# Keep adding to tmp array when wildcard \\'.\\' results in nodes with the same char appearing. \\n\\t\\t\\t\\t\\t# e.g., suppose adding two words \\'abc\\' and \\'cbd\\'. When searching for \\'.bc\\', \\n\\t\\t\\t\\t\\t# both word nodes will be appended as candidates at the node.children[\\'b\\']\\n                    tmp.append(node.children[char]) \\n            queue = tmp # the newly appended queue to bfs over in the next iteration\\n        return any([node.is_word for node in queue])    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 775049,
                "title": "java-simple-trie-implementation",
                "content": "```\\nclass TrieNode{\\n    boolean isEnd = false;\\n    TrieNode children[] = new TrieNode[26];\\n}\\n\\nclass WordDictionary {\\n    \\n    /** Initialize your data structure here. */\\n    TrieNode root;\\n    public WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n        TrieNode temp = root;\\n        \\n        for(int i=0;i<word.length();i++){\\n            char ch = word.charAt(i);\\n            if(temp.children[ch-\\'a\\'] == null) temp.children[ch-\\'a\\'] = new TrieNode();\\n            temp = temp.children[ch-\\'a\\'];\\n        }\\n        temp.isEnd = true;\\n        \\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public boolean search(String word) {\\n\\n        TrieNode temp = root;\\n        return search(word,0,temp);\\n        \\n    }\\n    \\n    public boolean search(String word,int i, TrieNode node){\\n        if(node == null) return false;\\n        \\n        if(i == word.length()) return node.isEnd;\\n        \\n        char ch = word.charAt(i);\\n        if(ch == \\'.\\'){\\n            for(int k=0;k<26;k++){\\n                if(search(word,i+1,node.children[k])) return true;\\n            }\\n        }else{\\n            if(search(word,i+1,node.children[ch-\\'a\\'])) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode{\\n    boolean isEnd = false;\\n    TrieNode children[] = new TrieNode[26];\\n}\\n\\nclass WordDictionary {\\n    \\n    /** Initialize your data structure here. */\\n    TrieNode root;\\n    public WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n        TrieNode temp = root;\\n        \\n        for(int i=0;i<word.length();i++){\\n            char ch = word.charAt(i);\\n            if(temp.children[ch-\\'a\\'] == null) temp.children[ch-\\'a\\'] = new TrieNode();\\n            temp = temp.children[ch-\\'a\\'];\\n        }\\n        temp.isEnd = true;\\n        \\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public boolean search(String word) {\\n\\n        TrieNode temp = root;\\n        return search(word,0,temp);\\n        \\n    }\\n    \\n    public boolean search(String word,int i, TrieNode node){\\n        if(node == null) return false;\\n        \\n        if(i == word.length()) return node.isEnd;\\n        \\n        char ch = word.charAt(i);\\n        if(ch == \\'.\\'){\\n            for(int k=0;k<26;k++){\\n                if(search(word,i+1,node.children[k])) return true;\\n            }\\n        }else{\\n            if(search(word,i+1,node.children[ch-\\'a\\'])) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684356,
                "title": "java-solution-using-hashmap-data-structure",
                "content": "Create ```HashMap<Integer, ArrayList<String>>``` to store words in specific lists mapped to their length. This will drastically reduce the number of words that will be searched for.\\n\\n```\\nimport java.util.regex.Pattern;\\nclass WordDictionary {\\n    // Mapping word length as the key and the list of words as the value\\n    Map<Integer, ArrayList<String>> map;\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        map = new HashMap<Integer, ArrayList<String>>();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n        ArrayList<String> list;\\n        if(map.get(word.length()) != null) list = map.get(word.length());\\n        else list = new ArrayList<String>();\\n        list.add(word);\\n        map.put(word.length(), list);\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public boolean search(String word) {\\n        ArrayList<String> list;\\n        if(map.get(word.length()) != null) list = map.get(word.length());\\n        else return false;\\n        if(list.contains(word)) return true;\\n        else {\\n            Pattern regex = Pattern.compile(word);\\n            for (String s:list) {\\n                if (regex.matcher(s).matches()) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```HashMap<Integer, ArrayList<String>>```\n```\\nimport java.util.regex.Pattern;\\nclass WordDictionary {\\n    // Mapping word length as the key and the list of words as the value\\n    Map<Integer, ArrayList<String>> map;\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        map = new HashMap<Integer, ArrayList<String>>();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n        ArrayList<String> list;\\n        if(map.get(word.length()) != null) list = map.get(word.length());\\n        else list = new ArrayList<String>();\\n        list.add(word);\\n        map.put(word.length(), list);\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public boolean search(String word) {\\n        ArrayList<String> list;\\n        if(map.get(word.length()) != null) list = map.get(word.length());\\n        else return false;\\n        if(list.contains(word)) return true;\\n        else {\\n            Pattern regex = Pattern.compile(word);\\n            for (String s:list) {\\n                if (regex.matcher(s).matches()) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59700,
                "title": "python-trie-solution-search-using-dfs",
                "content": "    class WordDictionary:\\n    # initialize your data structure here.\\n    def __init__(self):\\n        self.trie={}\\n\\n    # @param {string} word\\n    # @return {void}\\n    # Adds a word into the data structure.\\n    def addWord(self, word):\\n        trie=self.trie\\n        for c in word:\\n            if c not in trie:\\n                trie[c]={}\\n            trie=trie[c]\\n        trie['#']='#'\\n\\n    # @param {string} word\\n    # @return {boolean}\\n    # Returns if the word is in the data structure. A word could\\n    # contain the dot character '.' to represent any one letter.\\n    def search(self,word,trie=None):\\n        if trie==None:\\n            trie=self.trie\\n        if not word:\\n            if '#' in trie:\\n                return True\\n            else:\\n                return False\\n        c=word[0]\\n        if c=='.':\\n            for cc in trie:\\n                if cc!='#' and self.search(word[1:],trie[cc]):\\n                    return True\\n        elif c in trie:\\n            return self.search(word[1:],trie[c])\\n        return False",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "    class WordDictionary:\\n    # initialize your data structure here.\\n    def __init__(self):\\n        self.trie={}\\n\\n    # @param {string} word\\n    # @return {void}\\n    # Adds a word into the data structure.\\n    def addWord(self, word):\\n        trie=self.trie\\n        for c in word:\\n            if c not in trie:\\n                trie[c]={}\\n            trie=trie[c]\\n        trie['#']='#'\\n\\n    # @param {string} word\\n    # @return {boolean}\\n    # Returns if the word is in the data structure. A word could\\n    # contain the dot character '.' to represent any one letter.\\n    def search(self,word,trie=None):\\n        if trie==None:\\n            trie=self.trie\\n        if not word:\\n            if '#' in trie:\\n                return True\\n            else:\\n                return False\\n        c=word[0]\\n        if c=='.':\\n            for cc in trie:\\n                if cc!='#' and self.search(word[1:],trie[cc]):\\n                    return True\\n        elif c in trie:\\n            return self.search(word[1:],trie[c])\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 3712740,
                "title": "easy-solution-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: The insert and search function are of O(length of word) time complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Node{\\n    Node* links[26];\\n    bool flag;\\n    public:\\n    bool containsKey(char ch)\\n    {\\n        return links[ch-\\'a\\']!=NULL;\\n    }\\n    void put(char ch,Node* node)\\n    {\\n        links[ch-\\'a\\']=node;\\n    }\\n    Node* get(char ch)\\n    {\\n        return links[ch-\\'a\\'];\\n    }\\n    bool isEnd()\\n    {\\n        return flag;\\n    }\\n    void setEnd()\\n    {\\n        flag=true;\\n    }\\n};\\nclass WordDictionary \\n{\\n    Node* root;\\npublic:\\n    WordDictionary() \\n    {\\n        root=new Node();\\n    }\\n    \\n    void addWord(string word) \\n    {\\n        Node* node=root;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            if(!node->containsKey(word[i]))\\n            {\\n                node->put(word[i],new Node());\\n            }\\n            node=node->get(word[i]);\\n        }\\n        node->setEnd();\\n    }\\n    bool helper(Node* root,string word,int index)\\n    {\\n        if(index==word.size() && root->isEnd()==true)\\n            return true;\\n        if(index==word.size() && root->isEnd()==false)\\n            return false;\\n        if(word[index]==\\'.\\')\\n        {\\n            for(int i=0;i<26;i++)\\n            {\\n                bool a;\\n                if(root->links[i]!=NULL)\\n                    a=helper(root->links[i],word,index+1);\\n                    if(a==true)             \\n                    return true;\\n            }\\n            return false;\\n        }\\n        else\\n        {\\n            if(root->links[word[index]-\\'a\\']==NULL)\\n            return false;\\n            return helper(root->links[word[index]-\\'a\\'],word,index+1);\\n        }\\n    }\\n    bool search(string word) \\n    {\\n        Node* node=root;\\n        return helper(node,word,0);\\n    }\\n\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node* links[26];\\n    bool flag;\\n    public:\\n    bool containsKey(char ch)\\n    {\\n        return links[ch-\\'a\\']!=NULL;\\n    }\\n    void put(char ch,Node* node)\\n    {\\n        links[ch-\\'a\\']=node;\\n    }\\n    Node* get(char ch)\\n    {\\n        return links[ch-\\'a\\'];\\n    }\\n    bool isEnd()\\n    {\\n        return flag;\\n    }\\n    void setEnd()\\n    {\\n        flag=true;\\n    }\\n};\\nclass WordDictionary \\n{\\n    Node* root;\\npublic:\\n    WordDictionary() \\n    {\\n        root=new Node();\\n    }\\n    \\n    void addWord(string word) \\n    {\\n        Node* node=root;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            if(!node->containsKey(word[i]))\\n            {\\n                node->put(word[i],new Node());\\n            }\\n            node=node->get(word[i]);\\n        }\\n        node->setEnd();\\n    }\\n    bool helper(Node* root,string word,int index)\\n    {\\n        if(index==word.size() && root->isEnd()==true)\\n            return true;\\n        if(index==word.size() && root->isEnd()==false)\\n            return false;\\n        if(word[index]==\\'.\\')\\n        {\\n            for(int i=0;i<26;i++)\\n            {\\n                bool a;\\n                if(root->links[i]!=NULL)\\n                    a=helper(root->links[i],word,index+1);\\n                    if(a==true)             \\n                    return true;\\n            }\\n            return false;\\n        }\\n        else\\n        {\\n            if(root->links[word[index]-\\'a\\']==NULL)\\n            return false;\\n            return helper(root->links[word[index]-\\'a\\'],word,index+1);\\n        }\\n    }\\n    bool search(string word) \\n    {\\n        Node* node=root;\\n        return helper(node,word,0);\\n    }\\n\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317490,
                "title": "c-step-wise-commented-code-using-tries",
                "content": "# Disclaimer : \\nYou can understand the code **BETTER**, if you just have the **BASIC LOGIC** and the **IDEA** of the structure of the **TRIE** data structure...\\nNow, just proceed furthur to understand the code...\\n\\n**NOTE :** Read the corresponding comments to undertstand the code properly in detail\\n# Code\\n```\\n//Implementing a class for defining a new data type, named trie\\nclass trie{\\n    public:\\n    trie* a[26];\\n    bool terminal;\\n\\n    //constructor to initialize the values\\n    trie()\\n    {\\n        terminal=false;\\n        for(int i=0;i<26;i++)\\n            a[i]=NULL;\\n    }\\n};\\n\\n//given class\\nclass WordDictionary {\\npublic:\\n\\n    //creating the starting trie, named root\\n    trie* root;\\n\\n    //contructor to initialize the values\\n    WordDictionary() {\\n        root=new trie;              //intializing the starting root of the trie\\n    }\\n    \\n    //self made function to add word into our data structure\\n    void add(trie* &root,string word,int index)\\n    {\\n        //base case starts\\n        if(index==word.size())                         \\n        {\\n            root->terminal=true;\\n            return;\\n        }      \\n        //base case ends\\n\\n        //word[index]-\\'a\\' will give us the proper integer index\\n        if(root->a[word[index]-\\'a\\']==NULL)\\n            root->a[word[index]-\\'a\\']=new trie;\\n\\n        add(root->a[word[index]-\\'a\\'],word,index+1);\\n    }\\n\\n    //given function\\n    void addWord(string word) {\\n        add(root,word,0);\\n    }\\n    \\n    //self made function to search word in our data structure\\n    bool searching(trie* root,string word,int index)\\n    {\\n        //base cases starts\\n        if(index==word.size() && root->terminal==true)\\n            return true;\\n        if(index==word.size() && root->terminal==false)\\n            return false;\\n        //base cases ends\\n\\n        //In the problem itself, it is given that, dot(.) might also\\n        //be given while searching any string. So, whenever we get\\n        //a dot, we will look at each of the pointers in our array\\n        //of the current root because dot might represent any \\n        //character. So, for that reason we have a FOR loop here...\\n        if(word[index]==\\'.\\')\\n        {\\n            for(int i=0;i<26;i++)\\n            {\\n                bool a;\\n                if(root->a[i]!=NULL)\\n                    a=searching(root->a[i],word,index+1);\\n\\n                    //base case : If you get true then no need to\\n                    //check further, that\\'s why directly return\\n                    //true from here itself. \\n                    if(a==true)             \\n                    return true;\\n            }\\n            return false;\\n        }\\n        //If it is not a dot, then it is definitely any other character \\n        else\\n        {\\n            //base starts\\n            if(root->a[word[index]-\\'a\\']==NULL)\\n            return false;\\n            //base case ends\\n\\n            return searching(root->a[word[index]-\\'a\\'],word,index+1);\\n        }\\n    }\\n\\n    //given function\\n    bool search(string word) {\\n        return searching(root,word,0);\\n    }\\n};\\n```\\nI hope that you would have understood the code and the logic behind each statement. If now also, you have any doubts regarding any statement in my code, then you can just ask me, I will clear it too...\\nThankYou...\\n**Don\\'t forget to UPVOTE...**",
                "solutionTags": [
                    "C++",
                    "String",
                    "Depth-First Search",
                    "Design",
                    "Trie"
                ],
                "code": "```\\n//Implementing a class for defining a new data type, named trie\\nclass trie{\\n    public:\\n    trie* a[26];\\n    bool terminal;\\n\\n    //constructor to initialize the values\\n    trie()\\n    {\\n        terminal=false;\\n        for(int i=0;i<26;i++)\\n            a[i]=NULL;\\n    }\\n};\\n\\n//given class\\nclass WordDictionary {\\npublic:\\n\\n    //creating the starting trie, named root\\n    trie* root;\\n\\n    //contructor to initialize the values\\n    WordDictionary() {\\n        root=new trie;              //intializing the starting root of the trie\\n    }\\n    \\n    //self made function to add word into our data structure\\n    void add(trie* &root,string word,int index)\\n    {\\n        //base case starts\\n        if(index==word.size())                         \\n        {\\n            root->terminal=true;\\n            return;\\n        }      \\n        //base case ends\\n\\n        //word[index]-\\'a\\' will give us the proper integer index\\n        if(root->a[word[index]-\\'a\\']==NULL)\\n            root->a[word[index]-\\'a\\']=new trie;\\n\\n        add(root->a[word[index]-\\'a\\'],word,index+1);\\n    }\\n\\n    //given function\\n    void addWord(string word) {\\n        add(root,word,0);\\n    }\\n    \\n    //self made function to search word in our data structure\\n    bool searching(trie* root,string word,int index)\\n    {\\n        //base cases starts\\n        if(index==word.size() && root->terminal==true)\\n            return true;\\n        if(index==word.size() && root->terminal==false)\\n            return false;\\n        //base cases ends\\n\\n        //In the problem itself, it is given that, dot(.) might also\\n        //be given while searching any string. So, whenever we get\\n        //a dot, we will look at each of the pointers in our array\\n        //of the current root because dot might represent any \\n        //character. So, for that reason we have a FOR loop here...\\n        if(word[index]==\\'.\\')\\n        {\\n            for(int i=0;i<26;i++)\\n            {\\n                bool a;\\n                if(root->a[i]!=NULL)\\n                    a=searching(root->a[i],word,index+1);\\n\\n                    //base case : If you get true then no need to\\n                    //check further, that\\'s why directly return\\n                    //true from here itself. \\n                    if(a==true)             \\n                    return true;\\n            }\\n            return false;\\n        }\\n        //If it is not a dot, then it is definitely any other character \\n        else\\n        {\\n            //base starts\\n            if(root->a[word[index]-\\'a\\']==NULL)\\n            return false;\\n            //base case ends\\n\\n            return searching(root->a[word[index]-\\'a\\'],word,index+1);\\n        }\\n    }\\n\\n    //given function\\n    bool search(string word) {\\n        return searching(root,word,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313837,
                "title": "java-easy-solution-100-faster-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass WordDictionary {\\n  class TrieNode {\\n    boolean isWord;\\n    TrieNode[] children;\\n    \\n    public TrieNode() {\\n      isWord = false;\\n      children = new TrieNode[26];\\n    }\\n  }\\n  \\n  TrieNode root;\\n\\n  public WordDictionary() {\\n    root = new TrieNode();\\n  }\\n\\n  /**\\n   * Time Complexity: O(n)\\n   * Space Complexity: O(n)\\n   */\\n  public void addWord(String word) {\\n    TrieNode node = root;\\n    /**\\n     * Time Complexity: O(n)\\n     *   - word length\\n     * Space Complexity: O(n)\\n     *   - word length\\n     */\\n    for (int i = 0; i < word.length(); i++) {\\n      int idx = word.charAt(i) - \\'a\\';\\n      if (node.children[idx] == null) {\\n        /**\\n         * Space Complexity: O(1)\\n         *   - Always 26 lower-case English letters\\n         */\\n        node.children[idx] = new TrieNode();\\n      }\\n      node = node.children[idx];\\n    }\\n    node.isWord = true;\\n  }\\n\\n\\n  /**\\n   * Time Complexity: O(n)\\n   * Space Complexity: O(n)\\n   */\\n  public boolean searching(String word, TrieNode node, int wordIdx) {\\n    if (node == null) return false;\\n    /**\\n     * Time Complexity: O(n)\\n     *   - word length\\n     */\\n    for (int i = wordIdx; i < word.length(); i++) {\\n      int idx = word.charAt(i) - \\'a\\';\\n      // (\\'.\\' - \\'a\\') = -51\\n      if (idx == (-51)) {\\n        /**\\n         * Time Complexity: O(1)\\n         *   - Always 26 lower-case English letters\\n         */\\n        for (int j = 0; j < node.children.length; j++) {\\n          /**\\n           * Space Complexity: O(n)\\n           *   - stack: if search \\'.\\' for whole letters.\\n           */\\n          if (searching(word, node.children[j], i + 1)) {\\n            return true;\\n          }\\n        }\\n        return false;\\n      }\\n      if (node.children[idx] == null) return false;\\n      node = node.children[idx];\\n    }\\n    return node.isWord;\\n  }\\n\\n  public boolean search(String word) {\\n    return searching(word, root, 0);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass WordDictionary {\\n  class TrieNode {\\n    boolean isWord;\\n    TrieNode[] children;\\n    \\n    public TrieNode() {\\n      isWord = false;\\n      children = new TrieNode[26];\\n    }\\n  }\\n  \\n  TrieNode root;\\n\\n  public WordDictionary() {\\n    root = new TrieNode();\\n  }\\n\\n  /**\\n   * Time Complexity: O(n)\\n   * Space Complexity: O(n)\\n   */\\n  public void addWord(String word) {\\n    TrieNode node = root;\\n    /**\\n     * Time Complexity: O(n)\\n     *   - word length\\n     * Space Complexity: O(n)\\n     *   - word length\\n     */\\n    for (int i = 0; i < word.length(); i++) {\\n      int idx = word.charAt(i) - \\'a\\';\\n      if (node.children[idx] == null) {\\n        /**\\n         * Space Complexity: O(1)\\n         *   - Always 26 lower-case English letters\\n         */\\n        node.children[idx] = new TrieNode();\\n      }\\n      node = node.children[idx];\\n    }\\n    node.isWord = true;\\n  }\\n\\n\\n  /**\\n   * Time Complexity: O(n)\\n   * Space Complexity: O(n)\\n   */\\n  public boolean searching(String word, TrieNode node, int wordIdx) {\\n    if (node == null) return false;\\n    /**\\n     * Time Complexity: O(n)\\n     *   - word length\\n     */\\n    for (int i = wordIdx; i < word.length(); i++) {\\n      int idx = word.charAt(i) - \\'a\\';\\n      // (\\'.\\' - \\'a\\') = -51\\n      if (idx == (-51)) {\\n        /**\\n         * Time Complexity: O(1)\\n         *   - Always 26 lower-case English letters\\n         */\\n        for (int j = 0; j < node.children.length; j++) {\\n          /**\\n           * Space Complexity: O(n)\\n           *   - stack: if search \\'.\\' for whole letters.\\n           */\\n          if (searching(word, node.children[j], i + 1)) {\\n            return true;\\n          }\\n        }\\n        return false;\\n      }\\n      if (node.children[idx] == null) return false;\\n      node = node.children[idx];\\n    }\\n    return node.isWord;\\n  }\\n\\n  public boolean search(String word) {\\n    return searching(word, root, 0);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313711,
                "title": "python3-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.text = []\\n        \\n\\n    def addWord(self, word: str) -> None:\\n        self.text.append(word)\\n        \\n\\n    def search(self, word: str) -> bool:\\n        if \\'.\\' not in word:\\n            return word in self.text\\n\\n        for t in self.text:\\n            if len(t) != len(word):\\n                continue\\n            for i in range(len(word)):\\n                if word[i] == \\'.\\':\\n                    continue\\n                if word[i] != t[i]:\\n                    break\\n            else:\\n                return True\\n        return False\\n        \\n\\n\\n# Your WordDictionary object will be instantiated and called as such:\\n# obj = WordDictionary()\\n# obj.addWord(word)\\n# param_2 = obj.search(word)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.text = []\\n        \\n\\n    def addWord(self, word: str) -> None:\\n        self.text.append(word)\\n        \\n\\n    def search(self, word: str) -> bool:\\n        if \\'.\\' not in word:\\n            return word in self.text\\n\\n        for t in self.text:\\n            if len(t) != len(word):\\n                continue\\n            for i in range(len(word)):\\n                if word[i] == \\'.\\':\\n                    continue\\n                if word[i] != t[i]:\\n                    break\\n            else:\\n                return True\\n        return False\\n        \\n\\n\\n# Your WordDictionary object will be instantiated and called as such:\\n# obj = WordDictionary()\\n# obj.addWord(word)\\n# param_2 = obj.search(word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421416,
                "title": "python-tle-faster-than-99-trie-optimization",
                "content": "For those who are encountering TLE, add some more check conditions\\n* While inserting words in the Trie, keep the max length of all the words.\\n* While searching in the Trie, if length of the word to be searched is greater than max length, return False.\\n\\n**Python Code:**\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.links = {}\\n        self.end = False\\n    \\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.maxL = 0   #store the maximum length of all the words inserted\\n        \\n    def addWord(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: None\\n        \"\"\"\\n        node = self.root\\n        l = 0\\n        for w in word:\\n            if w not in node.links:\\n                node.links[w] = TrieNode()\\n            node = node.links[w]\\n            l += 1\\n        \\n        self.maxL = max(self.maxL, l)\\n        node.end = True\\n\\n    def search(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        if len(word) > self.maxL:    #optimization\\n            return False\\n        \\n        def helper(index, node):\\n            for inn in range(index, len(word)):\\n                c = word[inn]\\n                if c == \".\":\\n                    for child in node.links.values():\\n                        if helper(inn+1, child):\\n                            return True\\n                    return False\\n                else:\\n                    if c not in node.links:\\n                        return False\\n                    node = node.links[c]\\n\\n            return node.end\\n        return helper(0, self.root)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.links = {}\\n        self.end = False\\n    \\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.maxL = 0   #store the maximum length of all the words inserted\\n        \\n    def addWord(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: None\\n        \"\"\"\\n        node = self.root\\n        l = 0\\n        for w in word:\\n            if w not in node.links:\\n                node.links[w] = TrieNode()\\n            node = node.links[w]\\n            l += 1\\n        \\n        self.maxL = max(self.maxL, l)\\n        node.end = True\\n\\n    def search(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        if len(word) > self.maxL:    #optimization\\n            return False\\n        \\n        def helper(index, node):\\n            for inn in range(index, len(word)):\\n                c = word[inn]\\n                if c == \".\":\\n                    for child in node.links.values():\\n                        if helper(inn+1, child):\\n                            return True\\n                    return False\\n                else:\\n                    if c not in node.links:\\n                        return False\\n                    node = node.links[c]\\n\\n            return node.end\\n        return helper(0, self.root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776233,
                "title": "c-trie-based-approach-explained-90-time-70-space",
                "content": "The core idea is to solve this problem with a [`Trie`](https://en.wikipedia.org/wiki/Trie), a tree-like structure that allows us to navigate across a vocabulary of possible words, so that its root store as `children` all the possible first letters of all the words in the vocabulary and they in turn point to the possible second letters and so on - check the wiki link above for more info and a visual representation.\\n\\nThe advantages of this approach are clear when you start to think about navigating the tree structure only once to verify if a word is valid: does it start with `\\'t\\'`? If so, you go down that route, otherwise you do not waste time checking for all the other possible combinations; and for larger vocabularies and/or longer word the difference in performances might be massive.\\n\\nSo, in order to implement it, first of all we need a base node with at least 2 properties: `children` (ie: all the other nodes that start from there and lead to other words) and a boolean telling us if a word was ending there or not (`eow`, in my code, as in \"end of word\").\\n\\nAlso note that since an array can vastly improve performance over a vector, but it is not initialised by default, we will have to do so in our constructor for our trie, `WordDictionary`.\\n\\nSince we know we will only get lowercase letters and we really want (and love!) to save resources whenever it is possible, our array of pointers is going to be only `26` in size and the helper function `convertChar` will help us turning the characters we get in matching indexes in the `0 - 25` range.\\n\\nAnd, well, that was the easy part - I am not gonna lie here -, but if you grasp it properly, the rest is definitely going to come down much more easily.\\n\\nSo we also need to implement the `add` method that will gradually populate our trie, building graphs out of new words: we loop through each character, check if we already have a matching node for it in the current `children`, we create one if not and we update our pointer `root` until we are done, being mindful of setting `eow` to `true` for the last word, without touching it otherwise: if for example we add, in order `\"pip\"` and `\"pippi\"`, we will have `eow` set to `true` for both the second `\\'p\\'` and the second `\\'i\\'` nodes.\\n\\nAnd that was the intermediate part, so now catch your breath and be ready for the hard part (including looking for wild card characters, the real challenge of this kata): the `search` method is meant to take initially just one `word`, but we might be better off allowing it to receive different optional parameters too: an `index` of where to start to look in the string (defaulted to `0`) and its companion `*WordDictionary` pointer `root` telling us what tree to use for our search (defaulted to `this`).\\n\\nLet\\'s start with the hardest part: when the character is `\\'.\\'`, the wild card option, we do not proceed through a child linearly, but we ask our Trie to check for all the children: we return `any_of` taking all of them and returning `false` first of all if the node is not there (meaning: no child present and no letter matches that path), otherwise we return `true` if either `node->eow` (it is a valid, end of word) and `i == word.size() - 1` (it is actually the last character).\\n\\nAlternatively, we just invoke search recursively (still provided `node` exist, otherwise we would be using `root` at each call and I had to debug a bit before noticing that!): same string, increased `index`, updated `root`.\\n\\nThe other cases are a bit easier: if we find a character matching no element in the current `children`, we return false; otherwise we update `root` to be `root->children[c]` and we either return when it is the last character or proceed with the next iteration of the query string.\\n\\nIf all else fails, we just return `false` :)\\n\\nThe code:\\n\\n```cpp\\nclass WordDictionary {\\npublic:\\n    WordDictionary *children[26];\\n    bool eow = false;\\n    /** Initialize your data structure here. */\\n    WordDictionary() {\\n        // initially setting all children = to NULL\\n        for (auto &c: children) c = NULL; \\n    }\\n    int convertChar(char c) {\\n        return c - \\'a\\';\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        // building a Trie from a word\\n        WordDictionary *root = this;\\n        for (char c: word) {\\n            c = convertChar(c);\\n            // if there is not already such a children Trie, we create it\\n            if (!root->children[c]) root->children[c] = new WordDictionary;\\n            root = root->children[c];\\n        }\\n        root->eow = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word, int index = 0, WordDictionary *root = NULL) {\\n        // in the base call we just take this as a root\\n        if (!root) root = this;\\n        // looping through all the characters\\n        for (int i = index; i < word.size(); i++) {\\n            // if a \\'.\\' is found, we move with a DFS approach across the Trie\\n            if (word[i] == \\'.\\') return any_of(begin(root->children), end(root->children), [this, i, &word](WordDictionary *node){return node && (node->eow && i == word.size() - 1 || i + 1 < word.size() && search(word, i + 1, node));});\\n            // otherwise we stop if no child matching the current character is present...\\n            int c = convertChar(word[i]);\\n            if (!root->children[c]) return false;\\n            // update root in any case\\n            root = root->children[c];\\n            // and check if that was the last character, matching the termination of some Trie\\n            if (i == word.size() - 1) return root->eow;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```cpp\\nclass WordDictionary {\\npublic:\\n    WordDictionary *children[26];\\n    bool eow = false;\\n    /** Initialize your data structure here. */\\n    WordDictionary() {\\n        // initially setting all children = to NULL\\n        for (auto &c: children) c = NULL; \\n    }\\n    int convertChar(char c) {\\n        return c - \\'a\\';\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        // building a Trie from a word\\n        WordDictionary *root = this;\\n        for (char c: word) {\\n            c = convertChar(c);\\n            // if there is not already such a children Trie, we create it\\n            if (!root->children[c]) root->children[c] = new WordDictionary;\\n            root = root->children[c];\\n        }\\n        root->eow = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word, int index = 0, WordDictionary *root = NULL) {\\n        // in the base call we just take this as a root\\n        if (!root) root = this;\\n        // looping through all the characters\\n        for (int i = index; i < word.size(); i++) {\\n            // if a \\'.\\' is found, we move with a DFS approach across the Trie\\n            if (word[i] == \\'.\\') return any_of(begin(root->children), end(root->children), [this, i, &word](WordDictionary *node){return node && (node->eow && i == word.size() - 1 || i + 1 < word.size() && search(word, i + 1, node));});\\n            // otherwise we stop if no child matching the current character is present...\\n            int c = convertChar(word[i]);\\n            if (!root->children[c]) return false;\\n            // update root in any case\\n            root = root->children[c];\\n            // and check if that was the last character, matching the termination of some Trie\\n            if (i == word.size() - 1) return root->eow;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774648,
                "title": "updated-22-12-23-python-faster-than-99-space-efficient-than-92-trie-indexing",
                "content": "## Updated (2022.12.23)\\n\\n![image.png](https://assets.leetcode.com/users/images/b806db9d-1611-41f2-8740-3553e63a3234_1671734207.994404.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/6343246c-e93e-4e12-ab33-805cf2f4ca04_1671734235.6923153.png)\\n\\n\\nThe recent problem Testcase has been changed, so it has been changed to Trie + Indexing + Queue.\\nBeat 99.22% (Compute), 92.18% (Memory).\\n\\nOptimization works as follows.\\n- Exact match index cahing via Set $$O(1)$$\\n- Guard clause based on string length $$O(1)$$\\n- Otherwise search Trie from values indexed by word number $$O(L)$$\\n- However, when a special search is included as in `\\'.\\'`, the BFS Trie branches through the queue. $$O(LlogL)$$\\n\\n```\\nclass WordDictionary:\\n    def __init__(self):\\n        self.index = set()\\n        self.words = defaultdict(dict)\\n        \\n    def addWord(self, word: str) -> None:\\n        if word in self.index: return\\n        self.index.add(word)\\n        d = self.words[len(word)]\\n        for c in word:\\n            if c not in d: d[c] = {}\\n            d = d[c]\\n        \\n    def search(self, word: str) -> bool:\\n        if word in self.index: return True\\n        \\n        word_len = len(word)\\n        if word_len not in self.words: return False\\n        if word == \\'.\\' * word_len: return True\\n        \\n        ds = [self.words[word_len]]\\n        for c in word:\\n            nds = []\\n            for d in ds:\\n                if c == \\'.\\': nds += d.values()\\n                elif c in d: nds.append(d[c])\\n            ds = nds\\n            \\n        return bool(ds)\\n```\\n\\n---\\n\\n## Previous content (2020.08.05)\\n\\nInitially, I write a code by using Trie among string search algorithms, but I realized that it was very inefficient in wildcard and applied index and generator.\\n\\nThe index consists of a total of 2 (word matching, count matching if only wild cards are used),\\nIf the index is not hit, the word is fully scanned until it is matched.\\n\\nSometimes it shows that context-sensitive logic selection is more important than famous algorithms.\\n\\n```python\\nclass WordDictionary:\\n    def __init__(self):\\n        self.index = {}\\n        self.words = defaultdict(list)\\n        \\n    def compare(self, w1: str, w2: str) -> bool:\\n        w1 = list(w1)\\n        w2 = list(w2)\\n        \\n        while w1:\\n            c1 = w1.pop(0)\\n            c2 = w2.pop(0)\\n            \\n            if c1 == \\'.\\':\\n                continue\\n                \\n            if c1 != c2:\\n                return False\\n            \\n        return True\\n        \\n    def addWord(self, word: str) -> None:\\n        self.index[word] = True\\n        self.words[len(word)].append(word)\\n        \\n\\n    def search(self, word: str) -> bool:\\n        if word in self.index:\\n            return True\\n        \\n        word_len = len(word)\\n        if word_len not in self.words:\\n            return False\\n        \\n        if word == \\'.\\' * word_len:\\n            return True\\n        \\n        words = self.words[word_len]\\n        for w in words:\\n            if self.compare(word, w):\\n                return True\\n            \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Trie",
                    "Queue"
                ],
                "code": "```\\nclass WordDictionary:\\n    def __init__(self):\\n        self.index = set()\\n        self.words = defaultdict(dict)\\n        \\n    def addWord(self, word: str) -> None:\\n        if word in self.index: return\\n        self.index.add(word)\\n        d = self.words[len(word)]\\n        for c in word:\\n            if c not in d: d[c] = {}\\n            d = d[c]\\n        \\n    def search(self, word: str) -> bool:\\n        if word in self.index: return True\\n        \\n        word_len = len(word)\\n        if word_len not in self.words: return False\\n        if word == \\'.\\' * word_len: return True\\n        \\n        ds = [self.words[word_len]]\\n        for c in word:\\n            nds = []\\n            for d in ds:\\n                if c == \\'.\\': nds += d.values()\\n                elif c in d: nds.append(d[c])\\n            ds = nds\\n            \\n        return bool(ds)\\n```\n```python\\nclass WordDictionary:\\n    def __init__(self):\\n        self.index = {}\\n        self.words = defaultdict(list)\\n        \\n    def compare(self, w1: str, w2: str) -> bool:\\n        w1 = list(w1)\\n        w2 = list(w2)\\n        \\n        while w1:\\n            c1 = w1.pop(0)\\n            c2 = w2.pop(0)\\n            \\n            if c1 == \\'.\\':\\n                continue\\n                \\n            if c1 != c2:\\n                return False\\n            \\n        return True\\n        \\n    def addWord(self, word: str) -> None:\\n        self.index[word] = True\\n        self.words[len(word)].append(word)\\n        \\n\\n    def search(self, word: str) -> bool:\\n        if word in self.index:\\n            return True\\n        \\n        word_len = len(word)\\n        if word_len not in self.words:\\n            return False\\n        \\n        if word == \\'.\\' * word_len:\\n            return True\\n        \\n        words = self.words[word_len]\\n        for w in words:\\n            if self.compare(word, w):\\n                return True\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774633,
                "title": "c-trie-solution",
                "content": "```\\nclass WordDictionary {\\npublic:\\n\\n    /** Initialize your data structure here. */\\n    WordDictionary() {\\n        this->is_leaf = false;\\n        for(int i=0; i<26; i++)\\n            this->children[i] = NULL;\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        WordDictionary* root = this;\\n        for (int i=0;i<word.length();i++)\\n        {\\n            int index = word[i] - \\'a\\';\\n            if (root->children[index] == NULL)\\n                root->children[index] = new WordDictionary();\\n            root = root->children[index];\\n        }\\n        root->is_leaf = true;\\n    }\\n    \\n   \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word) {\\n        return helper(word, this);\\n    }\\n    \\n    \\nprivate:\\n    bool is_leaf;\\n    WordDictionary* children[26];\\n    \\n    bool helper(string subword, WordDictionary* ptr)\\n    {\\n        for(int i=0;i<subword.length();i++)\\n        {\\n            if (subword[i] == \\'.\\')\\n            {\\n                for (int j=0;j<26;j++)\\n                {\\n                    if(ptr->children[j]) {\\n                        if (helper(subword.substr(i+1), ptr->children[j]))\\n                            return true;\\n                    }\\n                }\\n\\n            }\\n            else\\n            {\\n                int index = subword[i] - \\'a\\';\\n                if (!ptr->children[index])\\n                    return false;\\n                ptr = ptr->children[index];\\n                continue;\\n            }\\n            return false;\\n        }\\n        if (ptr->is_leaf)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass WordDictionary {\\npublic:\\n\\n    /** Initialize your data structure here. */\\n    WordDictionary() {\\n        this->is_leaf = false;\\n        for(int i=0; i<26; i++)\\n            this->children[i] = NULL;\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        WordDictionary* root = this;\\n        for (int i=0;i<word.length();i++)\\n        {\\n            int index = word[i] - \\'a\\';\\n            if (root->children[index] == NULL)\\n                root->children[index] = new WordDictionary();\\n            root = root->children[index];\\n        }\\n        root->is_leaf = true;\\n    }\\n    \\n   \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word) {\\n        return helper(word, this);\\n    }\\n    \\n    \\nprivate:\\n    bool is_leaf;\\n    WordDictionary* children[26];\\n    \\n    bool helper(string subword, WordDictionary* ptr)\\n    {\\n        for(int i=0;i<subword.length();i++)\\n        {\\n            if (subword[i] == \\'.\\')\\n            {\\n                for (int j=0;j<26;j++)\\n                {\\n                    if(ptr->children[j]) {\\n                        if (helper(subword.substr(i+1), ptr->children[j]))\\n                            return true;\\n                    }\\n                }\\n\\n            }\\n            else\\n            {\\n                int index = subword[i] - \\'a\\';\\n                if (!ptr->children[index])\\n                    return false;\\n                ptr = ptr->children[index];\\n                continue;\\n            }\\n            return false;\\n        }\\n        if (ptr->is_leaf)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735094,
                "title": "swift-trie-dfs-with-complexity-analysis",
                "content": "Complexity Analysis:\\nWe use \"n\" as the length of the string being added,\\n\\nFor add():\\nTime: O(n), Space: O(n)\\n\\nFor search():\\n- When there are no wildcards: \\nTime: O(n), Space: O(n) because of the recursive calls\\n- Where there are wildcards:\\nThe absolute worst case we can have 26 children at each node, traversing through all nodes with DFS will take 26^n (n nodes, each nodes have 26 children/characters). 26^n is technically 2^n. Therefore,\\nTime: O(2^n), Space: O(n) because we only have at max n calls on the stack at any given time.\\nHowever, one can use tighter bounds and say Time: O(m) where m is the total number of characters on the trie.\\n\\n\\n```\\nclass Trie {\\n    var isEnd = false\\n    var dict = [Character : Trie]()\\n}\\n\\nclass WordDictionary {\\n    let root = Trie()\\n    \\n    func addWord(_ word: String) {\\n        var node = root\\n        for char in word {\\n            if node.dict[char] == nil { node.dict[char] = Trie() }\\n            node = node.dict[char]!\\n        }\\n        node.isEnd = true\\n    }\\n    \\n    func search(_ word: String) -> Bool {\\n        return dfs(0, Array(word), root)\\n    }\\n    \\n    func dfs(_ index: Int, _ word: [Character], _ node: Trie) -> Bool {\\n        if index == word.count { return node.isEnd }\\n        let char = word[index]\\n        if char != \".\" {\\n            return node.dict[char] != nil && dfs(index + 1, word, node.dict[char]!)\\n        } else {\\n            for ch in node.dict.keys {\\n                if node.dict[ch] != nil && dfs(index + 1, word, node.dict[ch]!) {\\n                    return true\\n                }\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie {\\n    var isEnd = false\\n    var dict = [Character : Trie]()\\n}\\n\\nclass WordDictionary {\\n    let root = Trie()\\n    \\n    func addWord(_ word: String) {\\n        var node = root\\n        for char in word {\\n            if node.dict[char] == nil { node.dict[char] = Trie() }\\n            node = node.dict[char]!\\n        }\\n        node.isEnd = true\\n    }\\n    \\n    func search(_ word: String) -> Bool {\\n        return dfs(0, Array(word), root)\\n    }\\n    \\n    func dfs(_ index: Int, _ word: [Character], _ node: Trie) -> Bool {\\n        if index == word.count { return node.isEnd }\\n        let char = word[index]\\n        if char != \".\" {\\n            return node.dict[char] != nil && dfs(index + 1, word, node.dict[char]!)\\n        } else {\\n            for ch in node.dict.keys {\\n                if node.dict[ch] != nil && dfs(index + 1, word, node.dict[ch]!) {\\n                    return true\\n                }\\n            }\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693500,
                "title": "python-generic-solution-template-for-all-trie-problems",
                "content": "```\\n## RC ##\\n## APPROACH : TRIE + DFS ## (BFS/DFS both are same here)\\n## LOGIC ##\\n## 1. Build Trie with give Words ##\\n## 2. When there is character match next level will be only that characters children\\n## 3. when ch = \".\", we take it as, it matched all the children in curr row, so we send next children of those row ##\\n## 4. When you are done with letters, check if it is end of word.\\n\\n## TIME COMPLEXITY: addWord: O(len(word)), search: O(N) ## (where N is the number of nodes in the Trie up to depth len(word))\\n## SPACE COMPLEXITY : O(W) ##\\n\\nclass WordDictionary:\\n    def __init__(self):\\n        self.my_trie = Trie()\\n        \\n    def addWord(self, word: str) -> None:\\n        self.my_trie.insert(word)\\n\\n    def search(self, word: str) -> bool:\\n        return self.my_trie.serachWithDot(word)\\n    \\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.rootNode = TrieNode()\\n        \\n    # Inserts a word into the trie.\\n    def insert(self, word: str) -> None:\\n        currNode = self.rootNode\\n        for idx, ch in enumerate(word):                     \\n            if( ch not in currNode.children ):\\n                currNode.children[ch] = TrieNode()          \\n            currNode = currNode.children[ch]        # currnode.children[ch]\\n        currNode.endOfWord = True\\n    \\n\\t# Leetcode: 208, Implement Trie or Prefix Tree\\n    # Returns if the word is in the trie.\\n    def search(self, word: str) -> bool:\\n        currNode = self.rootNode                    \\n        for ch in word:\\n            if(ch not in currNode.children):\\n                return False\\n            currNode = currNode.children[ch]\\n        return currNode.endOfWord\\n    \\n\\t# Leetcode: 648 Replace Words\\n    # Returns if there is any word in the trie that starts with the given prefix.\\n    def startsWith(self, prefix: str) -> bool:\\n        currNode = self.rootNode                            \\n        for ch in prefix:\\n            if(ch not in currNode.children):\\n                return False\\n            currNode = currNode.children[ch]\\n        return True\\n    \\n\\t# Leetcode 211, Search words including \".\" (matches any character)\\n    # Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n    def serachWithDot(self, word: str) -> bool:\\n            def dfs(currNode, word):\\n                if not word:\\n                    return currNode.endOfWord\\n                ch = word[0]\\n                if ch == \".\":\\n                    for node in [currNode.children[_] for _ in currNode.children]:\\n                        if dfs(node, word[1:]):\\n                            return True\\n                else:\\n                    if ch in currNode.children:\\n                        if dfs(currNode.children[ch], word[1:]):\\n                            return True\\n                    else:\\n                        return False\\n            return dfs(self.rootNode, word)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n## RC ##\\n## APPROACH : TRIE + DFS ## (BFS/DFS both are same here)\\n## LOGIC ##\\n## 1. Build Trie with give Words ##\\n## 2. When there is character match next level will be only that characters children\\n## 3. when ch = \".\", we take it as, it matched all the children in curr row, so we send next children of those row ##\\n## 4. When you are done with letters, check if it is end of word.\\n\\n## TIME COMPLEXITY: addWord: O(len(word)), search: O(N) ## (where N is the number of nodes in the Trie up to depth len(word))\\n## SPACE COMPLEXITY : O(W) ##\\n\\nclass WordDictionary:\\n    def __init__(self):\\n        self.my_trie = Trie()\\n        \\n    def addWord(self, word: str) -> None:\\n        self.my_trie.insert(word)\\n\\n    def search(self, word: str) -> bool:\\n        return self.my_trie.serachWithDot(word)\\n    \\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.rootNode = TrieNode()\\n        \\n    # Inserts a word into the trie.\\n    def insert(self, word: str) -> None:\\n        currNode = self.rootNode\\n        for idx, ch in enumerate(word):                     \\n            if( ch not in currNode.children ):\\n                currNode.children[ch] = TrieNode()          \\n            currNode = currNode.children[ch]        # currnode.children[ch]\\n        currNode.endOfWord = True\\n    \\n\\t# Leetcode: 208, Implement Trie or Prefix Tree\\n    # Returns if the word is in the trie.\\n    def search(self, word: str) -> bool:\\n        currNode = self.rootNode                    \\n        for ch in word:\\n            if(ch not in currNode.children):\\n                return False\\n            currNode = currNode.children[ch]\\n        return currNode.endOfWord\\n    \\n\\t# Leetcode: 648 Replace Words\\n    # Returns if there is any word in the trie that starts with the given prefix.\\n    def startsWith(self, prefix: str) -> bool:\\n        currNode = self.rootNode                            \\n        for ch in prefix:\\n            if(ch not in currNode.children):\\n                return False\\n            currNode = currNode.children[ch]\\n        return True\\n    \\n\\t# Leetcode 211, Search words including \".\" (matches any character)\\n    # Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n    def serachWithDot(self, word: str) -> bool:\\n            def dfs(currNode, word):\\n                if not word:\\n                    return currNode.endOfWord\\n                ch = word[0]\\n                if ch == \".\":\\n                    for node in [currNode.children[_] for _ in currNode.children]:\\n                        if dfs(node, word[1:]):\\n                            return True\\n                else:\\n                    if ch in currNode.children:\\n                        if dfs(currNode.children[ch], word[1:]):\\n                            return True\\n                    else:\\n                        return False\\n            return dfs(self.rootNode, word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632196,
                "title": "c-solution-using-unordered-map-very-easy-to-understand-backtracking",
                "content": "```\\nclass WordDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    \\n    struct TrieNode {\\n        unordered_map<char, TrieNode*> umap;\\n        bool eow;\\n        TrieNode(){\\n            eow = false;\\n        }\\n    };\\n    \\n    TrieNode* root;\\n\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        TrieNode* tmp = root;\\n        for(char ele: word){\\n            if(tmp->umap.find(ele) == tmp->umap.end()){\\n                tmp->umap[ele] = new TrieNode();\\n            }\\n            tmp = tmp->umap[ele];\\n        }\\n        tmp->eow = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    \\n    bool search(string word) {\\n        bool ans = false;\\n        search2(word, 0, root, ans);\\n        return ans;\\n    }\\n    \\n    void search2(string word, int i, TrieNode* tmp, bool& ans){\\n        if(i<word.length()){\\n            if(word[i] == \\'.\\'){\\n                for(auto ptr = tmp->umap.begin(); ptr!=tmp->umap.end(); ptr++){\\n                    search2(word, i+1, ptr->second, ans);\\n                }\\n            }else if(tmp->umap.find(word[i]) != tmp->umap.end()){\\n                search2(word, i+1, tmp->umap[word[i]], ans);\\n            }\\n        }else{\\n            ans = ans || tmp->eow;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    \\n    struct TrieNode {\\n        unordered_map<char, TrieNode*> umap;\\n        bool eow;\\n        TrieNode(){\\n            eow = false;\\n        }\\n    };\\n    \\n    TrieNode* root;\\n\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        TrieNode* tmp = root;\\n        for(char ele: word){\\n            if(tmp->umap.find(ele) == tmp->umap.end()){\\n                tmp->umap[ele] = new TrieNode();\\n            }\\n            tmp = tmp->umap[ele];\\n        }\\n        tmp->eow = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    \\n    bool search(string word) {\\n        bool ans = false;\\n        search2(word, 0, root, ans);\\n        return ans;\\n    }\\n    \\n    void search2(string word, int i, TrieNode* tmp, bool& ans){\\n        if(i<word.length()){\\n            if(word[i] == \\'.\\'){\\n                for(auto ptr = tmp->umap.begin(); ptr!=tmp->umap.end(); ptr++){\\n                    search2(word, i+1, ptr->second, ans);\\n                }\\n            }else if(tmp->umap.find(word[i]) != tmp->umap.end()){\\n                search2(word, i+1, tmp->umap[word[i]], ans);\\n            }\\n        }else{\\n            ans = ans || tmp->eow;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544869,
                "title": "simple-java-solution-using-trie-with-hashmap",
                "content": "\\n\\n```\\nclass WordDictionary {\\n\\n    private TrieNode root;\\n    \\n    /** Initialize your data structure here. */\\n    public class TrieNode {\\n        public Map<Character, TrieNode> children = new HashMap<>();\\n        public boolean isWord;\\n    }\\n    \\n    public WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n       \\n        TrieNode temp = root;\\n\\n        for (char c : word.toCharArray()) {\\n            if (temp.children.get(c) == null)\\n                temp.children.put(c, new TrieNode());\\n\\n            temp = temp.children.get(c);\\n        }\\n\\n        temp.isWord = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public boolean search(String word) {\\n        return match(word.toCharArray(), 0, root);\\n    }\\n    \\n    private boolean match(char[] chs, int k, TrieNode node) {\\n\\n        if (k == chs.length)\\n            return node.isWord;\\n\\n        if (chs[k] == \\'.\\') {\\n            for (Character curr: node.children.keySet()) {\\n                if (node.children.get(curr) != null && match(chs, k+1, node.children.get(curr)))\\n                    return true;\\n            }\\n        } else \\n            return node.children.get(chs[k]) != null && match(chs, k + 1, node.children.get(chs[k]));\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass WordDictionary {\\n\\n    private TrieNode root;\\n    \\n    /** Initialize your data structure here. */\\n    public class TrieNode {\\n        public Map<Character, TrieNode> children = new HashMap<>();\\n        public boolean isWord;\\n    }\\n    \\n    public WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n       \\n        TrieNode temp = root;\\n\\n        for (char c : word.toCharArray()) {\\n            if (temp.children.get(c) == null)\\n                temp.children.put(c, new TrieNode());\\n\\n            temp = temp.children.get(c);\\n        }\\n\\n        temp.isWord = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public boolean search(String word) {\\n        return match(word.toCharArray(), 0, root);\\n    }\\n    \\n    private boolean match(char[] chs, int k, TrieNode node) {\\n\\n        if (k == chs.length)\\n            return node.isWord;\\n\\n        if (chs[k] == \\'.\\') {\\n            for (Character curr: node.children.keySet()) {\\n                if (node.children.get(curr) != null && match(chs, k+1, node.children.get(curr)))\\n                    return true;\\n            }\\n        } else \\n            return node.children.get(chs[k]) != null && match(chs, k + 1, node.children.get(chs[k]));\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413270,
                "title": "java-with-map-and-trie",
                "content": "I used Trie with Map as its children. Using DFS to search for the word and deal with the dot separately. This is a good question to practice Trie.\\n```\\nclass WordDictionary {\\n    class TrieNode{\\n        Map<Character, TrieNode> children;\\n        boolean isWord;\\n        TrieNode() {\\n            children = new HashMap<>();\\n            isWord = false;\\n        }\\n    }\\n\\n    private TrieNode root;\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n        if (word == null || word.length() == 0) {\\n            return;\\n        }\\n        TrieNode cur = root;\\n        for (char c : word.toCharArray()) {\\n            TrieNode next = cur.children.get(c);\\n            if (next == null) {\\n                next = new TrieNode();\\n                cur.children.put(c, next);\\n            }\\n            cur = next;\\n        }\\n        cur.isWord = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public boolean search(String word) {\\n        return search(word, 0, root);\\n    }\\n    \\n    private boolean search(String word, int idx, TrieNode node) {\\n        if (idx == word.length()) {\\n            return node.isWord;\\n        }\\n        if (word.charAt(idx) == \\'.\\') {\\n            for (char c : node.children.keySet()) {\\n                if (search(word, idx + 1, node.children.get(c))) {\\n                    return true;\\n                }\\n            }\\n        }\\n        else {\\n            if (node.children.get(word.charAt(idx)) != null) {\\n                return search(word, idx + 1, node.children.get(word.charAt(idx)));\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass WordDictionary {\\n    class TrieNode{\\n        Map<Character, TrieNode> children;\\n        boolean isWord;\\n        TrieNode() {\\n            children = new HashMap<>();\\n            isWord = false;\\n        }\\n    }\\n\\n    private TrieNode root;\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n        if (word == null || word.length() == 0) {\\n            return;\\n        }\\n        TrieNode cur = root;\\n        for (char c : word.toCharArray()) {\\n            TrieNode next = cur.children.get(c);\\n            if (next == null) {\\n                next = new TrieNode();\\n                cur.children.put(c, next);\\n            }\\n            cur = next;\\n        }\\n        cur.isWord = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public boolean search(String word) {\\n        return search(word, 0, root);\\n    }\\n    \\n    private boolean search(String word, int idx, TrieNode node) {\\n        if (idx == word.length()) {\\n            return node.isWord;\\n        }\\n        if (word.charAt(idx) == \\'.\\') {\\n            for (char c : node.children.keySet()) {\\n                if (search(word, idx + 1, node.children.get(c))) {\\n                    return true;\\n                }\\n            }\\n        }\\n        else {\\n            if (node.children.get(word.charAt(idx)) != null) {\\n                return search(word, idx + 1, node.children.get(word.charAt(idx)));\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405285,
                "title": "python-tries-clean-code",
                "content": "```\\n\"\"\"\\nTrieNode class : It is representation of each TrieNode.\\n\\nTrie class: It has related operations related to tries. (Note: The search is modified to handle the regex matching)\\n\\n\"\"\"\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(list)\\n        self.isWord = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        root = self.root\\n        for w in word:\\n            if w not in root.children:\\n                root.children[w] = TrieNode()\\n            root = root.children[w]\\n        root.isWord = True\\n    \\n    def search(self, root, word):\\n        for i in range(len(word)):\\n            if word[i] != \\'.\\':\\n                if word[i] in root.children:\\n                    root = root.children[word[i]]\\n                else:\\n                    return False\\n            else:\\n\\t\\t\\t\\t#If the present char is a \\'.\\' then I visit all the children nodes in DFS manner to find match\\n                visitAll = root.children\\n                for child in visitAll:\\n                    if self.search(root.children[child], word[i+1:]):\\n                        return True\\n                return False\\n        return (root.isWord == True)\\n\\n\\nclass WordDictionary(object):\\n    def __init__(self):\\n        self.trie = Trie()\\n        self.root = self.trie.root\\n\\n    def addWord(self, word):\\n        self.trie.insert(word)\\n    \\n    def search(self, word):\\n        return self.trie.search(self.root, word)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n\"\"\"\\nTrieNode class : It is representation of each TrieNode.\\n\\nTrie class: It has related operations related to tries. (Note: The search is modified to handle the regex matching)\\n\\n\"\"\"\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(list)\\n        self.isWord = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        \\n    def insert(self, word):\\n        root = self.root\\n        for w in word:\\n            if w not in root.children:\\n                root.children[w] = TrieNode()\\n            root = root.children[w]\\n        root.isWord = True\\n    \\n    def search(self, root, word):\\n        for i in range(len(word)):\\n            if word[i] != \\'.\\':\\n                if word[i] in root.children:\\n                    root = root.children[word[i]]\\n                else:\\n                    return False\\n            else:\\n\\t\\t\\t\\t#If the present char is a \\'.\\' then I visit all the children nodes in DFS manner to find match\\n                visitAll = root.children\\n                for child in visitAll:\\n                    if self.search(root.children[child], word[i+1:]):\\n                        return True\\n                return False\\n        return (root.isWord == True)\\n\\n\\nclass WordDictionary(object):\\n    def __init__(self):\\n        self.trie = Trie()\\n        self.root = self.trie.root\\n\\n    def addWord(self, word):\\n        self.trie.insert(word)\\n    \\n    def search(self, word):\\n        return self.trie.search(self.root, word)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 319361,
                "title": "simple-python-solution",
                "content": "Please see and vote for my solutions for\\n[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/discuss/320224/Simple-Python-solution)\\n[1233. Remove Sub-Folders from the Filesystem](https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/discuss/409075/standard-python-prefix-tree-solution)\\n[1032. Stream of Characters](https://leetcode.com/problems/stream-of-characters/discuss/320837/Standard-Python-Trie-Solution)\\n[211. Add and Search Word - Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design/discuss/319361/Simple-Python-solution)\\n[676. Implement Magic Dictionary](https://leetcode.com/problems/implement-magic-dictionary/discuss/320197/Simple-Python-solution)\\n[677. Map Sum Pairs](https://leetcode.com/problems/map-sum-pairs/discuss/320237/Simple-Python-solution)\\n[745. Prefix and Suffix Search](https://leetcode.com/problems/prefix-and-suffix-search/discuss/320712/Different-Python-solutions-with-thinking-process)\\n[425. Word Squares](https://leetcode.com/problems/word-squares/discuss/320916/Easily-implemented-Python-solution%3A-Backtrack-%2B-Trie)\\n[472. Concatenated Words](https://leetcode.com/problems/concatenated-words/discuss/322444/Python-solutions%3A-top-down-DP-Trie)\\n[212. Word Search II](https://leetcode.com/problems/word-search-ii/discuss/319071/Standard-Python-solution-with-Trie-%2B-Backtrack)\\n[336. Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/discuss/316960/Different-Python-solutions%3A-brute-force-dictionary-Trie)\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n\\nclass WordDictionary:\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n\\n    def addWord(self, word: str) -> None:\\n        \"\"\"\\n        Adds a word into the data structure.\\n        \"\"\"\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.isEnd = True\\n\\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        \"\"\"\\n        def dfs(node, i, word):\\n            if i == len(word):\\n                return node.isEnd\\n            if word[i] == \\'.\\':\\n                for c in node.children:\\n                    if dfs(node.children[c], i + 1, word):\\n                        return True\\n                return False\\n            else:\\n                if word[i] not in node.children:\\n                    return False\\n                else:\\n                    return dfs(node.children[word[i]], i + 1, word)\\n        \\n        return dfs(self.root, 0, word)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n\\nclass WordDictionary:\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n\\n    def addWord(self, word: str) -> None:\\n        \"\"\"\\n        Adds a word into the data structure.\\n        \"\"\"\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.isEnd = True\\n\\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        \"\"\"\\n        def dfs(node, i, word):\\n            if i == len(word):\\n                return node.isEnd\\n            if word[i] == \\'.\\':\\n                for c in node.children:\\n                    if dfs(node.children[c], i + 1, word):\\n                        return True\\n                return False\\n            else:\\n                if word[i] not in node.children:\\n                    return False\\n                else:\\n                    return dfs(node.children[word[i]], i + 1, word)\\n        \\n        return dfs(self.root, 0, word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203116,
                "title": "python-trie-solution",
                "content": "The idea is the same as Stefan\\'s elegant solution: https://leetcode.com/problems/add-and-search-word-data-structure-design/discuss/59576/Tree-solutions-18-20-lines  But the differences are: 1. My code is using a class for Trie; 2. It has early return if the word is found; 3. It is not using pythonic \"list comprehension\", so in the end, it\\'s slower than Stefan\\'s code. But for reference, here is the code:\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n\\n    def addWord(self, word):\\n        \"\"\"\\n        Adds a word into the data structure.\\n        :type word: str\\n        :rtype: void\\n        \"\"\"\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.isWord = True\\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        cur = [self.root]\\n        for i, c in enumerate(word):\\n            newcur = []\\n            for node in cur:\\n                for ck, cv in node.children.items():\\n                    if c == \\'.\\' or c == ck:\\n                        if i == len(word) - 1 and cv.isWord:\\n                            return True\\n                        newcur.append(cv)\\n            cur = newcur\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n\\n    def addWord(self, word):\\n        \"\"\"\\n        Adds a word into the data structure.\\n        :type word: str\\n        :rtype: void\\n        \"\"\"\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.isWord = True\\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        cur = [self.root]\\n        for i, c in enumerate(word):\\n            newcur = []\\n            for node in cur:\\n                for ck, cv in node.children.items():\\n                    if c == \\'.\\' or c == ck:\\n                        if i == len(word) - 1 and cv.isWord:\\n                            return True\\n                        newcur.append(cv)\\n            cur = newcur\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173538,
                "title": "c-dictionary-solution-beats-100",
                "content": "```\\npublic class WordDictionary\\n{\\n    private Dictionary<int, List<string>> Map = new Dictionary<int, List<string>>(); // Length -> words\\n    \\n    public void AddWord(string word)\\n    {\\n        if (!Map.TryGetValue(word.Length, out var words))\\n            Map.Add(word.Length, new List<string>{word});\\n        else\\n            words.Add(word);\\n    }\\n    \\n    public bool Search(string word)\\n    {\\n        if (!Map.TryGetValue(word.Length, out var words))\\n            return false;\\n        foreach (var w in words)\\n        {\\n            var found = true;\\n            for (var i = 0; i < word.Length; i++)\\n            {\\n                if (word[i] != \\'.\\' && word[i] != w[i])\\n                {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if (found)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/nex-54/image_1537693445.png)\\n",
                "solutionTags": [],
                "code": "```\\npublic class WordDictionary\\n{\\n    private Dictionary<int, List<string>> Map = new Dictionary<int, List<string>>(); // Length -> words\\n    \\n    public void AddWord(string word)\\n    {\\n        if (!Map.TryGetValue(word.Length, out var words))\\n            Map.Add(word.Length, new List<string>{word});\\n        else\\n            words.Add(word);\\n    }\\n    \\n    public bool Search(string word)\\n    {\\n        if (!Map.TryGetValue(word.Length, out var words))\\n            return false;\\n        foreach (var w in words)\\n        {\\n            var found = true;\\n            for (var i = 0; i < word.Length; i++)\\n            {\\n                if (word[i] != \\'.\\' && word[i] != w[i])\\n                {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if (found)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59703,
                "title": "java-trie-easy-to-read",
                "content": "    public class WordDictionary {\\n        // Trie Node\\n        class Node{ \\n            // String word = \"\"; // will be set as  actual word when this node is \"end of the word\". \"\" otherwise.\\n            boolean isEnd = false;\\n            Node[] subs = new Node[26]; // a-z\\n        }\\n        \\n        private Node root = new Node(); //special value\\n        \\n        static int index(char c){\\n            return c-'a';\\n        }\\n        \\n        // Adds a word into the data structure.\\n        public void addWord(String word) {\\n            Node cur = root;\\n            for(char c : word.toCharArray()){\\n                if(cur.subs[index(c)] == null)\\n                    cur.subs[index(c)] = new Node();\\n                    \\n                cur = cur.subs[index(c)]; // forward\\n            }\\n            \\n            cur.isEnd = true;\\n        }\\n    \\n        // Returns if the word is in the data structure. A word could\\n        // contain the dot character '.' to represent any one letter.\\n        public boolean search(String word) {\\n            return search(root, word, 0);\\n        }\\n        \\n        private boolean search (Node cur, String word, int idx){\\n            if(cur == null) return false;\\n            else if(idx == word.length()){\\n                return cur.isEnd; // some words ended here.\\n            }\\n            \\n            final char c = word.charAt(idx);\\n            \\n            if(c == '.'){\\n                /*check existance*/\\n                for(Node n : cur.subs)\\n                    if(search (n, word, idx + 1))\\n                        return true;\\n                \\n                return false;\\n            }\\n            else{\\n                Node n = cur.subs[index(c)];\\n                return search(n, word, idx +1);\\n            }\\n        }\\n    \\n    }",
                "solutionTags": [],
                "code": "    public class WordDictionary {\\n        // Trie Node\\n        class Node{ \\n            // String word = \"\"; // will be set as  actual word when this node is \"end of the word\". \"\" otherwise.\\n            boolean isEnd = false;\\n            Node[] subs = new Node[26]; // a-z\\n        }\\n        \\n        private Node root = new Node(); //special value\\n        \\n        static int index(char c){\\n            return c-'a';\\n        }\\n        \\n        // Adds a word into the data structure.\\n        public void addWord(String word) {\\n            Node cur = root;\\n            for(char c : word.toCharArray()){\\n                if(cur.subs[index(c)] == null)\\n                    cur.subs[index(c)] = new Node();\\n                    \\n                cur = cur.subs[index(c)]; // forward\\n            }\\n            \\n            cur.isEnd = true;\\n        }\\n    \\n        // Returns if the word is in the data structure. A word could\\n        // contain the dot character '.' to represent any one letter.\\n        public boolean search(String word) {\\n            return search(root, word, 0);\\n        }\\n        \\n        private boolean search (Node cur, String word, int idx){\\n            if(cur == null) return false;\\n            else if(idx == word.length()){\\n                return cur.isEnd; // some words ended here.\\n            }\\n            \\n            final char c = word.charAt(idx);\\n            \\n            if(c == '.'){\\n                /*check existance*/\\n                for(Node n : cur.subs)\\n                    if(search (n, word, idx + 1))\\n                        return true;\\n                \\n                return false;\\n            }\\n            else{\\n                Node n = cur.subs[index(c)];\\n                return search(n, word, idx +1);\\n            }\\n        }\\n    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 59777,
                "title": "java-hashmap-backed-trie",
                "content": "Here is working Trie implementation that uses the HashMap for storing the references to the next nodes.\\n\\n    public class WordDictionary {\\n    \\n    private static final char WILDCARD = '.';\\n\\n    private final TrieNode root = new TrieNode();\\n\\n    // Adds a word into the data structure.\\n    public void addWord(String word) {\\n\\n        insert(root, word);\\n    }\\n\\n    // Returns if the word is in the data structure. A word could\\n    // contain the dot character '.' to represent any one letter.\\n    public boolean search(String word) {\\n\\n        return search(root, word, 0);\\n    }\\n    \\n    private void insert(TrieNode root, String word) {\\n\\n        TrieNode node = root;\\n        for(int ind = 0; ind < word.length(); ind++) {\\n            final char c = word.charAt(ind);\\n            if(!node.next.containsKey(c)) {\\n                node.next.put(c, new TrieNode());\\n            }\\n            node = node.next.get(c);\\n        }\\n        node.isWordEnd = true;\\n    }\\n\\n    private boolean search(TrieNode node, String word, int len) {\\n\\n        if(node == null) {\\n            return false;\\n        }\\n        if(len == word.length()) {\\n            return node.isWordEnd;\\n        }\\n        final char c = word.charAt(len);\\n        if(isWildcard(c)) {\\n            for(TrieNode next : node.next.values()) {\\n                if(search(next, word, len + 1)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        } else {\\n            return search(node.next.get(c), word, len + 1);\\n        }\\n    }\\n\\n    private boolean isWildcard(char c) {\\n        return c == WILDCARD;\\n    }\\n\\n    private static class TrieNode {\\n\\n        private final Map<Character, TrieNode> next = new HashMap<>();\\n        private boolean isWordEnd;\\n    }\\n    }",
                "solutionTags": [],
                "code": "Here is working Trie implementation that uses the HashMap for storing the references to the next nodes.\\n\\n    public class WordDictionary {\\n    \\n    private static final char WILDCARD = '.';\\n\\n    private final TrieNode root = new TrieNode();\\n\\n    // Adds a word into the data structure.\\n    public void addWord(String word) {\\n\\n        insert(root, word);\\n    }\\n\\n    // Returns if the word is in the data structure. A word could\\n    // contain the dot character '.' to represent any one letter.\\n    public boolean search(String word) {\\n\\n        return search(root, word, 0);\\n    }\\n    \\n    private void insert(TrieNode root, String word) {\\n\\n        TrieNode node = root;\\n        for(int ind = 0; ind < word.length(); ind++) {\\n            final char c = word.charAt(ind);\\n            if(!node.next.containsKey(c)) {\\n                node.next.put(c, new TrieNode());\\n            }\\n            node = node.next.get(c);\\n        }\\n        node.isWordEnd = true;\\n    }\\n\\n    private boolean search(TrieNode node, String word, int len) {\\n\\n        if(node == null) {\\n            return false;\\n        }\\n        if(len == word.length()) {\\n            return node.isWordEnd;\\n        }\\n        final char c = word.charAt(len);\\n        if(isWildcard(c)) {\\n            for(TrieNode next : node.next.values()) {\\n                if(search(next, word, len + 1)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        } else {\\n            return search(node.next.get(c), word, len + 1);\\n        }\\n    }\\n\\n    private boolean isWildcard(char c) {\\n        return c == WILDCARD;\\n    }\\n\\n    private static class TrieNode {\\n\\n        private final Map<Character, TrieNode> next = new HashMap<>();\\n        private boolean isWordEnd;\\n    }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3317712,
                "title": "c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass WordDictionary {\\npublic:\\n    vector<string> v;\\n    WordDictionary() {\\n        \\n    }\\n    \\n    void addWord(string word) {\\n        v.push_back(word);\\n    }\\n    \\n    bool search(string word) {\\n        int count=0;\\n        int n=word.size();\\n        for(int i=0; i<v.size(); i++){\\n            if(n==v[i].size()){\\n                for(int j=0; j<n; j++){\\n                    if(v[i][j]==word[j]||word[j]==\\'.\\'){\\n                        count++;\\n                    }\\n                    else{\\n                        count=0;\\n                        break;\\n                    }\\n                }\\n                if(count==n) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass WordDictionary {\\npublic:\\n    vector<string> v;\\n    WordDictionary() {\\n        \\n    }\\n    \\n    void addWord(string word) {\\n        v.push_back(word);\\n    }\\n    \\n    bool search(string word) {\\n        int count=0;\\n        int n=word.size();\\n        for(int i=0; i<v.size(); i++){\\n            if(n==v[i].size()){\\n                for(int j=0; j<n; j++){\\n                    if(v[i][j]==word[j]||word[j]==\\'.\\'){\\n                        count++;\\n                    }\\n                    else{\\n                        count=0;\\n                        break;\\n                    }\\n                }\\n                if(count==n) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936989,
                "title": "pretty-efficient-using-trie-codedominar-solution",
                "content": "# Code\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n        \\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def addWord(self, word: str) -> None:\\n        curr = self.root\\n        for w in word:\\n            if w not in curr.children:\\n                curr.children[w] = TrieNode()\\n            curr = curr.children[w]  \\n        curr.is_word = True    \\n\\n    def search(self, word: str) -> bool:\\n        stack = [(self.root,0)]\\n        while stack:\\n            curr,idx = stack.pop()\\n            if idx == len(word):\\n                if curr.is_word:\\n                    return True\\n            elif word[idx] == \\'.\\':\\n                for child in curr.children.values():\\n                    stack.append((child,idx+1))\\n            elif word[idx] in curr.children:\\n                stack.append((curr.children[word[idx]], idx+1))\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n        \\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def addWord(self, word: str) -> None:\\n        curr = self.root\\n        for w in word:\\n            if w not in curr.children:\\n                curr.children[w] = TrieNode()\\n            curr = curr.children[w]  \\n        curr.is_word = True    \\n\\n    def search(self, word: str) -> bool:\\n        stack = [(self.root,0)]\\n        while stack:\\n            curr,idx = stack.pop()\\n            if idx == len(word):\\n                if curr.is_word:\\n                    return True\\n            elif word[idx] == \\'.\\':\\n                for child in curr.children.values():\\n                    stack.append((child,idx+1))\\n            elif word[idx] in curr.children:\\n                stack.append((curr.children[word[idx]], idx+1))\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677472,
                "title": "python-trie-solution-6170-ms",
                "content": "My solution is very similar to other people\\'s answers so I will just say how mine is different.\\n\\nI will remember the length of the longest given word, so if someone tries to \\'look up\\' a word that consists of more letters than the longest of our available words, then we can automatically return False.\\n\\nThis way our algorithm will be a lot faster.\\nPlease ask any questions if something is not clear to you, after all, my code is pretty messy.\\n\\n\\tclass TrieNode:\\n\\n\\t\\tdef __init__(self, char=\\'\\'):\\n\\n\\t\\t\\tself.children = dict()\\n\\t\\t\\tself.is_word = False\\n\\n\\n\\tclass Trie:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.root = TrieNode()\\n\\n\\t\\tdef add(self, word: str):\\n\\n\\t\\t\\tnode = self.root\\n\\n\\t\\t\\tfor char in word:\\n\\t\\t\\t\\tif char not in node.children:\\n\\t\\t\\t\\t\\tnode.children[char] = TrieNode()\\n\\n\\t\\t\\t\\tnode = node.children[char]\\n\\n\\t\\t\\tnode.is_word = True\\n\\n\\t\\tdef search(self, word: str, index: int, node=None):\\n\\n\\t\\t\\tif node is None: node = self.root\\n\\n\\t\\t\\tfor i in range(index, len(word)):\\n\\t\\t\\t\\tif word[i] == \\'.\\':\\n\\t\\t\\t\\t\\tfor child in node.children.values():\\n\\t\\t\\t\\t\\t\\tif self.search(word, i+1, child):\\n\\t\\t\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tif word[i] not in node.children:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tnode = node.children[word[i]]\\n\\n\\t\\t\\treturn node.is_word\\n\\n\\n\\tclass WordDictionary:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.trie = Trie()\\n\\t\\t\\tself.longest = 0\\n\\n\\t\\tdef addWord(self, word: str) -> None:\\n\\t\\t\\tself.trie.add(word)\\n\\t\\t\\tself.longest = max(self.longest, len(word))\\n\\n\\t\\tdef search(self, word: str) -> bool:\\n\\t\\t\\tif len(word) > self.longest: return False\\n\\t\\t\\treturn self.trie.search(word, 0)\\n",
                "solutionTags": [],
                "code": "My solution is very similar to other people\\'s answers so I will just say how mine is different.\\n\\nI will remember the length of the longest given word, so if someone tries to \\'look up\\' a word that consists of more letters than the longest of our available words, then we can automatically return False.\\n\\nThis way our algorithm will be a lot faster.\\nPlease ask any questions if something is not clear to you, after all, my code is pretty messy.\\n\\n\\tclass TrieNode:\\n\\n\\t\\tdef __init__(self, char=\\'\\'):\\n\\n\\t\\t\\tself.children = dict()\\n\\t\\t\\tself.is_word = False\\n\\n\\n\\tclass Trie:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.root = TrieNode()\\n\\n\\t\\tdef add(self, word: str):\\n\\n\\t\\t\\tnode = self.root\\n\\n\\t\\t\\tfor char in word:\\n\\t\\t\\t\\tif char not in node.children:\\n\\t\\t\\t\\t\\tnode.children[char] = TrieNode()\\n\\n\\t\\t\\t\\tnode = node.children[char]\\n\\n\\t\\t\\tnode.is_word = True\\n\\n\\t\\tdef search(self, word: str, index: int, node=None):\\n\\n\\t\\t\\tif node is None: node = self.root\\n\\n\\t\\t\\tfor i in range(index, len(word)):\\n\\t\\t\\t\\tif word[i] == \\'.\\':\\n\\t\\t\\t\\t\\tfor child in node.children.values():\\n\\t\\t\\t\\t\\t\\tif self.search(word, i+1, child):\\n\\t\\t\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tif word[i] not in node.children:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tnode = node.children[word[i]]\\n\\n\\t\\t\\treturn node.is_word\\n\\n\\n\\tclass WordDictionary:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.trie = Trie()\\n\\t\\t\\tself.longest = 0\\n\\n\\t\\tdef addWord(self, word: str) -> None:\\n\\t\\t\\tself.trie.add(word)\\n\\t\\t\\tself.longest = max(self.longest, len(word))\\n\\n\\t\\tdef search(self, word: str) -> bool:\\n\\t\\t\\tif len(word) > self.longest: return False\\n\\t\\t\\treturn self.trie.search(word, 0)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2636411,
                "title": "python-dfs-no-tle-error-95-time",
                "content": "The key to using DFS and not getting a TLE error is the max_length attribute.\\n```\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.edges = {}\\n        self.isWord = False\\n\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.head = TrieNode()\\n        self.max_length = 0\\n    def addWord(self, word: str) -> None:\\n        curr = self.head\\n        i = 0\\n        for c in word:\\n            #check if c is in edges, if yes, move to it,\\n            if c not in curr.edges:\\n                curr.edges[c] = TrieNode()\\n            curr = curr.edges[c]\\n            i += 1\\n        #now mark isWord to True\\n        curr.isWord = True\\n        self.max_length = max(self.max_length, i)\\n    def search(self, word: str) -> bool:\\n\\n        def dfs(j, head):\\n            curr = head\\n            \\n            for i in range(j, len(word)):\\n                c = word[i]\\n                if c == \".\":\\n                    # if ., iterate over all edges and make a recusrive call\\n                    for v in curr.edges.values():\\n                        if dfs(i + 1, v):\\n                            return True\\n                    return False\\n                else:\\n                    if c not in curr.edges:\\n                        return False\\n                    curr = curr.edges[c]\\n            return curr.isWord\\n        \\n        if len(word) > self.max_length:\\n            return False\\n\\n        return dfs(0, self.head)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n    def __init__(self):\\n        self.edges = {}\\n        self.isWord = False\\n\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.head = TrieNode()\\n        self.max_length = 0\\n    def addWord(self, word: str) -> None:\\n        curr = self.head\\n        i = 0\\n        for c in word:\\n            #check if c is in edges, if yes, move to it,\\n            if c not in curr.edges:\\n                curr.edges[c] = TrieNode()\\n            curr = curr.edges[c]\\n            i += 1\\n        #now mark isWord to True\\n        curr.isWord = True\\n        self.max_length = max(self.max_length, i)\\n    def search(self, word: str) -> bool:\\n\\n        def dfs(j, head):\\n            curr = head\\n            \\n            for i in range(j, len(word)):\\n                c = word[i]\\n                if c == \".\":\\n                    # if ., iterate over all edges and make a recusrive call\\n                    for v in curr.edges.values():\\n                        if dfs(i + 1, v):\\n                            return True\\n                    return False\\n                else:\\n                    if c not in curr.edges:\\n                        return False\\n                    curr = curr.edges[c]\\n            return curr.isWord\\n        \\n        if len(word) > self.max_length:\\n            return False\\n\\n        return dfs(0, self.head)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514891,
                "title": "clean-c-implementation",
                "content": "\\n```\\nclass WordDictionary {\\npublic:\\n    \\n    WordDictionary *child[26] = {};\\n    bool isWord = false;\\n    \\n    WordDictionary() {\\n        \\n    }\\n    \\n    void addWord(string word) {\\n        WordDictionary *root = this;\\n        for(char &x : word) {\\n            int ind = x-\\'a\\';\\n\\t\\t\\t// check if the child already exists, create if not\\n            if(!root->child[ind]) root->child[ind] =  new WordDictionary();\\n            root = root->child[ind];\\n        }\\n        root->isWord = true;\\n    }\\n    \\n    bool search(string word) {\\n        return search(word, 0, this);\\n    }\\n    \\n\\t/* Start with index 0 and recursively check if the string matches with our existing WordDictionary\\n\\tConditional validations for each index include,\\n\\t- If the index contains a character which is not \".\" -> then check if the character exists as child of root & proceed to the next index\\n\\t- If the index contains \".\" -> recursively call the search function for all the available 26 childs and proceed with the next index\\n\\t- Termination Condition : When we complete all the characters of the given word (index == word.length()), check if the root is a valid word here (using root->isWord) and return accordingly. */\\n\\t\\n    bool search(string &word, int ind, WordDictionary *root) {\\n        if(ind==word.length()) return root->isWord;\\n        char x = word[ind];\\n        if(x!=\\'.\\') {\\n            return root->child[x-\\'a\\'] && search(word, ind+1, root->child[x-\\'a\\']);\\n        }\\n        else {\\n            for(int i=0;i<26;i++) {\\n                if(root->child[i] && search(word, ind+1, root->child[i])) return true;\\n            }\\n            return false;\\n        }\\n        return root->isWord;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass WordDictionary {\\npublic:\\n    \\n    WordDictionary *child[26] = {};\\n    bool isWord = false;\\n    \\n    WordDictionary() {\\n        \\n    }\\n    \\n    void addWord(string word) {\\n        WordDictionary *root = this;\\n        for(char &x : word) {\\n            int ind = x-\\'a\\';\\n\\t\\t\\t// check if the child already exists, create if not\\n            if(!root->child[ind]) root->child[ind] =  new WordDictionary();\\n            root = root->child[ind];\\n        }\\n        root->isWord = true;\\n    }\\n    \\n    bool search(string word) {\\n        return search(word, 0, this);\\n    }\\n    \\n\\t/* Start with index 0 and recursively check if the string matches with our existing WordDictionary\\n\\tConditional validations for each index include,\\n\\t- If the index contains a character which is not \".\" -> then check if the character exists as child of root & proceed to the next index\\n\\t- If the index contains \".\" -> recursively call the search function for all the available 26 childs and proceed with the next index\\n\\t- Termination Condition : When we complete all the characters of the given word (index == word.length()), check if the root is a valid word here (using root->isWord) and return accordingly. */\\n\\t\\n    bool search(string &word, int ind, WordDictionary *root) {\\n        if(ind==word.length()) return root->isWord;\\n        char x = word[ind];\\n        if(x!=\\'.\\') {\\n            return root->child[x-\\'a\\'] && search(word, ind+1, root->child[x-\\'a\\']);\\n        }\\n        else {\\n            for(int i=0;i<26;i++) {\\n                if(root->child[i] && search(word, ind+1, root->child[i])) return true;\\n            }\\n            return false;\\n        }\\n        return root->isWord;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178429,
                "title": "c-solution-clean-code-trie",
                "content": "```\\nstruct Node{\\n    Node* links[26];\\n    bool flag = false;\\n    \\n    bool containsKey(char ch){\\n        return links[ch-\\'a\\']!=NULL;\\n    }\\n    \\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    \\n    void put(char ch,Node* node){\\n        links[ch-\\'a\\'] = node;\\n    }\\n    \\n    void setEnd(){\\n        flag = true;\\n    }\\n    \\n    bool isEnd(){\\n        return flag;\\n    }\\n};\\n\\nclass WordDictionary {\\n    Node* root;\\npublic:\\n    WordDictionary() {\\n        root = new Node();\\n    }\\n    \\n    void addWord(string word) {\\n        Node* node = root;\\n        for(int i = 0;i<word.size();i++){\\n            if(!node->containsKey(word[i])){\\n                node->put(word[i],new Node());\\n            }\\n            node = node->get(word[i]);\\n        }\\n        node->setEnd();\\n    }\\n    \\n    bool search(Node* node,string word){\\n        for(int i = 0;i<word.size();i++){\\n            if(word[i]==\\'.\\'){\\n                for(int j = 0;j<26;j++){\\n                    if(node->links[j]!=NULL){\\n                        if(search(node->links[j],word.substr(i+1))){ //imp\\n                            return true;\\n                        }\\n                    }\\n                }\\n                return false;\\n            }\\n            if(!node->containsKey(word[i])){\\n                return false;\\n            }\\n            else\\n            node = node->get(word[i]);\\n        }\\n        return node->isEnd();\\n    }\\n    \\n    bool search(string word) {\\n        Node* node = root;\\n        return search(node,word);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie",
                    "Iterator"
                ],
                "code": "```\\nstruct Node{\\n    Node* links[26];\\n    bool flag = false;\\n    \\n    bool containsKey(char ch){\\n        return links[ch-\\'a\\']!=NULL;\\n    }\\n    \\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    \\n    void put(char ch,Node* node){\\n        links[ch-\\'a\\'] = node;\\n    }\\n    \\n    void setEnd(){\\n        flag = true;\\n    }\\n    \\n    bool isEnd(){\\n        return flag;\\n    }\\n};\\n\\nclass WordDictionary {\\n    Node* root;\\npublic:\\n    WordDictionary() {\\n        root = new Node();\\n    }\\n    \\n    void addWord(string word) {\\n        Node* node = root;\\n        for(int i = 0;i<word.size();i++){\\n            if(!node->containsKey(word[i])){\\n                node->put(word[i],new Node());\\n            }\\n            node = node->get(word[i]);\\n        }\\n        node->setEnd();\\n    }\\n    \\n    bool search(Node* node,string word){\\n        for(int i = 0;i<word.size();i++){\\n            if(word[i]==\\'.\\'){\\n                for(int j = 0;j<26;j++){\\n                    if(node->links[j]!=NULL){\\n                        if(search(node->links[j],word.substr(i+1))){ //imp\\n                            return true;\\n                        }\\n                    }\\n                }\\n                return false;\\n            }\\n            if(!node->containsKey(word[i])){\\n                return false;\\n            }\\n            else\\n            node = node->get(word[i]);\\n        }\\n        return node->isEnd();\\n    }\\n    \\n    bool search(string word) {\\n        Node* node = root;\\n        return search(node,word);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062472,
                "title": "c-trie-cache-solution-new-tle-case-explained",
                "content": "Recently went back to re-do this problem and discovered my original solution was no longer working and getting TLE.\\n\\nThe testcase that was causing the timeout was a bunch of identical searches like this:\\n`... , [\"...z\"], [\"...z\"], ... , [\"...z\"]`\\n\\nWithout a cache, we\\'re re-doing the same work each on each search - traversing the Trie and checking all the children of each node where there is a wildcard - even though we already know the answer.\\nWe can store search results in a cache to return the results of repeated searches in O(1). We just need to be careful though because adding additional words could invalidate the results of our cache. \\nIn my implementation, I cleared the cache when adding a word since this was simple. But if anyone has other ideas for a caching strategy please comment :)\\n\\n```\\nstruct TrieNode {\\n    bool isWord;\\n    unordered_map<char, TrieNode*> next;\\n};\\n\\nclass WordDictionary {\\npublic:\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        cache.clear();\\n        \\n        TrieNode* cur = root;\\n        \\n        for (char c : word) {\\n            if (!cur->next.count(c)) {\\n                cur->next[c] = new TrieNode();\\n            }\\n            cur = cur->next[c];\\n        }\\n        \\n        cur->isWord = true;\\n    }\\n    \\n    bool search(string word) {\\n        if (cache.count(word)) {\\n            return cache[word];\\n        }\\n        \\n        bool result = searchInNode(word, 0, root);\\n        cache[word] = result;\\n            \\n        return result;\\n    }\\n    \\nprivate:\\n    TrieNode* root = nullptr;\\n    unordered_map<string, bool> cache;\\n    \\n    bool searchInNode(string& word, int curPos, TrieNode* node) {\\n        if (node == nullptr) {\\n            return false;\\n        }\\n        \\n        for (int i = curPos; i < word.length(); i++) {\\n            char c = word[i];\\n            \\n            if (node->next.count(c)) {\\n                node = node->next[c];\\n            }\\n            else {\\n                if (c == \\'.\\') {\\n                    for (auto& iter : node->next) {\\n                        TrieNode* child = iter.second;\\n                        \\n                        if (searchInNode(word, i + 1, child)) {\\n                            return true;\\n                        }\\n                    }\\n                }\\n                \\n                return false;\\n            }\\n        }\\n        \\n        return node->isWord;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nstruct TrieNode {\\n    bool isWord;\\n    unordered_map<char, TrieNode*> next;\\n};\\n\\nclass WordDictionary {\\npublic:\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        cache.clear();\\n        \\n        TrieNode* cur = root;\\n        \\n        for (char c : word) {\\n            if (!cur->next.count(c)) {\\n                cur->next[c] = new TrieNode();\\n            }\\n            cur = cur->next[c];\\n        }\\n        \\n        cur->isWord = true;\\n    }\\n    \\n    bool search(string word) {\\n        if (cache.count(word)) {\\n            return cache[word];\\n        }\\n        \\n        bool result = searchInNode(word, 0, root);\\n        cache[word] = result;\\n            \\n        return result;\\n    }\\n    \\nprivate:\\n    TrieNode* root = nullptr;\\n    unordered_map<string, bool> cache;\\n    \\n    bool searchInNode(string& word, int curPos, TrieNode* node) {\\n        if (node == nullptr) {\\n            return false;\\n        }\\n        \\n        for (int i = curPos; i < word.length(); i++) {\\n            char c = word[i];\\n            \\n            if (node->next.count(c)) {\\n                node = node->next[c];\\n            }\\n            else {\\n                if (c == \\'.\\') {\\n                    for (auto& iter : node->next) {\\n                        TrieNode* child = iter.second;\\n                        \\n                        if (searchInNode(word, i + 1, child)) {\\n                            return true;\\n                        }\\n                    }\\n                }\\n                \\n                return false;\\n            }\\n        }\\n        \\n        return node->isWord;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725891,
                "title": "c-dfs-deconstructor-tc-o-n-to-add-o-26-n-to-search",
                "content": "```\\nclass TrieNode{\\npublic:\\n    TrieNode* children[26] = {NULL};\\n    int isWord = false;\\n};\\n\\nclass WordDictionary {\\nprivate:\\n    TrieNode* root;\\npublic:\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    void addWord(string word) {   //O(N) TIME\\n        auto cur = root;\\n        for(auto &w : word){\\n            int k = w - \\'a\\';\\n            if(cur->children[k]==NULL){\\n                cur->children[k] = new TrieNode;\\n            }\\n            cur = cur->children[k];\\n        }\\n        cur->isWord = true;\\n    }\\n    bool searchWord(string &word, int ind, TrieNode* cur){  //O(26^N) TIME\\n        for(int i = ind; i < word.size(); i++){\\n            if(word[i]==\\'.\\'){\\n                for(int k = 0 ; k < 26; k++){\\n                    auto temp = cur->children[k];\\n                    if(temp!=NULL && searchWord(word, i+1, temp))\\n                            return true;\\n                }   \\n                return false;\\n            }else{\\n                int k = word[i] - \\'a\\';\\n                cur = cur->children[k];   \\n                if(cur == NULL) return false;\\n            }\\n        }\\n        return cur->isWord;\\n    }\\n    bool search(string word) {\\n        return searchWord(word, 0, root);\\n    }\\n    \\n    //Deconstructor\\n    ~WordDictionary(){                      \\n        clear_nodes(root);\\n    }\\n    void clear_nodes(TrieNode* root) \\n    {\\n        for(int i = 0; i<26; i++)\\n            if(root->children[i] != NULL)\\n                clear_nodes(root->children[i]);\\n        delete root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass TrieNode{\\npublic:\\n    TrieNode* children[26] = {NULL};\\n    int isWord = false;\\n};\\n\\nclass WordDictionary {\\nprivate:\\n    TrieNode* root;\\npublic:\\n    WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    void addWord(string word) {   //O(N) TIME\\n        auto cur = root;\\n        for(auto &w : word){\\n            int k = w - \\'a\\';\\n            if(cur->children[k]==NULL){\\n                cur->children[k] = new TrieNode;\\n            }\\n            cur = cur->children[k];\\n        }\\n        cur->isWord = true;\\n    }\\n    bool searchWord(string &word, int ind, TrieNode* cur){  //O(26^N) TIME\\n        for(int i = ind; i < word.size(); i++){\\n            if(word[i]==\\'.\\'){\\n                for(int k = 0 ; k < 26; k++){\\n                    auto temp = cur->children[k];\\n                    if(temp!=NULL && searchWord(word, i+1, temp))\\n                            return true;\\n                }   \\n                return false;\\n            }else{\\n                int k = word[i] - \\'a\\';\\n                cur = cur->children[k];   \\n                if(cur == NULL) return false;\\n            }\\n        }\\n        return cur->isWord;\\n    }\\n    bool search(string word) {\\n        return searchWord(word, 0, root);\\n    }\\n    \\n    //Deconstructor\\n    ~WordDictionary(){                      \\n        clear_nodes(root);\\n    }\\n    void clear_nodes(TrieNode* root) \\n    {\\n        for(int i = 0; i<26; i++)\\n            if(root->children[i] != NULL)\\n                clear_nodes(root->children[i]);\\n        delete root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725788,
                "title": "c-faster-then-97-search-function-explained-trie",
                "content": "```\\nclass WordDictionary {\\npublic:\\n    class Node {\\n    public:\\n        Node *child[26];\\n        bool isEnd;\\n    \\n        Node() {\\n            isEnd = false;\\n            for(int i = 0; i<26 ; i++){\\n                child[i] = NULL;\\n            }\\n        }\\n    };\\n    class Trie {\\n    public:\\n        Node *root;\\n        Trie(){\\n            root = new Node();\\n        }\\n        void insert(string &s){\\n            Node *curr = root;\\n            for(int i=0;i<s.size(); i++){\\n                int idx = s[i] -\\'a\\';\\n                if(curr->child[idx] == NULL){\\n                    curr->child[idx] = new Node();\\n                }\\n                curr = curr->child[idx];\\n            }\\n            curr->isEnd = true;\\n        }\\n        bool isFound(string &s, Node *node, int it=0){    //dfs\\n            if(!node)return false;                          // as node is null, we can\\'t go further \\n            if(it==s.size()){                              // we are at end, return true if we have a word ending at that point\\n                return node->isEnd;\\n            }\\n            if(s[it]!=\\'.\\'){                               //if s[i] != \\'.\\' ,we have to chek if child of node at s[i]-\\'a\\' is present \\n                return isFound(s,node->child[s[it]-\\'a\\'], it+1);\\n            }else{\\n                for(int i=0;i<26;i++){             //else we have to check at all 26 options, if any option could lead us true, \\n                    if(isFound(s, node->child[i], it+1)){\\n                        return true;\\n                    }\\n                }\\n                return false;                    //otherwise return false;\\n            }\\n        }\\n        \\n    };\\n    Trie t1;\\n    WordDictionary() {\\n        \\n    }\\n    \\n    void addWord(string word) {\\n        t1.insert(word);\\n    }\\n    \\n    bool search(string word) {\\n        return t1.isFound(word, t1.root);\\n    }\\n};\\n\\n// Please feel free to ask, if you have any doubt( in comment section )\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass WordDictionary {\\npublic:\\n    class Node {\\n    public:\\n        Node *child[26];\\n        bool isEnd;\\n    \\n        Node() {\\n            isEnd = false;\\n            for(int i = 0; i<26 ; i++){\\n                child[i] = NULL;\\n            }\\n        }\\n    };\\n    class Trie {\\n    public:\\n        Node *root;\\n        Trie(){\\n            root = new Node();\\n        }\\n        void insert(string &s){\\n            Node *curr = root;\\n            for(int i=0;i<s.size(); i++){\\n                int idx = s[i] -\\'a\\';\\n                if(curr->child[idx] == NULL){\\n                    curr->child[idx] = new Node();\\n                }\\n                curr = curr->child[idx];\\n            }\\n            curr->isEnd = true;\\n        }\\n        bool isFound(string &s, Node *node, int it=0){    //dfs\\n            if(!node)return false;                          // as node is null, we can\\'t go further \\n            if(it==s.size()){                              // we are at end, return true if we have a word ending at that point\\n                return node->isEnd;\\n            }\\n            if(s[it]!=\\'.\\'){                               //if s[i] != \\'.\\' ,we have to chek if child of node at s[i]-\\'a\\' is present \\n                return isFound(s,node->child[s[it]-\\'a\\'], it+1);\\n            }else{\\n                for(int i=0;i<26;i++){             //else we have to check at all 26 options, if any option could lead us true, \\n                    if(isFound(s, node->child[i], it+1)){\\n                        return true;\\n                    }\\n                }\\n                return false;                    //otherwise return false;\\n            }\\n        }\\n        \\n    };\\n    Trie t1;\\n    WordDictionary() {\\n        \\n    }\\n    \\n    void addWord(string word) {\\n        t1.insert(word);\\n    }\\n    \\n    bool search(string word) {\\n        return t1.isFound(word, t1.root);\\n    }\\n};\\n\\n// Please feel free to ask, if you have any doubt( in comment section )\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725780,
                "title": "python-most-intuitive-solution-using-dictionary-and-re-28th-jan",
                "content": "```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.dct = {}\\n        \\n    def addWord(self, word):\\n        if len(word) in self.dct.keys():\\n            self.dct[len(word)].append(word)\\n        else:\\n            self.dct[len(word)] = [word]\\n        #print(self.dct)\\n        \\n    def search(self, word):\\n        if len(word) in self.dct.keys():\\n            r = re.compile(\\'^\\' + word + \\'$\\')\\n            return len(list(filter(r.match, self.dct[len(word)])))>0\\n\\t\\t\\t# or you can use this too:  return any(r.match(line) for line in self.dct[len(word)])\\n        else:\\n            return False\\n```\\n\\nFeel free to comment if you did not get any part of the code. And upvote if it helped you. Thanks in advance.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.dct = {}\\n        \\n    def addWord(self, word):\\n        if len(word) in self.dct.keys():\\n            self.dct[len(word)].append(word)\\n        else:\\n            self.dct[len(word)] = [word]\\n        #print(self.dct)\\n        \\n    def search(self, word):\\n        if len(word) in self.dct.keys():\\n            r = re.compile(\\'^\\' + word + \\'$\\')\\n            return len(list(filter(r.match, self.dct[len(word)])))>0\\n\\t\\t\\t# or you can use this too:  return any(r.match(line) for line in self.dct[len(word)])\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725751,
                "title": "kotlin-fast-trie-solution-explained",
                "content": "To solve this challenge using Trie data structure is the most appropriate way. I mean, let\\'s look at the challenge description again:\\n\"Design a data structure that supports adding new words and finding if a string matches any previously added string.\"\\n\\nIsn\\'t it just a definition of Trie? It just looks like challenge author asked us to implement Trie without actually asking us to implement Trie. So Trie it is. Now, if you are not familiar with the Trie data structure yet, let\\'s dive into it for a minute.\\n\\nThe trie data structure (or prefix tree) is very interesting data structure for storing strings (or actually any other elements that you can split into atomic parts. numbers, for example, can be split into digits). It works as follows:\\n\\n1. We start with an empty root node\\n![image](https://assets.leetcode.com/users/images/8d173b62-ca0e-43da-b876-42aff1e2d6e4_1643352804.2674875.png)\\n\\n2. We can insert some string into the tree by splitting it into atomic elements - chars. Let\\'s insert the word `bad` into our trie. We split it into `b`, `a`, and `d` and link `b` to the root node, `a` to the `b` node and `d` to the `a` node. We also mark node `d` as a \"word\" meaning that there is a word ending at this node.\\n\\n![image](https://assets.leetcode.com/users/images/8aef38a3-2a08-4131-af9e-f4e9d6d3aeab_1643353095.4774163.png)\\n\\n3. Now we can check that our trie contains word `bad`. We split the word into characters again and first check that the root node has child with value  `b`, `b` node has a child with value `a`, and finally `a` node has a child with value `d` and also `d` is the end of the word. Note that there is no words `b` or `ba` in our trie, because nodes `b` and `a` are not marked as words.\\n\\n4. Let\\'s add some other words to the trie. We will add words `badland`, `bass`, `dog` and `bus` into the trie:\\n\\t4.1. Adding `badland`: root already has child with value `b`, so we just move to node `b`. `b` already has child `a` and `a` already has child `d` so we move to `d` the same way. Now `d` has not a child with value `l` so we create new node `l`, link it to `d` and move to node `l`. Same situation appears for characters `a`, `n` and `d`. Finally, we mark `d` as a word.\\n\\t4.2. Adding `bass`: we move to the node `root -> b -> a` same way as we did for word `badland`, now node `a` doesn\\'t have child with value `s`, so we create new node and move to it. Same for the second `s`.\\n\\t4.3. I suppose you can figure out how to add other words using the same logic.\\n\\n![image](https://assets.leetcode.com/users/images/16d70bdd-fc2f-4597-87e4-718de885668b_1643353934.8150754.png)\\n\\nSo, the trie we just described is already looks like the solution to the challenge. Except one thing: we need to deal with `.` cahracter. When we have any other character we can just check if current node has a child with this value. But for `.` we have to check all the children for this node, so search will be not iterative, but recursive. Modified version of trie will still work as a simple trie for strings without `.` characters and for `.` it will recursively split between subtrees. Below is the solution code. We just need to implement the `Trie` class and funcions `addWord` and `search` just directly coresspond to `Trie` methods.\\n\\n```\\nclass WordDictionary() {\\n    \\n    private class Trie {\\n        private val root = Node(\\'.\\')\\n        private class Node(val value: Char, val children: Array<Node?> = Array<Node?>(26) { null }, var isWord: Boolean = false)\\n        \\n        fun insert(word: String) {\\n            var currNode = root\\n            for (char in word) {\\n\\t\\t\\t\\t// If child node doesn\\'t yet exist, create one\\n                if (currNode.children[char - \\'a\\'] == null) currNode.children[char - \\'a\\'] = Node(char)\\n\\t\\t\\t\\t// Move to child node\\n                currNode = currNode.children[char - \\'a\\']!!\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// When reached the end of the word, mark the node as a word\\n            currNode.isWord = true\\n        }\\n        \\n\\t\\t// Recursive search\\n        private fun _contains(node: Node, word: String, index: Int): Boolean {\\n            if (index == word.length - 1) {\\n                if (word[index] == \\'.\\') return node.children.any { it != null && it.isWord }\\n                else return node.children[word[index] - \\'a\\']?.isWord ?: false\\n            }\\n            \\n            if (word[index] == \\'.\\') {\\n                for (n in node.children) {\\n                    if (n == null) continue\\n\\t\\t\\t\\t\\t// Here we recursively split between subtrees\\n                    if (_contains(n!!, word, index + 1)) return true\\n                }\\n                return false\\n            } else {\\n                if (node.children[word[index] - \\'a\\'] == null) return false\\n                return _contains(node.children[word[index] - \\'a\\']!!, word, index + 1)\\n            }\\n            \\n            return false\\n        }\\n        \\n        fun contains(word: String): Boolean {\\n            return _contains(root, word, 0)\\n        }\\n    }\\n\\n    private val trie = Trie()\\n    \\n    fun addWord(word: String) {\\n        trie.insert(word)\\n    }\\n\\n    fun search(word: String): Boolean {\\n        return trie.contains(word)\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Trie"
                ],
                "code": "```\\nclass WordDictionary() {\\n    \\n    private class Trie {\\n        private val root = Node(\\'.\\')\\n        private class Node(val value: Char, val children: Array<Node?> = Array<Node?>(26) { null }, var isWord: Boolean = false)\\n        \\n        fun insert(word: String) {\\n            var currNode = root\\n            for (char in word) {\\n\\t\\t\\t\\t// If child node doesn\\'t yet exist, create one\\n                if (currNode.children[char - \\'a\\'] == null) currNode.children[char - \\'a\\'] = Node(char)\\n\\t\\t\\t\\t// Move to child node\\n                currNode = currNode.children[char - \\'a\\']!!\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// When reached the end of the word, mark the node as a word\\n            currNode.isWord = true\\n        }\\n        \\n\\t\\t// Recursive search\\n        private fun _contains(node: Node, word: String, index: Int): Boolean {\\n            if (index == word.length - 1) {\\n                if (word[index] == \\'.\\') return node.children.any { it != null && it.isWord }\\n                else return node.children[word[index] - \\'a\\']?.isWord ?: false\\n            }\\n            \\n            if (word[index] == \\'.\\') {\\n                for (n in node.children) {\\n                    if (n == null) continue\\n\\t\\t\\t\\t\\t// Here we recursively split between subtrees\\n                    if (_contains(n!!, word, index + 1)) return true\\n                }\\n                return false\\n            } else {\\n                if (node.children[word[index] - \\'a\\'] == null) return false\\n                return _contains(node.children[word[index] - \\'a\\']!!, word, index + 1)\\n            }\\n            \\n            return false\\n        }\\n        \\n        fun contains(word: String): Boolean {\\n            return _contains(root, word, 0)\\n        }\\n    }\\n\\n    private val trie = Trie()\\n    \\n    fun addWord(word: String) {\\n        trie.insert(word)\\n    }\\n\\n    fun search(word: String): Boolean {\\n        return trie.contains(word)\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725022,
                "title": "simple-java-solution-using-trie",
                "content": "**Upvote if you Got It** \\uD83D\\uDE42\\nclass WordDictionary {\\n\\n    TrieNode root;\\n    public WordDictionary() {\\n        root = new TrieNode(\\'#\\');\\n        \\n    }\\n    \\n    public void addWord(String word) {\\n        TrieNode cur = root;\\n        for(char ch: word.toCharArray()){\\n            if(cur.child[ch-\\'a\\']==null) cur.child[ch-\\'a\\']=new TrieNode(ch);\\n                cur=cur.child[ch-\\'a\\'];\\n        }\\n        cur.last=true;\\n    }\\n    \\n    public boolean search(String word) {\\n        TrieNode s = root;\\n        return helper(s,0,word);\\n    }\\n    \\n    public boolean helper(TrieNode s,int idx,String word){\\n        if(idx>=word.length()) return s.last;\\n        if(word.charAt(idx)==\\'.\\'){\\n            for(int i=0;i<26;i++){\\n                if(s.child[i]!=null && helper(s.child[i],idx+1,word)){\\n                    return true;\\n                }\\n            }\\n        }\\n        else{\\n            if(s.child[word.charAt(idx)-\\'a\\']==null || s.child[word.charAt(idx)-\\'a\\'].c!=word.charAt(idx)) return false;\\n            s=s.child[word.charAt(idx)-\\'a\\'];\\n            return helper(s,idx+1,word);\\n        }\\n        return false;\\n    }\\n    \\n    class TrieNode{\\n        char c;\\n        TrieNode[] child;\\n        boolean last;\\n        public TrieNode(char c){\\n            this.c=c;\\n            child = new TrieNode[26];\\n            last = false;\\n        }\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "**Upvote if you Got It** \\uD83D\\uDE42\\nclass WordDictionary {\\n\\n    TrieNode root;\\n    public WordDictionary() {\\n        root = new TrieNode(\\'#\\');\\n        \\n    }\\n    \\n    public void addWord(String word) {\\n        TrieNode cur = root;\\n        for(char ch: word.toCharArray()){\\n            if(cur.child[ch-\\'a\\']==null) cur.child[ch-\\'a\\']=new TrieNode(ch);\\n                cur=cur.child[ch-\\'a\\'];\\n        }\\n        cur.last=true;\\n    }\\n    \\n    public boolean search(String word) {\\n        TrieNode s = root;\\n        return helper(s,0,word);\\n    }\\n    \\n    public boolean helper(TrieNode s,int idx,String word){\\n        if(idx>=word.length()) return s.last;\\n        if(word.charAt(idx)==\\'.\\'){\\n            for(int i=0;i<26;i++){\\n                if(s.child[i]!=null && helper(s.child[i],idx+1,word)){\\n                    return true;\\n                }\\n            }\\n        }\\n        else{\\n            if(s.child[word.charAt(idx)-\\'a\\']==null || s.child[word.charAt(idx)-\\'a\\'].c!=word.charAt(idx)) return false;\\n            s=s.child[word.charAt(idx)-\\'a\\'];\\n            return helper(s,idx+1,word);\\n        }\\n        return false;\\n    }\\n    \\n    class TrieNode{\\n        char c;\\n        TrieNode[] child;\\n        boolean last;\\n        public TrieNode(char c){\\n            this.c=c;\\n            child = new TrieNode[26];\\n            last = false;\\n        }\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1570968,
                "title": "java-hashset-hashmap-solution",
                "content": "It seems that nobody has posted a solution using a hashset.\\nSo rather than using a trie like a rational person, My mind was like \"I wanna be the first one to solve this with a hashset\".\\nSo I did. \\nRuntime: 45 ms\\nMemory Usage: 47.8 MB\\n```\\nclass WordDictionary {\\n    HashSet<String> dict;\\n    boolean singleChar = false;\\n    public WordDictionary() {\\n        dict = new HashSet<String>();\\n    }\\n    public void addWord(String word) {\\n        if(word.length()==1){singleChar = true;} // improve search functionality for single chars\\n        dict.add(word);\\n    }\\n    public boolean search(String word) {\\n        if(word.contains(\".\"))\\n        {\\n            if(word.equals(\".\")) // edge case that slows us down\\n            {return singleChar;}\\n            char[] arr = word.toCharArray();\\n            for(String i : dict) // cluster fuck of code to test if the given string matches our parameter\\n            {\\n                if(i.length() == arr.length)\\n                {\\n                    StringBuilder curr = new StringBuilder();\\n                    for(int j = 0; j < arr.length; j++)\\n                    {\\n                        if(arr[j]==\\'.\\')\\n                        {\\n                            curr.append(\\'.\\');\\n                        }\\n                        else\\n                        {\\n                            curr.append(i.charAt(j));\\n                        }\\n                    }\\n                    if(curr.toString().equals(word))\\n                    {\\n                        return true;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return dict.contains(word);\\n        \\n    }\\n        \\n}\\n\\n```\\n\\nI also added a hashmap solution to see if it would be faster. it was similar in speed\\nRuntime: 42 ms\\nMemory Usage: 51 MB\\n\\n```\\nclass WordDictionary {\\n    HashMap<Integer, HashSet<String>> hm;\\n    public WordDictionary() {\\n        hm = new HashMap<Integer, HashSet<String>>();\\n    }\\n    \\n    public void addWord(String word) {\\n        int size = word.length();\\n        if(hm.containsKey(size))\\n        {\\n            hm.get(size).add(word);\\n        }\\n        else\\n        {\\n            hm.put(size, new HashSet<String>());\\n            hm.get(size).add(word);\\n        }\\n        \\n    }\\n    \\n    public boolean search(String word) {\\n        int size = word.length();\\n        if(hm.containsKey(size))\\n        {\\n            if(word.equals(\".\")){return true;}\\n            if(word.contains(\".\"))\\n            {\\n                HashSet<String> curr = hm.get(size);\\n                for(String i : curr)\\n                {\\n                    StringBuilder bld = new StringBuilder();\\n                    for(int j = 0; j < i.length(); j++)\\n                    {\\n                        if(word.charAt(j)==\\'.\\')\\n                        {\\n                           bld.append(\\'.\\');\\n                        }\\n                        else\\n                        {\\n                            bld.append(i.charAt(j));\\n                        }\\n                    }\\n                    if(word.equals(bld.toString())){return true;}\\n                }\\n                return false;\\n            }\\n            else\\n            {\\n                return(hm.get(size).contains(word));\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass WordDictionary {\\n    HashSet<String> dict;\\n    boolean singleChar = false;\\n    public WordDictionary() {\\n        dict = new HashSet<String>();\\n    }\\n    public void addWord(String word) {\\n        if(word.length()==1){singleChar = true;} // improve search functionality for single chars\\n        dict.add(word);\\n    }\\n    public boolean search(String word) {\\n        if(word.contains(\".\"))\\n        {\\n            if(word.equals(\".\")) // edge case that slows us down\\n            {return singleChar;}\\n            char[] arr = word.toCharArray();\\n            for(String i : dict) // cluster fuck of code to test if the given string matches our parameter\\n            {\\n                if(i.length() == arr.length)\\n                {\\n                    StringBuilder curr = new StringBuilder();\\n                    for(int j = 0; j < arr.length; j++)\\n                    {\\n                        if(arr[j]==\\'.\\')\\n                        {\\n                            curr.append(\\'.\\');\\n                        }\\n                        else\\n                        {\\n                            curr.append(i.charAt(j));\\n                        }\\n                    }\\n                    if(curr.toString().equals(word))\\n                    {\\n                        return true;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return dict.contains(word);\\n        \\n    }\\n        \\n}\\n\\n```\n```\\nclass WordDictionary {\\n    HashMap<Integer, HashSet<String>> hm;\\n    public WordDictionary() {\\n        hm = new HashMap<Integer, HashSet<String>>();\\n    }\\n    \\n    public void addWord(String word) {\\n        int size = word.length();\\n        if(hm.containsKey(size))\\n        {\\n            hm.get(size).add(word);\\n        }\\n        else\\n        {\\n            hm.put(size, new HashSet<String>());\\n            hm.get(size).add(word);\\n        }\\n        \\n    }\\n    \\n    public boolean search(String word) {\\n        int size = word.length();\\n        if(hm.containsKey(size))\\n        {\\n            if(word.equals(\".\")){return true;}\\n            if(word.contains(\".\"))\\n            {\\n                HashSet<String> curr = hm.get(size);\\n                for(String i : curr)\\n                {\\n                    StringBuilder bld = new StringBuilder();\\n                    for(int j = 0; j < i.length(); j++)\\n                    {\\n                        if(word.charAt(j)==\\'.\\')\\n                        {\\n                           bld.append(\\'.\\');\\n                        }\\n                        else\\n                        {\\n                            bld.append(i.charAt(j));\\n                        }\\n                    }\\n                    if(word.equals(bld.toString())){return true;}\\n                }\\n                return false;\\n            }\\n            else\\n            {\\n                return(hm.get(size).contains(word));\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013084,
                "title": "java-trie-dfs-clean-code",
                "content": "```\\nclass WordDictionary {\\n    static class TrieNode {\\n\\tboolean endOfWord;\\n        Map<Character, TrieNode> children;\\n        public TrieNode() {\\n            children = new HashMap<>();\\n            endOfWord = false;\\n        }\\n    }\\n\\n    /** Initialize your data structure here. */\\n    TrieNode root;\\n    public WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void addWord(String word) {\\n        TrieNode curr = root;\\n        \\n        for(char ch: word.toCharArray()) {\\n            TrieNode node = curr.children.get(ch);\\n            if(node == null) {\\n                node = new TrieNode();\\n                curr.children.put(ch, node);\\n            }\\n            curr = node;\\n        }\\n        \\n        curr.endOfWord = true;\\n    }\\n    \\n    public boolean search(String word) {\\n        return findMatch(root, word, 0);\\n    }\\n    \\n    //Search recursively\\n    private boolean findMatch(TrieNode node, String word, int index) {\\n        if(index == word.length()) {\\n            return node.endOfWord;\\n        }\\n        \\n        if(word.charAt(index) == \\'.\\') {\\n            for(char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n                if(node.children.get(ch) != null && findMatch(node.children.get(ch), word, index+1)) {\\n                    return true;\\n                }\\n            }\\n        } else {\\n            char ch = word.charAt(index);\\n            if(node.children.get(ch) != null && findMatch(node.children.get(ch), word, index+1)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass WordDictionary {\\n    static class TrieNode {\\n\\tboolean endOfWord;\\n        Map<Character, TrieNode> children;\\n        public TrieNode() {\\n            children = new HashMap<>();\\n            endOfWord = false;\\n        }\\n    }\\n\\n    /** Initialize your data structure here. */\\n    TrieNode root;\\n    public WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void addWord(String word) {\\n        TrieNode curr = root;\\n        \\n        for(char ch: word.toCharArray()) {\\n            TrieNode node = curr.children.get(ch);\\n            if(node == null) {\\n                node = new TrieNode();\\n                curr.children.put(ch, node);\\n            }\\n            curr = node;\\n        }\\n        \\n        curr.endOfWord = true;\\n    }\\n    \\n    public boolean search(String word) {\\n        return findMatch(root, word, 0);\\n    }\\n    \\n    //Search recursively\\n    private boolean findMatch(TrieNode node, String word, int index) {\\n        if(index == word.length()) {\\n            return node.endOfWord;\\n        }\\n        \\n        if(word.charAt(index) == \\'.\\') {\\n            for(char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n                if(node.children.get(ch) != null && findMatch(node.children.get(ch), word, index+1)) {\\n                    return true;\\n                }\\n            }\\n        } else {\\n            char ch = word.charAt(index);\\n            if(node.children.get(ch) != null && findMatch(node.children.get(ch), word, index+1)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008747,
                "title": "hashmap",
                "content": "```java\\nclass WordDictionary {\\n    private final Map<Integer, Set<String>> lookup;\\n    \\n    public WordDictionary() {\\n        this.lookup = new HashMap<>();\\n    }\\n    \\n    public void addWord(String word) {\\n        int n = word.length();\\n        lookup.computeIfAbsent(n, f -> new HashSet<>()).add(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        int n = word.length();\\n        if (!lookup.containsKey(n)) {\\n            return false;\\n        }\\n        for (final String w : lookup.get(n)) {\\n            int i = 0;\\n            while (i < n && (w.charAt(i) == word.charAt(i) || word.charAt(i) == \\'.\\')) {\\n                i++;\\n            }\\n            if (i == n) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass WordDictionary {\\n    private final Map<Integer, Set<String>> lookup;\\n    \\n    public WordDictionary() {\\n        this.lookup = new HashMap<>();\\n    }\\n    \\n    public void addWord(String word) {\\n        int n = word.length();\\n        lookup.computeIfAbsent(n, f -> new HashSet<>()).add(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        int n = word.length();\\n        if (!lookup.containsKey(n)) {\\n            return false;\\n        }\\n        for (final String w : lookup.get(n)) {\\n            int i = 0;\\n            while (i < n && (w.charAt(i) == word.charAt(i) || word.charAt(i) == \\'.\\')) {\\n                i++;\\n            }\\n            if (i == n) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774235,
                "title": "java-implementing-trie",
                "content": "```\\nclass WordDictionary {\\n\\n    class Trie{\\n        Trie[] letters;\\n        boolean end;\\n        Trie(){\\n            letters = new Trie[26];\\n            end = false;\\n        }\\n    }\\n    Trie dict;\\n    public WordDictionary() {\\n        this.dict = new Trie();\\n    }\\n    \\n    public void addWord(String word) {\\n        Trie ptr = this.dict;\\n        for(char c : word.toCharArray()){\\n            if(ptr.letters[c - \\'a\\'] == null)\\n                ptr.letters[c - \\'a\\'] = new Trie();\\n            ptr = ptr.letters[c - \\'a\\'];\\n        }\\n        ptr.end = true; \\n    }\\n    \\n    public boolean search(Trie ptr, String word, int index){\\n        if(index >= word.length()) return ptr.end;\\n        char c = word.charAt(index);\\n\\n        if(c == \\'.\\'){\\n            for(Trie t : ptr.letters){\\n                if(t != null && search(t, word, index + 1))\\n                    return true;\\n            }\\n            return false;\\n        }\\n        if(ptr == null || ptr.letters[c - \\'a\\'] == null) return false;\\n        \\n        return search(ptr.letters[c - \\'a\\'], word, index + 1);\\n    }\\n    public boolean search(String word) {\\n        return search(this.dict, word, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordDictionary {\\n\\n    class Trie{\\n        Trie[] letters;\\n        boolean end;\\n        Trie(){\\n            letters = new Trie[26];\\n            end = false;\\n        }\\n    }\\n    Trie dict;\\n    public WordDictionary() {\\n        this.dict = new Trie();\\n    }\\n    \\n    public void addWord(String word) {\\n        Trie ptr = this.dict;\\n        for(char c : word.toCharArray()){\\n            if(ptr.letters[c - \\'a\\'] == null)\\n                ptr.letters[c - \\'a\\'] = new Trie();\\n            ptr = ptr.letters[c - \\'a\\'];\\n        }\\n        ptr.end = true; \\n    }\\n    \\n    public boolean search(Trie ptr, String word, int index){\\n        if(index >= word.length()) return ptr.end;\\n        char c = word.charAt(index);\\n\\n        if(c == \\'.\\'){\\n            for(Trie t : ptr.letters){\\n                if(t != null && search(t, word, index + 1))\\n                    return true;\\n            }\\n            return false;\\n        }\\n        if(ptr == null || ptr.letters[c - \\'a\\'] == null) return false;\\n        \\n        return search(ptr.letters[c - \\'a\\'], word, index + 1);\\n    }\\n    public boolean search(String word) {\\n        return search(this.dict, word, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774228,
                "title": "c-trie-solution",
                "content": "**Solution: Trie**\\nThe idea is to use trie data structure to store all the words, then use DFS to search a specific word.\\n\\nAdd(word) \\n* Time complexity is O(m) where m= word.Length\\n* Space complexity is O(m).\\n\\nSearch(word)\\n* Time: O(26^m) where m= word.Length\\n* Space: O(m)\\n\\n\\n```\\npublic class WordDictionary {\\n    \\n    public class TrieNode\\n    {\\n        public TrieNode[] Children;\\n        public bool IsWord;\\n        public TrieNode()\\n        {\\n            Children = new TrieNode[26];\\n        }\\n    }\\n    \\n    public TrieNode root;\\n\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void AddWord(string word) {\\n        var curr = root;\\n        foreach(char c in word)\\n        {\\n            if(curr.Children[c-\\'a\\'] == null)\\n                curr.Children[c-\\'a\\'] = new TrieNode();\\n            \\n            curr = curr.Children[c-\\'a\\'];\\n        }\\n        \\n        curr.IsWord = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public bool Search(string word) {\\n        return Search(word, 0, root);\\n    }\\n    \\n    public bool Search(string word, int index, TrieNode node)\\n    {\\n        if(node == null)\\n            return false;\\n\\n        if(index == word.Length)\\n            return node.IsWord;\\n        \\n        if(word[index] == \\'.\\')\\n        {\\n            for(int i = 0; i < node.Children.Length; i++)\\n            {\\n                TrieNode curr = node.Children[i];\\n                \\n                if(Search(word, index + 1, curr))\\n                    return true;\\n            }\\n        }\\n        else\\n        {\\n            if(Search(word, index + 1, node.Children[word[index] - \\'a\\']))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class WordDictionary {\\n    \\n    public class TrieNode\\n    {\\n        public TrieNode[] Children;\\n        public bool IsWord;\\n        public TrieNode()\\n        {\\n            Children = new TrieNode[26];\\n        }\\n    }\\n    \\n    public TrieNode root;\\n\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void AddWord(string word) {\\n        var curr = root;\\n        foreach(char c in word)\\n        {\\n            if(curr.Children[c-\\'a\\'] == null)\\n                curr.Children[c-\\'a\\'] = new TrieNode();\\n            \\n            curr = curr.Children[c-\\'a\\'];\\n        }\\n        \\n        curr.IsWord = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public bool Search(string word) {\\n        return Search(word, 0, root);\\n    }\\n    \\n    public bool Search(string word, int index, TrieNode node)\\n    {\\n        if(node == null)\\n            return false;\\n\\n        if(index == word.Length)\\n            return node.IsWord;\\n        \\n        if(word[index] == \\'.\\')\\n        {\\n            for(int i = 0; i < node.Children.Length; i++)\\n            {\\n                TrieNode curr = node.Children[i];\\n                \\n                if(Search(word, index + 1, curr))\\n                    return true;\\n            }\\n        }\\n        else\\n        {\\n            if(Search(word, index + 1, node.Children[word[index] - \\'a\\']))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 714780,
                "title": "c-simple-solution-using-trie",
                "content": "```csharp\\npublic class WordDictionary \\n{    \\n    public class TrieNode\\n    {\\n        public TrieNode[] Children = new TrieNode[26];\\n        public bool IsWord;\\n        \\n        public static void Insert(TrieNode root, string word)\\n        {\\n            TrieNode node = root;\\n            foreach(char c in word)\\n            {\\n                int index = c - \\'a\\';\\n                if(node.Children[index] == null)\\n                {\\n                    node.Children[index] = new TrieNode();\\n                }\\n                \\n                node = node.Children[index];\\n            }\\n            \\n            node.IsWord = true;\\n        }\\n    }\\n    \\n    private TrieNode root;\\n\\n    /** Initialize your data structure here. */\\n    public WordDictionary() \\n    {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void AddWord(string word) \\n    {\\n        TrieNode.Insert(root, word);    \\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public bool Search(string word)\\n    {\\n        return search(root, word, 0);\\n    }\\n    \\n    \\n    private bool search(TrieNode root, string word, int index)\\n    {\\n        TrieNode node = root;\\n        \\n        if(index == word.Length)\\n        {\\n            return node.IsWord;\\n        }\\n                \\n        if(word[index] != \\'.\\')\\n        {\\n            if(node.Children[word[index] - \\'a\\'] == null)\\n            {\\n                return false;\\n            }\\n            \\n            node = node.Children[word[index] - \\'a\\'];\\n            return search(node, word, index + 1);\\n        }\\n        \\n        else\\n        {\\n            foreach(var child in node.Children)\\n            {\\n                if(child != null)\\n                {\\n                    if(search(child, word, index + 1))\\n                    {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```csharp\\npublic class WordDictionary \\n{    \\n    public class TrieNode\\n    {\\n        public TrieNode[] Children = new TrieNode[26];\\n        public bool IsWord;\\n        \\n        public static void Insert(TrieNode root, string word)\\n        {\\n            TrieNode node = root;\\n            foreach(char c in word)\\n            {\\n                int index = c - \\'a\\';\\n                if(node.Children[index] == null)\\n                {\\n                    node.Children[index] = new TrieNode();\\n                }\\n                \\n                node = node.Children[index];\\n            }\\n            \\n            node.IsWord = true;\\n        }\\n    }\\n    \\n    private TrieNode root;\\n\\n    /** Initialize your data structure here. */\\n    public WordDictionary() \\n    {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void AddWord(string word) \\n    {\\n        TrieNode.Insert(root, word);    \\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public bool Search(string word)\\n    {\\n        return search(root, word, 0);\\n    }\\n    \\n    \\n    private bool search(TrieNode root, string word, int index)\\n    {\\n        TrieNode node = root;\\n        \\n        if(index == word.Length)\\n        {\\n            return node.IsWord;\\n        }\\n                \\n        if(word[index] != \\'.\\')\\n        {\\n            if(node.Children[word[index] - \\'a\\'] == null)\\n            {\\n                return false;\\n            }\\n            \\n            node = node.Children[word[index] - \\'a\\'];\\n            return search(node, word, index + 1);\\n        }\\n        \\n        else\\n        {\\n            foreach(var child in node.Children)\\n            {\\n                if(child != null)\\n                {\\n                    if(search(child, word, index + 1))\\n                    {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712019,
                "title": "typescript-trie-solution",
                "content": "Just a regular trie implementation in Typescript, trying to be as clean as possible.\\n\\n```typescript\\nclass WordDictionary {\\n    isWord: boolean;\\n    child: {[Key: string]: WordDictionary};\\n    constructor() {\\n        this.child = {}; \\n        this.isWord = false;\\n    }\\n\\n    addWord(word: string): void {\\n        let curr: WordDictionary = this;\\n        for(const c of word) {\\n            if(!curr.child[c]) {\\n                curr.child[c] = new WordDictionary();\\n            }\\n            curr = curr.child[c];\\n        }\\n        curr.isWord = true;\\n    }\\n\\n    search(word: string, i = 0): boolean {\\n        let curr: WordDictionary = this;\\n        for(;i < word.length; i++) {\\n            const c = word[i];\\n            if(c !== \\'.\\') {\\n                if(!curr.child[c]) { \\n                    return false; \\n                }\\n                curr = curr.child[c];\\n            } else {\\n                for(const key in curr.child) {\\n                    if(curr.child[key].search(word, i + 1)){\\n                        return true;\\n                    };\\n                }\\n                return false;\\n            }\\n        }\\n        return curr.isWord;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Trie"
                ],
                "code": "```typescript\\nclass WordDictionary {\\n    isWord: boolean;\\n    child: {[Key: string]: WordDictionary};\\n    constructor() {\\n        this.child = {}; \\n        this.isWord = false;\\n    }\\n\\n    addWord(word: string): void {\\n        let curr: WordDictionary = this;\\n        for(const c of word) {\\n            if(!curr.child[c]) {\\n                curr.child[c] = new WordDictionary();\\n            }\\n            curr = curr.child[c];\\n        }\\n        curr.isWord = true;\\n    }\\n\\n    search(word: string, i = 0): boolean {\\n        let curr: WordDictionary = this;\\n        for(;i < word.length; i++) {\\n            const c = word[i];\\n            if(c !== \\'.\\') {\\n                if(!curr.child[c]) { \\n                    return false; \\n                }\\n                curr = curr.child[c];\\n            } else {\\n                for(const key in curr.child) {\\n                    if(curr.child[key].search(word, i + 1)){\\n                        return true;\\n                    };\\n                }\\n                return false;\\n            }\\n        }\\n        return curr.isWord;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648915,
                "title": "c-solution-using-simple-implementation-of-trie",
                "content": "```\\nstruct node {\\n    node* next[26];\\n    bool hasWord;\\n    \\n    node() {\\n        for(int i = 0; i < 26; i++) {\\n            next[i] = nullptr;\\n        }\\n        hasWord = false;\\n    }\\n};\\nclass WordDictionary {\\npublic:\\n    node* root = new node();\\n\\n    void addWord(const string& word) {\\n        node* curV = root;\\n        for(int i = 0; i < word.length(); i++) {\\n            int curIndex = word[i] - \\'a\\';\\n\\n\\t\\t\\tif(!curV->next[curIndex]) {\\n                curV->next[curIndex] = new node();\\n            }\\n            \\n            curV = curV->next[curIndex];\\n        }\\n        curV->hasWord = true;\\n    }\\n    \\n    bool search(const string& word) {\\n        return searchHelper(word, 0, root);\\n    }\\n    \\n    bool searchHelper(const string& word, int index, node* curV) {\\n        // BASE CASE\\n        if (index == word.length()) {\\n            return curV->hasWord;\\n        }\\n\\n        \\n        char curChar = word[index];\\n\\n        // when char is defiend\\n        if (curChar != \\'.\\') {\\n            if (curV->next[curChar - \\'a\\'])\\n                return searchHelper(word, index + 1, curV->next[curChar - \\'a\\']);\\n            return false;\\n        }\\n        \\n        // when char is undefiend\\n        for (int i = 0; i < 26; i++) {\\n            if (curV->next[i] != nullptr) {\\n                if (searchHelper(word, index + 1, curV->next[i]))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nstruct node {\\n    node* next[26];\\n    bool hasWord;\\n    \\n    node() {\\n        for(int i = 0; i < 26; i++) {\\n            next[i] = nullptr;\\n        }\\n        hasWord = false;\\n    }\\n};\\nclass WordDictionary {\\npublic:\\n    node* root = new node();\\n\\n    void addWord(const string& word) {\\n        node* curV = root;\\n        for(int i = 0; i < word.length(); i++) {\\n            int curIndex = word[i] - \\'a\\';\\n\\n\\t\\t\\tif(!curV->next[curIndex]) {\\n                curV->next[curIndex] = new node();\\n            }\\n            \\n            curV = curV->next[curIndex];\\n        }\\n        curV->hasWord = true;\\n    }\\n    \\n    bool search(const string& word) {\\n        return searchHelper(word, 0, root);\\n    }\\n    \\n    bool searchHelper(const string& word, int index, node* curV) {\\n        // BASE CASE\\n        if (index == word.length()) {\\n            return curV->hasWord;\\n        }\\n\\n        \\n        char curChar = word[index];\\n\\n        // when char is defiend\\n        if (curChar != \\'.\\') {\\n            if (curV->next[curChar - \\'a\\'])\\n                return searchHelper(word, index + 1, curV->next[curChar - \\'a\\']);\\n            return false;\\n        }\\n        \\n        // when char is undefiend\\n        for (int i = 0; i < 26; i++) {\\n            if (curV->next[i] != nullptr) {\\n                if (searchHelper(word, index + 1, curV->next[i]))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534248,
                "title": "php-trie-solution-100-fast-100-less-memory",
                "content": "```\\nclass TrieNode \\n{\\n    public $isEnd = true;\\n    public $children = [];\\n    \\n    function __construct() {\\n        $this->isEnd = false;\\n    }\\n}\\n\\n\\nclass WordDictionary {\\n    public $node = null;\\n    /**\\n     * Initialize your data structure here.\\n     */\\n    function __construct() \\n    {\\n        $this->node = new TrieNode();\\n    }\\n  \\n    /**\\n     * Adds a word into the data structure.\\n     * @param String $word\\n     * @return NULL\\n     */\\n    function addWord(string $word) \\n    {\\n        $count = strlen($word);\\n        $node = $this->node;\\n        for ($i = 0; $i < $count; $i++) {\\n            $char = $word[$i];\\n            if (array_key_exists($char, $node->children)) {\\n                $node = $node->children[$char];\\n                continue;\\n            }\\n            $node->children[$char] = new TrieNode();\\n            $node = $node->children[$char];\\n        }\\n        $node->isEnd = true;\\n    }\\n  \\n    /**\\n     * Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n     * @param String $word\\n     * @return Boolean\\n     */\\n    function search(string $word, $node = null): bool\\n    {     \\n        if (!$node) {\\n            $node = $this->node;\\n        }\\n        $count = strlen($word);\\n        \\n        for ($i = 0; $i < $count; $i++) {\\n            $character = $word[$i];\\n            if ($character === \\'.\\') {\\n                $subString = substr($word, $i+1);\\n                foreach ($node->children as $child => $childNode) {\\n                    if ($this->search($subString, $childNode)) {\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            }\\n            if (array_key_exists($character, $node->children)) {\\n                $node = $node->children[$character];\\n                continue;\\n            }\\n            return false;    \\n        }\\n        return $node->isEnd;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode \\n{\\n    public $isEnd = true;\\n    public $children = [];\\n    \\n    function __construct() {\\n        $this->isEnd = false;\\n    }\\n}\\n\\n\\nclass WordDictionary {\\n    public $node = null;\\n    /**\\n     * Initialize your data structure here.\\n     */\\n    function __construct() \\n    {\\n        $this->node = new TrieNode();\\n    }\\n  \\n    /**\\n     * Adds a word into the data structure.\\n     * @param String $word\\n     * @return NULL\\n     */\\n    function addWord(string $word) \\n    {\\n        $count = strlen($word);\\n        $node = $this->node;\\n        for ($i = 0; $i < $count; $i++) {\\n            $char = $word[$i];\\n            if (array_key_exists($char, $node->children)) {\\n                $node = $node->children[$char];\\n                continue;\\n            }\\n            $node->children[$char] = new TrieNode();\\n            $node = $node->children[$char];\\n        }\\n        $node->isEnd = true;\\n    }\\n  \\n    /**\\n     * Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n     * @param String $word\\n     * @return Boolean\\n     */\\n    function search(string $word, $node = null): bool\\n    {     \\n        if (!$node) {\\n            $node = $this->node;\\n        }\\n        $count = strlen($word);\\n        \\n        for ($i = 0; $i < $count; $i++) {\\n            $character = $word[$i];\\n            if ($character === \\'.\\') {\\n                $subString = substr($word, $i+1);\\n                foreach ($node->children as $child => $childNode) {\\n                    if ($this->search($subString, $childNode)) {\\n                        return true;\\n                    }\\n                }\\n                return false;\\n            }\\n            if (array_key_exists($character, $node->children)) {\\n                $node = $node->children[$character];\\n                continue;\\n            }\\n            return false;    \\n        }\\n        return $node->isEnd;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378014,
                "title": "javascript-solution-using-hashmap-es6-methods",
                "content": "[Following this pattern:](https://leetcode.com/problems/add-and-search-word-data-structure-design/discuss/339954/Javascript-beats-100-easy-to-understand)\\n```\\nclass WordDictionary {\\n    constructor() {\\n        this.root= {}\\n    }\\n    \\n     addWord(word) {\\n        // start with current node\\n        let node = this.root[word.length] = this.root[word.length] || []\\n        node.push(word)\\n        \\n    }\\n    \\n    search(word) {\\n        let wordArr = this.root[word.length] || false\\n        \\n        if(!wordArr) return false\\n        \\n        // Go over all added workds that have n characters  \\n        // Filter out words where every letter doesn\\'t match with search or \".\"\\n\\t\\t// Returns an array with all the matching words \\n\\t\\treturn wordArr.filter(currentWord => {\\n            return currentWord.split(\"\").every((letter, idx) => (letter === word[idx] || word[idx] === \".\"))\\n        }).length > 0\\n        \\n    }\\n};\\n```\\n\\n\\nI think the complexities are: \\naddWord - Time complexity = O(1) since we\\'re just accessing a hashmap and pushing to an array\\naddWord - Space complexity = O(n) depending on how many words and various lengths of words \\n\\nsearch - Time = O(n^2) we have to filter then we have to map over each letter \\nsearch - Space = O(1) because we\\'re not adding or remove any space",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass WordDictionary {\\n    constructor() {\\n        this.root= {}\\n    }\\n    \\n     addWord(word) {\\n        // start with current node\\n        let node = this.root[word.length] = this.root[word.length] || []\\n        node.push(word)\\n        \\n    }\\n    \\n    search(word) {\\n        let wordArr = this.root[word.length] || false\\n        \\n        if(!wordArr) return false\\n        \\n        // Go over all added workds that have n characters  \\n        // Filter out words where every letter doesn\\'t match with search or \".\"\\n\\t\\t// Returns an array with all the matching words \\n\\t\\treturn wordArr.filter(currentWord => {\\n            return currentWord.split(\"\").every((letter, idx) => (letter === word[idx] || word[idx] === \".\"))\\n        }).length > 0\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294880,
                "title": "c-trie",
                "content": "```\\npublic class WordDictionary {\\n    TrieNode root;\\n    bool canFind;\\n\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        root = new TrieNode();\\n        canFind = false;\\n    }\\n\\n    public void AddWord(string word) {\\n        var n = word.Length;\\n        TrieNode curNode = root;\\n        for (int i = 0; i < n; i++) {\\n            var index = word[i] - \\'a\\';\\n            if (curNode.nodes[index] == null) {\\n                curNode.nodes[index] = new TrieNode();\\n            }\\n            curNode = curNode.nodes[index];\\n\\n            if (i == n - 1) {\\n                curNode.isWord = true;\\n            }\\n        }\\n    }\\n\\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public bool Search(string word) {\\n        canFind = false;\\n        DFS(root, word, 0);\\n        return canFind;\\n    }\\n\\n    private void DFS(TrieNode root, string word, int i) {\\n        if (canFind) return;\\n        if (root == null) return;\\n        var n = word.Length;\\n        if (n == i) {\\n            if (root.isWord) {\\n                canFind = true;\\n            }\\n            return;\\n        }\\n        if (word[i] == \\'.\\') {\\n            for (var j = \\'a\\'; j <= \\'z\\'; j++) {\\n                DFS(root.nodes[j - \\'a\\'], word, i + 1);\\n            }\\n        } else {\\n            var index = word[i] - \\'a\\';\\n            DFS(root.nodes[index], word, i + 1);\\n        }\\n    }\\n}\\n\\nclass TrieNode {\\n    public TrieNode[] nodes;\\n    public bool isWord;\\n\\n    public TrieNode() {\\n        nodes = new TrieNode[26];\\n        isWord = false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class WordDictionary {\\n    TrieNode root;\\n    bool canFind;\\n\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        root = new TrieNode();\\n        canFind = false;\\n    }\\n\\n    public void AddWord(string word) {\\n        var n = word.Length;\\n        TrieNode curNode = root;\\n        for (int i = 0; i < n; i++) {\\n            var index = word[i] - \\'a\\';\\n            if (curNode.nodes[index] == null) {\\n                curNode.nodes[index] = new TrieNode();\\n            }\\n            curNode = curNode.nodes[index];\\n\\n            if (i == n - 1) {\\n                curNode.isWord = true;\\n            }\\n        }\\n    }\\n\\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public bool Search(string word) {\\n        canFind = false;\\n        DFS(root, word, 0);\\n        return canFind;\\n    }\\n\\n    private void DFS(TrieNode root, string word, int i) {\\n        if (canFind) return;\\n        if (root == null) return;\\n        var n = word.Length;\\n        if (n == i) {\\n            if (root.isWord) {\\n                canFind = true;\\n            }\\n            return;\\n        }\\n        if (word[i] == \\'.\\') {\\n            for (var j = \\'a\\'; j <= \\'z\\'; j++) {\\n                DFS(root.nodes[j - \\'a\\'], word, i + 1);\\n            }\\n        } else {\\n            var index = word[i] - \\'a\\';\\n            DFS(root.nodes[index], word, i + 1);\\n        }\\n    }\\n}\\n\\nclass TrieNode {\\n    public TrieNode[] nodes;\\n    public bool isWord;\\n\\n    public TrieNode() {\\n        nodes = new TrieNode[26];\\n        isWord = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 261564,
                "title": "simple-java-solution",
                "content": "```\\nclass TrieNode {\\n    TrieNode[] children;\\n    boolean isWord;\\n    \\n    TrieNode() {\\n        children = new TrieNode[26];\\n        isWord = false;\\n    }\\n}\\n\\nclass WordDictionary {\\n    TrieNode root;\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n        if(word == null) return;\\n        \\n        TrieNode curr = root;\\n        for(char c : word.toCharArray()) {\\n            if(curr.children[c-\\'a\\'] == null) {\\n                curr.children[c-\\'a\\'] = new TrieNode();\\n            }\\n            curr = curr.children[c-\\'a\\'];\\n        }\\n        \\n        curr.isWord = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    private boolean search(String word, int i, TrieNode node) {\\n        if(node == null) return false;\\n        if(i == word.length()) return node.isWord;\\n        \\n        char c = word.charAt(i);\\n        \\n        if(c == \\'.\\') {\\n\\t\\t\\t/* Do a recursive call for every child since the rest of the word can be found\\n\\t\\t\\tstarting from any node child */\\n            for(TrieNode child : node.children) {\\n                if(search(word, i+1, child)) return true;\\n            }\\n        } else {\\n            if(search(word, i+1, node.children[c-\\'a\\'])) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean search(String word) {\\n        return search(word, 0, root);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\n    TrieNode[] children;\\n    boolean isWord;\\n    \\n    TrieNode() {\\n        children = new TrieNode[26];\\n        isWord = false;\\n    }\\n}\\n\\nclass WordDictionary {\\n    TrieNode root;\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n        if(word == null) return;\\n        \\n        TrieNode curr = root;\\n        for(char c : word.toCharArray()) {\\n            if(curr.children[c-\\'a\\'] == null) {\\n                curr.children[c-\\'a\\'] = new TrieNode();\\n            }\\n            curr = curr.children[c-\\'a\\'];\\n        }\\n        \\n        curr.isWord = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    private boolean search(String word, int i, TrieNode node) {\\n        if(node == null) return false;\\n        if(i == word.length()) return node.isWord;\\n        \\n        char c = word.charAt(i);\\n        \\n        if(c == \\'.\\') {\\n\\t\\t\\t/* Do a recursive call for every child since the rest of the word can be found\\n\\t\\t\\tstarting from any node child */\\n            for(TrieNode child : node.children) {\\n                if(search(word, i+1, child)) return true;\\n            }\\n        } else {\\n            if(search(word, i+1, node.children[c-\\'a\\'])) return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean search(String word) {\\n        return search(word, 0, root);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259889,
                "title": "python-solution-with-trie-and-defaultdict",
                "content": "```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.isWord = False\\n\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n        \\n\\n    def addWord(self, word: str) -> None:\\n        \"\"\"\\n        Adds a word into the data structure.\\n        \"\"\"\\n        node = self.root\\n        for ch in word:\\n            node = node.children[ch]\\n        node.isWord = True\\n        \\n\\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        \"\"\"\\n        def find(word, node):\\n            if not word: return node.isWord\\n            if word[0] != \\'.\\':\\n                if word[0] in node.children: return find(word[1:], node.children[word[0]])\\n                return False\\n            else:\\n                for n in node.children.values():\\n                    if find(word[1:], n): return True\\n                return False\\n        node = self.root\\n        return find(word, node)\\n        \\n\\n\\n# Your WordDictionary object will be instantiated and called as such:\\n# obj = WordDictionary()\\n# obj.addWord(word)\\n# param_2 = obj.search(word)\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.isWord = False\\n\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n        \\n\\n    def addWord(self, word: str) -> None:\\n        \"\"\"\\n        Adds a word into the data structure.\\n        \"\"\"\\n        node = self.root\\n        for ch in word:\\n            node = node.children[ch]\\n        node.isWord = True\\n        \\n\\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        \"\"\"\\n        def find(word, node):\\n            if not word: return node.isWord\\n            if word[0] != \\'.\\':\\n                if word[0] in node.children: return find(word[1:], node.children[word[0]])\\n                return False\\n            else:\\n                for n in node.children.values():\\n                    if find(word[1:], n): return True\\n                return False\\n        node = self.root\\n        return find(word, node)\\n        \\n\\n\\n# Your WordDictionary object will be instantiated and called as such:\\n# obj = WordDictionary()\\n# obj.addWord(word)\\n# param_2 = obj.search(word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238016,
                "title": "python-solution",
                "content": "Time complexity for `addWord`: `O(len(word))`, time complexity for `search`: `O(N)`, where `N` is the number of nodes in the Trie up to depth `len(word)`.\\n\\n```\\nclass TreeNode(object):\\n    \\n    def __init__(self, val):\\n        self.children = {}\\n        self.end_here = False\\n    \\nclass WordDictionary(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TreeNode(-1)\\n        \\n\\n    def addWord(self, word):\\n        \"\"\"\\n        Adds a word into the data structure.\\n        :type word: str\\n        :rtype: void\\n        \"\"\"\\n        trav = self.root\\n        for i, c in enumerate(word):\\n            if c in trav.children:\\n                trav = trav.children[c]\\n            else:\\n                trav.children[c] = TreeNode(c)\\n                trav = trav.children[c]\\n            if i == len(word)-1:\\n                trav.end_here = True\\n        \\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(i, trav):\\n            if i == len(word):\\n                return trav.end_here\\n            if word[i] != \".\":\\n                if word[i] not in trav.children:\\n                    return False\\n                else:\\n                    return dfs(i+1, trav.children[word[i]])\\n            else:\\n                for val in trav.children.values():\\n                    if dfs(i+1, val):\\n                        return True\\n                return False\\n        return dfs(0, self.root)\\n```",
                "solutionTags": [],
                "code": "```\\nclass TreeNode(object):\\n    \\n    def __init__(self, val):\\n        self.children = {}\\n        self.end_here = False\\n    \\nclass WordDictionary(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TreeNode(-1)\\n        \\n\\n    def addWord(self, word):\\n        \"\"\"\\n        Adds a word into the data structure.\\n        :type word: str\\n        :rtype: void\\n        \"\"\"\\n        trav = self.root\\n        for i, c in enumerate(word):\\n            if c in trav.children:\\n                trav = trav.children[c]\\n            else:\\n                trav.children[c] = TreeNode(c)\\n                trav = trav.children[c]\\n            if i == len(word)-1:\\n                trav.end_here = True\\n        \\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(i, trav):\\n            if i == len(word):\\n                return trav.end_here\\n            if word[i] != \".\":\\n                if word[i] not in trav.children:\\n                    return False\\n                else:\\n                    return dfs(i+1, trav.children[word[i]])\\n            else:\\n                for val in trav.children.values():\\n                    if dfs(i+1, val):\\n                        return True\\n                return False\\n        return dfs(0, self.root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 225900,
                "title": "python-trie",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_end = False\\n\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n\\n    def addWord(self, word):\\n        \"\"\"\\n        Adds a word into the data structure.\\n        :type word: str\\n        :rtype: void\\n        \"\"\"\\n        node = self.root\\n        for c in word:\\n            if c not in node.children:\\n                node.children[c] = TrieNode()\\n            node = node.children[c]\\n        node.is_end = True\\n        \\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        return self.mySearch(word, self.root)\\n    \\n    def mySearch(self, word, node):\\n        for i, c in enumerate(word):\\n            if c not in node.children and c != \\'.\\':\\n                return False\\n            elif c == \\'.\\':\\n                for key in node.children:\\n                    if self.mySearch(word[i+1:], node.children[key]):\\n                        return True\\n                return False\\n            else:\\n                node = node.children[c]\\n        return node.is_end\\n        \\n\\n\\n# Your WordDictionary object will be instantiated and called as such:\\n# obj = WordDictionary()\\n# obj.addWord(word)\\n# param_2 = obj.search(word)\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.is_end = False\\n\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n\\n    def addWord(self, word):\\n        \"\"\"\\n        Adds a word into the data structure.\\n        :type word: str\\n        :rtype: void\\n        \"\"\"\\n        node = self.root\\n        for c in word:\\n            if c not in node.children:\\n                node.children[c] = TrieNode()\\n            node = node.children[c]\\n        node.is_end = True\\n        \\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        return self.mySearch(word, self.root)\\n    \\n    def mySearch(self, word, node):\\n        for i, c in enumerate(word):\\n            if c not in node.children and c != \\'.\\':\\n                return False\\n            elif c == \\'.\\':\\n                for key in node.children:\\n                    if self.mySearch(word[i+1:], node.children[key]):\\n                        return True\\n                return False\\n            else:\\n                node = node.children[c]\\n        return node.is_end\\n        \\n\\n\\n# Your WordDictionary object will be instantiated and called as such:\\n# obj = WordDictionary()\\n# obj.addWord(word)\\n# param_2 = obj.search(word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59706,
                "title": "java-2-easy-to-understand-solutions-trie-hashmap",
                "content": "#Method with HashMap#\\n\\nStore all words of same length into one set map them to their length.\\n\\n    public class WordDictionary {\\n    private HashMap<Integer, HashSet<String>> map = new HashMap<>();\\n\\n    public void addWord(String word) {\\n        int L = word.length();\\n        if(map.containsKey(L)) {\\n            map.get(L).add(word);\\n        }\\n        else {\\n            HashSet<String> set = new HashSet<>();\\n            set.add(word);\\n            map.put(L, set);\\n        }\\n    }\\n\\n    public boolean search(String word) {\\n        int L = word.length();\\n        if(!map.containsKey(L)) return false;\\n        HashSet<String> set = map.get(L);\\n        for(String str : set) {\\n            int i = 0, LL = word.length();\\n            while(i<LL) {\\n                if(word.charAt(i)!='.' && str.charAt(i)!=word.charAt(i)) break;\\n                ++i;\\n            }\\n            //System.out.println(i +\"\\\\t\"+ LL);\\n            if(i==LL && (word.charAt(i-1)=='.' || str.charAt(i-1)==word.charAt(i-1))) return true;\\n        }\\n        return false;\\n    }\\n    }\\n\\n\\n\\n#Method with Trie#\\n\\nOnce you have the cent of using `trie`, the remaining work would seem not that difficult.  For the `search` method, I recursively check `word` suffix until exhausted.\\n\\n    public class WordDictionary {\\n\\n\\tprivate static final int R = 26;\\n\\tprivate TrieNode root;\\n\\t\\n\\tpublic class TrieNode {\\n\\t\\tprivate static final int R = 26;\\n\\t\\t\\n\\t\\tprivate boolean isEnd;\\n\\t\\tprivate TrieNode[] children;\\n\\t\\t\\n\\t\\tpublic TrieNode() {\\n\\t\\t\\tisEnd = true;\\n\\t\\t\\tchildren = new TrieNode[R];\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic WordDictionary() {\\n\\t\\troot = new TrieNode();\\n\\t}\\n\\n    // Adds a word into the data structure.\\n    public void addWord(String word) {\\n        TrieNode current = root;\\n        for(int i=0, L=word.length(); i<L; i++) {\\n        \\tint id = word.charAt(i) - 'a';\\n        \\tif(current.children[id]==null) {\\n        \\t\\tcurrent.children[id] = new TrieNode();\\n        \\t\\tcurrent.children[id].isEnd = false;\\n        \\t}\\n        \\tcurrent = current.children[id];\\n        }\\n        current.isEnd = true;\\n    }\\n\\n    // Returns if the word is in the data structure. A word could\\n    // contain the dot character '.' to represent any one letter.\\n    public boolean search(String word) {\\n    \\tchar[] chars = word.toCharArray();\\n        return search(chars, 0, chars.length, root);\\n    }\\n    \\n    private boolean search(char[] chars, int start, int L, TrieNode root) {\\n    \\tif(start>=L) return root.isEnd;\\n    \\tchar ch = chars[start];\\n    \\tif(ch=='.') {\\n    \\t\\tfor(int i=0; i<R; i++) {\\n    \\t\\t\\tif(root.children[i]==null) continue;\\n    \\t\\t\\tif(search(chars, start+1, L, root.children[i])) return true;\\n    \\t\\t}\\n    \\t}\\n    \\telse {\\n    \\t\\tif(root.children[ch-'a']!=null) \\n    \\t\\t\\tif(search(chars, start+1, L, root.children[ch-'a'])) return true;\\n    \\t}\\n    \\treturn false;\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "#Method with HashMap#\\n\\nStore all words of same length into one set map them to their length.\\n\\n    public class WordDictionary {\\n    private HashMap<Integer, HashSet<String>> map = new HashMap<>();\\n\\n    public void addWord(String word) {\\n        int L = word.length();\\n        if(map.containsKey(L)) {\\n            map.get(L).add(word);\\n        }\\n        else {\\n            HashSet<String> set = new HashSet<>();\\n            set.add(word);\\n            map.put(L, set);\\n        }\\n    }\\n\\n    public boolean search(String word) {\\n        int L = word.length();\\n        if(!map.containsKey(L)) return false;\\n        HashSet<String> set = map.get(L);\\n        for(String str : set) {\\n            int i = 0, LL = word.length();\\n            while(i<LL) {\\n                if(word.charAt(i)!='.' && str.charAt(i)!=word.charAt(i)) break;\\n                ++i;\\n            }\\n            //System.out.println(i +\"\\\\t\"+ LL);\\n            if(i==LL && (word.charAt(i-1)=='.' || str.charAt(i-1)==word.charAt(i-1))) return true;\\n        }\\n        return false;\\n    }\\n    }\\n\\n\\n\\n#Method with Trie#\\n\\nOnce you have the cent of using `trie`, the remaining work would seem not that difficult.  For the `search` method, I recursively check `word` suffix until exhausted.\\n\\n    public class WordDictionary {\\n\\n\\tprivate static final int R = 26;\\n\\tprivate TrieNode root;\\n\\t\\n\\tpublic class TrieNode {\\n\\t\\tprivate static final int R = 26;\\n\\t\\t\\n\\t\\tprivate boolean isEnd;\\n\\t\\tprivate TrieNode[] children;\\n\\t\\t\\n\\t\\tpublic TrieNode() {\\n\\t\\t\\tisEnd = true;\\n\\t\\t\\tchildren = new TrieNode[R];\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic WordDictionary() {\\n\\t\\troot = new TrieNode();\\n\\t}\\n\\n    // Adds a word into the data structure.\\n    public void addWord(String word) {\\n        TrieNode current = root;\\n        for(int i=0, L=word.length(); i<L; i++) {\\n        \\tint id = word.charAt(i) - 'a';\\n        \\tif(current.children[id]==null) {\\n        \\t\\tcurrent.children[id] = new TrieNode();\\n        \\t\\tcurrent.children[id].isEnd = false;\\n        \\t}\\n        \\tcurrent = current.children[id];\\n        }\\n        current.isEnd = true;\\n    }\\n\\n    // Returns if the word is in the data structure. A word could\\n    // contain the dot character '.' to represent any one letter.\\n    public boolean search(String word) {\\n    \\tchar[] chars = word.toCharArray();\\n        return search(chars, 0, chars.length, root);\\n    }\\n    \\n    private boolean search(char[] chars, int start, int L, TrieNode root) {\\n    \\tif(start>=L) return root.isEnd;\\n    \\tchar ch = chars[start];\\n    \\tif(ch=='.') {\\n    \\t\\tfor(int i=0; i<R; i++) {\\n    \\t\\t\\tif(root.children[i]==null) continue;\\n    \\t\\t\\tif(search(chars, start+1, L, root.children[i])) return true;\\n    \\t\\t}\\n    \\t}\\n    \\telse {\\n    \\t\\tif(root.children[ch-'a']!=null) \\n    \\t\\t\\tif(search(chars, start+1, L, root.children[ch-'a'])) return true;\\n    \\t}\\n    \\treturn false;\\n    }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 59739,
                "title": "java-solution-not-using-trie",
                "content": "public class WordDictionary {\\n\\n    Map<Integer, List<String>> map = new HashMap<Integer, List<String>>();\\n    // Adds a word into the data structure.\\n    public void addWord(String word) {\\n        if (word != null && word.length() > 0){\\n            if (map.containsKey(word.length()))\\n                map.get(word.length()).add(word);\\n            else{\\n                List<String> list = new ArrayList<String>();\\n                list.add(word);\\n                map.put(word.length(), list);\\n            }\\n        }\\n    }\\n\\n    // Returns if the word is in the data structure. A word could\\n    // contain the dot character '.' to represent any one letter.\\n    public boolean search(String word) {\\n        if (map.size() < 1)    return false;\\n        if (word == null || word.length() < 1)  return false;\\n        boolean found = false;\\n        if (map.containsKey(word.length())){\\n            List<String> list = map.get(word.length());\\n            for (int i = 0; i < list.size(); i++){\\n                String s = list.get(i);\\n                for (int j = 0; j < s.length(); j++){\\n                    if (word.charAt(j) == s.charAt(j) || word.charAt(j) == '.'){\\n                        found = true;\\n                    }else{\\n                        found = false;\\n                        break;\\n                    }\\n                }\\n                if (found)  return true;\\n            }\\n        }else\\n            return false;\\n        return found;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "public class WordDictionary {\\n\\n    Map<Integer, List<String>> map = new HashMap<Integer, List<String>>();\\n    // Adds a word into the data structure.\\n    public void addWord(String word) {\\n        if (word != null && word.length() > 0){\\n            if (map.containsKey(word.length()))\\n                map.get(word.length()).add(word);\\n            else{\\n                List<String> list = new ArrayList<String>();\\n                list.add(word);\\n                map.put(word.length(), list);\\n            }\\n        }\\n    }\\n\\n    // Returns if the word is in the data structure. A word could\\n    // contain the dot character '.' to represent any one letter.\\n    public boolean search(String word) {\\n        if (map.size() < 1)    return false;\\n        if (word == null || word.length() < 1)  return false;\\n        boolean found = false;\\n        if (map.containsKey(word.length())){\\n            List<String> list = map.get(word.length());\\n            for (int i = 0; i < list.size(); i++){\\n                String s = list.get(i);\\n                for (int j = 0; j < s.length(); j++){\\n                    if (word.charAt(j) == s.charAt(j) || word.charAt(j) == '.'){\\n                        found = true;\\n                    }else{\\n                        found = false;\\n                        break;\\n                    }\\n                }\\n                if (found)  return true;\\n            }\\n        }else\\n            return false;\\n        return found;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3315853,
                "title": "trie-c-simple-short-sweet-easy-to-understand",
                "content": "```\\nclass WordDictionary {\\npublic:\\n    class Trie{\\n        public:\\n        bool end;\\n        Trie *v[26];\\n        Trie(){\\n            end = false;\\n            for(int i = 0; i < 26; i++){\\n                v[i] = NULL;\\n            }\\n        }\\n    };\\n    Trie *node = new Trie();\\n    WordDictionary() {\\n    }\\n    \\n    void addWord(string word) {\\n        Trie *p = node;\\n        for(auto &i: word){\\n            if(p->v[i-\\'a\\']==NULL){\\n                p->v[i-\\'a\\'] = new Trie();\\n            }\\n            p = p->v[i-\\'a\\'];\\n        }\\n        p->end = true;\\n    }\\n    bool solve(Trie *node,string &str,int i){\\n        if(i==str.length()){\\n            return node->end;\\n        }\\n        bool ans = false;\\n        if(str[i]==\\'.\\'){\\n            for(int j = 0; j < 26; j++){\\n                if(node->v[j])\\n                ans |= solve(node->v[j],str,i+1);\\n                if(ans)return true;\\n            }\\n        }else{\\n            if(node->v[str[i]-\\'a\\'])\\n            ans = solve(node->v[str[i]-\\'a\\'],str,i+1);\\n        }\\n        return ans;\\n    }\\n    bool search(string word) {\\n        return solve(node,word,0);\\n    }\\n};\\n ```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass WordDictionary {\\npublic:\\n    class Trie{\\n        public:\\n        bool end;\\n        Trie *v[26];\\n        Trie(){\\n            end = false;\\n            for(int i = 0; i < 26; i++){\\n                v[i] = NULL;\\n            }\\n        }\\n    };\\n    Trie *node = new Trie();\\n    WordDictionary() {\\n    }\\n    \\n    void addWord(string word) {\\n        Trie *p = node;\\n        for(auto &i: word){\\n            if(p->v[i-\\'a\\']==NULL){\\n                p->v[i-\\'a\\'] = new Trie();\\n            }\\n            p = p->v[i-\\'a\\'];\\n        }\\n        p->end = true;\\n    }\\n    bool solve(Trie *node,string &str,int i){\\n        if(i==str.length()){\\n            return node->end;\\n        }\\n        bool ans = false;\\n        if(str[i]==\\'.\\'){\\n            for(int j = 0; j < 26; j++){\\n                if(node->v[j])\\n                ans |= solve(node->v[j],str,i+1);\\n                if(ans)return true;\\n            }\\n        }else{\\n            if(node->v[str[i]-\\'a\\'])\\n            ans = solve(node->v[str[i]-\\'a\\'],str,i+1);\\n        }\\n        return ans;\\n    }\\n    bool search(string word) {\\n        return solve(node,word,0);\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3314933,
                "title": "python-short-and-clean-trie-dfs",
                "content": "# Approach\\nTL;DR, Similar to [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) except `DFS` for `search`.\\n\\n# Complexity\\n`__init__`:\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n`addWord`:\\n- Time complexity: $$O(k)$$\\n- Space complexity: $$O(k)$$\\n\\n`search`:\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\nwhere,\\n`k is the length of word`,\\n`n is the total length of all words`.\\n\\n# Code\\n```python\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.root = Node()\\n\\n    def addWord(self, word: str) -> None:\\n        reduce(lambda a, x: a.children[x], word, self.root).is_end = True\\n\\n    def search(self, word: str) -> bool:\\n        def search_(node: Node, i: int) -> bool:\\n            if i == len(word): return node.is_end\\n            ch = word[i]\\n            if ch != \\'.\\' and ch not in node.children: return False\\n            xs = node.children.values() if ch == \\'.\\' else (node.children[ch],)\\n            return any(search_(x, i + 1) for x in xs)\\n        \\n        return search_(self.root, 0)\\n\\nclass Node:\\n    def __init__(self, children: dict = None, is_end: bool = False) -> None:\\n        self.children = defaultdict(Node) if children is None else children\\n        self.is_end = is_end\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Design",
                    "Trie"
                ],
                "code": "```python\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.root = Node()\\n\\n    def addWord(self, word: str) -> None:\\n        reduce(lambda a, x: a.children[x], word, self.root).is_end = True\\n\\n    def search(self, word: str) -> bool:\\n        def search_(node: Node, i: int) -> bool:\\n            if i == len(word): return node.is_end\\n            ch = word[i]\\n            if ch != \\'.\\' and ch not in node.children: return False\\n            xs = node.children.values() if ch == \\'.\\' else (node.children[ch],)\\n            return any(search_(x, i + 1) for x in xs)\\n        \\n        return search_(self.root, 0)\\n\\nclass Node:\\n    def __init__(self, children: dict = None, is_end: bool = False) -> None:\\n        self.children = defaultdict(Node) if children is None else children\\n        self.is_end = is_end\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314673,
                "title": "easy-python-pure-dict-trie-dfs",
                "content": "# Intuition\\nWe don\\'t need to create a class like `Node` to build our trie, just using `dict`. \\n\\nFor `search(self, word: str)`, when meeting `.`, we need to check the next level recursively. When meeting a letter, check whether it is in `cur`, if it is, check its branch recursively.\\n\\n\\n# Code\\n```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.trie = {}\\n\\n    def addWord(self, word: str) -> None:\\n        cur = self.trie\\n        for ch in word:\\n            if ch not in cur:\\n                # create the next level\\n                cur[ch] = {}\\n            cur = cur[ch]\\n        # end of a string\\n        cur[\\'-\\'] = True\\n\\n    def search(self, word: str) -> bool:\\n        def dfs(cur, idx):\\n            # check whether it is the end of the string\\n            if idx == len(word):\\n                return \\'-\\' in cur\\n            if word[idx] == \\'.\\':\\n                for ch in cur:\\n                    # skip this, since it is for checking\\n                    if ch == \\'-\\':\\n                        continue\\n                    # recursively check every possible branch\\n                    if dfs(cur[ch], idx + 1):\\n                        return True\\n            if word[idx] not in cur:\\n                return False\\n            return dfs(cur[word[idx]], idx + 1)\\n\\n        return dfs(self.trie, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.trie = {}\\n\\n    def addWord(self, word: str) -> None:\\n        cur = self.trie\\n        for ch in word:\\n            if ch not in cur:\\n                # create the next level\\n                cur[ch] = {}\\n            cur = cur[ch]\\n        # end of a string\\n        cur[\\'-\\'] = True\\n\\n    def search(self, word: str) -> bool:\\n        def dfs(cur, idx):\\n            # check whether it is the end of the string\\n            if idx == len(word):\\n                return \\'-\\' in cur\\n            if word[idx] == \\'.\\':\\n                for ch in cur:\\n                    # skip this, since it is for checking\\n                    if ch == \\'-\\':\\n                        continue\\n                    # recursively check every possible branch\\n                    if dfs(cur[ch], idx + 1):\\n                        return True\\n            if word[idx] not in cur:\\n                return False\\n            return dfs(cur[word[idx]], idx + 1)\\n\\n        return dfs(self.trie, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314586,
                "title": "industry-standard-code-best-clean-code-trie-most-upvoted",
                "content": "# INDUSTRY STANDARD CODE | BEST CLEAN CODE | TRIE | UPVOTED\\n```WordDictionary []\\nclass WordDictionary {\\n    private final Node root;\\n\\n    public WordDictionary() {\\n        root = new Node();\\n    }\\n\\n    public void addWord(String word) {\\n        Node node = this.root;\\n        for (char c : word.toCharArray()) {\\n            assert node != null;\\n            if (node.doesNotContainsKey(c)) node.put(c, new Node());\\n            node = node.get(c);\\n        }\\n        node.setEnd();\\n    }\\n\\n    public boolean search(String word) {\\n        return root.search(word, 0, root);\\n    }\\n}\\n```\\n```NODE []\\nclass Node {\\n    private Node[] links = new Node[26];\\n    private boolean isCompleted = false;\\n\\n    public void put(char c, Node node) {\\n        this.links[c - \\'a\\'] = node;\\n    }\\n\\n    public Node get(char c) {\\n        return this.links[c - \\'a\\'];\\n    }\\n\\n    public boolean doesNotContainsKey(char c) {\\n        return this.links[c - \\'a\\'] == null;\\n    }\\n\\n    public boolean isEnd() {\\n        return this.isCompleted;\\n    }\\n\\n    public void setEnd() {\\n        this.isCompleted = true;\\n    }\\n\\n    public boolean search(String word, int index, Node node) {\\n        if (index == word.length()) return node.isEnd();\\n        char c = word.charAt(index);\\n        if (c == \\'.\\') {\\n            for (Node child : node.links)\\n                if (child != null && child.search(word, index + 1, child)) return true;\\n            return false;\\n        } else {\\n            if (node.doesNotContainsKey(c)) return false;\\n            return search(word, index + 1, node.get(c));\\n        }\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(3^26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![MEME.png](https://assets.leetcode.com/users/images/4f1a6cca-9b8b-4643-a4bc-9b4daee490d9_1679203354.436818.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Trie"
                ],
                "code": "```WordDictionary []\\nclass WordDictionary {\\n    private final Node root;\\n\\n    public WordDictionary() {\\n        root = new Node();\\n    }\\n\\n    public void addWord(String word) {\\n        Node node = this.root;\\n        for (char c : word.toCharArray()) {\\n            assert node != null;\\n            if (node.doesNotContainsKey(c)) node.put(c, new Node());\\n            node = node.get(c);\\n        }\\n        node.setEnd();\\n    }\\n\\n    public boolean search(String word) {\\n        return root.search(word, 0, root);\\n    }\\n}\\n```\n```NODE []\\nclass Node {\\n    private Node[] links = new Node[26];\\n    private boolean isCompleted = false;\\n\\n    public void put(char c, Node node) {\\n        this.links[c - \\'a\\'] = node;\\n    }\\n\\n    public Node get(char c) {\\n        return this.links[c - \\'a\\'];\\n    }\\n\\n    public boolean doesNotContainsKey(char c) {\\n        return this.links[c - \\'a\\'] == null;\\n    }\\n\\n    public boolean isEnd() {\\n        return this.isCompleted;\\n    }\\n\\n    public void setEnd() {\\n        this.isCompleted = true;\\n    }\\n\\n    public boolean search(String word, int index, Node node) {\\n        if (index == word.length()) return node.isEnd();\\n        char c = word.charAt(index);\\n        if (c == \\'.\\') {\\n            for (Node child : node.links)\\n                if (child != null && child.search(word, index + 1, child)) return true;\\n            return false;\\n        } else {\\n            if (node.doesNotContainsKey(c)) return false;\\n            return search(word, index + 1, node.get(c));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314557,
                "title": "java-trie-clean-code-beats-76",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ for `addWord`, $$O(26^n)$$ for `search`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(26^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass WordDictionary {\\n  class Node {\\n    Node[] next;\\n    boolean isWord;\\n\\n    Node() {\\n      next = new Node[26];\\n    }\\n  }\\n\\n  private Node root;\\n\\n  public WordDictionary() {\\n    root = new Node();\\n  }\\n  \\n  public void addWord(String word) {\\n    var node = root;\\n\\n    for (var c : word.toCharArray()) {\\n      var i = c - \\'a\\';\\n      \\n      if (node.next[i] == null)\\n        node.next[i] = new Node();\\n      \\n      node = node.next[i];\\n    }\\n    node.isWord = true;\\n  }\\n\\n  private boolean search(String word, int idx, Node node) {\\n    if (idx == word.length())\\n      return node == null || node.isWord;\\n\\n    for (var i = idx; i < word.length() && node != null; i++) {\\n      var c = word.charAt(i);\\n\\n      if (c == \\'.\\') {\\n        for (var nextNode : node.next)\\n          if (nextNode != null && search(word, i+1, nextNode))\\n            return true;\\n        \\n        return false;\\n      }\\n      node = node.next[c - \\'a\\'];\\n    }\\n    return node != null && node.isWord;\\n  }\\n  \\n  public boolean search(String word) {\\n    return search(word, 0, root);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass WordDictionary {\\n  class Node {\\n    Node[] next;\\n    boolean isWord;\\n\\n    Node() {\\n      next = new Node[26];\\n    }\\n  }\\n\\n  private Node root;\\n\\n  public WordDictionary() {\\n    root = new Node();\\n  }\\n  \\n  public void addWord(String word) {\\n    var node = root;\\n\\n    for (var c : word.toCharArray()) {\\n      var i = c - \\'a\\';\\n      \\n      if (node.next[i] == null)\\n        node.next[i] = new Node();\\n      \\n      node = node.next[i];\\n    }\\n    node.isWord = true;\\n  }\\n\\n  private boolean search(String word, int idx, Node node) {\\n    if (idx == word.length())\\n      return node == null || node.isWord;\\n\\n    for (var i = idx; i < word.length() && node != null; i++) {\\n      var c = word.charAt(i);\\n\\n      if (c == \\'.\\') {\\n        for (var nextNode : node.next)\\n          if (nextNode != null && search(word, i+1, nextNode))\\n            return true;\\n        \\n        return false;\\n      }\\n      node = node.next[c - \\'a\\'];\\n    }\\n    return node != null && node.isWord;\\n  }\\n  \\n  public boolean search(String word) {\\n    return search(word, 0, root);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313724,
                "title": "simple-python3-solution-100-faster-11-lines-code-commented-dictionary",
                "content": "# Intuition\\nImplemented a trie-like approach where we are storing the length of each word in a dictionary and when searching, we are replacing the \\'.\\' with each letter in the alphabet and checking if the word exists in the dictionary.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nAdding a word: O(1)\\nSearching a word: O(n * w^m), where n is the length of the word, w is number of words in dictionary and m is the number of \\'.\\' in the word. \\n\\n- Space complexity:\\nO(k * L), where k is the number of words and L is the average length of the words.\\n\\n# Code\\n```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        # create a defaultdict of sets to store the words\\n        self.dic = defaultdict(set)\\n\\n    def addWord(self, word: str) -> None:\\n        # add the word to the set of words with the same length\\n        self.dic[len(word)].add(word)\\n\\n    def search(self, word: str) -> bool:\\n        # If \".\" in word\\n        # check if it exists in the set of words with the same length\\n        if \\'.\\' not in word:\\n            return word in self.dic[len(word)]\\n        # if the word contains dots, iterate over all words of the same length\\n        for l in self.dic[len(word)]:\\n            # check if each letter in the word matches the respective letter\\n            for i, ind in enumerate(word):\\n                if ind != l[i] and ind != \\'.\\':\\n                    break\\n            else:\\n                return True\\n        # if no matching word is found, return False\\n        return False\\n            \\n\\n# Your WordDictionary object will be instantiated and called as such:\\n# obj = WordDictionary()\\n# obj.addWord(word)\\n# param_2 = obj.search(word)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        # create a defaultdict of sets to store the words\\n        self.dic = defaultdict(set)\\n\\n    def addWord(self, word: str) -> None:\\n        # add the word to the set of words with the same length\\n        self.dic[len(word)].add(word)\\n\\n    def search(self, word: str) -> bool:\\n        # If \".\" in word\\n        # check if it exists in the set of words with the same length\\n        if \\'.\\' not in word:\\n            return word in self.dic[len(word)]\\n        # if the word contains dots, iterate over all words of the same length\\n        for l in self.dic[len(word)]:\\n            # check if each letter in the word matches the respective letter\\n            for i, ind in enumerate(word):\\n                if ind != l[i] and ind != \\'.\\':\\n                    break\\n            else:\\n                return True\\n        # if no matching word is found, return False\\n        return False\\n            \\n\\n# Your WordDictionary object will be instantiated and called as such:\\n# obj = WordDictionary()\\n# obj.addWord(word)\\n# param_2 = obj.search(word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313632,
                "title": "c-trie",
                "content": "# Code\\n```\\nclass TrieNode{\\npublic:\\n    TrieNode *child[26];\\n    bool end = false;\\n    TrieNode(){\\n        for(int i = 0; i < 26; i++)\\n            child[i] = NULL;\\n    }\\n};\\nclass WordDictionary {\\n      TrieNode *root ;\\npublic:\\n    WordDictionary() {\\n        root =  new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        int idx = 0;\\n        TrieNode * node = root;\\n        for(char c: word) {\\n            idx = c -\\'a\\';\\n            if(!node->child[idx])\\n                node->child[idx] = new TrieNode();\\n            node = node->child[idx];\\n        }\\n        node->end = true;\\n    }\\n    \\n    bool search(string word) {\\n        TrieNode *node = root;\\n        return search(word, 0, node);\\n    }\\n    bool search(string &word, int idx , TrieNode *node ) {\\n        if(!node) return 0;\\n        if(idx == word.size()) return node->end;\\n        if(word[idx] != \\'.\\')\\n            return search(word, idx+1, node->child[word[idx]-\\'a\\']);\\n\\n        for(int key = 0; key< 26; key++)\\n            if(search(word, idx+1, node->child[key]))\\n                return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode{\\npublic:\\n    TrieNode *child[26];\\n    bool end = false;\\n    TrieNode(){\\n        for(int i = 0; i < 26; i++)\\n            child[i] = NULL;\\n    }\\n};\\nclass WordDictionary {\\n      TrieNode *root ;\\npublic:\\n    WordDictionary() {\\n        root =  new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        int idx = 0;\\n        TrieNode * node = root;\\n        for(char c: word) {\\n            idx = c -\\'a\\';\\n            if(!node->child[idx])\\n                node->child[idx] = new TrieNode();\\n            node = node->child[idx];\\n        }\\n        node->end = true;\\n    }\\n    \\n    bool search(string word) {\\n        TrieNode *node = root;\\n        return search(word, 0, node);\\n    }\\n    bool search(string &word, int idx , TrieNode *node ) {\\n        if(!node) return 0;\\n        if(idx == word.size()) return node->end;\\n        if(word[idx] != \\'.\\')\\n            return search(word, idx+1, node->child[word[idx]-\\'a\\']);\\n\\n        for(int key = 0; key< 26; key++)\\n            if(search(word, idx+1, node->child[key]))\\n                return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313624,
                "title": "daily-leetcoding-challenge-march-day-19",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3080856,
                "title": "elegant-solution-using-trie-and-recursion-in-javascript",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution implements a Trie data structure for the WordDictionary class, where each node in the Trie represents a letter in a word. The $$addWord(word)$$ method adds a given word to the data structure by iterating through each letter in the word and creating a new node for the letter if it doesn\\'t already exist. It then sets the $$isWord$$ property of the last node to $$true$$ to indicate that it is the end of a word.\\n\\nThe $$search(word)$$ method is used to check if a given word is present in the data structure. It starts at the root of the Trie and iterates through each letter in the word. If the current letter is a \\'.\\', it means that it can match any letter, so the method iterates through all the children of the current node and recursively calls the search method for each child. If the current letter is not a \\'.\\', the method checks if a child node for the letter exists in the current node. If it doesn\\'t exist, the method returns false as the word is not present in the data structure. If the loop completes without returning false, it means that the word is present in the data structure, so the method returns the value of the isWord property of the last node.\\n\\nOverall, this solution is efficient as it uses Trie data structure which allows for fast search and insertion of words. The use of recursion makes the search method more readable and easy to understand. The use of \\'.\\' as a wildcard character allows for more flexibility in matching words.\\n\\n# Code\\n```\\nvar WordDictionary = function() {\\n    this.n = {};  \\n    this.isWord = false;\\n    return this;\\n};\\n\\n/** \\n * @param {string} word\\n * @return {void}\\n */\\nWordDictionary.prototype.addWord = function(word) {\\n    let curr = this;\\n    for (let i = 0; i < word.length; i++) {\\n        if (!curr.n[word[i]]) {\\n            curr.n[word[i]] = new WordDictionary(word[i]);\\n        }\\n        curr = curr.n[word[i]];\\n    }\\n    curr.isWord = true;\\n};\\n\\n/** \\n * @param {string} word\\n * @return {boolean}\\n */\\nWordDictionary.prototype.search = function(word, start = 0, newCurr = null) {\\n    let curr = this;\\n    if (newCurr != null)\\n        curr = newCurr;\\n    for (let i = start; i < word.length; i++) {\\n        let char = word[i];\\n        if (char == \\'.\\') {\\n            let letters = Object.keys(curr.n);\\n            let res = false;\\n            for (let letter of letters) {\\n                res = res || this.search(word, i + 1, curr.n[letter]);\\n            }\\n            return res;\\n        } else if (!curr.n[char]) {\\n            return false;\\n        }\\n        curr = curr.n[char];\\n    }\\n    return curr.isWord;\\n};\\n\\n/** \\n * Your WordDictionary object will be instantiated and called as such:\\n * var obj = new WordDictionary()\\n * obj.addWord(word)\\n * var param_2 = obj.search(word)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Trie",
                    "Recursion",
                    "String Matching"
                ],
                "code": "```\\nvar WordDictionary = function() {\\n    this.n = {};  \\n    this.isWord = false;\\n    return this;\\n};\\n\\n/** \\n * @param {string} word\\n * @return {void}\\n */\\nWordDictionary.prototype.addWord = function(word) {\\n    let curr = this;\\n    for (let i = 0; i < word.length; i++) {\\n        if (!curr.n[word[i]]) {\\n            curr.n[word[i]] = new WordDictionary(word[i]);\\n        }\\n        curr = curr.n[word[i]];\\n    }\\n    curr.isWord = true;\\n};\\n\\n/** \\n * @param {string} word\\n * @return {boolean}\\n */\\nWordDictionary.prototype.search = function(word, start = 0, newCurr = null) {\\n    let curr = this;\\n    if (newCurr != null)\\n        curr = newCurr;\\n    for (let i = start; i < word.length; i++) {\\n        let char = word[i];\\n        if (char == \\'.\\') {\\n            let letters = Object.keys(curr.n);\\n            let res = false;\\n            for (let letter of letters) {\\n                res = res || this.search(word, i + 1, curr.n[letter]);\\n            }\\n            return res;\\n        } else if (!curr.n[char]) {\\n            return false;\\n        }\\n        curr = curr.n[char];\\n    }\\n    return curr.isWord;\\n};\\n\\n/** \\n * Your WordDictionary object will be instantiated and called as such:\\n * var obj = new WordDictionary()\\n * obj.addWord(word)\\n * var param_2 = obj.search(word)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3066848,
                "title": "easy-c-trie-solution-faster-than-others",
                "content": "\\n\\n# Code\\n```\\nclass WordDictionary {\\n    class Trie{\\n        public:\\n        Trie* child[26];\\n        bool isEnd;\\n        Trie(){\\n            for(int i=0;i<26;i++){\\n                child[i]=NULL;\\n            }\\n            isEnd=false;\\n        }\\n    };\\npublic:\\nTrie* root=new Trie();\\n    WordDictionary() {\\n        \\n    }\\n    \\n    void addWord(string word) {\\n        Trie* curr=root;\\n        for(int i=0;i<word.length();i++){\\n            int idx=word[i]-97;\\n            if(curr->child[idx]==NULL){\\n                curr->child[idx]=new Trie();\\n            }\\n            curr=curr->child[idx];\\n        }\\n        curr->isEnd=true;\\n        \\n    }\\n    //basically the idea is is the word[i]=\\'.\\' we match it & we find word(i+1) to word.length characters\\n    bool helper(string word,Trie* curr){\\n        for(int i=0;i<word.length();i++){\\n            if(word[i]!=\\'.\\'){\\n                int idx=word[i]-97;\\n                if(curr->child[idx]==NULL)return false;\\n                curr=curr->child[idx];\\n            }\\n            else{\\n                //if word[i]==\\'.\\'\\n                int j=0;\\n                bool found=false;\\n                for(;j<26;j++){\\n                    if(curr->child[j]!=NULL){\\n                        found |=helper(word.substr(i+1),curr->child[j]);\\n                        if(found)return true;\\n                    }\\n                }    \\n                if(j==26)return false;\\n            }\\n            \\n        }\\n        return curr->isEnd;\\n    }\\n    bool search(string word) {\\n        Trie*curr=root;\\n        return helper(word,curr);\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n\\n\\n \\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Trie"
                ],
                "code": "```\\nclass WordDictionary {\\n    class Trie{\\n        public:\\n        Trie* child[26];\\n        bool isEnd;\\n        Trie(){\\n            for(int i=0;i<26;i++){\\n                child[i]=NULL;\\n            }\\n            isEnd=false;\\n        }\\n    };\\npublic:\\nTrie* root=new Trie();\\n    WordDictionary() {\\n        \\n    }\\n    \\n    void addWord(string word) {\\n        Trie* curr=root;\\n        for(int i=0;i<word.length();i++){\\n            int idx=word[i]-97;\\n            if(curr->child[idx]==NULL){\\n                curr->child[idx]=new Trie();\\n            }\\n            curr=curr->child[idx];\\n        }\\n        curr->isEnd=true;\\n        \\n    }\\n    //basically the idea is is the word[i]=\\'.\\' we match it & we find word(i+1) to word.length characters\\n    bool helper(string word,Trie* curr){\\n        for(int i=0;i<word.length();i++){\\n            if(word[i]!=\\'.\\'){\\n                int idx=word[i]-97;\\n                if(curr->child[idx]==NULL)return false;\\n                curr=curr->child[idx];\\n            }\\n            else{\\n                //if word[i]==\\'.\\'\\n                int j=0;\\n                bool found=false;\\n                for(;j<26;j++){\\n                    if(curr->child[j]!=NULL){\\n                        found |=helper(word.substr(i+1),curr->child[j]);\\n                        if(found)return true;\\n                    }\\n                }    \\n                if(j==26)return false;\\n            }\\n            \\n        }\\n        return curr->isEnd;\\n    }\\n    bool search(string word) {\\n        Trie*curr=root;\\n        return helper(word,curr);\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846451,
                "title": "simple-explanation-99-python-for-beginners",
                "content": "![image](https://assets.leetcode.com/users/images/752b221f-1c2c-40bf-9926-0d133cb3fb03_1669340793.1175375.png)\\n\\n```\\nclass WordDictionary(object):\\n    def __init__(self):\\n        self.word_dict = collections.defaultdict(set)\\n        \\n\\n    def addWord(self, word):\\n        # add to the bucket with same length\\n        if word:\\n            self.word_dict[len(word)].add(word)\\n\\n    def search(self, word):\\n        # Edge Case\\n        if not word:\\n            return False\\n        \\n        # if \\'.\\' not in word given\\n        if \\'.\\' not in word:\\n            return word in self.word_dict[len(word)]\\n        \\n        # if \\'.\\' in word then compare the structure for each word in set with given word\\n        for v in self.word_dict[len(word)]:\\n            # match xx.xx.x with yyyyyyy\\n            for i, ch in enumerate(word):\\n                if ch != v[i]:\\n                    if ch != \\'.\\':\\n                        break\\n            else:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass WordDictionary(object):\\n    def __init__(self):\\n        self.word_dict = collections.defaultdict(set)\\n        \\n\\n    def addWord(self, word):\\n        # add to the bucket with same length\\n        if word:\\n            self.word_dict[len(word)].add(word)\\n\\n    def search(self, word):\\n        # Edge Case\\n        if not word:\\n            return False\\n        \\n        # if \\'.\\' not in word given\\n        if \\'.\\' not in word:\\n            return word in self.word_dict[len(word)]\\n        \\n        # if \\'.\\' in word then compare the structure for each word in set with given word\\n        for v in self.word_dict[len(word)]:\\n            # match xx.xx.x with yyyyyyy\\n            for i, ch in enumerate(word):\\n                if ch != v[i]:\\n                    if ch != \\'.\\':\\n                        break\\n            else:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774617,
                "title": "python-faster-than-98-prefix-tree-trie-with-dfs-optimization",
                "content": "**This solution gives TLE. If you keep submitting, it will pass all test cases (rarely).**\\n![image.png](https://assets.leetcode.com/users/images/cb2d5ea4-bd98-431a-8e71-f7e7ce846d41_1667497454.24535.png)\\n\\n```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n\\nclass WordDictionary:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def addWord(self, word: str) -> None:\\n        curr = self.root\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = TrieNode()\\n            \\n            curr = curr.children[c]\\n\\n        curr.endOfWord = True\\n\\n    def search(self, word: str) -> bool:\\n        def dfs(i, root):\\n            curr = root\\n            for j in range(i, len(word)):\\n                c = word[j]\\n                if c != \\'.\\':\\n                    if c not in curr.children:\\n                        return False\\n\\n                    curr = curr.children[c]\\n\\n                else:\\n                    for child in curr.children.values():\\n                        if dfs(j + 1, child):\\n                            return True\\n                        \\n                    return False\\n\\n            return curr.endOfWord\\n\\n        return dfs(0, self.root)\\n```\\n# Optimized Trie\\n**Keeps track of length of the longest word inserted into the trie.**\\n![image.png](https://assets.leetcode.com/users/images/99d7421c-7383-4ce2-a71d-50bebf283bd1_1667497434.2082036.png)\\n\\n```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n\\nclass WordDictionary:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.maxLen = 0\\n\\n    def addWord(self, word: str) -> None:\\n        curr = self.root\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = TrieNode()\\n            \\n            curr = curr.children[c]\\n\\n        self.maxLen = max(self.maxLen, len(word))   #Keeps track of the max length\\n        curr.endOfWord = True\\n\\n    def search(self, word: str) -> bool:\\n        if len(word) > self.maxLen:     #Optimization\\n            return False\\n\\n        def dfs(i, root):\\n            curr = root\\n            for j in range(i, len(word)):\\n                c = word[j]\\n                if c != \\'.\\':\\n                    if c not in curr.children:\\n                        return False\\n\\n                    curr = curr.children[c]\\n\\n                else:\\n                    for child in curr.children.values():\\n                        if dfs(j + 1, child):\\n                            return True\\n                        \\n                    return False\\n\\n            return curr.endOfWord\\n\\n        return dfs(0, self.root)\\n```\\n\\n# Please upvote if you find this helpful.",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n\\nclass WordDictionary:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def addWord(self, word: str) -> None:\\n        curr = self.root\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = TrieNode()\\n            \\n            curr = curr.children[c]\\n\\n        curr.endOfWord = True\\n\\n    def search(self, word: str) -> bool:\\n        def dfs(i, root):\\n            curr = root\\n            for j in range(i, len(word)):\\n                c = word[j]\\n                if c != \\'.\\':\\n                    if c not in curr.children:\\n                        return False\\n\\n                    curr = curr.children[c]\\n\\n                else:\\n                    for child in curr.children.values():\\n                        if dfs(j + 1, child):\\n                            return True\\n                        \\n                    return False\\n\\n            return curr.endOfWord\\n\\n        return dfs(0, self.root)\\n```\n```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n\\nclass WordDictionary:\\n    def __init__(self):\\n        self.root = TrieNode()\\n        self.maxLen = 0\\n\\n    def addWord(self, word: str) -> None:\\n        curr = self.root\\n        for c in word:\\n            if c not in curr.children:\\n                curr.children[c] = TrieNode()\\n            \\n            curr = curr.children[c]\\n\\n        self.maxLen = max(self.maxLen, len(word))   #Keeps track of the max length\\n        curr.endOfWord = True\\n\\n    def search(self, word: str) -> bool:\\n        if len(word) > self.maxLen:     #Optimization\\n            return False\\n\\n        def dfs(i, root):\\n            curr = root\\n            for j in range(i, len(word)):\\n                c = word[j]\\n                if c != \\'.\\':\\n                    if c not in curr.children:\\n                        return False\\n\\n                    curr = curr.children[c]\\n\\n                else:\\n                    for child in curr.children.values():\\n                        if dfs(j + 1, child):\\n                            return True\\n                        \\n                    return False\\n\\n            return curr.endOfWord\\n\\n        return dfs(0, self.root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622070,
                "title": "simple-c-solution-using-trie-clean-code",
                "content": "```\\nclass TrieNode{\\npublic:\\n    TrieNode *child[26];\\n    bool end = false;\\n    TrieNode(){\\n        for(int i = 0; i < 26; i++)\\n            child[i] = NULL;\\n    }\\n};\\n\\n\\nclass WordDictionary {\\n    TrieNode *root ;\\npublic:\\n    WordDictionary() {\\n        root =  new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        int idx = 0;\\n        TrieNode * node = root;\\n        for(char c: word) {\\n            idx = c -\\'a\\';\\n            if(!node->child[idx])\\n                node->child[idx] = new TrieNode();\\n            node = node->child[idx];\\n        }\\n        node->end = true;\\n    }\\n    \\n    bool search(string word) {\\n        TrieNode *node = root;\\n        return search(word, 0, node);\\n    }\\n    bool search(string &word, int idx , TrieNode *node ) {\\n        if(!node) return 0;\\n        if(idx == word.size()) return node->end;\\n        if(word[idx] != \\'.\\')\\n            return search(word, idx+1, node->child[word[idx]-\\'a\\']);\\n\\n        for(int key = 0; key< 26; key++)\\n            if(search(word, idx+1, node->child[key]))\\n                return true;\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass TrieNode{\\npublic:\\n    TrieNode *child[26];\\n    bool end = false;\\n    TrieNode(){\\n        for(int i = 0; i < 26; i++)\\n            child[i] = NULL;\\n    }\\n};\\n\\n\\nclass WordDictionary {\\n    TrieNode *root ;\\npublic:\\n    WordDictionary() {\\n        root =  new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        int idx = 0;\\n        TrieNode * node = root;\\n        for(char c: word) {\\n            idx = c -\\'a\\';\\n            if(!node->child[idx])\\n                node->child[idx] = new TrieNode();\\n            node = node->child[idx];\\n        }\\n        node->end = true;\\n    }\\n    \\n    bool search(string word) {\\n        TrieNode *node = root;\\n        return search(word, 0, node);\\n    }\\n    bool search(string &word, int idx , TrieNode *node ) {\\n        if(!node) return 0;\\n        if(idx == word.size()) return node->end;\\n        if(word[idx] != \\'.\\')\\n            return search(word, idx+1, node->child[word[idx]-\\'a\\']);\\n\\n        for(int key = 0; key< 26; key++)\\n            if(search(word, idx+1, node->child[key]))\\n                return true;\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269316,
                "title": "design-add-and-search-words-data-structure-cpp-easy-solution-with-full-explanation",
                "content": "**Explanation**\\nNo need to write the generic functions in the data structure that we do usually. It will give TLE, so to simulate the functionality (insert, get, setEnd, isEnd) we will be using the `links[]` array itself.\\n\\nThere is a very interesting thing you will notice, `addWord` functon is fine. You will get certain words and you have to insert it as we do in generic implementation of Trie.\\n\\nBut in `search` function, it is said that it will return `true` if there is any string in data structure that matches `word` or `false` otherwise.\\n\\nNow, the interesting part, it is said that, `word` may contains dots `\\'.\\'` and these dots can be matched with any letter. This basically means we have 26 possibilities from `a to z`. So, this case we have to handle. Otherwise, the entire search function is same as we do in generic implementation of Trie.\\n\\n**Code**\\n```\\nstruct Node{\\n    Node *links[26];\\n    bool isEnd = false;\\n};\\n\\nclass WordDictionary {\\nprivate:\\n    Node* root;    \\npublic:\\n    WordDictionary() {\\n        root = new Node();\\n    }\\n    \\n    void addWord(string word) {\\n        Node* node = root;\\n        for(int i=0; i<word.size(); i++){\\n            \\n            // If word[i] doesn\\'t exists then insert it\\n            if(node->links[word[i] - \\'a\\'] == NULL){\\n                node->links[word[i] - \\'a\\'] = new Node();\\n            }\\n            \\n            node = node->links[word[i] - \\'a\\'];\\n        }\\n        \\n        node->isEnd = true;\\n    }\\n    \\n    bool searchHelper(string word, Node* node){\\n        for(int i=0; i<word.size(); i++){\\n            \\n            // if word[i] is \\'.\\' then we have 26 possibilities\\n            // So we have to consider every possibility\\n            if(word[i] == \\'.\\'){\\n                for(char c=\\'a\\';c<=\\'z\\';c++){\\n                    if(node->links[c - \\'a\\']){\\n                        if(searchHelper(word.substr(i+1), node->links[c - \\'a\\']))\\n                            return true;\\n                    }\\n                }\\n                return false;\\n            }\\n            else{\\n                if(node->links[word[i] - \\'a\\'] == NULL) return false;\\n                node = node->links[word[i] - \\'a\\'];\\n            }\\n        }\\n        \\n        // if(node->isEnd) return true;\\n        // return false;\\n        return node->isEnd;\\n    }\\n    \\n    bool search(string word) {\\n        Node* node = root;\\n       return searchHelper(word, node);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nstruct Node{\\n    Node *links[26];\\n    bool isEnd = false;\\n};\\n\\nclass WordDictionary {\\nprivate:\\n    Node* root;    \\npublic:\\n    WordDictionary() {\\n        root = new Node();\\n    }\\n    \\n    void addWord(string word) {\\n        Node* node = root;\\n        for(int i=0; i<word.size(); i++){\\n            \\n            // If word[i] doesn\\'t exists then insert it\\n            if(node->links[word[i] - \\'a\\'] == NULL){\\n                node->links[word[i] - \\'a\\'] = new Node();\\n            }\\n            \\n            node = node->links[word[i] - \\'a\\'];\\n        }\\n        \\n        node->isEnd = true;\\n    }\\n    \\n    bool searchHelper(string word, Node* node){\\n        for(int i=0; i<word.size(); i++){\\n            \\n            // if word[i] is \\'.\\' then we have 26 possibilities\\n            // So we have to consider every possibility\\n            if(word[i] == \\'.\\'){\\n                for(char c=\\'a\\';c<=\\'z\\';c++){\\n                    if(node->links[c - \\'a\\']){\\n                        if(searchHelper(word.substr(i+1), node->links[c - \\'a\\']))\\n                            return true;\\n                    }\\n                }\\n                return false;\\n            }\\n            else{\\n                if(node->links[word[i] - \\'a\\'] == NULL) return false;\\n                node = node->links[word[i] - \\'a\\'];\\n            }\\n        }\\n        \\n        // if(node->isEnd) return true;\\n        // return false;\\n        return node->isEnd;\\n    }\\n    \\n    bool search(string word) {\\n        Node* node = root;\\n       return searchHelper(word, node);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081970,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Trie***\\n\\n* ***Time Complexity : O(N) for both insert && search***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass WordDictionary {\\npublic:\\n    WordDictionary() {\\n        \\n    }\\n    \\n    struct TrieNode\\n    {\\n        bool end;\\n        \\n        TrieNode* child[26];\\n        \\n        TrieNode()\\n        {\\n            end = false;\\n            \\n            for(int i = 0; i < 26; i++)\\n            {\\n                child[i] = NULL;\\n            }\\n        }\\n    };\\n    \\n    TrieNode* root = new TrieNode();\\n    \\n    void addWord(string word) {\\n        \\n        int n = word.size();\\n        \\n        TrieNode* curr = root;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int idx = word[i] - \\'a\\';\\n            \\n            if(curr -> child[idx] == NULL)\\n            {\\n                curr -> child[idx] = new TrieNode();\\n            }\\n            \\n            curr = curr -> child[idx];\\n        }\\n        \\n        curr -> end = true;\\n    }\\n    \\n    \\n    bool rec_search(string &str, int i, int n, TrieNode* curr) \\n    {\\n        if(i == n)\\n        {\\n            return curr -> end;\\n        }\\n        \\n        if(str[i] != \\'.\\')\\n        {\\n            int idx = str[i] - \\'a\\';\\n            \\n            if(curr -> child[idx] == NULL)\\n            {\\n                return false;\\n            }\\n            \\n            return rec_search(str, i + 1, n, curr -> child[idx]);\\n        }\\n        \\n        else\\n        {   \\n            for(int j = 0; j < 26; j++)\\n            {\\n                if(curr -> child[j] != NULL)\\n                {\\n                    if(rec_search(str, i + 1, n, curr -> child[j]))\\n                        return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool search(string word) {\\n        \\n        int n = word.size();\\n        \\n        return rec_search(word, 0, n, root);\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass WordDictionary {\\npublic:\\n    WordDictionary() {\\n        \\n    }\\n    \\n    struct TrieNode\\n    {\\n        bool end;\\n        \\n        TrieNode* child[26];\\n        \\n        TrieNode()\\n        {\\n            end = false;\\n            \\n            for(int i = 0; i < 26; i++)\\n            {\\n                child[i] = NULL;\\n            }\\n        }\\n    };\\n    \\n    TrieNode* root = new TrieNode();\\n    \\n    void addWord(string word) {\\n        \\n        int n = word.size();\\n        \\n        TrieNode* curr = root;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int idx = word[i] - \\'a\\';\\n            \\n            if(curr -> child[idx] == NULL)\\n            {\\n                curr -> child[idx] = new TrieNode();\\n            }\\n            \\n            curr = curr -> child[idx];\\n        }\\n        \\n        curr -> end = true;\\n    }\\n    \\n    \\n    bool rec_search(string &str, int i, int n, TrieNode* curr) \\n    {\\n        if(i == n)\\n        {\\n            return curr -> end;\\n        }\\n        \\n        if(str[i] != \\'.\\')\\n        {\\n            int idx = str[i] - \\'a\\';\\n            \\n            if(curr -> child[idx] == NULL)\\n            {\\n                return false;\\n            }\\n            \\n            return rec_search(str, i + 1, n, curr -> child[idx]);\\n        }\\n        \\n        else\\n        {   \\n            for(int j = 0; j < 26; j++)\\n            {\\n                if(curr -> child[j] != NULL)\\n                {\\n                    if(rec_search(str, i + 1, n, curr -> child[j]))\\n                        return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool search(string word) {\\n        \\n        int n = word.size();\\n        \\n        return rec_search(word, 0, n, root);\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065090,
                "title": "go-trie-clear-solution",
                "content": "```\\ntype WordDictionary struct {\\n    nodes       map[rune]*WordDictionary\\n    endOfWord   bool\\n}\\n\\nfunc Constructor() WordDictionary {\\n    return WordDictionary{make(map[rune]*WordDictionary), false}\\n}\\n\\nfunc (d *WordDictionary) AddWord(word string) {\\n    for _, r := range word {\\n        if _, found := d.nodes[r]; !found { node := Constructor(); d.nodes[r] = &node }\\n        d = d.nodes[r]\\n    }\\n    d.endOfWord = true\\n}\\n\\n\\nfunc (d *WordDictionary) Search(word string) bool {\\n    for i, r := range word {\\n        if _, found := d.nodes[r]; !found {\\n            if r != \\'.\\' { return false }\\n            for _, node := range d.nodes {\\n                if node.Search(word[i+1:]) { return true }\\n            }\\n            return false\\n        }\\n        d = d.nodes[r]\\n    }\\n    return d.endOfWord\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Trie"
                ],
                "code": "```\\ntype WordDictionary struct {\\n    nodes       map[rune]*WordDictionary\\n    endOfWord   bool\\n}\\n\\nfunc Constructor() WordDictionary {\\n    return WordDictionary{make(map[rune]*WordDictionary), false}\\n}\\n\\nfunc (d *WordDictionary) AddWord(word string) {\\n    for _, r := range word {\\n        if _, found := d.nodes[r]; !found { node := Constructor(); d.nodes[r] = &node }\\n        d = d.nodes[r]\\n    }\\n    d.endOfWord = true\\n}\\n\\n\\nfunc (d *WordDictionary) Search(word string) bool {\\n    for i, r := range word {\\n        if _, found := d.nodes[r]; !found {\\n            if r != \\'.\\' { return false }\\n            for _, node := range d.nodes {\\n                if node.Search(word[i+1:]) { return true }\\n            }\\n            return false\\n        }\\n        d = d.nodes[r]\\n    }\\n    return d.endOfWord\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1726057,
                "title": "c-simple-and-clean-trie-solution",
                "content": "```\\nclass WordDictionary {\\npublic:\\n\\n    /** Initialize your data structure here. */\\n    WordDictionary() {\\n        this->is_leaf = false;\\n        for(int i=0; i<26; i++)\\n            this->children[i] = NULL;\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        WordDictionary* root = this;\\n        for (int i=0;i<word.length();i++)\\n        {\\n            int index = word[i] - \\'a\\';\\n            if (root->children[index] == NULL)\\n                root->children[index] = new WordDictionary();\\n            root = root->children[index];\\n        }\\n        root->is_leaf = true;\\n    }\\n    \\n   \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word) {\\n        return helper(word, this);\\n    }\\n    \\n    \\nprivate:\\n    bool is_leaf;\\n    WordDictionary* children[26];\\n    \\n    bool helper(string subword, WordDictionary* ptr)\\n    {\\n        for(int i=0;i<subword.length();i++)\\n        {\\n            if (subword[i] == \\'.\\')\\n            {\\n                for (int j=0;j<26;j++)\\n                {\\n                    if(ptr->children[j]) {\\n                        if (helper(subword.substr(i+1), ptr->children[j]))\\n                            return true;\\n                    }\\n                }\\n\\n            }\\n            else\\n            {\\n                int index = subword[i] - \\'a\\';\\n                if (!ptr->children[index])\\n                    return false;\\n                ptr = ptr->children[index];\\n                continue;\\n            }\\n            return false;\\n        }\\n        if (ptr->is_leaf)\\n            return true;\\n        return false;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass WordDictionary {\\npublic:\\n\\n    /** Initialize your data structure here. */\\n    WordDictionary() {\\n        this->is_leaf = false;\\n        for(int i=0; i<26; i++)\\n            this->children[i] = NULL;\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        WordDictionary* root = this;\\n        for (int i=0;i<word.length();i++)\\n        {\\n            int index = word[i] - \\'a\\';\\n            if (root->children[index] == NULL)\\n                root->children[index] = new WordDictionary();\\n            root = root->children[index];\\n        }\\n        root->is_leaf = true;\\n    }\\n    \\n   \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool search(string word) {\\n        return helper(word, this);\\n    }\\n    \\n    \\nprivate:\\n    bool is_leaf;\\n    WordDictionary* children[26];\\n    \\n    bool helper(string subword, WordDictionary* ptr)\\n    {\\n        for(int i=0;i<subword.length();i++)\\n        {\\n            if (subword[i] == \\'.\\')\\n            {\\n                for (int j=0;j<26;j++)\\n                {\\n                    if(ptr->children[j]) {\\n                        if (helper(subword.substr(i+1), ptr->children[j]))\\n                            return true;\\n                    }\\n                }\\n\\n            }\\n            else\\n            {\\n                int index = subword[i] - \\'a\\';\\n                if (!ptr->children[index])\\n                    return false;\\n                ptr = ptr->children[index];\\n                continue;\\n            }\\n            return false;\\n        }\\n        if (ptr->is_leaf)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725228,
                "title": "simple-solution-using-hashmaps-explained",
                "content": "## Intuition\\n- We maintain a hashmap with a key of integers that represent the word size\\n- Corrosponding to each word size we store a ```vector of strings ``` of that size\\n- So whenever, the search function is called we find the words of a given word size and then match each one of them\\n- The matching is perfomed by matching each letter of each word, if the letter is a ```.``` we just continue\\n- The searching can be further improved via a trie.\\n\\n\\n```cpp\\nclass WordDictionary {\\npublic:\\n    \\n    unordered_map <int, vector <string> > umap;\\n    \\n    bool dotMatch( string & str, string & dotted){\\n        \\n        for( int i = 0 ; i < dotted.size() ; i++ ){\\n            if(dotted[i] == \\'.\\' ) continue;\\n            if( dotted[i] != str[i] ) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    WordDictionary() {\\n        \\n    }\\n    \\n    void addWord(string word) {\\n        \\n        umap[word.size()].push_back(word);\\n        \\n    }\\n    \\n    bool search(string word) {\\n        \\n        if( umap.find(word.size()) == umap.end()) return false;\\n        auto storedWords = umap[word.size()];\\n        \\n        for( auto it: storedWords){\\n            if (dotMatch(it,word) ) return true;\\n        }\\n        \\n        return false;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```vector of strings ```\n```.```\n```cpp\\nclass WordDictionary {\\npublic:\\n    \\n    unordered_map <int, vector <string> > umap;\\n    \\n    bool dotMatch( string & str, string & dotted){\\n        \\n        for( int i = 0 ; i < dotted.size() ; i++ ){\\n            if(dotted[i] == \\'.\\' ) continue;\\n            if( dotted[i] != str[i] ) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    WordDictionary() {\\n        \\n    }\\n    \\n    void addWord(string word) {\\n        \\n        umap[word.size()].push_back(word);\\n        \\n    }\\n    \\n    bool search(string word) {\\n        \\n        if( umap.find(word.size()) == umap.end()) return false;\\n        auto storedWords = umap[word.size()];\\n        \\n        for( auto it: storedWords){\\n            if (dotMatch(it,word) ) return true;\\n        }\\n        \\n        return false;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651974,
                "title": "java-simple-trie-tree-solution-100",
                "content": "```java\\nclass WordDictionary {\\n    private TrieNode root;\\n    \\n    public WordDictionary() {\\n        this.root = new TrieNode();\\n    }\\n    \\n    public void addWord(String word) {\\n        TrieNode currentNode = this.root;\\n        \\n        for(int i = 0; i < word.length(); ++i) {\\n            if(currentNode.children[word.charAt(i) - \\'a\\'] == null)\\n                currentNode.children[word.charAt(i) - \\'a\\'] = new TrieNode();\\n            currentNode = currentNode.children[word.charAt(i) - \\'a\\'];\\n        }\\n        currentNode.isWord = true;\\n    }\\n    \\n    public boolean search(String word) {\\n        return searchHelper(word, this.root, 0);\\n    }\\n    \\n    public boolean searchHelper(String word, TrieNode node, int index) {\\n        if(node == null)\\n            return false;\\n        \\n        if(index == word.length())\\n            return node.isWord;\\n        \\n        if(word.charAt(index) != \\'.\\' && node.children[word.charAt(index) - \\'a\\'] != null)\\n            return searchHelper(word, node.children[word.charAt(index) - \\'a\\'], index + 1);\\n        \\n        if(word.charAt(index) == \\'.\\')\\n            for(int i = 0; i < 26; ++i)\\n\\t\\t\\t\\tif(searchHelper(word, node.children[i], index + 1))\\n\\t\\t\\t\\t\\treturn true;\\n        \\n        return false;\\n    }\\n    \\n    private class TrieNode {\\n        public TrieNode[] children = new TrieNode[26];\\n        public boolean isWord;\\n        \\n        public TrieNode() {}\\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */\\n```",
                "solutionTags": [],
                "code": "```java\\nclass WordDictionary {\\n    private TrieNode root;\\n    \\n    public WordDictionary() {\\n        this.root = new TrieNode();\\n    }\\n    \\n    public void addWord(String word) {\\n        TrieNode currentNode = this.root;\\n        \\n        for(int i = 0; i < word.length(); ++i) {\\n            if(currentNode.children[word.charAt(i) - \\'a\\'] == null)\\n                currentNode.children[word.charAt(i) - \\'a\\'] = new TrieNode();\\n            currentNode = currentNode.children[word.charAt(i) - \\'a\\'];\\n        }\\n        currentNode.isWord = true;\\n    }\\n    \\n    public boolean search(String word) {\\n        return searchHelper(word, this.root, 0);\\n    }\\n    \\n    public boolean searchHelper(String word, TrieNode node, int index) {\\n        if(node == null)\\n            return false;\\n        \\n        if(index == word.length())\\n            return node.isWord;\\n        \\n        if(word.charAt(index) != \\'.\\' && node.children[word.charAt(index) - \\'a\\'] != null)\\n            return searchHelper(word, node.children[word.charAt(index) - \\'a\\'], index + 1);\\n        \\n        if(word.charAt(index) == \\'.\\')\\n            for(int i = 0; i < 26; ++i)\\n\\t\\t\\t\\tif(searchHelper(word, node.children[i], index + 1))\\n\\t\\t\\t\\t\\treturn true;\\n        \\n        return false;\\n    }\\n    \\n    private class TrieNode {\\n        public TrieNode[] children = new TrieNode[26];\\n        public boolean isWord;\\n        \\n        public TrieNode() {}\\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114680,
                "title": "faster-than-99-23-of-python3-online-submissions-for-design-add-and-search-words-data-structure",
                "content": "```python\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.trie = {}\\n\\n    def addWord(self, word: str) -> None:\\n        cur = self.trie\\n        for w in word:\\n            if w not in cur:\\n                cur[w] = {}\\n            cur = cur[w]\\n        cur[\"#\"] = {}\\n\\n    def search(self, word) -> bool:\\n        def _search(word, trie):\\n            if not word:\\n                return \"#\" in trie\\n\\n            if word[0] == \".\":\\n                return any(_search(word[1:], v) for v in trie.values())\\n            if word[0] not in trie:\\n                return False\\n            return _search(word[1:], trie[word[0]])\\n\\n        return _search(word, self.trie) \\n\\n# Your WordDictionary object will be instantiated and called as such:\\n# obj = WordDictionary()\\n# obj.addWord(word)\\n# param_2 = obj.search(word)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```python\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.trie = {}\\n\\n    def addWord(self, word: str) -> None:\\n        cur = self.trie\\n        for w in word:\\n            if w not in cur:\\n                cur[w] = {}\\n            cur = cur[w]\\n        cur[\"#\"] = {}\\n\\n    def search(self, word) -> bool:\\n        def _search(word, trie):\\n            if not word:\\n                return \"#\" in trie\\n\\n            if word[0] == \".\":\\n                return any(_search(word[1:], v) for v in trie.values())\\n            if word[0] not in trie:\\n                return False\\n            return _search(word[1:], trie[word[0]])\\n\\n        return _search(word, self.trie) \\n\\n# Your WordDictionary object will be instantiated and called as such:\\n# obj = WordDictionary()\\n# obj.addWord(word)\\n# param_2 = obj.search(word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1040326,
                "title": "kotlin-trie",
                "content": "Trie implementation. Checking all nodes if the current character is `.`...\\n\\n```\\nclass WordDictionary() {\\n    data class TrieNode(var isLeaf: Boolean = false, val children: MutableMap<Char, TrieNode> = mutableMapOf())\\n\\n    val root = TrieNode()\\n\\n    fun addWord(word: String) {\\n        var current = root\\n        for (c in word) {\\n            current = current.children.getOrPut(c) { TrieNode() }\\n        }\\n        current.isLeaf = true\\n    }\\n\\n    fun search(word: String): Boolean {\\n        var candidates = listOf(root)\\n        for (c in word) {\\n            candidates = when (c) {\\n                \\'.\\' -> candidates.flatMap { it.children.values }\\n                else -> candidates.mapNotNull { it.children[c] }\\n            }\\n            if (candidates.isEmpty()) return false\\n        }\\n        return candidates.any { it.isLeaf }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordDictionary() {\\n    data class TrieNode(var isLeaf: Boolean = false, val children: MutableMap<Char, TrieNode> = mutableMapOf())\\n\\n    val root = TrieNode()\\n\\n    fun addWord(word: String) {\\n        var current = root\\n        for (c in word) {\\n            current = current.children.getOrPut(c) { TrieNode() }\\n        }\\n        current.isLeaf = true\\n    }\\n\\n    fun search(word: String): Boolean {\\n        var candidates = listOf(root)\\n        for (c in word) {\\n            candidates = when (c) {\\n                \\'.\\' -> candidates.flatMap { it.children.values }\\n                else -> candidates.mapNotNull { it.children[c] }\\n            }\\n            if (candidates.isEmpty()) return false\\n        }\\n        return candidates.any { it.isLeaf }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011835,
                "title": "python-trie",
                "content": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.h = {}\\n        self.isTerminal=False\\n        self.val = val\\n        \\nclass WordDictionary(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.head = Node(None)\\n\\n    def addWord(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: None\\n        \"\"\"\\n        root = self.head\\n        for ch in word:\\n            if not ch in root.h:\\n                nn = Node(ch)\\n                root.h[ch] = nn\\n            root = root.h[ch]\\n        root.isTerminal = True\\n\\n    def search(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(root, word):\\n            for i, ch in enumerate(word):\\n                if ch==\".\":\\n                    for _ch in root.h:\\n                        if dfs(root.h[_ch], word[i+1:]):\\n                            return True                        \\n                if not ch in root.h:\\n                    return False\\n                root = root.h[ch]\\n            return root.isTerminal\\n        \\n        root = self.head\\n        return dfs(root, word)\\n\\n\\n# Your WordDictionary object will be instantiated and called as such:\\n# obj = WordDictionary()\\n# obj.addWord(word)\\n# param_2 = obj.search(word)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.h = {}\\n        self.isTerminal=False\\n        self.val = val\\n        \\nclass WordDictionary(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.head = Node(None)\\n\\n    def addWord(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: None\\n        \"\"\"\\n        root = self.head\\n        for ch in word:\\n            if not ch in root.h:\\n                nn = Node(ch)\\n                root.h[ch] = nn\\n            root = root.h[ch]\\n        root.isTerminal = True\\n\\n    def search(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(root, word):\\n            for i, ch in enumerate(word):\\n                if ch==\".\":\\n                    for _ch in root.h:\\n                        if dfs(root.h[_ch], word[i+1:]):\\n                            return True                        \\n                if not ch in root.h:\\n                    return False\\n                root = root.h[ch]\\n            return root.isTerminal\\n        \\n        root = self.head\\n        return dfs(root, word)\\n\\n\\n# Your WordDictionary object will be instantiated and called as such:\\n# obj = WordDictionary()\\n# obj.addWord(word)\\n# param_2 = obj.search(word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891015,
                "title": "c-faster-than-97-20-no-trie-using-only-unordered-map",
                "content": "```\\nclass WordDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<int,vector<string>>mp;\\n    WordDictionary() {\\n        mp.clear();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        mp[word.size()].push_back(word);\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool isSame(string str,string word)\\n    {\\n        if(str==word) return true;\\n        int n =word.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(word[i]==\\'.\\')\\n                continue;\\n            else if(word[i]!=str[i])\\n                return false;\\n            \\n        }\\n        return true;\\n        \\n    }\\n    bool search(string word) {\\n        int n=word.size();\\n        if(mp.find(n)!=mp.end())\\n        {\\n            auto temp=mp[n];\\n            for(auto str:temp)\\n            {\\n                if(isSame(str,word))\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else \\n            return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass WordDictionary {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<int,vector<string>>mp;\\n    WordDictionary() {\\n        mp.clear();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    void addWord(string word) {\\n        mp[word.size()].push_back(word);\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    bool isSame(string str,string word)\\n    {\\n        if(str==word) return true;\\n        int n =word.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(word[i]==\\'.\\')\\n                continue;\\n            else if(word[i]!=str[i])\\n                return false;\\n            \\n        }\\n        return true;\\n        \\n    }\\n    bool search(string word) {\\n        int n=word.size();\\n        if(mp.find(n)!=mp.end())\\n        {\\n            auto temp=mp[n];\\n            for(auto str:temp)\\n            {\\n                if(isSame(str,word))\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else \\n            return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882085,
                "title": "faster-improved-trie-self-explaining-code",
                "content": "```\\nclass WordDictionary: # iterative + recursive, best 140 ms, \\n    def __init__(self):\\n        self.root = {}\\n        self.wordLength = set()\\n\\n    def addWord(self, word: str) -> None:\\n        if len(word) not in self.wordLength:\\n            self.wordLength.add(len(word))\\n            \\n        curr = self.root\\n        for c in word:\\n            if c not in curr: curr[c] = {}\\n            curr = curr[c]\\n        curr[\\'#\\'] = word\\n\\n    def search(self, word):\\n        if len(word) not in self.wordLength: return False\\n        return self.__search(word, self.root)\\n\\n    def __search(self, word, curr):           \\n        for i, c in enumerate(word):\\n            if c == \\'.\\':\\n                if i == len(word) - 1:\\n                    for key in curr:\\n                        if \\'#\\' in curr[key]: return True\\n                    return False\\n                \\n                for key in curr:\\n                    if key is not \\'#\\':\\n                        if self.__search(word[i+1:], curr[key]):\\n                            return True\\n                return False\\n\\n            if c not in curr: return False\\n            curr = curr[c]\\n            \\n        return \\'#\\' in curr\\n```\\nWelcome suggestion, question, comments.\\nIf you think this post is helpful, ***please upvote. Thanks a lot.***",
                "solutionTags": [],
                "code": "```\\nclass WordDictionary: # iterative + recursive, best 140 ms, \\n    def __init__(self):\\n        self.root = {}\\n        self.wordLength = set()\\n\\n    def addWord(self, word: str) -> None:\\n        if len(word) not in self.wordLength:\\n            self.wordLength.add(len(word))\\n            \\n        curr = self.root\\n        for c in word:\\n            if c not in curr: curr[c] = {}\\n            curr = curr[c]\\n        curr[\\'#\\'] = word\\n\\n    def search(self, word):\\n        if len(word) not in self.wordLength: return False\\n        return self.__search(word, self.root)\\n\\n    def __search(self, word, curr):           \\n        for i, c in enumerate(word):\\n            if c == \\'.\\':\\n                if i == len(word) - 1:\\n                    for key in curr:\\n                        if \\'#\\' in curr[key]: return True\\n                    return False\\n                \\n                for key in curr:\\n                    if key is not \\'#\\':\\n                        if self.__search(word[i+1:], curr[key]):\\n                            return True\\n                return False\\n\\n            if c not in curr: return False\\n            curr = curr[c]\\n            \\n        return \\'#\\' in curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859584,
                "title": "light-and-clean-solution-in-c-simple-trie",
                "content": "```\\ntypedef struct trie_node {\\n    struct trie_node *sub_chars[26];\\n    bool EOW;\\n} WordDictionary;\\n\\n/** Initialize your data structure here. */\\n\\nWordDictionary* wordDictionaryCreate() {\\n    WordDictionary *obj = (WordDictionary*)calloc(1,sizeof(WordDictionary));\\n    return obj;\\n}\\n\\n/** Adds a word into the data structure. */\\nvoid wordDictionaryAddWord(WordDictionary* obj, char * word) {\\n  while((*word)) {\\n      if(obj->sub_chars[(*word)-\\'a\\']==NULL) {\\n          obj->sub_chars[(*word)-\\'a\\'] = (WordDictionary*)calloc(1,sizeof(WordDictionary));\\n      }\\n      obj = obj->sub_chars[(*word)-\\'a\\'];\\n      word++;\\n  }\\n    obj->EOW = true;\\n}\\n\\n/** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\nbool wordDictionarySearch(WordDictionary* obj, char * word) {\\n    while(*word) {\\n        if( (*word) ==\\'.\\') {\\n            for(int i =0;i<26;i++) {\\n                if(!obj->sub_chars[i]) continue;\\n                bool a = wordDictionarySearch(obj->sub_chars[i],word+1);\\n                if(a) return true;\\n            }\\n            return false;\\n        }\\n        else if(!obj->sub_chars[(*word)-\\'a\\']) return false;\\n        obj = obj->sub_chars[(*word)-\\'a\\'];\\n        word++;\\n    }\\n    if(obj->EOW)return true;\\n    else return false;\\n}\\n\\nvoid wordDictionaryFree(WordDictionary* obj) {\\n    //recursivly free the memory\\n    for(int i=0;i<26;i++) {\\n        if(!obj->sub_chars[i]) continue;\\n        wordDictionaryFree(obj->sub_chars[i]);\\n    }\\n    free(obj);\\n}\\n\\n/**\\n * Your WordDictionary struct will be instantiated and called as such:\\n * WordDictionary* obj = wordDictionaryCreate();\\n * wordDictionaryAddWord(obj, word);\\n \\n * bool param_2 = wordDictionarySearch(obj, word);\\n \\n * wordDictionaryFree(obj);\\n*/\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct trie_node {\\n    struct trie_node *sub_chars[26];\\n    bool EOW;\\n} WordDictionary;\\n\\n/** Initialize your data structure here. */\\n\\nWordDictionary* wordDictionaryCreate() {\\n    WordDictionary *obj = (WordDictionary*)calloc(1,sizeof(WordDictionary));\\n    return obj;\\n}\\n\\n/** Adds a word into the data structure. */\\nvoid wordDictionaryAddWord(WordDictionary* obj, char * word) {\\n  while((*word)) {\\n      if(obj->sub_chars[(*word)-\\'a\\']==NULL) {\\n          obj->sub_chars[(*word)-\\'a\\'] = (WordDictionary*)calloc(1,sizeof(WordDictionary));\\n      }\\n      obj = obj->sub_chars[(*word)-\\'a\\'];\\n      word++;\\n  }\\n    obj->EOW = true;\\n}\\n\\n/** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\nbool wordDictionarySearch(WordDictionary* obj, char * word) {\\n    while(*word) {\\n        if( (*word) ==\\'.\\') {\\n            for(int i =0;i<26;i++) {\\n                if(!obj->sub_chars[i]) continue;\\n                bool a = wordDictionarySearch(obj->sub_chars[i],word+1);\\n                if(a) return true;\\n            }\\n            return false;\\n        }\\n        else if(!obj->sub_chars[(*word)-\\'a\\']) return false;\\n        obj = obj->sub_chars[(*word)-\\'a\\'];\\n        word++;\\n    }\\n    if(obj->EOW)return true;\\n    else return false;\\n}\\n\\nvoid wordDictionaryFree(WordDictionary* obj) {\\n    //recursivly free the memory\\n    for(int i=0;i<26;i++) {\\n        if(!obj->sub_chars[i]) continue;\\n        wordDictionaryFree(obj->sub_chars[i]);\\n    }\\n    free(obj);\\n}\\n\\n/**\\n * Your WordDictionary struct will be instantiated and called as such:\\n * WordDictionary* obj = wordDictionaryCreate();\\n * wordDictionaryAddWord(obj, word);\\n \\n * bool param_2 = wordDictionarySearch(obj, word);\\n \\n * wordDictionaryFree(obj);\\n*/\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 774464,
                "title": "java-solution-using-hashmap",
                "content": "//class WordDictionary {\\n\\n    public class WordDictionary {\\n        Map<Integer, List<String>> mp=new HashMap<Integer, List<String>>();\\n    public void addWord(String word) {\\n        int idx=word.length();\\n        if(!mp.containsKey(idx)){\\n            List<String> lst=new ArrayList<String>();\\n            lst.add(word);\\n            mp.put(idx,lst);\\n        }\\n        else{\\n            mp.get(idx).add(word);\\n        }\\n    }   \\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public boolean search(String word) {\\n        int idx=word.length();\\n        if(!mp.containsKey(idx)){\\n            return false;\\n        }\\n        List<String> lst=mp.get(idx);\\n    if(iswrds(word)){\\n        return lst.contains(word);\\n    }\\n        for(String s: lst)\\n        {\\n            if(same(s,word)){\\n                return true;\\n            }\\n        }\\n        return false;\\n}\\n\\nboolean iswrds(String s){\\n        for(int e=0;e<s.length();e++)\\n        {\\n            if(!Character.isLetter(s.charAt(e)))\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    boolean same(String s, String b)\\n    {\\n        if(s.length()!=b.length()){\\n         return false;   \\n        }\\n        \\n        for(int e=0;e<s.length();e++)\\n        {\\n            if(b.charAt(e)!=\\'.\\' && s.charAt(e)!=b.charAt(e)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    }\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "//class WordDictionary {\\n\\n    public class WordDictionary {\\n        Map<Integer, List<String>> mp=new HashMap<Integer, List<String>>();\\n    public void addWord(String word) {\\n        int idx=word.length();\\n        if(!mp.containsKey(idx)){\\n            List<String> lst=new ArrayList<String>();\\n            lst.add(word);\\n            mp.put(idx,lst);\\n        }\\n        else{\\n            mp.get(idx).add(word);\\n        }\\n    }   \\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public boolean search(String word) {\\n        int idx=word.length();\\n        if(!mp.containsKey(idx)){\\n            return false;\\n        }\\n        List<String> lst=mp.get(idx);\\n    if(iswrds(word)){\\n        return lst.contains(word);\\n    }\\n        for(String s: lst)\\n        {\\n            if(same(s,word)){\\n                return true;\\n            }\\n        }\\n        return false;\\n}\\n\\nboolean iswrds(String s){\\n        for(int e=0;e<s.length();e++)\\n        {\\n            if(!Character.isLetter(s.charAt(e)))\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    boolean same(String s, String b)\\n    {\\n        if(s.length()!=b.length()){\\n         return false;   \\n        }\\n        \\n        for(int e=0;e<s.length();e++)\\n        {\\n            if(b.charAt(e)!=\\'.\\' && s.charAt(e)!=b.charAt(e)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    }\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 747746,
                "title": "c-using-map-beats-95-41-in-time-2-approach",
                "content": "**Approach - 1 : Use map for storage and retreival**\\n\\nThis is short and the complexity is good to be implemented.\\n```\\nclass WordDictionary {\\n    unordered_map<int,vector<string>>m;\\npublic:\\n    WordDictionary() {}\\n    \\n    void addWord(string word) {\\n        m[word.size()].push_back(word);\\n    }\\n\\n    bool search(string word) {\\n        for(auto x:m[word.size()])\\n        {\\n            bool flag=true;\\n            for(int i=0 ; i<word.size() ; i++)\\n            {\\n                if(word[i]==\\'.\\') continue;\\n                if(word[i] != x[i]) {flag=false;break;}\\n            }\\n            if(flag) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Approach - 2 : Use Trie data sructure**\\n\\n```\\nclass WordDictionary {\\n    struct TrieNode{\\n        vector<TrieNode*>children = vector<TrieNode*>(26,NULL);\\n        bool isWord=false;\\n    };\\n    TrieNode* root = new TrieNode;\\npublic:\\n    WordDictionary() {}\\n    \\n    void addWord(string word) {\\n        TrieNode* cur = root;\\n        for(auto x:word)\\n        {\\n            if(!cur->children[x-\\'a\\']) cur->children[x-\\'a\\'] = new TrieNode;\\n            cur = cur->children[x-\\'a\\'];\\n        }\\n        cur->isWord=true;\\n    }\\n    \\n    bool dfs(TrieNode* cur,int idx,string& word)     //dfs for searching the word in the prefix tree.\\n    {\\n        if(cur==NULL) return false;\\n        if(idx==word.length()) return cur->isWord;\\n        if(word[idx]==\\'.\\')                           //if a dot comes check if any of all possible alphabets can form the word or not. \\n        {\\n            for(int i=0 ; i<26 ; i++)\\n                if(cur->children[i] and dfs(cur->children[i],idx+1,word)) return true;\\n            return false;\\n        }\\n        else return dfs(cur->children[word[idx]-\\'a\\'],idx+1,word);\\n    }\\n    \\n    bool search(string word)\\n    {\\n        return dfs(root,0,word);\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordDictionary {\\n    unordered_map<int,vector<string>>m;\\npublic:\\n    WordDictionary() {}\\n    \\n    void addWord(string word) {\\n        m[word.size()].push_back(word);\\n    }\\n\\n    bool search(string word) {\\n        for(auto x:m[word.size()])\\n        {\\n            bool flag=true;\\n            for(int i=0 ; i<word.size() ; i++)\\n            {\\n                if(word[i]==\\'.\\') continue;\\n                if(word[i] != x[i]) {flag=false;break;}\\n            }\\n            if(flag) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass WordDictionary {\\n    struct TrieNode{\\n        vector<TrieNode*>children = vector<TrieNode*>(26,NULL);\\n        bool isWord=false;\\n    };\\n    TrieNode* root = new TrieNode;\\npublic:\\n    WordDictionary() {}\\n    \\n    void addWord(string word) {\\n        TrieNode* cur = root;\\n        for(auto x:word)\\n        {\\n            if(!cur->children[x-\\'a\\']) cur->children[x-\\'a\\'] = new TrieNode;\\n            cur = cur->children[x-\\'a\\'];\\n        }\\n        cur->isWord=true;\\n    }\\n    \\n    bool dfs(TrieNode* cur,int idx,string& word)     //dfs for searching the word in the prefix tree.\\n    {\\n        if(cur==NULL) return false;\\n        if(idx==word.length()) return cur->isWord;\\n        if(word[idx]==\\'.\\')                           //if a dot comes check if any of all possible alphabets can form the word or not. \\n        {\\n            for(int i=0 ; i<26 ; i++)\\n                if(cur->children[i] and dfs(cur->children[i],idx+1,word)) return true;\\n            return false;\\n        }\\n        else return dfs(cur->children[word[idx]-\\'a\\'],idx+1,word);\\n    }\\n    \\n    bool search(string word)\\n    {\\n        return dfs(root,0,word);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681589,
                "title": "java-solution-using-trie-dfs",
                "content": "```\\nclass WordDictionary {\\n    class Trie {\\n        Trie[] arr = new Trie[26];\\n        boolean isWord = false;\\n    }\\n    Trie root;\\n    public WordDictionary() {\\n        root = new Trie();\\n    }\\n   \\n    public void addWord(String word) {\\n        Trie cur = root;\\n        for (int i = 0; i < word.length(); i++) {\\n            char c = word.charAt(i);\\n            if (cur.arr[c - \\'a\\'] == null) cur.arr[c - \\'a\\'] = new Trie();\\n            cur = cur.arr[c - \\'a\\'];\\n        }\\n        cur.isWord = true;\\n    }\\n\\n    public boolean search(String word) {\\n        Trie cur = root;\\n        return helper(word, 0, cur);    \\n    }\\n    \\n    private boolean helper(String word, int i, Trie cur) {\\n        if (i == word.length()) return cur.isWord;\\n        \\n        char c = word.charAt(i);\\n        if (c == \\'.\\') {\\n            for (int j = 0; j < 26; j++) {\\n                if (cur.arr[j] != null && helper(word, i + 1, cur.arr[j])) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        if (cur.arr[c - \\'a\\'] == null) return false;\\n        return helper(word, i + 1, cur.arr[c - \\'a\\']);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordDictionary {\\n    class Trie {\\n        Trie[] arr = new Trie[26];\\n        boolean isWord = false;\\n    }\\n    Trie root;\\n    public WordDictionary() {\\n        root = new Trie();\\n    }\\n   \\n    public void addWord(String word) {\\n        Trie cur = root;\\n        for (int i = 0; i < word.length(); i++) {\\n            char c = word.charAt(i);\\n            if (cur.arr[c - \\'a\\'] == null) cur.arr[c - \\'a\\'] = new Trie();\\n            cur = cur.arr[c - \\'a\\'];\\n        }\\n        cur.isWord = true;\\n    }\\n\\n    public boolean search(String word) {\\n        Trie cur = root;\\n        return helper(word, 0, cur);    \\n    }\\n    \\n    private boolean helper(String word, int i, Trie cur) {\\n        if (i == word.length()) return cur.isWord;\\n        \\n        char c = word.charAt(i);\\n        if (c == \\'.\\') {\\n            for (int j = 0; j < 26; j++) {\\n                if (cur.arr[j] != null && helper(word, i + 1, cur.arr[j])) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        if (cur.arr[c - \\'a\\'] == null) return false;\\n        return helper(word, i + 1, cur.arr[c - \\'a\\']);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502505,
                "title": "python-trie-stack-dfs-solution",
                "content": "```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.trie = {}\\n\\n    def addWord(self, word: str) -> None:\\n        \"\"\"\\n        Adds a word into the data structure.\\n        \"\"\"\\n        cur_node = self.trie\\n        for char in word:\\n            if not char in cur_node:\\n                cur_node[char] = {}\\n            cur_node = cur_node[char]\\n        cur_node[\"*\"] = {}\\n        \\n\\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        \"\"\"\\n        stack = [(self.trie, 0)]\\n        while stack:\\n            cur_node, index = stack.pop()\\n            if index == len(word):\\n                if \"*\" in cur_node:\\n                    return True\\n            else:\\n                if word[index] in cur_node:\\n                    stack.append((cur_node[word[index]], index+1))\\n                elif word[index] == \".\":\\n                    for child in cur_node:\\n                        if child != \"*\":\\n                            stack.append((cur_node[child], index+1))\\n        return False\\n```",
                "solutionTags": [
                    "Stack",
                    "Trie"
                ],
                "code": "```\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.trie = {}\\n\\n    def addWord(self, word: str) -> None:\\n        \"\"\"\\n        Adds a word into the data structure.\\n        \"\"\"\\n        cur_node = self.trie\\n        for char in word:\\n            if not char in cur_node:\\n                cur_node[char] = {}\\n            cur_node = cur_node[char]\\n        cur_node[\"*\"] = {}\\n        \\n\\n    def search(self, word: str) -> bool:\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        \"\"\"\\n        stack = [(self.trie, 0)]\\n        while stack:\\n            cur_node, index = stack.pop()\\n            if index == len(word):\\n                if \"*\" in cur_node:\\n                    return True\\n            else:\\n                if word[index] in cur_node:\\n                    stack.append((cur_node[word[index]], index+1))\\n                elif word[index] == \".\":\\n                    for child in cur_node:\\n                        if child != \"*\":\\n                            stack.append((cur_node[child], index+1))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453510,
                "title": "java-trie-solution-easy-to-understand",
                "content": "Use a TrieNode class to represent Trie node. Do the addWord operation on the trie. Checkout the information about Trie in the following video. Here I use an array rather than a hashmap because in this question array can be more efficient.\\n\\n**Reference:** https://www.youtube.com/watch?v=-urNrIAQnNo&t=40s\\n\\n```java\\nclass TrieNode {\\n\\tTrieNode[] children = null;\\n\\tboolean endOfWord;\\n\\n\\tpublic TrieNode() {\\n\\t\\tthis.children = new TrieNode[26];\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tthis.children[i] = null;\\n\\t\\t}\\n\\t\\tthis.endOfWord = false;\\n\\t}\\n}\\n\\n\\nclass WordDictionary {\\n\\tTrieNode root = null;\\n\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        this.root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n        TrieNode currNode = this.root;\\n\\n        for (int i = 0; i < word.length(); i++) {\\n        \\tchar c = word.charAt(i);\\n        \\tif (currNode.children[c - \\'a\\'] == null) {\\n        \\t\\tcurrNode.children[c - \\'a\\'] = new TrieNode();\\n        \\t}\\n\\n        \\tcurrNode = currNode.children[c - \\'a\\'];\\n        }\\n\\n        currNode.endOfWord = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public boolean search(String word) {\\n\\n        return this.searchHelper(this.root, word, 0);\\n    }\\n\\n    private boolean searchHelper(TrieNode currNode, String word, int index) {\\n        if (index == word.length())\\n            return currNode.endOfWord;\\n        \\n\\n        char c = word.charAt(index);\\n\\n        if (c == \\'.\\') {\\n            for (int i = 0; i < 26; i++) {\\n                if (currNode.children[i] != null && this.searchHelper(currNode.children[i], word, index + 1)) {\\n                    return true;\\n                }\\n            }\\n\\n            return false;\\n        } else if (currNode.children[c - \\'a\\'] != null) {\\n            return this.searchHelper(currNode.children[c - \\'a\\'], word, index + 1);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass TrieNode {\\n\\tTrieNode[] children = null;\\n\\tboolean endOfWord;\\n\\n\\tpublic TrieNode() {\\n\\t\\tthis.children = new TrieNode[26];\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tthis.children[i] = null;\\n\\t\\t}\\n\\t\\tthis.endOfWord = false;\\n\\t}\\n}\\n\\n\\nclass WordDictionary {\\n\\tTrieNode root = null;\\n\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        this.root = new TrieNode();\\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n        TrieNode currNode = this.root;\\n\\n        for (int i = 0; i < word.length(); i++) {\\n        \\tchar c = word.charAt(i);\\n        \\tif (currNode.children[c - \\'a\\'] == null) {\\n        \\t\\tcurrNode.children[c - \\'a\\'] = new TrieNode();\\n        \\t}\\n\\n        \\tcurrNode = currNode.children[c - \\'a\\'];\\n        }\\n\\n        currNode.endOfWord = true;\\n    }\\n    \\n    /** Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter. */\\n    public boolean search(String word) {\\n\\n        return this.searchHelper(this.root, word, 0);\\n    }\\n\\n    private boolean searchHelper(TrieNode currNode, String word, int index) {\\n        if (index == word.length())\\n            return currNode.endOfWord;\\n        \\n\\n        char c = word.charAt(index);\\n\\n        if (c == \\'.\\') {\\n            for (int i = 0; i < 26; i++) {\\n                if (currNode.children[i] != null && this.searchHelper(currNode.children[i], word, index + 1)) {\\n                    return true;\\n                }\\n            }\\n\\n            return false;\\n        } else if (currNode.children[c - \\'a\\'] != null) {\\n            return this.searchHelper(currNode.children[c - \\'a\\'], word, index + 1);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393432,
                "title": "python-trie-solution-with-dfs",
                "content": "```\\nclass TrieNode(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n        \\nclass WordDictionary(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n        \\n\\n    def addWord(self, word):\\n        \"\"\"\\n        Adds a word into the data structure.\\n        :type word: str\\n        :rtype: None\\n        \"\"\"\\n        node = self.root\\n        for w in word:\\n            if w not in node.children:\\n                node.children[w] = TrieNode()\\n            node = node.children[w]\\n        node.isEnd = True\\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        :type word: str\\n        :rtype: bool\\n         \"\"\"\\n        return self.dfs(word, self.root)\\n        \\n    def dfs(self, word, root):\\n        if len(word) == 0:\\n            return root.isEnd\\n        if word[0] == \".\":\\n            for _, node in root.children.items():\\n                if node is not None and self.dfs(word[1:], node):\\n                    return True\\n        elif word[0] not in root.children:\\n            return False\\n        else:\\n            return self.dfs(word[1:], root.children[word[0]])\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.isEnd = False\\n        \\nclass WordDictionary(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n        \\n\\n    def addWord(self, word):\\n        \"\"\"\\n        Adds a word into the data structure.\\n        :type word: str\\n        :rtype: None\\n        \"\"\"\\n        node = self.root\\n        for w in word:\\n            if w not in node.children:\\n                node.children[w] = TrieNode()\\n            node = node.children[w]\\n        node.isEnd = True\\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        :type word: str\\n        :rtype: bool\\n         \"\"\"\\n        return self.dfs(word, self.root)\\n        \\n    def dfs(self, word, root):\\n        if len(word) == 0:\\n            return root.isEnd\\n        if word[0] == \".\":\\n            for _, node in root.children.items():\\n                if node is not None and self.dfs(word[1:], node):\\n                    return True\\n        elif word[0] not in root.children:\\n            return False\\n        else:\\n            return self.dfs(word[1:], root.children[word[0]])\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386624,
                "title": "java-dfs-reduce-levels-of-recursion",
                "content": "```\\nclass WordDictionary {\\n    class TrieNode{\\n        TrieNode[] children = new TrieNode[26];\\n        String word;\\n    }\\n    private TrieNode root;\\n\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        root = new TrieNode();        \\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n        TrieNode cur = root;\\n        for(char c: word.toCharArray()){\\n            if(cur.children[c - \\'a\\'] == null)\\n                cur.children[c - \\'a\\'] = new TrieNode();\\n            cur = cur.children[c - \\'a\\'];\\n        }\\n        cur.word = word;        \\n    }\\n    \\n\\n    public boolean search(String word) {\\n        return search(word.toCharArray(), 0, root);                     \\n    }\\n    \\n    public boolean search(char[] word, int i, TrieNode cur) {\\n        if(i == word.length)\\n            return cur.word != null;\\n        while(i < word.length && word[i] != \\'.\\'){\\n            if(cur.children[word[i] - \\'a\\'] == null)\\n                return false;\\n            cur = cur.children[word[i] - \\'a\\'];\\n            i++;\\n        }\\n        if(i == word.length)\\n            return cur.word != null;\\n        else{\\n            for(int j = 0; j < cur.children.length; j++){\\n                if(cur.children[j] != null)\\n                    if(search(word, i + 1, cur.children[j]))\\n                        return true;\\n            }\\n            return false;\\n        }                      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordDictionary {\\n    class TrieNode{\\n        TrieNode[] children = new TrieNode[26];\\n        String word;\\n    }\\n    private TrieNode root;\\n\\n    /** Initialize your data structure here. */\\n    public WordDictionary() {\\n        root = new TrieNode();        \\n    }\\n    \\n    /** Adds a word into the data structure. */\\n    public void addWord(String word) {\\n        TrieNode cur = root;\\n        for(char c: word.toCharArray()){\\n            if(cur.children[c - \\'a\\'] == null)\\n                cur.children[c - \\'a\\'] = new TrieNode();\\n            cur = cur.children[c - \\'a\\'];\\n        }\\n        cur.word = word;        \\n    }\\n    \\n\\n    public boolean search(String word) {\\n        return search(word.toCharArray(), 0, root);                     \\n    }\\n    \\n    public boolean search(char[] word, int i, TrieNode cur) {\\n        if(i == word.length)\\n            return cur.word != null;\\n        while(i < word.length && word[i] != \\'.\\'){\\n            if(cur.children[word[i] - \\'a\\'] == null)\\n                return false;\\n            cur = cur.children[word[i] - \\'a\\'];\\n            i++;\\n        }\\n        if(i == word.length)\\n            return cur.word != null;\\n        else{\\n            for(int j = 0; j < cur.children.length; j++){\\n                if(cur.children[j] != null)\\n                    if(search(word, i + 1, cur.children[j]))\\n                        return true;\\n            }\\n            return false;\\n        }                      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346809,
                "title": "python-trie-solution",
                "content": "```python\\nclass Trie:\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n        \\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.root = Trie()\\n\\n    def addWord(self, word: \\'str\\') -> \\'None\\':\\n        p = self.root\\n        for c in word:\\n            if c not in p.children: p.children[c] = Trie()\\n            p = p.children[c]\\n        p.end = True\\n\\n    def search(self, word: \\'str\\') -> \\'bool\\':\\n        def judge(word, node):\\n            if not word: return node.end\\n            cur = node\\n            for i in range(len(word)):\\n                c = word[i]\\n                if c != \\'.\\':\\n                    if c not in cur.children: return False\\n                    cur = cur.children[c]\\n                else:\\n                    for nxt in cur.children.values():\\n                        if judge(word[i+1:], nxt): return True\\n                    return False\\n            return cur.end\\n        return judge(word, self.root)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Trie:\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n        \\nclass WordDictionary:\\n\\n    def __init__(self):\\n        self.root = Trie()\\n\\n    def addWord(self, word: \\'str\\') -> \\'None\\':\\n        p = self.root\\n        for c in word:\\n            if c not in p.children: p.children[c] = Trie()\\n            p = p.children[c]\\n        p.end = True\\n\\n    def search(self, word: \\'str\\') -> \\'bool\\':\\n        def judge(word, node):\\n            if not word: return node.end\\n            cur = node\\n            for i in range(len(word)):\\n                c = word[i]\\n                if c != \\'.\\':\\n                    if c not in cur.children: return False\\n                    cur = cur.children[c]\\n                else:\\n                    for nxt in cur.children.values():\\n                        if judge(word[i+1:], nxt): return True\\n                    return False\\n            return cur.end\\n        return judge(word, self.root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 122470,
                "title": "python-with-trie-recursive-solution",
                "content": "```\\nfrom collections import defaultdict\\nclass TrieNode:\\n    def __init__(self):\\n        self.child = defaultdict(TrieNode)\\n        self.isword = False\\n    \\nclass WordDictionary:\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n\\n    def addWord(self, word):\\n        \"\"\"\\n        Adds a word into the data structure.\\n        :type word: str\\n        :rtype: void\\n        \"\"\"\\n        cur = self.root\\n        for l in word:\\n            cur = cur.child[l]\\n        cur.isword = True\\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        cur = self.root\\n        for i,l in enumerate(word):\\n            if l == \\'.\\':\\n                for k in cur.child:\\n                    #make a new trie tree with root child[k]\\n                    chdTrie = WordDictionary()\\n                    chdTrie.root = cur.child[k]\\n                    if chdTrie.search(word[i+1:]):\\n                        return True\\n                return False\\n            elif l not in cur.child:\\n                return False\\n            cur = cur.child[l]\\n        return cur.isword\\n```\\nThe only thing I change from basic implementation of trie is recursive call when the letter is \\'.\\'. Start search with a new tire Tree with root equal to one of the child node and search the rest part of work.",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass TrieNode:\\n    def __init__(self):\\n        self.child = defaultdict(TrieNode)\\n        self.isword = False\\n    \\nclass WordDictionary:\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.root = TrieNode()\\n\\n    def addWord(self, word):\\n        \"\"\"\\n        Adds a word into the data structure.\\n        :type word: str\\n        :rtype: void\\n        \"\"\"\\n        cur = self.root\\n        for l in word:\\n            cur = cur.child[l]\\n        cur.isword = True\\n\\n    def search(self, word):\\n        \"\"\"\\n        Returns if the word is in the data structure. A word could contain the dot character \\'.\\' to represent any one letter.\\n        :type word: str\\n        :rtype: bool\\n        \"\"\"\\n        cur = self.root\\n        for i,l in enumerate(word):\\n            if l == \\'.\\':\\n                for k in cur.child:\\n                    #make a new trie tree with root child[k]\\n                    chdTrie = WordDictionary()\\n                    chdTrie.root = cur.child[k]\\n                    if chdTrie.search(word[i+1:]):\\n                        return True\\n                return False\\n            elif l not in cur.child:\\n                return False\\n            cur = cur.child[l]\\n        return cur.isword\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59617,
                "title": "python-solution-with-trie",
                "content": "```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.is_leaf = False\\n\\nclass WordDictionary(object):\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def addWord(self, word):\\n        curr = self.root\\n        for char in word:\\n            curr = curr.children[char]\\n        curr.is_leaf = True\\n\\n    def search(self, word):\\n        return self.helper(word, self.root)\\n        \\n    def helper(self, word, node):\\n        if len(word) == 0:\\n            return node.is_leaf\\n        first = word[0]\\n        if first == \".\":\\n            for key in node.children:\\n                # return true if any was true\\n                if self.helper(word[1:], node.children[key]):\\n                    return True\\n        else:\\n            if first not in node.children:\\n                return False\\n            return self.helper(word[1:], node.children[first])\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.is_leaf = False\\n\\nclass WordDictionary(object):\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def addWord(self, word):\\n        curr = self.root\\n        for char in word:\\n            curr = curr.children[char]\\n        curr.is_leaf = True\\n\\n    def search(self, word):\\n        return self.helper(word, self.root)\\n        \\n    def helper(self, word, node):\\n        if len(word) == 0:\\n            return node.is_leaf\\n        first = word[0]\\n        if first == \".\":\\n            for key in node.children:\\n                # return true if any was true\\n                if self.helper(word[1:], node.children[key]):\\n                    return True\\n        else:\\n            if first not in node.children:\\n                return False\\n            return self.helper(word[1:], node.children[first])\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59646,
                "title": "trie-based-java-22ms",
                "content": "```\\npublic class WordDictionary {\\n\\n    private class WordNode {\\n        boolean isLeaf = false;\\n        WordNode[] children = new WordNode[26];\\n    }\\n\\n    private WordNode root = new WordNode();\\n\\n    // Adds a word into the data structure.\\n    public void addWord(String word) {\\n        WordNode node = root;\\n        for (int i = 0; i < word.length(); i++) {\\n            char c = word.charAt(i);\\n            if (node.children[c - 'a'] == null) {\\n                node.children[c - 'a'] = new WordNode();\\n            }\\n            node = node.children[c - 'a'];\\n        }\\n        node.isLeaf = true;\\n    }\\n\\n    // Returns if the word is in the data structure. A word could\\n    // contain the dot character '.' to represent any one letter.\\n    public boolean search(String word) {\\n        return search(word, 0, root);\\n    }\\n\\n    private boolean search(String word, int index, WordNode node) {\\n        if (index == word.length()) {\\n            return node.isLeaf;\\n        }\\n\\n        for (int i = index; i < word.length(); i++) {\\n            char c = word.charAt(i);\\n            if (c == '.') {\\n                for (WordNode child : node.children) {\\n                    if (child != null) {\\n                        if (search(word, i + 1, child)) {\\n                            return true;\\n                        }\\n                    }\\n                }\\n                return false;\\n            } else {\\n                if (node.children[c - 'a'] == null) {\\n                    return false;\\n                }\\n                node = node.children[c - 'a'];\\n            }\\n        }\\n\\n        return node.isLeaf;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class WordDictionary {\\n\\n    private class WordNode {\\n        boolean isLeaf = false;\\n        WordNode[] children = new WordNode[26];\\n    }\\n\\n    private WordNode root = new WordNode();\\n\\n    // Adds a word into the data structure.\\n    public void addWord(String word) {\\n        WordNode node = root;\\n        for (int i = 0; i < word.length(); i++) {\\n            char c = word.charAt(i);\\n            if (node.children[c - 'a'] == null) {\\n                node.children[c - 'a'] = new WordNode();\\n            }\\n            node = node.children[c - 'a'];\\n        }\\n        node.isLeaf = true;\\n    }\\n\\n    // Returns if the word is in the data structure. A word could\\n    // contain the dot character '.' to represent any one letter.\\n    public boolean search(String word) {\\n        return search(word, 0, root);\\n    }\\n\\n    private boolean search(String word, int index, WordNode node) {\\n        if (index == word.length()) {\\n            return node.isLeaf;\\n        }\\n\\n        for (int i = index; i < word.length(); i++) {\\n            char c = word.charAt(i);\\n            if (c == '.') {\\n                for (WordNode child : node.children) {\\n                    if (child != null) {\\n                        if (search(word, i + 1, child)) {\\n                            return true;\\n                        }\\n                    }\\n                }\\n                return false;\\n            } else {\\n                if (node.children[c - 'a'] == null) {\\n                    return false;\\n                }\\n                node = node.children[c - 'a'];\\n            }\\n        }\\n\\n        return node.isLeaf;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 59709,
                "title": "accepted-concise-python-solution-based-on-trie",
                "content": "    class WordDictionary(object):\\n        def __init__(self):\\n            self.chars = {}  #each char is the key and each key has a dict as its value\\n    \\n        def addWord(self, word):\\n            curr = self.chars\\n            for c in word:\\n                if c not in curr:\\n                    curr[c] = {}\\n                curr = curr[c]\\n            curr['#'] = {}  #indicate the end of a word\\n    \\n    \\n        def search(self, word):\\n            return self.search_dfs(word, self.chars)\\n            \\n            \\n        def search_dfs(self, word, curr):\\n            if len(word)==0:\\n                return '#' in curr\\n            c = word[0]\\n            if c == '.':\\n                for char in curr:\\n                    if self.search_dfs(word[1:], curr[char]):\\n                        return True\\n                return False\\n            # now c is a-z\\n            if c in curr:\\n                return self.search_dfs(word[1:], curr[c])\\n            return False",
                "solutionTags": [],
                "code": "    class WordDictionary(object):\\n        def __init__(self):\\n            self.chars = {}  #each char is the key and each key has a dict as its value\\n    \\n        def addWord(self, word):\\n            curr = self.chars\\n            for c in word:\\n                if c not in curr:\\n                    curr[c] = {}\\n                curr = curr[c]\\n            curr['#'] = {}  #indicate the end of a word\\n    \\n    \\n        def search(self, word):\\n            return self.search_dfs(word, self.chars)\\n            \\n            \\n        def search_dfs(self, word, curr):\\n            if len(word)==0:\\n                return '#' in curr\\n            c = word[0]\\n            if c == '.':\\n                for char in curr:\\n                    if self.search_dfs(word[1:], curr[char]):\\n                        return True\\n                return False\\n            # now c is a-z\\n            if c in curr:\\n                return self.search_dfs(word[1:], curr[c])\\n            return False",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570929,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1576305,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1756079,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1567916,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1576912,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1566767,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1670836,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1836894,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1573709,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1566697,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1570929,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1576305,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1756079,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1567916,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1576912,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1566767,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1670836,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1836894,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1573709,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1566697,
                "content": [
                    {
                        "username": "bittergreen",
                        "content": "vectors, unordered_map\\'s, raw array\\'s alll get Time Limit exceeded for Test Case 14.\\n\\nCopy and pasted several of the top voted: All TLE.\\n\\nCopy and pasted the official java solution.  That gets TLE.  Test case 14 needs to be removed."
                    },
                    {
                        "username": "steiner",
                        "content": "I must confess, I totally dislike these types of problems on leetcode. \\n\\nIt is unclear which solution complexity is intended, and almost any brute-force solution passes with some heuristics on top of that.\\n\\nFor example, just caching the answers worked for me. Here, in discussions, I see a lot of solutions that group all the words by size. However, it is quite obvious that both heuristics are extremely easy to break. So the actual reason all of that works is a set of unbelievably weak tests.\\n\\nSeeing these heuristics work may create the wrong impression of being the \"correct\" approaches. They are not, and it could be very misleading.\\n\\nP.S. would be glad to help to improve this and other dubious problems here :)"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@nikhila01](/nikhila01) Surprisingly they are accepting solutions with 17000+ ms(17+ seconds). Because in worst case, brute force will have to check all 5000 words for all 5000 queries till last 25th letter. which will be of 6.25*10^8 order of time. Which should have given TLE. But they are accepting that as solution."
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) Simple. I don't handle it. The constraints say that there are a maximum of 3 dot characters in the word. That's an important constraint because it limits the amount of backtracking needed in the trie.\n\nThe hash map solution that some people are using also has the same worst case time complexity as the trie. That solution maps `len of word -> hash set of words of that length`. Then it does a brute force comparison of the search word against that set. In your example, all words have the same length so it's comparison against all 5000 words. And no early breaking from the comparisons either since the only non-dot character is at the end.\n\nThat's why I asked what better solution you have in mind. Your test case is tough, but unless there's *some* solution that can do better than the existing accepted solutions, then what is your test case supposed to be filtering out? It'll just reject all solutions."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) You can check out some of my Test cases If they may help.. My Test cases were always accepted till now..\n\nYou may check them out [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues?q=is%3Aissue+author%3Akautsiitd+is%3Aclosed).\n\nI have also submitted some Test cases [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12466) and [here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/12465) for some bad heuristics I found in some Codes which were giving TLE but Accepted."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) To understand what's wrong with the constraints read the following comment I originally wrote below for another user. How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches.\n\n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Nikhil Arora](/nikhila01) The only thing I got from reporting stuff is their boilerplate \"Thank you for your time, we don't care ...\". When they accept one of your test cases let me know. Look at the first 100 problems in their problem list (e.g. 3sum). Those problems have been there for years. Nevertheless, several of those problems still have ambiguous or wrong problem descriptions, weak tests, misleading constraints and whatnot. I don't want to know how many hours have been wasted by users reporting stuff (and again, I myself have spent some time writing detailed reports). One thing is certain: if they did take user feedback seriously those problems would definitely have improved at this point "
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@Electron1997](/Electron1997) I haven\\'t ever submitted a test case. It your tests cases were as good as you say and they didn\\'t accept them then that\\'s unfortunate. I really like having strong test cases. I did submit a fix to a solution once and they accepted it within a few days.\\n\\nI\\'m curious what you mean about the constraints. If you think a trie solution isn\\'t good because it\\'s linear then what solution do you expect that\\'s better? What kind of worst case test case are you talking about?"
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@AAM](/AAM) The problem is fine but the constraints are not, because all these trie solutions I have seen have worst case linear in number of nodes and it's definitely possible to construct a test case under the given constraints that busts them. If linear time search is fine they should reduce number of queries to about 2000."
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@nikhila01](/nikhila01) Have they ever accepted one of yours? Mine always get rejected without any explanation (even though they are well crafted and within the constraints, including explanation and example of inefficient code that passes all their tests and gets caught). I won\\'t contribute anymore because in my experience they DO NOT take it seriously!"
                    },
                    {
                        "username": "AAM",
                        "content": "I think this is a good problem with the right approach.\\nIt is possible that someone don\\'t know about the trie, solve the problem by brute force, get a green checkmark and move on. \\nBut what\\'s the point? Leetcode is about learning and practice.\\nIt is better to look at similar topics, maybe read solutions, and finally figure out how to use the trie and solve similar problems."
                    },
                    {
                        "username": "zenfred",
                        "content": "That\\'s why LeetCode is only for practicing. It\\'s not for any serious competition or assessment. A single metrics of running time is just too broad to judge an attendant\\'s coding/algorithm ability fairly."
                    },
                    {
                        "username": "nikhila01",
                        "content": "You should definitely help! LeetCode accepts user-submitted test cases."
                    },
                    {
                        "username": "rntongo",
                        "content": "I hate to be that guy but this should be a hard!"
                    },
                    {
                        "username": "marks716",
                        "content": "[@Mister_CK](/Mister_CK) Maybe the lower range of hard since the modification of the Trie is fairly complicated to figure out"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "[@Electron1997](/Electron1997) Note that maximum \".\" can be 3 only. so queries like \"........... ... ...c\" (24 dots with some char c at the end) should not be a valid Test Case.."
                    },
                    {
                        "username": "Zein4",
                        "content": "I  don\\'t think this is hard ( yes I didn\\'t do at as a trie I used a set ) to be honest it took me 5-10 minutes "
                    },
                    {
                        "username": "Electron1997",
                        "content": "[@Chris Kapinga](/Mister_CK) How do you handle the following with your trie?\nFirst, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\nThen, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this would result in approx. 5000 * 1e5 operations on nodes ...).\nI could also mix up the patterns of the second phase a bit each time to prevent you from caching searches."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think it should be hard, you just have to construct a Trie (I build an N-array tree). You should do this problem first: https://leetcode.com/problems/implement-trie-prefix-tree/ and then just slightly modify the search part to handle the dots. "
                    },
                    {
                        "username": "ftpsmtp",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the '.' could have been replaced by another 'a' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "because \"aa\" is considered a complete word not \"a\" so for every word you insert you need to store it flag that this leaf node ends in a word."
                    },
                    {
                        "username": "charonme",
                        "content": "that might have been a bug in 2016, now insert(\"aa\"); search(\"a.\"); correctly expects true"
                    },
                    {
                        "username": "BittuBaby",
                        "content": "i believe that insert is two seperate letter i.e [a][a] "
                    },
                    {
                        "username": "pmcspmcspmcs",
                        "content": "The C++ trie solution using std::vector to store children trie nodes gets TLE (or barely passes). I took a look at how other people were solving the problem and found that some people were using built-in arrays instead of std::vector. After switching to built-in arrays, the runtime was cut in half and it now doesn\\'t TLE.\\n\\nI think it is silly that we have to resort to doing something like this to pass the test cases...this isn\\'t competitive programming.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "I heard that LeetCode C++ STL libraries are not compiler-optimized. They can be several times slower than primitive data types. I think STL is de-optimized at LeetCode to balance out the intrinsic speed advantange of C++... Just my two cents.\\n\\nTo avoid the need of constant factor optimization... Use Python \\u256E\\uFF08\\u256F\\uFF3F\\u2570\\uFF09\\u256D"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If the time limits are relaxed, people will resort to using hash sets to just store words, so I think it is a compulsion to keep tight bounds."
                    },
                    {
                        "username": "nr1286",
                        "content": "for all of the trie solutions where they use a vector of trienodes of size 26\\n\\ncan someone explain the space and runtime complexity. especially of the search method dealing with the case of a . or all .\\n\\nBest,\\n\\nNick"
                    },
                    {
                        "username": "charonme",
                        "content": "[@yongjunchai](/yongjunchai) I\\'m not saying you are wrong, but with this kind of complexity analysis you could say about any leetcode problem that its space and time complexities are both O(1) even if the input constraint was given as 100 Petabytes. Because that\\'s still just a finite number :D At an interview you should still give the interviewer a proper analysis."
                    },
                    {
                        "username": "yongjunchai",
                        "content": "Space complexity: if use recursive to handle the \".\" match, since there is at most three \".\", it means there is most three levels of recursive call. the space complexity is O(1). \nTime complexity: since there is at most three \".\". The time complexity is: 3 * 26 + length of word.  Since the length of the word is at most 25, so the time complexity is O(1). "
                    },
                    {
                        "username": "guna_hawk",
                        "content": "well new leetcode ui sucks"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach:-\n\n- The WordDictionary class implements a Trie data structure to store words and search for words. The Trie is a tree-like data structure where each node represents a character and the path from the root to the node represents a word.\n- The TrieNode class is a nested class of WordDictionary and defines a node of the Trie. Each node contains an array of 26 TrieNodes (one for each letter of the alphabet) and a boolean flag isEndWord to indicate if a word ends at that node.\n- The WordDictionary constructor creates a new Trie with an empty root node.\n- The addWord() method adds a word to the Trie. It traverses the Trie from the root to the last character of the word, creating new TrieNodes as necessary. The TrieNode corresponding to the last character of the word is marked as the end of a word by setting the isEndWord flag to true.\n- The search() method searches for a word in the Trie. It calls a private helper method, searchHelper(), passing in the word as a character array, an index indicating the current character being searched, and the current TrieNode being visited. If the current index is equal to the length of the word, then the search is complete, and the method returns the isEndWord flag of the current TrieNode. Otherwise, if the current character is not a dot, then the corresponding child TrieNode is visited recursively. If the current character is a dot, then all children of the current TrieNode are visited recursively. The searchHelper() method returns true if any recursive call returns true, indicating that the word was found in the Trie. Otherwise, it returns false."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@Electron1997](/Electron1997) You are correct that in the worst case, the search operation may need to traverse all the nodes in the trie, resulting in a time complexity of O(m * n), where m is the length of the search pattern and n is the number of nodes in the trie. As you mentioned, this worst-case scenario can be constructed by inserting a large number of distinct words into the trie and then querying with a search pattern that matches all of them.\\n\\nIn such cases, the search operation may time out, depending on the constraints and performance of the system running the code. However, as you also noted, there may not be a better solution in terms of time complexity, and this trie-based approach may still be a reasonable and efficient solution for most practical use cases.\\n\\nRegarding caching, the current implementation does not use any caching, so it should not be affected by changes in the search pattern. However, caching could potentially improve the performance of the search operation by avoiding redundant traversals of the same nodes in the trie for different search patterns."
                    },
                    {
                        "username": "Electron1997",
                        "content": "If I understand correctly your search is in worst case linear in the number of nodes in the trie. Hence, I think it's possible to construct cases for which your solution times out under the given constraints. For example:\n     First, insert 5000 distinct strings of size 25 without long overlapping prefixes into the data structure (such that you end up with about 1e5 nodes).\n     Then, query something like \"........... ... ...c\" (24 dots with some char c at the end) 5000 times (note that this could result in approx. 5000 * 1e5 operations on nodes).\nWe could also mix up the patterns of the second phase a bit each time to bust solutions that use caching for their searches. This being said, I haven't found a solution with better complexity and I assume this is LeetCode's intended solution (in other words, the constraints they give here aren't sharp and thus misleading)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@vivekrajsundar](/vivekrajsundar) you\\'re welcome "
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "Thanks for the clear approach man."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3314273/using-trie-datastructure/"
                    },
                    {
                        "username": "foxkanda",
                        "content": "[\"WordDictionary\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\\n[[],[\"a\"],[\"a\"],[\".\"],[\"a\"],[\"aa\"],[\"a\"],[\".a\"],[\"a.\"]]\\n\\nmy output: [null,null,null,true,true,false,true,false,true]\\n\\nleetcode expected : [null,null,null,true,true,false,true,false,false]\\n\\nSince the word \"aa\" in present in the Trie, wouldnt searching for \"a.\" return true ?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`\"aa\"` isn't present in the trie because you never inserted it. You only did a search for `\"aa\"`.\n\nLook at the list of operations in your test case. Only the first two are `\"addWord\"` operations.\n\nOr perhaps the confusion is that you expected `addWord(\"a\")` followed by `addWord(\"a\")` to add `\"aa\"`? It doesn't. It just adds `\"a\"`. The second `addWord` is a duplicate and is effectively ignored."
                    },
                    {
                        "username": "Vi5hnukumar",
                        "content": "have you marked each word as endofword ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/design-add-and-search-words-data-structure/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "It is, again, on March, Day 19, 2023."
                    }
                ]
            },
            {
                "id": 1836651,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "If you brute force with a `map` you get `TLE`.\\nIf you brute force with a `vector` or `array` it passes."
                    },
                    {
                        "username": "cagils",
                        "content": "A one liner tip for javascript recursive trie for \\'.\\' search:\\n```js\\nif (c === \\'.\\') return Object.keys(node.children).some(k => recSearch(i + 1, node.children[k]))\\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "How can I pass last test case: 29 , There was No input and When I run mu code I doesn't show output was incorrect but showing gray dot on test Case. Also, all test Case Passing. "
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Same thing happened to me, I just made some small changes here and there, and barely passed the test cases [beats 5% , this bad :(  ]\\nNo idea what happened, my logic was pretty much the same as other people who posted in solutions."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Its giving TLE if hasmap is used even when the submitted codes are pasted directly  \n"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Is someone else getting TLE on Testcase 29 (which is empty) on C++ . My code seems to pass all other testcases . When I use Testcase 29, Leetcode seems to ignore it (It shows grey dot instead of green one in result)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Solve [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) first.\\n\\nA good one to improve your skills too [212. Word Search II](https://leetcode.com/problems/word-search-ii/)."
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "[@LeetCode](/LeetCode) I am getting TLE for the following submission https://leetcode.com/problems/design-add-and-search-words-data-structure/submissions/884432069/ I am sure the time complexity is within check for the problem statement. Have checked with the official solution as well. Can you help me in understanding the same."
                    },
                    {
                        "username": "Decompile",
                        "content": "If you are getting a TLE try adding a `max_length` variable that updates during insertion. You can save a lot of time by checking it first within `search()` rather than doing a long traversal in your Trie for something we know can\\'t be true."
                    },
                    {
                        "username": "afederici",
                        "content": "Not sure whats going on here, but when I use the same exact test case on submission I get a different answer from when its used as the test case in the console.\\n\\n![image](https://assets.leetcode.com/users/afederici/image_1578782629.png)\\n\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "**The C Compiler isnt updated to the latest standards and is showing errors.**\\nMy code ends at line 55 and here is the compiler error :\\nLine 58: Char 63: error: unknown type name \\u2018WordDictionary\\u2019\\n\\nBasically, the Compiler should accept the structure name as it is, instead it requires the prefix \"struct\" compulsoriy for it to recoginize the following string as a name-of-structure.\\n\\nLeetCode needs to fix this issue!!!"
                    }
                ]
            },
            {
                "id": 1839357,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "If you brute force with a `map` you get `TLE`.\\nIf you brute force with a `vector` or `array` it passes."
                    },
                    {
                        "username": "cagils",
                        "content": "A one liner tip for javascript recursive trie for \\'.\\' search:\\n```js\\nif (c === \\'.\\') return Object.keys(node.children).some(k => recSearch(i + 1, node.children[k]))\\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "How can I pass last test case: 29 , There was No input and When I run mu code I doesn't show output was incorrect but showing gray dot on test Case. Also, all test Case Passing. "
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Same thing happened to me, I just made some small changes here and there, and barely passed the test cases [beats 5% , this bad :(  ]\\nNo idea what happened, my logic was pretty much the same as other people who posted in solutions."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Its giving TLE if hasmap is used even when the submitted codes are pasted directly  \n"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Is someone else getting TLE on Testcase 29 (which is empty) on C++ . My code seems to pass all other testcases . When I use Testcase 29, Leetcode seems to ignore it (It shows grey dot instead of green one in result)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Solve [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) first.\\n\\nA good one to improve your skills too [212. Word Search II](https://leetcode.com/problems/word-search-ii/)."
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "[@LeetCode](/LeetCode) I am getting TLE for the following submission https://leetcode.com/problems/design-add-and-search-words-data-structure/submissions/884432069/ I am sure the time complexity is within check for the problem statement. Have checked with the official solution as well. Can you help me in understanding the same."
                    },
                    {
                        "username": "Decompile",
                        "content": "If you are getting a TLE try adding a `max_length` variable that updates during insertion. You can save a lot of time by checking it first within `search()` rather than doing a long traversal in your Trie for something we know can\\'t be true."
                    },
                    {
                        "username": "afederici",
                        "content": "Not sure whats going on here, but when I use the same exact test case on submission I get a different answer from when its used as the test case in the console.\\n\\n![image](https://assets.leetcode.com/users/afederici/image_1578782629.png)\\n\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "**The C Compiler isnt updated to the latest standards and is showing errors.**\\nMy code ends at line 55 and here is the compiler error :\\nLine 58: Char 63: error: unknown type name \\u2018WordDictionary\\u2019\\n\\nBasically, the Compiler should accept the structure name as it is, instead it requires the prefix \"struct\" compulsoriy for it to recoginize the following string as a name-of-structure.\\n\\nLeetCode needs to fix this issue!!!"
                    }
                ]
            },
            {
                "id": 1837682,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "If you brute force with a `map` you get `TLE`.\\nIf you brute force with a `vector` or `array` it passes."
                    },
                    {
                        "username": "cagils",
                        "content": "A one liner tip for javascript recursive trie for \\'.\\' search:\\n```js\\nif (c === \\'.\\') return Object.keys(node.children).some(k => recSearch(i + 1, node.children[k]))\\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "How can I pass last test case: 29 , There was No input and When I run mu code I doesn't show output was incorrect but showing gray dot on test Case. Also, all test Case Passing. "
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Same thing happened to me, I just made some small changes here and there, and barely passed the test cases [beats 5% , this bad :(  ]\\nNo idea what happened, my logic was pretty much the same as other people who posted in solutions."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Its giving TLE if hasmap is used even when the submitted codes are pasted directly  \n"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Is someone else getting TLE on Testcase 29 (which is empty) on C++ . My code seems to pass all other testcases . When I use Testcase 29, Leetcode seems to ignore it (It shows grey dot instead of green one in result)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Solve [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) first.\\n\\nA good one to improve your skills too [212. Word Search II](https://leetcode.com/problems/word-search-ii/)."
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "[@LeetCode](/LeetCode) I am getting TLE for the following submission https://leetcode.com/problems/design-add-and-search-words-data-structure/submissions/884432069/ I am sure the time complexity is within check for the problem statement. Have checked with the official solution as well. Can you help me in understanding the same."
                    },
                    {
                        "username": "Decompile",
                        "content": "If you are getting a TLE try adding a `max_length` variable that updates during insertion. You can save a lot of time by checking it first within `search()` rather than doing a long traversal in your Trie for something we know can\\'t be true."
                    },
                    {
                        "username": "afederici",
                        "content": "Not sure whats going on here, but when I use the same exact test case on submission I get a different answer from when its used as the test case in the console.\\n\\n![image](https://assets.leetcode.com/users/afederici/image_1578782629.png)\\n\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "**The C Compiler isnt updated to the latest standards and is showing errors.**\\nMy code ends at line 55 and here is the compiler error :\\nLine 58: Char 63: error: unknown type name \\u2018WordDictionary\\u2019\\n\\nBasically, the Compiler should accept the structure name as it is, instead it requires the prefix \"struct\" compulsoriy for it to recoginize the following string as a name-of-structure.\\n\\nLeetCode needs to fix this issue!!!"
                    }
                ]
            },
            {
                "id": 1837284,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "If you brute force with a `map` you get `TLE`.\\nIf you brute force with a `vector` or `array` it passes."
                    },
                    {
                        "username": "cagils",
                        "content": "A one liner tip for javascript recursive trie for \\'.\\' search:\\n```js\\nif (c === \\'.\\') return Object.keys(node.children).some(k => recSearch(i + 1, node.children[k]))\\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "How can I pass last test case: 29 , There was No input and When I run mu code I doesn't show output was incorrect but showing gray dot on test Case. Also, all test Case Passing. "
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Same thing happened to me, I just made some small changes here and there, and barely passed the test cases [beats 5% , this bad :(  ]\\nNo idea what happened, my logic was pretty much the same as other people who posted in solutions."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Its giving TLE if hasmap is used even when the submitted codes are pasted directly  \n"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Is someone else getting TLE on Testcase 29 (which is empty) on C++ . My code seems to pass all other testcases . When I use Testcase 29, Leetcode seems to ignore it (It shows grey dot instead of green one in result)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Solve [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) first.\\n\\nA good one to improve your skills too [212. Word Search II](https://leetcode.com/problems/word-search-ii/)."
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "[@LeetCode](/LeetCode) I am getting TLE for the following submission https://leetcode.com/problems/design-add-and-search-words-data-structure/submissions/884432069/ I am sure the time complexity is within check for the problem statement. Have checked with the official solution as well. Can you help me in understanding the same."
                    },
                    {
                        "username": "Decompile",
                        "content": "If you are getting a TLE try adding a `max_length` variable that updates during insertion. You can save a lot of time by checking it first within `search()` rather than doing a long traversal in your Trie for something we know can\\'t be true."
                    },
                    {
                        "username": "afederici",
                        "content": "Not sure whats going on here, but when I use the same exact test case on submission I get a different answer from when its used as the test case in the console.\\n\\n![image](https://assets.leetcode.com/users/afederici/image_1578782629.png)\\n\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "**The C Compiler isnt updated to the latest standards and is showing errors.**\\nMy code ends at line 55 and here is the compiler error :\\nLine 58: Char 63: error: unknown type name \\u2018WordDictionary\\u2019\\n\\nBasically, the Compiler should accept the structure name as it is, instead it requires the prefix \"struct\" compulsoriy for it to recoginize the following string as a name-of-structure.\\n\\nLeetCode needs to fix this issue!!!"
                    }
                ]
            },
            {
                "id": 1837134,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "If you brute force with a `map` you get `TLE`.\\nIf you brute force with a `vector` or `array` it passes."
                    },
                    {
                        "username": "cagils",
                        "content": "A one liner tip for javascript recursive trie for \\'.\\' search:\\n```js\\nif (c === \\'.\\') return Object.keys(node.children).some(k => recSearch(i + 1, node.children[k]))\\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "How can I pass last test case: 29 , There was No input and When I run mu code I doesn't show output was incorrect but showing gray dot on test Case. Also, all test Case Passing. "
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Same thing happened to me, I just made some small changes here and there, and barely passed the test cases [beats 5% , this bad :(  ]\\nNo idea what happened, my logic was pretty much the same as other people who posted in solutions."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Its giving TLE if hasmap is used even when the submitted codes are pasted directly  \n"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Is someone else getting TLE on Testcase 29 (which is empty) on C++ . My code seems to pass all other testcases . When I use Testcase 29, Leetcode seems to ignore it (It shows grey dot instead of green one in result)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Solve [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) first.\\n\\nA good one to improve your skills too [212. Word Search II](https://leetcode.com/problems/word-search-ii/)."
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "[@LeetCode](/LeetCode) I am getting TLE for the following submission https://leetcode.com/problems/design-add-and-search-words-data-structure/submissions/884432069/ I am sure the time complexity is within check for the problem statement. Have checked with the official solution as well. Can you help me in understanding the same."
                    },
                    {
                        "username": "Decompile",
                        "content": "If you are getting a TLE try adding a `max_length` variable that updates during insertion. You can save a lot of time by checking it first within `search()` rather than doing a long traversal in your Trie for something we know can\\'t be true."
                    },
                    {
                        "username": "afederici",
                        "content": "Not sure whats going on here, but when I use the same exact test case on submission I get a different answer from when its used as the test case in the console.\\n\\n![image](https://assets.leetcode.com/users/afederici/image_1578782629.png)\\n\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "**The C Compiler isnt updated to the latest standards and is showing errors.**\\nMy code ends at line 55 and here is the compiler error :\\nLine 58: Char 63: error: unknown type name \\u2018WordDictionary\\u2019\\n\\nBasically, the Compiler should accept the structure name as it is, instead it requires the prefix \"struct\" compulsoriy for it to recoginize the following string as a name-of-structure.\\n\\nLeetCode needs to fix this issue!!!"
                    }
                ]
            },
            {
                "id": 1784836,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "If you brute force with a `map` you get `TLE`.\\nIf you brute force with a `vector` or `array` it passes."
                    },
                    {
                        "username": "cagils",
                        "content": "A one liner tip for javascript recursive trie for \\'.\\' search:\\n```js\\nif (c === \\'.\\') return Object.keys(node.children).some(k => recSearch(i + 1, node.children[k]))\\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "How can I pass last test case: 29 , There was No input and When I run mu code I doesn't show output was incorrect but showing gray dot on test Case. Also, all test Case Passing. "
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Same thing happened to me, I just made some small changes here and there, and barely passed the test cases [beats 5% , this bad :(  ]\\nNo idea what happened, my logic was pretty much the same as other people who posted in solutions."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Its giving TLE if hasmap is used even when the submitted codes are pasted directly  \n"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Is someone else getting TLE on Testcase 29 (which is empty) on C++ . My code seems to pass all other testcases . When I use Testcase 29, Leetcode seems to ignore it (It shows grey dot instead of green one in result)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Solve [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) first.\\n\\nA good one to improve your skills too [212. Word Search II](https://leetcode.com/problems/word-search-ii/)."
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "[@LeetCode](/LeetCode) I am getting TLE for the following submission https://leetcode.com/problems/design-add-and-search-words-data-structure/submissions/884432069/ I am sure the time complexity is within check for the problem statement. Have checked with the official solution as well. Can you help me in understanding the same."
                    },
                    {
                        "username": "Decompile",
                        "content": "If you are getting a TLE try adding a `max_length` variable that updates during insertion. You can save a lot of time by checking it first within `search()` rather than doing a long traversal in your Trie for something we know can\\'t be true."
                    },
                    {
                        "username": "afederici",
                        "content": "Not sure whats going on here, but when I use the same exact test case on submission I get a different answer from when its used as the test case in the console.\\n\\n![image](https://assets.leetcode.com/users/afederici/image_1578782629.png)\\n\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "**The C Compiler isnt updated to the latest standards and is showing errors.**\\nMy code ends at line 55 and here is the compiler error :\\nLine 58: Char 63: error: unknown type name \\u2018WordDictionary\\u2019\\n\\nBasically, the Compiler should accept the structure name as it is, instead it requires the prefix \"struct\" compulsoriy for it to recoginize the following string as a name-of-structure.\\n\\nLeetCode needs to fix this issue!!!"
                    }
                ]
            },
            {
                "id": 1772811,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "If you brute force with a `map` you get `TLE`.\\nIf you brute force with a `vector` or `array` it passes."
                    },
                    {
                        "username": "cagils",
                        "content": "A one liner tip for javascript recursive trie for \\'.\\' search:\\n```js\\nif (c === \\'.\\') return Object.keys(node.children).some(k => recSearch(i + 1, node.children[k]))\\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "How can I pass last test case: 29 , There was No input and When I run mu code I doesn't show output was incorrect but showing gray dot on test Case. Also, all test Case Passing. "
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Same thing happened to me, I just made some small changes here and there, and barely passed the test cases [beats 5% , this bad :(  ]\\nNo idea what happened, my logic was pretty much the same as other people who posted in solutions."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Its giving TLE if hasmap is used even when the submitted codes are pasted directly  \n"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Is someone else getting TLE on Testcase 29 (which is empty) on C++ . My code seems to pass all other testcases . When I use Testcase 29, Leetcode seems to ignore it (It shows grey dot instead of green one in result)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Solve [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) first.\\n\\nA good one to improve your skills too [212. Word Search II](https://leetcode.com/problems/word-search-ii/)."
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "[@LeetCode](/LeetCode) I am getting TLE for the following submission https://leetcode.com/problems/design-add-and-search-words-data-structure/submissions/884432069/ I am sure the time complexity is within check for the problem statement. Have checked with the official solution as well. Can you help me in understanding the same."
                    },
                    {
                        "username": "Decompile",
                        "content": "If you are getting a TLE try adding a `max_length` variable that updates during insertion. You can save a lot of time by checking it first within `search()` rather than doing a long traversal in your Trie for something we know can\\'t be true."
                    },
                    {
                        "username": "afederici",
                        "content": "Not sure whats going on here, but when I use the same exact test case on submission I get a different answer from when its used as the test case in the console.\\n\\n![image](https://assets.leetcode.com/users/afederici/image_1578782629.png)\\n\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "**The C Compiler isnt updated to the latest standards and is showing errors.**\\nMy code ends at line 55 and here is the compiler error :\\nLine 58: Char 63: error: unknown type name \\u2018WordDictionary\\u2019\\n\\nBasically, the Compiler should accept the structure name as it is, instead it requires the prefix \"struct\" compulsoriy for it to recoginize the following string as a name-of-structure.\\n\\nLeetCode needs to fix this issue!!!"
                    }
                ]
            },
            {
                "id": 1771329,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "If you brute force with a `map` you get `TLE`.\\nIf you brute force with a `vector` or `array` it passes."
                    },
                    {
                        "username": "cagils",
                        "content": "A one liner tip for javascript recursive trie for \\'.\\' search:\\n```js\\nif (c === \\'.\\') return Object.keys(node.children).some(k => recSearch(i + 1, node.children[k]))\\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "How can I pass last test case: 29 , There was No input and When I run mu code I doesn't show output was incorrect but showing gray dot on test Case. Also, all test Case Passing. "
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Same thing happened to me, I just made some small changes here and there, and barely passed the test cases [beats 5% , this bad :(  ]\\nNo idea what happened, my logic was pretty much the same as other people who posted in solutions."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Its giving TLE if hasmap is used even when the submitted codes are pasted directly  \n"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Is someone else getting TLE on Testcase 29 (which is empty) on C++ . My code seems to pass all other testcases . When I use Testcase 29, Leetcode seems to ignore it (It shows grey dot instead of green one in result)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Solve [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) first.\\n\\nA good one to improve your skills too [212. Word Search II](https://leetcode.com/problems/word-search-ii/)."
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "[@LeetCode](/LeetCode) I am getting TLE for the following submission https://leetcode.com/problems/design-add-and-search-words-data-structure/submissions/884432069/ I am sure the time complexity is within check for the problem statement. Have checked with the official solution as well. Can you help me in understanding the same."
                    },
                    {
                        "username": "Decompile",
                        "content": "If you are getting a TLE try adding a `max_length` variable that updates during insertion. You can save a lot of time by checking it first within `search()` rather than doing a long traversal in your Trie for something we know can\\'t be true."
                    },
                    {
                        "username": "afederici",
                        "content": "Not sure whats going on here, but when I use the same exact test case on submission I get a different answer from when its used as the test case in the console.\\n\\n![image](https://assets.leetcode.com/users/afederici/image_1578782629.png)\\n\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "**The C Compiler isnt updated to the latest standards and is showing errors.**\\nMy code ends at line 55 and here is the compiler error :\\nLine 58: Char 63: error: unknown type name \\u2018WordDictionary\\u2019\\n\\nBasically, the Compiler should accept the structure name as it is, instead it requires the prefix \"struct\" compulsoriy for it to recoginize the following string as a name-of-structure.\\n\\nLeetCode needs to fix this issue!!!"
                    }
                ]
            },
            {
                "id": 1573334,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "If you brute force with a `map` you get `TLE`.\\nIf you brute force with a `vector` or `array` it passes."
                    },
                    {
                        "username": "cagils",
                        "content": "A one liner tip for javascript recursive trie for \\'.\\' search:\\n```js\\nif (c === \\'.\\') return Object.keys(node.children).some(k => recSearch(i + 1, node.children[k]))\\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "How can I pass last test case: 29 , There was No input and When I run mu code I doesn't show output was incorrect but showing gray dot on test Case. Also, all test Case Passing. "
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Same thing happened to me, I just made some small changes here and there, and barely passed the test cases [beats 5% , this bad :(  ]\\nNo idea what happened, my logic was pretty much the same as other people who posted in solutions."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Its giving TLE if hasmap is used even when the submitted codes are pasted directly  \n"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Is someone else getting TLE on Testcase 29 (which is empty) on C++ . My code seems to pass all other testcases . When I use Testcase 29, Leetcode seems to ignore it (It shows grey dot instead of green one in result)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Solve [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) first.\\n\\nA good one to improve your skills too [212. Word Search II](https://leetcode.com/problems/word-search-ii/)."
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "[@LeetCode](/LeetCode) I am getting TLE for the following submission https://leetcode.com/problems/design-add-and-search-words-data-structure/submissions/884432069/ I am sure the time complexity is within check for the problem statement. Have checked with the official solution as well. Can you help me in understanding the same."
                    },
                    {
                        "username": "Decompile",
                        "content": "If you are getting a TLE try adding a `max_length` variable that updates during insertion. You can save a lot of time by checking it first within `search()` rather than doing a long traversal in your Trie for something we know can\\'t be true."
                    },
                    {
                        "username": "afederici",
                        "content": "Not sure whats going on here, but when I use the same exact test case on submission I get a different answer from when its used as the test case in the console.\\n\\n![image](https://assets.leetcode.com/users/afederici/image_1578782629.png)\\n\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "**The C Compiler isnt updated to the latest standards and is showing errors.**\\nMy code ends at line 55 and here is the compiler error :\\nLine 58: Char 63: error: unknown type name \\u2018WordDictionary\\u2019\\n\\nBasically, the Compiler should accept the structure name as it is, instead it requires the prefix \"struct\" compulsoriy for it to recoginize the following string as a name-of-structure.\\n\\nLeetCode needs to fix this issue!!!"
                    }
                ]
            },
            {
                "id": 1574189,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "If you brute force with a `map` you get `TLE`.\\nIf you brute force with a `vector` or `array` it passes."
                    },
                    {
                        "username": "cagils",
                        "content": "A one liner tip for javascript recursive trie for \\'.\\' search:\\n```js\\nif (c === \\'.\\') return Object.keys(node.children).some(k => recSearch(i + 1, node.children[k]))\\n```"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "How can I pass last test case: 29 , There was No input and When I run mu code I doesn't show output was incorrect but showing gray dot on test Case. Also, all test Case Passing. "
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Same thing happened to me, I just made some small changes here and there, and barely passed the test cases [beats 5% , this bad :(  ]\\nNo idea what happened, my logic was pretty much the same as other people who posted in solutions."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Its giving TLE if hasmap is used even when the submitted codes are pasted directly  \n"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Is someone else getting TLE on Testcase 29 (which is empty) on C++ . My code seems to pass all other testcases . When I use Testcase 29, Leetcode seems to ignore it (It shows grey dot instead of green one in result)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Solve [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) first.\\n\\nA good one to improve your skills too [212. Word Search II](https://leetcode.com/problems/word-search-ii/)."
                    },
                    {
                        "username": "ravishankar_gp",
                        "content": "[@LeetCode](/LeetCode) I am getting TLE for the following submission https://leetcode.com/problems/design-add-and-search-words-data-structure/submissions/884432069/ I am sure the time complexity is within check for the problem statement. Have checked with the official solution as well. Can you help me in understanding the same."
                    },
                    {
                        "username": "Decompile",
                        "content": "If you are getting a TLE try adding a `max_length` variable that updates during insertion. You can save a lot of time by checking it first within `search()` rather than doing a long traversal in your Trie for something we know can\\'t be true."
                    },
                    {
                        "username": "afederici",
                        "content": "Not sure whats going on here, but when I use the same exact test case on submission I get a different answer from when its used as the test case in the console.\\n\\n![image](https://assets.leetcode.com/users/afederici/image_1578782629.png)\\n\\n"
                    },
                    {
                        "username": "dhairyasd",
                        "content": "**The C Compiler isnt updated to the latest standards and is showing errors.**\\nMy code ends at line 55 and here is the compiler error :\\nLine 58: Char 63: error: unknown type name \\u2018WordDictionary\\u2019\\n\\nBasically, the Compiler should accept the structure name as it is, instead it requires the prefix \"struct\" compulsoriy for it to recoginize the following string as a name-of-structure.\\n\\nLeetCode needs to fix this issue!!!"
                    }
                ]
            },
            {
                "id": 2055048,
                "content": [
                    {
                        "username": "SSHshadow2222",
                        "content": "Solving the problem comes down to understanding how a [Trie](https://en.wikipedia.org/wiki/Trie) data structure works (you\\'ve been told this since the first hint of the problem), and after submitting and optimizing my code, I can assure you that the problem\\'s difficulty should and will stay as medium. (This is for all the people crying in the discussion section.)"
                    },
                    {
                        "username": "abhipatwari",
                        "content": "This search function is perfectly working in my local but it\\'s failing for last use case of \"b..\"\\nusual scenario for programmers :D `it\\'s working in my local`\\n\\npublic boolean search(String word) {\\n        TrieNode current = root;\\n        for(int i=0; i<word.length(); i++) {\\n            char ch = word.charAt(i);\\n            if (ch == \\'.\\') {\\n                for(Map.Entry<Character, TrieNode> entry: current.children.entrySet()) {\\n                    root = entry.getValue();\\n                    if(entry != null && search(word.substring(i+1))) return true;\\n                    return false;\\n                }\\n            }\\n            TrieNode child = current.children.get(ch);\\n            if (child == null) return false;\\n            current = child;\\n        }\\n        return current.endOfWord;\\n    }\\n}"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "the dot could be in the middle?"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Could someone please kindly tell me what's the issue with my code? Only 6 testcases passed :( I suspect it has something to do with the 2nd last line `return curr` but I can't be sure how I should fix that \n```\nclass WordDictionary(object):\n\n    def __init__(self):\n        self.root = {}\n\n    def addWord(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: None\n        \"\"\"\n        curr = self.root\n        for char in word:\n            if char not in curr:\n                curr[char] = {}\n            curr = curr[char]\n        curr[\"end\"] = True\n\n    def search(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        def dfs(idx, node):\n            curr = node\n            for i in range(idx, len(word)):\n                char = word[i]\n                if char == \".\":\n                    for child in curr.values():\n                        if dfs(i+1, child):\n                            return True\n                    return False\n                else:\n                    if char not in curr:\n                        return False\n                    curr = curr[char]\n        \n            return curr\n        \n        return dfs(0, self.root)\n```"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Test case fails:\\n```\\n[\"WordDictionary\",\"addWord\", \"search\"]\\n[[],[\"at\"],[\".\"]]\\n```\\n\\nOutput\\n```\\n[null,null,true]\\n```\\n\\nExpected\\n```\\n[null,null,false]\\n```\\n\\nExplanation. We are searching a prefix, not the whole word, so after we inserted any non empty string, it should return `true` for `.`. Because our trie contains at least one character."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think we are looking for prefixes, that isn\\'t mentioned anywhere. I believe you have to match the whole word.\\n\\nThe output fails because \".\" only represents a single char and \"at\" consists of 2. \"..\" does return true, as does \"at\". \\n\\nI could be wrong, it\\'s been a while since I did this one. "
                    },
                    {
                        "username": "nish06",
                        "content": "Can someone help me identify what is wrong with this code(Testcase 17 and later do not pass) ? \n `class WordDictionary {\n\n    TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        if(word == null || word.length() == 0)\n            return;\n        TrieNode curr = root; \n        for(char ch: word.toCharArray()) {\n            TrieNode child = curr.children[ch-'a'];\n            if(child == null){\n                child = new TrieNode(ch);\n                curr.children[ch-'a'] = child;\n            }\n            curr = child;\n        }\n        curr.setIsWord();\n    }\n    public TrieNode searchPrefix(TrieNode node, char[] letters, int index) {\n        for(int i = index; i < letters.length; i++) {\n            TrieNode[] children = node.children;\n            char ch = letters[i];\n                if(ch == '.'){\n                    for(int j = 0; j < children.length; j++){\n                        if(children[j] != null){\n                            TrieNode child = searchPrefix(children[j], letters, i+1);\n                            \n                            return child;\n                        }   \n                    }\n                }\n                else{\n                    if(children[ch-'a'] != null)\n                        node = children[ch - 'a'];\n                }            \n            \n        }\n       \n        return node;\n    }\n    public boolean search(String word) {\n        TrieNode lastLetter = searchPrefix(root, word.toCharArray(), 0);\n        return (lastLetter != null ? lastLetter.getIsWord(): false);\n    }\n}'\n'class TrieNode{\n    char ch; \n    TrieNode[] children;\n    boolean isWord = false;\n    public TrieNode(){\n        children = new TrieNode[26];\n    }\n    public TrieNode(char letter) {\n        ch = letter; \n        children = new TrieNode[26];\n    }\n    public void setIsWord() {\n        isWord = true;\n    }\n    public boolean getIsWord() {\n        return isWord;\n    }\n}`"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If you don\\'t know about the data structure trie, this should be a hard problem."
                    },
                    {
                        "username": "paullam328",
                        "content": "Why is \\'backtracking\\' not included in the list of tags?"
                    },
                    {
                        "username": "user4851h",
                        "content": "Getting error at \\'.\\' comparison.plz help.\\n\\n\\nclass WordDictionary {\\n    ArrayList<String> arr;\\n    public WordDictionary() {\\n        arr=new ArrayList<String>();\\n    }\\n    \\n    public void addWord(String word) {\\n        arr.add(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        Boolean v=false;\\n     for(String s:arr){\\n         int j=0;\\n         for(int i=0;i<word.length();i++){\\n             if(word.charAt(i)==\\'.\\') {j++;}\\n             if(word.charAt(i)!=s.charAt(j)){\\n                 break;\\n             }else \\n             j++;\\n         }\\n         if(j==s.length()) return true;\\n         \\n     }return false;   \\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Some solutions which are consuming more than 17000 ms (17 seconds) in Python for some test cases marked as accepted. Is there a time limit? I thought more than 5 seconds for Python, It should have given TLE."
                    }
                ]
            },
            {
                "id": 2034911,
                "content": [
                    {
                        "username": "SSHshadow2222",
                        "content": "Solving the problem comes down to understanding how a [Trie](https://en.wikipedia.org/wiki/Trie) data structure works (you\\'ve been told this since the first hint of the problem), and after submitting and optimizing my code, I can assure you that the problem\\'s difficulty should and will stay as medium. (This is for all the people crying in the discussion section.)"
                    },
                    {
                        "username": "abhipatwari",
                        "content": "This search function is perfectly working in my local but it\\'s failing for last use case of \"b..\"\\nusual scenario for programmers :D `it\\'s working in my local`\\n\\npublic boolean search(String word) {\\n        TrieNode current = root;\\n        for(int i=0; i<word.length(); i++) {\\n            char ch = word.charAt(i);\\n            if (ch == \\'.\\') {\\n                for(Map.Entry<Character, TrieNode> entry: current.children.entrySet()) {\\n                    root = entry.getValue();\\n                    if(entry != null && search(word.substring(i+1))) return true;\\n                    return false;\\n                }\\n            }\\n            TrieNode child = current.children.get(ch);\\n            if (child == null) return false;\\n            current = child;\\n        }\\n        return current.endOfWord;\\n    }\\n}"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "the dot could be in the middle?"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Could someone please kindly tell me what's the issue with my code? Only 6 testcases passed :( I suspect it has something to do with the 2nd last line `return curr` but I can't be sure how I should fix that \n```\nclass WordDictionary(object):\n\n    def __init__(self):\n        self.root = {}\n\n    def addWord(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: None\n        \"\"\"\n        curr = self.root\n        for char in word:\n            if char not in curr:\n                curr[char] = {}\n            curr = curr[char]\n        curr[\"end\"] = True\n\n    def search(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        def dfs(idx, node):\n            curr = node\n            for i in range(idx, len(word)):\n                char = word[i]\n                if char == \".\":\n                    for child in curr.values():\n                        if dfs(i+1, child):\n                            return True\n                    return False\n                else:\n                    if char not in curr:\n                        return False\n                    curr = curr[char]\n        \n            return curr\n        \n        return dfs(0, self.root)\n```"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Test case fails:\\n```\\n[\"WordDictionary\",\"addWord\", \"search\"]\\n[[],[\"at\"],[\".\"]]\\n```\\n\\nOutput\\n```\\n[null,null,true]\\n```\\n\\nExpected\\n```\\n[null,null,false]\\n```\\n\\nExplanation. We are searching a prefix, not the whole word, so after we inserted any non empty string, it should return `true` for `.`. Because our trie contains at least one character."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think we are looking for prefixes, that isn\\'t mentioned anywhere. I believe you have to match the whole word.\\n\\nThe output fails because \".\" only represents a single char and \"at\" consists of 2. \"..\" does return true, as does \"at\". \\n\\nI could be wrong, it\\'s been a while since I did this one. "
                    },
                    {
                        "username": "nish06",
                        "content": "Can someone help me identify what is wrong with this code(Testcase 17 and later do not pass) ? \n `class WordDictionary {\n\n    TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        if(word == null || word.length() == 0)\n            return;\n        TrieNode curr = root; \n        for(char ch: word.toCharArray()) {\n            TrieNode child = curr.children[ch-'a'];\n            if(child == null){\n                child = new TrieNode(ch);\n                curr.children[ch-'a'] = child;\n            }\n            curr = child;\n        }\n        curr.setIsWord();\n    }\n    public TrieNode searchPrefix(TrieNode node, char[] letters, int index) {\n        for(int i = index; i < letters.length; i++) {\n            TrieNode[] children = node.children;\n            char ch = letters[i];\n                if(ch == '.'){\n                    for(int j = 0; j < children.length; j++){\n                        if(children[j] != null){\n                            TrieNode child = searchPrefix(children[j], letters, i+1);\n                            \n                            return child;\n                        }   \n                    }\n                }\n                else{\n                    if(children[ch-'a'] != null)\n                        node = children[ch - 'a'];\n                }            \n            \n        }\n       \n        return node;\n    }\n    public boolean search(String word) {\n        TrieNode lastLetter = searchPrefix(root, word.toCharArray(), 0);\n        return (lastLetter != null ? lastLetter.getIsWord(): false);\n    }\n}'\n'class TrieNode{\n    char ch; \n    TrieNode[] children;\n    boolean isWord = false;\n    public TrieNode(){\n        children = new TrieNode[26];\n    }\n    public TrieNode(char letter) {\n        ch = letter; \n        children = new TrieNode[26];\n    }\n    public void setIsWord() {\n        isWord = true;\n    }\n    public boolean getIsWord() {\n        return isWord;\n    }\n}`"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If you don\\'t know about the data structure trie, this should be a hard problem."
                    },
                    {
                        "username": "paullam328",
                        "content": "Why is \\'backtracking\\' not included in the list of tags?"
                    },
                    {
                        "username": "user4851h",
                        "content": "Getting error at \\'.\\' comparison.plz help.\\n\\n\\nclass WordDictionary {\\n    ArrayList<String> arr;\\n    public WordDictionary() {\\n        arr=new ArrayList<String>();\\n    }\\n    \\n    public void addWord(String word) {\\n        arr.add(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        Boolean v=false;\\n     for(String s:arr){\\n         int j=0;\\n         for(int i=0;i<word.length();i++){\\n             if(word.charAt(i)==\\'.\\') {j++;}\\n             if(word.charAt(i)!=s.charAt(j)){\\n                 break;\\n             }else \\n             j++;\\n         }\\n         if(j==s.length()) return true;\\n         \\n     }return false;   \\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Some solutions which are consuming more than 17000 ms (17 seconds) in Python for some test cases marked as accepted. Is there a time limit? I thought more than 5 seconds for Python, It should have given TLE."
                    }
                ]
            },
            {
                "id": 2029542,
                "content": [
                    {
                        "username": "SSHshadow2222",
                        "content": "Solving the problem comes down to understanding how a [Trie](https://en.wikipedia.org/wiki/Trie) data structure works (you\\'ve been told this since the first hint of the problem), and after submitting and optimizing my code, I can assure you that the problem\\'s difficulty should and will stay as medium. (This is for all the people crying in the discussion section.)"
                    },
                    {
                        "username": "abhipatwari",
                        "content": "This search function is perfectly working in my local but it\\'s failing for last use case of \"b..\"\\nusual scenario for programmers :D `it\\'s working in my local`\\n\\npublic boolean search(String word) {\\n        TrieNode current = root;\\n        for(int i=0; i<word.length(); i++) {\\n            char ch = word.charAt(i);\\n            if (ch == \\'.\\') {\\n                for(Map.Entry<Character, TrieNode> entry: current.children.entrySet()) {\\n                    root = entry.getValue();\\n                    if(entry != null && search(word.substring(i+1))) return true;\\n                    return false;\\n                }\\n            }\\n            TrieNode child = current.children.get(ch);\\n            if (child == null) return false;\\n            current = child;\\n        }\\n        return current.endOfWord;\\n    }\\n}"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "the dot could be in the middle?"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Could someone please kindly tell me what's the issue with my code? Only 6 testcases passed :( I suspect it has something to do with the 2nd last line `return curr` but I can't be sure how I should fix that \n```\nclass WordDictionary(object):\n\n    def __init__(self):\n        self.root = {}\n\n    def addWord(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: None\n        \"\"\"\n        curr = self.root\n        for char in word:\n            if char not in curr:\n                curr[char] = {}\n            curr = curr[char]\n        curr[\"end\"] = True\n\n    def search(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        def dfs(idx, node):\n            curr = node\n            for i in range(idx, len(word)):\n                char = word[i]\n                if char == \".\":\n                    for child in curr.values():\n                        if dfs(i+1, child):\n                            return True\n                    return False\n                else:\n                    if char not in curr:\n                        return False\n                    curr = curr[char]\n        \n            return curr\n        \n        return dfs(0, self.root)\n```"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Test case fails:\\n```\\n[\"WordDictionary\",\"addWord\", \"search\"]\\n[[],[\"at\"],[\".\"]]\\n```\\n\\nOutput\\n```\\n[null,null,true]\\n```\\n\\nExpected\\n```\\n[null,null,false]\\n```\\n\\nExplanation. We are searching a prefix, not the whole word, so after we inserted any non empty string, it should return `true` for `.`. Because our trie contains at least one character."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think we are looking for prefixes, that isn\\'t mentioned anywhere. I believe you have to match the whole word.\\n\\nThe output fails because \".\" only represents a single char and \"at\" consists of 2. \"..\" does return true, as does \"at\". \\n\\nI could be wrong, it\\'s been a while since I did this one. "
                    },
                    {
                        "username": "nish06",
                        "content": "Can someone help me identify what is wrong with this code(Testcase 17 and later do not pass) ? \n `class WordDictionary {\n\n    TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        if(word == null || word.length() == 0)\n            return;\n        TrieNode curr = root; \n        for(char ch: word.toCharArray()) {\n            TrieNode child = curr.children[ch-'a'];\n            if(child == null){\n                child = new TrieNode(ch);\n                curr.children[ch-'a'] = child;\n            }\n            curr = child;\n        }\n        curr.setIsWord();\n    }\n    public TrieNode searchPrefix(TrieNode node, char[] letters, int index) {\n        for(int i = index; i < letters.length; i++) {\n            TrieNode[] children = node.children;\n            char ch = letters[i];\n                if(ch == '.'){\n                    for(int j = 0; j < children.length; j++){\n                        if(children[j] != null){\n                            TrieNode child = searchPrefix(children[j], letters, i+1);\n                            \n                            return child;\n                        }   \n                    }\n                }\n                else{\n                    if(children[ch-'a'] != null)\n                        node = children[ch - 'a'];\n                }            \n            \n        }\n       \n        return node;\n    }\n    public boolean search(String word) {\n        TrieNode lastLetter = searchPrefix(root, word.toCharArray(), 0);\n        return (lastLetter != null ? lastLetter.getIsWord(): false);\n    }\n}'\n'class TrieNode{\n    char ch; \n    TrieNode[] children;\n    boolean isWord = false;\n    public TrieNode(){\n        children = new TrieNode[26];\n    }\n    public TrieNode(char letter) {\n        ch = letter; \n        children = new TrieNode[26];\n    }\n    public void setIsWord() {\n        isWord = true;\n    }\n    public boolean getIsWord() {\n        return isWord;\n    }\n}`"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If you don\\'t know about the data structure trie, this should be a hard problem."
                    },
                    {
                        "username": "paullam328",
                        "content": "Why is \\'backtracking\\' not included in the list of tags?"
                    },
                    {
                        "username": "user4851h",
                        "content": "Getting error at \\'.\\' comparison.plz help.\\n\\n\\nclass WordDictionary {\\n    ArrayList<String> arr;\\n    public WordDictionary() {\\n        arr=new ArrayList<String>();\\n    }\\n    \\n    public void addWord(String word) {\\n        arr.add(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        Boolean v=false;\\n     for(String s:arr){\\n         int j=0;\\n         for(int i=0;i<word.length();i++){\\n             if(word.charAt(i)==\\'.\\') {j++;}\\n             if(word.charAt(i)!=s.charAt(j)){\\n                 break;\\n             }else \\n             j++;\\n         }\\n         if(j==s.length()) return true;\\n         \\n     }return false;   \\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Some solutions which are consuming more than 17000 ms (17 seconds) in Python for some test cases marked as accepted. Is there a time limit? I thought more than 5 seconds for Python, It should have given TLE."
                    }
                ]
            },
            {
                "id": 2019494,
                "content": [
                    {
                        "username": "SSHshadow2222",
                        "content": "Solving the problem comes down to understanding how a [Trie](https://en.wikipedia.org/wiki/Trie) data structure works (you\\'ve been told this since the first hint of the problem), and after submitting and optimizing my code, I can assure you that the problem\\'s difficulty should and will stay as medium. (This is for all the people crying in the discussion section.)"
                    },
                    {
                        "username": "abhipatwari",
                        "content": "This search function is perfectly working in my local but it\\'s failing for last use case of \"b..\"\\nusual scenario for programmers :D `it\\'s working in my local`\\n\\npublic boolean search(String word) {\\n        TrieNode current = root;\\n        for(int i=0; i<word.length(); i++) {\\n            char ch = word.charAt(i);\\n            if (ch == \\'.\\') {\\n                for(Map.Entry<Character, TrieNode> entry: current.children.entrySet()) {\\n                    root = entry.getValue();\\n                    if(entry != null && search(word.substring(i+1))) return true;\\n                    return false;\\n                }\\n            }\\n            TrieNode child = current.children.get(ch);\\n            if (child == null) return false;\\n            current = child;\\n        }\\n        return current.endOfWord;\\n    }\\n}"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "the dot could be in the middle?"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Could someone please kindly tell me what's the issue with my code? Only 6 testcases passed :( I suspect it has something to do with the 2nd last line `return curr` but I can't be sure how I should fix that \n```\nclass WordDictionary(object):\n\n    def __init__(self):\n        self.root = {}\n\n    def addWord(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: None\n        \"\"\"\n        curr = self.root\n        for char in word:\n            if char not in curr:\n                curr[char] = {}\n            curr = curr[char]\n        curr[\"end\"] = True\n\n    def search(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        def dfs(idx, node):\n            curr = node\n            for i in range(idx, len(word)):\n                char = word[i]\n                if char == \".\":\n                    for child in curr.values():\n                        if dfs(i+1, child):\n                            return True\n                    return False\n                else:\n                    if char not in curr:\n                        return False\n                    curr = curr[char]\n        \n            return curr\n        \n        return dfs(0, self.root)\n```"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Test case fails:\\n```\\n[\"WordDictionary\",\"addWord\", \"search\"]\\n[[],[\"at\"],[\".\"]]\\n```\\n\\nOutput\\n```\\n[null,null,true]\\n```\\n\\nExpected\\n```\\n[null,null,false]\\n```\\n\\nExplanation. We are searching a prefix, not the whole word, so after we inserted any non empty string, it should return `true` for `.`. Because our trie contains at least one character."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think we are looking for prefixes, that isn\\'t mentioned anywhere. I believe you have to match the whole word.\\n\\nThe output fails because \".\" only represents a single char and \"at\" consists of 2. \"..\" does return true, as does \"at\". \\n\\nI could be wrong, it\\'s been a while since I did this one. "
                    },
                    {
                        "username": "nish06",
                        "content": "Can someone help me identify what is wrong with this code(Testcase 17 and later do not pass) ? \n `class WordDictionary {\n\n    TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        if(word == null || word.length() == 0)\n            return;\n        TrieNode curr = root; \n        for(char ch: word.toCharArray()) {\n            TrieNode child = curr.children[ch-'a'];\n            if(child == null){\n                child = new TrieNode(ch);\n                curr.children[ch-'a'] = child;\n            }\n            curr = child;\n        }\n        curr.setIsWord();\n    }\n    public TrieNode searchPrefix(TrieNode node, char[] letters, int index) {\n        for(int i = index; i < letters.length; i++) {\n            TrieNode[] children = node.children;\n            char ch = letters[i];\n                if(ch == '.'){\n                    for(int j = 0; j < children.length; j++){\n                        if(children[j] != null){\n                            TrieNode child = searchPrefix(children[j], letters, i+1);\n                            \n                            return child;\n                        }   \n                    }\n                }\n                else{\n                    if(children[ch-'a'] != null)\n                        node = children[ch - 'a'];\n                }            \n            \n        }\n       \n        return node;\n    }\n    public boolean search(String word) {\n        TrieNode lastLetter = searchPrefix(root, word.toCharArray(), 0);\n        return (lastLetter != null ? lastLetter.getIsWord(): false);\n    }\n}'\n'class TrieNode{\n    char ch; \n    TrieNode[] children;\n    boolean isWord = false;\n    public TrieNode(){\n        children = new TrieNode[26];\n    }\n    public TrieNode(char letter) {\n        ch = letter; \n        children = new TrieNode[26];\n    }\n    public void setIsWord() {\n        isWord = true;\n    }\n    public boolean getIsWord() {\n        return isWord;\n    }\n}`"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If you don\\'t know about the data structure trie, this should be a hard problem."
                    },
                    {
                        "username": "paullam328",
                        "content": "Why is \\'backtracking\\' not included in the list of tags?"
                    },
                    {
                        "username": "user4851h",
                        "content": "Getting error at \\'.\\' comparison.plz help.\\n\\n\\nclass WordDictionary {\\n    ArrayList<String> arr;\\n    public WordDictionary() {\\n        arr=new ArrayList<String>();\\n    }\\n    \\n    public void addWord(String word) {\\n        arr.add(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        Boolean v=false;\\n     for(String s:arr){\\n         int j=0;\\n         for(int i=0;i<word.length();i++){\\n             if(word.charAt(i)==\\'.\\') {j++;}\\n             if(word.charAt(i)!=s.charAt(j)){\\n                 break;\\n             }else \\n             j++;\\n         }\\n         if(j==s.length()) return true;\\n         \\n     }return false;   \\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Some solutions which are consuming more than 17000 ms (17 seconds) in Python for some test cases marked as accepted. Is there a time limit? I thought more than 5 seconds for Python, It should have given TLE."
                    }
                ]
            },
            {
                "id": 1963481,
                "content": [
                    {
                        "username": "SSHshadow2222",
                        "content": "Solving the problem comes down to understanding how a [Trie](https://en.wikipedia.org/wiki/Trie) data structure works (you\\'ve been told this since the first hint of the problem), and after submitting and optimizing my code, I can assure you that the problem\\'s difficulty should and will stay as medium. (This is for all the people crying in the discussion section.)"
                    },
                    {
                        "username": "abhipatwari",
                        "content": "This search function is perfectly working in my local but it\\'s failing for last use case of \"b..\"\\nusual scenario for programmers :D `it\\'s working in my local`\\n\\npublic boolean search(String word) {\\n        TrieNode current = root;\\n        for(int i=0; i<word.length(); i++) {\\n            char ch = word.charAt(i);\\n            if (ch == \\'.\\') {\\n                for(Map.Entry<Character, TrieNode> entry: current.children.entrySet()) {\\n                    root = entry.getValue();\\n                    if(entry != null && search(word.substring(i+1))) return true;\\n                    return false;\\n                }\\n            }\\n            TrieNode child = current.children.get(ch);\\n            if (child == null) return false;\\n            current = child;\\n        }\\n        return current.endOfWord;\\n    }\\n}"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "the dot could be in the middle?"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Could someone please kindly tell me what's the issue with my code? Only 6 testcases passed :( I suspect it has something to do with the 2nd last line `return curr` but I can't be sure how I should fix that \n```\nclass WordDictionary(object):\n\n    def __init__(self):\n        self.root = {}\n\n    def addWord(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: None\n        \"\"\"\n        curr = self.root\n        for char in word:\n            if char not in curr:\n                curr[char] = {}\n            curr = curr[char]\n        curr[\"end\"] = True\n\n    def search(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        def dfs(idx, node):\n            curr = node\n            for i in range(idx, len(word)):\n                char = word[i]\n                if char == \".\":\n                    for child in curr.values():\n                        if dfs(i+1, child):\n                            return True\n                    return False\n                else:\n                    if char not in curr:\n                        return False\n                    curr = curr[char]\n        \n            return curr\n        \n        return dfs(0, self.root)\n```"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Test case fails:\\n```\\n[\"WordDictionary\",\"addWord\", \"search\"]\\n[[],[\"at\"],[\".\"]]\\n```\\n\\nOutput\\n```\\n[null,null,true]\\n```\\n\\nExpected\\n```\\n[null,null,false]\\n```\\n\\nExplanation. We are searching a prefix, not the whole word, so after we inserted any non empty string, it should return `true` for `.`. Because our trie contains at least one character."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think we are looking for prefixes, that isn\\'t mentioned anywhere. I believe you have to match the whole word.\\n\\nThe output fails because \".\" only represents a single char and \"at\" consists of 2. \"..\" does return true, as does \"at\". \\n\\nI could be wrong, it\\'s been a while since I did this one. "
                    },
                    {
                        "username": "nish06",
                        "content": "Can someone help me identify what is wrong with this code(Testcase 17 and later do not pass) ? \n `class WordDictionary {\n\n    TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        if(word == null || word.length() == 0)\n            return;\n        TrieNode curr = root; \n        for(char ch: word.toCharArray()) {\n            TrieNode child = curr.children[ch-'a'];\n            if(child == null){\n                child = new TrieNode(ch);\n                curr.children[ch-'a'] = child;\n            }\n            curr = child;\n        }\n        curr.setIsWord();\n    }\n    public TrieNode searchPrefix(TrieNode node, char[] letters, int index) {\n        for(int i = index; i < letters.length; i++) {\n            TrieNode[] children = node.children;\n            char ch = letters[i];\n                if(ch == '.'){\n                    for(int j = 0; j < children.length; j++){\n                        if(children[j] != null){\n                            TrieNode child = searchPrefix(children[j], letters, i+1);\n                            \n                            return child;\n                        }   \n                    }\n                }\n                else{\n                    if(children[ch-'a'] != null)\n                        node = children[ch - 'a'];\n                }            \n            \n        }\n       \n        return node;\n    }\n    public boolean search(String word) {\n        TrieNode lastLetter = searchPrefix(root, word.toCharArray(), 0);\n        return (lastLetter != null ? lastLetter.getIsWord(): false);\n    }\n}'\n'class TrieNode{\n    char ch; \n    TrieNode[] children;\n    boolean isWord = false;\n    public TrieNode(){\n        children = new TrieNode[26];\n    }\n    public TrieNode(char letter) {\n        ch = letter; \n        children = new TrieNode[26];\n    }\n    public void setIsWord() {\n        isWord = true;\n    }\n    public boolean getIsWord() {\n        return isWord;\n    }\n}`"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If you don\\'t know about the data structure trie, this should be a hard problem."
                    },
                    {
                        "username": "paullam328",
                        "content": "Why is \\'backtracking\\' not included in the list of tags?"
                    },
                    {
                        "username": "user4851h",
                        "content": "Getting error at \\'.\\' comparison.plz help.\\n\\n\\nclass WordDictionary {\\n    ArrayList<String> arr;\\n    public WordDictionary() {\\n        arr=new ArrayList<String>();\\n    }\\n    \\n    public void addWord(String word) {\\n        arr.add(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        Boolean v=false;\\n     for(String s:arr){\\n         int j=0;\\n         for(int i=0;i<word.length();i++){\\n             if(word.charAt(i)==\\'.\\') {j++;}\\n             if(word.charAt(i)!=s.charAt(j)){\\n                 break;\\n             }else \\n             j++;\\n         }\\n         if(j==s.length()) return true;\\n         \\n     }return false;   \\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Some solutions which are consuming more than 17000 ms (17 seconds) in Python for some test cases marked as accepted. Is there a time limit? I thought more than 5 seconds for Python, It should have given TLE."
                    }
                ]
            },
            {
                "id": 1909133,
                "content": [
                    {
                        "username": "SSHshadow2222",
                        "content": "Solving the problem comes down to understanding how a [Trie](https://en.wikipedia.org/wiki/Trie) data structure works (you\\'ve been told this since the first hint of the problem), and after submitting and optimizing my code, I can assure you that the problem\\'s difficulty should and will stay as medium. (This is for all the people crying in the discussion section.)"
                    },
                    {
                        "username": "abhipatwari",
                        "content": "This search function is perfectly working in my local but it\\'s failing for last use case of \"b..\"\\nusual scenario for programmers :D `it\\'s working in my local`\\n\\npublic boolean search(String word) {\\n        TrieNode current = root;\\n        for(int i=0; i<word.length(); i++) {\\n            char ch = word.charAt(i);\\n            if (ch == \\'.\\') {\\n                for(Map.Entry<Character, TrieNode> entry: current.children.entrySet()) {\\n                    root = entry.getValue();\\n                    if(entry != null && search(word.substring(i+1))) return true;\\n                    return false;\\n                }\\n            }\\n            TrieNode child = current.children.get(ch);\\n            if (child == null) return false;\\n            current = child;\\n        }\\n        return current.endOfWord;\\n    }\\n}"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "the dot could be in the middle?"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Could someone please kindly tell me what's the issue with my code? Only 6 testcases passed :( I suspect it has something to do with the 2nd last line `return curr` but I can't be sure how I should fix that \n```\nclass WordDictionary(object):\n\n    def __init__(self):\n        self.root = {}\n\n    def addWord(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: None\n        \"\"\"\n        curr = self.root\n        for char in word:\n            if char not in curr:\n                curr[char] = {}\n            curr = curr[char]\n        curr[\"end\"] = True\n\n    def search(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        def dfs(idx, node):\n            curr = node\n            for i in range(idx, len(word)):\n                char = word[i]\n                if char == \".\":\n                    for child in curr.values():\n                        if dfs(i+1, child):\n                            return True\n                    return False\n                else:\n                    if char not in curr:\n                        return False\n                    curr = curr[char]\n        \n            return curr\n        \n        return dfs(0, self.root)\n```"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Test case fails:\\n```\\n[\"WordDictionary\",\"addWord\", \"search\"]\\n[[],[\"at\"],[\".\"]]\\n```\\n\\nOutput\\n```\\n[null,null,true]\\n```\\n\\nExpected\\n```\\n[null,null,false]\\n```\\n\\nExplanation. We are searching a prefix, not the whole word, so after we inserted any non empty string, it should return `true` for `.`. Because our trie contains at least one character."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think we are looking for prefixes, that isn\\'t mentioned anywhere. I believe you have to match the whole word.\\n\\nThe output fails because \".\" only represents a single char and \"at\" consists of 2. \"..\" does return true, as does \"at\". \\n\\nI could be wrong, it\\'s been a while since I did this one. "
                    },
                    {
                        "username": "nish06",
                        "content": "Can someone help me identify what is wrong with this code(Testcase 17 and later do not pass) ? \n `class WordDictionary {\n\n    TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        if(word == null || word.length() == 0)\n            return;\n        TrieNode curr = root; \n        for(char ch: word.toCharArray()) {\n            TrieNode child = curr.children[ch-'a'];\n            if(child == null){\n                child = new TrieNode(ch);\n                curr.children[ch-'a'] = child;\n            }\n            curr = child;\n        }\n        curr.setIsWord();\n    }\n    public TrieNode searchPrefix(TrieNode node, char[] letters, int index) {\n        for(int i = index; i < letters.length; i++) {\n            TrieNode[] children = node.children;\n            char ch = letters[i];\n                if(ch == '.'){\n                    for(int j = 0; j < children.length; j++){\n                        if(children[j] != null){\n                            TrieNode child = searchPrefix(children[j], letters, i+1);\n                            \n                            return child;\n                        }   \n                    }\n                }\n                else{\n                    if(children[ch-'a'] != null)\n                        node = children[ch - 'a'];\n                }            \n            \n        }\n       \n        return node;\n    }\n    public boolean search(String word) {\n        TrieNode lastLetter = searchPrefix(root, word.toCharArray(), 0);\n        return (lastLetter != null ? lastLetter.getIsWord(): false);\n    }\n}'\n'class TrieNode{\n    char ch; \n    TrieNode[] children;\n    boolean isWord = false;\n    public TrieNode(){\n        children = new TrieNode[26];\n    }\n    public TrieNode(char letter) {\n        ch = letter; \n        children = new TrieNode[26];\n    }\n    public void setIsWord() {\n        isWord = true;\n    }\n    public boolean getIsWord() {\n        return isWord;\n    }\n}`"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If you don\\'t know about the data structure trie, this should be a hard problem."
                    },
                    {
                        "username": "paullam328",
                        "content": "Why is \\'backtracking\\' not included in the list of tags?"
                    },
                    {
                        "username": "user4851h",
                        "content": "Getting error at \\'.\\' comparison.plz help.\\n\\n\\nclass WordDictionary {\\n    ArrayList<String> arr;\\n    public WordDictionary() {\\n        arr=new ArrayList<String>();\\n    }\\n    \\n    public void addWord(String word) {\\n        arr.add(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        Boolean v=false;\\n     for(String s:arr){\\n         int j=0;\\n         for(int i=0;i<word.length();i++){\\n             if(word.charAt(i)==\\'.\\') {j++;}\\n             if(word.charAt(i)!=s.charAt(j)){\\n                 break;\\n             }else \\n             j++;\\n         }\\n         if(j==s.length()) return true;\\n         \\n     }return false;   \\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Some solutions which are consuming more than 17000 ms (17 seconds) in Python for some test cases marked as accepted. Is there a time limit? I thought more than 5 seconds for Python, It should have given TLE."
                    }
                ]
            },
            {
                "id": 1872741,
                "content": [
                    {
                        "username": "SSHshadow2222",
                        "content": "Solving the problem comes down to understanding how a [Trie](https://en.wikipedia.org/wiki/Trie) data structure works (you\\'ve been told this since the first hint of the problem), and after submitting and optimizing my code, I can assure you that the problem\\'s difficulty should and will stay as medium. (This is for all the people crying in the discussion section.)"
                    },
                    {
                        "username": "abhipatwari",
                        "content": "This search function is perfectly working in my local but it\\'s failing for last use case of \"b..\"\\nusual scenario for programmers :D `it\\'s working in my local`\\n\\npublic boolean search(String word) {\\n        TrieNode current = root;\\n        for(int i=0; i<word.length(); i++) {\\n            char ch = word.charAt(i);\\n            if (ch == \\'.\\') {\\n                for(Map.Entry<Character, TrieNode> entry: current.children.entrySet()) {\\n                    root = entry.getValue();\\n                    if(entry != null && search(word.substring(i+1))) return true;\\n                    return false;\\n                }\\n            }\\n            TrieNode child = current.children.get(ch);\\n            if (child == null) return false;\\n            current = child;\\n        }\\n        return current.endOfWord;\\n    }\\n}"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "the dot could be in the middle?"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Could someone please kindly tell me what's the issue with my code? Only 6 testcases passed :( I suspect it has something to do with the 2nd last line `return curr` but I can't be sure how I should fix that \n```\nclass WordDictionary(object):\n\n    def __init__(self):\n        self.root = {}\n\n    def addWord(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: None\n        \"\"\"\n        curr = self.root\n        for char in word:\n            if char not in curr:\n                curr[char] = {}\n            curr = curr[char]\n        curr[\"end\"] = True\n\n    def search(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        def dfs(idx, node):\n            curr = node\n            for i in range(idx, len(word)):\n                char = word[i]\n                if char == \".\":\n                    for child in curr.values():\n                        if dfs(i+1, child):\n                            return True\n                    return False\n                else:\n                    if char not in curr:\n                        return False\n                    curr = curr[char]\n        \n            return curr\n        \n        return dfs(0, self.root)\n```"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Test case fails:\\n```\\n[\"WordDictionary\",\"addWord\", \"search\"]\\n[[],[\"at\"],[\".\"]]\\n```\\n\\nOutput\\n```\\n[null,null,true]\\n```\\n\\nExpected\\n```\\n[null,null,false]\\n```\\n\\nExplanation. We are searching a prefix, not the whole word, so after we inserted any non empty string, it should return `true` for `.`. Because our trie contains at least one character."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think we are looking for prefixes, that isn\\'t mentioned anywhere. I believe you have to match the whole word.\\n\\nThe output fails because \".\" only represents a single char and \"at\" consists of 2. \"..\" does return true, as does \"at\". \\n\\nI could be wrong, it\\'s been a while since I did this one. "
                    },
                    {
                        "username": "nish06",
                        "content": "Can someone help me identify what is wrong with this code(Testcase 17 and later do not pass) ? \n `class WordDictionary {\n\n    TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        if(word == null || word.length() == 0)\n            return;\n        TrieNode curr = root; \n        for(char ch: word.toCharArray()) {\n            TrieNode child = curr.children[ch-'a'];\n            if(child == null){\n                child = new TrieNode(ch);\n                curr.children[ch-'a'] = child;\n            }\n            curr = child;\n        }\n        curr.setIsWord();\n    }\n    public TrieNode searchPrefix(TrieNode node, char[] letters, int index) {\n        for(int i = index; i < letters.length; i++) {\n            TrieNode[] children = node.children;\n            char ch = letters[i];\n                if(ch == '.'){\n                    for(int j = 0; j < children.length; j++){\n                        if(children[j] != null){\n                            TrieNode child = searchPrefix(children[j], letters, i+1);\n                            \n                            return child;\n                        }   \n                    }\n                }\n                else{\n                    if(children[ch-'a'] != null)\n                        node = children[ch - 'a'];\n                }            \n            \n        }\n       \n        return node;\n    }\n    public boolean search(String word) {\n        TrieNode lastLetter = searchPrefix(root, word.toCharArray(), 0);\n        return (lastLetter != null ? lastLetter.getIsWord(): false);\n    }\n}'\n'class TrieNode{\n    char ch; \n    TrieNode[] children;\n    boolean isWord = false;\n    public TrieNode(){\n        children = new TrieNode[26];\n    }\n    public TrieNode(char letter) {\n        ch = letter; \n        children = new TrieNode[26];\n    }\n    public void setIsWord() {\n        isWord = true;\n    }\n    public boolean getIsWord() {\n        return isWord;\n    }\n}`"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If you don\\'t know about the data structure trie, this should be a hard problem."
                    },
                    {
                        "username": "paullam328",
                        "content": "Why is \\'backtracking\\' not included in the list of tags?"
                    },
                    {
                        "username": "user4851h",
                        "content": "Getting error at \\'.\\' comparison.plz help.\\n\\n\\nclass WordDictionary {\\n    ArrayList<String> arr;\\n    public WordDictionary() {\\n        arr=new ArrayList<String>();\\n    }\\n    \\n    public void addWord(String word) {\\n        arr.add(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        Boolean v=false;\\n     for(String s:arr){\\n         int j=0;\\n         for(int i=0;i<word.length();i++){\\n             if(word.charAt(i)==\\'.\\') {j++;}\\n             if(word.charAt(i)!=s.charAt(j)){\\n                 break;\\n             }else \\n             j++;\\n         }\\n         if(j==s.length()) return true;\\n         \\n     }return false;   \\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Some solutions which are consuming more than 17000 ms (17 seconds) in Python for some test cases marked as accepted. Is there a time limit? I thought more than 5 seconds for Python, It should have given TLE."
                    }
                ]
            },
            {
                "id": 1845789,
                "content": [
                    {
                        "username": "SSHshadow2222",
                        "content": "Solving the problem comes down to understanding how a [Trie](https://en.wikipedia.org/wiki/Trie) data structure works (you\\'ve been told this since the first hint of the problem), and after submitting and optimizing my code, I can assure you that the problem\\'s difficulty should and will stay as medium. (This is for all the people crying in the discussion section.)"
                    },
                    {
                        "username": "abhipatwari",
                        "content": "This search function is perfectly working in my local but it\\'s failing for last use case of \"b..\"\\nusual scenario for programmers :D `it\\'s working in my local`\\n\\npublic boolean search(String word) {\\n        TrieNode current = root;\\n        for(int i=0; i<word.length(); i++) {\\n            char ch = word.charAt(i);\\n            if (ch == \\'.\\') {\\n                for(Map.Entry<Character, TrieNode> entry: current.children.entrySet()) {\\n                    root = entry.getValue();\\n                    if(entry != null && search(word.substring(i+1))) return true;\\n                    return false;\\n                }\\n            }\\n            TrieNode child = current.children.get(ch);\\n            if (child == null) return false;\\n            current = child;\\n        }\\n        return current.endOfWord;\\n    }\\n}"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "the dot could be in the middle?"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Could someone please kindly tell me what's the issue with my code? Only 6 testcases passed :( I suspect it has something to do with the 2nd last line `return curr` but I can't be sure how I should fix that \n```\nclass WordDictionary(object):\n\n    def __init__(self):\n        self.root = {}\n\n    def addWord(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: None\n        \"\"\"\n        curr = self.root\n        for char in word:\n            if char not in curr:\n                curr[char] = {}\n            curr = curr[char]\n        curr[\"end\"] = True\n\n    def search(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        def dfs(idx, node):\n            curr = node\n            for i in range(idx, len(word)):\n                char = word[i]\n                if char == \".\":\n                    for child in curr.values():\n                        if dfs(i+1, child):\n                            return True\n                    return False\n                else:\n                    if char not in curr:\n                        return False\n                    curr = curr[char]\n        \n            return curr\n        \n        return dfs(0, self.root)\n```"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Test case fails:\\n```\\n[\"WordDictionary\",\"addWord\", \"search\"]\\n[[],[\"at\"],[\".\"]]\\n```\\n\\nOutput\\n```\\n[null,null,true]\\n```\\n\\nExpected\\n```\\n[null,null,false]\\n```\\n\\nExplanation. We are searching a prefix, not the whole word, so after we inserted any non empty string, it should return `true` for `.`. Because our trie contains at least one character."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think we are looking for prefixes, that isn\\'t mentioned anywhere. I believe you have to match the whole word.\\n\\nThe output fails because \".\" only represents a single char and \"at\" consists of 2. \"..\" does return true, as does \"at\". \\n\\nI could be wrong, it\\'s been a while since I did this one. "
                    },
                    {
                        "username": "nish06",
                        "content": "Can someone help me identify what is wrong with this code(Testcase 17 and later do not pass) ? \n `class WordDictionary {\n\n    TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        if(word == null || word.length() == 0)\n            return;\n        TrieNode curr = root; \n        for(char ch: word.toCharArray()) {\n            TrieNode child = curr.children[ch-'a'];\n            if(child == null){\n                child = new TrieNode(ch);\n                curr.children[ch-'a'] = child;\n            }\n            curr = child;\n        }\n        curr.setIsWord();\n    }\n    public TrieNode searchPrefix(TrieNode node, char[] letters, int index) {\n        for(int i = index; i < letters.length; i++) {\n            TrieNode[] children = node.children;\n            char ch = letters[i];\n                if(ch == '.'){\n                    for(int j = 0; j < children.length; j++){\n                        if(children[j] != null){\n                            TrieNode child = searchPrefix(children[j], letters, i+1);\n                            \n                            return child;\n                        }   \n                    }\n                }\n                else{\n                    if(children[ch-'a'] != null)\n                        node = children[ch - 'a'];\n                }            \n            \n        }\n       \n        return node;\n    }\n    public boolean search(String word) {\n        TrieNode lastLetter = searchPrefix(root, word.toCharArray(), 0);\n        return (lastLetter != null ? lastLetter.getIsWord(): false);\n    }\n}'\n'class TrieNode{\n    char ch; \n    TrieNode[] children;\n    boolean isWord = false;\n    public TrieNode(){\n        children = new TrieNode[26];\n    }\n    public TrieNode(char letter) {\n        ch = letter; \n        children = new TrieNode[26];\n    }\n    public void setIsWord() {\n        isWord = true;\n    }\n    public boolean getIsWord() {\n        return isWord;\n    }\n}`"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If you don\\'t know about the data structure trie, this should be a hard problem."
                    },
                    {
                        "username": "paullam328",
                        "content": "Why is \\'backtracking\\' not included in the list of tags?"
                    },
                    {
                        "username": "user4851h",
                        "content": "Getting error at \\'.\\' comparison.plz help.\\n\\n\\nclass WordDictionary {\\n    ArrayList<String> arr;\\n    public WordDictionary() {\\n        arr=new ArrayList<String>();\\n    }\\n    \\n    public void addWord(String word) {\\n        arr.add(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        Boolean v=false;\\n     for(String s:arr){\\n         int j=0;\\n         for(int i=0;i<word.length();i++){\\n             if(word.charAt(i)==\\'.\\') {j++;}\\n             if(word.charAt(i)!=s.charAt(j)){\\n                 break;\\n             }else \\n             j++;\\n         }\\n         if(j==s.length()) return true;\\n         \\n     }return false;   \\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Some solutions which are consuming more than 17000 ms (17 seconds) in Python for some test cases marked as accepted. Is there a time limit? I thought more than 5 seconds for Python, It should have given TLE."
                    }
                ]
            },
            {
                "id": 1839916,
                "content": [
                    {
                        "username": "SSHshadow2222",
                        "content": "Solving the problem comes down to understanding how a [Trie](https://en.wikipedia.org/wiki/Trie) data structure works (you\\'ve been told this since the first hint of the problem), and after submitting and optimizing my code, I can assure you that the problem\\'s difficulty should and will stay as medium. (This is for all the people crying in the discussion section.)"
                    },
                    {
                        "username": "abhipatwari",
                        "content": "This search function is perfectly working in my local but it\\'s failing for last use case of \"b..\"\\nusual scenario for programmers :D `it\\'s working in my local`\\n\\npublic boolean search(String word) {\\n        TrieNode current = root;\\n        for(int i=0; i<word.length(); i++) {\\n            char ch = word.charAt(i);\\n            if (ch == \\'.\\') {\\n                for(Map.Entry<Character, TrieNode> entry: current.children.entrySet()) {\\n                    root = entry.getValue();\\n                    if(entry != null && search(word.substring(i+1))) return true;\\n                    return false;\\n                }\\n            }\\n            TrieNode child = current.children.get(ch);\\n            if (child == null) return false;\\n            current = child;\\n        }\\n        return current.endOfWord;\\n    }\\n}"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "the dot could be in the middle?"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Could someone please kindly tell me what's the issue with my code? Only 6 testcases passed :( I suspect it has something to do with the 2nd last line `return curr` but I can't be sure how I should fix that \n```\nclass WordDictionary(object):\n\n    def __init__(self):\n        self.root = {}\n\n    def addWord(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: None\n        \"\"\"\n        curr = self.root\n        for char in word:\n            if char not in curr:\n                curr[char] = {}\n            curr = curr[char]\n        curr[\"end\"] = True\n\n    def search(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        def dfs(idx, node):\n            curr = node\n            for i in range(idx, len(word)):\n                char = word[i]\n                if char == \".\":\n                    for child in curr.values():\n                        if dfs(i+1, child):\n                            return True\n                    return False\n                else:\n                    if char not in curr:\n                        return False\n                    curr = curr[char]\n        \n            return curr\n        \n        return dfs(0, self.root)\n```"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Test case fails:\\n```\\n[\"WordDictionary\",\"addWord\", \"search\"]\\n[[],[\"at\"],[\".\"]]\\n```\\n\\nOutput\\n```\\n[null,null,true]\\n```\\n\\nExpected\\n```\\n[null,null,false]\\n```\\n\\nExplanation. We are searching a prefix, not the whole word, so after we inserted any non empty string, it should return `true` for `.`. Because our trie contains at least one character."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think we are looking for prefixes, that isn\\'t mentioned anywhere. I believe you have to match the whole word.\\n\\nThe output fails because \".\" only represents a single char and \"at\" consists of 2. \"..\" does return true, as does \"at\". \\n\\nI could be wrong, it\\'s been a while since I did this one. "
                    },
                    {
                        "username": "nish06",
                        "content": "Can someone help me identify what is wrong with this code(Testcase 17 and later do not pass) ? \n `class WordDictionary {\n\n    TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        if(word == null || word.length() == 0)\n            return;\n        TrieNode curr = root; \n        for(char ch: word.toCharArray()) {\n            TrieNode child = curr.children[ch-'a'];\n            if(child == null){\n                child = new TrieNode(ch);\n                curr.children[ch-'a'] = child;\n            }\n            curr = child;\n        }\n        curr.setIsWord();\n    }\n    public TrieNode searchPrefix(TrieNode node, char[] letters, int index) {\n        for(int i = index; i < letters.length; i++) {\n            TrieNode[] children = node.children;\n            char ch = letters[i];\n                if(ch == '.'){\n                    for(int j = 0; j < children.length; j++){\n                        if(children[j] != null){\n                            TrieNode child = searchPrefix(children[j], letters, i+1);\n                            \n                            return child;\n                        }   \n                    }\n                }\n                else{\n                    if(children[ch-'a'] != null)\n                        node = children[ch - 'a'];\n                }            \n            \n        }\n       \n        return node;\n    }\n    public boolean search(String word) {\n        TrieNode lastLetter = searchPrefix(root, word.toCharArray(), 0);\n        return (lastLetter != null ? lastLetter.getIsWord(): false);\n    }\n}'\n'class TrieNode{\n    char ch; \n    TrieNode[] children;\n    boolean isWord = false;\n    public TrieNode(){\n        children = new TrieNode[26];\n    }\n    public TrieNode(char letter) {\n        ch = letter; \n        children = new TrieNode[26];\n    }\n    public void setIsWord() {\n        isWord = true;\n    }\n    public boolean getIsWord() {\n        return isWord;\n    }\n}`"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If you don\\'t know about the data structure trie, this should be a hard problem."
                    },
                    {
                        "username": "paullam328",
                        "content": "Why is \\'backtracking\\' not included in the list of tags?"
                    },
                    {
                        "username": "user4851h",
                        "content": "Getting error at \\'.\\' comparison.plz help.\\n\\n\\nclass WordDictionary {\\n    ArrayList<String> arr;\\n    public WordDictionary() {\\n        arr=new ArrayList<String>();\\n    }\\n    \\n    public void addWord(String word) {\\n        arr.add(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        Boolean v=false;\\n     for(String s:arr){\\n         int j=0;\\n         for(int i=0;i<word.length();i++){\\n             if(word.charAt(i)==\\'.\\') {j++;}\\n             if(word.charAt(i)!=s.charAt(j)){\\n                 break;\\n             }else \\n             j++;\\n         }\\n         if(j==s.length()) return true;\\n         \\n     }return false;   \\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Some solutions which are consuming more than 17000 ms (17 seconds) in Python for some test cases marked as accepted. Is there a time limit? I thought more than 5 seconds for Python, It should have given TLE."
                    }
                ]
            },
            {
                "id": 1837998,
                "content": [
                    {
                        "username": "SSHshadow2222",
                        "content": "Solving the problem comes down to understanding how a [Trie](https://en.wikipedia.org/wiki/Trie) data structure works (you\\'ve been told this since the first hint of the problem), and after submitting and optimizing my code, I can assure you that the problem\\'s difficulty should and will stay as medium. (This is for all the people crying in the discussion section.)"
                    },
                    {
                        "username": "abhipatwari",
                        "content": "This search function is perfectly working in my local but it\\'s failing for last use case of \"b..\"\\nusual scenario for programmers :D `it\\'s working in my local`\\n\\npublic boolean search(String word) {\\n        TrieNode current = root;\\n        for(int i=0; i<word.length(); i++) {\\n            char ch = word.charAt(i);\\n            if (ch == \\'.\\') {\\n                for(Map.Entry<Character, TrieNode> entry: current.children.entrySet()) {\\n                    root = entry.getValue();\\n                    if(entry != null && search(word.substring(i+1))) return true;\\n                    return false;\\n                }\\n            }\\n            TrieNode child = current.children.get(ch);\\n            if (child == null) return false;\\n            current = child;\\n        }\\n        return current.endOfWord;\\n    }\\n}"
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "the dot could be in the middle?"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Could someone please kindly tell me what's the issue with my code? Only 6 testcases passed :( I suspect it has something to do with the 2nd last line `return curr` but I can't be sure how I should fix that \n```\nclass WordDictionary(object):\n\n    def __init__(self):\n        self.root = {}\n\n    def addWord(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: None\n        \"\"\"\n        curr = self.root\n        for char in word:\n            if char not in curr:\n                curr[char] = {}\n            curr = curr[char]\n        curr[\"end\"] = True\n\n    def search(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        def dfs(idx, node):\n            curr = node\n            for i in range(idx, len(word)):\n                char = word[i]\n                if char == \".\":\n                    for child in curr.values():\n                        if dfs(i+1, child):\n                            return True\n                    return False\n                else:\n                    if char not in curr:\n                        return False\n                    curr = curr[char]\n        \n            return curr\n        \n        return dfs(0, self.root)\n```"
                    },
                    {
                        "username": "yan-khonski-it",
                        "content": "Test case fails:\\n```\\n[\"WordDictionary\",\"addWord\", \"search\"]\\n[[],[\"at\"],[\".\"]]\\n```\\n\\nOutput\\n```\\n[null,null,true]\\n```\\n\\nExpected\\n```\\n[null,null,false]\\n```\\n\\nExplanation. We are searching a prefix, not the whole word, so after we inserted any non empty string, it should return `true` for `.`. Because our trie contains at least one character."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don\\'t think we are looking for prefixes, that isn\\'t mentioned anywhere. I believe you have to match the whole word.\\n\\nThe output fails because \".\" only represents a single char and \"at\" consists of 2. \"..\" does return true, as does \"at\". \\n\\nI could be wrong, it\\'s been a while since I did this one. "
                    },
                    {
                        "username": "nish06",
                        "content": "Can someone help me identify what is wrong with this code(Testcase 17 and later do not pass) ? \n `class WordDictionary {\n\n    TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        if(word == null || word.length() == 0)\n            return;\n        TrieNode curr = root; \n        for(char ch: word.toCharArray()) {\n            TrieNode child = curr.children[ch-'a'];\n            if(child == null){\n                child = new TrieNode(ch);\n                curr.children[ch-'a'] = child;\n            }\n            curr = child;\n        }\n        curr.setIsWord();\n    }\n    public TrieNode searchPrefix(TrieNode node, char[] letters, int index) {\n        for(int i = index; i < letters.length; i++) {\n            TrieNode[] children = node.children;\n            char ch = letters[i];\n                if(ch == '.'){\n                    for(int j = 0; j < children.length; j++){\n                        if(children[j] != null){\n                            TrieNode child = searchPrefix(children[j], letters, i+1);\n                            \n                            return child;\n                        }   \n                    }\n                }\n                else{\n                    if(children[ch-'a'] != null)\n                        node = children[ch - 'a'];\n                }            \n            \n        }\n       \n        return node;\n    }\n    public boolean search(String word) {\n        TrieNode lastLetter = searchPrefix(root, word.toCharArray(), 0);\n        return (lastLetter != null ? lastLetter.getIsWord(): false);\n    }\n}'\n'class TrieNode{\n    char ch; \n    TrieNode[] children;\n    boolean isWord = false;\n    public TrieNode(){\n        children = new TrieNode[26];\n    }\n    public TrieNode(char letter) {\n        ch = letter; \n        children = new TrieNode[26];\n    }\n    public void setIsWord() {\n        isWord = true;\n    }\n    public boolean getIsWord() {\n        return isWord;\n    }\n}`"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "If you don\\'t know about the data structure trie, this should be a hard problem."
                    },
                    {
                        "username": "paullam328",
                        "content": "Why is \\'backtracking\\' not included in the list of tags?"
                    },
                    {
                        "username": "user4851h",
                        "content": "Getting error at \\'.\\' comparison.plz help.\\n\\n\\nclass WordDictionary {\\n    ArrayList<String> arr;\\n    public WordDictionary() {\\n        arr=new ArrayList<String>();\\n    }\\n    \\n    public void addWord(String word) {\\n        arr.add(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        Boolean v=false;\\n     for(String s:arr){\\n         int j=0;\\n         for(int i=0;i<word.length();i++){\\n             if(word.charAt(i)==\\'.\\') {j++;}\\n             if(word.charAt(i)!=s.charAt(j)){\\n                 break;\\n             }else \\n             j++;\\n         }\\n         if(j==s.length()) return true;\\n         \\n     }return false;   \\n    }\\n}\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary obj = new WordDictionary();\\n * obj.addWord(word);\\n * boolean param_2 = obj.search(word);\\n */"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Some solutions which are consuming more than 17000 ms (17 seconds) in Python for some test cases marked as accepted. Is there a time limit? I thought more than 5 seconds for Python, It should have given TLE."
                    }
                ]
            },
            {
                "id": 1837944,
                "content": [
                    {
                        "username": "akeempositive",
                        "content": "After solving this challenge with acceptable answer.... All the edge cases are very much.. And this is one challenge that tests requires performance tuning at every stage to pass it acceptably... I was thinking with my data structure and memory usage, I will have a poor rating on memory beats.... But it still beats 97% which is exactly why I think this is freaking hard a challenge "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "No way! I just used the stupidest possible brute force solution with arrays and its build-in find method and still got accepted and moreover it says my solution is faster than 96%  and uses less memory than 97% of other solutions, how is that even possible?? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "aryan20022003",
                        "content": "getting error use Array of Node and use memset for setting node NULL"
                    },
                    {
                        "username": "coderinterview",
                        "content": "I am using trie to store individual charcters in form of tree. \\nFor search I used BFS using queue, which should be faster than DFS using recursion and I am able to pass the testcases by \"run\", but when I \"submit\" I get TLE for same test cases. \\nCan someone please explain what I am missing?\\n```\\nclass WordDictionary {\\nprivate:\\n    struct node{\\n        bool end;\\n        node* v[26];\\n        node(){\\n            end=false;\\n            for(int i=0;i<26;i++){\\n                v[i]=nullptr;\\n            }\\n        }\\n        ~node() {}\\n    };\\n    node *head;\\npublic:        \\n    WordDictionary() {\\n        head = new node();\\n    }\\n    \\n    void addWord(string word) {\\n        node *curr = head;        \\n        for(char &c: word){\\n            if(curr->v[c-\\'a\\'] == nullptr) curr->v[c-\\'a\\'] = new node();\\n            curr = curr->v[c-\\'a\\'];\\n        }\\n        curr->end=true;\\n    }\\n    \\n    bool search(string word) {\\n        // node *curr=head;\\n        queue<node*> q;\\n        q.push(head);\\n        for(char &c: word){\\n            int s = q.size();\\n            while(s--){\\n                node *curr = q.front();\\n                q.pop();\\n                if(c == \\'.\\'){\\n                    for(int i=0;i<26;i++){\\n                        if(curr->v[i] != nullptr) q.push(curr->v[i]);\\n                    }\\n                }\\n                else if(curr->v[c-\\'a\\'] != nullptr) q.push(curr->v[c-\\'a\\']);                \\n            }\\n        }\\n        while(!q.empty()){\\n            node *curr = q.front();\\n            q.pop();\\n            if(curr->end) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```"
                    },
                    {
                        "username": "vadim_spirin",
                        "content": "7/29 testcases passed. Leetcode says that my output is [null,null,null,true,true,true,true,true,true], but it expected [null,null,null,true,true,false,true,false,false]. I tried it in my IDE and my code outputs exactly what is expected. Why does it work like that??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Your solution might have some state that is not being reset properly between test cases."
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone help how this solution is giving WA on this TC :\n\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]] \n\n `your inline code..\n\npublic class TrieNode\n{\n    HashMap<Character,TrieNode>store;\n    boolean is_end;\n    TrieNode()\n    {\n        store = new HashMap<>();\n        is_end = false;\n    }\n}\nclass WordDictionary {\n    private TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        TrieNode curNode = root;\n        for(char c:word.toCharArray())\n        {\n            if(!curNode.store.containsKey(c))\n            {\n                curNode.store.put(c,new TrieNode());\n            }\n            curNode = curNode.store.get(c);\n        }\n        curNode.is_end = true;\n    }\n    \n    public boolean search(String word) {\n    \n       TrieNode curNode = root;\n       return solve(curNode,word,0);\n    }\n\n    public boolean solve(TrieNode node,String word,int idx)\n    {\n        if(idx == word.length())\n        {\n            return node.is_end;\n        }\n        char c = word.charAt(idx);\n        if(c == '.')\n        {\n            for(TrieNode child : node.store.values())\n            {\n                boolean val = solve(child,word,idx+1);\n                if(val == true)\n                {\n                    return true;\n                }\n                return false;\n            }\n        }\n         \n             TrieNode child = node.store.get(c);\n             if(child == null)\n             {\n                 return false;\n             }\n             return solve(child,word,idx+1);\n         }     \n    \n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */\n\n\n\n.your inline code...`"
                    },
                    {
                        "username": "paullam328",
                        "content": "You don't need a TrieNode in the first place.  Optimize that part first and just use nested HashTable.  isEnd can be replaced by HashMap['end'] = {}.  Go back to \"Implement Trie\" problem and get the most memory-optimized solution first, then work on this problem, your code will be much simpler and easier to debug in that sense."
                    },
                    {
                        "username": "Heisenberg2003",
                        "content": "```\\nclass WordDictionary {\\npublic:\\n    struct TrieNode\\n    {\\n        TrieNode* childs[26];\\n    };\\n\\n    unordered_map<TrieNode*,bool>isTerminal;\\n    TrieNode* root=new TrieNode();\\n\\n    WordDictionary() {\\n        root=new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        TrieNode* node=root;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            if(node->childs[word[i]-\\'a\\']==NULL)\\n            {\\n                node->childs[word[i]-\\'a\\']=new TrieNode();\\n            }\\n            node=node->childs[word[i]-\\'a\\'];\\n        }\\n        isTerminal[node]=true;\\n        return;\\n    }\\n\\n    bool searchstr(string str)\\n    {\\n        TrieNode* node=root;\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if(node->childs[str[i]-\\'a\\']==NULL)\\n            {\\n                return false;\\n            }\\n            node=node->childs[str[i]-\\'a\\'];\\n        }\\n        return isTerminal[node];\\n    }\\n\\n    void permute(vector<string>&ans,string word,int ptr)\\n    {\\n        if(ptr==word.size())\\n        {\\n            ans.push_back(word);\\n            return;\\n        }\\n        if(word[ptr]==\\'.\\')\\n        {\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n                word[ptr]=ch;\\n                permute(ans,word,ptr+1);\\n            }\\n        }\\n        else\\n        {\\n            permute(ans,word,ptr+1);\\n        }\\n        return;\\n    }\\n    \\n    bool search(string word) {\\n        vector<string>possible;\\n        permute(possible,word,0);\\n        bool found=false;\\n        for(auto str:possible)\\n        {\\n            found=found||searchstr(str);\\n        }\\n        return found;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```\\nWhy Does This Give TLE?"
                    },
                    {
                        "username": "iamhariom28",
                        "content": "class Node{\n    Node* links[26];\n    bool flag;\npublic:\n    bool containsKey(char ch){\n        return links[ch-'a']!=NULL;\n    }\n    void insertKey(char ch, Node* node){\n        links[ch-'a'] = node;\n    }\n    Node* getNext(char ch){\n        return links[ch-'a'];\n    }\n    void setEnd(){\n        flag = true;\n    }\n    bool isEnd(){\n        return flag;\n    }\n};\n\nclass WordDictionary {\n    Node* root;\npublic:\n    WordDictionary() {\n        root = new Node();\n    }\n    \n    void addWord(string word) {\n        Node* node = root;\n        for(int i=0;i<word.size();i++){\n            if(!node->containsKey(word[i])){\n                node->insertKey(word[i], new Node());\n            }\n            node = node->getNext(word[i]);\n        }\n        node->setEnd();\n    }\n    \n    bool search(string word) {\n        Node* node = root;\n        if(word.size()==0) return node->isEnd();\n\n        for(int i=0;i<word.size();i++){\n            if(word[i]=='.'){\n                bool found = false;\n                for(char ch = 'a';ch <= 'z';ch++){\n                    if(node->containsKey(ch)){\n                        found = true;\n                        node = node->getNext(ch);\n                        break;\n                    }\n                }\n                if(!found) return false;\n            }else{\n                if(node->containsKey(word[i])){\n                    cout<<word[i]<<endl;\n                    node = node->getNext(word[i]);\n                }else return false;\n            }\n        }\n        return node->isEnd();\n    }\n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary* obj = new WordDictionary();\n * obj->addWord(word);\n * bool param_2 = obj->search(word);\n */\n\n\n\nIt is giving me wrong answer for given test case, can anyone tell me what mistake I am doing?\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]]\n\nOutput:\n[null,null,null,null,null,false,false,null,false,true,false,false,true,false]\nExpected output:\n[null,null,null,null,null,false,false,null,true,true,false,false,true,false]\n\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Hey, I have done this problem by doubly LL. and after 20 test cases it shows TLE. can any one tell the best approach of comparing the dot(.) based word with previous words ? Actually i have added another another loop over there so its taking O(n2). thats why its giving TLE i guess."
                    },
                    {
                        "username": "user9157cE",
                        "content": "How ? I can\\'t pass testcase 17, I have ONE false value, how am I suppose to see the error when there is 3300+ different methods calls. I just don\\'t see how I can isolate the error to fix it. And I can\\'t imagine of any way why my code is wrong. It passes all edge case I can think of. It would be great if leetcode can highlight what input caused the mistake. \\nI can only think of making a function that count all output values, gives me all wrong output and do the same with the input to get the 1423th that gives me the wrong value. but even then what ? there is hundreds of words in the dictionary already. I don\\'t know how to go further here :/"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) You're welcome! Most people never reply so I'm glad to help someone who appreciates it.\n\nMy mistake on the initialization thing. I believe it's mostly a stylistic choice. It just looked unfamiliar to me. I googled it shortly afterwards and edited my comment to remove that, but you probably saw the original version of my comment in the email notification.\n\nNot using a `TrieNode` was similar in that it mostly looked strange, but after thinking about it, I can see that your way should work. The main reason to use a `TrieNode` is to have a separate data class. The class storing the data doesn't really need the `addWord()` and `Search()` methods on it. You see this in places like linked list problems too. The linked list node and linked list class are usually separate.\n\nHaving separate classes for the node and trie also gives you a place to store 'global' data about the trie. For example, if you want to keep a count of the number of words in the trie, that goes in the trie class not the node class. With your current design it would have to go into `WordDictionary` but then every node also has a count variable which is unused."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01) Thanks a lot ! I didn\\'t imagine someone would\\'ve helped me so much, you\\'ve made my day !\\n\\nI simply stored endOfWord one step too early, I don\\'t know how it worked so far like that lol. But basically if I add a word \"c\" the whole first level of letter would get endOfWord = true but I needed to do ```dict[letter].endOfWord = true``` instead. So adding adding \"mfqef\" and search for \"m\" is returning true even if there was never a \"m\" in the array.\\n\\nAs for the nodes by looking at others solution I just did not see the use of it here, I imagine there is a good reason to work like that but haven\\'t found it yet.\\n\\nAnd for the variable is it better like this ? \\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord;\\n    WordDictionary[] dict;\\n    int index;\\n    \\n    public WordDictionary() {\\n        this(-1);\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n        this.dict = new WordDictionary[26];\\n    }\\n}\\n```\\nI honestly don\\'t know the difference between initializing the variable in the class or in the constructor. (if there is no variable in the constructor)\\n\\nThanks again for your fast answers, you\\'ve helped me a lot ! My answer beat 74% so I\\'m very happy with it. I think I can optimize it a bit but not today lol.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) Ok, thanks for explaining. Now I understand what you meant by counting output values.\n\nI've cut the test case down a lot. I need to go to bed now, but hopefully you can work on it some more. It's 86 `addWord` calls and a single `search` at the end that fails. Drastically smaller, and it should be easier to remove more `addWord` calls now since you don't have the problem of different interleaved methods.\n\n```\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\"]\n```\n\n```\n[[],[\"xgvk\"],[\"wykzbvwdsoyfowqicymzd\"],[\"xajbtjyjuwgoynjgu\"],[\"qsibzxaorktypkfg\"],[\"vbycuvrkbcq\"],[\"sm\"],[\"fkqclfmvzpzpnbvz\"],[\"jpnneostllnnma\"],[\"zvmtfg\"],[\"lboe\"],[\"jypzkxnzc\"],[\"qes\"],[\"jioqlytzqx\"],[\"fojsjyiz\"],[\"qkprluekewtsftvbrjndpt\"],[\"mwsgyywmmkzmy\"],[\"tcjmitm\"],[\"pybk\"],[\"poljqcitty\"],[\"qfdabgsvkboyaq\"],[\"pvreuprpvoycadnsxaajrkh\"],[\"sv\"],[\"knmxzabetvqehv\"],[\"ziazu\"],[\"ghhelrzgbsmxkrnezif\"],[\"fn\"],[\"tnjcttrsozynjpqhox\"],[\"qhxcfujxmayzlsrctmsa\"],[\"fyaaivfrupktdgw\"],[\"aiurwhjnhxfqokgiumbeyfcwk\"],[\"y\"],[\"pqxtikjgislbvr\"],[\"halneyxidcqt\"],[\"ugifaaxdcqioabmy\"],[\"dlmcs\"],[\"monsnupyvxyqkegmtmb\"],[\"oexhcxlfcnyijwquaw\"],[\"phetnfndiwyce\"],[\"lofnodyf\"],[\"brrwqho\"],[\"xxaolhw\"],[\"pqmlmuhradvjsx\"],[\"brlhfbvcom\"],[\"v\"],[\"yuhscpvbe\"],[\"ejiavk\"],[\"kbhrkecoaomocvdss\"],[\"mecwmipivkrlotxtjavs\"],[\"hfnconmujvgumljeiakpejgd\"],[\"kwrxzundledqdqbawtrrthps\"],[\"qtzjqxsh\"],[\"apsokathssqpsblye\"],[\"sgvnrpegeqclxtclwzzh\"],[\"eougulzekfcqkxvamtd\"],[\"soasdxrbagqgtbi\"],[\"fdtwtnoh\"],[\"maxsbmlojhhvrumynwppqvm\"],[\"wqopnyebntkkvrea\"],[\"xxnruy\"],[\"eiovag\"],[\"ieryygffvhjcvwrhssvgqqjl\"],[\"g\"],[\"bxbzeccraoqzqreqomg\"],[\"ccg\"],[\"nueebqsegnjnybbs\"],[\"lbcsuh\"],[\"c\"],[\"tcvgwubm\"],[\"nrkwveryqc\"],[\"scapopfqf\"],[\"druwthqeowerqgskfzwvp\"],[\"mvsw\"],[\"oogbspsthyxmlqpqgdsnv\"],[\"hzzvtuhkpimxrxwn\"],[\"wxyrykx\"],[\"wftaqtjkqgabepcpboplcsz\"],[\"gprfavikjmxovw\"],[\"qnmhflhmonzwfdolvaoq\"],[\"fuymduy\"],[\"j\"],[\"tjedwvjtdghhkavwnuyfgkie\"],[\"gtyybcgckuotlmitribvb\"],[\"zchqgemhqjpoxla\"],[\"ldzhusmikkebme\"],[\"imnhhzj\"],[\"yylrxnnlpixqod\"],[\"m\"]]\n```\n\nBy the way, using `WordDictionary` as your node class instead of defining a separate `TrieNode` class stood out to me as being strange.\n\nMaybe your problem doesn't lie there, but it's something to consider."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01)  Thanks for the reply ! I\\'m gonna try harder a bit later but unfortunnately I\\'ve fought about your solution before. \\n\\nIf Leetcode can highligh the output #1681 they could highlight the input #1681 (its a search methods).\\n\\nI can\\'t cut the test case since they are all different length and in order. If I cut randomly 100 input then all the other will have an offset and won\\'t be valid since there is \"search\" and \"addWord\" methods and they don\\'t accept the same input. So cutting half the input would still require me to count each one exactly so they remain in order.\\n\\nMy solution isn\\'t like the other one I\\'ve seen, and nearly all other solutions are the same anyway, they all have the same approach and structure of code. So yeah I could go look a video on how they\\'ve done this but I won\\'t learn anything if I don\\'t know where\\'s my mistake. And I don\\'t think I have the wrong approach since 99% of my answer are correct.\\n\\nAnd yes a debugger would be helpful there, It would be a pain to create an entire new program just to make a debugger accept the input and calling my methods. Leetcode is basically forcing the use of their debugger here but as a student I can\\'t afford the premium, it\\'s half of what I pay for a year of college.\\n\\nAnyway here is my code , if anyone can find a SHORT testcase that doesn\\'t work it would help me greatly :D\\n\\n\\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord = false;\\n    WordDictionary[] dict = new WordDictionary[26];\\n    int index;\\n    \\n    public WordDictionary() {\\n        this.index = 0;\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n    }\\n    \\n    public void addWord(String word) {\\n        if(dict[toInt(word.charAt(index))] == null){\\n            dict[toInt(word.charAt(index))] = new WordDictionary(index);\\n        }\\n        if(index == word.length()-1){\\n            endOfWord = true;\\n        }else dict[toInt(word.charAt(index))].addWord(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        if(index == word.length()-1) return endOfWord && (word.charAt(index) == \\'.\\' ? true : dict[toInt(word.charAt(index))] != null);\\n        if(word.charAt(index) == \\'.\\'){\\n            for(WordDictionary d : dict){\\n                if(d != null && d.search(word)) return true;\\n            }\\n            return false;\\n        }else if(dict[toInt(word.charAt(index))] != null){\\n            return dict[toInt(word.charAt(index))].search(word);\\n        }\\n        return false;\\n    }\\n\\n    private int toInt(char c){\\n        return c-\\'a\\';\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It's a tough situation. I don't see how LeetCode could highlight what input caused the bug. It's obviously a combination of multiple method calls that triggered the bug.\n\nYou've got a few options (not necessarily in order):\n* Try to cut down the test case while still having it fail. It's tedious but I've done this. You sort of \"binary search\" it by cutting it in half and seeing if either of the halves fails. Can you reduce the number of addWord calls while still getting it to fail the search call? Then try to remove the other search calls. If you can shrink it enough you can get to a small enough test case to debug. Don't get stuck on exactly halving it though. You might have to play around with how many method calls you remove.\n* If you have LeetCode Premium you can use the debugger. Or set up a local debugger on your own system and try to debug it. Even though there are hundreds of words in the trie, you might still notice something wrong while debugging.\n* To aid in debugging add a method to print the entire trie.\n*  Review your solution very carefully. First take a break to clear your mind. Don't think of it as \"how can this possibly be wrong\". Think of it as \"I know something is wrong and I can find it. It's only 20-30 lines of code\".\n* Compare against other people's solutions. If you know their solution is correct, then any places where your code is different are prime suspects.\n* Get someone else to review your solution. They won't have your preconceptions about how your code works and the bug may be obvious to them.\n\nIt's not fun but it's good practice. We all have to debug code at work, and this is still easier than some non-reproducible bug. At least you know what input causes it to fail."
                    }
                ]
            },
            {
                "id": 1837905,
                "content": [
                    {
                        "username": "akeempositive",
                        "content": "After solving this challenge with acceptable answer.... All the edge cases are very much.. And this is one challenge that tests requires performance tuning at every stage to pass it acceptably... I was thinking with my data structure and memory usage, I will have a poor rating on memory beats.... But it still beats 97% which is exactly why I think this is freaking hard a challenge "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "No way! I just used the stupidest possible brute force solution with arrays and its build-in find method and still got accepted and moreover it says my solution is faster than 96%  and uses less memory than 97% of other solutions, how is that even possible?? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "aryan20022003",
                        "content": "getting error use Array of Node and use memset for setting node NULL"
                    },
                    {
                        "username": "coderinterview",
                        "content": "I am using trie to store individual charcters in form of tree. \\nFor search I used BFS using queue, which should be faster than DFS using recursion and I am able to pass the testcases by \"run\", but when I \"submit\" I get TLE for same test cases. \\nCan someone please explain what I am missing?\\n```\\nclass WordDictionary {\\nprivate:\\n    struct node{\\n        bool end;\\n        node* v[26];\\n        node(){\\n            end=false;\\n            for(int i=0;i<26;i++){\\n                v[i]=nullptr;\\n            }\\n        }\\n        ~node() {}\\n    };\\n    node *head;\\npublic:        \\n    WordDictionary() {\\n        head = new node();\\n    }\\n    \\n    void addWord(string word) {\\n        node *curr = head;        \\n        for(char &c: word){\\n            if(curr->v[c-\\'a\\'] == nullptr) curr->v[c-\\'a\\'] = new node();\\n            curr = curr->v[c-\\'a\\'];\\n        }\\n        curr->end=true;\\n    }\\n    \\n    bool search(string word) {\\n        // node *curr=head;\\n        queue<node*> q;\\n        q.push(head);\\n        for(char &c: word){\\n            int s = q.size();\\n            while(s--){\\n                node *curr = q.front();\\n                q.pop();\\n                if(c == \\'.\\'){\\n                    for(int i=0;i<26;i++){\\n                        if(curr->v[i] != nullptr) q.push(curr->v[i]);\\n                    }\\n                }\\n                else if(curr->v[c-\\'a\\'] != nullptr) q.push(curr->v[c-\\'a\\']);                \\n            }\\n        }\\n        while(!q.empty()){\\n            node *curr = q.front();\\n            q.pop();\\n            if(curr->end) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```"
                    },
                    {
                        "username": "vadim_spirin",
                        "content": "7/29 testcases passed. Leetcode says that my output is [null,null,null,true,true,true,true,true,true], but it expected [null,null,null,true,true,false,true,false,false]. I tried it in my IDE and my code outputs exactly what is expected. Why does it work like that??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Your solution might have some state that is not being reset properly between test cases."
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone help how this solution is giving WA on this TC :\n\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]] \n\n `your inline code..\n\npublic class TrieNode\n{\n    HashMap<Character,TrieNode>store;\n    boolean is_end;\n    TrieNode()\n    {\n        store = new HashMap<>();\n        is_end = false;\n    }\n}\nclass WordDictionary {\n    private TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        TrieNode curNode = root;\n        for(char c:word.toCharArray())\n        {\n            if(!curNode.store.containsKey(c))\n            {\n                curNode.store.put(c,new TrieNode());\n            }\n            curNode = curNode.store.get(c);\n        }\n        curNode.is_end = true;\n    }\n    \n    public boolean search(String word) {\n    \n       TrieNode curNode = root;\n       return solve(curNode,word,0);\n    }\n\n    public boolean solve(TrieNode node,String word,int idx)\n    {\n        if(idx == word.length())\n        {\n            return node.is_end;\n        }\n        char c = word.charAt(idx);\n        if(c == '.')\n        {\n            for(TrieNode child : node.store.values())\n            {\n                boolean val = solve(child,word,idx+1);\n                if(val == true)\n                {\n                    return true;\n                }\n                return false;\n            }\n        }\n         \n             TrieNode child = node.store.get(c);\n             if(child == null)\n             {\n                 return false;\n             }\n             return solve(child,word,idx+1);\n         }     \n    \n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */\n\n\n\n.your inline code...`"
                    },
                    {
                        "username": "paullam328",
                        "content": "You don't need a TrieNode in the first place.  Optimize that part first and just use nested HashTable.  isEnd can be replaced by HashMap['end'] = {}.  Go back to \"Implement Trie\" problem and get the most memory-optimized solution first, then work on this problem, your code will be much simpler and easier to debug in that sense."
                    },
                    {
                        "username": "Heisenberg2003",
                        "content": "```\\nclass WordDictionary {\\npublic:\\n    struct TrieNode\\n    {\\n        TrieNode* childs[26];\\n    };\\n\\n    unordered_map<TrieNode*,bool>isTerminal;\\n    TrieNode* root=new TrieNode();\\n\\n    WordDictionary() {\\n        root=new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        TrieNode* node=root;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            if(node->childs[word[i]-\\'a\\']==NULL)\\n            {\\n                node->childs[word[i]-\\'a\\']=new TrieNode();\\n            }\\n            node=node->childs[word[i]-\\'a\\'];\\n        }\\n        isTerminal[node]=true;\\n        return;\\n    }\\n\\n    bool searchstr(string str)\\n    {\\n        TrieNode* node=root;\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if(node->childs[str[i]-\\'a\\']==NULL)\\n            {\\n                return false;\\n            }\\n            node=node->childs[str[i]-\\'a\\'];\\n        }\\n        return isTerminal[node];\\n    }\\n\\n    void permute(vector<string>&ans,string word,int ptr)\\n    {\\n        if(ptr==word.size())\\n        {\\n            ans.push_back(word);\\n            return;\\n        }\\n        if(word[ptr]==\\'.\\')\\n        {\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n                word[ptr]=ch;\\n                permute(ans,word,ptr+1);\\n            }\\n        }\\n        else\\n        {\\n            permute(ans,word,ptr+1);\\n        }\\n        return;\\n    }\\n    \\n    bool search(string word) {\\n        vector<string>possible;\\n        permute(possible,word,0);\\n        bool found=false;\\n        for(auto str:possible)\\n        {\\n            found=found||searchstr(str);\\n        }\\n        return found;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```\\nWhy Does This Give TLE?"
                    },
                    {
                        "username": "iamhariom28",
                        "content": "class Node{\n    Node* links[26];\n    bool flag;\npublic:\n    bool containsKey(char ch){\n        return links[ch-'a']!=NULL;\n    }\n    void insertKey(char ch, Node* node){\n        links[ch-'a'] = node;\n    }\n    Node* getNext(char ch){\n        return links[ch-'a'];\n    }\n    void setEnd(){\n        flag = true;\n    }\n    bool isEnd(){\n        return flag;\n    }\n};\n\nclass WordDictionary {\n    Node* root;\npublic:\n    WordDictionary() {\n        root = new Node();\n    }\n    \n    void addWord(string word) {\n        Node* node = root;\n        for(int i=0;i<word.size();i++){\n            if(!node->containsKey(word[i])){\n                node->insertKey(word[i], new Node());\n            }\n            node = node->getNext(word[i]);\n        }\n        node->setEnd();\n    }\n    \n    bool search(string word) {\n        Node* node = root;\n        if(word.size()==0) return node->isEnd();\n\n        for(int i=0;i<word.size();i++){\n            if(word[i]=='.'){\n                bool found = false;\n                for(char ch = 'a';ch <= 'z';ch++){\n                    if(node->containsKey(ch)){\n                        found = true;\n                        node = node->getNext(ch);\n                        break;\n                    }\n                }\n                if(!found) return false;\n            }else{\n                if(node->containsKey(word[i])){\n                    cout<<word[i]<<endl;\n                    node = node->getNext(word[i]);\n                }else return false;\n            }\n        }\n        return node->isEnd();\n    }\n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary* obj = new WordDictionary();\n * obj->addWord(word);\n * bool param_2 = obj->search(word);\n */\n\n\n\nIt is giving me wrong answer for given test case, can anyone tell me what mistake I am doing?\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]]\n\nOutput:\n[null,null,null,null,null,false,false,null,false,true,false,false,true,false]\nExpected output:\n[null,null,null,null,null,false,false,null,true,true,false,false,true,false]\n\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Hey, I have done this problem by doubly LL. and after 20 test cases it shows TLE. can any one tell the best approach of comparing the dot(.) based word with previous words ? Actually i have added another another loop over there so its taking O(n2). thats why its giving TLE i guess."
                    },
                    {
                        "username": "user9157cE",
                        "content": "How ? I can\\'t pass testcase 17, I have ONE false value, how am I suppose to see the error when there is 3300+ different methods calls. I just don\\'t see how I can isolate the error to fix it. And I can\\'t imagine of any way why my code is wrong. It passes all edge case I can think of. It would be great if leetcode can highlight what input caused the mistake. \\nI can only think of making a function that count all output values, gives me all wrong output and do the same with the input to get the 1423th that gives me the wrong value. but even then what ? there is hundreds of words in the dictionary already. I don\\'t know how to go further here :/"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) You're welcome! Most people never reply so I'm glad to help someone who appreciates it.\n\nMy mistake on the initialization thing. I believe it's mostly a stylistic choice. It just looked unfamiliar to me. I googled it shortly afterwards and edited my comment to remove that, but you probably saw the original version of my comment in the email notification.\n\nNot using a `TrieNode` was similar in that it mostly looked strange, but after thinking about it, I can see that your way should work. The main reason to use a `TrieNode` is to have a separate data class. The class storing the data doesn't really need the `addWord()` and `Search()` methods on it. You see this in places like linked list problems too. The linked list node and linked list class are usually separate.\n\nHaving separate classes for the node and trie also gives you a place to store 'global' data about the trie. For example, if you want to keep a count of the number of words in the trie, that goes in the trie class not the node class. With your current design it would have to go into `WordDictionary` but then every node also has a count variable which is unused."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01) Thanks a lot ! I didn\\'t imagine someone would\\'ve helped me so much, you\\'ve made my day !\\n\\nI simply stored endOfWord one step too early, I don\\'t know how it worked so far like that lol. But basically if I add a word \"c\" the whole first level of letter would get endOfWord = true but I needed to do ```dict[letter].endOfWord = true``` instead. So adding adding \"mfqef\" and search for \"m\" is returning true even if there was never a \"m\" in the array.\\n\\nAs for the nodes by looking at others solution I just did not see the use of it here, I imagine there is a good reason to work like that but haven\\'t found it yet.\\n\\nAnd for the variable is it better like this ? \\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord;\\n    WordDictionary[] dict;\\n    int index;\\n    \\n    public WordDictionary() {\\n        this(-1);\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n        this.dict = new WordDictionary[26];\\n    }\\n}\\n```\\nI honestly don\\'t know the difference between initializing the variable in the class or in the constructor. (if there is no variable in the constructor)\\n\\nThanks again for your fast answers, you\\'ve helped me a lot ! My answer beat 74% so I\\'m very happy with it. I think I can optimize it a bit but not today lol.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) Ok, thanks for explaining. Now I understand what you meant by counting output values.\n\nI've cut the test case down a lot. I need to go to bed now, but hopefully you can work on it some more. It's 86 `addWord` calls and a single `search` at the end that fails. Drastically smaller, and it should be easier to remove more `addWord` calls now since you don't have the problem of different interleaved methods.\n\n```\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\"]\n```\n\n```\n[[],[\"xgvk\"],[\"wykzbvwdsoyfowqicymzd\"],[\"xajbtjyjuwgoynjgu\"],[\"qsibzxaorktypkfg\"],[\"vbycuvrkbcq\"],[\"sm\"],[\"fkqclfmvzpzpnbvz\"],[\"jpnneostllnnma\"],[\"zvmtfg\"],[\"lboe\"],[\"jypzkxnzc\"],[\"qes\"],[\"jioqlytzqx\"],[\"fojsjyiz\"],[\"qkprluekewtsftvbrjndpt\"],[\"mwsgyywmmkzmy\"],[\"tcjmitm\"],[\"pybk\"],[\"poljqcitty\"],[\"qfdabgsvkboyaq\"],[\"pvreuprpvoycadnsxaajrkh\"],[\"sv\"],[\"knmxzabetvqehv\"],[\"ziazu\"],[\"ghhelrzgbsmxkrnezif\"],[\"fn\"],[\"tnjcttrsozynjpqhox\"],[\"qhxcfujxmayzlsrctmsa\"],[\"fyaaivfrupktdgw\"],[\"aiurwhjnhxfqokgiumbeyfcwk\"],[\"y\"],[\"pqxtikjgislbvr\"],[\"halneyxidcqt\"],[\"ugifaaxdcqioabmy\"],[\"dlmcs\"],[\"monsnupyvxyqkegmtmb\"],[\"oexhcxlfcnyijwquaw\"],[\"phetnfndiwyce\"],[\"lofnodyf\"],[\"brrwqho\"],[\"xxaolhw\"],[\"pqmlmuhradvjsx\"],[\"brlhfbvcom\"],[\"v\"],[\"yuhscpvbe\"],[\"ejiavk\"],[\"kbhrkecoaomocvdss\"],[\"mecwmipivkrlotxtjavs\"],[\"hfnconmujvgumljeiakpejgd\"],[\"kwrxzundledqdqbawtrrthps\"],[\"qtzjqxsh\"],[\"apsokathssqpsblye\"],[\"sgvnrpegeqclxtclwzzh\"],[\"eougulzekfcqkxvamtd\"],[\"soasdxrbagqgtbi\"],[\"fdtwtnoh\"],[\"maxsbmlojhhvrumynwppqvm\"],[\"wqopnyebntkkvrea\"],[\"xxnruy\"],[\"eiovag\"],[\"ieryygffvhjcvwrhssvgqqjl\"],[\"g\"],[\"bxbzeccraoqzqreqomg\"],[\"ccg\"],[\"nueebqsegnjnybbs\"],[\"lbcsuh\"],[\"c\"],[\"tcvgwubm\"],[\"nrkwveryqc\"],[\"scapopfqf\"],[\"druwthqeowerqgskfzwvp\"],[\"mvsw\"],[\"oogbspsthyxmlqpqgdsnv\"],[\"hzzvtuhkpimxrxwn\"],[\"wxyrykx\"],[\"wftaqtjkqgabepcpboplcsz\"],[\"gprfavikjmxovw\"],[\"qnmhflhmonzwfdolvaoq\"],[\"fuymduy\"],[\"j\"],[\"tjedwvjtdghhkavwnuyfgkie\"],[\"gtyybcgckuotlmitribvb\"],[\"zchqgemhqjpoxla\"],[\"ldzhusmikkebme\"],[\"imnhhzj\"],[\"yylrxnnlpixqod\"],[\"m\"]]\n```\n\nBy the way, using `WordDictionary` as your node class instead of defining a separate `TrieNode` class stood out to me as being strange.\n\nMaybe your problem doesn't lie there, but it's something to consider."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01)  Thanks for the reply ! I\\'m gonna try harder a bit later but unfortunnately I\\'ve fought about your solution before. \\n\\nIf Leetcode can highligh the output #1681 they could highlight the input #1681 (its a search methods).\\n\\nI can\\'t cut the test case since they are all different length and in order. If I cut randomly 100 input then all the other will have an offset and won\\'t be valid since there is \"search\" and \"addWord\" methods and they don\\'t accept the same input. So cutting half the input would still require me to count each one exactly so they remain in order.\\n\\nMy solution isn\\'t like the other one I\\'ve seen, and nearly all other solutions are the same anyway, they all have the same approach and structure of code. So yeah I could go look a video on how they\\'ve done this but I won\\'t learn anything if I don\\'t know where\\'s my mistake. And I don\\'t think I have the wrong approach since 99% of my answer are correct.\\n\\nAnd yes a debugger would be helpful there, It would be a pain to create an entire new program just to make a debugger accept the input and calling my methods. Leetcode is basically forcing the use of their debugger here but as a student I can\\'t afford the premium, it\\'s half of what I pay for a year of college.\\n\\nAnyway here is my code , if anyone can find a SHORT testcase that doesn\\'t work it would help me greatly :D\\n\\n\\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord = false;\\n    WordDictionary[] dict = new WordDictionary[26];\\n    int index;\\n    \\n    public WordDictionary() {\\n        this.index = 0;\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n    }\\n    \\n    public void addWord(String word) {\\n        if(dict[toInt(word.charAt(index))] == null){\\n            dict[toInt(word.charAt(index))] = new WordDictionary(index);\\n        }\\n        if(index == word.length()-1){\\n            endOfWord = true;\\n        }else dict[toInt(word.charAt(index))].addWord(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        if(index == word.length()-1) return endOfWord && (word.charAt(index) == \\'.\\' ? true : dict[toInt(word.charAt(index))] != null);\\n        if(word.charAt(index) == \\'.\\'){\\n            for(WordDictionary d : dict){\\n                if(d != null && d.search(word)) return true;\\n            }\\n            return false;\\n        }else if(dict[toInt(word.charAt(index))] != null){\\n            return dict[toInt(word.charAt(index))].search(word);\\n        }\\n        return false;\\n    }\\n\\n    private int toInt(char c){\\n        return c-\\'a\\';\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It's a tough situation. I don't see how LeetCode could highlight what input caused the bug. It's obviously a combination of multiple method calls that triggered the bug.\n\nYou've got a few options (not necessarily in order):\n* Try to cut down the test case while still having it fail. It's tedious but I've done this. You sort of \"binary search\" it by cutting it in half and seeing if either of the halves fails. Can you reduce the number of addWord calls while still getting it to fail the search call? Then try to remove the other search calls. If you can shrink it enough you can get to a small enough test case to debug. Don't get stuck on exactly halving it though. You might have to play around with how many method calls you remove.\n* If you have LeetCode Premium you can use the debugger. Or set up a local debugger on your own system and try to debug it. Even though there are hundreds of words in the trie, you might still notice something wrong while debugging.\n* To aid in debugging add a method to print the entire trie.\n*  Review your solution very carefully. First take a break to clear your mind. Don't think of it as \"how can this possibly be wrong\". Think of it as \"I know something is wrong and I can find it. It's only 20-30 lines of code\".\n* Compare against other people's solutions. If you know their solution is correct, then any places where your code is different are prime suspects.\n* Get someone else to review your solution. They won't have your preconceptions about how your code works and the bug may be obvious to them.\n\nIt's not fun but it's good practice. We all have to debug code at work, and this is still easier than some non-reproducible bug. At least you know what input causes it to fail."
                    }
                ]
            },
            {
                "id": 1837828,
                "content": [
                    {
                        "username": "akeempositive",
                        "content": "After solving this challenge with acceptable answer.... All the edge cases are very much.. And this is one challenge that tests requires performance tuning at every stage to pass it acceptably... I was thinking with my data structure and memory usage, I will have a poor rating on memory beats.... But it still beats 97% which is exactly why I think this is freaking hard a challenge "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "No way! I just used the stupidest possible brute force solution with arrays and its build-in find method and still got accepted and moreover it says my solution is faster than 96%  and uses less memory than 97% of other solutions, how is that even possible?? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "aryan20022003",
                        "content": "getting error use Array of Node and use memset for setting node NULL"
                    },
                    {
                        "username": "coderinterview",
                        "content": "I am using trie to store individual charcters in form of tree. \\nFor search I used BFS using queue, which should be faster than DFS using recursion and I am able to pass the testcases by \"run\", but when I \"submit\" I get TLE for same test cases. \\nCan someone please explain what I am missing?\\n```\\nclass WordDictionary {\\nprivate:\\n    struct node{\\n        bool end;\\n        node* v[26];\\n        node(){\\n            end=false;\\n            for(int i=0;i<26;i++){\\n                v[i]=nullptr;\\n            }\\n        }\\n        ~node() {}\\n    };\\n    node *head;\\npublic:        \\n    WordDictionary() {\\n        head = new node();\\n    }\\n    \\n    void addWord(string word) {\\n        node *curr = head;        \\n        for(char &c: word){\\n            if(curr->v[c-\\'a\\'] == nullptr) curr->v[c-\\'a\\'] = new node();\\n            curr = curr->v[c-\\'a\\'];\\n        }\\n        curr->end=true;\\n    }\\n    \\n    bool search(string word) {\\n        // node *curr=head;\\n        queue<node*> q;\\n        q.push(head);\\n        for(char &c: word){\\n            int s = q.size();\\n            while(s--){\\n                node *curr = q.front();\\n                q.pop();\\n                if(c == \\'.\\'){\\n                    for(int i=0;i<26;i++){\\n                        if(curr->v[i] != nullptr) q.push(curr->v[i]);\\n                    }\\n                }\\n                else if(curr->v[c-\\'a\\'] != nullptr) q.push(curr->v[c-\\'a\\']);                \\n            }\\n        }\\n        while(!q.empty()){\\n            node *curr = q.front();\\n            q.pop();\\n            if(curr->end) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```"
                    },
                    {
                        "username": "vadim_spirin",
                        "content": "7/29 testcases passed. Leetcode says that my output is [null,null,null,true,true,true,true,true,true], but it expected [null,null,null,true,true,false,true,false,false]. I tried it in my IDE and my code outputs exactly what is expected. Why does it work like that??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Your solution might have some state that is not being reset properly between test cases."
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone help how this solution is giving WA on this TC :\n\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]] \n\n `your inline code..\n\npublic class TrieNode\n{\n    HashMap<Character,TrieNode>store;\n    boolean is_end;\n    TrieNode()\n    {\n        store = new HashMap<>();\n        is_end = false;\n    }\n}\nclass WordDictionary {\n    private TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        TrieNode curNode = root;\n        for(char c:word.toCharArray())\n        {\n            if(!curNode.store.containsKey(c))\n            {\n                curNode.store.put(c,new TrieNode());\n            }\n            curNode = curNode.store.get(c);\n        }\n        curNode.is_end = true;\n    }\n    \n    public boolean search(String word) {\n    \n       TrieNode curNode = root;\n       return solve(curNode,word,0);\n    }\n\n    public boolean solve(TrieNode node,String word,int idx)\n    {\n        if(idx == word.length())\n        {\n            return node.is_end;\n        }\n        char c = word.charAt(idx);\n        if(c == '.')\n        {\n            for(TrieNode child : node.store.values())\n            {\n                boolean val = solve(child,word,idx+1);\n                if(val == true)\n                {\n                    return true;\n                }\n                return false;\n            }\n        }\n         \n             TrieNode child = node.store.get(c);\n             if(child == null)\n             {\n                 return false;\n             }\n             return solve(child,word,idx+1);\n         }     \n    \n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */\n\n\n\n.your inline code...`"
                    },
                    {
                        "username": "paullam328",
                        "content": "You don't need a TrieNode in the first place.  Optimize that part first and just use nested HashTable.  isEnd can be replaced by HashMap['end'] = {}.  Go back to \"Implement Trie\" problem and get the most memory-optimized solution first, then work on this problem, your code will be much simpler and easier to debug in that sense."
                    },
                    {
                        "username": "Heisenberg2003",
                        "content": "```\\nclass WordDictionary {\\npublic:\\n    struct TrieNode\\n    {\\n        TrieNode* childs[26];\\n    };\\n\\n    unordered_map<TrieNode*,bool>isTerminal;\\n    TrieNode* root=new TrieNode();\\n\\n    WordDictionary() {\\n        root=new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        TrieNode* node=root;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            if(node->childs[word[i]-\\'a\\']==NULL)\\n            {\\n                node->childs[word[i]-\\'a\\']=new TrieNode();\\n            }\\n            node=node->childs[word[i]-\\'a\\'];\\n        }\\n        isTerminal[node]=true;\\n        return;\\n    }\\n\\n    bool searchstr(string str)\\n    {\\n        TrieNode* node=root;\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if(node->childs[str[i]-\\'a\\']==NULL)\\n            {\\n                return false;\\n            }\\n            node=node->childs[str[i]-\\'a\\'];\\n        }\\n        return isTerminal[node];\\n    }\\n\\n    void permute(vector<string>&ans,string word,int ptr)\\n    {\\n        if(ptr==word.size())\\n        {\\n            ans.push_back(word);\\n            return;\\n        }\\n        if(word[ptr]==\\'.\\')\\n        {\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n                word[ptr]=ch;\\n                permute(ans,word,ptr+1);\\n            }\\n        }\\n        else\\n        {\\n            permute(ans,word,ptr+1);\\n        }\\n        return;\\n    }\\n    \\n    bool search(string word) {\\n        vector<string>possible;\\n        permute(possible,word,0);\\n        bool found=false;\\n        for(auto str:possible)\\n        {\\n            found=found||searchstr(str);\\n        }\\n        return found;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```\\nWhy Does This Give TLE?"
                    },
                    {
                        "username": "iamhariom28",
                        "content": "class Node{\n    Node* links[26];\n    bool flag;\npublic:\n    bool containsKey(char ch){\n        return links[ch-'a']!=NULL;\n    }\n    void insertKey(char ch, Node* node){\n        links[ch-'a'] = node;\n    }\n    Node* getNext(char ch){\n        return links[ch-'a'];\n    }\n    void setEnd(){\n        flag = true;\n    }\n    bool isEnd(){\n        return flag;\n    }\n};\n\nclass WordDictionary {\n    Node* root;\npublic:\n    WordDictionary() {\n        root = new Node();\n    }\n    \n    void addWord(string word) {\n        Node* node = root;\n        for(int i=0;i<word.size();i++){\n            if(!node->containsKey(word[i])){\n                node->insertKey(word[i], new Node());\n            }\n            node = node->getNext(word[i]);\n        }\n        node->setEnd();\n    }\n    \n    bool search(string word) {\n        Node* node = root;\n        if(word.size()==0) return node->isEnd();\n\n        for(int i=0;i<word.size();i++){\n            if(word[i]=='.'){\n                bool found = false;\n                for(char ch = 'a';ch <= 'z';ch++){\n                    if(node->containsKey(ch)){\n                        found = true;\n                        node = node->getNext(ch);\n                        break;\n                    }\n                }\n                if(!found) return false;\n            }else{\n                if(node->containsKey(word[i])){\n                    cout<<word[i]<<endl;\n                    node = node->getNext(word[i]);\n                }else return false;\n            }\n        }\n        return node->isEnd();\n    }\n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary* obj = new WordDictionary();\n * obj->addWord(word);\n * bool param_2 = obj->search(word);\n */\n\n\n\nIt is giving me wrong answer for given test case, can anyone tell me what mistake I am doing?\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]]\n\nOutput:\n[null,null,null,null,null,false,false,null,false,true,false,false,true,false]\nExpected output:\n[null,null,null,null,null,false,false,null,true,true,false,false,true,false]\n\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Hey, I have done this problem by doubly LL. and after 20 test cases it shows TLE. can any one tell the best approach of comparing the dot(.) based word with previous words ? Actually i have added another another loop over there so its taking O(n2). thats why its giving TLE i guess."
                    },
                    {
                        "username": "user9157cE",
                        "content": "How ? I can\\'t pass testcase 17, I have ONE false value, how am I suppose to see the error when there is 3300+ different methods calls. I just don\\'t see how I can isolate the error to fix it. And I can\\'t imagine of any way why my code is wrong. It passes all edge case I can think of. It would be great if leetcode can highlight what input caused the mistake. \\nI can only think of making a function that count all output values, gives me all wrong output and do the same with the input to get the 1423th that gives me the wrong value. but even then what ? there is hundreds of words in the dictionary already. I don\\'t know how to go further here :/"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) You're welcome! Most people never reply so I'm glad to help someone who appreciates it.\n\nMy mistake on the initialization thing. I believe it's mostly a stylistic choice. It just looked unfamiliar to me. I googled it shortly afterwards and edited my comment to remove that, but you probably saw the original version of my comment in the email notification.\n\nNot using a `TrieNode` was similar in that it mostly looked strange, but after thinking about it, I can see that your way should work. The main reason to use a `TrieNode` is to have a separate data class. The class storing the data doesn't really need the `addWord()` and `Search()` methods on it. You see this in places like linked list problems too. The linked list node and linked list class are usually separate.\n\nHaving separate classes for the node and trie also gives you a place to store 'global' data about the trie. For example, if you want to keep a count of the number of words in the trie, that goes in the trie class not the node class. With your current design it would have to go into `WordDictionary` but then every node also has a count variable which is unused."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01) Thanks a lot ! I didn\\'t imagine someone would\\'ve helped me so much, you\\'ve made my day !\\n\\nI simply stored endOfWord one step too early, I don\\'t know how it worked so far like that lol. But basically if I add a word \"c\" the whole first level of letter would get endOfWord = true but I needed to do ```dict[letter].endOfWord = true``` instead. So adding adding \"mfqef\" and search for \"m\" is returning true even if there was never a \"m\" in the array.\\n\\nAs for the nodes by looking at others solution I just did not see the use of it here, I imagine there is a good reason to work like that but haven\\'t found it yet.\\n\\nAnd for the variable is it better like this ? \\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord;\\n    WordDictionary[] dict;\\n    int index;\\n    \\n    public WordDictionary() {\\n        this(-1);\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n        this.dict = new WordDictionary[26];\\n    }\\n}\\n```\\nI honestly don\\'t know the difference between initializing the variable in the class or in the constructor. (if there is no variable in the constructor)\\n\\nThanks again for your fast answers, you\\'ve helped me a lot ! My answer beat 74% so I\\'m very happy with it. I think I can optimize it a bit but not today lol.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) Ok, thanks for explaining. Now I understand what you meant by counting output values.\n\nI've cut the test case down a lot. I need to go to bed now, but hopefully you can work on it some more. It's 86 `addWord` calls and a single `search` at the end that fails. Drastically smaller, and it should be easier to remove more `addWord` calls now since you don't have the problem of different interleaved methods.\n\n```\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\"]\n```\n\n```\n[[],[\"xgvk\"],[\"wykzbvwdsoyfowqicymzd\"],[\"xajbtjyjuwgoynjgu\"],[\"qsibzxaorktypkfg\"],[\"vbycuvrkbcq\"],[\"sm\"],[\"fkqclfmvzpzpnbvz\"],[\"jpnneostllnnma\"],[\"zvmtfg\"],[\"lboe\"],[\"jypzkxnzc\"],[\"qes\"],[\"jioqlytzqx\"],[\"fojsjyiz\"],[\"qkprluekewtsftvbrjndpt\"],[\"mwsgyywmmkzmy\"],[\"tcjmitm\"],[\"pybk\"],[\"poljqcitty\"],[\"qfdabgsvkboyaq\"],[\"pvreuprpvoycadnsxaajrkh\"],[\"sv\"],[\"knmxzabetvqehv\"],[\"ziazu\"],[\"ghhelrzgbsmxkrnezif\"],[\"fn\"],[\"tnjcttrsozynjpqhox\"],[\"qhxcfujxmayzlsrctmsa\"],[\"fyaaivfrupktdgw\"],[\"aiurwhjnhxfqokgiumbeyfcwk\"],[\"y\"],[\"pqxtikjgislbvr\"],[\"halneyxidcqt\"],[\"ugifaaxdcqioabmy\"],[\"dlmcs\"],[\"monsnupyvxyqkegmtmb\"],[\"oexhcxlfcnyijwquaw\"],[\"phetnfndiwyce\"],[\"lofnodyf\"],[\"brrwqho\"],[\"xxaolhw\"],[\"pqmlmuhradvjsx\"],[\"brlhfbvcom\"],[\"v\"],[\"yuhscpvbe\"],[\"ejiavk\"],[\"kbhrkecoaomocvdss\"],[\"mecwmipivkrlotxtjavs\"],[\"hfnconmujvgumljeiakpejgd\"],[\"kwrxzundledqdqbawtrrthps\"],[\"qtzjqxsh\"],[\"apsokathssqpsblye\"],[\"sgvnrpegeqclxtclwzzh\"],[\"eougulzekfcqkxvamtd\"],[\"soasdxrbagqgtbi\"],[\"fdtwtnoh\"],[\"maxsbmlojhhvrumynwppqvm\"],[\"wqopnyebntkkvrea\"],[\"xxnruy\"],[\"eiovag\"],[\"ieryygffvhjcvwrhssvgqqjl\"],[\"g\"],[\"bxbzeccraoqzqreqomg\"],[\"ccg\"],[\"nueebqsegnjnybbs\"],[\"lbcsuh\"],[\"c\"],[\"tcvgwubm\"],[\"nrkwveryqc\"],[\"scapopfqf\"],[\"druwthqeowerqgskfzwvp\"],[\"mvsw\"],[\"oogbspsthyxmlqpqgdsnv\"],[\"hzzvtuhkpimxrxwn\"],[\"wxyrykx\"],[\"wftaqtjkqgabepcpboplcsz\"],[\"gprfavikjmxovw\"],[\"qnmhflhmonzwfdolvaoq\"],[\"fuymduy\"],[\"j\"],[\"tjedwvjtdghhkavwnuyfgkie\"],[\"gtyybcgckuotlmitribvb\"],[\"zchqgemhqjpoxla\"],[\"ldzhusmikkebme\"],[\"imnhhzj\"],[\"yylrxnnlpixqod\"],[\"m\"]]\n```\n\nBy the way, using `WordDictionary` as your node class instead of defining a separate `TrieNode` class stood out to me as being strange.\n\nMaybe your problem doesn't lie there, but it's something to consider."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01)  Thanks for the reply ! I\\'m gonna try harder a bit later but unfortunnately I\\'ve fought about your solution before. \\n\\nIf Leetcode can highligh the output #1681 they could highlight the input #1681 (its a search methods).\\n\\nI can\\'t cut the test case since they are all different length and in order. If I cut randomly 100 input then all the other will have an offset and won\\'t be valid since there is \"search\" and \"addWord\" methods and they don\\'t accept the same input. So cutting half the input would still require me to count each one exactly so they remain in order.\\n\\nMy solution isn\\'t like the other one I\\'ve seen, and nearly all other solutions are the same anyway, they all have the same approach and structure of code. So yeah I could go look a video on how they\\'ve done this but I won\\'t learn anything if I don\\'t know where\\'s my mistake. And I don\\'t think I have the wrong approach since 99% of my answer are correct.\\n\\nAnd yes a debugger would be helpful there, It would be a pain to create an entire new program just to make a debugger accept the input and calling my methods. Leetcode is basically forcing the use of their debugger here but as a student I can\\'t afford the premium, it\\'s half of what I pay for a year of college.\\n\\nAnyway here is my code , if anyone can find a SHORT testcase that doesn\\'t work it would help me greatly :D\\n\\n\\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord = false;\\n    WordDictionary[] dict = new WordDictionary[26];\\n    int index;\\n    \\n    public WordDictionary() {\\n        this.index = 0;\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n    }\\n    \\n    public void addWord(String word) {\\n        if(dict[toInt(word.charAt(index))] == null){\\n            dict[toInt(word.charAt(index))] = new WordDictionary(index);\\n        }\\n        if(index == word.length()-1){\\n            endOfWord = true;\\n        }else dict[toInt(word.charAt(index))].addWord(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        if(index == word.length()-1) return endOfWord && (word.charAt(index) == \\'.\\' ? true : dict[toInt(word.charAt(index))] != null);\\n        if(word.charAt(index) == \\'.\\'){\\n            for(WordDictionary d : dict){\\n                if(d != null && d.search(word)) return true;\\n            }\\n            return false;\\n        }else if(dict[toInt(word.charAt(index))] != null){\\n            return dict[toInt(word.charAt(index))].search(word);\\n        }\\n        return false;\\n    }\\n\\n    private int toInt(char c){\\n        return c-\\'a\\';\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It's a tough situation. I don't see how LeetCode could highlight what input caused the bug. It's obviously a combination of multiple method calls that triggered the bug.\n\nYou've got a few options (not necessarily in order):\n* Try to cut down the test case while still having it fail. It's tedious but I've done this. You sort of \"binary search\" it by cutting it in half and seeing if either of the halves fails. Can you reduce the number of addWord calls while still getting it to fail the search call? Then try to remove the other search calls. If you can shrink it enough you can get to a small enough test case to debug. Don't get stuck on exactly halving it though. You might have to play around with how many method calls you remove.\n* If you have LeetCode Premium you can use the debugger. Or set up a local debugger on your own system and try to debug it. Even though there are hundreds of words in the trie, you might still notice something wrong while debugging.\n* To aid in debugging add a method to print the entire trie.\n*  Review your solution very carefully. First take a break to clear your mind. Don't think of it as \"how can this possibly be wrong\". Think of it as \"I know something is wrong and I can find it. It's only 20-30 lines of code\".\n* Compare against other people's solutions. If you know their solution is correct, then any places where your code is different are prime suspects.\n* Get someone else to review your solution. They won't have your preconceptions about how your code works and the bug may be obvious to them.\n\nIt's not fun but it's good practice. We all have to debug code at work, and this is still easier than some non-reproducible bug. At least you know what input causes it to fail."
                    }
                ]
            },
            {
                "id": 1837818,
                "content": [
                    {
                        "username": "akeempositive",
                        "content": "After solving this challenge with acceptable answer.... All the edge cases are very much.. And this is one challenge that tests requires performance tuning at every stage to pass it acceptably... I was thinking with my data structure and memory usage, I will have a poor rating on memory beats.... But it still beats 97% which is exactly why I think this is freaking hard a challenge "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "No way! I just used the stupidest possible brute force solution with arrays and its build-in find method and still got accepted and moreover it says my solution is faster than 96%  and uses less memory than 97% of other solutions, how is that even possible?? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "aryan20022003",
                        "content": "getting error use Array of Node and use memset for setting node NULL"
                    },
                    {
                        "username": "coderinterview",
                        "content": "I am using trie to store individual charcters in form of tree. \\nFor search I used BFS using queue, which should be faster than DFS using recursion and I am able to pass the testcases by \"run\", but when I \"submit\" I get TLE for same test cases. \\nCan someone please explain what I am missing?\\n```\\nclass WordDictionary {\\nprivate:\\n    struct node{\\n        bool end;\\n        node* v[26];\\n        node(){\\n            end=false;\\n            for(int i=0;i<26;i++){\\n                v[i]=nullptr;\\n            }\\n        }\\n        ~node() {}\\n    };\\n    node *head;\\npublic:        \\n    WordDictionary() {\\n        head = new node();\\n    }\\n    \\n    void addWord(string word) {\\n        node *curr = head;        \\n        for(char &c: word){\\n            if(curr->v[c-\\'a\\'] == nullptr) curr->v[c-\\'a\\'] = new node();\\n            curr = curr->v[c-\\'a\\'];\\n        }\\n        curr->end=true;\\n    }\\n    \\n    bool search(string word) {\\n        // node *curr=head;\\n        queue<node*> q;\\n        q.push(head);\\n        for(char &c: word){\\n            int s = q.size();\\n            while(s--){\\n                node *curr = q.front();\\n                q.pop();\\n                if(c == \\'.\\'){\\n                    for(int i=0;i<26;i++){\\n                        if(curr->v[i] != nullptr) q.push(curr->v[i]);\\n                    }\\n                }\\n                else if(curr->v[c-\\'a\\'] != nullptr) q.push(curr->v[c-\\'a\\']);                \\n            }\\n        }\\n        while(!q.empty()){\\n            node *curr = q.front();\\n            q.pop();\\n            if(curr->end) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```"
                    },
                    {
                        "username": "vadim_spirin",
                        "content": "7/29 testcases passed. Leetcode says that my output is [null,null,null,true,true,true,true,true,true], but it expected [null,null,null,true,true,false,true,false,false]. I tried it in my IDE and my code outputs exactly what is expected. Why does it work like that??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Your solution might have some state that is not being reset properly between test cases."
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone help how this solution is giving WA on this TC :\n\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]] \n\n `your inline code..\n\npublic class TrieNode\n{\n    HashMap<Character,TrieNode>store;\n    boolean is_end;\n    TrieNode()\n    {\n        store = new HashMap<>();\n        is_end = false;\n    }\n}\nclass WordDictionary {\n    private TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        TrieNode curNode = root;\n        for(char c:word.toCharArray())\n        {\n            if(!curNode.store.containsKey(c))\n            {\n                curNode.store.put(c,new TrieNode());\n            }\n            curNode = curNode.store.get(c);\n        }\n        curNode.is_end = true;\n    }\n    \n    public boolean search(String word) {\n    \n       TrieNode curNode = root;\n       return solve(curNode,word,0);\n    }\n\n    public boolean solve(TrieNode node,String word,int idx)\n    {\n        if(idx == word.length())\n        {\n            return node.is_end;\n        }\n        char c = word.charAt(idx);\n        if(c == '.')\n        {\n            for(TrieNode child : node.store.values())\n            {\n                boolean val = solve(child,word,idx+1);\n                if(val == true)\n                {\n                    return true;\n                }\n                return false;\n            }\n        }\n         \n             TrieNode child = node.store.get(c);\n             if(child == null)\n             {\n                 return false;\n             }\n             return solve(child,word,idx+1);\n         }     \n    \n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */\n\n\n\n.your inline code...`"
                    },
                    {
                        "username": "paullam328",
                        "content": "You don't need a TrieNode in the first place.  Optimize that part first and just use nested HashTable.  isEnd can be replaced by HashMap['end'] = {}.  Go back to \"Implement Trie\" problem and get the most memory-optimized solution first, then work on this problem, your code will be much simpler and easier to debug in that sense."
                    },
                    {
                        "username": "Heisenberg2003",
                        "content": "```\\nclass WordDictionary {\\npublic:\\n    struct TrieNode\\n    {\\n        TrieNode* childs[26];\\n    };\\n\\n    unordered_map<TrieNode*,bool>isTerminal;\\n    TrieNode* root=new TrieNode();\\n\\n    WordDictionary() {\\n        root=new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        TrieNode* node=root;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            if(node->childs[word[i]-\\'a\\']==NULL)\\n            {\\n                node->childs[word[i]-\\'a\\']=new TrieNode();\\n            }\\n            node=node->childs[word[i]-\\'a\\'];\\n        }\\n        isTerminal[node]=true;\\n        return;\\n    }\\n\\n    bool searchstr(string str)\\n    {\\n        TrieNode* node=root;\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if(node->childs[str[i]-\\'a\\']==NULL)\\n            {\\n                return false;\\n            }\\n            node=node->childs[str[i]-\\'a\\'];\\n        }\\n        return isTerminal[node];\\n    }\\n\\n    void permute(vector<string>&ans,string word,int ptr)\\n    {\\n        if(ptr==word.size())\\n        {\\n            ans.push_back(word);\\n            return;\\n        }\\n        if(word[ptr]==\\'.\\')\\n        {\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n                word[ptr]=ch;\\n                permute(ans,word,ptr+1);\\n            }\\n        }\\n        else\\n        {\\n            permute(ans,word,ptr+1);\\n        }\\n        return;\\n    }\\n    \\n    bool search(string word) {\\n        vector<string>possible;\\n        permute(possible,word,0);\\n        bool found=false;\\n        for(auto str:possible)\\n        {\\n            found=found||searchstr(str);\\n        }\\n        return found;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```\\nWhy Does This Give TLE?"
                    },
                    {
                        "username": "iamhariom28",
                        "content": "class Node{\n    Node* links[26];\n    bool flag;\npublic:\n    bool containsKey(char ch){\n        return links[ch-'a']!=NULL;\n    }\n    void insertKey(char ch, Node* node){\n        links[ch-'a'] = node;\n    }\n    Node* getNext(char ch){\n        return links[ch-'a'];\n    }\n    void setEnd(){\n        flag = true;\n    }\n    bool isEnd(){\n        return flag;\n    }\n};\n\nclass WordDictionary {\n    Node* root;\npublic:\n    WordDictionary() {\n        root = new Node();\n    }\n    \n    void addWord(string word) {\n        Node* node = root;\n        for(int i=0;i<word.size();i++){\n            if(!node->containsKey(word[i])){\n                node->insertKey(word[i], new Node());\n            }\n            node = node->getNext(word[i]);\n        }\n        node->setEnd();\n    }\n    \n    bool search(string word) {\n        Node* node = root;\n        if(word.size()==0) return node->isEnd();\n\n        for(int i=0;i<word.size();i++){\n            if(word[i]=='.'){\n                bool found = false;\n                for(char ch = 'a';ch <= 'z';ch++){\n                    if(node->containsKey(ch)){\n                        found = true;\n                        node = node->getNext(ch);\n                        break;\n                    }\n                }\n                if(!found) return false;\n            }else{\n                if(node->containsKey(word[i])){\n                    cout<<word[i]<<endl;\n                    node = node->getNext(word[i]);\n                }else return false;\n            }\n        }\n        return node->isEnd();\n    }\n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary* obj = new WordDictionary();\n * obj->addWord(word);\n * bool param_2 = obj->search(word);\n */\n\n\n\nIt is giving me wrong answer for given test case, can anyone tell me what mistake I am doing?\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]]\n\nOutput:\n[null,null,null,null,null,false,false,null,false,true,false,false,true,false]\nExpected output:\n[null,null,null,null,null,false,false,null,true,true,false,false,true,false]\n\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Hey, I have done this problem by doubly LL. and after 20 test cases it shows TLE. can any one tell the best approach of comparing the dot(.) based word with previous words ? Actually i have added another another loop over there so its taking O(n2). thats why its giving TLE i guess."
                    },
                    {
                        "username": "user9157cE",
                        "content": "How ? I can\\'t pass testcase 17, I have ONE false value, how am I suppose to see the error when there is 3300+ different methods calls. I just don\\'t see how I can isolate the error to fix it. And I can\\'t imagine of any way why my code is wrong. It passes all edge case I can think of. It would be great if leetcode can highlight what input caused the mistake. \\nI can only think of making a function that count all output values, gives me all wrong output and do the same with the input to get the 1423th that gives me the wrong value. but even then what ? there is hundreds of words in the dictionary already. I don\\'t know how to go further here :/"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) You're welcome! Most people never reply so I'm glad to help someone who appreciates it.\n\nMy mistake on the initialization thing. I believe it's mostly a stylistic choice. It just looked unfamiliar to me. I googled it shortly afterwards and edited my comment to remove that, but you probably saw the original version of my comment in the email notification.\n\nNot using a `TrieNode` was similar in that it mostly looked strange, but after thinking about it, I can see that your way should work. The main reason to use a `TrieNode` is to have a separate data class. The class storing the data doesn't really need the `addWord()` and `Search()` methods on it. You see this in places like linked list problems too. The linked list node and linked list class are usually separate.\n\nHaving separate classes for the node and trie also gives you a place to store 'global' data about the trie. For example, if you want to keep a count of the number of words in the trie, that goes in the trie class not the node class. With your current design it would have to go into `WordDictionary` but then every node also has a count variable which is unused."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01) Thanks a lot ! I didn\\'t imagine someone would\\'ve helped me so much, you\\'ve made my day !\\n\\nI simply stored endOfWord one step too early, I don\\'t know how it worked so far like that lol. But basically if I add a word \"c\" the whole first level of letter would get endOfWord = true but I needed to do ```dict[letter].endOfWord = true``` instead. So adding adding \"mfqef\" and search for \"m\" is returning true even if there was never a \"m\" in the array.\\n\\nAs for the nodes by looking at others solution I just did not see the use of it here, I imagine there is a good reason to work like that but haven\\'t found it yet.\\n\\nAnd for the variable is it better like this ? \\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord;\\n    WordDictionary[] dict;\\n    int index;\\n    \\n    public WordDictionary() {\\n        this(-1);\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n        this.dict = new WordDictionary[26];\\n    }\\n}\\n```\\nI honestly don\\'t know the difference between initializing the variable in the class or in the constructor. (if there is no variable in the constructor)\\n\\nThanks again for your fast answers, you\\'ve helped me a lot ! My answer beat 74% so I\\'m very happy with it. I think I can optimize it a bit but not today lol.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) Ok, thanks for explaining. Now I understand what you meant by counting output values.\n\nI've cut the test case down a lot. I need to go to bed now, but hopefully you can work on it some more. It's 86 `addWord` calls and a single `search` at the end that fails. Drastically smaller, and it should be easier to remove more `addWord` calls now since you don't have the problem of different interleaved methods.\n\n```\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\"]\n```\n\n```\n[[],[\"xgvk\"],[\"wykzbvwdsoyfowqicymzd\"],[\"xajbtjyjuwgoynjgu\"],[\"qsibzxaorktypkfg\"],[\"vbycuvrkbcq\"],[\"sm\"],[\"fkqclfmvzpzpnbvz\"],[\"jpnneostllnnma\"],[\"zvmtfg\"],[\"lboe\"],[\"jypzkxnzc\"],[\"qes\"],[\"jioqlytzqx\"],[\"fojsjyiz\"],[\"qkprluekewtsftvbrjndpt\"],[\"mwsgyywmmkzmy\"],[\"tcjmitm\"],[\"pybk\"],[\"poljqcitty\"],[\"qfdabgsvkboyaq\"],[\"pvreuprpvoycadnsxaajrkh\"],[\"sv\"],[\"knmxzabetvqehv\"],[\"ziazu\"],[\"ghhelrzgbsmxkrnezif\"],[\"fn\"],[\"tnjcttrsozynjpqhox\"],[\"qhxcfujxmayzlsrctmsa\"],[\"fyaaivfrupktdgw\"],[\"aiurwhjnhxfqokgiumbeyfcwk\"],[\"y\"],[\"pqxtikjgislbvr\"],[\"halneyxidcqt\"],[\"ugifaaxdcqioabmy\"],[\"dlmcs\"],[\"monsnupyvxyqkegmtmb\"],[\"oexhcxlfcnyijwquaw\"],[\"phetnfndiwyce\"],[\"lofnodyf\"],[\"brrwqho\"],[\"xxaolhw\"],[\"pqmlmuhradvjsx\"],[\"brlhfbvcom\"],[\"v\"],[\"yuhscpvbe\"],[\"ejiavk\"],[\"kbhrkecoaomocvdss\"],[\"mecwmipivkrlotxtjavs\"],[\"hfnconmujvgumljeiakpejgd\"],[\"kwrxzundledqdqbawtrrthps\"],[\"qtzjqxsh\"],[\"apsokathssqpsblye\"],[\"sgvnrpegeqclxtclwzzh\"],[\"eougulzekfcqkxvamtd\"],[\"soasdxrbagqgtbi\"],[\"fdtwtnoh\"],[\"maxsbmlojhhvrumynwppqvm\"],[\"wqopnyebntkkvrea\"],[\"xxnruy\"],[\"eiovag\"],[\"ieryygffvhjcvwrhssvgqqjl\"],[\"g\"],[\"bxbzeccraoqzqreqomg\"],[\"ccg\"],[\"nueebqsegnjnybbs\"],[\"lbcsuh\"],[\"c\"],[\"tcvgwubm\"],[\"nrkwveryqc\"],[\"scapopfqf\"],[\"druwthqeowerqgskfzwvp\"],[\"mvsw\"],[\"oogbspsthyxmlqpqgdsnv\"],[\"hzzvtuhkpimxrxwn\"],[\"wxyrykx\"],[\"wftaqtjkqgabepcpboplcsz\"],[\"gprfavikjmxovw\"],[\"qnmhflhmonzwfdolvaoq\"],[\"fuymduy\"],[\"j\"],[\"tjedwvjtdghhkavwnuyfgkie\"],[\"gtyybcgckuotlmitribvb\"],[\"zchqgemhqjpoxla\"],[\"ldzhusmikkebme\"],[\"imnhhzj\"],[\"yylrxnnlpixqod\"],[\"m\"]]\n```\n\nBy the way, using `WordDictionary` as your node class instead of defining a separate `TrieNode` class stood out to me as being strange.\n\nMaybe your problem doesn't lie there, but it's something to consider."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01)  Thanks for the reply ! I\\'m gonna try harder a bit later but unfortunnately I\\'ve fought about your solution before. \\n\\nIf Leetcode can highligh the output #1681 they could highlight the input #1681 (its a search methods).\\n\\nI can\\'t cut the test case since they are all different length and in order. If I cut randomly 100 input then all the other will have an offset and won\\'t be valid since there is \"search\" and \"addWord\" methods and they don\\'t accept the same input. So cutting half the input would still require me to count each one exactly so they remain in order.\\n\\nMy solution isn\\'t like the other one I\\'ve seen, and nearly all other solutions are the same anyway, they all have the same approach and structure of code. So yeah I could go look a video on how they\\'ve done this but I won\\'t learn anything if I don\\'t know where\\'s my mistake. And I don\\'t think I have the wrong approach since 99% of my answer are correct.\\n\\nAnd yes a debugger would be helpful there, It would be a pain to create an entire new program just to make a debugger accept the input and calling my methods. Leetcode is basically forcing the use of their debugger here but as a student I can\\'t afford the premium, it\\'s half of what I pay for a year of college.\\n\\nAnyway here is my code , if anyone can find a SHORT testcase that doesn\\'t work it would help me greatly :D\\n\\n\\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord = false;\\n    WordDictionary[] dict = new WordDictionary[26];\\n    int index;\\n    \\n    public WordDictionary() {\\n        this.index = 0;\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n    }\\n    \\n    public void addWord(String word) {\\n        if(dict[toInt(word.charAt(index))] == null){\\n            dict[toInt(word.charAt(index))] = new WordDictionary(index);\\n        }\\n        if(index == word.length()-1){\\n            endOfWord = true;\\n        }else dict[toInt(word.charAt(index))].addWord(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        if(index == word.length()-1) return endOfWord && (word.charAt(index) == \\'.\\' ? true : dict[toInt(word.charAt(index))] != null);\\n        if(word.charAt(index) == \\'.\\'){\\n            for(WordDictionary d : dict){\\n                if(d != null && d.search(word)) return true;\\n            }\\n            return false;\\n        }else if(dict[toInt(word.charAt(index))] != null){\\n            return dict[toInt(word.charAt(index))].search(word);\\n        }\\n        return false;\\n    }\\n\\n    private int toInt(char c){\\n        return c-\\'a\\';\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It's a tough situation. I don't see how LeetCode could highlight what input caused the bug. It's obviously a combination of multiple method calls that triggered the bug.\n\nYou've got a few options (not necessarily in order):\n* Try to cut down the test case while still having it fail. It's tedious but I've done this. You sort of \"binary search\" it by cutting it in half and seeing if either of the halves fails. Can you reduce the number of addWord calls while still getting it to fail the search call? Then try to remove the other search calls. If you can shrink it enough you can get to a small enough test case to debug. Don't get stuck on exactly halving it though. You might have to play around with how many method calls you remove.\n* If you have LeetCode Premium you can use the debugger. Or set up a local debugger on your own system and try to debug it. Even though there are hundreds of words in the trie, you might still notice something wrong while debugging.\n* To aid in debugging add a method to print the entire trie.\n*  Review your solution very carefully. First take a break to clear your mind. Don't think of it as \"how can this possibly be wrong\". Think of it as \"I know something is wrong and I can find it. It's only 20-30 lines of code\".\n* Compare against other people's solutions. If you know their solution is correct, then any places where your code is different are prime suspects.\n* Get someone else to review your solution. They won't have your preconceptions about how your code works and the bug may be obvious to them.\n\nIt's not fun but it's good practice. We all have to debug code at work, and this is still easier than some non-reproducible bug. At least you know what input causes it to fail."
                    }
                ]
            },
            {
                "id": 1837688,
                "content": [
                    {
                        "username": "akeempositive",
                        "content": "After solving this challenge with acceptable answer.... All the edge cases are very much.. And this is one challenge that tests requires performance tuning at every stage to pass it acceptably... I was thinking with my data structure and memory usage, I will have a poor rating on memory beats.... But it still beats 97% which is exactly why I think this is freaking hard a challenge "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "No way! I just used the stupidest possible brute force solution with arrays and its build-in find method and still got accepted and moreover it says my solution is faster than 96%  and uses less memory than 97% of other solutions, how is that even possible?? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "aryan20022003",
                        "content": "getting error use Array of Node and use memset for setting node NULL"
                    },
                    {
                        "username": "coderinterview",
                        "content": "I am using trie to store individual charcters in form of tree. \\nFor search I used BFS using queue, which should be faster than DFS using recursion and I am able to pass the testcases by \"run\", but when I \"submit\" I get TLE for same test cases. \\nCan someone please explain what I am missing?\\n```\\nclass WordDictionary {\\nprivate:\\n    struct node{\\n        bool end;\\n        node* v[26];\\n        node(){\\n            end=false;\\n            for(int i=0;i<26;i++){\\n                v[i]=nullptr;\\n            }\\n        }\\n        ~node() {}\\n    };\\n    node *head;\\npublic:        \\n    WordDictionary() {\\n        head = new node();\\n    }\\n    \\n    void addWord(string word) {\\n        node *curr = head;        \\n        for(char &c: word){\\n            if(curr->v[c-\\'a\\'] == nullptr) curr->v[c-\\'a\\'] = new node();\\n            curr = curr->v[c-\\'a\\'];\\n        }\\n        curr->end=true;\\n    }\\n    \\n    bool search(string word) {\\n        // node *curr=head;\\n        queue<node*> q;\\n        q.push(head);\\n        for(char &c: word){\\n            int s = q.size();\\n            while(s--){\\n                node *curr = q.front();\\n                q.pop();\\n                if(c == \\'.\\'){\\n                    for(int i=0;i<26;i++){\\n                        if(curr->v[i] != nullptr) q.push(curr->v[i]);\\n                    }\\n                }\\n                else if(curr->v[c-\\'a\\'] != nullptr) q.push(curr->v[c-\\'a\\']);                \\n            }\\n        }\\n        while(!q.empty()){\\n            node *curr = q.front();\\n            q.pop();\\n            if(curr->end) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```"
                    },
                    {
                        "username": "vadim_spirin",
                        "content": "7/29 testcases passed. Leetcode says that my output is [null,null,null,true,true,true,true,true,true], but it expected [null,null,null,true,true,false,true,false,false]. I tried it in my IDE and my code outputs exactly what is expected. Why does it work like that??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Your solution might have some state that is not being reset properly between test cases."
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone help how this solution is giving WA on this TC :\n\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]] \n\n `your inline code..\n\npublic class TrieNode\n{\n    HashMap<Character,TrieNode>store;\n    boolean is_end;\n    TrieNode()\n    {\n        store = new HashMap<>();\n        is_end = false;\n    }\n}\nclass WordDictionary {\n    private TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        TrieNode curNode = root;\n        for(char c:word.toCharArray())\n        {\n            if(!curNode.store.containsKey(c))\n            {\n                curNode.store.put(c,new TrieNode());\n            }\n            curNode = curNode.store.get(c);\n        }\n        curNode.is_end = true;\n    }\n    \n    public boolean search(String word) {\n    \n       TrieNode curNode = root;\n       return solve(curNode,word,0);\n    }\n\n    public boolean solve(TrieNode node,String word,int idx)\n    {\n        if(idx == word.length())\n        {\n            return node.is_end;\n        }\n        char c = word.charAt(idx);\n        if(c == '.')\n        {\n            for(TrieNode child : node.store.values())\n            {\n                boolean val = solve(child,word,idx+1);\n                if(val == true)\n                {\n                    return true;\n                }\n                return false;\n            }\n        }\n         \n             TrieNode child = node.store.get(c);\n             if(child == null)\n             {\n                 return false;\n             }\n             return solve(child,word,idx+1);\n         }     \n    \n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */\n\n\n\n.your inline code...`"
                    },
                    {
                        "username": "paullam328",
                        "content": "You don't need a TrieNode in the first place.  Optimize that part first and just use nested HashTable.  isEnd can be replaced by HashMap['end'] = {}.  Go back to \"Implement Trie\" problem and get the most memory-optimized solution first, then work on this problem, your code will be much simpler and easier to debug in that sense."
                    },
                    {
                        "username": "Heisenberg2003",
                        "content": "```\\nclass WordDictionary {\\npublic:\\n    struct TrieNode\\n    {\\n        TrieNode* childs[26];\\n    };\\n\\n    unordered_map<TrieNode*,bool>isTerminal;\\n    TrieNode* root=new TrieNode();\\n\\n    WordDictionary() {\\n        root=new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        TrieNode* node=root;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            if(node->childs[word[i]-\\'a\\']==NULL)\\n            {\\n                node->childs[word[i]-\\'a\\']=new TrieNode();\\n            }\\n            node=node->childs[word[i]-\\'a\\'];\\n        }\\n        isTerminal[node]=true;\\n        return;\\n    }\\n\\n    bool searchstr(string str)\\n    {\\n        TrieNode* node=root;\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if(node->childs[str[i]-\\'a\\']==NULL)\\n            {\\n                return false;\\n            }\\n            node=node->childs[str[i]-\\'a\\'];\\n        }\\n        return isTerminal[node];\\n    }\\n\\n    void permute(vector<string>&ans,string word,int ptr)\\n    {\\n        if(ptr==word.size())\\n        {\\n            ans.push_back(word);\\n            return;\\n        }\\n        if(word[ptr]==\\'.\\')\\n        {\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n                word[ptr]=ch;\\n                permute(ans,word,ptr+1);\\n            }\\n        }\\n        else\\n        {\\n            permute(ans,word,ptr+1);\\n        }\\n        return;\\n    }\\n    \\n    bool search(string word) {\\n        vector<string>possible;\\n        permute(possible,word,0);\\n        bool found=false;\\n        for(auto str:possible)\\n        {\\n            found=found||searchstr(str);\\n        }\\n        return found;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```\\nWhy Does This Give TLE?"
                    },
                    {
                        "username": "iamhariom28",
                        "content": "class Node{\n    Node* links[26];\n    bool flag;\npublic:\n    bool containsKey(char ch){\n        return links[ch-'a']!=NULL;\n    }\n    void insertKey(char ch, Node* node){\n        links[ch-'a'] = node;\n    }\n    Node* getNext(char ch){\n        return links[ch-'a'];\n    }\n    void setEnd(){\n        flag = true;\n    }\n    bool isEnd(){\n        return flag;\n    }\n};\n\nclass WordDictionary {\n    Node* root;\npublic:\n    WordDictionary() {\n        root = new Node();\n    }\n    \n    void addWord(string word) {\n        Node* node = root;\n        for(int i=0;i<word.size();i++){\n            if(!node->containsKey(word[i])){\n                node->insertKey(word[i], new Node());\n            }\n            node = node->getNext(word[i]);\n        }\n        node->setEnd();\n    }\n    \n    bool search(string word) {\n        Node* node = root;\n        if(word.size()==0) return node->isEnd();\n\n        for(int i=0;i<word.size();i++){\n            if(word[i]=='.'){\n                bool found = false;\n                for(char ch = 'a';ch <= 'z';ch++){\n                    if(node->containsKey(ch)){\n                        found = true;\n                        node = node->getNext(ch);\n                        break;\n                    }\n                }\n                if(!found) return false;\n            }else{\n                if(node->containsKey(word[i])){\n                    cout<<word[i]<<endl;\n                    node = node->getNext(word[i]);\n                }else return false;\n            }\n        }\n        return node->isEnd();\n    }\n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary* obj = new WordDictionary();\n * obj->addWord(word);\n * bool param_2 = obj->search(word);\n */\n\n\n\nIt is giving me wrong answer for given test case, can anyone tell me what mistake I am doing?\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]]\n\nOutput:\n[null,null,null,null,null,false,false,null,false,true,false,false,true,false]\nExpected output:\n[null,null,null,null,null,false,false,null,true,true,false,false,true,false]\n\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Hey, I have done this problem by doubly LL. and after 20 test cases it shows TLE. can any one tell the best approach of comparing the dot(.) based word with previous words ? Actually i have added another another loop over there so its taking O(n2). thats why its giving TLE i guess."
                    },
                    {
                        "username": "user9157cE",
                        "content": "How ? I can\\'t pass testcase 17, I have ONE false value, how am I suppose to see the error when there is 3300+ different methods calls. I just don\\'t see how I can isolate the error to fix it. And I can\\'t imagine of any way why my code is wrong. It passes all edge case I can think of. It would be great if leetcode can highlight what input caused the mistake. \\nI can only think of making a function that count all output values, gives me all wrong output and do the same with the input to get the 1423th that gives me the wrong value. but even then what ? there is hundreds of words in the dictionary already. I don\\'t know how to go further here :/"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) You're welcome! Most people never reply so I'm glad to help someone who appreciates it.\n\nMy mistake on the initialization thing. I believe it's mostly a stylistic choice. It just looked unfamiliar to me. I googled it shortly afterwards and edited my comment to remove that, but you probably saw the original version of my comment in the email notification.\n\nNot using a `TrieNode` was similar in that it mostly looked strange, but after thinking about it, I can see that your way should work. The main reason to use a `TrieNode` is to have a separate data class. The class storing the data doesn't really need the `addWord()` and `Search()` methods on it. You see this in places like linked list problems too. The linked list node and linked list class are usually separate.\n\nHaving separate classes for the node and trie also gives you a place to store 'global' data about the trie. For example, if you want to keep a count of the number of words in the trie, that goes in the trie class not the node class. With your current design it would have to go into `WordDictionary` but then every node also has a count variable which is unused."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01) Thanks a lot ! I didn\\'t imagine someone would\\'ve helped me so much, you\\'ve made my day !\\n\\nI simply stored endOfWord one step too early, I don\\'t know how it worked so far like that lol. But basically if I add a word \"c\" the whole first level of letter would get endOfWord = true but I needed to do ```dict[letter].endOfWord = true``` instead. So adding adding \"mfqef\" and search for \"m\" is returning true even if there was never a \"m\" in the array.\\n\\nAs for the nodes by looking at others solution I just did not see the use of it here, I imagine there is a good reason to work like that but haven\\'t found it yet.\\n\\nAnd for the variable is it better like this ? \\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord;\\n    WordDictionary[] dict;\\n    int index;\\n    \\n    public WordDictionary() {\\n        this(-1);\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n        this.dict = new WordDictionary[26];\\n    }\\n}\\n```\\nI honestly don\\'t know the difference between initializing the variable in the class or in the constructor. (if there is no variable in the constructor)\\n\\nThanks again for your fast answers, you\\'ve helped me a lot ! My answer beat 74% so I\\'m very happy with it. I think I can optimize it a bit but not today lol.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) Ok, thanks for explaining. Now I understand what you meant by counting output values.\n\nI've cut the test case down a lot. I need to go to bed now, but hopefully you can work on it some more. It's 86 `addWord` calls and a single `search` at the end that fails. Drastically smaller, and it should be easier to remove more `addWord` calls now since you don't have the problem of different interleaved methods.\n\n```\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\"]\n```\n\n```\n[[],[\"xgvk\"],[\"wykzbvwdsoyfowqicymzd\"],[\"xajbtjyjuwgoynjgu\"],[\"qsibzxaorktypkfg\"],[\"vbycuvrkbcq\"],[\"sm\"],[\"fkqclfmvzpzpnbvz\"],[\"jpnneostllnnma\"],[\"zvmtfg\"],[\"lboe\"],[\"jypzkxnzc\"],[\"qes\"],[\"jioqlytzqx\"],[\"fojsjyiz\"],[\"qkprluekewtsftvbrjndpt\"],[\"mwsgyywmmkzmy\"],[\"tcjmitm\"],[\"pybk\"],[\"poljqcitty\"],[\"qfdabgsvkboyaq\"],[\"pvreuprpvoycadnsxaajrkh\"],[\"sv\"],[\"knmxzabetvqehv\"],[\"ziazu\"],[\"ghhelrzgbsmxkrnezif\"],[\"fn\"],[\"tnjcttrsozynjpqhox\"],[\"qhxcfujxmayzlsrctmsa\"],[\"fyaaivfrupktdgw\"],[\"aiurwhjnhxfqokgiumbeyfcwk\"],[\"y\"],[\"pqxtikjgislbvr\"],[\"halneyxidcqt\"],[\"ugifaaxdcqioabmy\"],[\"dlmcs\"],[\"monsnupyvxyqkegmtmb\"],[\"oexhcxlfcnyijwquaw\"],[\"phetnfndiwyce\"],[\"lofnodyf\"],[\"brrwqho\"],[\"xxaolhw\"],[\"pqmlmuhradvjsx\"],[\"brlhfbvcom\"],[\"v\"],[\"yuhscpvbe\"],[\"ejiavk\"],[\"kbhrkecoaomocvdss\"],[\"mecwmipivkrlotxtjavs\"],[\"hfnconmujvgumljeiakpejgd\"],[\"kwrxzundledqdqbawtrrthps\"],[\"qtzjqxsh\"],[\"apsokathssqpsblye\"],[\"sgvnrpegeqclxtclwzzh\"],[\"eougulzekfcqkxvamtd\"],[\"soasdxrbagqgtbi\"],[\"fdtwtnoh\"],[\"maxsbmlojhhvrumynwppqvm\"],[\"wqopnyebntkkvrea\"],[\"xxnruy\"],[\"eiovag\"],[\"ieryygffvhjcvwrhssvgqqjl\"],[\"g\"],[\"bxbzeccraoqzqreqomg\"],[\"ccg\"],[\"nueebqsegnjnybbs\"],[\"lbcsuh\"],[\"c\"],[\"tcvgwubm\"],[\"nrkwveryqc\"],[\"scapopfqf\"],[\"druwthqeowerqgskfzwvp\"],[\"mvsw\"],[\"oogbspsthyxmlqpqgdsnv\"],[\"hzzvtuhkpimxrxwn\"],[\"wxyrykx\"],[\"wftaqtjkqgabepcpboplcsz\"],[\"gprfavikjmxovw\"],[\"qnmhflhmonzwfdolvaoq\"],[\"fuymduy\"],[\"j\"],[\"tjedwvjtdghhkavwnuyfgkie\"],[\"gtyybcgckuotlmitribvb\"],[\"zchqgemhqjpoxla\"],[\"ldzhusmikkebme\"],[\"imnhhzj\"],[\"yylrxnnlpixqod\"],[\"m\"]]\n```\n\nBy the way, using `WordDictionary` as your node class instead of defining a separate `TrieNode` class stood out to me as being strange.\n\nMaybe your problem doesn't lie there, but it's something to consider."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01)  Thanks for the reply ! I\\'m gonna try harder a bit later but unfortunnately I\\'ve fought about your solution before. \\n\\nIf Leetcode can highligh the output #1681 they could highlight the input #1681 (its a search methods).\\n\\nI can\\'t cut the test case since they are all different length and in order. If I cut randomly 100 input then all the other will have an offset and won\\'t be valid since there is \"search\" and \"addWord\" methods and they don\\'t accept the same input. So cutting half the input would still require me to count each one exactly so they remain in order.\\n\\nMy solution isn\\'t like the other one I\\'ve seen, and nearly all other solutions are the same anyway, they all have the same approach and structure of code. So yeah I could go look a video on how they\\'ve done this but I won\\'t learn anything if I don\\'t know where\\'s my mistake. And I don\\'t think I have the wrong approach since 99% of my answer are correct.\\n\\nAnd yes a debugger would be helpful there, It would be a pain to create an entire new program just to make a debugger accept the input and calling my methods. Leetcode is basically forcing the use of their debugger here but as a student I can\\'t afford the premium, it\\'s half of what I pay for a year of college.\\n\\nAnyway here is my code , if anyone can find a SHORT testcase that doesn\\'t work it would help me greatly :D\\n\\n\\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord = false;\\n    WordDictionary[] dict = new WordDictionary[26];\\n    int index;\\n    \\n    public WordDictionary() {\\n        this.index = 0;\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n    }\\n    \\n    public void addWord(String word) {\\n        if(dict[toInt(word.charAt(index))] == null){\\n            dict[toInt(word.charAt(index))] = new WordDictionary(index);\\n        }\\n        if(index == word.length()-1){\\n            endOfWord = true;\\n        }else dict[toInt(word.charAt(index))].addWord(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        if(index == word.length()-1) return endOfWord && (word.charAt(index) == \\'.\\' ? true : dict[toInt(word.charAt(index))] != null);\\n        if(word.charAt(index) == \\'.\\'){\\n            for(WordDictionary d : dict){\\n                if(d != null && d.search(word)) return true;\\n            }\\n            return false;\\n        }else if(dict[toInt(word.charAt(index))] != null){\\n            return dict[toInt(word.charAt(index))].search(word);\\n        }\\n        return false;\\n    }\\n\\n    private int toInt(char c){\\n        return c-\\'a\\';\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It's a tough situation. I don't see how LeetCode could highlight what input caused the bug. It's obviously a combination of multiple method calls that triggered the bug.\n\nYou've got a few options (not necessarily in order):\n* Try to cut down the test case while still having it fail. It's tedious but I've done this. You sort of \"binary search\" it by cutting it in half and seeing if either of the halves fails. Can you reduce the number of addWord calls while still getting it to fail the search call? Then try to remove the other search calls. If you can shrink it enough you can get to a small enough test case to debug. Don't get stuck on exactly halving it though. You might have to play around with how many method calls you remove.\n* If you have LeetCode Premium you can use the debugger. Or set up a local debugger on your own system and try to debug it. Even though there are hundreds of words in the trie, you might still notice something wrong while debugging.\n* To aid in debugging add a method to print the entire trie.\n*  Review your solution very carefully. First take a break to clear your mind. Don't think of it as \"how can this possibly be wrong\". Think of it as \"I know something is wrong and I can find it. It's only 20-30 lines of code\".\n* Compare against other people's solutions. If you know their solution is correct, then any places where your code is different are prime suspects.\n* Get someone else to review your solution. They won't have your preconceptions about how your code works and the bug may be obvious to them.\n\nIt's not fun but it's good practice. We all have to debug code at work, and this is still easier than some non-reproducible bug. At least you know what input causes it to fail."
                    }
                ]
            },
            {
                "id": 1837629,
                "content": [
                    {
                        "username": "akeempositive",
                        "content": "After solving this challenge with acceptable answer.... All the edge cases are very much.. And this is one challenge that tests requires performance tuning at every stage to pass it acceptably... I was thinking with my data structure and memory usage, I will have a poor rating on memory beats.... But it still beats 97% which is exactly why I think this is freaking hard a challenge "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "No way! I just used the stupidest possible brute force solution with arrays and its build-in find method and still got accepted and moreover it says my solution is faster than 96%  and uses less memory than 97% of other solutions, how is that even possible?? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "aryan20022003",
                        "content": "getting error use Array of Node and use memset for setting node NULL"
                    },
                    {
                        "username": "coderinterview",
                        "content": "I am using trie to store individual charcters in form of tree. \\nFor search I used BFS using queue, which should be faster than DFS using recursion and I am able to pass the testcases by \"run\", but when I \"submit\" I get TLE for same test cases. \\nCan someone please explain what I am missing?\\n```\\nclass WordDictionary {\\nprivate:\\n    struct node{\\n        bool end;\\n        node* v[26];\\n        node(){\\n            end=false;\\n            for(int i=0;i<26;i++){\\n                v[i]=nullptr;\\n            }\\n        }\\n        ~node() {}\\n    };\\n    node *head;\\npublic:        \\n    WordDictionary() {\\n        head = new node();\\n    }\\n    \\n    void addWord(string word) {\\n        node *curr = head;        \\n        for(char &c: word){\\n            if(curr->v[c-\\'a\\'] == nullptr) curr->v[c-\\'a\\'] = new node();\\n            curr = curr->v[c-\\'a\\'];\\n        }\\n        curr->end=true;\\n    }\\n    \\n    bool search(string word) {\\n        // node *curr=head;\\n        queue<node*> q;\\n        q.push(head);\\n        for(char &c: word){\\n            int s = q.size();\\n            while(s--){\\n                node *curr = q.front();\\n                q.pop();\\n                if(c == \\'.\\'){\\n                    for(int i=0;i<26;i++){\\n                        if(curr->v[i] != nullptr) q.push(curr->v[i]);\\n                    }\\n                }\\n                else if(curr->v[c-\\'a\\'] != nullptr) q.push(curr->v[c-\\'a\\']);                \\n            }\\n        }\\n        while(!q.empty()){\\n            node *curr = q.front();\\n            q.pop();\\n            if(curr->end) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```"
                    },
                    {
                        "username": "vadim_spirin",
                        "content": "7/29 testcases passed. Leetcode says that my output is [null,null,null,true,true,true,true,true,true], but it expected [null,null,null,true,true,false,true,false,false]. I tried it in my IDE and my code outputs exactly what is expected. Why does it work like that??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Your solution might have some state that is not being reset properly between test cases."
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone help how this solution is giving WA on this TC :\n\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]] \n\n `your inline code..\n\npublic class TrieNode\n{\n    HashMap<Character,TrieNode>store;\n    boolean is_end;\n    TrieNode()\n    {\n        store = new HashMap<>();\n        is_end = false;\n    }\n}\nclass WordDictionary {\n    private TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        TrieNode curNode = root;\n        for(char c:word.toCharArray())\n        {\n            if(!curNode.store.containsKey(c))\n            {\n                curNode.store.put(c,new TrieNode());\n            }\n            curNode = curNode.store.get(c);\n        }\n        curNode.is_end = true;\n    }\n    \n    public boolean search(String word) {\n    \n       TrieNode curNode = root;\n       return solve(curNode,word,0);\n    }\n\n    public boolean solve(TrieNode node,String word,int idx)\n    {\n        if(idx == word.length())\n        {\n            return node.is_end;\n        }\n        char c = word.charAt(idx);\n        if(c == '.')\n        {\n            for(TrieNode child : node.store.values())\n            {\n                boolean val = solve(child,word,idx+1);\n                if(val == true)\n                {\n                    return true;\n                }\n                return false;\n            }\n        }\n         \n             TrieNode child = node.store.get(c);\n             if(child == null)\n             {\n                 return false;\n             }\n             return solve(child,word,idx+1);\n         }     \n    \n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */\n\n\n\n.your inline code...`"
                    },
                    {
                        "username": "paullam328",
                        "content": "You don't need a TrieNode in the first place.  Optimize that part first and just use nested HashTable.  isEnd can be replaced by HashMap['end'] = {}.  Go back to \"Implement Trie\" problem and get the most memory-optimized solution first, then work on this problem, your code will be much simpler and easier to debug in that sense."
                    },
                    {
                        "username": "Heisenberg2003",
                        "content": "```\\nclass WordDictionary {\\npublic:\\n    struct TrieNode\\n    {\\n        TrieNode* childs[26];\\n    };\\n\\n    unordered_map<TrieNode*,bool>isTerminal;\\n    TrieNode* root=new TrieNode();\\n\\n    WordDictionary() {\\n        root=new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        TrieNode* node=root;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            if(node->childs[word[i]-\\'a\\']==NULL)\\n            {\\n                node->childs[word[i]-\\'a\\']=new TrieNode();\\n            }\\n            node=node->childs[word[i]-\\'a\\'];\\n        }\\n        isTerminal[node]=true;\\n        return;\\n    }\\n\\n    bool searchstr(string str)\\n    {\\n        TrieNode* node=root;\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if(node->childs[str[i]-\\'a\\']==NULL)\\n            {\\n                return false;\\n            }\\n            node=node->childs[str[i]-\\'a\\'];\\n        }\\n        return isTerminal[node];\\n    }\\n\\n    void permute(vector<string>&ans,string word,int ptr)\\n    {\\n        if(ptr==word.size())\\n        {\\n            ans.push_back(word);\\n            return;\\n        }\\n        if(word[ptr]==\\'.\\')\\n        {\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n                word[ptr]=ch;\\n                permute(ans,word,ptr+1);\\n            }\\n        }\\n        else\\n        {\\n            permute(ans,word,ptr+1);\\n        }\\n        return;\\n    }\\n    \\n    bool search(string word) {\\n        vector<string>possible;\\n        permute(possible,word,0);\\n        bool found=false;\\n        for(auto str:possible)\\n        {\\n            found=found||searchstr(str);\\n        }\\n        return found;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```\\nWhy Does This Give TLE?"
                    },
                    {
                        "username": "iamhariom28",
                        "content": "class Node{\n    Node* links[26];\n    bool flag;\npublic:\n    bool containsKey(char ch){\n        return links[ch-'a']!=NULL;\n    }\n    void insertKey(char ch, Node* node){\n        links[ch-'a'] = node;\n    }\n    Node* getNext(char ch){\n        return links[ch-'a'];\n    }\n    void setEnd(){\n        flag = true;\n    }\n    bool isEnd(){\n        return flag;\n    }\n};\n\nclass WordDictionary {\n    Node* root;\npublic:\n    WordDictionary() {\n        root = new Node();\n    }\n    \n    void addWord(string word) {\n        Node* node = root;\n        for(int i=0;i<word.size();i++){\n            if(!node->containsKey(word[i])){\n                node->insertKey(word[i], new Node());\n            }\n            node = node->getNext(word[i]);\n        }\n        node->setEnd();\n    }\n    \n    bool search(string word) {\n        Node* node = root;\n        if(word.size()==0) return node->isEnd();\n\n        for(int i=0;i<word.size();i++){\n            if(word[i]=='.'){\n                bool found = false;\n                for(char ch = 'a';ch <= 'z';ch++){\n                    if(node->containsKey(ch)){\n                        found = true;\n                        node = node->getNext(ch);\n                        break;\n                    }\n                }\n                if(!found) return false;\n            }else{\n                if(node->containsKey(word[i])){\n                    cout<<word[i]<<endl;\n                    node = node->getNext(word[i]);\n                }else return false;\n            }\n        }\n        return node->isEnd();\n    }\n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary* obj = new WordDictionary();\n * obj->addWord(word);\n * bool param_2 = obj->search(word);\n */\n\n\n\nIt is giving me wrong answer for given test case, can anyone tell me what mistake I am doing?\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]]\n\nOutput:\n[null,null,null,null,null,false,false,null,false,true,false,false,true,false]\nExpected output:\n[null,null,null,null,null,false,false,null,true,true,false,false,true,false]\n\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Hey, I have done this problem by doubly LL. and after 20 test cases it shows TLE. can any one tell the best approach of comparing the dot(.) based word with previous words ? Actually i have added another another loop over there so its taking O(n2). thats why its giving TLE i guess."
                    },
                    {
                        "username": "user9157cE",
                        "content": "How ? I can\\'t pass testcase 17, I have ONE false value, how am I suppose to see the error when there is 3300+ different methods calls. I just don\\'t see how I can isolate the error to fix it. And I can\\'t imagine of any way why my code is wrong. It passes all edge case I can think of. It would be great if leetcode can highlight what input caused the mistake. \\nI can only think of making a function that count all output values, gives me all wrong output and do the same with the input to get the 1423th that gives me the wrong value. but even then what ? there is hundreds of words in the dictionary already. I don\\'t know how to go further here :/"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) You're welcome! Most people never reply so I'm glad to help someone who appreciates it.\n\nMy mistake on the initialization thing. I believe it's mostly a stylistic choice. It just looked unfamiliar to me. I googled it shortly afterwards and edited my comment to remove that, but you probably saw the original version of my comment in the email notification.\n\nNot using a `TrieNode` was similar in that it mostly looked strange, but after thinking about it, I can see that your way should work. The main reason to use a `TrieNode` is to have a separate data class. The class storing the data doesn't really need the `addWord()` and `Search()` methods on it. You see this in places like linked list problems too. The linked list node and linked list class are usually separate.\n\nHaving separate classes for the node and trie also gives you a place to store 'global' data about the trie. For example, if you want to keep a count of the number of words in the trie, that goes in the trie class not the node class. With your current design it would have to go into `WordDictionary` but then every node also has a count variable which is unused."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01) Thanks a lot ! I didn\\'t imagine someone would\\'ve helped me so much, you\\'ve made my day !\\n\\nI simply stored endOfWord one step too early, I don\\'t know how it worked so far like that lol. But basically if I add a word \"c\" the whole first level of letter would get endOfWord = true but I needed to do ```dict[letter].endOfWord = true``` instead. So adding adding \"mfqef\" and search for \"m\" is returning true even if there was never a \"m\" in the array.\\n\\nAs for the nodes by looking at others solution I just did not see the use of it here, I imagine there is a good reason to work like that but haven\\'t found it yet.\\n\\nAnd for the variable is it better like this ? \\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord;\\n    WordDictionary[] dict;\\n    int index;\\n    \\n    public WordDictionary() {\\n        this(-1);\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n        this.dict = new WordDictionary[26];\\n    }\\n}\\n```\\nI honestly don\\'t know the difference between initializing the variable in the class or in the constructor. (if there is no variable in the constructor)\\n\\nThanks again for your fast answers, you\\'ve helped me a lot ! My answer beat 74% so I\\'m very happy with it. I think I can optimize it a bit but not today lol.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) Ok, thanks for explaining. Now I understand what you meant by counting output values.\n\nI've cut the test case down a lot. I need to go to bed now, but hopefully you can work on it some more. It's 86 `addWord` calls and a single `search` at the end that fails. Drastically smaller, and it should be easier to remove more `addWord` calls now since you don't have the problem of different interleaved methods.\n\n```\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\"]\n```\n\n```\n[[],[\"xgvk\"],[\"wykzbvwdsoyfowqicymzd\"],[\"xajbtjyjuwgoynjgu\"],[\"qsibzxaorktypkfg\"],[\"vbycuvrkbcq\"],[\"sm\"],[\"fkqclfmvzpzpnbvz\"],[\"jpnneostllnnma\"],[\"zvmtfg\"],[\"lboe\"],[\"jypzkxnzc\"],[\"qes\"],[\"jioqlytzqx\"],[\"fojsjyiz\"],[\"qkprluekewtsftvbrjndpt\"],[\"mwsgyywmmkzmy\"],[\"tcjmitm\"],[\"pybk\"],[\"poljqcitty\"],[\"qfdabgsvkboyaq\"],[\"pvreuprpvoycadnsxaajrkh\"],[\"sv\"],[\"knmxzabetvqehv\"],[\"ziazu\"],[\"ghhelrzgbsmxkrnezif\"],[\"fn\"],[\"tnjcttrsozynjpqhox\"],[\"qhxcfujxmayzlsrctmsa\"],[\"fyaaivfrupktdgw\"],[\"aiurwhjnhxfqokgiumbeyfcwk\"],[\"y\"],[\"pqxtikjgislbvr\"],[\"halneyxidcqt\"],[\"ugifaaxdcqioabmy\"],[\"dlmcs\"],[\"monsnupyvxyqkegmtmb\"],[\"oexhcxlfcnyijwquaw\"],[\"phetnfndiwyce\"],[\"lofnodyf\"],[\"brrwqho\"],[\"xxaolhw\"],[\"pqmlmuhradvjsx\"],[\"brlhfbvcom\"],[\"v\"],[\"yuhscpvbe\"],[\"ejiavk\"],[\"kbhrkecoaomocvdss\"],[\"mecwmipivkrlotxtjavs\"],[\"hfnconmujvgumljeiakpejgd\"],[\"kwrxzundledqdqbawtrrthps\"],[\"qtzjqxsh\"],[\"apsokathssqpsblye\"],[\"sgvnrpegeqclxtclwzzh\"],[\"eougulzekfcqkxvamtd\"],[\"soasdxrbagqgtbi\"],[\"fdtwtnoh\"],[\"maxsbmlojhhvrumynwppqvm\"],[\"wqopnyebntkkvrea\"],[\"xxnruy\"],[\"eiovag\"],[\"ieryygffvhjcvwrhssvgqqjl\"],[\"g\"],[\"bxbzeccraoqzqreqomg\"],[\"ccg\"],[\"nueebqsegnjnybbs\"],[\"lbcsuh\"],[\"c\"],[\"tcvgwubm\"],[\"nrkwveryqc\"],[\"scapopfqf\"],[\"druwthqeowerqgskfzwvp\"],[\"mvsw\"],[\"oogbspsthyxmlqpqgdsnv\"],[\"hzzvtuhkpimxrxwn\"],[\"wxyrykx\"],[\"wftaqtjkqgabepcpboplcsz\"],[\"gprfavikjmxovw\"],[\"qnmhflhmonzwfdolvaoq\"],[\"fuymduy\"],[\"j\"],[\"tjedwvjtdghhkavwnuyfgkie\"],[\"gtyybcgckuotlmitribvb\"],[\"zchqgemhqjpoxla\"],[\"ldzhusmikkebme\"],[\"imnhhzj\"],[\"yylrxnnlpixqod\"],[\"m\"]]\n```\n\nBy the way, using `WordDictionary` as your node class instead of defining a separate `TrieNode` class stood out to me as being strange.\n\nMaybe your problem doesn't lie there, but it's something to consider."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01)  Thanks for the reply ! I\\'m gonna try harder a bit later but unfortunnately I\\'ve fought about your solution before. \\n\\nIf Leetcode can highligh the output #1681 they could highlight the input #1681 (its a search methods).\\n\\nI can\\'t cut the test case since they are all different length and in order. If I cut randomly 100 input then all the other will have an offset and won\\'t be valid since there is \"search\" and \"addWord\" methods and they don\\'t accept the same input. So cutting half the input would still require me to count each one exactly so they remain in order.\\n\\nMy solution isn\\'t like the other one I\\'ve seen, and nearly all other solutions are the same anyway, they all have the same approach and structure of code. So yeah I could go look a video on how they\\'ve done this but I won\\'t learn anything if I don\\'t know where\\'s my mistake. And I don\\'t think I have the wrong approach since 99% of my answer are correct.\\n\\nAnd yes a debugger would be helpful there, It would be a pain to create an entire new program just to make a debugger accept the input and calling my methods. Leetcode is basically forcing the use of their debugger here but as a student I can\\'t afford the premium, it\\'s half of what I pay for a year of college.\\n\\nAnyway here is my code , if anyone can find a SHORT testcase that doesn\\'t work it would help me greatly :D\\n\\n\\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord = false;\\n    WordDictionary[] dict = new WordDictionary[26];\\n    int index;\\n    \\n    public WordDictionary() {\\n        this.index = 0;\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n    }\\n    \\n    public void addWord(String word) {\\n        if(dict[toInt(word.charAt(index))] == null){\\n            dict[toInt(word.charAt(index))] = new WordDictionary(index);\\n        }\\n        if(index == word.length()-1){\\n            endOfWord = true;\\n        }else dict[toInt(word.charAt(index))].addWord(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        if(index == word.length()-1) return endOfWord && (word.charAt(index) == \\'.\\' ? true : dict[toInt(word.charAt(index))] != null);\\n        if(word.charAt(index) == \\'.\\'){\\n            for(WordDictionary d : dict){\\n                if(d != null && d.search(word)) return true;\\n            }\\n            return false;\\n        }else if(dict[toInt(word.charAt(index))] != null){\\n            return dict[toInt(word.charAt(index))].search(word);\\n        }\\n        return false;\\n    }\\n\\n    private int toInt(char c){\\n        return c-\\'a\\';\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It's a tough situation. I don't see how LeetCode could highlight what input caused the bug. It's obviously a combination of multiple method calls that triggered the bug.\n\nYou've got a few options (not necessarily in order):\n* Try to cut down the test case while still having it fail. It's tedious but I've done this. You sort of \"binary search\" it by cutting it in half and seeing if either of the halves fails. Can you reduce the number of addWord calls while still getting it to fail the search call? Then try to remove the other search calls. If you can shrink it enough you can get to a small enough test case to debug. Don't get stuck on exactly halving it though. You might have to play around with how many method calls you remove.\n* If you have LeetCode Premium you can use the debugger. Or set up a local debugger on your own system and try to debug it. Even though there are hundreds of words in the trie, you might still notice something wrong while debugging.\n* To aid in debugging add a method to print the entire trie.\n*  Review your solution very carefully. First take a break to clear your mind. Don't think of it as \"how can this possibly be wrong\". Think of it as \"I know something is wrong and I can find it. It's only 20-30 lines of code\".\n* Compare against other people's solutions. If you know their solution is correct, then any places where your code is different are prime suspects.\n* Get someone else to review your solution. They won't have your preconceptions about how your code works and the bug may be obvious to them.\n\nIt's not fun but it's good practice. We all have to debug code at work, and this is still easier than some non-reproducible bug. At least you know what input causes it to fail."
                    }
                ]
            },
            {
                "id": 1837611,
                "content": [
                    {
                        "username": "akeempositive",
                        "content": "After solving this challenge with acceptable answer.... All the edge cases are very much.. And this is one challenge that tests requires performance tuning at every stage to pass it acceptably... I was thinking with my data structure and memory usage, I will have a poor rating on memory beats.... But it still beats 97% which is exactly why I think this is freaking hard a challenge "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "No way! I just used the stupidest possible brute force solution with arrays and its build-in find method and still got accepted and moreover it says my solution is faster than 96%  and uses less memory than 97% of other solutions, how is that even possible?? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "aryan20022003",
                        "content": "getting error use Array of Node and use memset for setting node NULL"
                    },
                    {
                        "username": "coderinterview",
                        "content": "I am using trie to store individual charcters in form of tree. \\nFor search I used BFS using queue, which should be faster than DFS using recursion and I am able to pass the testcases by \"run\", but when I \"submit\" I get TLE for same test cases. \\nCan someone please explain what I am missing?\\n```\\nclass WordDictionary {\\nprivate:\\n    struct node{\\n        bool end;\\n        node* v[26];\\n        node(){\\n            end=false;\\n            for(int i=0;i<26;i++){\\n                v[i]=nullptr;\\n            }\\n        }\\n        ~node() {}\\n    };\\n    node *head;\\npublic:        \\n    WordDictionary() {\\n        head = new node();\\n    }\\n    \\n    void addWord(string word) {\\n        node *curr = head;        \\n        for(char &c: word){\\n            if(curr->v[c-\\'a\\'] == nullptr) curr->v[c-\\'a\\'] = new node();\\n            curr = curr->v[c-\\'a\\'];\\n        }\\n        curr->end=true;\\n    }\\n    \\n    bool search(string word) {\\n        // node *curr=head;\\n        queue<node*> q;\\n        q.push(head);\\n        for(char &c: word){\\n            int s = q.size();\\n            while(s--){\\n                node *curr = q.front();\\n                q.pop();\\n                if(c == \\'.\\'){\\n                    for(int i=0;i<26;i++){\\n                        if(curr->v[i] != nullptr) q.push(curr->v[i]);\\n                    }\\n                }\\n                else if(curr->v[c-\\'a\\'] != nullptr) q.push(curr->v[c-\\'a\\']);                \\n            }\\n        }\\n        while(!q.empty()){\\n            node *curr = q.front();\\n            q.pop();\\n            if(curr->end) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```"
                    },
                    {
                        "username": "vadim_spirin",
                        "content": "7/29 testcases passed. Leetcode says that my output is [null,null,null,true,true,true,true,true,true], but it expected [null,null,null,true,true,false,true,false,false]. I tried it in my IDE and my code outputs exactly what is expected. Why does it work like that??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Your solution might have some state that is not being reset properly between test cases."
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone help how this solution is giving WA on this TC :\n\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]] \n\n `your inline code..\n\npublic class TrieNode\n{\n    HashMap<Character,TrieNode>store;\n    boolean is_end;\n    TrieNode()\n    {\n        store = new HashMap<>();\n        is_end = false;\n    }\n}\nclass WordDictionary {\n    private TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        TrieNode curNode = root;\n        for(char c:word.toCharArray())\n        {\n            if(!curNode.store.containsKey(c))\n            {\n                curNode.store.put(c,new TrieNode());\n            }\n            curNode = curNode.store.get(c);\n        }\n        curNode.is_end = true;\n    }\n    \n    public boolean search(String word) {\n    \n       TrieNode curNode = root;\n       return solve(curNode,word,0);\n    }\n\n    public boolean solve(TrieNode node,String word,int idx)\n    {\n        if(idx == word.length())\n        {\n            return node.is_end;\n        }\n        char c = word.charAt(idx);\n        if(c == '.')\n        {\n            for(TrieNode child : node.store.values())\n            {\n                boolean val = solve(child,word,idx+1);\n                if(val == true)\n                {\n                    return true;\n                }\n                return false;\n            }\n        }\n         \n             TrieNode child = node.store.get(c);\n             if(child == null)\n             {\n                 return false;\n             }\n             return solve(child,word,idx+1);\n         }     \n    \n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */\n\n\n\n.your inline code...`"
                    },
                    {
                        "username": "paullam328",
                        "content": "You don't need a TrieNode in the first place.  Optimize that part first and just use nested HashTable.  isEnd can be replaced by HashMap['end'] = {}.  Go back to \"Implement Trie\" problem and get the most memory-optimized solution first, then work on this problem, your code will be much simpler and easier to debug in that sense."
                    },
                    {
                        "username": "Heisenberg2003",
                        "content": "```\\nclass WordDictionary {\\npublic:\\n    struct TrieNode\\n    {\\n        TrieNode* childs[26];\\n    };\\n\\n    unordered_map<TrieNode*,bool>isTerminal;\\n    TrieNode* root=new TrieNode();\\n\\n    WordDictionary() {\\n        root=new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        TrieNode* node=root;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            if(node->childs[word[i]-\\'a\\']==NULL)\\n            {\\n                node->childs[word[i]-\\'a\\']=new TrieNode();\\n            }\\n            node=node->childs[word[i]-\\'a\\'];\\n        }\\n        isTerminal[node]=true;\\n        return;\\n    }\\n\\n    bool searchstr(string str)\\n    {\\n        TrieNode* node=root;\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if(node->childs[str[i]-\\'a\\']==NULL)\\n            {\\n                return false;\\n            }\\n            node=node->childs[str[i]-\\'a\\'];\\n        }\\n        return isTerminal[node];\\n    }\\n\\n    void permute(vector<string>&ans,string word,int ptr)\\n    {\\n        if(ptr==word.size())\\n        {\\n            ans.push_back(word);\\n            return;\\n        }\\n        if(word[ptr]==\\'.\\')\\n        {\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n                word[ptr]=ch;\\n                permute(ans,word,ptr+1);\\n            }\\n        }\\n        else\\n        {\\n            permute(ans,word,ptr+1);\\n        }\\n        return;\\n    }\\n    \\n    bool search(string word) {\\n        vector<string>possible;\\n        permute(possible,word,0);\\n        bool found=false;\\n        for(auto str:possible)\\n        {\\n            found=found||searchstr(str);\\n        }\\n        return found;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```\\nWhy Does This Give TLE?"
                    },
                    {
                        "username": "iamhariom28",
                        "content": "class Node{\n    Node* links[26];\n    bool flag;\npublic:\n    bool containsKey(char ch){\n        return links[ch-'a']!=NULL;\n    }\n    void insertKey(char ch, Node* node){\n        links[ch-'a'] = node;\n    }\n    Node* getNext(char ch){\n        return links[ch-'a'];\n    }\n    void setEnd(){\n        flag = true;\n    }\n    bool isEnd(){\n        return flag;\n    }\n};\n\nclass WordDictionary {\n    Node* root;\npublic:\n    WordDictionary() {\n        root = new Node();\n    }\n    \n    void addWord(string word) {\n        Node* node = root;\n        for(int i=0;i<word.size();i++){\n            if(!node->containsKey(word[i])){\n                node->insertKey(word[i], new Node());\n            }\n            node = node->getNext(word[i]);\n        }\n        node->setEnd();\n    }\n    \n    bool search(string word) {\n        Node* node = root;\n        if(word.size()==0) return node->isEnd();\n\n        for(int i=0;i<word.size();i++){\n            if(word[i]=='.'){\n                bool found = false;\n                for(char ch = 'a';ch <= 'z';ch++){\n                    if(node->containsKey(ch)){\n                        found = true;\n                        node = node->getNext(ch);\n                        break;\n                    }\n                }\n                if(!found) return false;\n            }else{\n                if(node->containsKey(word[i])){\n                    cout<<word[i]<<endl;\n                    node = node->getNext(word[i]);\n                }else return false;\n            }\n        }\n        return node->isEnd();\n    }\n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary* obj = new WordDictionary();\n * obj->addWord(word);\n * bool param_2 = obj->search(word);\n */\n\n\n\nIt is giving me wrong answer for given test case, can anyone tell me what mistake I am doing?\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]]\n\nOutput:\n[null,null,null,null,null,false,false,null,false,true,false,false,true,false]\nExpected output:\n[null,null,null,null,null,false,false,null,true,true,false,false,true,false]\n\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Hey, I have done this problem by doubly LL. and after 20 test cases it shows TLE. can any one tell the best approach of comparing the dot(.) based word with previous words ? Actually i have added another another loop over there so its taking O(n2). thats why its giving TLE i guess."
                    },
                    {
                        "username": "user9157cE",
                        "content": "How ? I can\\'t pass testcase 17, I have ONE false value, how am I suppose to see the error when there is 3300+ different methods calls. I just don\\'t see how I can isolate the error to fix it. And I can\\'t imagine of any way why my code is wrong. It passes all edge case I can think of. It would be great if leetcode can highlight what input caused the mistake. \\nI can only think of making a function that count all output values, gives me all wrong output and do the same with the input to get the 1423th that gives me the wrong value. but even then what ? there is hundreds of words in the dictionary already. I don\\'t know how to go further here :/"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) You're welcome! Most people never reply so I'm glad to help someone who appreciates it.\n\nMy mistake on the initialization thing. I believe it's mostly a stylistic choice. It just looked unfamiliar to me. I googled it shortly afterwards and edited my comment to remove that, but you probably saw the original version of my comment in the email notification.\n\nNot using a `TrieNode` was similar in that it mostly looked strange, but after thinking about it, I can see that your way should work. The main reason to use a `TrieNode` is to have a separate data class. The class storing the data doesn't really need the `addWord()` and `Search()` methods on it. You see this in places like linked list problems too. The linked list node and linked list class are usually separate.\n\nHaving separate classes for the node and trie also gives you a place to store 'global' data about the trie. For example, if you want to keep a count of the number of words in the trie, that goes in the trie class not the node class. With your current design it would have to go into `WordDictionary` but then every node also has a count variable which is unused."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01) Thanks a lot ! I didn\\'t imagine someone would\\'ve helped me so much, you\\'ve made my day !\\n\\nI simply stored endOfWord one step too early, I don\\'t know how it worked so far like that lol. But basically if I add a word \"c\" the whole first level of letter would get endOfWord = true but I needed to do ```dict[letter].endOfWord = true``` instead. So adding adding \"mfqef\" and search for \"m\" is returning true even if there was never a \"m\" in the array.\\n\\nAs for the nodes by looking at others solution I just did not see the use of it here, I imagine there is a good reason to work like that but haven\\'t found it yet.\\n\\nAnd for the variable is it better like this ? \\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord;\\n    WordDictionary[] dict;\\n    int index;\\n    \\n    public WordDictionary() {\\n        this(-1);\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n        this.dict = new WordDictionary[26];\\n    }\\n}\\n```\\nI honestly don\\'t know the difference between initializing the variable in the class or in the constructor. (if there is no variable in the constructor)\\n\\nThanks again for your fast answers, you\\'ve helped me a lot ! My answer beat 74% so I\\'m very happy with it. I think I can optimize it a bit but not today lol.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) Ok, thanks for explaining. Now I understand what you meant by counting output values.\n\nI've cut the test case down a lot. I need to go to bed now, but hopefully you can work on it some more. It's 86 `addWord` calls and a single `search` at the end that fails. Drastically smaller, and it should be easier to remove more `addWord` calls now since you don't have the problem of different interleaved methods.\n\n```\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\"]\n```\n\n```\n[[],[\"xgvk\"],[\"wykzbvwdsoyfowqicymzd\"],[\"xajbtjyjuwgoynjgu\"],[\"qsibzxaorktypkfg\"],[\"vbycuvrkbcq\"],[\"sm\"],[\"fkqclfmvzpzpnbvz\"],[\"jpnneostllnnma\"],[\"zvmtfg\"],[\"lboe\"],[\"jypzkxnzc\"],[\"qes\"],[\"jioqlytzqx\"],[\"fojsjyiz\"],[\"qkprluekewtsftvbrjndpt\"],[\"mwsgyywmmkzmy\"],[\"tcjmitm\"],[\"pybk\"],[\"poljqcitty\"],[\"qfdabgsvkboyaq\"],[\"pvreuprpvoycadnsxaajrkh\"],[\"sv\"],[\"knmxzabetvqehv\"],[\"ziazu\"],[\"ghhelrzgbsmxkrnezif\"],[\"fn\"],[\"tnjcttrsozynjpqhox\"],[\"qhxcfujxmayzlsrctmsa\"],[\"fyaaivfrupktdgw\"],[\"aiurwhjnhxfqokgiumbeyfcwk\"],[\"y\"],[\"pqxtikjgislbvr\"],[\"halneyxidcqt\"],[\"ugifaaxdcqioabmy\"],[\"dlmcs\"],[\"monsnupyvxyqkegmtmb\"],[\"oexhcxlfcnyijwquaw\"],[\"phetnfndiwyce\"],[\"lofnodyf\"],[\"brrwqho\"],[\"xxaolhw\"],[\"pqmlmuhradvjsx\"],[\"brlhfbvcom\"],[\"v\"],[\"yuhscpvbe\"],[\"ejiavk\"],[\"kbhrkecoaomocvdss\"],[\"mecwmipivkrlotxtjavs\"],[\"hfnconmujvgumljeiakpejgd\"],[\"kwrxzundledqdqbawtrrthps\"],[\"qtzjqxsh\"],[\"apsokathssqpsblye\"],[\"sgvnrpegeqclxtclwzzh\"],[\"eougulzekfcqkxvamtd\"],[\"soasdxrbagqgtbi\"],[\"fdtwtnoh\"],[\"maxsbmlojhhvrumynwppqvm\"],[\"wqopnyebntkkvrea\"],[\"xxnruy\"],[\"eiovag\"],[\"ieryygffvhjcvwrhssvgqqjl\"],[\"g\"],[\"bxbzeccraoqzqreqomg\"],[\"ccg\"],[\"nueebqsegnjnybbs\"],[\"lbcsuh\"],[\"c\"],[\"tcvgwubm\"],[\"nrkwveryqc\"],[\"scapopfqf\"],[\"druwthqeowerqgskfzwvp\"],[\"mvsw\"],[\"oogbspsthyxmlqpqgdsnv\"],[\"hzzvtuhkpimxrxwn\"],[\"wxyrykx\"],[\"wftaqtjkqgabepcpboplcsz\"],[\"gprfavikjmxovw\"],[\"qnmhflhmonzwfdolvaoq\"],[\"fuymduy\"],[\"j\"],[\"tjedwvjtdghhkavwnuyfgkie\"],[\"gtyybcgckuotlmitribvb\"],[\"zchqgemhqjpoxla\"],[\"ldzhusmikkebme\"],[\"imnhhzj\"],[\"yylrxnnlpixqod\"],[\"m\"]]\n```\n\nBy the way, using `WordDictionary` as your node class instead of defining a separate `TrieNode` class stood out to me as being strange.\n\nMaybe your problem doesn't lie there, but it's something to consider."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01)  Thanks for the reply ! I\\'m gonna try harder a bit later but unfortunnately I\\'ve fought about your solution before. \\n\\nIf Leetcode can highligh the output #1681 they could highlight the input #1681 (its a search methods).\\n\\nI can\\'t cut the test case since they are all different length and in order. If I cut randomly 100 input then all the other will have an offset and won\\'t be valid since there is \"search\" and \"addWord\" methods and they don\\'t accept the same input. So cutting half the input would still require me to count each one exactly so they remain in order.\\n\\nMy solution isn\\'t like the other one I\\'ve seen, and nearly all other solutions are the same anyway, they all have the same approach and structure of code. So yeah I could go look a video on how they\\'ve done this but I won\\'t learn anything if I don\\'t know where\\'s my mistake. And I don\\'t think I have the wrong approach since 99% of my answer are correct.\\n\\nAnd yes a debugger would be helpful there, It would be a pain to create an entire new program just to make a debugger accept the input and calling my methods. Leetcode is basically forcing the use of their debugger here but as a student I can\\'t afford the premium, it\\'s half of what I pay for a year of college.\\n\\nAnyway here is my code , if anyone can find a SHORT testcase that doesn\\'t work it would help me greatly :D\\n\\n\\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord = false;\\n    WordDictionary[] dict = new WordDictionary[26];\\n    int index;\\n    \\n    public WordDictionary() {\\n        this.index = 0;\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n    }\\n    \\n    public void addWord(String word) {\\n        if(dict[toInt(word.charAt(index))] == null){\\n            dict[toInt(word.charAt(index))] = new WordDictionary(index);\\n        }\\n        if(index == word.length()-1){\\n            endOfWord = true;\\n        }else dict[toInt(word.charAt(index))].addWord(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        if(index == word.length()-1) return endOfWord && (word.charAt(index) == \\'.\\' ? true : dict[toInt(word.charAt(index))] != null);\\n        if(word.charAt(index) == \\'.\\'){\\n            for(WordDictionary d : dict){\\n                if(d != null && d.search(word)) return true;\\n            }\\n            return false;\\n        }else if(dict[toInt(word.charAt(index))] != null){\\n            return dict[toInt(word.charAt(index))].search(word);\\n        }\\n        return false;\\n    }\\n\\n    private int toInt(char c){\\n        return c-\\'a\\';\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It's a tough situation. I don't see how LeetCode could highlight what input caused the bug. It's obviously a combination of multiple method calls that triggered the bug.\n\nYou've got a few options (not necessarily in order):\n* Try to cut down the test case while still having it fail. It's tedious but I've done this. You sort of \"binary search\" it by cutting it in half and seeing if either of the halves fails. Can you reduce the number of addWord calls while still getting it to fail the search call? Then try to remove the other search calls. If you can shrink it enough you can get to a small enough test case to debug. Don't get stuck on exactly halving it though. You might have to play around with how many method calls you remove.\n* If you have LeetCode Premium you can use the debugger. Or set up a local debugger on your own system and try to debug it. Even though there are hundreds of words in the trie, you might still notice something wrong while debugging.\n* To aid in debugging add a method to print the entire trie.\n*  Review your solution very carefully. First take a break to clear your mind. Don't think of it as \"how can this possibly be wrong\". Think of it as \"I know something is wrong and I can find it. It's only 20-30 lines of code\".\n* Compare against other people's solutions. If you know their solution is correct, then any places where your code is different are prime suspects.\n* Get someone else to review your solution. They won't have your preconceptions about how your code works and the bug may be obvious to them.\n\nIt's not fun but it's good practice. We all have to debug code at work, and this is still easier than some non-reproducible bug. At least you know what input causes it to fail."
                    }
                ]
            },
            {
                "id": 1837571,
                "content": [
                    {
                        "username": "akeempositive",
                        "content": "After solving this challenge with acceptable answer.... All the edge cases are very much.. And this is one challenge that tests requires performance tuning at every stage to pass it acceptably... I was thinking with my data structure and memory usage, I will have a poor rating on memory beats.... But it still beats 97% which is exactly why I think this is freaking hard a challenge "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "No way! I just used the stupidest possible brute force solution with arrays and its build-in find method and still got accepted and moreover it says my solution is faster than 96%  and uses less memory than 97% of other solutions, how is that even possible?? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "aryan20022003",
                        "content": "getting error use Array of Node and use memset for setting node NULL"
                    },
                    {
                        "username": "coderinterview",
                        "content": "I am using trie to store individual charcters in form of tree. \\nFor search I used BFS using queue, which should be faster than DFS using recursion and I am able to pass the testcases by \"run\", but when I \"submit\" I get TLE for same test cases. \\nCan someone please explain what I am missing?\\n```\\nclass WordDictionary {\\nprivate:\\n    struct node{\\n        bool end;\\n        node* v[26];\\n        node(){\\n            end=false;\\n            for(int i=0;i<26;i++){\\n                v[i]=nullptr;\\n            }\\n        }\\n        ~node() {}\\n    };\\n    node *head;\\npublic:        \\n    WordDictionary() {\\n        head = new node();\\n    }\\n    \\n    void addWord(string word) {\\n        node *curr = head;        \\n        for(char &c: word){\\n            if(curr->v[c-\\'a\\'] == nullptr) curr->v[c-\\'a\\'] = new node();\\n            curr = curr->v[c-\\'a\\'];\\n        }\\n        curr->end=true;\\n    }\\n    \\n    bool search(string word) {\\n        // node *curr=head;\\n        queue<node*> q;\\n        q.push(head);\\n        for(char &c: word){\\n            int s = q.size();\\n            while(s--){\\n                node *curr = q.front();\\n                q.pop();\\n                if(c == \\'.\\'){\\n                    for(int i=0;i<26;i++){\\n                        if(curr->v[i] != nullptr) q.push(curr->v[i]);\\n                    }\\n                }\\n                else if(curr->v[c-\\'a\\'] != nullptr) q.push(curr->v[c-\\'a\\']);                \\n            }\\n        }\\n        while(!q.empty()){\\n            node *curr = q.front();\\n            q.pop();\\n            if(curr->end) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```"
                    },
                    {
                        "username": "vadim_spirin",
                        "content": "7/29 testcases passed. Leetcode says that my output is [null,null,null,true,true,true,true,true,true], but it expected [null,null,null,true,true,false,true,false,false]. I tried it in my IDE and my code outputs exactly what is expected. Why does it work like that??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Your solution might have some state that is not being reset properly between test cases."
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone help how this solution is giving WA on this TC :\n\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]] \n\n `your inline code..\n\npublic class TrieNode\n{\n    HashMap<Character,TrieNode>store;\n    boolean is_end;\n    TrieNode()\n    {\n        store = new HashMap<>();\n        is_end = false;\n    }\n}\nclass WordDictionary {\n    private TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        TrieNode curNode = root;\n        for(char c:word.toCharArray())\n        {\n            if(!curNode.store.containsKey(c))\n            {\n                curNode.store.put(c,new TrieNode());\n            }\n            curNode = curNode.store.get(c);\n        }\n        curNode.is_end = true;\n    }\n    \n    public boolean search(String word) {\n    \n       TrieNode curNode = root;\n       return solve(curNode,word,0);\n    }\n\n    public boolean solve(TrieNode node,String word,int idx)\n    {\n        if(idx == word.length())\n        {\n            return node.is_end;\n        }\n        char c = word.charAt(idx);\n        if(c == '.')\n        {\n            for(TrieNode child : node.store.values())\n            {\n                boolean val = solve(child,word,idx+1);\n                if(val == true)\n                {\n                    return true;\n                }\n                return false;\n            }\n        }\n         \n             TrieNode child = node.store.get(c);\n             if(child == null)\n             {\n                 return false;\n             }\n             return solve(child,word,idx+1);\n         }     \n    \n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */\n\n\n\n.your inline code...`"
                    },
                    {
                        "username": "paullam328",
                        "content": "You don't need a TrieNode in the first place.  Optimize that part first and just use nested HashTable.  isEnd can be replaced by HashMap['end'] = {}.  Go back to \"Implement Trie\" problem and get the most memory-optimized solution first, then work on this problem, your code will be much simpler and easier to debug in that sense."
                    },
                    {
                        "username": "Heisenberg2003",
                        "content": "```\\nclass WordDictionary {\\npublic:\\n    struct TrieNode\\n    {\\n        TrieNode* childs[26];\\n    };\\n\\n    unordered_map<TrieNode*,bool>isTerminal;\\n    TrieNode* root=new TrieNode();\\n\\n    WordDictionary() {\\n        root=new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        TrieNode* node=root;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            if(node->childs[word[i]-\\'a\\']==NULL)\\n            {\\n                node->childs[word[i]-\\'a\\']=new TrieNode();\\n            }\\n            node=node->childs[word[i]-\\'a\\'];\\n        }\\n        isTerminal[node]=true;\\n        return;\\n    }\\n\\n    bool searchstr(string str)\\n    {\\n        TrieNode* node=root;\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if(node->childs[str[i]-\\'a\\']==NULL)\\n            {\\n                return false;\\n            }\\n            node=node->childs[str[i]-\\'a\\'];\\n        }\\n        return isTerminal[node];\\n    }\\n\\n    void permute(vector<string>&ans,string word,int ptr)\\n    {\\n        if(ptr==word.size())\\n        {\\n            ans.push_back(word);\\n            return;\\n        }\\n        if(word[ptr]==\\'.\\')\\n        {\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n                word[ptr]=ch;\\n                permute(ans,word,ptr+1);\\n            }\\n        }\\n        else\\n        {\\n            permute(ans,word,ptr+1);\\n        }\\n        return;\\n    }\\n    \\n    bool search(string word) {\\n        vector<string>possible;\\n        permute(possible,word,0);\\n        bool found=false;\\n        for(auto str:possible)\\n        {\\n            found=found||searchstr(str);\\n        }\\n        return found;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```\\nWhy Does This Give TLE?"
                    },
                    {
                        "username": "iamhariom28",
                        "content": "class Node{\n    Node* links[26];\n    bool flag;\npublic:\n    bool containsKey(char ch){\n        return links[ch-'a']!=NULL;\n    }\n    void insertKey(char ch, Node* node){\n        links[ch-'a'] = node;\n    }\n    Node* getNext(char ch){\n        return links[ch-'a'];\n    }\n    void setEnd(){\n        flag = true;\n    }\n    bool isEnd(){\n        return flag;\n    }\n};\n\nclass WordDictionary {\n    Node* root;\npublic:\n    WordDictionary() {\n        root = new Node();\n    }\n    \n    void addWord(string word) {\n        Node* node = root;\n        for(int i=0;i<word.size();i++){\n            if(!node->containsKey(word[i])){\n                node->insertKey(word[i], new Node());\n            }\n            node = node->getNext(word[i]);\n        }\n        node->setEnd();\n    }\n    \n    bool search(string word) {\n        Node* node = root;\n        if(word.size()==0) return node->isEnd();\n\n        for(int i=0;i<word.size();i++){\n            if(word[i]=='.'){\n                bool found = false;\n                for(char ch = 'a';ch <= 'z';ch++){\n                    if(node->containsKey(ch)){\n                        found = true;\n                        node = node->getNext(ch);\n                        break;\n                    }\n                }\n                if(!found) return false;\n            }else{\n                if(node->containsKey(word[i])){\n                    cout<<word[i]<<endl;\n                    node = node->getNext(word[i]);\n                }else return false;\n            }\n        }\n        return node->isEnd();\n    }\n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary* obj = new WordDictionary();\n * obj->addWord(word);\n * bool param_2 = obj->search(word);\n */\n\n\n\nIt is giving me wrong answer for given test case, can anyone tell me what mistake I am doing?\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]]\n\nOutput:\n[null,null,null,null,null,false,false,null,false,true,false,false,true,false]\nExpected output:\n[null,null,null,null,null,false,false,null,true,true,false,false,true,false]\n\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Hey, I have done this problem by doubly LL. and after 20 test cases it shows TLE. can any one tell the best approach of comparing the dot(.) based word with previous words ? Actually i have added another another loop over there so its taking O(n2). thats why its giving TLE i guess."
                    },
                    {
                        "username": "user9157cE",
                        "content": "How ? I can\\'t pass testcase 17, I have ONE false value, how am I suppose to see the error when there is 3300+ different methods calls. I just don\\'t see how I can isolate the error to fix it. And I can\\'t imagine of any way why my code is wrong. It passes all edge case I can think of. It would be great if leetcode can highlight what input caused the mistake. \\nI can only think of making a function that count all output values, gives me all wrong output and do the same with the input to get the 1423th that gives me the wrong value. but even then what ? there is hundreds of words in the dictionary already. I don\\'t know how to go further here :/"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) You're welcome! Most people never reply so I'm glad to help someone who appreciates it.\n\nMy mistake on the initialization thing. I believe it's mostly a stylistic choice. It just looked unfamiliar to me. I googled it shortly afterwards and edited my comment to remove that, but you probably saw the original version of my comment in the email notification.\n\nNot using a `TrieNode` was similar in that it mostly looked strange, but after thinking about it, I can see that your way should work. The main reason to use a `TrieNode` is to have a separate data class. The class storing the data doesn't really need the `addWord()` and `Search()` methods on it. You see this in places like linked list problems too. The linked list node and linked list class are usually separate.\n\nHaving separate classes for the node and trie also gives you a place to store 'global' data about the trie. For example, if you want to keep a count of the number of words in the trie, that goes in the trie class not the node class. With your current design it would have to go into `WordDictionary` but then every node also has a count variable which is unused."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01) Thanks a lot ! I didn\\'t imagine someone would\\'ve helped me so much, you\\'ve made my day !\\n\\nI simply stored endOfWord one step too early, I don\\'t know how it worked so far like that lol. But basically if I add a word \"c\" the whole first level of letter would get endOfWord = true but I needed to do ```dict[letter].endOfWord = true``` instead. So adding adding \"mfqef\" and search for \"m\" is returning true even if there was never a \"m\" in the array.\\n\\nAs for the nodes by looking at others solution I just did not see the use of it here, I imagine there is a good reason to work like that but haven\\'t found it yet.\\n\\nAnd for the variable is it better like this ? \\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord;\\n    WordDictionary[] dict;\\n    int index;\\n    \\n    public WordDictionary() {\\n        this(-1);\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n        this.dict = new WordDictionary[26];\\n    }\\n}\\n```\\nI honestly don\\'t know the difference between initializing the variable in the class or in the constructor. (if there is no variable in the constructor)\\n\\nThanks again for your fast answers, you\\'ve helped me a lot ! My answer beat 74% so I\\'m very happy with it. I think I can optimize it a bit but not today lol.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) Ok, thanks for explaining. Now I understand what you meant by counting output values.\n\nI've cut the test case down a lot. I need to go to bed now, but hopefully you can work on it some more. It's 86 `addWord` calls and a single `search` at the end that fails. Drastically smaller, and it should be easier to remove more `addWord` calls now since you don't have the problem of different interleaved methods.\n\n```\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\"]\n```\n\n```\n[[],[\"xgvk\"],[\"wykzbvwdsoyfowqicymzd\"],[\"xajbtjyjuwgoynjgu\"],[\"qsibzxaorktypkfg\"],[\"vbycuvrkbcq\"],[\"sm\"],[\"fkqclfmvzpzpnbvz\"],[\"jpnneostllnnma\"],[\"zvmtfg\"],[\"lboe\"],[\"jypzkxnzc\"],[\"qes\"],[\"jioqlytzqx\"],[\"fojsjyiz\"],[\"qkprluekewtsftvbrjndpt\"],[\"mwsgyywmmkzmy\"],[\"tcjmitm\"],[\"pybk\"],[\"poljqcitty\"],[\"qfdabgsvkboyaq\"],[\"pvreuprpvoycadnsxaajrkh\"],[\"sv\"],[\"knmxzabetvqehv\"],[\"ziazu\"],[\"ghhelrzgbsmxkrnezif\"],[\"fn\"],[\"tnjcttrsozynjpqhox\"],[\"qhxcfujxmayzlsrctmsa\"],[\"fyaaivfrupktdgw\"],[\"aiurwhjnhxfqokgiumbeyfcwk\"],[\"y\"],[\"pqxtikjgislbvr\"],[\"halneyxidcqt\"],[\"ugifaaxdcqioabmy\"],[\"dlmcs\"],[\"monsnupyvxyqkegmtmb\"],[\"oexhcxlfcnyijwquaw\"],[\"phetnfndiwyce\"],[\"lofnodyf\"],[\"brrwqho\"],[\"xxaolhw\"],[\"pqmlmuhradvjsx\"],[\"brlhfbvcom\"],[\"v\"],[\"yuhscpvbe\"],[\"ejiavk\"],[\"kbhrkecoaomocvdss\"],[\"mecwmipivkrlotxtjavs\"],[\"hfnconmujvgumljeiakpejgd\"],[\"kwrxzundledqdqbawtrrthps\"],[\"qtzjqxsh\"],[\"apsokathssqpsblye\"],[\"sgvnrpegeqclxtclwzzh\"],[\"eougulzekfcqkxvamtd\"],[\"soasdxrbagqgtbi\"],[\"fdtwtnoh\"],[\"maxsbmlojhhvrumynwppqvm\"],[\"wqopnyebntkkvrea\"],[\"xxnruy\"],[\"eiovag\"],[\"ieryygffvhjcvwrhssvgqqjl\"],[\"g\"],[\"bxbzeccraoqzqreqomg\"],[\"ccg\"],[\"nueebqsegnjnybbs\"],[\"lbcsuh\"],[\"c\"],[\"tcvgwubm\"],[\"nrkwveryqc\"],[\"scapopfqf\"],[\"druwthqeowerqgskfzwvp\"],[\"mvsw\"],[\"oogbspsthyxmlqpqgdsnv\"],[\"hzzvtuhkpimxrxwn\"],[\"wxyrykx\"],[\"wftaqtjkqgabepcpboplcsz\"],[\"gprfavikjmxovw\"],[\"qnmhflhmonzwfdolvaoq\"],[\"fuymduy\"],[\"j\"],[\"tjedwvjtdghhkavwnuyfgkie\"],[\"gtyybcgckuotlmitribvb\"],[\"zchqgemhqjpoxla\"],[\"ldzhusmikkebme\"],[\"imnhhzj\"],[\"yylrxnnlpixqod\"],[\"m\"]]\n```\n\nBy the way, using `WordDictionary` as your node class instead of defining a separate `TrieNode` class stood out to me as being strange.\n\nMaybe your problem doesn't lie there, but it's something to consider."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01)  Thanks for the reply ! I\\'m gonna try harder a bit later but unfortunnately I\\'ve fought about your solution before. \\n\\nIf Leetcode can highligh the output #1681 they could highlight the input #1681 (its a search methods).\\n\\nI can\\'t cut the test case since they are all different length and in order. If I cut randomly 100 input then all the other will have an offset and won\\'t be valid since there is \"search\" and \"addWord\" methods and they don\\'t accept the same input. So cutting half the input would still require me to count each one exactly so they remain in order.\\n\\nMy solution isn\\'t like the other one I\\'ve seen, and nearly all other solutions are the same anyway, they all have the same approach and structure of code. So yeah I could go look a video on how they\\'ve done this but I won\\'t learn anything if I don\\'t know where\\'s my mistake. And I don\\'t think I have the wrong approach since 99% of my answer are correct.\\n\\nAnd yes a debugger would be helpful there, It would be a pain to create an entire new program just to make a debugger accept the input and calling my methods. Leetcode is basically forcing the use of their debugger here but as a student I can\\'t afford the premium, it\\'s half of what I pay for a year of college.\\n\\nAnyway here is my code , if anyone can find a SHORT testcase that doesn\\'t work it would help me greatly :D\\n\\n\\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord = false;\\n    WordDictionary[] dict = new WordDictionary[26];\\n    int index;\\n    \\n    public WordDictionary() {\\n        this.index = 0;\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n    }\\n    \\n    public void addWord(String word) {\\n        if(dict[toInt(word.charAt(index))] == null){\\n            dict[toInt(word.charAt(index))] = new WordDictionary(index);\\n        }\\n        if(index == word.length()-1){\\n            endOfWord = true;\\n        }else dict[toInt(word.charAt(index))].addWord(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        if(index == word.length()-1) return endOfWord && (word.charAt(index) == \\'.\\' ? true : dict[toInt(word.charAt(index))] != null);\\n        if(word.charAt(index) == \\'.\\'){\\n            for(WordDictionary d : dict){\\n                if(d != null && d.search(word)) return true;\\n            }\\n            return false;\\n        }else if(dict[toInt(word.charAt(index))] != null){\\n            return dict[toInt(word.charAt(index))].search(word);\\n        }\\n        return false;\\n    }\\n\\n    private int toInt(char c){\\n        return c-\\'a\\';\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It's a tough situation. I don't see how LeetCode could highlight what input caused the bug. It's obviously a combination of multiple method calls that triggered the bug.\n\nYou've got a few options (not necessarily in order):\n* Try to cut down the test case while still having it fail. It's tedious but I've done this. You sort of \"binary search\" it by cutting it in half and seeing if either of the halves fails. Can you reduce the number of addWord calls while still getting it to fail the search call? Then try to remove the other search calls. If you can shrink it enough you can get to a small enough test case to debug. Don't get stuck on exactly halving it though. You might have to play around with how many method calls you remove.\n* If you have LeetCode Premium you can use the debugger. Or set up a local debugger on your own system and try to debug it. Even though there are hundreds of words in the trie, you might still notice something wrong while debugging.\n* To aid in debugging add a method to print the entire trie.\n*  Review your solution very carefully. First take a break to clear your mind. Don't think of it as \"how can this possibly be wrong\". Think of it as \"I know something is wrong and I can find it. It's only 20-30 lines of code\".\n* Compare against other people's solutions. If you know their solution is correct, then any places where your code is different are prime suspects.\n* Get someone else to review your solution. They won't have your preconceptions about how your code works and the bug may be obvious to them.\n\nIt's not fun but it's good practice. We all have to debug code at work, and this is still easier than some non-reproducible bug. At least you know what input causes it to fail."
                    }
                ]
            },
            {
                "id": 1837560,
                "content": [
                    {
                        "username": "akeempositive",
                        "content": "After solving this challenge with acceptable answer.... All the edge cases are very much.. And this is one challenge that tests requires performance tuning at every stage to pass it acceptably... I was thinking with my data structure and memory usage, I will have a poor rating on memory beats.... But it still beats 97% which is exactly why I think this is freaking hard a challenge "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "No way! I just used the stupidest possible brute force solution with arrays and its build-in find method and still got accepted and moreover it says my solution is faster than 96%  and uses less memory than 97% of other solutions, how is that even possible?? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "aryan20022003",
                        "content": "getting error use Array of Node and use memset for setting node NULL"
                    },
                    {
                        "username": "coderinterview",
                        "content": "I am using trie to store individual charcters in form of tree. \\nFor search I used BFS using queue, which should be faster than DFS using recursion and I am able to pass the testcases by \"run\", but when I \"submit\" I get TLE for same test cases. \\nCan someone please explain what I am missing?\\n```\\nclass WordDictionary {\\nprivate:\\n    struct node{\\n        bool end;\\n        node* v[26];\\n        node(){\\n            end=false;\\n            for(int i=0;i<26;i++){\\n                v[i]=nullptr;\\n            }\\n        }\\n        ~node() {}\\n    };\\n    node *head;\\npublic:        \\n    WordDictionary() {\\n        head = new node();\\n    }\\n    \\n    void addWord(string word) {\\n        node *curr = head;        \\n        for(char &c: word){\\n            if(curr->v[c-\\'a\\'] == nullptr) curr->v[c-\\'a\\'] = new node();\\n            curr = curr->v[c-\\'a\\'];\\n        }\\n        curr->end=true;\\n    }\\n    \\n    bool search(string word) {\\n        // node *curr=head;\\n        queue<node*> q;\\n        q.push(head);\\n        for(char &c: word){\\n            int s = q.size();\\n            while(s--){\\n                node *curr = q.front();\\n                q.pop();\\n                if(c == \\'.\\'){\\n                    for(int i=0;i<26;i++){\\n                        if(curr->v[i] != nullptr) q.push(curr->v[i]);\\n                    }\\n                }\\n                else if(curr->v[c-\\'a\\'] != nullptr) q.push(curr->v[c-\\'a\\']);                \\n            }\\n        }\\n        while(!q.empty()){\\n            node *curr = q.front();\\n            q.pop();\\n            if(curr->end) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```"
                    },
                    {
                        "username": "vadim_spirin",
                        "content": "7/29 testcases passed. Leetcode says that my output is [null,null,null,true,true,true,true,true,true], but it expected [null,null,null,true,true,false,true,false,false]. I tried it in my IDE and my code outputs exactly what is expected. Why does it work like that??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Your solution might have some state that is not being reset properly between test cases."
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone help how this solution is giving WA on this TC :\n\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]] \n\n `your inline code..\n\npublic class TrieNode\n{\n    HashMap<Character,TrieNode>store;\n    boolean is_end;\n    TrieNode()\n    {\n        store = new HashMap<>();\n        is_end = false;\n    }\n}\nclass WordDictionary {\n    private TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        TrieNode curNode = root;\n        for(char c:word.toCharArray())\n        {\n            if(!curNode.store.containsKey(c))\n            {\n                curNode.store.put(c,new TrieNode());\n            }\n            curNode = curNode.store.get(c);\n        }\n        curNode.is_end = true;\n    }\n    \n    public boolean search(String word) {\n    \n       TrieNode curNode = root;\n       return solve(curNode,word,0);\n    }\n\n    public boolean solve(TrieNode node,String word,int idx)\n    {\n        if(idx == word.length())\n        {\n            return node.is_end;\n        }\n        char c = word.charAt(idx);\n        if(c == '.')\n        {\n            for(TrieNode child : node.store.values())\n            {\n                boolean val = solve(child,word,idx+1);\n                if(val == true)\n                {\n                    return true;\n                }\n                return false;\n            }\n        }\n         \n             TrieNode child = node.store.get(c);\n             if(child == null)\n             {\n                 return false;\n             }\n             return solve(child,word,idx+1);\n         }     \n    \n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */\n\n\n\n.your inline code...`"
                    },
                    {
                        "username": "paullam328",
                        "content": "You don't need a TrieNode in the first place.  Optimize that part first and just use nested HashTable.  isEnd can be replaced by HashMap['end'] = {}.  Go back to \"Implement Trie\" problem and get the most memory-optimized solution first, then work on this problem, your code will be much simpler and easier to debug in that sense."
                    },
                    {
                        "username": "Heisenberg2003",
                        "content": "```\\nclass WordDictionary {\\npublic:\\n    struct TrieNode\\n    {\\n        TrieNode* childs[26];\\n    };\\n\\n    unordered_map<TrieNode*,bool>isTerminal;\\n    TrieNode* root=new TrieNode();\\n\\n    WordDictionary() {\\n        root=new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        TrieNode* node=root;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            if(node->childs[word[i]-\\'a\\']==NULL)\\n            {\\n                node->childs[word[i]-\\'a\\']=new TrieNode();\\n            }\\n            node=node->childs[word[i]-\\'a\\'];\\n        }\\n        isTerminal[node]=true;\\n        return;\\n    }\\n\\n    bool searchstr(string str)\\n    {\\n        TrieNode* node=root;\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if(node->childs[str[i]-\\'a\\']==NULL)\\n            {\\n                return false;\\n            }\\n            node=node->childs[str[i]-\\'a\\'];\\n        }\\n        return isTerminal[node];\\n    }\\n\\n    void permute(vector<string>&ans,string word,int ptr)\\n    {\\n        if(ptr==word.size())\\n        {\\n            ans.push_back(word);\\n            return;\\n        }\\n        if(word[ptr]==\\'.\\')\\n        {\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n                word[ptr]=ch;\\n                permute(ans,word,ptr+1);\\n            }\\n        }\\n        else\\n        {\\n            permute(ans,word,ptr+1);\\n        }\\n        return;\\n    }\\n    \\n    bool search(string word) {\\n        vector<string>possible;\\n        permute(possible,word,0);\\n        bool found=false;\\n        for(auto str:possible)\\n        {\\n            found=found||searchstr(str);\\n        }\\n        return found;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```\\nWhy Does This Give TLE?"
                    },
                    {
                        "username": "iamhariom28",
                        "content": "class Node{\n    Node* links[26];\n    bool flag;\npublic:\n    bool containsKey(char ch){\n        return links[ch-'a']!=NULL;\n    }\n    void insertKey(char ch, Node* node){\n        links[ch-'a'] = node;\n    }\n    Node* getNext(char ch){\n        return links[ch-'a'];\n    }\n    void setEnd(){\n        flag = true;\n    }\n    bool isEnd(){\n        return flag;\n    }\n};\n\nclass WordDictionary {\n    Node* root;\npublic:\n    WordDictionary() {\n        root = new Node();\n    }\n    \n    void addWord(string word) {\n        Node* node = root;\n        for(int i=0;i<word.size();i++){\n            if(!node->containsKey(word[i])){\n                node->insertKey(word[i], new Node());\n            }\n            node = node->getNext(word[i]);\n        }\n        node->setEnd();\n    }\n    \n    bool search(string word) {\n        Node* node = root;\n        if(word.size()==0) return node->isEnd();\n\n        for(int i=0;i<word.size();i++){\n            if(word[i]=='.'){\n                bool found = false;\n                for(char ch = 'a';ch <= 'z';ch++){\n                    if(node->containsKey(ch)){\n                        found = true;\n                        node = node->getNext(ch);\n                        break;\n                    }\n                }\n                if(!found) return false;\n            }else{\n                if(node->containsKey(word[i])){\n                    cout<<word[i]<<endl;\n                    node = node->getNext(word[i]);\n                }else return false;\n            }\n        }\n        return node->isEnd();\n    }\n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary* obj = new WordDictionary();\n * obj->addWord(word);\n * bool param_2 = obj->search(word);\n */\n\n\n\nIt is giving me wrong answer for given test case, can anyone tell me what mistake I am doing?\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]]\n\nOutput:\n[null,null,null,null,null,false,false,null,false,true,false,false,true,false]\nExpected output:\n[null,null,null,null,null,false,false,null,true,true,false,false,true,false]\n\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Hey, I have done this problem by doubly LL. and after 20 test cases it shows TLE. can any one tell the best approach of comparing the dot(.) based word with previous words ? Actually i have added another another loop over there so its taking O(n2). thats why its giving TLE i guess."
                    },
                    {
                        "username": "user9157cE",
                        "content": "How ? I can\\'t pass testcase 17, I have ONE false value, how am I suppose to see the error when there is 3300+ different methods calls. I just don\\'t see how I can isolate the error to fix it. And I can\\'t imagine of any way why my code is wrong. It passes all edge case I can think of. It would be great if leetcode can highlight what input caused the mistake. \\nI can only think of making a function that count all output values, gives me all wrong output and do the same with the input to get the 1423th that gives me the wrong value. but even then what ? there is hundreds of words in the dictionary already. I don\\'t know how to go further here :/"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) You're welcome! Most people never reply so I'm glad to help someone who appreciates it.\n\nMy mistake on the initialization thing. I believe it's mostly a stylistic choice. It just looked unfamiliar to me. I googled it shortly afterwards and edited my comment to remove that, but you probably saw the original version of my comment in the email notification.\n\nNot using a `TrieNode` was similar in that it mostly looked strange, but after thinking about it, I can see that your way should work. The main reason to use a `TrieNode` is to have a separate data class. The class storing the data doesn't really need the `addWord()` and `Search()` methods on it. You see this in places like linked list problems too. The linked list node and linked list class are usually separate.\n\nHaving separate classes for the node and trie also gives you a place to store 'global' data about the trie. For example, if you want to keep a count of the number of words in the trie, that goes in the trie class not the node class. With your current design it would have to go into `WordDictionary` but then every node also has a count variable which is unused."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01) Thanks a lot ! I didn\\'t imagine someone would\\'ve helped me so much, you\\'ve made my day !\\n\\nI simply stored endOfWord one step too early, I don\\'t know how it worked so far like that lol. But basically if I add a word \"c\" the whole first level of letter would get endOfWord = true but I needed to do ```dict[letter].endOfWord = true``` instead. So adding adding \"mfqef\" and search for \"m\" is returning true even if there was never a \"m\" in the array.\\n\\nAs for the nodes by looking at others solution I just did not see the use of it here, I imagine there is a good reason to work like that but haven\\'t found it yet.\\n\\nAnd for the variable is it better like this ? \\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord;\\n    WordDictionary[] dict;\\n    int index;\\n    \\n    public WordDictionary() {\\n        this(-1);\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n        this.dict = new WordDictionary[26];\\n    }\\n}\\n```\\nI honestly don\\'t know the difference between initializing the variable in the class or in the constructor. (if there is no variable in the constructor)\\n\\nThanks again for your fast answers, you\\'ve helped me a lot ! My answer beat 74% so I\\'m very happy with it. I think I can optimize it a bit but not today lol.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) Ok, thanks for explaining. Now I understand what you meant by counting output values.\n\nI've cut the test case down a lot. I need to go to bed now, but hopefully you can work on it some more. It's 86 `addWord` calls and a single `search` at the end that fails. Drastically smaller, and it should be easier to remove more `addWord` calls now since you don't have the problem of different interleaved methods.\n\n```\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\"]\n```\n\n```\n[[],[\"xgvk\"],[\"wykzbvwdsoyfowqicymzd\"],[\"xajbtjyjuwgoynjgu\"],[\"qsibzxaorktypkfg\"],[\"vbycuvrkbcq\"],[\"sm\"],[\"fkqclfmvzpzpnbvz\"],[\"jpnneostllnnma\"],[\"zvmtfg\"],[\"lboe\"],[\"jypzkxnzc\"],[\"qes\"],[\"jioqlytzqx\"],[\"fojsjyiz\"],[\"qkprluekewtsftvbrjndpt\"],[\"mwsgyywmmkzmy\"],[\"tcjmitm\"],[\"pybk\"],[\"poljqcitty\"],[\"qfdabgsvkboyaq\"],[\"pvreuprpvoycadnsxaajrkh\"],[\"sv\"],[\"knmxzabetvqehv\"],[\"ziazu\"],[\"ghhelrzgbsmxkrnezif\"],[\"fn\"],[\"tnjcttrsozynjpqhox\"],[\"qhxcfujxmayzlsrctmsa\"],[\"fyaaivfrupktdgw\"],[\"aiurwhjnhxfqokgiumbeyfcwk\"],[\"y\"],[\"pqxtikjgislbvr\"],[\"halneyxidcqt\"],[\"ugifaaxdcqioabmy\"],[\"dlmcs\"],[\"monsnupyvxyqkegmtmb\"],[\"oexhcxlfcnyijwquaw\"],[\"phetnfndiwyce\"],[\"lofnodyf\"],[\"brrwqho\"],[\"xxaolhw\"],[\"pqmlmuhradvjsx\"],[\"brlhfbvcom\"],[\"v\"],[\"yuhscpvbe\"],[\"ejiavk\"],[\"kbhrkecoaomocvdss\"],[\"mecwmipivkrlotxtjavs\"],[\"hfnconmujvgumljeiakpejgd\"],[\"kwrxzundledqdqbawtrrthps\"],[\"qtzjqxsh\"],[\"apsokathssqpsblye\"],[\"sgvnrpegeqclxtclwzzh\"],[\"eougulzekfcqkxvamtd\"],[\"soasdxrbagqgtbi\"],[\"fdtwtnoh\"],[\"maxsbmlojhhvrumynwppqvm\"],[\"wqopnyebntkkvrea\"],[\"xxnruy\"],[\"eiovag\"],[\"ieryygffvhjcvwrhssvgqqjl\"],[\"g\"],[\"bxbzeccraoqzqreqomg\"],[\"ccg\"],[\"nueebqsegnjnybbs\"],[\"lbcsuh\"],[\"c\"],[\"tcvgwubm\"],[\"nrkwveryqc\"],[\"scapopfqf\"],[\"druwthqeowerqgskfzwvp\"],[\"mvsw\"],[\"oogbspsthyxmlqpqgdsnv\"],[\"hzzvtuhkpimxrxwn\"],[\"wxyrykx\"],[\"wftaqtjkqgabepcpboplcsz\"],[\"gprfavikjmxovw\"],[\"qnmhflhmonzwfdolvaoq\"],[\"fuymduy\"],[\"j\"],[\"tjedwvjtdghhkavwnuyfgkie\"],[\"gtyybcgckuotlmitribvb\"],[\"zchqgemhqjpoxla\"],[\"ldzhusmikkebme\"],[\"imnhhzj\"],[\"yylrxnnlpixqod\"],[\"m\"]]\n```\n\nBy the way, using `WordDictionary` as your node class instead of defining a separate `TrieNode` class stood out to me as being strange.\n\nMaybe your problem doesn't lie there, but it's something to consider."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01)  Thanks for the reply ! I\\'m gonna try harder a bit later but unfortunnately I\\'ve fought about your solution before. \\n\\nIf Leetcode can highligh the output #1681 they could highlight the input #1681 (its a search methods).\\n\\nI can\\'t cut the test case since they are all different length and in order. If I cut randomly 100 input then all the other will have an offset and won\\'t be valid since there is \"search\" and \"addWord\" methods and they don\\'t accept the same input. So cutting half the input would still require me to count each one exactly so they remain in order.\\n\\nMy solution isn\\'t like the other one I\\'ve seen, and nearly all other solutions are the same anyway, they all have the same approach and structure of code. So yeah I could go look a video on how they\\'ve done this but I won\\'t learn anything if I don\\'t know where\\'s my mistake. And I don\\'t think I have the wrong approach since 99% of my answer are correct.\\n\\nAnd yes a debugger would be helpful there, It would be a pain to create an entire new program just to make a debugger accept the input and calling my methods. Leetcode is basically forcing the use of their debugger here but as a student I can\\'t afford the premium, it\\'s half of what I pay for a year of college.\\n\\nAnyway here is my code , if anyone can find a SHORT testcase that doesn\\'t work it would help me greatly :D\\n\\n\\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord = false;\\n    WordDictionary[] dict = new WordDictionary[26];\\n    int index;\\n    \\n    public WordDictionary() {\\n        this.index = 0;\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n    }\\n    \\n    public void addWord(String word) {\\n        if(dict[toInt(word.charAt(index))] == null){\\n            dict[toInt(word.charAt(index))] = new WordDictionary(index);\\n        }\\n        if(index == word.length()-1){\\n            endOfWord = true;\\n        }else dict[toInt(word.charAt(index))].addWord(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        if(index == word.length()-1) return endOfWord && (word.charAt(index) == \\'.\\' ? true : dict[toInt(word.charAt(index))] != null);\\n        if(word.charAt(index) == \\'.\\'){\\n            for(WordDictionary d : dict){\\n                if(d != null && d.search(word)) return true;\\n            }\\n            return false;\\n        }else if(dict[toInt(word.charAt(index))] != null){\\n            return dict[toInt(word.charAt(index))].search(word);\\n        }\\n        return false;\\n    }\\n\\n    private int toInt(char c){\\n        return c-\\'a\\';\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It's a tough situation. I don't see how LeetCode could highlight what input caused the bug. It's obviously a combination of multiple method calls that triggered the bug.\n\nYou've got a few options (not necessarily in order):\n* Try to cut down the test case while still having it fail. It's tedious but I've done this. You sort of \"binary search\" it by cutting it in half and seeing if either of the halves fails. Can you reduce the number of addWord calls while still getting it to fail the search call? Then try to remove the other search calls. If you can shrink it enough you can get to a small enough test case to debug. Don't get stuck on exactly halving it though. You might have to play around with how many method calls you remove.\n* If you have LeetCode Premium you can use the debugger. Or set up a local debugger on your own system and try to debug it. Even though there are hundreds of words in the trie, you might still notice something wrong while debugging.\n* To aid in debugging add a method to print the entire trie.\n*  Review your solution very carefully. First take a break to clear your mind. Don't think of it as \"how can this possibly be wrong\". Think of it as \"I know something is wrong and I can find it. It's only 20-30 lines of code\".\n* Compare against other people's solutions. If you know their solution is correct, then any places where your code is different are prime suspects.\n* Get someone else to review your solution. They won't have your preconceptions about how your code works and the bug may be obvious to them.\n\nIt's not fun but it's good practice. We all have to debug code at work, and this is still easier than some non-reproducible bug. At least you know what input causes it to fail."
                    }
                ]
            },
            {
                "id": 1837492,
                "content": [
                    {
                        "username": "akeempositive",
                        "content": "After solving this challenge with acceptable answer.... All the edge cases are very much.. And this is one challenge that tests requires performance tuning at every stage to pass it acceptably... I was thinking with my data structure and memory usage, I will have a poor rating on memory beats.... But it still beats 97% which is exactly why I think this is freaking hard a challenge "
                    },
                    {
                        "username": "KovDimaY",
                        "content": "No way! I just used the stupidest possible brute force solution with arrays and its build-in find method and still got accepted and moreover it says my solution is faster than 96%  and uses less memory than 97% of other solutions, how is that even possible?? \\uD83E\\uDD26\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "aryan20022003",
                        "content": "getting error use Array of Node and use memset for setting node NULL"
                    },
                    {
                        "username": "coderinterview",
                        "content": "I am using trie to store individual charcters in form of tree. \\nFor search I used BFS using queue, which should be faster than DFS using recursion and I am able to pass the testcases by \"run\", but when I \"submit\" I get TLE for same test cases. \\nCan someone please explain what I am missing?\\n```\\nclass WordDictionary {\\nprivate:\\n    struct node{\\n        bool end;\\n        node* v[26];\\n        node(){\\n            end=false;\\n            for(int i=0;i<26;i++){\\n                v[i]=nullptr;\\n            }\\n        }\\n        ~node() {}\\n    };\\n    node *head;\\npublic:        \\n    WordDictionary() {\\n        head = new node();\\n    }\\n    \\n    void addWord(string word) {\\n        node *curr = head;        \\n        for(char &c: word){\\n            if(curr->v[c-\\'a\\'] == nullptr) curr->v[c-\\'a\\'] = new node();\\n            curr = curr->v[c-\\'a\\'];\\n        }\\n        curr->end=true;\\n    }\\n    \\n    bool search(string word) {\\n        // node *curr=head;\\n        queue<node*> q;\\n        q.push(head);\\n        for(char &c: word){\\n            int s = q.size();\\n            while(s--){\\n                node *curr = q.front();\\n                q.pop();\\n                if(c == \\'.\\'){\\n                    for(int i=0;i<26;i++){\\n                        if(curr->v[i] != nullptr) q.push(curr->v[i]);\\n                    }\\n                }\\n                else if(curr->v[c-\\'a\\'] != nullptr) q.push(curr->v[c-\\'a\\']);                \\n            }\\n        }\\n        while(!q.empty()){\\n            node *curr = q.front();\\n            q.pop();\\n            if(curr->end) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```"
                    },
                    {
                        "username": "vadim_spirin",
                        "content": "7/29 testcases passed. Leetcode says that my output is [null,null,null,true,true,true,true,true,true], but it expected [null,null,null,true,true,false,true,false,false]. I tried it in my IDE and my code outputs exactly what is expected. Why does it work like that??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Your solution might have some state that is not being reset properly between test cases."
                    },
                    {
                        "username": "user4311YR",
                        "content": "Can someone help how this solution is giving WA on this TC :\n\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]] \n\n `your inline code..\n\npublic class TrieNode\n{\n    HashMap<Character,TrieNode>store;\n    boolean is_end;\n    TrieNode()\n    {\n        store = new HashMap<>();\n        is_end = false;\n    }\n}\nclass WordDictionary {\n    private TrieNode root;\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n    \n    public void addWord(String word) {\n        TrieNode curNode = root;\n        for(char c:word.toCharArray())\n        {\n            if(!curNode.store.containsKey(c))\n            {\n                curNode.store.put(c,new TrieNode());\n            }\n            curNode = curNode.store.get(c);\n        }\n        curNode.is_end = true;\n    }\n    \n    public boolean search(String word) {\n    \n       TrieNode curNode = root;\n       return solve(curNode,word,0);\n    }\n\n    public boolean solve(TrieNode node,String word,int idx)\n    {\n        if(idx == word.length())\n        {\n            return node.is_end;\n        }\n        char c = word.charAt(idx);\n        if(c == '.')\n        {\n            for(TrieNode child : node.store.values())\n            {\n                boolean val = solve(child,word,idx+1);\n                if(val == true)\n                {\n                    return true;\n                }\n                return false;\n            }\n        }\n         \n             TrieNode child = node.store.get(c);\n             if(child == null)\n             {\n                 return false;\n             }\n             return solve(child,word,idx+1);\n         }     \n    \n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */\n\n\n\n.your inline code...`"
                    },
                    {
                        "username": "paullam328",
                        "content": "You don't need a TrieNode in the first place.  Optimize that part first and just use nested HashTable.  isEnd can be replaced by HashMap['end'] = {}.  Go back to \"Implement Trie\" problem and get the most memory-optimized solution first, then work on this problem, your code will be much simpler and easier to debug in that sense."
                    },
                    {
                        "username": "Heisenberg2003",
                        "content": "```\\nclass WordDictionary {\\npublic:\\n    struct TrieNode\\n    {\\n        TrieNode* childs[26];\\n    };\\n\\n    unordered_map<TrieNode*,bool>isTerminal;\\n    TrieNode* root=new TrieNode();\\n\\n    WordDictionary() {\\n        root=new TrieNode();\\n    }\\n    \\n    void addWord(string word) {\\n        TrieNode* node=root;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            if(node->childs[word[i]-\\'a\\']==NULL)\\n            {\\n                node->childs[word[i]-\\'a\\']=new TrieNode();\\n            }\\n            node=node->childs[word[i]-\\'a\\'];\\n        }\\n        isTerminal[node]=true;\\n        return;\\n    }\\n\\n    bool searchstr(string str)\\n    {\\n        TrieNode* node=root;\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if(node->childs[str[i]-\\'a\\']==NULL)\\n            {\\n                return false;\\n            }\\n            node=node->childs[str[i]-\\'a\\'];\\n        }\\n        return isTerminal[node];\\n    }\\n\\n    void permute(vector<string>&ans,string word,int ptr)\\n    {\\n        if(ptr==word.size())\\n        {\\n            ans.push_back(word);\\n            return;\\n        }\\n        if(word[ptr]==\\'.\\')\\n        {\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n                word[ptr]=ch;\\n                permute(ans,word,ptr+1);\\n            }\\n        }\\n        else\\n        {\\n            permute(ans,word,ptr+1);\\n        }\\n        return;\\n    }\\n    \\n    bool search(string word) {\\n        vector<string>possible;\\n        permute(possible,word,0);\\n        bool found=false;\\n        for(auto str:possible)\\n        {\\n            found=found||searchstr(str);\\n        }\\n        return found;\\n    }\\n};\\n\\n/**\\n * Your WordDictionary object will be instantiated and called as such:\\n * WordDictionary* obj = new WordDictionary();\\n * obj->addWord(word);\\n * bool param_2 = obj->search(word);\\n */\\n```\\nWhy Does This Give TLE?"
                    },
                    {
                        "username": "iamhariom28",
                        "content": "class Node{\n    Node* links[26];\n    bool flag;\npublic:\n    bool containsKey(char ch){\n        return links[ch-'a']!=NULL;\n    }\n    void insertKey(char ch, Node* node){\n        links[ch-'a'] = node;\n    }\n    Node* getNext(char ch){\n        return links[ch-'a'];\n    }\n    void setEnd(){\n        flag = true;\n    }\n    bool isEnd(){\n        return flag;\n    }\n};\n\nclass WordDictionary {\n    Node* root;\npublic:\n    WordDictionary() {\n        root = new Node();\n    }\n    \n    void addWord(string word) {\n        Node* node = root;\n        for(int i=0;i<word.size();i++){\n            if(!node->containsKey(word[i])){\n                node->insertKey(word[i], new Node());\n            }\n            node = node->getNext(word[i]);\n        }\n        node->setEnd();\n    }\n    \n    bool search(string word) {\n        Node* node = root;\n        if(word.size()==0) return node->isEnd();\n\n        for(int i=0;i<word.size();i++){\n            if(word[i]=='.'){\n                bool found = false;\n                for(char ch = 'a';ch <= 'z';ch++){\n                    if(node->containsKey(ch)){\n                        found = true;\n                        node = node->getNext(ch);\n                        break;\n                    }\n                }\n                if(!found) return false;\n            }else{\n                if(node->containsKey(word[i])){\n                    cout<<word[i]<<endl;\n                    node = node->getNext(word[i]);\n                }else return false;\n            }\n        }\n        return node->isEnd();\n    }\n};\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary* obj = new WordDictionary();\n * obj->addWord(word);\n * bool param_2 = obj->search(word);\n */\n\n\n\nIt is giving me wrong answer for given test case, can anyone tell me what mistake I am doing?\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\",\"search\",\"search\",\"search\",\"search\",\"search\"]\n\n[[],[\"at\"],[\"and\"],[\"an\"],[\"add\"],[\"a\"],[\".at\"],[\"bat\"],[\".at\"],[\"an.\"],[\"a.d.\"],[\"b.\"],[\"a.d\"],[\".\"]]\n\nOutput:\n[null,null,null,null,null,false,false,null,false,true,false,false,true,false]\nExpected output:\n[null,null,null,null,null,false,false,null,true,true,false,false,true,false]\n\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "Hey, I have done this problem by doubly LL. and after 20 test cases it shows TLE. can any one tell the best approach of comparing the dot(.) based word with previous words ? Actually i have added another another loop over there so its taking O(n2). thats why its giving TLE i guess."
                    },
                    {
                        "username": "user9157cE",
                        "content": "How ? I can\\'t pass testcase 17, I have ONE false value, how am I suppose to see the error when there is 3300+ different methods calls. I just don\\'t see how I can isolate the error to fix it. And I can\\'t imagine of any way why my code is wrong. It passes all edge case I can think of. It would be great if leetcode can highlight what input caused the mistake. \\nI can only think of making a function that count all output values, gives me all wrong output and do the same with the input to get the 1423th that gives me the wrong value. but even then what ? there is hundreds of words in the dictionary already. I don\\'t know how to go further here :/"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) You're welcome! Most people never reply so I'm glad to help someone who appreciates it.\n\nMy mistake on the initialization thing. I believe it's mostly a stylistic choice. It just looked unfamiliar to me. I googled it shortly afterwards and edited my comment to remove that, but you probably saw the original version of my comment in the email notification.\n\nNot using a `TrieNode` was similar in that it mostly looked strange, but after thinking about it, I can see that your way should work. The main reason to use a `TrieNode` is to have a separate data class. The class storing the data doesn't really need the `addWord()` and `Search()` methods on it. You see this in places like linked list problems too. The linked list node and linked list class are usually separate.\n\nHaving separate classes for the node and trie also gives you a place to store 'global' data about the trie. For example, if you want to keep a count of the number of words in the trie, that goes in the trie class not the node class. With your current design it would have to go into `WordDictionary` but then every node also has a count variable which is unused."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01) Thanks a lot ! I didn\\'t imagine someone would\\'ve helped me so much, you\\'ve made my day !\\n\\nI simply stored endOfWord one step too early, I don\\'t know how it worked so far like that lol. But basically if I add a word \"c\" the whole first level of letter would get endOfWord = true but I needed to do ```dict[letter].endOfWord = true``` instead. So adding adding \"mfqef\" and search for \"m\" is returning true even if there was never a \"m\" in the array.\\n\\nAs for the nodes by looking at others solution I just did not see the use of it here, I imagine there is a good reason to work like that but haven\\'t found it yet.\\n\\nAnd for the variable is it better like this ? \\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord;\\n    WordDictionary[] dict;\\n    int index;\\n    \\n    public WordDictionary() {\\n        this(-1);\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n        this.dict = new WordDictionary[26];\\n    }\\n}\\n```\\nI honestly don\\'t know the difference between initializing the variable in the class or in the constructor. (if there is no variable in the constructor)\\n\\nThanks again for your fast answers, you\\'ve helped me a lot ! My answer beat 74% so I\\'m very happy with it. I think I can optimize it a bit but not today lol.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@user9157cE](/user9157cE) Ok, thanks for explaining. Now I understand what you meant by counting output values.\n\nI've cut the test case down a lot. I need to go to bed now, but hopefully you can work on it some more. It's 86 `addWord` calls and a single `search` at the end that fails. Drastically smaller, and it should be easier to remove more `addWord` calls now since you don't have the problem of different interleaved methods.\n\n```\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"addWord\",\"search\"]\n```\n\n```\n[[],[\"xgvk\"],[\"wykzbvwdsoyfowqicymzd\"],[\"xajbtjyjuwgoynjgu\"],[\"qsibzxaorktypkfg\"],[\"vbycuvrkbcq\"],[\"sm\"],[\"fkqclfmvzpzpnbvz\"],[\"jpnneostllnnma\"],[\"zvmtfg\"],[\"lboe\"],[\"jypzkxnzc\"],[\"qes\"],[\"jioqlytzqx\"],[\"fojsjyiz\"],[\"qkprluekewtsftvbrjndpt\"],[\"mwsgyywmmkzmy\"],[\"tcjmitm\"],[\"pybk\"],[\"poljqcitty\"],[\"qfdabgsvkboyaq\"],[\"pvreuprpvoycadnsxaajrkh\"],[\"sv\"],[\"knmxzabetvqehv\"],[\"ziazu\"],[\"ghhelrzgbsmxkrnezif\"],[\"fn\"],[\"tnjcttrsozynjpqhox\"],[\"qhxcfujxmayzlsrctmsa\"],[\"fyaaivfrupktdgw\"],[\"aiurwhjnhxfqokgiumbeyfcwk\"],[\"y\"],[\"pqxtikjgislbvr\"],[\"halneyxidcqt\"],[\"ugifaaxdcqioabmy\"],[\"dlmcs\"],[\"monsnupyvxyqkegmtmb\"],[\"oexhcxlfcnyijwquaw\"],[\"phetnfndiwyce\"],[\"lofnodyf\"],[\"brrwqho\"],[\"xxaolhw\"],[\"pqmlmuhradvjsx\"],[\"brlhfbvcom\"],[\"v\"],[\"yuhscpvbe\"],[\"ejiavk\"],[\"kbhrkecoaomocvdss\"],[\"mecwmipivkrlotxtjavs\"],[\"hfnconmujvgumljeiakpejgd\"],[\"kwrxzundledqdqbawtrrthps\"],[\"qtzjqxsh\"],[\"apsokathssqpsblye\"],[\"sgvnrpegeqclxtclwzzh\"],[\"eougulzekfcqkxvamtd\"],[\"soasdxrbagqgtbi\"],[\"fdtwtnoh\"],[\"maxsbmlojhhvrumynwppqvm\"],[\"wqopnyebntkkvrea\"],[\"xxnruy\"],[\"eiovag\"],[\"ieryygffvhjcvwrhssvgqqjl\"],[\"g\"],[\"bxbzeccraoqzqreqomg\"],[\"ccg\"],[\"nueebqsegnjnybbs\"],[\"lbcsuh\"],[\"c\"],[\"tcvgwubm\"],[\"nrkwveryqc\"],[\"scapopfqf\"],[\"druwthqeowerqgskfzwvp\"],[\"mvsw\"],[\"oogbspsthyxmlqpqgdsnv\"],[\"hzzvtuhkpimxrxwn\"],[\"wxyrykx\"],[\"wftaqtjkqgabepcpboplcsz\"],[\"gprfavikjmxovw\"],[\"qnmhflhmonzwfdolvaoq\"],[\"fuymduy\"],[\"j\"],[\"tjedwvjtdghhkavwnuyfgkie\"],[\"gtyybcgckuotlmitribvb\"],[\"zchqgemhqjpoxla\"],[\"ldzhusmikkebme\"],[\"imnhhzj\"],[\"yylrxnnlpixqod\"],[\"m\"]]\n```\n\nBy the way, using `WordDictionary` as your node class instead of defining a separate `TrieNode` class stood out to me as being strange.\n\nMaybe your problem doesn't lie there, but it's something to consider."
                    },
                    {
                        "username": "user9157cE",
                        "content": "[@nikhila01](/nikhila01)  Thanks for the reply ! I\\'m gonna try harder a bit later but unfortunnately I\\'ve fought about your solution before. \\n\\nIf Leetcode can highligh the output #1681 they could highlight the input #1681 (its a search methods).\\n\\nI can\\'t cut the test case since they are all different length and in order. If I cut randomly 100 input then all the other will have an offset and won\\'t be valid since there is \"search\" and \"addWord\" methods and they don\\'t accept the same input. So cutting half the input would still require me to count each one exactly so they remain in order.\\n\\nMy solution isn\\'t like the other one I\\'ve seen, and nearly all other solutions are the same anyway, they all have the same approach and structure of code. So yeah I could go look a video on how they\\'ve done this but I won\\'t learn anything if I don\\'t know where\\'s my mistake. And I don\\'t think I have the wrong approach since 99% of my answer are correct.\\n\\nAnd yes a debugger would be helpful there, It would be a pain to create an entire new program just to make a debugger accept the input and calling my methods. Leetcode is basically forcing the use of their debugger here but as a student I can\\'t afford the premium, it\\'s half of what I pay for a year of college.\\n\\nAnyway here is my code , if anyone can find a SHORT testcase that doesn\\'t work it would help me greatly :D\\n\\n\\n```\\nclass WordDictionary {\\n\\n    boolean endOfWord = false;\\n    WordDictionary[] dict = new WordDictionary[26];\\n    int index;\\n    \\n    public WordDictionary() {\\n        this.index = 0;\\n    }\\n    public WordDictionary(int index) {\\n        this.index = index+1;\\n    }\\n    \\n    public void addWord(String word) {\\n        if(dict[toInt(word.charAt(index))] == null){\\n            dict[toInt(word.charAt(index))] = new WordDictionary(index);\\n        }\\n        if(index == word.length()-1){\\n            endOfWord = true;\\n        }else dict[toInt(word.charAt(index))].addWord(word);\\n    }\\n    \\n    public boolean search(String word) {\\n        if(index == word.length()-1) return endOfWord && (word.charAt(index) == \\'.\\' ? true : dict[toInt(word.charAt(index))] != null);\\n        if(word.charAt(index) == \\'.\\'){\\n            for(WordDictionary d : dict){\\n                if(d != null && d.search(word)) return true;\\n            }\\n            return false;\\n        }else if(dict[toInt(word.charAt(index))] != null){\\n            return dict[toInt(word.charAt(index))].search(word);\\n        }\\n        return false;\\n    }\\n\\n    private int toInt(char c){\\n        return c-\\'a\\';\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "It's a tough situation. I don't see how LeetCode could highlight what input caused the bug. It's obviously a combination of multiple method calls that triggered the bug.\n\nYou've got a few options (not necessarily in order):\n* Try to cut down the test case while still having it fail. It's tedious but I've done this. You sort of \"binary search\" it by cutting it in half and seeing if either of the halves fails. Can you reduce the number of addWord calls while still getting it to fail the search call? Then try to remove the other search calls. If you can shrink it enough you can get to a small enough test case to debug. Don't get stuck on exactly halving it though. You might have to play around with how many method calls you remove.\n* If you have LeetCode Premium you can use the debugger. Or set up a local debugger on your own system and try to debug it. Even though there are hundreds of words in the trie, you might still notice something wrong while debugging.\n* To aid in debugging add a method to print the entire trie.\n*  Review your solution very carefully. First take a break to clear your mind. Don't think of it as \"how can this possibly be wrong\". Think of it as \"I know something is wrong and I can find it. It's only 20-30 lines of code\".\n* Compare against other people's solutions. If you know their solution is correct, then any places where your code is different are prime suspects.\n* Get someone else to review your solution. They won't have your preconceptions about how your code works and the bug may be obvious to them.\n\nIt's not fun but it's good practice. We all have to debug code at work, and this is still easier than some non-reproducible bug. At least you know what input causes it to fail."
                    }
                ]
            },
            {
                "id": 1837443,
                "content": [
                    {
                        "username": "vishaljoshi1998",
                        "content": "[[],[\"a\"],[\"a.\"]]"
                    },
                    {
                        "username": "smbody",
                        "content": "I have passed 29/29 test cases but the result still shows TLE. How do i resolve this ?"
                    },
                    {
                        "username": "ibaydin",
                        "content": "did u solve that? i have same situation too. \nEdit: I just solved, little more optimization fixed my issue."
                    },
                    {
                        "username": "user7275Ci",
                        "content": "Golang submission is broken\\n`\\nLine 75: Char 19: undefined: Deserializer (solution.go)\\nLine 80: Char 36: undefined: Deserializer (solution.go)\\nLine 84: Char 36: undefined: Deserializer (solution.go)\\nLine 85: Char 34: undefined: Serializer (solution.go)\\nLine 153: Char 25: undefined: Deserializer (solution.go)\\n`"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "\\uD83D\\uDD25++;"
                    },
                    {
                        "username": "Mukul_reign",
                        "content": " i think so it\\'s basically asked to use trie data structure"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Question to people who did it in C (or C++ ig). Why do we have to always check if(ptr==NULL) and not if(!ptr)? My code didnt work because of this. "
                    },
                    {
                        "username": "aadevilas1137",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the \\'.\\' could have been replaced by another \\'a\\' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "charonme",
                        "content": "addWord(\"aa\"); search(\"a.\"); correctly expects true. What exact testcase are you trying?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "What you said makes sense but you should post the test case. You may not be reading the test correctly.\n\n`addWord(\"a\")` followed by `addWord(\"a\")` doesn't add `\"aa\"`. It just adds `\"a\"`. Is that the confusion?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Thank goodness.... I am finally able to implement and use this Data Structure."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "this should be hard\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Though I use trie-structure, the words being added must be grouped by their length... In other words, multiple trie-tree may be needed to avoid TLE."
                    }
                ]
            },
            {
                "id": 1837388,
                "content": [
                    {
                        "username": "vishaljoshi1998",
                        "content": "[[],[\"a\"],[\"a.\"]]"
                    },
                    {
                        "username": "smbody",
                        "content": "I have passed 29/29 test cases but the result still shows TLE. How do i resolve this ?"
                    },
                    {
                        "username": "ibaydin",
                        "content": "did u solve that? i have same situation too. \nEdit: I just solved, little more optimization fixed my issue."
                    },
                    {
                        "username": "user7275Ci",
                        "content": "Golang submission is broken\\n`\\nLine 75: Char 19: undefined: Deserializer (solution.go)\\nLine 80: Char 36: undefined: Deserializer (solution.go)\\nLine 84: Char 36: undefined: Deserializer (solution.go)\\nLine 85: Char 34: undefined: Serializer (solution.go)\\nLine 153: Char 25: undefined: Deserializer (solution.go)\\n`"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "\\uD83D\\uDD25++;"
                    },
                    {
                        "username": "Mukul_reign",
                        "content": " i think so it\\'s basically asked to use trie data structure"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Question to people who did it in C (or C++ ig). Why do we have to always check if(ptr==NULL) and not if(!ptr)? My code didnt work because of this. "
                    },
                    {
                        "username": "aadevilas1137",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the \\'.\\' could have been replaced by another \\'a\\' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "charonme",
                        "content": "addWord(\"aa\"); search(\"a.\"); correctly expects true. What exact testcase are you trying?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "What you said makes sense but you should post the test case. You may not be reading the test correctly.\n\n`addWord(\"a\")` followed by `addWord(\"a\")` doesn't add `\"aa\"`. It just adds `\"a\"`. Is that the confusion?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Thank goodness.... I am finally able to implement and use this Data Structure."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "this should be hard\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Though I use trie-structure, the words being added must be grouped by their length... In other words, multiple trie-tree may be needed to avoid TLE."
                    }
                ]
            },
            {
                "id": 1837381,
                "content": [
                    {
                        "username": "vishaljoshi1998",
                        "content": "[[],[\"a\"],[\"a.\"]]"
                    },
                    {
                        "username": "smbody",
                        "content": "I have passed 29/29 test cases but the result still shows TLE. How do i resolve this ?"
                    },
                    {
                        "username": "ibaydin",
                        "content": "did u solve that? i have same situation too. \nEdit: I just solved, little more optimization fixed my issue."
                    },
                    {
                        "username": "user7275Ci",
                        "content": "Golang submission is broken\\n`\\nLine 75: Char 19: undefined: Deserializer (solution.go)\\nLine 80: Char 36: undefined: Deserializer (solution.go)\\nLine 84: Char 36: undefined: Deserializer (solution.go)\\nLine 85: Char 34: undefined: Serializer (solution.go)\\nLine 153: Char 25: undefined: Deserializer (solution.go)\\n`"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "\\uD83D\\uDD25++;"
                    },
                    {
                        "username": "Mukul_reign",
                        "content": " i think so it\\'s basically asked to use trie data structure"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Question to people who did it in C (or C++ ig). Why do we have to always check if(ptr==NULL) and not if(!ptr)? My code didnt work because of this. "
                    },
                    {
                        "username": "aadevilas1137",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the \\'.\\' could have been replaced by another \\'a\\' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "charonme",
                        "content": "addWord(\"aa\"); search(\"a.\"); correctly expects true. What exact testcase are you trying?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "What you said makes sense but you should post the test case. You may not be reading the test correctly.\n\n`addWord(\"a\")` followed by `addWord(\"a\")` doesn't add `\"aa\"`. It just adds `\"a\"`. Is that the confusion?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Thank goodness.... I am finally able to implement and use this Data Structure."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "this should be hard\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Though I use trie-structure, the words being added must be grouped by their length... In other words, multiple trie-tree may be needed to avoid TLE."
                    }
                ]
            },
            {
                "id": 1837356,
                "content": [
                    {
                        "username": "vishaljoshi1998",
                        "content": "[[],[\"a\"],[\"a.\"]]"
                    },
                    {
                        "username": "smbody",
                        "content": "I have passed 29/29 test cases but the result still shows TLE. How do i resolve this ?"
                    },
                    {
                        "username": "ibaydin",
                        "content": "did u solve that? i have same situation too. \nEdit: I just solved, little more optimization fixed my issue."
                    },
                    {
                        "username": "user7275Ci",
                        "content": "Golang submission is broken\\n`\\nLine 75: Char 19: undefined: Deserializer (solution.go)\\nLine 80: Char 36: undefined: Deserializer (solution.go)\\nLine 84: Char 36: undefined: Deserializer (solution.go)\\nLine 85: Char 34: undefined: Serializer (solution.go)\\nLine 153: Char 25: undefined: Deserializer (solution.go)\\n`"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "\\uD83D\\uDD25++;"
                    },
                    {
                        "username": "Mukul_reign",
                        "content": " i think so it\\'s basically asked to use trie data structure"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Question to people who did it in C (or C++ ig). Why do we have to always check if(ptr==NULL) and not if(!ptr)? My code didnt work because of this. "
                    },
                    {
                        "username": "aadevilas1137",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the \\'.\\' could have been replaced by another \\'a\\' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "charonme",
                        "content": "addWord(\"aa\"); search(\"a.\"); correctly expects true. What exact testcase are you trying?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "What you said makes sense but you should post the test case. You may not be reading the test correctly.\n\n`addWord(\"a\")` followed by `addWord(\"a\")` doesn't add `\"aa\"`. It just adds `\"a\"`. Is that the confusion?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Thank goodness.... I am finally able to implement and use this Data Structure."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "this should be hard\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Though I use trie-structure, the words being added must be grouped by their length... In other words, multiple trie-tree may be needed to avoid TLE."
                    }
                ]
            },
            {
                "id": 1837251,
                "content": [
                    {
                        "username": "vishaljoshi1998",
                        "content": "[[],[\"a\"],[\"a.\"]]"
                    },
                    {
                        "username": "smbody",
                        "content": "I have passed 29/29 test cases but the result still shows TLE. How do i resolve this ?"
                    },
                    {
                        "username": "ibaydin",
                        "content": "did u solve that? i have same situation too. \nEdit: I just solved, little more optimization fixed my issue."
                    },
                    {
                        "username": "user7275Ci",
                        "content": "Golang submission is broken\\n`\\nLine 75: Char 19: undefined: Deserializer (solution.go)\\nLine 80: Char 36: undefined: Deserializer (solution.go)\\nLine 84: Char 36: undefined: Deserializer (solution.go)\\nLine 85: Char 34: undefined: Serializer (solution.go)\\nLine 153: Char 25: undefined: Deserializer (solution.go)\\n`"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "\\uD83D\\uDD25++;"
                    },
                    {
                        "username": "Mukul_reign",
                        "content": " i think so it\\'s basically asked to use trie data structure"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Question to people who did it in C (or C++ ig). Why do we have to always check if(ptr==NULL) and not if(!ptr)? My code didnt work because of this. "
                    },
                    {
                        "username": "aadevilas1137",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the \\'.\\' could have been replaced by another \\'a\\' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "charonme",
                        "content": "addWord(\"aa\"); search(\"a.\"); correctly expects true. What exact testcase are you trying?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "What you said makes sense but you should post the test case. You may not be reading the test correctly.\n\n`addWord(\"a\")` followed by `addWord(\"a\")` doesn't add `\"aa\"`. It just adds `\"a\"`. Is that the confusion?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Thank goodness.... I am finally able to implement and use this Data Structure."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "this should be hard\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Though I use trie-structure, the words being added must be grouped by their length... In other words, multiple trie-tree may be needed to avoid TLE."
                    }
                ]
            },
            {
                "id": 1837114,
                "content": [
                    {
                        "username": "vishaljoshi1998",
                        "content": "[[],[\"a\"],[\"a.\"]]"
                    },
                    {
                        "username": "smbody",
                        "content": "I have passed 29/29 test cases but the result still shows TLE. How do i resolve this ?"
                    },
                    {
                        "username": "ibaydin",
                        "content": "did u solve that? i have same situation too. \nEdit: I just solved, little more optimization fixed my issue."
                    },
                    {
                        "username": "user7275Ci",
                        "content": "Golang submission is broken\\n`\\nLine 75: Char 19: undefined: Deserializer (solution.go)\\nLine 80: Char 36: undefined: Deserializer (solution.go)\\nLine 84: Char 36: undefined: Deserializer (solution.go)\\nLine 85: Char 34: undefined: Serializer (solution.go)\\nLine 153: Char 25: undefined: Deserializer (solution.go)\\n`"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "\\uD83D\\uDD25++;"
                    },
                    {
                        "username": "Mukul_reign",
                        "content": " i think so it\\'s basically asked to use trie data structure"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Question to people who did it in C (or C++ ig). Why do we have to always check if(ptr==NULL) and not if(!ptr)? My code didnt work because of this. "
                    },
                    {
                        "username": "aadevilas1137",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the \\'.\\' could have been replaced by another \\'a\\' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "charonme",
                        "content": "addWord(\"aa\"); search(\"a.\"); correctly expects true. What exact testcase are you trying?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "What you said makes sense but you should post the test case. You may not be reading the test correctly.\n\n`addWord(\"a\")` followed by `addWord(\"a\")` doesn't add `\"aa\"`. It just adds `\"a\"`. Is that the confusion?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Thank goodness.... I am finally able to implement and use this Data Structure."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "this should be hard\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Though I use trie-structure, the words being added must be grouped by their length... In other words, multiple trie-tree may be needed to avoid TLE."
                    }
                ]
            },
            {
                "id": 1837067,
                "content": [
                    {
                        "username": "vishaljoshi1998",
                        "content": "[[],[\"a\"],[\"a.\"]]"
                    },
                    {
                        "username": "smbody",
                        "content": "I have passed 29/29 test cases but the result still shows TLE. How do i resolve this ?"
                    },
                    {
                        "username": "ibaydin",
                        "content": "did u solve that? i have same situation too. \nEdit: I just solved, little more optimization fixed my issue."
                    },
                    {
                        "username": "user7275Ci",
                        "content": "Golang submission is broken\\n`\\nLine 75: Char 19: undefined: Deserializer (solution.go)\\nLine 80: Char 36: undefined: Deserializer (solution.go)\\nLine 84: Char 36: undefined: Deserializer (solution.go)\\nLine 85: Char 34: undefined: Serializer (solution.go)\\nLine 153: Char 25: undefined: Deserializer (solution.go)\\n`"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "\\uD83D\\uDD25++;"
                    },
                    {
                        "username": "Mukul_reign",
                        "content": " i think so it\\'s basically asked to use trie data structure"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Question to people who did it in C (or C++ ig). Why do we have to always check if(ptr==NULL) and not if(!ptr)? My code didnt work because of this. "
                    },
                    {
                        "username": "aadevilas1137",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the \\'.\\' could have been replaced by another \\'a\\' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "charonme",
                        "content": "addWord(\"aa\"); search(\"a.\"); correctly expects true. What exact testcase are you trying?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "What you said makes sense but you should post the test case. You may not be reading the test correctly.\n\n`addWord(\"a\")` followed by `addWord(\"a\")` doesn't add `\"aa\"`. It just adds `\"a\"`. Is that the confusion?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Thank goodness.... I am finally able to implement and use this Data Structure."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "this should be hard\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Though I use trie-structure, the words being added must be grouped by their length... In other words, multiple trie-tree may be needed to avoid TLE."
                    }
                ]
            },
            {
                "id": 1836905,
                "content": [
                    {
                        "username": "vishaljoshi1998",
                        "content": "[[],[\"a\"],[\"a.\"]]"
                    },
                    {
                        "username": "smbody",
                        "content": "I have passed 29/29 test cases but the result still shows TLE. How do i resolve this ?"
                    },
                    {
                        "username": "ibaydin",
                        "content": "did u solve that? i have same situation too. \nEdit: I just solved, little more optimization fixed my issue."
                    },
                    {
                        "username": "user7275Ci",
                        "content": "Golang submission is broken\\n`\\nLine 75: Char 19: undefined: Deserializer (solution.go)\\nLine 80: Char 36: undefined: Deserializer (solution.go)\\nLine 84: Char 36: undefined: Deserializer (solution.go)\\nLine 85: Char 34: undefined: Serializer (solution.go)\\nLine 153: Char 25: undefined: Deserializer (solution.go)\\n`"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "\\uD83D\\uDD25++;"
                    },
                    {
                        "username": "Mukul_reign",
                        "content": " i think so it\\'s basically asked to use trie data structure"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Question to people who did it in C (or C++ ig). Why do we have to always check if(ptr==NULL) and not if(!ptr)? My code didnt work because of this. "
                    },
                    {
                        "username": "aadevilas1137",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the \\'.\\' could have been replaced by another \\'a\\' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "charonme",
                        "content": "addWord(\"aa\"); search(\"a.\"); correctly expects true. What exact testcase are you trying?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "What you said makes sense but you should post the test case. You may not be reading the test correctly.\n\n`addWord(\"a\")` followed by `addWord(\"a\")` doesn't add `\"aa\"`. It just adds `\"a\"`. Is that the confusion?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Thank goodness.... I am finally able to implement and use this Data Structure."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "this should be hard\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Though I use trie-structure, the words being added must be grouped by their length... In other words, multiple trie-tree may be needed to avoid TLE."
                    }
                ]
            },
            {
                "id": 1836750,
                "content": [
                    {
                        "username": "vishaljoshi1998",
                        "content": "[[],[\"a\"],[\"a.\"]]"
                    },
                    {
                        "username": "smbody",
                        "content": "I have passed 29/29 test cases but the result still shows TLE. How do i resolve this ?"
                    },
                    {
                        "username": "ibaydin",
                        "content": "did u solve that? i have same situation too. \nEdit: I just solved, little more optimization fixed my issue."
                    },
                    {
                        "username": "user7275Ci",
                        "content": "Golang submission is broken\\n`\\nLine 75: Char 19: undefined: Deserializer (solution.go)\\nLine 80: Char 36: undefined: Deserializer (solution.go)\\nLine 84: Char 36: undefined: Deserializer (solution.go)\\nLine 85: Char 34: undefined: Serializer (solution.go)\\nLine 153: Char 25: undefined: Deserializer (solution.go)\\n`"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "\\uD83D\\uDD25++;"
                    },
                    {
                        "username": "Mukul_reign",
                        "content": " i think so it\\'s basically asked to use trie data structure"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Question to people who did it in C (or C++ ig). Why do we have to always check if(ptr==NULL) and not if(!ptr)? My code didnt work because of this. "
                    },
                    {
                        "username": "aadevilas1137",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the \\'.\\' could have been replaced by another \\'a\\' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "charonme",
                        "content": "addWord(\"aa\"); search(\"a.\"); correctly expects true. What exact testcase are you trying?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "What you said makes sense but you should post the test case. You may not be reading the test correctly.\n\n`addWord(\"a\")` followed by `addWord(\"a\")` doesn't add `\"aa\"`. It just adds `\"a\"`. Is that the confusion?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Thank goodness.... I am finally able to implement and use this Data Structure."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "this should be hard\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Though I use trie-structure, the words being added must be grouped by their length... In other words, multiple trie-tree may be needed to avoid TLE."
                    }
                ]
            },
            {
                "id": 1836743,
                "content": [
                    {
                        "username": "vishaljoshi1998",
                        "content": "[[],[\"a\"],[\"a.\"]]"
                    },
                    {
                        "username": "smbody",
                        "content": "I have passed 29/29 test cases but the result still shows TLE. How do i resolve this ?"
                    },
                    {
                        "username": "ibaydin",
                        "content": "did u solve that? i have same situation too. \nEdit: I just solved, little more optimization fixed my issue."
                    },
                    {
                        "username": "user7275Ci",
                        "content": "Golang submission is broken\\n`\\nLine 75: Char 19: undefined: Deserializer (solution.go)\\nLine 80: Char 36: undefined: Deserializer (solution.go)\\nLine 84: Char 36: undefined: Deserializer (solution.go)\\nLine 85: Char 34: undefined: Serializer (solution.go)\\nLine 153: Char 25: undefined: Deserializer (solution.go)\\n`"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "\\uD83D\\uDD25++;"
                    },
                    {
                        "username": "Mukul_reign",
                        "content": " i think so it\\'s basically asked to use trie data structure"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Question to people who did it in C (or C++ ig). Why do we have to always check if(ptr==NULL) and not if(!ptr)? My code didnt work because of this. "
                    },
                    {
                        "username": "aadevilas1137",
                        "content": "There is an insert (\"aa\"). However, the search for test string (\"a.\") is returning FALSE in the test case ? Should it not be TRUE as the \\'.\\' could have been replaced by another \\'a\\' which exists there in the input \"aa\"?"
                    },
                    {
                        "username": "charonme",
                        "content": "addWord(\"aa\"); search(\"a.\"); correctly expects true. What exact testcase are you trying?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "What you said makes sense but you should post the test case. You may not be reading the test correctly.\n\n`addWord(\"a\")` followed by `addWord(\"a\")` doesn't add `\"aa\"`. It just adds `\"a\"`. Is that the confusion?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "Thank goodness.... I am finally able to implement and use this Data Structure."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "this should be hard\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Though I use trie-structure, the words being added must be grouped by their length... In other words, multiple trie-tree may be needed to avoid TLE."
                    }
                ]
            }
        ]
    }
]