[
    {
        "title": "Group By",
        "question_content": "Write code that enhances all arrays such that you can call the&nbsp;array.groupBy(fn)&nbsp;method on any array and it will return a grouped&nbsp;version of the array.\nA&nbsp;grouped&nbsp;array is an object where each&nbsp;key&nbsp;is&nbsp;the output of&nbsp;fn(arr[i])&nbsp;and each&nbsp;value is an array containing all items in the original array with that key.\nThe provided callback&nbsp;fn&nbsp;will accept an item in the array and return a string key.\nThe order of each value list should be the order the items&nbsp;appear in the array. Any order of keys is acceptable.\nPlease solve it without lodash's&nbsp;_.groupBy function.\n&nbsp;\nExample 1:\n\nInput: \narray = [\n&nbsp; {\"id\":\"1\"},\n&nbsp; {\"id\":\"1\"},\n&nbsp; {\"id\":\"2\"}\n], \nfn = function (item) { \n&nbsp; return item.id; \n}\nOutput: \n{ \n&nbsp; \"1\": [{\"id\": \"1\"}, {\"id\": \"1\"}], &nbsp; \n&nbsp; \"2\": [{\"id\": \"2\"}] \n}\nExplanation:\nOutput is from array.groupBy(fn).\nThe selector function gets the \"id\" out of each item in the array.\nThere are two objects with an \"id\" of 1. Both of those objects are put in the first array.\nThere is one object with an \"id\" of 2. That object is put in the second array.\n\nExample 2:\n\nInput: \narray = [\n&nbsp; [1, 2, 3],\n&nbsp; [1, 3, 5],\n&nbsp; [1, 5, 9]\n]\nfn = function (list) { \n&nbsp; return String(list[0]); \n}\nOutput: \n{ \n&nbsp; \"1\": [[1, 2, 3], [1, 3, 5], [1, 5, 9]] \n}\nExplanation:\nThe array can be of any type. In this case, the selector function defines the key as being the first element in the array. \nAll the arrays have 1 as their first element so they are grouped together.\n{\n  \"1\": [[1, 2, 3], [1, 3, 5], [1, 5, 9]]\n}\n\nExample 3:\n\nInput: \narray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfn = function (n) { \n&nbsp; return String(n > 5);\n}\nOutput:\n{\n&nbsp; \"true\": [6, 7, 8, 9, 10],\n&nbsp; \"false\": [1, 2, 3, 4, 5]\n}\nExplanation:\nThe selector function splits the array by whether each number is greater than 5.\n\n&nbsp;\nConstraints:\n\n\t0 <= array.length <= 105\n\tfn returns a string",
        "solutions": [
            {
                "id": 3568048,
                "title": "groupby-detailed-explanation-easy",
                "content": "# Approach:\\n1. We define groupBy method by extending the Array `prototype` to add a `groupBy` method. This allows any array to call this method.\\n\\n2. To group the elements, we need to iterate over each item in the array. One way to achieve this is by using the `reduce` function. The `reduce` function allows us to iterate over the array while accumulating a result.\\n\\n3. In order to group the elements, we need a way to identify which elements belong to the same group. This is where the provided function `fn` comes into play. The function takes an element as input and returns a value that will serve as the grouping key.\\n\\n4. While iterating over each element, we need to check if a group already exists for the current key. If not, we create an empty array to hold the elements for that group. Then, we push the current element into the corresponding group array.\\n\\n5. After all elements have been processed, we return the object that contains the grouped elements. Each key in the object represents a group, and the associated value is an array containing the elements belonging to that group.\\n\\n# Code Explanation:\\n1. `Array.prototype.groupBy = function(fn):` This line adds a new method called `groupBy` to the Array `prototype`. This means that any array object in JavaScript can now call this method.\\n\\n2. The `groupBy` function takes a single argument `fn`, which represents the function to be used for grouping the array elements.\\n\\n3. `this.reduce((grouped, item) => { ... })`: The `reduce` function is used to iterate over each element in the array and accumulate a final result. The initial value for the accumulator is an empty object `{}`.\\n\\n4. Inside the reduce function, we have an arrow function with two parameters: `grouped` and `item`. `grouped` represents the object that stores the grouped elements, and `item` represents the current element being processed.\\n\\n5. `const key = fn(item);`: This line calls the provided function `fn` with the current element item as an argument to determine the grouping `key`. The returned value is stored in the `key` variable.\\n\\n6. `if (!grouped[key]) { grouped[key] = []; }`: This code block checks if the `key` already exists as a `property` in the `grouped object`. If not, it creates a new property with the key name and assigns an empty array `[]` as its value.\\n\\n7. `grouped[key].push(item);`: This line adds the current item to the `array` corresponding to its `key` in the `grouped` object. This effectively groups the elements based on their key values.\\n\\n8. Finally, return `grouped`; is used to return the updated grouped object after all the elements have been processed.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  // Reduce the array into a single object\\n  return this.reduce((grouped, item) => {\\n    // Apply the provided callback function to get the key\\n    const key = fn(item);\\n    \\n    // If the key doesn\\'t exist in the grouped object, create a new array for it\\n    if (!grouped[key]) {\\n      grouped[key] = [];\\n    }\\n    \\n    // Push the current item to the array associated with the key\\n    grouped[key].push(item);\\n    \\n    // Return the updated grouped object for the next iteration\\n    return grouped;\\n  }, {});\\n};\\n\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  // Reduce the array into a single object\\n  return this.reduce((grouped, item) => {\\n    // Apply the provided callback function to get the key\\n    const key = fn(item);\\n    \\n    // If the key doesn\\'t exist in the grouped object, create a new array for it\\n    if (!grouped[key]) {\\n      grouped[key] = [];\\n    }\\n    \\n    // Push the current item to the array associated with the key\\n    grouped[key].push(item);\\n    \\n    // Return the updated grouped object for the next iteration\\n    return grouped;\\n  }, {});\\n};\\n\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407243,
                "title": "javascript-easy-solution-short",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const ans = {}\\n    for(let e of this){\\n        const key = fn((e))\\n        ans[key] ||=[]\\n        ans[key].push(e)\\n    }\\n    return ans\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const ans = {}\\n    for(let e of this){\\n        const key = fn((e))\\n        ans[key] ||=[]\\n        ans[key].push(e)\\n    }\\n    return ans\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570603,
                "title": "day-23-o-1-o-1-commented-examples",
                "content": "This code defines a new method called `groupBy()` for the `Array` prototype. The purpose of this method is to group elements of an array based on a provided function.\\n\\nHere\\'s how the code works:\\n\\n1. The `groupBy()` method is defined using `Array.prototype.groupBy = function(fn) { ... }`. This allows the method to be called on any array object.\\n\\n2. Inside the method, a new empty object `ans` is created. This object will store the grouped elements.\\n\\n3. The method then iterates over each element of the array using a `for...of` loop with `let ele of this`. The `this` keyword refers to the array on which the `groupBy()` method is called.\\n\\n4. For each element, the provided function `fn` is invoked with the current element as an argument, and the result is stored in the `temp` variable. The purpose of this function is to determine the grouping key for each element.\\n\\n5. The next step checks if the `ans` object already has a property corresponding to the `temp` value. If it does, it means that there is already a group for that key, and the current element is added to that group by using the `push()` method. If the property doesn\\'t exist, a new array is created with the current element and assigned to the `temp` key in the `ans` object.\\n\\n6. After all elements have been processed, the `ans` object containing the grouped elements is returned.\\n\\nLet\\'s look at an example to understand how this code works:\\n\\n```javascript\\nconst numbers = [1, 2, 3, 4, 5, 6];\\nconst groups = numbers.groupBy((num) => num % 2 === 0 ? \\'even\\' : \\'odd\\');\\n\\nconsole.log(groups);\\n```\\n\\nIn this example, the `numbers` array contains a sequence of numbers. We call the `groupBy()` method on the `numbers` array and provide a function that determines the grouping based on whether a number is even or odd.\\n\\nThe output of `console.log(groups)` will be:\\n\\n```javascript\\n{\\n  odd: [1, 3, 5],\\n  even: [2, 4, 6]\\n}\\n```\\n\\nAs you can see, the elements of the `numbers` array are grouped into two groups: `odd` and `even`. The `odd` group contains all the odd numbers from the original array, and the `even` group contains all the even numbers.\\n\\n\\n***Here is the solution to the current problem:-***\\n```\\n\\nArray.prototype.groupBy = function(fn) {\\n    const ans = {};\\n   for (let ele of this) {\\n        const temp = fn(ele);\\n        ans[temp]?ans[temp].push(ele): ans[temp] = [ele];\\n    }\\n    return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table"
                ],
                "code": "```javascript\\nconst numbers = [1, 2, 3, 4, 5, 6];\\nconst groups = numbers.groupBy((num) => num % 2 === 0 ? \\'even\\' : \\'odd\\');\\n\\nconsole.log(groups);\\n```\n```javascript\\n{\\n  odd: [1, 3, 5],\\n  even: [2, 4, 6]\\n}\\n```\n```\\n\\nArray.prototype.groupBy = function(fn) {\\n    const ans = {};\\n   for (let ele of this) {\\n        const temp = fn(ele);\\n        ans[temp]?ans[temp].push(ele): ans[temp] = [ele];\\n    }\\n    return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466211,
                "title": "javascript-reduce",
                "content": "```\\nArray.prototype.groupBy = function (fn) {\\n  return this.reduce((map, c) => {\\n    const id = fn(c);\\n    map[id] ? map[id].push(c) : (map[id] = [c]);\\n    return map;\\n  }, {});\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.groupBy = function (fn) {\\n  return this.reduce((map, c) => {\\n    const id = fn(c);\\n    map[id] ? map[id].push(c) : (map[id] = [c]);\\n    return map;\\n  }, {});\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941513,
                "title": "javascript-using-related-array-functionality-93-faster-exec",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const grouped = {};\\n    this.forEach((item) => {\\n        let key = fn(item);\\n        if(!grouped[key]) grouped[key] = [];\\n        grouped[key].push(item);\\n    })\\n    return grouped;\\n};\\n\\n/*\\nArray.prototype.groupBy = function(fn){\\n    return this.reduce((res, item) => {\\n        let key = fn(item);\\n        if(!res[key]) res[key] = [];\\n        res[key].push(item);\\n        return res;\\n    }, {})\\n};\\n\\n*/\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const grouped = {};\\n    this.forEach((item) => {\\n        let key = fn(item);\\n        if(!grouped[key]) grouped[key] = [];\\n        grouped[key].push(item);\\n    })\\n    return grouped;\\n};\\n\\n/*\\nArray.prototype.groupBy = function(fn){\\n    return this.reduce((res, item) => {\\n        let key = fn(item);\\n        if(!res[key]) res[key] = [];\\n        res[key].push(item);\\n        return res;\\n    }, {})\\n};\\n\\n*/\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3407219,
                "title": "groupby-typescript-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse an object to group the items by the groupBy function as the key.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate an object ```hash``` and then iterate each of the items and group them by the ```groupBy``` function.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$\\n# Code\\n```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    const hash = {}\\n    for (let item of this){\\n        const key = fn(item)\\n        hash[key] ||= []\\n        hash[key].push(item)\\n    }\\n    return hash\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```hash```\n```groupBy```\n```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    const hash = {}\\n    for (let item of this){\\n        const key = fn(item)\\n        hash[key] ||= []\\n        hash[key].push(item)\\n    }\\n    return hash\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572348,
                "title": "java-script-solution-for-group-by-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to enhance the Array prototype by adding a groupBy method that groups the elements of an array based on a provided callback function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to use the reduce function to iterate over the array and create a grouped object. For each item, the callback function is called to generate the grouping key. If the key doesn\\'t exist in the result object, it is initialized as an empty array. The item is then pushed into the array corresponding to its key. Finally, the resulting grouped object is returned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n), where n is the length of the array. This is because the reduce function iterates over each item in the array once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is also O(n), as the grouped object grows in size with the number of distinct keys in the array.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  return this.reduce((result, item) => {\\n    const key = fn(item);\\n    if (!(key in result)) {\\n      result[key] = [];\\n    }\\n    result[key].push(item);\\n    return result;\\n  }, {});\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  return this.reduce((result, item) => {\\n    const key = fn(item);\\n    if (!(key in result)) {\\n      result[key] = [];\\n    }\\n    result[key].push(item);\\n    return result;\\n  }, {});\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570846,
                "title": "simple-javascript-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const ans = {};\\n    this.forEach((el,idx) => {\\n        const key = fn(el);\\n         if (!ans.hasOwnProperty(key)) {\\n      ans[key] = [];\\n    }\\n     ans[key].push(el);\\n    })\\n    return ans;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const ans = {};\\n    this.forEach((el,idx) => {\\n        const key = fn(el);\\n         if (!ans.hasOwnProperty(key)) {\\n      ans[key] = [];\\n    }\\n     ans[key].push(el);\\n    })\\n    return ans;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570604,
                "title": "easy-javascript-solution",
                "content": "# Code\\n```\\nArray.prototype.groupBy = function(fn) {\\n    const grouped = {},length = this.length;\\n    for(let i=0;i<length;i++){\\n      const id = fn(this[i]);\\n      if(grouped[id] === undefined) grouped[id] = [];\\n      grouped[id].push(this[i]);\\n    }\\n    return grouped;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.groupBy = function(fn) {\\n    const grouped = {},length = this.length;\\n    for(let i=0;i<length;i++){\\n      const id = fn(this[i]);\\n      if(grouped[id] === undefined) grouped[id] = [];\\n      grouped[id].push(this[i]);\\n    }\\n    return grouped;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3419596,
                "title": "simple-object-and-array",
                "content": "# Code\\n```\\nArray.prototype.groupBy = function(fn) {\\n    const group = {};\\n    for (const val of this) {\\n        const key = fn(val);\\n        group.hasOwnProperty(key) ? group[key].push(val) : group[key] = [val];\\n    }\\n\\n    return group;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.groupBy = function(fn) {\\n    const group = {};\\n    for (const val of this) {\\n        const key = fn(val);\\n        group.hasOwnProperty(key) ? group[key].push(val) : group[key] = [val];\\n    }\\n\\n    return group;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570162,
                "title": "easy-solution-with-explanation-prototype-in-javascript-contructor-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. As we know in order to add any method or property to constructor,prototype is used.\\n1. To add the groupBy method to the Array constructor, we can use the prototype.\\n```\\nArray.prototype.groupBy = function (fn) {\\n  // Method implementation goes here\\n};\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n - The groupBy method is added to the Array.prototype. This allows you to call it directly on any array object.\\n - The groupBy method takes a callback function fn as a parameter. This callback function will be used to determine the grouping key for each item in the array.\\n\\n- Inside the groupBy method, we use the reduce function to iterate over each item in the array and create the grouped object.\\n\\n- The reduce function takes an initial value of an empty object {} as the accumulator (result). It iterates over each item in the array, and for each item, it executes the callback function and retrieves the grouping key (key).\\n- If the key doesn\\'t exist as a property in the result object, we initialize it as an empty array using result[key] = [].\\n- We then push the current item into the array corresponding to the key in the result object using result[key].push(item).\\n- Finally, we return the result object, which contains the grouped array.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n      let arr=this;\\n      const grouped_Arr={};\\n      for(a of arr)\\n      {\\n          let key=fn(a);\\n          if(key in grouped_Arr)\\n          {\\n             grouped_Arr[key].push(a);  \\n          }\\n          else\\n          {\\n             grouped_Arr[key]=[a];  \\n          }\\n      }\\n      return grouped_Arr;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.groupBy = function (fn) {\\n  // Method implementation goes here\\n};\\n```\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n      let arr=this;\\n      const grouped_Arr={};\\n      for(a of arr)\\n      {\\n          let key=fn(a);\\n          if(key in grouped_Arr)\\n          {\\n             grouped_Arr[key].push(a);  \\n          }\\n          else\\n          {\\n             grouped_Arr[key]=[a];  \\n          }\\n      }\\n      return grouped_Arr;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570055,
                "title": "easy-solution-loop-object",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const length = this.length\\n    const res = {}\\n    for(let i = 0; i < length; i++) {\\n        const k = fn(this[i])\\n        res[k] ? res[k].push(this[i]) :  res[k] = [this[i]]\\n    }\\n\\n    return res\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const length = this.length\\n    const res = {}\\n    for(let i = 0; i < length; i++) {\\n        const k = fn(this[i])\\n        res[k] ? res[k].push(this[i]) :  res[k] = [this[i]]\\n    }\\n\\n    return res\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3569954,
                "title": "javascript-solution",
                "content": "\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const ans={};\\n    for(let e of this){\\n        const key=fn((e));\\n        ans[key] ||=[];\\n        ans[key].push(e);\\n\\n    };\\n    return ans;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const ans={};\\n    for(let e of this){\\n        const key=fn((e));\\n        ans[key] ||=[];\\n        ans[key].push(e);\\n\\n    };\\n    return ans;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3465426,
                "title": "using-for-of-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    \\n  const nums = this;\\n  const res = {};\\n   \\n   for(let obj of nums){\\n     let _ID = fn(obj)\\n    if(!res.hasOwnProperty(_ID)){\\n      res[_ID] = [obj];\\n    }else{\\n      res[_ID].push(obj);\\n    }\\n   }\\n  return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```\\n# If You Find This Solution Helpful Please UpVote, Every Vote Makes me feel Motivated \\n**Happy coding mate ...**\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    \\n  const nums = this;\\n  const res = {};\\n   \\n   for(let obj of nums){\\n     let _ID = fn(obj)\\n    if(!res.hasOwnProperty(_ID)){\\n      res[_ID] = [obj];\\n    }else{\\n      res[_ID].push(obj);\\n    }\\n   }\\n  return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3457932,
                "title": "intuitive-readable-solution-is-typescript-javascript",
                "content": "# Approach\\nLoop through each element of the array, apply the callback function to it to get the key, and then use that key to group the elements in a new object.\\n\\n# Complexity\\n- Time complexity: The function loops through each element of the array once and performs constant-time operations for each element. The time complexity is therefore O(n), where n is the length of the array.\\n\\n- Space complexity: The function creates a new object to store the grouped elements, with keys and values that are copies of the original array elements. The space required is therefore proportional to the number of unique keys returned by the callback function, which could be as large as the size of the array if all elements have different keys. The worst-case space complexity is therefore O(n).\\n\\n# Code\\n```\\nexport {};\\n\\ndeclare global {\\n  interface Array<T> {\\n    groupBy(fn: (item: T) => string): Record<string, T[]>;\\n  }\\n}\\n\\nArray.prototype.groupBy = function <T>(\\n  this: Array<T>,\\n  callback: (element: T) => string\\n) {\\n  const grouped: Record<string, T[]> = {};\\n\\n  this.map((element) => {\\n    const key = callback(element);\\n    grouped[key] ||= [];\\n    grouped[key].push(element);\\n  });\\n\\n  return grouped;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nexport {};\\n\\ndeclare global {\\n  interface Array<T> {\\n    groupBy(fn: (item: T) => string): Record<string, T[]>;\\n  }\\n}\\n\\nArray.prototype.groupBy = function <T>(\\n  this: Array<T>,\\n  callback: (element: T) => string\\n) {\\n  const grouped: Record<string, T[]> = {};\\n\\n  this.map((element) => {\\n    const key = callback(element);\\n    grouped[key] ||= [];\\n    grouped[key].push(element);\\n  });\\n\\n  return grouped;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3443488,
                "title": "one-line-js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n        return this.reduce((grouped,item)=> (grouped[fn(item)] ||= []).push(item) && grouped,{})\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n        return this.reduce((grouped,item)=> (grouped[fn(item)] ||= []).push(item) && grouped,{})\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3751124,
                "title": "easy-js-code-beats-92",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const obj = {}\\n    arr = this\\n    arr.forEach((item, index) => {\\n        let temp = fn(item)\\n        if ( Object.hasOwn(obj, temp)) {\\n            obj[temp].push(item)}\\n        else {\\n            obj[temp] = [item] }\\n    })\\n    return obj  \\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const obj = {}\\n    arr = this\\n    arr.forEach((item, index) => {\\n        let temp = fn(item)\\n        if ( Object.hasOwn(obj, temp)) {\\n            obj[temp].push(item)}\\n        else {\\n            obj[temp] = [item] }\\n    })\\n    return obj  \\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570443,
                "title": "javascript-array-reduce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\n\\nArray.prototype.groupBy = function(fn) {\\n    // reduce method on the array (this) to build the grouped object\\n    return this.reduce((res, item) => {\\n    const key = fn(item);//fn function to calculate the key based on the current item\\n    if (!(key in res)) {\\n      res[key] = [];\\n    }\\n    // push the current item to the array for corresponding key in the result object.\\n    res[key].push(item);\\n    return res;\\n  }, {});// {} as the initial value for reduce (empty object)\\n};\\n\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\n\\nArray.prototype.groupBy = function(fn) {\\n    // reduce method on the array (this) to build the grouped object\\n    return this.reduce((res, item) => {\\n    const key = fn(item);//fn function to calculate the key based on the current item\\n    if (!(key in res)) {\\n      res[key] = [];\\n    }\\n    // push the current item to the array for corresponding key in the result object.\\n    res[key].push(item);\\n    return res;\\n  }, {});// {} as the initial value for reduce (empty object)\\n};\\n\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570050,
                "title": "c-simple-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    var arr = this;\\n    var ans = {};\\n\\n    for(let i =0;i<arr.length;i++){\\n        var key = fn(arr[i]);\\n\\n        if(ans[key]){\\n            ans[key].push(arr[i]);\\n        }\\n        else{\\n            ans[key] = [];\\n            ans[key].push(arr[i]);\\n        }\\n    }\\n    return ans;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    var arr = this;\\n    var ans = {};\\n\\n    for(let i =0;i<arr.length;i++){\\n        var key = fn(arr[i]);\\n\\n        if(ans[key]){\\n            ans[key].push(arr[i]);\\n        }\\n        else{\\n            ans[key] = [];\\n            ans[key].push(arr[i]);\\n        }\\n    }\\n    return ans;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3406908,
                "title": "solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  const groups = new Map();\\n  for (let item of this) {\\n    const groupKey = fn(item);\\n    if (!groups.has(groupKey)) {\\n      groups.set(groupKey, [item]);\\n    } else {\\n      groups.get(groupKey).push(item);\\n    }\\n  }\\n  return Object.fromEntries(groups.entries());\\n};\\n\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  const groups = new Map();\\n  for (let item of this) {\\n    const groupKey = fn(item);\\n    if (!groups.has(groupKey)) {\\n      groups.set(groupKey, [item]);\\n    } else {\\n      groups.get(groupKey).push(item);\\n    }\\n  }\\n  return Object.fromEntries(groups.entries());\\n};\\n\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095840,
                "title": "2631-group-by",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Object}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n\\n    this.forEach((item) => {\\n        let keys = fn(item);\\n\\n        if (keys in result) {\\n            result[`${keys}`].push(item);\\n        } else {\\n            result[`${keys}`] = [item];\\n        }\\n    })\\n\\n    return result;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Object}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n\\n    this.forEach((item) => {\\n        let keys = fn(item);\\n\\n        if (keys in result) {\\n            result[`${keys}`].push(item);\\n        } else {\\n            result[`${keys}`] = [item];\\n        }\\n    })\\n\\n    return result;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084590,
                "title": "simple-solution",
                "content": "```\\nArray.prototype.groupBy = function(fn) {\\n  const obj = {};\\n\\n  this.forEach((el) => {\\n    const key = fn(el);\\n\\n    obj[key] ? obj[key].push(el) : (obj[key] = [el]);\\n  });\\n\\n  return obj;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.groupBy = function(fn) {\\n  const obj = {};\\n\\n  this.forEach((el) => {\\n    const key = fn(el);\\n\\n    obj[key] ? obj[key].push(el) : (obj[key] = [el]);\\n  });\\n\\n  return obj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080076,
                "title": "simple-solution-in-js-ts",
                "content": "# Code\\n```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    let result = {};\\n\\n    for (let i = 0; i < this.length; i++) {\\n        let key = fn(this[i]);\\n        \\n        result[key] \\n            ? result[key].push(this[i])\\n            : result[key] = [this[i]];\\n    }\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    let result = {};\\n\\n    for (let i = 0; i < this.length; i++) {\\n        let key = fn(this[i]);\\n        \\n        result[key] \\n            ? result[key].push(this[i])\\n            : result[key] = [this[i]];\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079485,
                "title": "solution-of-2631-group-by-javascript",
                "content": "# About the problem\\nThis function takes a callback function as input, which is called for each element in the array. The callback function should return a value, which is used as the key for the group in which the element is placed. The function returns an object, where each key is a group key and each value is an array of the elements in that group.\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo group an array by a key, we can iterate over the array and push each element into an array associated with the key returned by the callback function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an object to store the grouped elements.\\n2. Iterate over the array and for each element:\\n    - Call the callback function to get the key for the element.\\n    - If the key does not exist in the object, create an empty array for the key.\\n    - Push the element into the array associated with the key.\\n3. Return the object containing the grouped elements.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the length of the array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n), where n is the length of the array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const ans = {}\\n    for(let e of this){\\n        const key = fn((e))\\n        ans[key] ||=[]\\n        ans[key].push(e)\\n    }\\n    return ans\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const ans = {}\\n    for(let e of this){\\n        const key = fn((e))\\n        ans[key] ||=[]\\n        ans[key].push(e)\\n    }\\n    return ans\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068272,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n    this.forEach((ele) => {\\n        const value = fn(ele);\\n        if (value in result) {\\n            result[value].push(ele);\\n        } else {\\n            result[value] = [ele];\\n        }\\n    })\\n    return result;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n    this.forEach((ele) => {\\n        const value = fn(ele);\\n        if (value in result) {\\n            result[value].push(ele);\\n        } else {\\n            result[value] = [ele];\\n        }\\n    })\\n    return result;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061815,
                "title": "m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n return this.reduce((v,c)=>{\\n  const key = fn(c)\\nif(!(key in v)){\\nv[key] = [];\\n}\\nv[key].push(c)\\nreturn v\\n },{})\\n \\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n return this.reduce((v,c)=>{\\n  const key = fn(c)\\nif(!(key in v)){\\nv[key] = [];\\n}\\nv[key].push(c)\\nreturn v\\n },{})\\n \\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057802,
                "title": "beats-92-07-of-users-with-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    // Method 1:\\n    /*\\n    let result = {};\\n    for(let i = 0, curr, temp; i < this.length; i++) {\\n        curr = this[i];\\n        temp = fn(curr);\\n        if(result[temp] !== undefined) {\\n            result[temp].push(curr);\\n        } else {\\n            result[temp] = [curr];\\n        }\\n    }\\n    return result;\\n    */\\n\\n    // Method 2: reduce\\n    return this.reduce((res, curr) => {\\n        let temp = fn(curr);\\n        (res[temp]) ? res[temp].push(curr): res[temp] = [curr];\\n        return res;\\n    }, {})\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    // Method 1:\\n    /*\\n    let result = {};\\n    for(let i = 0, curr, temp; i < this.length; i++) {\\n        curr = this[i];\\n        temp = fn(curr);\\n        if(result[temp] !== undefined) {\\n            result[temp].push(curr);\\n        } else {\\n            result[temp] = [curr];\\n        }\\n    }\\n    return result;\\n    */\\n\\n    // Method 2: reduce\\n    return this.reduce((res, curr) => {\\n        let temp = fn(curr);\\n        (res[temp]) ? res[temp].push(curr): res[temp] = [curr];\\n        return res;\\n    }, {})\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052008,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const ans = {};\\n    for (let ele of this) {\\n        const temp = fn(ele);\\n        ans[temp]?ans[temp].push(ele): ans[temp] = [ele];\\n    }\\n    return ans;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const ans = {};\\n    for (let ele of this) {\\n        const temp = fn(ele);\\n        ans[temp]?ans[temp].push(ele): ans[temp] = [ele];\\n    }\\n    return ans;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050399,
                "title": "use-of-foreach-for-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    obj = {}\\n    this.forEach(element => {\\n      key =fn(element)\\n     if(key in obj) {\\n      obj[key].push(element)  \\n      return \\n     } \\n      obj[key] = [element]\\n      return\\n  })\\n    return obj;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    obj = {}\\n    this.forEach(element => {\\n      key =fn(element)\\n     if(key in obj) {\\n      obj[key].push(element)  \\n      return \\n     } \\n      obj[key] = [element]\\n      return\\n  })\\n    return obj;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4042551,
                "title": "beats-96-58-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let obj = {}\\n    for(let i =0;i<this.length;i++){\\n        let key = fn(this[i])\\n        if(obj[key]){\\n            obj[key].push(this[i])\\n        }else {\\n            obj[key] = [this[i]]\\n        }\\n    }\\n    return obj\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let obj = {}\\n    for(let i =0;i<this.length;i++){\\n        let key = fn(this[i])\\n        if(obj[key]){\\n            obj[key].push(this[i])\\n        }else {\\n            obj[key] = [this[i]]\\n        }\\n    }\\n    return obj\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4029700,
                "title": "easy-to-understand-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Object to maintain key value pair\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate through array, get the key and insert the item in value for corresponding key. If key don\\'t exist, assign empty array.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const res = {}\\n    for (let item of this) {\\n        const key = fn(item)\\n        if (!res[key]) res[key] = []\\n        res[key].push(item)\\n    }\\n    return res\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const res = {}\\n    for (let item of this) {\\n        const key = fn(item)\\n        if (!res[key]) res[key] = []\\n        res[key].push(item)\\n    }\\n    return res\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028012,
                "title": "javascript-array-push-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n    this.forEach((item) => {\\n        const key = fn(item);\\n        if(typeof result[key] === \"object\") {\\n            result[key].push(item);\\n        } else {\\n            result[key] = [item];\\n        }\\n    })\\n    return result;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n    this.forEach((item) => {\\n        const key = fn(item);\\n        if(typeof result[key] === \"object\") {\\n            result[key].push(item);\\n        } else {\\n            result[key] = [item];\\n        }\\n    })\\n    return result;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027690,
                "title": "beats-92-in-rumtime-and-93-in-memory-typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    const result: Record<string, any[]> = {}\\n\\n    for (let i = 0; i < this.length; i++) {\\n        const key: string = fn(this[i])\\n\\n        if (result[key]) {\\n            result[key].push(this[i])\\n        } else {\\n            result[key] = [this[i]]\\n        }\\n    }\\n\\n    return result\\n}\\n\\nexport {}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    const result: Record<string, any[]> = {}\\n\\n    for (let i = 0; i < this.length; i++) {\\n        const key: string = fn(this[i])\\n\\n        if (result[key]) {\\n            result[key].push(this[i])\\n        } else {\\n            result[key] = [this[i]]\\n        }\\n    }\\n\\n    return result\\n}\\n\\nexport {}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021464,
                "title": "very-easy-solution-without-using-reduce-method",
                "content": "```\\nCode block\\n```# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --```\\n$$```\\nCode block\\n```$$\\n```>\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let a = this\\n    let obj= {}\\n    a.forEach(e =>{\\n        let id = fn(e)\\n        if(!obj[id]){\\n            obj[id] = [e]\\n        }\\n        else{\\n            obj[id].push(e)\\n        }\\n    })\\n    return obj\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nCode block\\n```\n```\\n$$```\n```$$\\n```\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let a = this\\n    let obj= {}\\n    a.forEach(e =>{\\n        let id = fn(e)\\n        if(!obj[id]){\\n            obj[id] = [e]\\n        }\\n        else{\\n            obj[id].push(e)\\n        }\\n    })\\n    return obj\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012712,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nArray.prototype.groupBy = function(fn) {\\n    let arr = this;\\n    let obj={};\\n    for(var i=0;i<arr.length;i++){\\n        let key = fn(arr[i]);\\n        let val = arr[i];\\n\\n        // if key is not present create new empty arr corresponds to that key\\n        if(!obj[key]){\\n            obj[key]=[];\\n        }\\n        obj[key].push(val);\\n    }\\n    return obj;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.groupBy = function(fn) {\\n    let arr = this;\\n    let obj={};\\n    for(var i=0;i<arr.length;i++){\\n        let key = fn(arr[i]);\\n        let val = arr[i];\\n\\n        // if key is not present create new empty arr corresponds to that key\\n        if(!obj[key]){\\n            obj[key]=[];\\n        }\\n        obj[key].push(val);\\n    }\\n    return obj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012212,
                "title": "2-solutions-using-for-loop-and-reduce",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((acc,item)=>{\\n        const key = fn(item);\\n        acc[key] ||= [];\\n        acc[key].push(item);\\n        return acc;\\n    },{})\\n}\\n```\\n```\\nArray.prototype.groupBy = function(fn) {\\n    const returnObj = {};\\n    for(const item of this){\\n        const key = fn(item)\\n        if(key in returnObj){\\n            returnObj[key].push(item)\\n        } else{\\n            returnObj[key] = [item];\\n        }\\n    }\\n    return returnObj;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((acc,item)=>{\\n        const key = fn(item);\\n        acc[key] ||= [];\\n        acc[key].push(item);\\n        return acc;\\n    },{})\\n}\\n```\n```\\nArray.prototype.groupBy = function(fn) {\\n    const returnObj = {};\\n    for(const item of this){\\n        const key = fn(item)\\n        if(key in returnObj){\\n            returnObj[key].push(item)\\n        } else{\\n            returnObj[key] = [item];\\n        }\\n    }\\n    return returnObj;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007362,
                "title": "group-by",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![00524.png](https://assets.leetcode.com/users/images/90e2f0dd-449f-4bcb-a846-e146761608d8_1693948051.6078117.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  const res = {};\\n  let i = 0;\\n  while (i !== this.length) {\\n    const currentKey = fn(this[i]);\\n    if (res.hasOwnProperty(currentKey)) {\\n      res[currentKey].push(this[i]);\\n    } else {\\n      res[currentKey] = [this[i]];\\n    }\\n    i++;\\n  }\\n  return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  const res = {};\\n  let i = 0;\\n  while (i !== this.length) {\\n    const currentKey = fn(this[i]);\\n    if (res.hasOwnProperty(currentKey)) {\\n      res[currentKey].push(this[i]);\\n    } else {\\n      res[currentKey] = [this[i]];\\n    }\\n    i++;\\n  }\\n  return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005964,
                "title": "ts-typescript-solution-group-by-simple-to-understand",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Start by creating an object called `grouped`. This object will have **string** keys and values that are **arrays of type T**.\\n\\n2. Go through each element in the input array (referred to as `this.Array` in the code):\\n    - For each element, store it in a variable called `item`.\\n    - Calculate a `key` by applying the function `fn` to the `item`. This key is a string.\\n    - Check if the `grouped` object already has an array associated with the calculated `key`. If not, create an empty array for that key. Otherwise, leave it as is.\\n        > In code: ```grouped[key] ||= [];```\\n    - Add/push the `item` to the array associated with the `key`.\\n\\n3. Once all elements in `this.Array` have been processed, return the `grouped` object. This object now contains the elements grouped according to the keys calculated by the `fn` function.\\n\\n# Complexity\\n\\n- **Time Complexity:**\\n\\n    - Iterating through the input array using forEach takes O(n) time, where n is the number of elements in the array.\\n    - For each element in the array, the provided function fn is called once to calculate the key. The time complexity of calling fn for each element is O(n) in the worst case.\\n    - Creating or updating the grouped object by adding elements to their respective arrays also takes O(n) time in the worst case because each element in the array is processed once.\\n\\n    > Therefore, the overall time complexity of the groupBy method is O(n) + O(n) + O(n), which simplifies to O(n).\\n\\n- **Space Complexity:**\\n\\n    - The primary space-consuming data structure in this implementation is the grouped object, which stores the grouped elements.\\n    - In the worst case, if all elements have unique keys, the grouped object will contain n different keys, each associated with an array containing one element. This results in O(n) space for the grouped object.\\n    - The space used by the fn function calls and other local variables is negligible in comparison.\\n\\n    > Therefore, the overall space complexity of the groupBy method is O(n) due to the grouped object.\\n\\n---\\n\\n**Do Upvote if it helps! Thank you.**\\n\\n# Code\\n```\\nexport {};\\n\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function<T>(fn: (item: T) => string): Record<string, T[]> {\\n    const grouped: Record<string, T[]> = {};\\n\\n    this.forEach((item: T) => {\\n        const key = fn(item);\\n        grouped[key] ||= [];\\n        grouped[key].push(item);\\n    });\\n\\n    return grouped;\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```grouped[key] ||= [];```\n```\\nexport {};\\n\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function<T>(fn: (item: T) => string): Record<string, T[]> {\\n    const grouped: Record<string, T[]> = {};\\n\\n    this.forEach((item: T) => {\\n        const key = fn(item);\\n        grouped[key] ||= [];\\n        grouped[key].push(item);\\n    });\\n\\n    return grouped;\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3999792,
                "title": "simple-for-loop",
                "content": "# Intuition\\n![group_by.png](https://assets.leetcode.com/users/images/f6bf29d9-2a4c-4234-8fc0-470623e2e45e_1693806822.6048894.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const arr = this;\\n    let obj = {};\\n    for(let i=0;i<arr.length;i++){\\n        const curFunOutput = fn(arr[i]);\\n        if(obj[curFunOutput]){\\n            obj[curFunOutput].push(arr[i]);\\n        } else\\n            obj[curFunOutput] = [arr[i]];\\n    }\\n    return obj\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const arr = this;\\n    let obj = {};\\n    for(let i=0;i<arr.length;i++){\\n        const curFunOutput = fn(arr[i]);\\n        if(obj[curFunOutput]){\\n            obj[curFunOutput].push(arr[i]);\\n        } else\\n            obj[curFunOutput] = [arr[i]];\\n    }\\n    return obj\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998448,
                "title": "so-simple",
                "content": "# Code\\n```\\nArray.prototype.groupBy = function(fn) {\\n    const res = {};\\n\\n    for (let val of this) {\\n        const key = fn(val).toString();\\n        res[key] ? res[key].push(val) : res[key] = [val];\\n    }\\n\\n    return res;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Code\\n```\\nArray.prototype.groupBy = function(fn) {\\n    const res = {};\\n\\n    for (let val of this) {\\n        const key = fn(val).toString();\\n        res[key] ? res[key].push(val) : res[key] = [val];\\n    }\\n\\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3996255,
                "title": "reduce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((res,n) =>  {\\n        let key = fn(n);\\n        if(!res[key]){\\n            res[key] = [];\\n        }\\n        res[key].push(n);  \\n        return res;\\n    },{});\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\",\"2\"1\":[1]:[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((res,n) =>  {\\n        let key = fn(n);\\n        if(!res[key]){\\n            res[key] = [];\\n        }\\n        res[key].push(n);  \\n        return res;\\n    },{});\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\",\"2\"1\":[1]:[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990070,
                "title": "javascript-groupby-o-n-easy-and-self-explanatory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThought initially that it could be an medium level question but it is somewhat easy - medium.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt was pretty clear how group by works, but the problem has an addition as fn() has a logic of groupby. So we need to run it through all the elements of the given array because there is a possibility of having each array element as a distinct one and fn() could also return anything. \\n\\nSo started with a loop following with an if condition to get keys for result object. Basically if condition checks, if function -> fn(some_logic) returned key is present in the current result obj. If it is present in current array element we will just add to an existing key else will create an key with array and having the current value of that element of that array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n\\n    //Object that will hold groupby values   \\n    let resultObj = {};\\n   //copy current array to a variable as it makes readable and explainable \\n    let arr = this;\\n\\n    for(let i = 0;i<arr.length;i++){\\n\\n        if(resultObj[fn(arr[i])]){\\n            resultObj[fn(arr[i])].push(arr[i]);\\n        }else{\\n            resultObj[fn(arr[i])] = [arr[i]]\\n        }\\n\\n    }\\n\\n    return resultObj;\\n\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n\\n    //Object that will hold groupby values   \\n    let resultObj = {};\\n   //copy current array to a variable as it makes readable and explainable \\n    let arr = this;\\n\\n    for(let i = 0;i<arr.length;i++){\\n\\n        if(resultObj[fn(arr[i])]){\\n            resultObj[fn(arr[i])].push(arr[i]);\\n        }else{\\n            resultObj[fn(arr[i])] = [arr[i]]\\n        }\\n\\n    }\\n\\n    return resultObj;\\n\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3989959,
                "title": "typescript-easy-to-understand-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function<T>(fn: (item: T) => string): Record<string, T[]> {\\n    const grouped: Record<string, T[]> = {}\\n\\n    this.forEach((item: T) => {\\n        const key = fn(item);\\n\\n        if(grouped[key]){\\n            grouped[key].push(item)\\n        }else{\\n            grouped[key] = [item]\\n        }\\n    })\\n\\n    return grouped\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function<T>(fn: (item: T) => string): Record<string, T[]> {\\n    const grouped: Record<string, T[]> = {}\\n\\n    this.forEach((item: T) => {\\n        const key = fn(item);\\n\\n        if(grouped[key]){\\n            grouped[key].push(item)\\n        }else{\\n            grouped[key] = [item]\\n        }\\n    })\\n\\n    return grouped\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3987703,
                "title": "a-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let result = {}\\n    for (const value of this){\\n        if (!result[fn(value)]){\\n                     result[fn(value)] = [];\\n        } \\n            result[fn(value)].push(value)\\n    }\\n    return result\\n\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let result = {}\\n    for (const value of this){\\n        if (!result[fn(value)]){\\n                     result[fn(value)] = [];\\n        } \\n            result[fn(value)].push(value)\\n    }\\n    return result\\n\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978337,
                "title": "javascript-grouping-array-elements-using-hasownproperty-in-o-n-time-and-o-n-space",
                "content": "# Intuition\\nThe goal is to implement a `groupBy` method that takes an array and a function as input. The method should group the elements of the array based on the values returned by the function. Since JavaScript doesn\\'t have a built-in `groupBy` method for arrays, extending the Array prototype is an option, although generally not recommended.\\n\\n# Approach\\n1. Extend the Array prototype with a `groupBy` method.\\n2. Inside the method, define an empty object called `groupedObject`.\\n3. Loop through each element of the array using `forEach`.\\n4. Apply the function `fn` to each element to determine the key under which it should be grouped.\\n5. If the key already exists in `groupedObject`, append the element to the existing array. Otherwise, create a new array for the key and add the element.\\n6. Return `groupedObject`.\\n\\n# Complexity\\n- Time complexity: \\\\(O(n)\\\\)\\n  - We iterate through each element of the array exactly once.\\n\\n- Space complexity: \\\\( O(k) \\\\)\\n\\n    - The `groupedObject` stores all the unique keys generated by the function `fn` applied to the array elements. Each unique key will have an associated array of elements. The space complexity is therefore determined by the number of unique keys, \\\\( k \\\\), rather than the number of elements in the array. In the worst-case scenario where all keys are unique, the space complexity would be \\\\( O(k) \\\\).\\n\\n# Code\\n```javascript\\n/**\\n * @param {Function} fn\\n * @return {Object}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const groupedObject = {};\\n\\n    this.forEach((elem) => {\\n        const key = fn(elem);\\n        if (groupedObject.hasOwnProperty(key)) {\\n            groupedObject[key].push(elem);\\n        } else {\\n            groupedObject[key] = [elem];\\n        }\\n    });\\n\\n    return groupedObject;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {Function} fn\\n * @return {Object}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const groupedObject = {};\\n\\n    this.forEach((elem) => {\\n        const key = fn(elem);\\n        if (groupedObject.hasOwnProperty(key)) {\\n            groupedObject[key].push(elem);\\n        } else {\\n            groupedObject[key] = [elem];\\n        }\\n    });\\n\\n    return groupedObject;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976391,
                "title": "clean-typescript-js-solution",
                "content": "\\n# Javascript Solution\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function (fn) {\\n\\n    const result = {}\\n\\n    for (let item of this) {\\n        const key = fn(item)\\n\\n        if (!result[key]) {\\n            result[key] = []\\n        }\\n        \\n        result[key].push(item)\\n    }\\n\\n    return result\\n};\\n\\n/**  \\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```\\n\\n# Typescript Solution\\n```\\nexport { };\\n\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function <T>(fn: (item: T) => string): Record<string, T[]> {\\n    const result: Record<string, T[]> = {}\\n\\n    this.forEach((eachItem: T) => {\\n        const key = fn(eachItem)\\n\\n        if (!result[key]) {\\n            result[key] = []\\n        }\\n        result[key].push(eachItem)\\n    })\\n\\n    return result\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function (fn) {\\n\\n    const result = {}\\n\\n    for (let item of this) {\\n        const key = fn(item)\\n\\n        if (!result[key]) {\\n            result[key] = []\\n        }\\n        \\n        result[key].push(item)\\n    }\\n\\n    return result\\n};\\n\\n/**  \\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```\n```\\nexport { };\\n\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function <T>(fn: (item: T) => string): Record<string, T[]> {\\n    const result: Record<string, T[]> = {}\\n\\n    this.forEach((eachItem: T) => {\\n        const key = fn(eachItem)\\n\\n        if (!result[key]) {\\n            result[key] = []\\n        }\\n        result[key].push(eachItem)\\n    })\\n\\n    return result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951217,
                "title": "using-container-and-for-loop",
                "content": "# Intuition\\nImportant to understand what `this` holds and all the property associated with it. In this case, its an array and it has the `.length` property, so we can use it to loop over `this`\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const container = {};\\n    for(let i = 0; i < this.length; i++){\\n    const val = fn(this[i]);\\n    if(!container[val])container[val] = [];\\n    container[val].push(this[i]);\\n    }\\n    return container;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const container = {};\\n    for(let i = 0; i < this.length; i++){\\n    const val = fn(this[i]);\\n    if(!container[val])container[val] = [];\\n    container[val].push(this[i]);\\n    }\\n    return container;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949722,
                "title": "foreach-with-guard-clause",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let out = {};\\n\\n    this.forEach(elem => {\\n        const key = fn(elem);\\n        if(!Object.hasOwn(out, key)) out[key] = [];\\n        out[key].push(elem);\\n    });\\n\\n    return out;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let out = {};\\n\\n    this.forEach(elem => {\\n        const key = fn(elem);\\n        if(!Object.hasOwn(out, key)) out[key] = [];\\n        out[key].push(elem);\\n    });\\n\\n    return out;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941818,
                "title": "short-solution-js",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const groups = {};\\n\\n    this.forEach(item => {\\n        const key = fn(item);\\n        if (!groups[key]) {\\n            groups[key] = [];\\n        }\\n        groups[key].push(item);\\n    });\\n    return groups;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const groups = {};\\n\\n    this.forEach(item => {\\n        const key = fn(item);\\n        if (!groups[key]) {\\n            groups[key] = [];\\n        }\\n        groups[key].push(item);\\n    });\\n    return groups;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941197,
                "title": "javascript-solution-2631-group-by",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    // console.log(this)\\n    // console.log(fn)\\n    let obj= {}\\n\\n    for(let i=0;i<this.length;i++){\\n        \\n      if(obj[fn(this[i])]){\\n          obj[fn(this[i])].push(this[i])\\n      }else{\\n\\n      obj[fn(this[i])] = [this[i]]\\n      }\\n    }\\n\\n    return obj\\n\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    // console.log(this)\\n    // console.log(fn)\\n    let obj= {}\\n\\n    for(let i=0;i<this.length;i++){\\n        \\n      if(obj[fn(this[i])]){\\n          obj[fn(this[i])].push(this[i])\\n      }else{\\n\\n      obj[fn(this[i])] = [this[i]]\\n      }\\n    }\\n\\n    return obj\\n\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938376,
                "title": "javascript-solution-beats-95-44",
                "content": "\\n```javascript\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const arr = this;\\n    const objResult = {};\\n    arr.forEach(value => {\\n        const key = fn(value);\\n        if (objResult[key])\\n            objResult[key].push(value);\\n        else\\n            objResult[key] = [value];\\n    });\\n    return objResult;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const arr = this;\\n    const objResult = {};\\n    arr.forEach(value => {\\n        const key = fn(value);\\n        if (objResult[key])\\n            objResult[key].push(value);\\n        else\\n            objResult[key] = [value];\\n    });\\n    return objResult;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931676,
                "title": "simple-javascript-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGet the current array and iterate over all of its elements, construct a key for each element and insert the key value pair inside the obj.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` javascript []\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    // this references to current instance of array\\n    const arr = this;\\n    const obj = {};\\n    // iterating over all elements\\n    for (let i=0;i<arr.length;i++) {\\n        const key = fn(arr[i]);\\n        // if value array exists, then use it\\n        // otherwise initialize a new empty array\\n        obj[key] = obj[key] || [];\\n        obj[key].push(arr[i]);\\n    }\\n    return obj;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript []\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    // this references to current instance of array\\n    const arr = this;\\n    const obj = {};\\n    // iterating over all elements\\n    for (let i=0;i<arr.length;i++) {\\n        const key = fn(arr[i]);\\n        // if value array exists, then use it\\n        // otherwise initialize a new empty array\\n        obj[key] = obj[key] || [];\\n        obj[key].push(arr[i]);\\n    }\\n    return obj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923888,
                "title": "typescript-solution",
                "content": "# Code\\n```\\n(Array.prototype as typeof Array[\"prototype\"] & {\\n  groupBy: <T>(fn: (item: T) => string) => Record<string, T[]>;\\n}).groupBy = function (fn) {\\n  const obj = {};\\n  for (const item of this) {\\n    const key = fn(item);\\n    if (!obj[key]) obj[key] = [];\\n    obj[key].push(item);\\n  }\\n  return obj;\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n(Array.prototype as typeof Array[\"prototype\"] & {\\n  groupBy: <T>(fn: (item: T) => string) => Record<string, T[]>;\\n}).groupBy = function (fn) {\\n  const obj = {};\\n  for (const item of this) {\\n    const key = fn(item);\\n    if (!obj[key]) obj[key] = [];\\n    obj[key].push(item);\\n  }\\n  return obj;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3921498,
                "title": "typescript-simple-solution-o-n-o-n",
                "content": "# Complexity\\n- Time complexity: $\\\\mathcal{O}(n)$\\n- Space complexity: $\\\\mathcal{O}(n)$\\n\\n# Code\\n```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function <T>( fn: ( item: T ) => string ): Record<string, T[]> {\\n    const result: Record<string, T[]> = {};\\n    for ( let i = 0; i < this.length; i++ ) {\\n        const key = fn( this[ i ] );\\n        const value = result[ key ] || [];\\n        value.push( this[ i ] );\\n        result[ key ] = value;\\n    }\\n    return result;\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function <T>( fn: ( item: T ) => string ): Record<string, T[]> {\\n    const result: Record<string, T[]> = {};\\n    for ( let i = 0; i < this.length; i++ ) {\\n        const key = fn( this[ i ] );\\n        const value = result[ key ] || [];\\n        value.push( this[ i ] );\\n        result[ key ] = value;\\n    }\\n    return result;\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915878,
                "title": "beats-99-81-simple-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\nWe can use **reduce function**. But for larger arrays, the given solution is more performant than reduce function.\\n\\nPlease **Upvote** if you find helpful.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const grouped = {};\\n    for(let i=0; i < this.length; i++){\\n        let key = fn(this[i]);\\n        if (!grouped[key]) {\\n            grouped[key] = [];\\n        }\\n        grouped[key].push(this[i]);\\n    }\\n    return grouped;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const grouped = {};\\n    for(let i=0; i < this.length; i++){\\n        let key = fn(this[i]);\\n        if (!grouped[key]) {\\n            grouped[key] = [];\\n        }\\n        grouped[key].push(this[i]);\\n    }\\n    return grouped;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914460,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>    \\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let ans={}\\n    for(let i of this){\\n        let id=fn(i)\\n        if(ans[id]){\\n          ans[id].push(i)\\n        }\\n        else{\\n            ans[id]=[i]\\n        }\\n    }\\n    return ans\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let ans={}\\n    for(let i of this){\\n        let id=fn(i)\\n        if(ans[id]){\\n          ans[id].push(i)\\n        }\\n        else{\\n            ans[id]=[i]\\n        }\\n    }\\n    return ans\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3900509,
                "title": "easy-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n\\n    this.forEach(e => {\\n      const key = fn(e);\\n      key in result ? result[key].push(e) : result[key] = [e];\\n    });\\n\\n    return result;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n\\n    this.forEach(e => {\\n      const key = fn(e);\\n      key in result ? result[key].push(e) : result[key] = [e];\\n    });\\n\\n    return result;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3897230,
                "title": "simplest-solution-in-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const obj={}\\n    for(let val of this){\\n    const key = fn(val)\\n    if(key in obj)\\n    obj[key].push(val)\\n    else\\n    obj[key]=[val];\\n    }\\n   return obj\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const obj={}\\n    for(let val of this){\\n    const key = fn(val)\\n    if(key in obj)\\n    obj[key].push(val)\\n    else\\n    obj[key]=[val];\\n    }\\n   return obj\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3893309,
                "title": "array-groupby-enhancement-buit-in-functions",
                "content": "# Intuition\\nWe want to enhance JavaScript arrays by adding a groupBy method that takes a callback function fn and returns a grouped version of the array based on the keys generated by applying fn to each element.\\n\\n# Approach\\nWe can achieve this by iterating through the array, applying the callback function to each element, and building a grouped object where each key is the output of the callback function and the corresponding value is an array of elements with that key. We will maintain the order of elements in the array while creating the grouped object.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the groupBy method is O(n), where n is the number of elements in the array. We iterate through the array once to group the elements.\\n\\n\\n- Space complexity:\\nThe space complexity is O(n), where n is the number of elements in the array. We store the grouped elements in an object, and in the worst case, each element is in a different group, leading to O(n) space usage.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const grouped = {};\\n\\n  this.forEach(item => {\\n    const key = fn(item);\\n    if (grouped[key] === undefined) {\\n      grouped[key] = [];\\n    }\\n    grouped[key].push(item);\\n  });\\n\\n  return grouped;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const grouped = {};\\n\\n  this.forEach(item => {\\n    const key = fn(item);\\n    if (grouped[key] === undefined) {\\n      grouped[key] = [];\\n    }\\n    grouped[key].push(item);\\n  });\\n\\n  return grouped;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3890368,
                "title": "group-by-beats-94-13-users",
                "content": "# Approach\\n- We need to return a object by grouping through its keys that come from the fn output.\\n- So loop through the array and get the value.\\n- If its new key making a new array for that then pushing the value to the key, so that we are grouping\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const group = {}\\n    for(const value of this){\\n        const key = fn(value)\\n        const newKey = !group[key]\\n        if(newKey){\\n            group[key] = []\\n        }\\n        group[key].push(value)\\n    }\\n    return group;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const group = {}\\n    for(const value of this){\\n        const key = fn(value)\\n        const newKey = !group[key]\\n        if(newKey){\\n            group[key] = []\\n        }\\n        group[key].push(value)\\n    }\\n    return group;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3890325,
                "title": "easy-js-solution-with-detailed-description",
                "content": "* We prepare an object to store the results.\\n```\\nler res = {};\\n```\\n* Loop through the original array.\\n```\\nthis.forEach(item => {\\n});\\n```\\n* At each iteration, we run the given function `fn()` with the current element of the source array as an argument and save the result of this function into the temporary variable `key`.\\n```\\nlet key = fn(item);\\n```\\n* We check if our result object contains a field equal to the `key` value we received. If it contains, then we add our current element of the original array to the array of values \\u200B\\u200Bof this field in our `res` object If it does not contain, then we create new field in `res` object in the form of an array and immediately add our next element to this array.\\n```\\nif (res[key]) {        \\n    res[key].push(item);\\n} else {\\n    res[key] = [item];\\n}\\n```\\n* After the loop completes, we return our `res` object, in which the values \\u200B\\u200Bof our original array are now grouped by keys obtained from the `fn()` function.\\n```\\nreturn res;\\n```\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let res = {};\\n    this.forEach(item => {\\n        let key = fn(item);\\n        if (res[key]) {        \\n            res[key].push(item);\\n        } else {\\n            res[key] = [item];\\n        }\\n    })\\n    return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nler res = {};\\n```\n```\\nthis.forEach(item => {\\n});\\n```\n```\\nlet key = fn(item);\\n```\n```\\nif (res[key]) {        \\n    res[key].push(item);\\n} else {\\n    res[key] = [item];\\n}\\n```\n```\\nreturn res;\\n```\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let res = {};\\n    this.forEach(item => {\\n        let key = fn(item);\\n        if (res[key]) {        \\n            res[key].push(item);\\n        } else {\\n            res[key] = [item];\\n        }\\n    })\\n    return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3890022,
                "title": "using-built-in-reduce-method-solution",
                "content": "# Intuition\\nTo loop over the given array, collect the result of the function & add the result of accordingly to an object & return an object. \\n\\n# Approach\\nUsing the reduce method to iterate over the array, and then append the current element (ith element) accordingly to a new object depending on the result of the function.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n\\n    return this.reduce((acc, curr, index) => {\\n        if(acc[fn(curr)]){\\n            acc[fn(curr)].push(curr);\\n        }else{\\n            acc[fn(curr)] = [curr];\\n        }\\n\\n        return acc;\\n    }, {})\\n    \\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n\\n    return this.reduce((acc, curr, index) => {\\n        if(acc[fn(curr)]){\\n            acc[fn(curr)].push(curr);\\n        }else{\\n            acc[fn(curr)] = [curr];\\n        }\\n\\n        return acc;\\n    }, {})\\n    \\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3886540,
                "title": "b-i-n-y-kh-qu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    //ph\\u1EA3i l\\u1EA5y t\\u1EEBng ph\\u1EA7n t\\u1EED  \\u0111\\xE3 \\'.\\' t\\u1EDBi groupBy\\n    return this.reduce((account, item) => {\\n        // key nh\\u1EADn gi\\xE1 tr\\u1ECB khi th\\u1EF1c hi\\u1EC7n fn(item)\\n        const key = fn(item);\\n        // l\\xFAc n\\xE0y acc l\\xE0 chu\\u1ED7i r\\u1ED7ng\\n        if(!account[key]) {\\n            //t\\u1EA1o ra m\\u1EA3ng r\\u1ED7ng\\n            account[key] = [];\\n        }\\n        //push t\\u1EEB ph\\u1EA7n t\\u1EED v\\xE0o acc\\n        account[key].push(item);\\n        return account;\\n    }, {})\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    //ph\\u1EA3i l\\u1EA5y t\\u1EEBng ph\\u1EA7n t\\u1EED  \\u0111\\xE3 \\'.\\' t\\u1EDBi groupBy\\n    return this.reduce((account, item) => {\\n        // key nh\\u1EADn gi\\xE1 tr\\u1ECB khi th\\u1EF1c hi\\u1EC7n fn(item)\\n        const key = fn(item);\\n        // l\\xFAc n\\xE0y acc l\\xE0 chu\\u1ED7i r\\u1ED7ng\\n        if(!account[key]) {\\n            //t\\u1EA1o ra m\\u1EA3ng r\\u1ED7ng\\n            account[key] = [];\\n        }\\n        //push t\\u1EEB ph\\u1EA7n t\\u1EED v\\xE0o acc\\n        account[key].push(item);\\n        return account;\\n    }, {})\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3885357,
                "title": "javascript-straight-forward-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let grouped = {}\\n    for(let key of this){\\n        let modKey = fn(key)\\n        if(!grouped[modKey]) grouped[modKey] = []\\n        grouped[modKey].push(key)\\n    }\\n    return grouped\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let grouped = {}\\n    for(let key of this){\\n        let modKey = fn(key)\\n        if(!grouped[modKey]) grouped[modKey] = []\\n        grouped[modKey].push(key)\\n    }\\n    return grouped\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3884771,
                "title": "easy-solution-beats-90",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let obj = {}\\n\\n    this.forEach(el => {\\n        const key = fn(el)\\n        Array.isArray(obj[key]) ? obj[key].push(el) : obj[key] = [el]\\n    })\\n\\n    return obj\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let obj = {}\\n\\n    this.forEach(el => {\\n        const key = fn(el)\\n        Array.isArray(obj[key]) ? obj[key].push(el) : obj[key] = [el]\\n    })\\n\\n    return obj\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3881686,
                "title": "beginner-friendly-javascript-loop-key-to-new-object",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const ans = {};\\n    for(let i=0;i<this.length;i++){\\n        const key = fn(this[i]);\\n        if(ans[key])\\n            ans[key].push(this[i]);\\n        else{ \\n            ans[key] = []\\n            ans[key].push(this[i]);\\n        }\\n    }\\n    return ans;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Function"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const ans = {};\\n    for(let i=0;i<this.length;i++){\\n        const key = fn(this[i]);\\n        if(ans[key])\\n            ans[key].push(this[i]);\\n        else{ \\n            ans[key] = []\\n            ans[key].push(this[i]);\\n        }\\n    }\\n    return ans;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3881338,
                "title": "beginner-friendly-solution-easy-explanation",
                "content": "\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n   let res={};\\n   for(var x of this){\\n      var key=fn(x);    //get key for every element\\n      if(key in res){  //check if key already exists\\n         res[key].push(x);       //if exists push curr elemet to list\\n      }else{\\n         res[key]=[x];           //if doesnt exist create new list\\n      }\\n   }\\n   return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```\\n# Code Without Comments\\n```\\n\\nArray.prototype.groupBy = function(fn) {\\n   let res={};\\n   for(var x of this){\\n      var key=fn(x);\\n      if(key in res){\\n         res[key].push(x);\\n      }else{\\n         res[key]=[x];\\n      }\\n   }\\n   return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n   let res={};\\n   for(var x of this){\\n      var key=fn(x);    //get key for every element\\n      if(key in res){  //check if key already exists\\n         res[key].push(x);       //if exists push curr elemet to list\\n      }else{\\n         res[key]=[x];           //if doesnt exist create new list\\n      }\\n   }\\n   return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```\n```\\n\\nArray.prototype.groupBy = function(fn) {\\n   let res={};\\n   for(var x of this){\\n      var key=fn(x);\\n      if(key in res){\\n         res[key].push(x);\\n      }else{\\n         res[key]=[x];\\n      }\\n   }\\n   return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879232,
                "title": "120ms-js-for-loop-object-hasown-no-reduce",
                "content": "# Intuition\\nI haven\\'t learned when or how to use `reduce` yet, so I took the the na\\xEFve approach and it turned out to be pretty fast.\\n \\n# Approach\\nLoop through the array, apply `fn` to each entry, initialize the key if it doesn\\'t exist yet, then push the next result.\\n\\nI tested `if (!res[key])` vs `if (!Object.hasOwn(res, key))` and the latter was consistently faster. I don\\'t know why.\\n\\n# Code\\n```\\nArray.prototype.groupBy = function(fn) {\\n    let res = {};\\n    for (let i = 0; i < this.length; i++) {\\n      let key = fn(this[i]);\\n      if (!Object.hasOwn(res, key)) res[key] = [];\\n      res[key].push(this[i]);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.groupBy = function(fn) {\\n    let res = {};\\n    for (let i = 0; i < this.length; i++) {\\n      let key = fn(this[i]);\\n      if (!Object.hasOwn(res, key)) res[key] = [];\\n      res[key].push(this[i]);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3877140,
                "title": "2631-group-by",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let results = {};\\n    this.forEach(element => {\\n        let result = fn(element);\\n        \\n        if (results[result] === undefined)\\n            results[result] = [];\\n        results[result].push(element);\\n    });\\n    return results;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let results = {};\\n    this.forEach(element => {\\n        let result = fn(element);\\n        \\n        if (results[result] === undefined)\\n            results[result] = [];\\n        results[result].push(element);\\n    });\\n    return results;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3862075,
                "title": "logical-js-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse Object to store the key generated by applying function onto each item. Push if exists and new 1 element array if not.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const res = {}\\n    for (let i = 0; i < this.length; i++) {\\n        const item = this[i]\\n        const key = fn(item);\\n        if (res[key]){\\n            res[key].push(item)\\n        } else {\\n            res[key] = [item]\\n        }\\n    }\\n    return res\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const res = {}\\n    for (let i = 0; i < this.length; i++) {\\n        const item = this[i]\\n        const key = fn(item);\\n        if (res[key]){\\n            res[key].push(item)\\n        } else {\\n            res[key] = [item]\\n        }\\n    }\\n    return res\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3856620,
                "title": "power-of-reduce-method",
                "content": "```\\n\\n```/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((acc,curr) => {\\n      let key = fn(curr) ;\\n      if(acc.hasOwnProperty(key)){\\n        acc[key].push(curr)\\n      }else{\\n        acc[key] = [curr]\\n      }\\n\\n      \\n      return acc ;\\n    },{})\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */``",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3856126,
                "title": "javascript-use-foreach-object-without-reduce",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {}\\n    this.forEach((item) => {\\n        let key = fn(item)\\n        result[key] = result[key] ?? []\\n        result[key].push(item)\\n    })\\n    return result\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {}\\n    this.forEach((item) => {\\n        let key = fn(item)\\n        result[key] = result[key] ?? []\\n        result[key].push(item)\\n    })\\n    return result\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3845288,
                "title": "group-by-super-easy",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const group = {};\\n\\n    for(let val of this) {\\n        const key = fn(val);\\n\\n        if(!group[key]) {\\n            group[key] = [];\\n        }\\n\\n        group[key].push(val);\\n    }\\n\\n    return group;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const group = {};\\n\\n    for(let val of this) {\\n        const key = fn(val);\\n\\n        if(!group[key]) {\\n            group[key] = [];\\n        }\\n\\n        group[key].push(val);\\n    }\\n\\n    return group;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3843530,
                "title": "easy-solution-for-everyone-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Object.property to solve this problem\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe fisrt time, I try to use Map(), but time limited. I have tried Object.hasOwn() instead Map.has(), and it work =)))\\n# Complexity\\n- Time complexity: 127ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: 60.22mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const map = {};\\n    this.forEach(val => {\\n        const key = fn(val)\\n        if (Object.hasOwn(map, key)) {\\n            map[key].push(val)\\n        } else {\\n            map[key] = [val]\\n        }\\n    })\\n    // console.log(map)\\n    return map\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const map = {};\\n    this.forEach(val => {\\n        const key = fn(val)\\n        if (Object.hasOwn(map, key)) {\\n            map[key].push(val)\\n        } else {\\n            map[key] = [val]\\n        }\\n    })\\n    // console.log(map)\\n    return map\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3827979,
                "title": "solution-group-by-for-an-array",
                "content": "# Approach\\nFirst we create a new object, where we can store our results.\\nThen we loop through this, since it contains all the values stored in the array. Every time we call also the passed function parameter to get the correct key.\\nNow we just can push the values inside the object with the key as group id and an array containing the values.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n    for (let item of this) {\\n        let id = fn(item);\\n        if (result[id] === undefined) {\\n            result[id] = [];\\n        }\\n        result[id].push(item);\\n    }\\n    return result;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n    for (let item of this) {\\n        let id = fn(item);\\n        if (result[id] === undefined) {\\n            result[id] = [];\\n        }\\n        result[id].push(item);\\n    }\\n    return result;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823868,
                "title": "easy-approach-99-time-93-space",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const map = {};\\n    for (let i=0; i< this.length; i++) {\\n        const res = fn(this[i]);\\n        if (!map[res]?.length) map[res] = [this[i]];\\n        else map[res].push(this[i]);\\n    }\\n    return map;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const map = {};\\n    for (let i=0; i< this.length; i++) {\\n        const res = fn(this[i]);\\n        if (!map[res]?.length) map[res] = [this[i]];\\n        else map[res].push(this[i]);\\n    }\\n    return map;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3818128,
                "title": "typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    let res: Record<string, any[]> = {};\\n    this.forEach(element => {\\n        let key: string = fn(element);\\n        if(!res[key]) res[key] = [];\\n        res[key].push(element);\\n    });\\n    return res;\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    let res: Record<string, any[]> = {};\\n    this.forEach(element => {\\n        let key: string = fn(element);\\n        if(!res[key]) res[key] = [];\\n        res[key].push(element);\\n    });\\n    return res;\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3816132,
                "title": "javascript-time-o-n-space-o-m-solution",
                "content": "# Intuition\\nreturn an object with filtered key value pairs\\n\\n# Approach\\n1. Take a memo object.\\n2. Iterate over array items and assign unique key based on input function and the current item. fn(i)\\n3. Store the current item as an array ( single item array because it is the first item of the array ) in the key in memo object if the key doesn\\'t already exist.\\n4. If it already exists, that means atleast one value is already present in the array as value to the key, so simply push the next item to the same array (value) against the same key.\\n5. Return the memo object.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(m) | m = number of unique keys in memo object\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const memo = {};\\n    this.map(i => {\\n        const key = fn(i);\\n        if (!memo[key]) {\\n            memo[key] = [i];\\n        } else {\\n            memo[key].push(i);\\n        }\\n    });\\n    return memo;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const memo = {};\\n    this.map(i => {\\n        const key = fn(i);\\n        if (!memo[key]) {\\n            memo[key] = [i];\\n        } else {\\n            memo[key].push(i);\\n        }\\n    });\\n    return memo;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3811625,
                "title": "simple-object",
                "content": "# Intuition\\nLoop over each item\\nRun the fn over an item to gen the key\\nSet the key and its value as an array in the object\\nPush the item to the array of the key in the object\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n\\n  const answer = {}\\n\\n  for (let i =0; i< this.length;i++){\\n    const item = this[i];    \\n    const key = fn(item)\\n    answer[key] = answer[key] ?? []\\n    answer[key].push(item)    \\n  }\\n  \\n  return answer\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n\\n  const answer = {}\\n\\n  for (let i =0; i< this.length;i++){\\n    const item = this[i];    \\n    const key = fn(item)\\n    answer[key] = answer[key] ?? []\\n    answer[key].push(item)    \\n  }\\n  \\n  return answer\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3803213,
                "title": "beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let obj ={}\\n    this.forEach(item => (obj.hasOwnProperty(fn(item)))? obj[fn(item)].push(item):obj[fn(item)]=[item])\\n    return obj\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let obj ={}\\n    this.forEach(item => (obj.hasOwnProperty(fn(item)))? obj[fn(item)].push(item):obj[fn(item)]=[item])\\n    return obj\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3783848,
                "title": "array-groupby-solved-using-array-reduce",
                "content": "# Intuition\\nSince we\\'re changing from an Array to an Object, `.reduce` is the goto method. \\n\\n# Approach\\nfirst we loop through each item in the arrray, using `.reduce`, find the Oject \\'key\\' (result of calling the given function).\\n\\nNext we either mutate the existing value and push the new item onto the end, or, we create a new array containing the new item\\n\\nwe do not use spread notation as that slows down most browsers.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  return this.reduce((prev, curr) => {\\n     const key = fn(curr)\\n      if (prev[key]) {\\n        prev[key].push(curr)\\n      } else {\\n        prev[key] = [curr]\\n      }\\n      return prev;\\n  }, {})\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  return this.reduce((prev, curr) => {\\n     const key = fn(curr)\\n      if (prev[key]) {\\n        prev[key].push(curr)\\n      } else {\\n        prev[key] = [curr]\\n      }\\n      return prev;\\n  }, {})\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3781514,
                "title": "clean-and-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n\\n    let res = {}\\n    for (let e of this) {\\n        let key = fn(e)\\n        if (key in res) {\\n            let val = res[key]\\n            val.push(e)\\n            res[key] = val\\n\\n        } else {\\n            res[key] = [e]\\n        }\\n    }\\n\\n    return res\\n    \\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n\\n    let res = {}\\n    for (let e of this) {\\n        let key = fn(e)\\n        if (key in res) {\\n            let val = res[key]\\n            val.push(e)\\n            res[key] = val\\n\\n        } else {\\n            res[key] = [e]\\n        }\\n    }\\n\\n    return res\\n    \\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3772671,
                "title": "easy-solution-hasownproperty-o-n-o-1",
                "content": "\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nArray.prototype.groupBy = function(fn) {\\n    const answer = {};\\n    for(let x of this){\\n        if(answer.hasOwnProperty(fn(x))){\\n            answer[fn(x)].push(x);\\n        }\\n        else answer[fn(x)] = [x];\\n    }\\n    return answer;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.groupBy = function(fn) {\\n    const answer = {};\\n    for(let x of this){\\n        if(answer.hasOwnProperty(fn(x))){\\n            answer[fn(x)].push(x);\\n        }\\n        else answer[fn(x)] = [x];\\n    }\\n    return answer;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3772222,
                "title": "easy-one-does-not-seem-to-fall-in-medium-category",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndeclare global {\\n  interface Array<T> {\\n    groupBy(fn: (item: T) => string): Record<string, T[]>;\\n  }\\n}\\n\\nArray.prototype.groupBy = function (fn) {\\n  const groupedArray = new Map<string, Array<any>>();\\n  this.forEach((element: any, idx: number) => {\\n    const key = fn(element);\\n    if (!groupedArray.has(key.toString())) {\\n      groupedArray.set(key.toString(), [this[idx]]);\\n    } else {\\n      const currentValue = groupedArray.get(key.toString()) || [];\\n      currentValue.push(this[idx]);\\n      groupedArray.set(key.toString(), currentValue);\\n    }\\n  });\\n\\n  return Object.fromEntries(groupedArray);\\n};\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n  interface Array<T> {\\n    groupBy(fn: (item: T) => string): Record<string, T[]>;\\n  }\\n}\\n\\nArray.prototype.groupBy = function (fn) {\\n  const groupedArray = new Map<string, Array<any>>();\\n  this.forEach((element: any, idx: number) => {\\n    const key = fn(element);\\n    if (!groupedArray.has(key.toString())) {\\n      groupedArray.set(key.toString(), [this[idx]]);\\n    } else {\\n      const currentValue = groupedArray.get(key.toString()) || [];\\n      currentValue.push(this[idx]);\\n      groupedArray.set(key.toString(), currentValue);\\n    }\\n  });\\n\\n  return Object.fromEntries(groupedArray);\\n};\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3766941,
                "title": "simple-solution-using-in-build-properties",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n\\n  let obj = {}\\n    this.forEach((el,i)=>{\\n        if(obj.hasOwnProperty(fn(el))){\\n           obj[fn(el)].push(el)\\n        }\\n        else {\\n            obj[fn(el)] = [el]\\n        }\\n    })\\n\\n  return obj  \\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n\\n  let obj = {}\\n    this.forEach((el,i)=>{\\n        if(obj.hasOwnProperty(fn(el))){\\n           obj[fn(el)].push(el)\\n        }\\n        else {\\n            obj[fn(el)] = [el]\\n        }\\n    })\\n\\n  return obj  \\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3763878,
                "title": "explained-solution",
                "content": "# Intuition\\nThe intuition behind solving this problem is to enhance the Array prototype with a groupBy method that groups the elements of the array based on a provided key function. The goal is to create a new object where the keys correspond to the grouping criterion and the values are arrays of elements belonging to that group.\\n\\n\\n\\n# Approach\\nThe approach involves extending the Array prototype with the groupBy method. This method takes a key function as a parameter, which determines how the elements should be grouped. It iterates over the array and applies the key function to each element. Based on the key returned by the function, it adds the element to the corresponding group in a new object (grouped). If the group already exists, the element is appended to the existing array; otherwise, a new array is created for the group. Finally, the grouped object is returned.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the groupBy method is $$O(n)$$, where n is the number of elements in the array. The function iterates over each element of the array once, applying the key function and adding the element to the corresponding group. Therefore, the time complexity scales linearly with the size of the input array.\\n\\n\\n\\n- Space complexity:\\nThe space complexity of the groupBy method is $$O(n)$$, where n is the number of elements in the array. The function creates a new object (grouped) to store the groups, and the size of this object depends on the number of distinct groups in the array. In the worst case, when all elements are unique, the number of groups can be equal to the number of elements in the array. Therefore, the space required by the function scales linearly with the size of the input array.\\n\\n\\n\\n# Code\\n```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function (fn) {\\n    let grouped = {}\\n    for (let i = 0; i < this.length; i++) {\\n        if (grouped[fn(this[i])]) {\\n            grouped[fn(this[i])].push(this[i])\\n        } else {\\n            grouped[fn(this[i])] = [this[i]]\\n        }\\n    }\\n    return grouped\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function (fn) {\\n    let grouped = {}\\n    for (let i = 0; i < this.length; i++) {\\n        if (grouped[fn(this[i])]) {\\n            grouped[fn(this[i])].push(this[i])\\n        } else {\\n            grouped[fn(this[i])] = [this[i]]\\n        }\\n    }\\n    return grouped\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3756572,
                "title": "object-foreach-easy-readable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n    this.forEach(el => {\\n        const key = fn(el);\\n        if(result[key]) {\\n            result[key].push(el);\\n        } else {\\n            result[key] = [el];\\n        }\\n    });\\n\\n    return result;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n    this.forEach(el => {\\n        const key = fn(el);\\n        if(result[key]) {\\n            result[key].push(el);\\n        } else {\\n            result[key] = [el];\\n        }\\n    });\\n\\n    return result;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3752010,
                "title": "using-reduce",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  \\n   const reducer=(acu, current)=>{\\n       let key=fn(current)\\n       if(!acu[key]){\\n           acu[key]=[]\\n       }\\n       acu[key].push(current)\\n\\n       return acu\\n   }\\n   const result=this.reduce(reducer,{})\\n\\n   return result\\n\\n}\\n    \\n",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  \\n   const reducer=(acu, current)=>{\\n       let key=fn(current)\\n       if(!acu[key]){\\n           acu[key]=[]\\n       }\\n       acu[key].push(current)\\n\\n       return acu\\n   }\\n   const result=this.reduce(reducer,{})\\n\\n   return result\\n\\n}\\n    \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3741072,
                "title": "easy-solution-using-hashmaps",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let map = {}\\n    for (let item of this) {\\n        const groupByCriteria = fn(item)\\n        if (map[groupByCriteria]) {\\n            map[groupByCriteria].push(item)\\n        } else {\\n            map[groupByCriteria] = [item]\\n        }\\n    }\\n    return map\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let map = {}\\n    for (let item of this) {\\n        const groupByCriteria = fn(item)\\n        if (map[groupByCriteria]) {\\n            map[groupByCriteria].push(item)\\n        } else {\\n            map[groupByCriteria] = [item]\\n        }\\n    }\\n    return map\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */",
                "codeTag": "Unknown"
            },
            {
                "id": 3740972,
                "title": "hasownproperty-returns-true-if-the-object-has-the-specified-property-as-own-property",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const temp=this;\\n    const op={};\\n    for(let i=0;i<temp.length;i++){\\n        if(op.hasOwnProperty(fn(temp[i])))\\n        {\\n            const old=op[fn(temp[i])];\\n            old.push(temp[i]);\\n            op[fn(temp[i])]=old;\\n        }\\n        else\\n        op[fn(temp[i])]=[temp[i]];\\n    }   \\n    return op;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const temp=this;\\n    const op={};\\n    for(let i=0;i<temp.length;i++){\\n        if(op.hasOwnProperty(fn(temp[i])))\\n        {\\n            const old=op[fn(temp[i])];\\n            old.push(temp[i]);\\n            op[fn(temp[i])]=old;\\n        }\\n        else\\n        op[fn(temp[i])]=[temp[i]];\\n    }   \\n    return op;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3720977,
                "title": "js-easy-solution-use-for-of-this-push",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let result = {}\\n    for (const object of this){\\n        const key = fn(object)\\n        result[key] = result[key] || []\\n        result[key].push(object)\\n    }\\n    return result\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let result = {}\\n    for (const object of this){\\n        const key = fn(object)\\n        result[key] = result[key] || []\\n        result[key].push(object)\\n    }\\n    return result\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3712403,
                "title": "group-by-polyfill",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let arr = this;\\n    console.log(\"arr: \", arr);\\n    let ans = {};\\n    arr.forEach((it, idx) => {\\n        let key = fn(it);\\n        if(!ans.hasOwnProperty(key)){\\n            ans[key] = [];\\n            ans[key].push(it)\\n        } else{\\n            ans[key].push(it)\\n        }\\n    })\\n    console.log(ans);\\n    return ans;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let arr = this;\\n    console.log(\"arr: \", arr);\\n    let ans = {};\\n    arr.forEach((it, idx) => {\\n        let key = fn(it);\\n        if(!ans.hasOwnProperty(key)){\\n            ans[key] = [];\\n            ans[key].push(it)\\n        } else{\\n            ans[key].push(it)\\n        }\\n    })\\n    console.log(ans);\\n    return ans;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3694730,
                "title": "ts-straightforward-solution-o-n",
                "content": "# Code\\n```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    const res = {};\\n\\n    for (const cur of this) {\\n      const val = fn(cur);\\n\\n      if (!res[val])\\n        res[val] = [];\\n\\n      res[val].push(cur);\\n    }\\n\\n    return res;\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    const res = {};\\n\\n    for (const cur of this) {\\n      const val = fn(cur);\\n\\n      if (!res[val])\\n        res[val] = [];\\n\\n      res[val].push(cur);\\n    }\\n\\n    return res;\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3674886,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\nArray.prototype.groupBy = function(fn) {\\n    const group = {};\\n    this.forEach(item => {\\n        const key = fn(item);\\n        if (!group.hasOwnProperty(key)) group[key] = [];\\n        group[key].push(item);\\n    });\\n    return group;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.groupBy = function(fn) {\\n    const group = {};\\n    this.forEach(item => {\\n        const key = fn(item);\\n        if (!group.hasOwnProperty(key)) group[key] = [];\\n        group[key].push(item);\\n    });\\n    return group;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3660240,
                "title": "simple-loop-and-group-method",
                "content": "# Intuition\\nWe need to group the items into buckets. Which is essentially a map with keys derived from the callback function to `groupBy` and the value as a list of items which can derive those keys.\\n\\n# Approach\\nFirst approach was to use `Array.prototype.reduce` directly as it is a very good and concise way of doing it. \\n\\nAnother approach is to run a `while` loop, which will keep track of a `count` until the value is equal to the length of the array.\\n\\nThe simplest and quickest approach is a `for` loop. It is pretty straight forward and gives us the desired result in the least amount of time.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Object}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {}\\n    for(const item of this) {\\n        const key = fn(item)\\n        if(result[key]) {\\n            result[key].push(item)\\n        } else {\\n            result[key] = [item]\\n        }\\n    }\\n\\n    return result;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\nWe need to group the items into buckets. Which is essentially a map with keys derived from the callback function to `groupBy` and the value as a list of items which can derive those keys.\\n\\n# Approach\\nFirst approach was to use `Array.prototype.reduce` directly as it is a very good and concise way of doing it. \\n\\nAnother approach is to run a `while` loop, which will keep track of a `count` until the value is equal to the length of the array.\\n\\nThe simplest and quickest approach is a `for` loop. It is pretty straight forward and gives us the desired result in the least amount of time.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Object}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {}\\n    for(const item of this) {\\n        const key = fn(item)\\n        if(result[key]) {\\n            result[key].push(item)\\n        } else {\\n            result[key] = [item]\\n        }\\n    }\\n\\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3659793,
                "title": "easy-javascript",
                "content": "\\n\\n# Code\\n```\\n\\nArray.prototype.groupBy = function(fn) {\\n\\n    let obj = {};\\n\\n    for(let val of this){\\n        \\n        let elem = fn(val);\\n        if(obj[elem] === undefined) obj[elem] = [];\\n        obj[elem].push(val);\\n        \\n    }\\n\\n    return obj;\\n    \\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nArray.prototype.groupBy = function(fn) {\\n\\n    let obj = {};\\n\\n    for(let val of this){\\n        \\n        let elem = fn(val);\\n        if(obj[elem] === undefined) obj[elem] = [];\\n        obj[elem].push(val);\\n        \\n    }\\n\\n    return obj;\\n    \\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3643444,
                "title": "js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function (fn) {\\n  let obj = {};\\n\\n  for (let i = 0; i < this.length; i++) {\\n    const key = fn(this[i]);\\n    if (key in obj) {\\n      obj[key].push(this[i]);\\n    } else {\\n        obj[key] = [this[i]];\\n    }\\n  }\\n\\n  return obj;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function (fn) {\\n  let obj = {};\\n\\n  for (let i = 0; i < this.length; i++) {\\n    const key = fn(this[i]);\\n    if (key in obj) {\\n      obj[key].push(this[i]);\\n    } else {\\n        obj[key] = [this[i]];\\n    }\\n  }\\n\\n  return obj;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3633699,
                "title": "js-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    \\n    return this.reduce((res, cur) => {\\n        const item = fn(cur);\\n        const curArr = res[item] || [];\\n        curArr.push(cur);\\n        res[item] = curArr;\\n        return res;\\n    },{})\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    \\n    return this.reduce((res, cur) => {\\n        const item = fn(cur);\\n        const curArr = res[item] || [];\\n        curArr.push(cur);\\n        res[item] = curArr;\\n        return res;\\n    },{})\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3618200,
                "title": "4-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n\\n    const grp = {};\\n\\n    for(const val of this){\\n        const key = fn(val);\\n        grp.hasOwnProperty(key) ? grp[key].push(val) :grp[key] = [val];\\n    }\\n    return grp;\\n\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n\\n    const grp = {};\\n\\n    for(const val of this){\\n        const key = fn(val);\\n        grp.hasOwnProperty(key) ? grp[key].push(val) :grp[key] = [val];\\n    }\\n    return grp;\\n\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3603929,
                "title": "simple-js-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    var opObj = {};\\n    for(let index = 0 ; index < this.length ; index++){\\n        let key = fn(this[index]);\\n        if(opObj[key]){\\n            opObj[key].push(this[index]);\\n        }else{\\n            opObj[key] = [this[index]];\\n        }\\n    }\\n    return opObj;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    var opObj = {};\\n    for(let index = 0 ; index < this.length ; index++){\\n        let key = fn(this[index]);\\n        if(opObj[key]){\\n            opObj[key].push(this[index]);\\n        }else{\\n            opObj[key] = [this[index]];\\n        }\\n    }\\n    return opObj;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3601986,
                "title": "js-solution-with-simple-hash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved by using a js object as hash map.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe iterate through each element of the array. We call `fn` for each element and check if our hash already contains the result as key. If not, we add a key and put the element on it. \\nSo, our hash will look something like: { `result`: item1, item2... }\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function (fn) {\\n  let hash = {};\\n  for (let i = 0; i < this.length; i++) {\\n    let res = fn(this[i]);\\n    if (res in hash) {\\n      hash[res].push(this[i]);\\n    } else {\\n      hash[res] = [this[i]];\\n    }\\n  }\\n  return hash;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function (fn) {\\n  let hash = {};\\n  for (let i = 0; i < this.length; i++) {\\n    let res = fn(this[i]);\\n    if (res in hash) {\\n      hash[res].push(this[i]);\\n    } else {\\n      hash[res] = [this[i]];\\n    }\\n  }\\n  return hash;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595745,
                "title": "js-easy-solution-with-explanation-beats-99-47",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code extends the functionality of the `Array` prototype by adding a new method `groupBy`. This method groups the elements of an array based on a provided `fn` function. The goal is to group the elements of the array into separate arrays based on the result of applying the `fn` function to each element.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define the `groupBy` method on the `Array` prototype. This allows the method to be called on any array object.\\n2. Inside the `groupBy` method, use the `reduce()` method on the array (`this`) to iterate through each element and build an object that groups the elements based on the result of applying the `fn` function to each element.\\n    * Initialize the accumulator `acc` as an empty object.\\n    * For each `curr` element in the array:\\n        * Apply the `fn` function to `curr` and use the result as the key for grouping.\\n        * Check if there is already an array stored in `acc` at the corresponding key.\\n            * If there is, push `curr` into the array.\\n            * If there isn\\'t, create a new array with `curr` as the first element and store it in `acc` at the corresponding key.\\n    * Return the final `acc` object that contains the grouped arrays.\\n3. Return the `acc` object.\\n# Complexity\\n- Time complexity: O(n), where n is the length of the array. The code uses the reduce() method to iterate through each element of the array, which takes O(n) time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n), where n is the length of the array. The code creates an object acc that stores the grouped arrays. In the worst case, when all elements in the array have unique results after applying the fn function, acc will have a length of n.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((acc, curr)=>{\\n        let arr = acc[fn(curr)];\\n        if(arr){\\n            acc[fn(curr)].push(curr)\\n        } else{\\n            acc[fn(curr)] = [curr];\\n        }\\n        return acc;\\n    },{})\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((acc, curr)=>{\\n        let arr = acc[fn(curr)];\\n        if(arr){\\n            acc[fn(curr)].push(curr)\\n        } else{\\n            acc[fn(curr)] = [curr];\\n        }\\n        return acc;\\n    },{})\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594416,
                "title": "iterative-easy-day-24",
                "content": "# Intuition\\nThe groupBy method takes a callback function (fn) as a parameter and groups the elements of the array based on the values returned by the callback function. It returns an object where the keys represent the grouped values, and the values are arrays containing the original elements associated with each key.\\n\\n# Approach\\n1. Define a new method called groupBy on the Array.prototype. This allows all array instances to access this method.\\n2. Inside the method, create an empty object res to store the grouped elements.\\n3. this is current object (the current array instance) .\\n4. Iterate over each element in the array instance (array) using forEach.\\n5. For each element, call the provided callback function fn with the current element as an argument to determine the grouping key.\\n6. Check if the grouping key already exists in the map object using the in operator. If the key doesn\\'t exist, create an empty array as the value for that key.\\n7. Push the current element into the array associated with the corresponding grouping key in the map object.\\n8. After iterating over all elements, the res object will contain the grouped elements.\\n9. Return the res object.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const res = {};\\n    this.forEach(elem =>{\\n      let key = fn(elem)\\n      if(key in res) {\\n        res[key].push(elem)\\n      }else res[key] = [elem]\\n    })\\n\\n    return res\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const res = {};\\n    this.forEach(elem =>{\\n      let key = fn(elem)\\n      if(key in res) {\\n        res[key].push(elem)\\n      }else res[key] = [elem]\\n    })\\n\\n    return res\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593777,
                "title": "straightforward-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    const grouped = {};\\n    this.forEach((elem)=>{\\n        const id = fn(elem)\\n        grouped[id] ??= []\\n        grouped[id].push(elem);\\n    })\\n    return grouped;\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    const grouped = {};\\n    this.forEach((elem)=>{\\n        const id = fn(elem)\\n        grouped[id] ??= []\\n        grouped[id].push(elem);\\n    })\\n    return grouped;\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590452,
                "title": "easiest-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const res={}\\n    for(let i=0;i<this.length;i++){\\n        const g=fn(this[i]);\\n        if(res[g]==undefined) res[g]=[];\\n        res[g].push(this[i]);\\n    }\\n    return res;\\n    \\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const res={}\\n    for(let i=0;i<this.length;i++){\\n        const g=fn(this[i]);\\n        if(res[g]==undefined) res[g]=[];\\n        res[g].push(this[i]);\\n    }\\n    return res;\\n    \\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590193,
                "title": "javascript-good-enough",
                "content": "``` JavaScript []\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    final = {};\\n\\n    for(const x of this){\\n        final[fn(x)] = final[fn(x)] || [];\\n        final[fn(x)].push(x);\\n    }\\n\\n    return final;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` JavaScript []\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    final = {};\\n\\n    for(const x of this){\\n        final[fn(x)] = final[fn(x)] || [];\\n        final[fn(x)].push(x);\\n    }\\n\\n    return final;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588729,
                "title": "day-24-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  const res = {};\\n    \\n  for (let i = 0; i < this.length; ++i) {\\n    const key = fn(this[i]);\\n    if (!(key in res)) {\\n      res[key] = [];\\n    }\\n    res[key].push(this[i]);\\n  }\\n    \\n  return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  const res = {};\\n    \\n  for (let i = 0; i < this.length; ++i) {\\n    const key = fn(this[i]);\\n    if (!(key in res)) {\\n      res[key] = [];\\n    }\\n    res[key].push(this[i]);\\n  }\\n    \\n  return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587797,
                "title": "reduce-soliution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nrun N time depends on array length\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\ngroupBy result create N lengh array\\n\\n# Code\\n```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function<T>(fn: (item: T) => string) {\\n    return this.reduce((acc, item) => {\\n        const key = fn(item)\\n        acc[key] ||= []\\n        acc[key].push(item)\\n        return acc\\n    }, {}) as Record<string, T>\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function<T>(fn: (item: T) => string) {\\n    return this.reduce((acc, item) => {\\n        const key = fn(item)\\n        acc[key] ||= []\\n        acc[key].push(item)\\n        return acc\\n    }, {}) as Record<string, T>\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586635,
                "title": "beats-84-js-ts-this-group-by-easy-solution-with-explanation",
                "content": "![image.png](https://assets.leetcode.com/users/images/d2575b22-e508-4748-be03-0b64d85df54a_1685636245.8199844.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI tried to follow the hints in order to come up to my solution as at the beginning it seemed a bit hard to me. My goal was to solve this with a `for` loop as I eventually did, however I also tried out using built-in object methods like `hasOwnProperty` which facilitated the process.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Declare the answer object called `obj` and leave it empty for now.\\n- Start a `for` loop with `i` running until `this.length` (it\\'s the array\\'s length) and incremented by `1` at every loop.\\n    - Declare the `key` variable, which is always assigned to the result of the `fn` parameter which we use in the `groupBy` method. As a parameter it will have the current element of the array (`this[i]`).\\n    - If `obj` has `key` as a property then we push the current element of the array to the `key` property of `obj` (`obj[key]`). \\n    - Otherwise we initialise `obj[key]` and assign it to `this[i]`, which is as we explained the current element of our array.\\n- After the end of the loop return `obj`. \\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n`JavaScript`\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let obj = {};\\n\\n    for(let i=0; i<this.length; i++) {\\n        const key = fn(this[i]);\\n        if(obj.hasOwnProperty(key)) {\\n            obj[key].push(this[i]);\\n        } else {\\n            obj[key] = [this[i]];\\n        }\\n    }\\n\\n    return obj;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```\\n`TypeScript`\\n```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    let obj = {};\\n\\n    for(let i=0; i<this.length; i++) {\\n        const key = fn(this[i]);\\n        if(obj.hasOwnProperty(key)) {\\n            obj[key].push(this[i]);\\n        } else {\\n            obj[key] = [this[i]];\\n        }\\n    }\\n\\n    return obj;\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```\\n\\n# Feedback\\nI would appreciate your feedback and would like to receive your comments and perspectives regarding my approach. I would also enjoy suggestions about how to hone my DSA skills because I am very new to this sector and it\\'s challenging at first. Thanks a lot!",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let obj = {};\\n\\n    for(let i=0; i<this.length; i++) {\\n        const key = fn(this[i]);\\n        if(obj.hasOwnProperty(key)) {\\n            obj[key].push(this[i]);\\n        } else {\\n            obj[key] = [this[i]];\\n        }\\n    }\\n\\n    return obj;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```\n```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    let obj = {};\\n\\n    for(let i=0; i<this.length; i++) {\\n        const key = fn(this[i]);\\n        if(obj.hasOwnProperty(key)) {\\n            obj[key].push(this[i]);\\n        } else {\\n            obj[key] = [this[i]];\\n        }\\n    }\\n\\n    return obj;\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586629,
                "title": "easy-js-solution",
                "content": "\\n# Code\\n```\\nArray.prototype.groupBy = function(fn) {\\n  const returnObject = {};\\n  for (const item of this) {\\n    const key = fn(item);\\n    if (key in returnObject) {\\n      returnObject[key].push(item);\\n    } else {\\n      returnObject[key] = [item];\\n    }\\n  }\\n  return returnObject;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.groupBy = function(fn) {\\n  const returnObject = {};\\n  for (const item of this) {\\n    const key = fn(item);\\n    if (key in returnObject) {\\n      returnObject[key].push(item);\\n    } else {\\n      returnObject[key] = [item];\\n    }\\n  }\\n  return returnObject;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585669,
                "title": "this-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let set ={};\\n    for (i=0; i<this.length; i++) {\\n        if (!set[fn(this[i])]) {\\n           set[fn(this[i])] = [] \\n        }\\n        set[fn(this[i])].push(this[i])\\n    }\\n    return set;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let set ={};\\n    for (i=0; i<this.length; i++) {\\n        if (!set[fn(this[i])]) {\\n           set[fn(this[i])] = [] \\n        }\\n        set[fn(this[i])].push(this[i])\\n    }\\n    return set;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585665,
                "title": "this-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let set ={};\\n    for (i=0; i<this.length; i++) {\\n        if (!set[fn(this[i])]) {\\n           set[fn(this[i])] = [] \\n        }\\n        set[fn(this[i])].push(this[i])\\n    }\\n    return set;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let set ={};\\n    for (i=0; i<this.length; i++) {\\n        if (!set[fn(this[i])]) {\\n           set[fn(this[i])] = [] \\n        }\\n        set[fn(this[i])].push(this[i])\\n    }\\n    return set;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585633,
                "title": "javascript-simple-javascript-typescript-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 131 ms, faster than 94.00% of JavaScript online submissions for Group By.\\n# Memory Usage: 60.5 MB, less than 93.68% of JavaScript online submissions for Group By.\\n\\n\\tArray.prototype.groupBy = function(fn) {\\n\\n\\t\\tconst result = {};\\n\\n\\t\\tfor(let item of this)\\n\\t\\t{\\n\\t\\t\\tconst key = fn(item);\\n\\n\\t\\t\\tif(key in result)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult[key].push(item);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tresult[key] = [item];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\n\\t};\\n\\t\\n# Approach 2 Using Typescript :\\n# Runtime: 157 ms, faster than 94.00% of JavaScript online submissions for Group By.\\n# Memory Usage: 64.3 MB, less than 93.68% of JavaScript online submissions for Group By.\\n\\n\\tdeclare global {\\n\\t\\tinterface Array<T> {\\n\\t\\t\\tgroupBy(fn: (item: T) => string): Record<string, T[]>\\n\\t\\t}\\n\\t}\\n\\n\\tArray.prototype.groupBy = function(fn) {\\n\\n\\t\\tconst result = {};\\n\\n\\t\\tfor(let item of this)\\n\\t\\t{\\n\\t\\t\\tconst key = fn(item);\\n\\n\\t\\t\\tif(key in result)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult[key].push(item);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tresult[key] = [item];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 131 ms, faster than 94.00% of JavaScript online submissions for Group By.\\n# Memory Usage: 60.5 MB, less than 93.68% of JavaScript online submissions for Group By.\\n\\n\\tArray.prototype.groupBy = function(fn) {\\n\\n\\t\\tconst result = {};\\n\\n\\t\\tfor(let item of this)\\n\\t\\t{\\n\\t\\t\\tconst key = fn(item);\\n\\n\\t\\t\\tif(key in result)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult[key].push(item);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tresult[key] = [item];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\n\\t};\\n\\t\\n# Approach 2 Using Typescript :\\n# Runtime: 157 ms, faster than 94.00% of JavaScript online submissions for Group By.\\n# Memory Usage: 64.3 MB, less than 93.68% of JavaScript online submissions for Group By.\\n\\n\\tdeclare global {\\n\\t\\tinterface Array<T> {\\n\\t\\t\\tgroupBy(fn: (item: T) => string): Record<string, T[]>\\n\\t\\t}\\n\\t}\\n\\n\\tArray.prototype.groupBy = function(fn) {\\n\\n\\t\\tconst result = {};\\n\\n\\t\\tfor(let item of this)\\n\\t\\t{\\n\\t\\t\\tconst key = fn(item);\\n\\n\\t\\t\\tif(key in result)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult[key].push(item);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tresult[key] = [item];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3579962,
                "title": "simple-javascript-groupby-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const res = {};\\n    this.forEach(el=>{\\n        const temp = fn(el);\\n        if(temp in res){\\n            res[temp].push(el);\\n        }else{\\n            res[temp] = [el]\\n        };\\n    })\\n\\n    return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const res = {};\\n    this.forEach(el=>{\\n        const temp = fn(el);\\n        if(temp in res){\\n            res[temp].push(el);\\n        }else{\\n            res[temp] = [el]\\n        };\\n    })\\n\\n    return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3579950,
                "title": "javascript-easy-to-understand-straight-forward-solution",
                "content": "# Code\\n```\\nArray.prototype.groupBy = function(fn) {\\n        let output = {};\\n        for (const item of this) {\\n            let key = fn(item);\\n            if (key in output)\\n                output[key].push(item)\\n            else \\n                output[key] = [item]\\n        }\\n        return output;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "# Code\\n```\\nArray.prototype.groupBy = function(fn) {\\n        let output = {};\\n        for (const item of this) {\\n            let key = fn(item);\\n            if (key in output)\\n                output[key].push(item)\\n            else \\n                output[key] = [item]\\n        }\\n        return output;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3578975,
                "title": "using-foreach-method",
                "content": "\\n```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    let result = {};\\n    if(this.length){\\n        this.forEach(item => {\\n            const key = fn(item);\\n            if(result[key]){\\n                result[key].push(item);\\n            }else{\\n                result[key] = [item]\\n            }\\n        })\\n\\n    }\\n    return result;\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    let result = {};\\n    if(this.length){\\n        this.forEach(item => {\\n            const key = fn(item);\\n            if(result[key]){\\n                result[key].push(item);\\n            }else{\\n                result[key] = [item]\\n            }\\n        })\\n\\n    }\\n    return result;\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3577978,
                "title": "javascript-easy-to-understand-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const res = {}\\n    for (const o of this) {\\n        const key = fn(o)\\n        if (key in res) {\\n            res[key].push(o)\\n        } else {\\n            res[key] = [o]\\n        }\\n    } \\n    \\n    return res\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */   \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const res = {}\\n    for (const o of this) {\\n        const key = fn(o)\\n        if (key in res) {\\n            res[key].push(o)\\n        } else {\\n            res[key] = [o]\\n        }\\n    } \\n    \\n    return res\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3576311,
                "title": "simple-elegant-solution-typescript-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe `groupBy` method takes a callback function (`cb`) as a parameter and groups the elements of the array based on the values returned by the callback function. It returns an object where the keys represent the grouped values, and the values are arrays containing the original elements associated with each key.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define a new method called `groupBy` on the `Array.prototype`. This allows all array instances to access this method.\\n2. Inside the method, create an empty object `map` to store the grouped elements.\\n3. Assign `this` (the current array instance) to a variable for easy reference.\\n4. Iterate over each element in the array.\\n5. For each element, call the provided callback function `cb` with the current element as an argument to determine the grouping key.\\n6. Check if the grouping key already exists in the `map` object using the `in` operator. If the key doesn\\'t exist, create an empty array as the value for that key.\\n7. Push the current element into the array associated with the corresponding grouping key in the `map` object.\\n8. Repeat steps 5-7 for all elements in the array.\\n9. After iterating over all elements, the `map` object will contain the grouped elements.\\n10. Return the `map` object.\\n\\n# Code\\n``` javascript []\\n/**\\n * @param {Function} cb\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(cb) {\\n    let map = {};\\n    let arr = this;\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        const key = cb(arr[i]);\\n        if(!(key in map)) {\\n            map[key] = [];\\n        }\\n\\n        map[key].push(arr[i]);\\n    }\\n\\n    return map;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```\\n``` typescript []\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(cb: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function<T>(cb: (item: T) => string): Record<string, T[]> {\\n    let map: Record<string, T[]> = {};\\n    let arr = this;\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        const key = cb(arr[i]);\\n        if(!(key in map)) {\\n            map[key] = [];\\n        }\\n\\n        map[key].push(arr[i]);\\n    }\\n\\n    return map;\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "``` javascript []\\n/**\\n * @param {Function} cb\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(cb) {\\n    let map = {};\\n    let arr = this;\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        const key = cb(arr[i]);\\n        if(!(key in map)) {\\n            map[key] = [];\\n        }\\n\\n        map[key].push(arr[i]);\\n    }\\n\\n    return map;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```\n``` typescript []\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(cb: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function<T>(cb: (item: T) => string): Record<string, T[]> {\\n    let map: Record<string, T[]> = {};\\n    let arr = this;\\n\\n    for(let i = 0; i < arr.length; i++) {\\n        const key = cb(arr[i]);\\n        if(!(key in map)) {\\n            map[key] = [];\\n        }\\n\\n        map[key].push(arr[i]);\\n    }\\n\\n    return map;\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3576149,
                "title": "js-iteration-time-130ms-90-space-61mb-63",
                "content": "# Approach\\nIterate through the array, apply the function to find the key, and add the element to the appropriate key\\n\\n# Complexity\\n- Time complexity:\\nO(n) *, where n is the length of the array*\\n\\n- Space complexity:\\nO(n) *, where n is the length of the array*\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let out = {};\\n    for (const elem of this) {\\n        let key = fn(elem);\\n        if (key in out) out[key].push(elem);\\n        else out[key] = [elem];\\n    }\\n    return out;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let out = {};\\n    for (const elem of this) {\\n        let key = fn(elem);\\n        if (key in out) out[key].push(elem);\\n        else out[key] = [elem];\\n    }\\n    return out;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3575161,
                "title": "solution-that-beats-97-58-by-runtime-and-84-46-by-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProblem is pretty simple, despite it is the medium\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDescription is not quite good, because we need return not an array, but an object with the keys by which values groupedBy.\\nSo what we need it is just to go through the values and associate it with the keys of our result object. The most tricky place is that this in our funtcion will refer to our array itself\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n) * O(f(n))$$\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const grp = {};\\n\\n    for (let i = 0; i < this.length; i++) {\\n        let key = fn(this[i]);\\n        if (grp.hasOwnProperty(key)) {\\n            grp[key].push(this[i]);\\n        } else {\\n            grp[key] = [this[i]];\\n        }\\n    }\\n    return grp;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const grp = {};\\n\\n    for (let i = 0; i < this.length; i++) {\\n        let key = fn(this[i]);\\n        if (grp.hasOwnProperty(key)) {\\n            grp[key].push(this[i]);\\n        } else {\\n            grp[key] = [this[i]];\\n        }\\n    }\\n    return grp;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3574900,
                "title": "easy-solution-11-lines-of-code",
                "content": "# Approach\\nFirst we initialize `grouped` and assign it an empty object - this will hold the grouped array. To get the key for our `grouped` object, we run the callback function `fn` for every item in the array that our `groupBy()` method was called on. If the key doesn\\'t exist - or in other words, it returns `undefined` - we create an array as the value for that key that holds the item we are currently looping over. In all other cases, we know that we already have an array as the value for the current key, so we can simply push the item to it. At the end, we return the `grouped` object.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const grouped = {}\\n    this.forEach(item => {\\n        const key = fn(item)\\n        if(grouped[key] === undefined) {\\n            grouped[key] = [item]\\n        } else {\\n            grouped[key].push(item)\\n        }\\n    })    \\n    return grouped\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const grouped = {}\\n    this.forEach(item => {\\n        const key = fn(item)\\n        if(grouped[key] === undefined) {\\n            grouped[key] = [item]\\n        } else {\\n            grouped[key].push(item)\\n        }\\n    })    \\n    return grouped\\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3574626,
                "title": "using-reduce",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function (fn) {\\n  return this.reduce((acc, v) => {\\n    acc[fn(v)] ? acc[fn(v)].push(v) : acc[fn(v)] = [v];\\n    return acc\\n  }\\n    , {})\\n} \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function (fn) {\\n  return this.reduce((acc, v) => {\\n    acc[fn(v)] ? acc[fn(v)].push(v) : acc[fn(v)] = [v];\\n    return acc\\n  }\\n    , {})\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3574180,
                "title": "simple-with-for-loop",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n    for (let i = 0; i < this.length; i++) {\\n        const key = fn(this[i]);\\n        if (!result[key]) result[key] = [];\\n        result[key].push(this[i]);\\n    }\\n    return result;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n    for (let i = 0; i < this.length; i++) {\\n        const key = fn(this[i]);\\n        if (!result[key]) result[key] = [];\\n        result[key].push(this[i]);\\n    }\\n    return result;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3573547,
                "title": "easy-solution-2631-day-24",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to group the items in the array based on a key obtained from a provided callback function. To achieve this, we can iterate over the array and use an object to store the groups. For each item, we determine its key using the callback function and add it to the corresponding **group** in the object. Finally, we return the resulting **group** object.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Initialize an empty object called **group** to store the groups.\\n* Iterate over each item in the array.\\n* For each item, use the provided callback function to obtain the key.\\n* Check if the key already exists as a property in the **group** object.\\n* * If it doesn\\'t exist, create a new property with the key in the **group** object and set its value as an empty array.\\n* * This ensures that each key has an associated array to store the items\\n* Push the current item into the array corresponding to the key in the\\n**group** object.\\n* After iterating over all the items, the **group** object will contain the groups.\\n* Return the **group** object as the **group** version of the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```javascript []\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\n\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((group, item) => {\\n        const key = fn(item)\\n\\n        if(!(key in group)){\\n            group[key] =  []\\n        }\\n        group[key].push(item)\\n\\n        return group\\n    },{})\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```\\n```typescript []\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((group, item) => {\\n        const key = fn(item)\\n\\n        if(!(key in group)){\\n            group[key] = []\\n        }\\n        group[key].push(item);\\n        return group;\\n    }, {})\\n    \\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```\\n```ruby []\\nputs \\'Hello world!\\'\\n```\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\n\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((group, item) => {\\n        const key = fn(item)\\n\\n        if(!(key in group)){\\n            group[key] =  []\\n        }\\n        group[key].push(item)\\n\\n        return group\\n    },{})\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```\n```typescript []\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((group, item) => {\\n        const key = fn(item)\\n\\n        if(!(key in group)){\\n            group[key] = []\\n        }\\n        group[key].push(item);\\n        return group;\\n    }, {})\\n    \\n}\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```\n```ruby []\\nputs \\'Hello world!\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572759,
                "title": "reduce",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((prev, ele)=> {\\n        const key = fn(ele)\\n        if(!prev[key]) {\\n            prev[key] = [ele]\\n        } else {\\n            prev[key].push(ele)\\n        }\\n        return prev;\\n    }, {})\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((prev, ele)=> {\\n        const key = fn(ele)\\n        if(!prev[key]) {\\n            prev[key] = [ele]\\n        } else {\\n            prev[key].push(ele)\\n        }\\n        return prev;\\n    }, {})\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572758,
                "title": "easy-soln-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const ans={};\\n    for(let e of this){\\n        const key=fn(e);\\n        if (!(key in ans)) {    \\n      // Create an empty array for the key\\n      ans[key] = [];\\n    }\\n\\n    // else push e into the corresponding array in the grouped object\\n    ans[key].push(e);\\n    }\\n    return ans;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const ans={};\\n    for(let e of this){\\n        const key=fn(e);\\n        if (!(key in ans)) {    \\n      // Create an empty array for the key\\n      ans[key] = [];\\n    }\\n\\n    // else push e into the corresponding array in the grouped object\\n    ans[key].push(e);\\n    }\\n    return ans;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572720,
                "title": "java-script-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  return this.reduce((result, item) => {\\n    const key = fn(item);\\n    if (!(key in result)) {\\n      result[key] = [];\\n    }\\n    result[key].push(item);\\n    return result;\\n  }, {});\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  return this.reduce((result, item) => {\\n    const key = fn(item);\\n    if (!(key in result)) {\\n      result[key] = [];\\n    }\\n    result[key].push(item);\\n    return result;\\n  }, {});\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572714,
                "title": "groupby-detailed-explanation-with-time-space-complexity-easy",
                "content": "# Approach\\n1. ```Array.prototype.groupBy = function(fn) {``` - This line extends the Array prototype and adds a new method called groupBy. It takes a function fn as a parameter, which will be used to determine the grouping key for each item in the array.\\n\\n2. ```const res = {};``` - This creates an empty object called res, which will store the grouped results.\\n\\n3. ```this.forEach((item) => {``` - This starts a loop over each item in the array.\\n\\n4. ```const key = fn(item);``` - It calls the provided function fn with the current item as an argument to determine the grouping key for that item.\\n\\n5. ```if(!res[key]){``` - This checks if the grouping key doesn\\'t exist as a property in the res object.\\n\\n6. ```res[key] = [item];``` - If the key doesn\\'t exist, it creates a new property in the res object with the grouping key as the property name. The corresponding value is an array containing only the current item.\\n\\n7. ```else{``` - If the key already exists in the res object.\\n\\n8. ``` res[key].push(item); ``` - It pushes the current item into the array associated with the existing grouping key.\\n\\n9. ```},{})``` - This empty object {} is passed as the second argument to the forEach method, which doesn\\'t affect the loop but is required syntactically.\\n\\n10. ```return res;``` - Finally, the res object containing the grouped elements is returned as the result of the groupBy method.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. Iterating over the array using forEach takes O(n) time, where n is the number of elements in the array.\\n2. Computing the grouping key using the provided function fn takes O(1) time.\\n3. Inserting an item into the grouped result takes O(1) time if the grouping key doesn\\'t exist in the result object, or O(1) amortized time if the key already exists.\\n4. Therefore, the overall time complexity of the groupBy method is O(n), where n is the number of elements in the array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. The space complexity of the groupBy method is ```O(k + n)```, where k is the number of unique grouping keys and n is the number of elements in the array.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const res = {};\\n    this.forEach((item) => {\\n        const key = fn(item);\\n        if(!res[key]){\\n            res[key] = [item];\\n        }else{\\n            res[key].push(item);\\n        }\\n    },{});\\n    return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```Array.prototype.groupBy = function(fn) {```\n```const res = {};```\n```this.forEach((item) => {```\n```const key = fn(item);```\n```if(!res[key]){```\n```res[key] = [item];```\n```else{```\n``` res[key].push(item); ```\n```},{})```\n```return res;```\n```O(k + n)```\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const res = {};\\n    this.forEach((item) => {\\n        const key = fn(item);\\n        if(!res[key]){\\n            res[key] = [item];\\n        }else{\\n            res[key].push(item);\\n        }\\n    },{});\\n    return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572666,
                "title": "2631-group-by-javascript-easy-solution-beats-88-a",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    \\n    const res={};\\n    for(const obj of this){\\n        const key = fn(obj);\\n        if(!res.hasOwnProperty(key)){\\n            res[key]=[];\\n        }\\n        res[key].push(obj);\\n    }\\n    return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    \\n    const res={};\\n    for(const obj of this){\\n        const key = fn(obj);\\n        if(!res.hasOwnProperty(key)){\\n            res[key]=[];\\n        }\\n        res[key].push(obj);\\n    }\\n    return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572505,
                "title": "solution-typescript-javascript",
                "content": "# Code\\n``` typescript []\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function<T>(fn: (item: T) => string) {\\n  const returnObject: Record<string, T[]> = {};\\n  for (const item of this) {\\n    const key = fn(item);\\n    if (key in returnObject) {\\n      returnObject[key].push(item);\\n    } else {\\n      returnObject[key] = [item];\\n    }\\n  }\\n  return returnObject;\\n};\\n```\\n``` javascript []\\nArray.prototype.groupBy = function(fn) {\\n  const returnObject = {};\\n  for (const item of this) {\\n    const key = fn(item);\\n    if (key in returnObject) {\\n      returnObject[key].push(item);\\n    } else {\\n      returnObject[key] = [item];\\n    }\\n  }\\n  return returnObject;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` typescript []\\ndeclare global {\\n    interface Array<T> {\\n        groupBy(fn: (item: T) => string): Record<string, T[]>\\n    }\\n}\\n\\nArray.prototype.groupBy = function<T>(fn: (item: T) => string) {\\n  const returnObject: Record<string, T[]> = {};\\n  for (const item of this) {\\n    const key = fn(item);\\n    if (key in returnObject) {\\n      returnObject[key].push(item);\\n    } else {\\n      returnObject[key] = [item];\\n    }\\n  }\\n  return returnObject;\\n};\\n```\n``` javascript []\\nArray.prototype.groupBy = function(fn) {\\n  const returnObject = {};\\n  for (const item of this) {\\n    const key = fn(item);\\n    if (key in returnObject) {\\n      returnObject[key].push(item);\\n    } else {\\n      returnObject[key] = [item];\\n    }\\n  }\\n  return returnObject;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572374,
                "title": "can-anyone-help-me-out-whats-wrong",
                "content": "```\\nArray.prototype.groupBy = function(fn) {\\n    let obj = {} ;\\n    for(let i = 0; i<this.length;i++){\\n        console.log(this[i])\\n        let key = fn(this[i]);\\n        if(obj[key]){   \\n            obj[key] = [...obj[key],this[i]];          \\n        } else {\\n            obj[key]= [this[i]];\\n        }\\n    }\\n    return obj;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nArray.prototype.groupBy = function(fn) {\\n    let obj = {} ;\\n    for(let i = 0; i<this.length;i++){\\n        console.log(this[i])\\n        let key = fn(this[i]);\\n        if(obj[key]){   \\n            obj[key] = [...obj[key],this[i]];          \\n        } else {\\n            obj[key]= [this[i]];\\n        }\\n    }\\n    return obj;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572371,
                "title": "solved-in-one-line",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse the reduce method to group elements of the array into an object according to a provided function.\\n\\n\\nEach iteration of the reduce method updates an accumulator object containing the groupings for each key.\\n\\n\\nThe reduce method uses an arrow function and comma chaining to perform multiple expressions, including incrementally updating the accumulator object for each element in the array.\\n\\n\\nThe resulting object contains each item in the original array as values grouped by their corresponding keys determined by the provided grouping function.\\n# Code\\n```\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((ans, item) => ((ans[key = fn(item)] = (ans[key] || [])).push(item), ans), {}); \\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((ans, item) => ((ans[key = fn(item)] = (ans[key] || [])).push(item), ans), {}); \\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572061,
                "title": "simple-solution-loop",
                "content": "# Intuition\\njust check in object if key is present or not and add the fn value in that object\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n\\n    let ans = {};\\n\\n     for( let item of this ) {\\n          let key = fn(item);\\n          if( ans.hasOwnProperty(key)) {\\n            ans[key].push(item);\\n          }else {\\n             ans[key] = [item]\\n          }\\n     }\\n\\n     return ans;\\n    \\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n\\n    let ans = {};\\n\\n     for( let item of this ) {\\n          let key = fn(item);\\n          if( ans.hasOwnProperty(key)) {\\n            ans[key].push(item);\\n          }else {\\n             ans[key] = [item]\\n          }\\n     }\\n\\n     return ans;\\n    \\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572026,
                "title": "easy-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let obj = {};\\n    for(const i of this) {\\n        let key = fn(i);\\n        if(key in obj) {\\n            obj[key].push(i);\\n        } else obj[key] = [i];\\n    }\\n    return obj;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let obj = {};\\n    for(const i of this) {\\n        let key = fn(i);\\n        if(key in obj) {\\n            obj[key].push(i);\\n        } else obj[key] = [i];\\n    }\\n    return obj;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571950,
                "title": "easy-solution-o-n",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((map, i) => {\\n        const key = fn(i);\\n        map[key] ? map[key].push(i) : map[key] = [i];\\n        return map;\\n    }, {});\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((map, i) => {\\n        const key = fn(i);\\n        map[key] ? map[key].push(i) : map[key] = [i];\\n        return map;\\n    }, {});\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571918,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n       const result = {};\\n    this.forEach((item) => {\\n        const key = fn(item);\\n        if(result[key]) {\\n            result[key].push(item);\\n        } else {\\n            result[key] = [item];\\n        }\\n    });\\n    return result; \\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n       const result = {};\\n    this.forEach((item) => {\\n        const key = fn(item);\\n        if(result[key]) {\\n            result[key].push(item);\\n        } else {\\n            result[key] = [item];\\n        }\\n    });\\n    return result; \\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571877,
                "title": "using-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((map,c)=>{\\n        const id = fn(c); //this function returns the id of item\\n        map[id] ? map[id].push(c) : (map[id]=[c]);\\n        return map;\\n    },{})\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((map,c)=>{\\n        const id = fn(c); //this function returns the id of item\\n        map[id] ? map[id].push(c) : (map[id]=[c]);\\n        return map;\\n    },{})\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571792,
                "title": "chatgpt-code-snippet",
                "content": "# Group By\\n\\n## Intuition\\nThe problem asks us to implement a `groupBy` method for arrays in JavaScript, which groups the elements of the array based on a given callback function. The grouped array is represented as an object, where each key is the output of the callback function for an item, and each value is an array containing all the items in the original array with that key.\\n\\nTo solve this problem, we can utilize the `reduce` method on the array. We iterate over each item in the array and apply the callback function to obtain the key. Then, we check if the key already exists in the result object. If not, we initialize an empty array for that key. Finally, we push the current item to the corresponding array in the result object.\\n\\n## Approach\\n1. Extend the `Array.prototype` and add a `groupBy` method to it.\\n2. Inside the `groupBy` method, use the `reduce` method on the array.\\n3. In the reduce callback function, initialize the `result` object as an empty object.\\n4. For each item in the array, apply the callback function to get the key.\\n5. Check if the key already exists in the `result` object.\\n6. If the key doesn\\'t exist, initialize an empty array for that key in the `result` object.\\n7. Push the current item to the array corresponding to the key in the `result` object.\\n8. Return the `result` object.\\n\\n## Complexity Analysis\\nThe time complexity of this approach is O(n), where n is the length of the input array. This is because we iterate through each item in the array once using the `reduce` method.\\n\\nThe space complexity is also O(n), as we store the grouped elements in an object. In the worst case, if all elements have unique keys, the object will have n distinct keys, each with an array of size 1.\\n\\n## Code Implementation\\nHere\\'s the JavaScript implementation of the `groupBy` method:\\n\\n```javascript\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  return this.reduce((result, item) => {\\n    const key = fn(item);\\n    if (!result[key]) {\\n      result[key] = [];\\n    }\\n    result[key].push(item);\\n    return result;\\n  }, {});\\n};\\n```\\n\\nNow, we can use the `groupBy` method on any array:\\n\\n```javascript\\n[1, 2, 3].groupBy(String); // Output: {\"1\":[1],\"2\":[2],\"3\":[3]}\\n```\\n\\nThis implementation allows us to group the elements of an array based on different criteria by providing different callback functions.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  return this.reduce((result, item) => {\\n    const key = fn(item);\\n    if (!result[key]) {\\n      result[key] = [];\\n    }\\n    result[key].push(item);\\n    return result;\\n  }, {});\\n};\\n```\n```javascript\\n[1, 2, 3].groupBy(String); // Output: {\"1\":[1],\"2\":[2],\"3\":[3]}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571578,
                "title": "javascript-easy-solution",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const res = {}\\n    for (const i of this){\\n        const key = fn(i)\\n        if(key in res){\\n            res[key].push(i);\\n        } else {\\n            res[key] = [i];\\n        }\\n    }\\n    return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const res = {}\\n    for (const i of this){\\n        const key = fn(i)\\n        if(key in res){\\n            res[key].push(i);\\n        } else {\\n            res[key] = [i];\\n        }\\n    }\\n    return res;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571533,
                "title": "simple-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let group={};\\n    this.map(x=>{\\n        let id=fn(x);\\n        if(!group[id]){\\n            group[id]=[]\\n        }\\n        group[id].push(x)\\n    })\\n    return group\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let group={};\\n    this.map(x=>{\\n        let id=fn(x);\\n        if(!group[id]){\\n            group[id]=[]\\n        }\\n        group[id].push(x)\\n    })\\n    return group\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571480,
                "title": "easy-solution-without-using-inbuilt-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const grouped ={} , length=this.length;\\n    for(let i=0  ; i<length ; i++){\\n        const id=fn(this[i]);\\n        if(grouped[id]===undefined) grouped[id]=[];\\n        grouped[id].push(this[i]);\\n    }\\n    return grouped;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const grouped ={} , length=this.length;\\n    for(let i=0  ; i<length ; i++){\\n        const id=fn(this[i]);\\n        if(grouped[id]===undefined) grouped[id]=[];\\n        grouped[id].push(this[i]);\\n    }\\n    return grouped;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571158,
                "title": "javascript-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  const returnObject = {};\\n  for (const item of this) {\\n    const key = fn(item);\\n    if (key in returnObject) {\\n      returnObject[key].push(item);\\n    } else {\\n      returnObject[key] = [item];\\n    }\\n  }\\n  return returnObject;\\n};\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/aef2d785-1252-4285-a373-d69b4969437c_1685260339.9350307.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n  const returnObject = {};\\n  for (const item of this) {\\n    const key = fn(item);\\n    if (key in returnObject) {\\n      returnObject[key].push(item);\\n    } else {\\n      returnObject[key] = [item];\\n    }\\n  }\\n  return returnObject;\\n};\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571135,
                "title": "easiest-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Create a Key : Value Pairs object.\\n2. . Traverse array.\\n    - Get element.\\n    - Call function \\'fn\\' to get *key*.\\n    - Check if *key* exists or not.\\n        - If not exists than create new with empty array as *value*.\\n    - Push the element as a *value* into the object with that *key*.\\n3. Return the resultant array.\\n# Code\\n``` javaScript []\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n    for(let i = 0; i < this.length; ++i) {\\n        const key = fn(this[i]);\\n\\n        if(!result[key]) result[key] = [];\\n        result[key].push(this[i]);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javaScript []\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n    for(let i = 0; i < this.length; ++i) {\\n        const key = fn(this[i]);\\n\\n        if(!result[key]) result[key] = [];\\n        result[key].push(this[i]);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571128,
                "title": "simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```js\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let g = {};\\n    this.forEach(\\n            (key, index) =>\\n                (key = fn(key)) in g\\n                    ? g[key].push(this[index])\\n                    : g[key] = [ this[index] ]\\n        );\\n    return g;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    let g = {};\\n    this.forEach(\\n            (key, index) =>\\n                (key = fn(key)) in g\\n                    ? g[key].push(this[index])\\n                    : g[key] = [ this[index] ]\\n        );\\n    return g;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571068,
                "title": "simple-solution-easy-to-understand-o-n-time-o-n-space",
                "content": "# Complexity\\n- Time complexity: **O(n)** - where **n** is the length of the input array\\n- Space complexity: **O(n)** - where **n** is the length of the input array\\n\\n# Code\\n```\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n\\n    for (const value of this) {\\n        const key = fn(value);\\n        key in result ? result[key].push(value) : result[key] = [value];\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nArray.prototype.groupBy = function(fn) {\\n    const result = {};\\n\\n    for (const value of this) {\\n        const key = fn(value);\\n        key in result ? result[key].push(value) : result[key] = [value];\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571055,
                "title": "easy-javascript-solution",
                "content": "# Approach\\n\\n1. We define the `groupBy` method and add it to the `Array.prototype`. This allows us to call `groupBy` directly on any array.\\n\\n2. The `groupBy` method takes a single argument, which is the callback function `fn`. This callback function is used to determine the key for grouping each item in the array.\\n\\n3. Inside the `groupBy` method, we use the `reduce` function to iterate over the array and build the grouped result.\\n\\n4. The `reduce` function takes two arguments: the accumulator (`result`) and the current item (`item`) being processed.\\n\\n5. For each item in the array, we call the callback function `fn(item)` to determine the key for grouping. We store this key in the `key` variable.\\n\\n6. We check if the `result` object already has a property with the `key` value using `result.hasOwnProperty(key)`. If it does, we push the current `item` to the existing array under that key. If not, we create a new array with the current `item` and assign it to the `key` property in the `result` object.\\n\\n7. Finally, we return the `result` object, which contains the grouped arrays based on the keys generated by the callback function.\\n\\nThis approach allows you to use the `groupBy` method on any array and group its elements based on a specified key generated by the provided callback function.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\n\\n// Define the groupBy method\\nArray.prototype.groupBy = function(fn) {\\n  return this.reduce((result, item) => {\\n    const key = fn(item);\\n    if (result.hasOwnProperty(key)) {\\n      result[key].push(item);\\n    } else {\\n      result[key] = [item];\\n    }\\n    return result;\\n  }, {});\\n};\\n\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\n\\n// Define the groupBy method\\nArray.prototype.groupBy = function(fn) {\\n  return this.reduce((result, item) => {\\n    const key = fn(item);\\n    if (result.hasOwnProperty(key)) {\\n      result[key].push(item);\\n    } else {\\n      result[key] = [item];\\n    }\\n    return result;\\n  }, {});\\n};\\n\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570966,
                "title": "day24-simple-js-beginner-solution",
                "content": "# Intuition\\n- The Question states that we will be having an array and function fn\\n- now fn returns a key for an element passed in as an paramenter to it.\\n- Now we need to return an object that has grouped the values of array on the basis of the key returned by the fn\\n- this means the array element have same key must be placed together.\\n- And the order in group should be according to the their occurance in array.\\n\\n- this question actually wants us to make an map of the value with respect to the key.\\n- we will create a an Object of arrays for the mapping\\n\\n# Approach\\n- for the Mapping we will be using the object of arrays.\\n\\n- We will first create an empty object result.\\n\\n- Now , we will traverse the array , in my solution i have used the foreach loop.\\n\\n```\\nthis.forEach(()=>{\\n      \\n})\\n```\\n- will apply the the arrow function to Every element of the Array\\n Now we will be doing following\\n\\n\\n```\\n1. first obtaining the key\\n\\nconst key = fn(i)\\n\\n2. Now check in the result object that is their a value corresponding to the key \"key\"\\n\\n3. if not present \\n \\n    if(!result[key]) , then\\n    result[key] will be equal to the array having i\\n    result[key]=[i]\\n\\n4. if yes then just push the i in the result[key]\\n\\n    result[key].push(i)\\n\\n5. after the itrtion to all elements return the result\\n```\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n\\nArray.prototype.groupBy = function(fn) {\\n    //result object to return the answer\\n    const result = {};\\n\\n    //now applying the operation for each element of array\\n    this.forEach((i )=>{\\n            // obtaining the key from given function fn\\n            const key = fn(i);\\n\\n            //check if their is any value corresponding to the key index \\n            // if not then result[key] will have an array with elements of array having same key\\n            //if yes then just push the element in the array result at index key.\\n            if(!result[key]) result[key]=[i];\\n            else result[key].push(i);\\n    })\\n\\n    //returing the resultant array.\\n    return result;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Ordered Map"
                ],
                "code": "```\\nthis.forEach(()=>{\\n      \\n})\\n```\n```\\n1. first obtaining the key\\n\\nconst key = fn(i)\\n\\n2. Now check in the result object that is their a value corresponding to the key \"key\"\\n\\n3. if not present \\n \\n    if(!result[key]) , then\\n    result[key] will be equal to the array having i\\n    result[key]=[i]\\n\\n4. if yes then just push the i in the result[key]\\n\\n    result[key].push(i)\\n\\n5. after the itrtion to all elements return the result\\n```\n```\\n\\nArray.prototype.groupBy = function(fn) {\\n    //result object to return the answer\\n    const result = {};\\n\\n    //now applying the operation for each element of array\\n    this.forEach((i )=>{\\n            // obtaining the key from given function fn\\n            const key = fn(i);\\n\\n            //check if their is any value corresponding to the key index \\n            // if not then result[key] will have an array with elements of array having same key\\n            //if yes then just push the element in the array result at index key.\\n            if(!result[key]) result[key]=[i];\\n            else result[key].push(i);\\n    })\\n\\n    //returing the resultant array.\\n    return result;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570901,
                "title": "grouping-array-elements-with-groupby-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires grouping elements of an array based on a provided callback function. We can create a `groupBy` method that extends the `Array` prototype to achieve this. The method will iterate over each element of the array, apply the callback function to generate a key, and group the elements accordingly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a `groupBy` method that extends the `Array` prototype.\\n2. Initialize an empty object called `grouped` to store the grouped elements.\\n3. Iterate over each element of the array using the `forEach` method.\\n4. Apply the provided callback function `fn` to the current element to obtain a key.\\n5. Check if the `grouped` object already has a property with the key.\\n    - If it does, push the current element to the corresponding array.\\n    - If it doesn\\'t, create a new array with the current element as its first value and assign it to the key in the `grouped` object.\\n6. Return the `grouped` object.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the length of the input array. We need to iterate over each element of the array to group them.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n), where n is the length of the input array. The space required is proportional to the number of distinct keys generated by the callback function, which can be at most the length of the array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const grouped = {};\\n\\n    this.forEach((item) => {\\n        const key = fn(item);\\n        if (grouped.hasOwnProperty(key)) {\\n            grouped[key].push(item);\\n        } else {\\n            grouped[key] = [item];\\n        }\\n    });\\n    return grouped;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    const grouped = {};\\n\\n    this.forEach((item) => {\\n        const key = fn(item);\\n        if (grouped.hasOwnProperty(key)) {\\n            grouped[key].push(item);\\n        } else {\\n            grouped[key] = [item];\\n        }\\n    });\\n    return grouped;\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570892,
                "title": "best-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((accum,item) => {\\n        const key = fn(item);\\n        accum[key] ||= [];\\n        accum[key].push(item);\\n        return accum;\\n    },{});\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce((accum,item) => {\\n        const key = fn(item);\\n        accum[key] ||= [];\\n        accum[key].push(item);\\n        return accum;\\n    },{});\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3570880,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo group items in an array based on a key obtained from a callback function, we can iterate over the array and use an object to store the groups. For each item, we determine its key using the callback function and add it to the corresponding group in the object. If the group doesn\\'t exist yet, we create an empty array for that group. Finally, we return the resulting grouped object. This approach allows us to easily organize and access the items based on their assigned groups.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize an empty object called groups to store the groups.\\n- Iterate over each item in the array.\\n- For each item, use the provided callback function to obtain the key.\\n- Check if the key already exists as a property in the groups object.\\n- If the key doesn\\'t exist, create a new property in the groups object with the key and set its value as an empty array.\\n- Push the current item into the array corresponding to the key in the groups object.\\n- After iterating over all the items, the groups object will contain the groups.\\n- Return the groups object as the grouped version of the array.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(keys)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce(function(groups, item) {\\n        var i = fn(item);\\n        if(!(i in groups)) groups[i] = [];\\n        groups[i].push(item);\\n        return groups;\\n    },{});\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Array}\\n */\\nArray.prototype.groupBy = function(fn) {\\n    return this.reduce(function(groups, item) {\\n        var i = fn(item);\\n        if(!(i in groups)) groups[i] = [];\\n        groups[i].push(item);\\n        return groups;\\n    },{});\\n};\\n\\n/**\\n * [1,2,3].groupBy(String) // {\"1\":[1],\"2\":[2],\"3\":[3]}\\n */\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1877323,
                "content": [
                    {
                        "username": "Vegeta_",
                        "content": "I think this should be moved to easy"
                    },
                    {
                        "username": "dbstnsdl12",
                        "content": "Return type of \"groupBy\" function is actually not \"Array\".\nAnd I agree with this one should be \"easy\""
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day24: Done solving Today\\'s Question \\uD83D\\uDE00\\n\\nTip: Use make an object of array"
                    },
                    {
                        "username": "c4tdog",
                        "content": "reinvent another wheel :\\\\"
                    },
                    {
                        "username": "tifv",
                        "content": "What is so bad with reinventing wheels as a training exercise? :)"
                    },
                    {
                        "username": "simarpalSingh",
                        "content": "should be moved to easy  :-)"
                    },
                    {
                        "username": "Bhelwulf",
                        "content": "This one should be easy."
                    },
                    {
                        "username": "raj2k00",
                        "content": "Another easy one with medium coating :)"
                    }
                ]
            },
            {
                "id": 1953514,
                "content": [
                    {
                        "username": "Vegeta_",
                        "content": "I think this should be moved to easy"
                    },
                    {
                        "username": "dbstnsdl12",
                        "content": "Return type of \"groupBy\" function is actually not \"Array\".\nAnd I agree with this one should be \"easy\""
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day24: Done solving Today\\'s Question \\uD83D\\uDE00\\n\\nTip: Use make an object of array"
                    },
                    {
                        "username": "c4tdog",
                        "content": "reinvent another wheel :\\\\"
                    },
                    {
                        "username": "tifv",
                        "content": "What is so bad with reinventing wheels as a training exercise? :)"
                    },
                    {
                        "username": "simarpalSingh",
                        "content": "should be moved to easy  :-)"
                    },
                    {
                        "username": "Bhelwulf",
                        "content": "This one should be easy."
                    },
                    {
                        "username": "raj2k00",
                        "content": "Another easy one with medium coating :)"
                    }
                ]
            },
            {
                "id": 1908512,
                "content": [
                    {
                        "username": "Vegeta_",
                        "content": "I think this should be moved to easy"
                    },
                    {
                        "username": "dbstnsdl12",
                        "content": "Return type of \"groupBy\" function is actually not \"Array\".\nAnd I agree with this one should be \"easy\""
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day24: Done solving Today\\'s Question \\uD83D\\uDE00\\n\\nTip: Use make an object of array"
                    },
                    {
                        "username": "c4tdog",
                        "content": "reinvent another wheel :\\\\"
                    },
                    {
                        "username": "tifv",
                        "content": "What is so bad with reinventing wheels as a training exercise? :)"
                    },
                    {
                        "username": "simarpalSingh",
                        "content": "should be moved to easy  :-)"
                    },
                    {
                        "username": "Bhelwulf",
                        "content": "This one should be easy."
                    },
                    {
                        "username": "raj2k00",
                        "content": "Another easy one with medium coating :)"
                    }
                ]
            },
            {
                "id": 1908041,
                "content": [
                    {
                        "username": "Vegeta_",
                        "content": "I think this should be moved to easy"
                    },
                    {
                        "username": "dbstnsdl12",
                        "content": "Return type of \"groupBy\" function is actually not \"Array\".\nAnd I agree with this one should be \"easy\""
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day24: Done solving Today\\'s Question \\uD83D\\uDE00\\n\\nTip: Use make an object of array"
                    },
                    {
                        "username": "c4tdog",
                        "content": "reinvent another wheel :\\\\"
                    },
                    {
                        "username": "tifv",
                        "content": "What is so bad with reinventing wheels as a training exercise? :)"
                    },
                    {
                        "username": "simarpalSingh",
                        "content": "should be moved to easy  :-)"
                    },
                    {
                        "username": "Bhelwulf",
                        "content": "This one should be easy."
                    },
                    {
                        "username": "raj2k00",
                        "content": "Another easy one with medium coating :)"
                    }
                ]
            },
            {
                "id": 1965906,
                "content": [
                    {
                        "username": "Vegeta_",
                        "content": "I think this should be moved to easy"
                    },
                    {
                        "username": "dbstnsdl12",
                        "content": "Return type of \"groupBy\" function is actually not \"Array\".\nAnd I agree with this one should be \"easy\""
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day24: Done solving Today\\'s Question \\uD83D\\uDE00\\n\\nTip: Use make an object of array"
                    },
                    {
                        "username": "c4tdog",
                        "content": "reinvent another wheel :\\\\"
                    },
                    {
                        "username": "tifv",
                        "content": "What is so bad with reinventing wheels as a training exercise? :)"
                    },
                    {
                        "username": "simarpalSingh",
                        "content": "should be moved to easy  :-)"
                    },
                    {
                        "username": "Bhelwulf",
                        "content": "This one should be easy."
                    },
                    {
                        "username": "raj2k00",
                        "content": "Another easy one with medium coating :)"
                    }
                ]
            },
            {
                "id": 1908601,
                "content": [
                    {
                        "username": "Vegeta_",
                        "content": "I think this should be moved to easy"
                    },
                    {
                        "username": "dbstnsdl12",
                        "content": "Return type of \"groupBy\" function is actually not \"Array\".\nAnd I agree with this one should be \"easy\""
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day24: Done solving Today\\'s Question \\uD83D\\uDE00\\n\\nTip: Use make an object of array"
                    },
                    {
                        "username": "c4tdog",
                        "content": "reinvent another wheel :\\\\"
                    },
                    {
                        "username": "tifv",
                        "content": "What is so bad with reinventing wheels as a training exercise? :)"
                    },
                    {
                        "username": "simarpalSingh",
                        "content": "should be moved to easy  :-)"
                    },
                    {
                        "username": "Bhelwulf",
                        "content": "This one should be easy."
                    },
                    {
                        "username": "raj2k00",
                        "content": "Another easy one with medium coating :)"
                    }
                ]
            },
            {
                "id": 1908340,
                "content": [
                    {
                        "username": "Vegeta_",
                        "content": "I think this should be moved to easy"
                    },
                    {
                        "username": "dbstnsdl12",
                        "content": "Return type of \"groupBy\" function is actually not \"Array\".\nAnd I agree with this one should be \"easy\""
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day24: Done solving Today\\'s Question \\uD83D\\uDE00\\n\\nTip: Use make an object of array"
                    },
                    {
                        "username": "c4tdog",
                        "content": "reinvent another wheel :\\\\"
                    },
                    {
                        "username": "tifv",
                        "content": "What is so bad with reinventing wheels as a training exercise? :)"
                    },
                    {
                        "username": "simarpalSingh",
                        "content": "should be moved to easy  :-)"
                    },
                    {
                        "username": "Bhelwulf",
                        "content": "This one should be easy."
                    },
                    {
                        "username": "raj2k00",
                        "content": "Another easy one with medium coating :)"
                    }
                ]
            }
        ]
    }
]