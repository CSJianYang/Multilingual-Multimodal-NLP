[
    {
        "title": "Largest Time for Given Digits",
        "question_content": "Given an array arr of 4 digits, find the latest 24-hour time that can be made using each digit exactly once.\n24-hour times are formatted as \"HH:MM\", where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59.\nReturn the latest 24-hour time in \"HH:MM\" format. If no valid time can be made, return an empty string.\n&nbsp;\nExample 1:\n\nInput: arr = [1,2,3,4]\nOutput: \"23:41\"\nExplanation: The valid 24-hour times are \"12:34\", \"12:43\", \"13:24\", \"13:42\", \"14:23\", \"14:32\", \"21:34\", \"21:43\", \"23:14\", and \"23:41\". Of these times, \"23:41\" is the latest.\n\nExample 2:\n\nInput: arr = [5,5,5,5]\nOutput: \"\"\nExplanation: There are no valid 24-hour times as \"55:55\" is not valid.\n\n&nbsp;\nConstraints:\n\n\tarr.length == 4\n\t0 <= arr[i] <= 9",
        "solutions": [
            {
                "id": 200693,
                "title": "java-python-3-11-liner-o-64-w-comment-6-ms",
                "content": "`A[i], A[j], A[k], & A[l]` are the `4` elements of `A`, where `i, j, k & l` are the permutation of `0, 1, 2, & 3`, e.g.,\\n`(A[i], A[j], A[k], A[l]) = (A[2], A[0], A[3], A[1])` or `(A[i], A[j], A[k], A[l]) = (A[3], A[1], A[2], A[0])`, etc. \\n\\n`i, j, k & l` can have `4! = 24` different values, but their sum is always same: `6`.\\n\\nTherefore, since `i + j + k + l = 0 + 1 + 2 + 3 = 6`, we have `l = 6 - i - j - k`.\\n\\n```java\\n    public String largestTimeFromDigits(int[] A) {\\n        String ans = \"\";\\n        for (int i = 0; i < 4; ++i) {\\n            for (int j = 0; j < 4; ++j) {\\n                for (int k = 0; k < 4; ++k) {\\n                    if (i == j || i == k || j == k) continue; // avoid duplicate among i, j & k.\\n                    String h = \"\" + A[i] + A[j], m = \"\" + A[k] + A[6 - i - j - k], t = h + \":\" + m; // hour, minutes, & time.\\n                    if (h.compareTo(\"24\") < 0 && m.compareTo(\"60\") < 0 && ans.compareTo(t) < 0) ans = t; // hour < 24; minute < 60; update result.\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        ans = \\'\\'\\n        for i, a in enumerate(A):\\n            for j, b in enumerate(A):\\n                for k, c in enumerate(A):\\n                    if i == j or i == k or j == k:\\n                        continue\\n                    hour, minute = str(a) + str(b), str(c) + str(A[6 - i - j - k])\\n                    if hour < \\'24\\' and minute < \\'60\\':\\n                        ans = max(ans, hour + \\':\\' + minute)\\n        return ans\\n```\\nUse Python lib:\\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        for time in itertools.permutations(sorted(A, reverse=True)):\\n            if time[:2] < (2, 4) and time[2] < 6:\\n                return \\'%d%d:%d%d\\' % time\\n        return \\'\\'\\n```\\n**Analysis:**\\n\\nThe inner most  loop at most iterates 4 * 4 * 4 = 64 times.",
                "solutionTags": [],
                "code": "```java\\n    public String largestTimeFromDigits(int[] A) {\\n        String ans = \"\";\\n        for (int i = 0; i < 4; ++i) {\\n            for (int j = 0; j < 4; ++j) {\\n                for (int k = 0; k < 4; ++k) {\\n                    if (i == j || i == k || j == k) continue; // avoid duplicate among i, j & k.\\n                    String h = \"\" + A[i] + A[j], m = \"\" + A[k] + A[6 - i - j - k], t = h + \":\" + m; // hour, minutes, & time.\\n                    if (h.compareTo(\"24\") < 0 && m.compareTo(\"60\") < 0 && ans.compareTo(t) < 0) ans = t; // hour < 24; minute < 60; update result.\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        ans = \\'\\'\\n        for i, a in enumerate(A):\\n            for j, b in enumerate(A):\\n                for k, c in enumerate(A):\\n                    if i == j or i == k or j == k:\\n                        continue\\n                    hour, minute = str(a) + str(b), str(c) + str(A[6 - i - j - k])\\n                    if hour < \\'24\\' and minute < \\'60\\':\\n                        ans = max(ans, hour + \\':\\' + minute)\\n        return ans\\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        for time in itertools.permutations(sorted(A, reverse=True)):\\n            if time[:2] < (2, 4) and time[2] < 6:\\n                return \\'%d%d:%d%d\\' % time\\n        return \\'\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 200517,
                "title": "python-1-line-check-permutations-o-24",
                "content": "```\\n    def largestTimeFromDigits(self, A):\\n        return max([\"%d%d:%d%d\" % t for t in itertools.permutations(A) if t[:2] < (2, 4) and t[2] < 6] or [\"\"])\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def largestTimeFromDigits(self, A):\\n        return max([\"%d%d:%d%d\" % t for t in itertools.permutations(A) if t[:2] < (2, 4) and t[2] < 6] or [\"\"])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 201564,
                "title": "c-4-lines-0-ms-prev-permutation",
                "content": "There are too many corner cases, so it\\'s easier to just brute-force all 24 combinations and find the maximum over valid ones.\\n\\nThanks to [@AdamTai](https://leetcode.com/adamtai) for pointing out that, since we permutating from smallest to largest, the last valid combination is also the largest one. Therefore, we can sort the input descending, iterate from largest to smallest using ```prev_permutation``` and return the first valid time.\\n```\\nstring largestTimeFromDigits(vector<int>& A) {\\n  sort(begin(A), end(A), greater<int>());\\n  do if ((A[0] < 2 || (A[0] == 2 && A[1] < 4)) && A[2] < 6) \\n      return to_string(A[0]) + to_string(A[1]) + \":\" + to_string(A[2]) + to_string(A[3]);\\n  while (prev_permutation(begin(A), end(A)));\\n  return \"\";\\n}\\n```",
                "solutionTags": [],
                "code": "```prev_permutation```\n```\\nstring largestTimeFromDigits(vector<int>& A) {\\n  sort(begin(A), end(A), greater<int>());\\n  do if ((A[0] < 2 || (A[0] == 2 && A[1] < 4)) && A[2] < 6) \\n      return to_string(A[0]) + to_string(A[1]) + \":\" + to_string(A[2]) + to_string(A[3]);\\n  while (prev_permutation(begin(A), end(A)));\\n  return \"\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 822874,
                "title": "python-check-all-permutations-explained",
                "content": "In this problem we are asked to check if some possible permutation of digits creates maximum possible valid time. One way to handle this problem is to just check all possible `4! = 24` permutations: this number is quite small and we can afford it. So, we:\\n\\n1. Create `out = \"\"`, here we will keep our answer.\\n2. Check all permutations of `A`, in python there is special function for it, why not use it: for each permutation check if it is valid time: hour need to be `<=23` and minutes need to be `<=59`, which can be written as `P[2] <= 5`.\\n3. Now, compare new build time with our current maximum and choose best of them. This is all!\\n\\n**Complexity**: time complexity is `O(1)`, but more strictrly it is `O(k!)`, we need to check all permutations in any case, where `k=4` is size of `A`. Space complexity is `O(1)` also, which is more like `O(k)` to keep our answer and compare it with `out`.\\n\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        out = \"\"\\n        for P in permutations(A):\\n            if P[0]*10 + P[1] <= 23 and P[2] <= 5:\\n                out = max(out, str(P[0])+str(P[1]) + \":\" + str(P[2])+str(P[3]))\\n        \\n        return out\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        out = \"\"\\n        for P in permutations(A):\\n            if P[0]*10 + P[1] <= 23 and P[2] <= 5:\\n                out = max(out, str(P[0])+str(P[1]) + \":\" + str(P[2])+str(P[3]))\\n        \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211540,
                "title": "python-simple-obvious-solution",
                "content": "```\\n def largestTimeFromDigits(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: str\\n        \"\"\"\\n        k = sorted(list(itertools.permutations(A)),reverse=True)\\n        \\n        for i in k:            \\n            a,b,c,d = i\\n            su = (a*10+b)\\n            sd = (c*10+d) \\n\\n            if su < 24 and sd <60:\\n                return  f\"{a}{b}:{c}{d}\"\\n                \\n        return \\'\\'\\n```",
                "solutionTags": [],
                "code": "```\\n def largestTimeFromDigits(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: str\\n        \"\"\"\\n        k = sorted(list(itertools.permutations(A)),reverse=True)\\n        \\n        for i in k:            \\n            a,b,c,d = i\\n            su = (a*10+b)\\n            sd = (c*10+d) \\n\\n            if su < 24 and sd <60:\\n                return  f\"{a}{b}:{c}{d}\"\\n                \\n        return \\'\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 823064,
                "title": "java-without-permutations-and-backtracking-beats-100-space-and-runtime",
                "content": "We need to rearrange the array of 4 digits such that it produces largest Time.\\n\\nfor Rearrange the Array I have created function ```rearrange(int maxValue,int index,int[] a)``` details below :\\n \\n Function arguments :\\n  1. maxValue -- maximum value for the given Index\\n  2. index -- for which index we need to rearrange the array\\n  3.  a[] - input array containing 4 digits\\n\\nreturns **TRUE** if we have found the **maximum element for index in a[]** else returns **FALSE**\\n\\nNow, Using above function we have to rearrange the array from left to right. \\n\\nThere are 2 type of cases, as mentioned below :\\n\\n***CASE 1***  - **23:59 , 19:59 , 09:59**\\n\\n\\tif 1st digit is 2 then 2nd digit value can  be 0<=value<=3\\n\\telse if 1st digit is less than 2 then 2nd digit value can be 0<=value<=9\\n\\tfor 3rd digit 0<=value<=5\\n\\tfor 4rth digit 0<=value<=9\\n\\nBelow code summarize the above cases and rearrange the array:\\n```(rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a))```\\n\\n***CASE 2*** : **06:26 , 16:26**\\n\\n**Now Case 1 will fail, when 1st digit can be 0 or 1**\\n\\nso, when Case 1 returns false value, then we can check Case 2 digits condition and rearrange them :\\n\\n\\t1st digit  :  0<=value<=1\\n\\t2nd digit  : 0<=value<=9\\n\\t3rd digit  : 0<=value<=5\\n\\t4rth digit  : 0<=value<=9\\n\\nbelow code summarize the above cases to rearrange:\\n```(rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a))```\\n\\nSo, after adding both ( CASE 1 || CASE 2), we get the below code:\\n\\n```\\nboolean res = (rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a)) || (rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a));\\n```\\n\\nAfter rearrangement we just simply convert the array to time format\\n\\nBelow is the final Code\\n\\n```\\nclass Solution {\\n    \\n    private boolean rearrange(int maxValue,int index,int[] a){\\n        int max = -1;\\n\\t\\t\\n\\t\\t// find the maximum number for the given index which should be less than equal\\n\\t\\t// to maxValue\\n        for(int i = index; i<a.length;i++) if(a[i]<=maxValue && (max==-1 || a[max]<a[i])) max = i;\\n\\t\\t// number not found\\n        if(max==-1) return false;\\n    \\n\\t// put the number to its correct index \\n\\t// swap it put at correct position\\n        int temp = a[max];\\n        a[max] = a[index];\\n        a[index] = temp;\\n        return true;\\n    }\\n\\t\\n\\t\\n    \\n    public String largestTimeFromDigits(int[] a) {\\n        boolean res = (rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a)) || (rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a));\\n        \\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if(!res) return sb.toString();\\n        \\n        return sb.append(String.valueOf(a[0]))\\n          .append(String.valueOf(a[1]))\\n          .append(\\':\\')\\n          .append(String.valueOf(a[2]))\\n          .append(String.valueOf(a[3])).toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "```rearrange(int maxValue,int index,int[] a)```\n```(rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a))```\n```(rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a))```\n```\\nboolean res = (rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a)) || (rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 822967,
                "title": "c-just-loop-and-check-validity-on-the-fly-0-ms-beats-100-in-time",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& a) {\\n        string ans = \"\"; int mx = -1, h1 = -1, h2 = -1, m1 = -1, m2 = -1;\\n        \\n        for(int i=0; i<4; ++i) {\\n            if(a[i] > 2) continue;\\n            \\n            for(int j=0; j<4; ++j) {\\n                if(j == i) continue;\\n                if(a[i] == 2 && a[j] > 3) continue;\\n                \\n                for(int k=0; k<4; ++k) {\\n                    if(k == j || k == i) continue;\\n                    if(a[k] > 5) continue;\\n                    \\n                    int l = 6-i-j-k;\\n                    if(l == k || l == j || l == i) continue;\\n\\n                    int val = (a[l] + (a[k] * 10)) + (a[j] + (a[i] * 10)) * 60; // value of time in minutes.\\n\\n                    if(mx < val) {\\n                        mx = val;\\n                        h1 = a[i], h2 = a[j], m1 = a[k], m2 = a[l];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(h1 == -1 || h2 == -1 || m1 == -1 || m2 == -1) return \"\";\\n        \\n        ans = to_string(h1) + to_string(h2) + \":\" + to_string(m1) + to_string(m2);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nIf you have any questions, feel free to ask. If you like the solution, please **Upvote!**\\nHave a great day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& a) {\\n        string ans = \"\"; int mx = -1, h1 = -1, h2 = -1, m1 = -1, m2 = -1;\\n        \\n        for(int i=0; i<4; ++i) {\\n            if(a[i] > 2) continue;\\n            \\n            for(int j=0; j<4; ++j) {\\n                if(j == i) continue;\\n                if(a[i] == 2 && a[j] > 3) continue;\\n                \\n                for(int k=0; k<4; ++k) {\\n                    if(k == j || k == i) continue;\\n                    if(a[k] > 5) continue;\\n                    \\n                    int l = 6-i-j-k;\\n                    if(l == k || l == j || l == i) continue;\\n\\n                    int val = (a[l] + (a[k] * 10)) + (a[j] + (a[i] * 10)) * 60; // value of time in minutes.\\n\\n                    if(mx < val) {\\n                        mx = val;\\n                        h1 = a[i], h2 = a[j], m1 = a[k], m2 = a[l];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(h1 == -1 || h2 == -1 || m1 == -1 || m2 == -1) return \"\";\\n        \\n        ans = to_string(h1) + to_string(h2) + \":\" + to_string(m1) + to_string(m2);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202234,
                "title": "java-super-short-solution",
                "content": "```\\n    public String largestTimeFromDigits(int[] A) {\\n        for(int h = 23; h >= 0; h--) {\\n            for(int m = 59; m >= 0; m--) {\\n                \\n                boolean flag = true;\\n                int[] count = new int[10];\\n                \\n                count[h < 10 ? 0 : h / 10]++;\\n                count[h < 10 ? h : h % 10]++;\\n                count[m < 10 ? 0 : m / 10]++;\\n                count[m < 10 ? m : m % 10]++;                \\n\\n                \\n                for(int e : A) {\\n                    if(--count[e] < 0) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(flag) return String.format(\"%02d:%02d\", h, m);\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String largestTimeFromDigits(int[] A) {\\n        for(int h = 23; h >= 0; h--) {\\n            for(int m = 59; m >= 0; m--) {\\n                \\n                boolean flag = true;\\n                int[] count = new int[10];\\n                \\n                count[h < 10 ? 0 : h / 10]++;\\n                count[h < 10 ? h : h % 10]++;\\n                count[m < 10 ? 0 : m / 10]++;\\n                count[m < 10 ? m : m % 10]++;                \\n\\n                \\n                for(int e : A) {\\n                    if(--count[e] < 0) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(flag) return String.format(\"%02d:%02d\", h, m);\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 309364,
                "title": "100-c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring largestTimeFromDigits(vector<int>& A) {\\n\\t\\t\\tstring ans = \"\";\\n\\t\\t\\tsort(A.begin(),A.end());\\n\\t\\t\\tdo\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstring temp = to_string(A[0])+to_string(A[1])+\":\"\\n\\t\\t\\t\\t\\t\\t+to_string(A[2])+to_string(A[3]);\\n\\t\\t\\t\\t\\tif(temp > ans) ans = temp;\\n\\t\\t\\t\\t}       \\n\\t\\t\\t}while(next_permutation(A.begin(),A.end()));\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring largestTimeFromDigits(vector<int>& A) {\\n\\t\\t\\tstring ans = \"\";\\n\\t\\t\\tsort(A.begin(),A.end());\\n\\t\\t\\tdo\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstring temp = to_string(A[0])+to_string(A[1])+\":\"\\n\\t\\t\\t\\t\\t\\t+to_string(A[2])+to_string(A[3]);\\n\\t\\t\\t\\t\\tif(temp > ans) ans = temp;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 450045,
                "title": "java-greedy-dfs-backtracking-solution-very-easy-to-understand-1ms",
                "content": "Since we want to find the max, we should try the max digit allowed from left to right.\\nFor exmaple, at the first digit, we can try 2, then 1, then 0.\\nat the 2nd digit, if the 1st on is 2, we try 3,2,....,0. Otherwise, try 9,8,7,....,1,0.\\nSince we are following the numerical order, it guarantees that the first permutarion found by the DFS helper is the max.  \\n```\\nclass Solution {\\n    boolean helper(int[] count, int loc, int[] ret) {\\n        if (loc > 3) return true;\\n        int e = 9;\\n        if (loc==0) {\\n            e = 2;\\n        } else if (loc==1) {\\n            if (ret[0]==2) e = 3;\\n        } else if (loc==2) {\\n            e = 5;\\n        }\\n        \\n        for (int i=e; i>=0; i--) {\\n            if (count[i]> 0) {\\n                ret[loc] = i;\\n                count[i]--;\\n                if (helper(count, loc+1, ret)) return true;\\n                count[i]++;\\n                ret[loc] = -1;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        int[] ret = new int[4];\\n        Arrays.fill(ret, -1);\\n        int[] count = new int[10];\\n        for (int a: A) count[a]++;\\n        if (helper(count, 0, ret)) {\\n            return \"\"+ret[0]+ret[1]+\":\"+ret[2]+ret[3];\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean helper(int[] count, int loc, int[] ret) {\\n        if (loc > 3) return true;\\n        int e = 9;\\n        if (loc==0) {\\n            e = 2;\\n        } else if (loc==1) {\\n            if (ret[0]==2) e = 3;\\n        } else if (loc==2) {\\n            e = 5;\\n        }\\n        \\n        for (int i=e; i>=0; i--) {\\n            if (count[i]> 0) {\\n                ret[loc] = i;\\n                count[i]--;\\n                if (helper(count, loc+1, ret)) return true;\\n                count[i]++;\\n                ret[loc] = -1;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        int[] ret = new int[4];\\n        Arrays.fill(ret, -1);\\n        int[] count = new int[10];\\n        for (int a: A) count[a]++;\\n        if (helper(count, 0, ret)) {\\n            return \"\"+ret[0]+ret[1]+\":\"+ret[2]+ret[3];\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536484,
                "title": "python3-easy-understanding-with-explanation",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n# From 23:59 to 00:00 go over every minute of 24 hours. If A meets this requirement, then totaly 24 * 60 minutes. Since using sort during the ongoing judegment process, so the time complexity is low.\\n        A.sort()\\n        for h in range(23, -1, -1):\\n            for m in range(59, -1, -1):\\n                t = [h//10, h % 10, m // 10, m % 10]\\n                ts = sorted(t)\\n                if ts == A:\\n                    return str(t[0]) + str(t[1]) +\\':\\' + str(t[2]) + str(t[3])\\n        return \\'\\'\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n# From 23:59 to 00:00 go over every minute of 24 hours. If A meets this requirement, then totaly 24 * 60 minutes. Since using sort during the ongoing judegment process, so the time complexity is low.\\n        A.sort()\\n        for h in range(23, -1, -1):\\n            for m in range(59, -1, -1):\\n                t = [h//10, h % 10, m // 10, m % 10]\\n                ts = sorted(t)\\n                if ts == A:\\n                    return str(t[0]) + str(t[1]) +\\':\\' + str(t[2]) + str(t[3])\\n        return \\'\\'\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 823156,
                "title": "python-simple-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=QJeI-gBTp1k)\\nhttps://www.youtube.com/watch?v=QJeI-gBTp1k\\n```\\nfrom itertools import permutations\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        arr = list(permutations(sorted(A, reverse=True)))\\n        \\n        for h1, h2, m1, m2 in arr:\\n            if h1 * 10 + h2 < 24 and m1 * 10 + m2 < 60:\\n                return f\\'{h1}{h2}:{m1}{m2}\\'\\n        return \\'\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom itertools import permutations\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        arr = list(permutations(sorted(A, reverse=True)))\\n        \\n        for h1, h2, m1, m2 in arr:\\n            if h1 * 10 + h2 < 24 and m1 * 10 + m2 < 60:\\n                return f\\'{h1}{h2}:{m1}{m2}\\'\\n        return \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200823,
                "title": "java-iterative-15-lines",
                "content": "```java\\npublic String largestTimeFromDigits(int[] a) {\\n        LinkedList<String> q = new LinkedList<>();\\n        q.add(\"\");\\n        for (int n : a)\\n            for (int size = q.size(); size > 0; size--) {\\n                String s = q.poll();\\n                for (int i = 0; i <= s.length(); i++)\\n                    q.add(s.substring(0, i) + n + s.substring(i));\\n            }\\n        String largest = \"\";\\n        for (String s : q) {\\n            s = s.substring(0, 2) + \":\" + s.substring(2);\\n            if (s.charAt(3) < \\'6\\' && s.compareTo(\"24:00\") < 0 && s.compareTo(largest) > 0)\\n                largest = s;\\n        }\\n        return largest;\\n    }",
                "solutionTags": [],
                "code": "```java\\npublic String largestTimeFromDigits(int[] a) {\\n        LinkedList<String> q = new LinkedList<>();\\n        q.add(\"\");\\n        for (int n : a)\\n            for (int size = q.size(); size > 0; size--) {\\n                String s = q.poll();\\n                for (int i = 0; i <= s.length(); i++)\\n                    q.add(s.substring(0, i) + n + s.substring(i));\\n            }\\n        String largest = \"\";\\n        for (String s : q) {\\n            s = s.substring(0, 2) + \":\" + s.substring(2);\\n            if (s.charAt(3) < \\'6\\' && s.compareTo(\"24:00\") < 0 && s.compareTo(largest) > 0)\\n                largest = s;\\n        }\\n        return largest;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 207126,
                "title": "elegant-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        string res = \"\";\\n        do {\\n            string hours = {(char)(A[0] + \\'0\\'), (char)(A[1] + \\'0\\')}, minutes = {(char)(A[2] + \\'0\\'), (char)(A[3] + \\'0\\')};\\n            res = (stoi(hours) <= 23 && stoi(minutes) <= 59) ? (hours + \":\" + minutes) : res;\\n        } while(next_permutation(A.begin(), A.end()));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        string res = \"\";\\n        do {\\n            string hours = {(char)(A[0] + \\'0\\'), (char)(A[1] + \\'0\\')}, minutes = {(char)(A[2] + \\'0\\'), (char)(A[3] + \\'0\\')};\\n            res = (stoi(hours) <= 23 && stoi(minutes) <= 59) ? (hours + \":\" + minutes) : res;\\n        } while(next_permutation(A.begin(), A.end()));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823706,
                "title": "find-all-permutations-easy-to-understand-solution-with-steps",
                "content": "**Steps :**\\n1) Sort the input array\\n2) Find all the valid permutations and store in a list\\n3) Since the list is sorted, the last element in the list is our required timestamp\\n4) If list is empty then return an empty string\\n\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        \\n        Arrays.sort(A);\\n                \\n        List<String> list = new ArrayList<>();\\n        \\n        findValidPermutations(A, list, new StringBuilder(), new boolean[A.length]);\\n        \\n        if(list.size() == 0)\\n            return \"\";\\n        \\n        String lastString = list.get(list.size() - 1);\\n        \\n        return formatTimeStamp(lastString);\\n        \\n    }\\n    \\n    private void findValidPermutations(int[] A, List<String> list, StringBuilder sb, boolean[] used){\\n        \\n        if(sb.length() == A.length){\\n            if(isValid(sb.toString()))\\n                list.add(sb.toString());\\n            return;\\n        }\\n        \\n        for(int i = 0; i < A.length; i++){\\n            \\n            if(used[i])\\n                continue;\\n            \\n            if(i > 0 && A[i] == A[i-1] && !used[i - 1])\\n                continue;\\n            \\n            used[i] = true;\\n            sb.append(A[i]);\\n            \\n            findValidPermutations(A, list, sb, used);\\n            \\n            sb.deleteCharAt(sb.length() - 1);\\n            used[i] = false;\\n        }\\n    }\\n    \\n    private boolean isValid(String str){\\n        \\n        int hour = Integer.valueOf( str.substring(0,2));\\n        int minute = Integer.valueOf( str.substring(2, 4));\\n \\n        return hour < 24 && minute <= 59;\\n        \\n    }\\n    \\n    private String formatTimeStamp(String str){\\n        \\n        String hour = str.substring(0,2);\\n        String minute = str.substring(2,4);\\n        \\n        return hour + \":\" + minute;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        \\n        Arrays.sort(A);\\n                \\n        List<String> list = new ArrayList<>();\\n        \\n        findValidPermutations(A, list, new StringBuilder(), new boolean[A.length]);\\n        \\n        if(list.size() == 0)\\n            return \"\";\\n        \\n        String lastString = list.get(list.size() - 1);\\n        \\n        return formatTimeStamp(lastString);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 823571,
                "title": "java-detailed-short-code-answer-array-permutation-followed-by-the-validity-check",
                "content": "To do so, we first need to perform the **permutation** of the array number, then pick all the **valid time combination** and find the **max** one. Here is the code:\\n```\\n    public String largestTimeFromDigits(int[] A) {\\n        int ans = -1; // If we cannot find a valid answer, it will keep as -1, then we will return \"\".\\n        // Choose different indices i, j, k, l as a permutation of 0, 1, 2, 3\\n        for (int i = 0; i < 4; ++i)\\n            for (int j = 0; j < 4; ++j) if (j != i)\\n                for (int k = 0; k < 4; ++k) if (k != i && k != j) {\\n                    int l = 6 - i - j - k;\\n                    // For each permutation of A[i], read out the time and\\n                    // record the largest legal time.\\n                    int hours = 10 * A[i] + A[j];\\n                    int mins = 10 * A[k] + A[l];\\n                    if (hours < 24  &&  mins < 60)\\n                        ans = Math.max(ans, hours * 60 + mins);\\n                }\\n        return ans >= 0 ? String.format(\"%02d:%02d\", ans / 60, ans % 60) : \"\";\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public String largestTimeFromDigits(int[] A) {\\n        int ans = -1; // If we cannot find a valid answer, it will keep as -1, then we will return \"\".\\n        // Choose different indices i, j, k, l as a permutation of 0, 1, 2, 3\\n        for (int i = 0; i < 4; ++i)\\n            for (int j = 0; j < 4; ++j) if (j != i)\\n                for (int k = 0; k < 4; ++k) if (k != i && k != j) {\\n                    int l = 6 - i - j - k;\\n                    // For each permutation of A[i], read out the time and\\n                    // record the largest legal time.\\n                    int hours = 10 * A[i] + A[j];\\n                    int mins = 10 * A[k] + A[l];\\n                    if (hours < 24  &&  mins < 60)\\n                        ans = Math.max(ans, hours * 60 + mins);\\n                }\\n        return ans >= 0 ? String.format(\"%02d:%02d\", ans / 60, ans % 60) : \"\";\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823132,
                "title": "c-very-easy-newbie-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans=\"\";\\n        string res=\"\";\\n        for(auto i:A)\\n        {\\n            res+=to_string(i);\\n        }\\n        \\n        sort(res.begin(),res.end());\\n        do\\n        {\\n            string sub1=res.substr(0,2);\\n            string sub2=res.substr(2);\\n            int f=stoi(sub1);\\n            int sec=stoi(sub2);\\n            if(f>=0&&f<=23&&sec>=0&&sec<=59)\\n            {\\n                ans=max(ans,sub1+\":\"+sub2);\\n            }\\n           \\n        }while(next_permutation(res.begin(),res.end()));\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans=\"\";\\n        string res=\"\";\\n        for(auto i:A)\\n        {\\n            res+=to_string(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 822956,
                "title": "c-simple-step-by-step-solution-explained-100-time-55-space",
                "content": "Man, wasn\\'t this the tricky one! But my bad for trying to filter too many edge cases initially, instead of trusting the rest of my logic a bit more.\\n\\nAnyway, let\\'s go with first things first: I declared a couple of class variables: `res` (our result) and `digits`, an array to store the frequency of the digits, so that they could be used by my helper `addMaxEqualLowerThan`, which in turn was created to avoid needless code duplications.\\n\\nThe harder part is to form the largest possible HH part with our digits: if we do that, the rest is relatively simple, as we just need to create the largest possible MM part.\\n\\nTo do so, we need to consider a few more things, but let\\'s move on with the logic: first of all we need to populate `digits` so that it has the frequency of the digit `i` stored in the `i`th cell.\\n\\nOnce we have done that, we can quickly loop through it and check our exit conditions:\\n* having reached `i == 2` and having `sum == 0` means we cannot form any hour;\\n* being at `i == 3` and having `sum == 1` when `digits[2] != 0` again means we cannot form hours (ie: we only have a `2` in that range);\\n* being at `i == 5` and having `sum < 2` means we might be able to form a hour, but then we would like a necessary digit (`<= 5`) for the minutes.\\n\\nIf did not return `res` and are still going on, time to check immediately for the best case: HH starting with `2`, a case we consider onlu if `sum > 2` (and, incidentally, the sole reason for which I did not make `sum` an internal variable of the second loop).\\n\\nWe add `2` (in this specific instance, since we know that `digits[2]`, `addMaxEqualLowerThan(2)` is equivalent to `digits[2]--; res.push_back(\\'2\\');` and then we call our helper again to get any digit `<= 3`; if by then our solution `reas` is still just `\"2\"`, we backtrack, resetting `res` to be empty.\\n\\nIf that was the case, we just invoke our helper to add any digit `<= 1`, followed by any digit `<= 9` (which would be just any digit, period, I guess?).\\n\\nTime to add `\\':\\'` and to easily slide into the MM part: we add any digit `<= 5`, followed by any digit `<= 9`.\\n\\nIf by any chance by now we got a `res` under `5` characters of length, we return an empty string, otherwise we return our successfully computed largest possible time :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\n    // support variables\\n\\tstring res;\\n    int digits[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, sum = 0;\\npublic:\\n    void addMaxEqualLowerThan(int n) {\\n        // updates both res and digits with/for the bigger number <=n\\n\\t\\tfor (int i = n; i >= 0; i--) if (digits[i]) {\\n            res.push_back(i + \\'0\\');\\n            digits[i]--;\\n            break;\\n        }\\n    }\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        // populating digits\\n\\t\\tfor (int i = 0; i < 4; i++) digits[arr[i]]++;\\n        // exit condition: no single digit less than 3, no 2 digits less than 6\\n        for (int i = 0; i < 6; i++) {\\n            sum += digits[i];\\n            if (i == 2 && !sum || i == 3 && digits[2] && sum < 2 || i ==5 && sum < 2) return res;\\n        }\\n        // checking for 2, trickier case\\n        if (digits[2] && sum > 2) {\\n            addMaxEqualLowerThan(2);\\n            addMaxEqualLowerThan(3);\\n            // if not such a number is found, we fold and move to the next\\n            if (res == \"2\") {\\n                digits[2]++;\\n                res = \"\";\\n            }\\n        }\\n        // checking for 1 and 0\\n        if (!res.size()) {\\n            addMaxEqualLowerThan(1);\\n            addMaxEqualLowerThan(9);\\n        }\\n        // and we are done with the hours\\n        res.push_back(\\':\\');\\n        // now with the mins\\n        addMaxEqualLowerThan(5);\\n        addMaxEqualLowerThan(9);\\n        return res.size() == 5 ? res : \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\n    // support variables\\n\\tstring res;\\n    int digits[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, sum = 0;\\npublic:\\n    void addMaxEqualLowerThan(int n) {\\n        // updates both res and digits with/for the bigger number <=n\\n\\t\\tfor (int i = n; i >= 0; i--) if (digits[i]) {\\n            res.push_back(i + \\'0\\');\\n            digits[i]--;\\n            break;\\n        }\\n    }\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        // populating digits\\n\\t\\tfor (int i = 0; i < 4; i++) digits[arr[i]]++;\\n        // exit condition: no single digit less than 3, no 2 digits less than 6\\n        for (int i = 0; i < 6; i++) {\\n            sum += digits[i];\\n            if (i == 2 && !sum || i == 3 && digits[2] && sum < 2 || i ==5 && sum < 2) return res;\\n        }\\n        // checking for 2, trickier case\\n        if (digits[2] && sum > 2) {\\n            addMaxEqualLowerThan(2);\\n            addMaxEqualLowerThan(3);\\n            // if not such a number is found, we fold and move to the next\\n            if (res == \"2\") {\\n                digits[2]++;\\n                res = \"\";\\n            }\\n        }\\n        // checking for 1 and 0\\n        if (!res.size()) {\\n            addMaxEqualLowerThan(1);\\n            addMaxEqualLowerThan(9);\\n        }\\n        // and we are done with the hours\\n        res.push_back(\\':\\');\\n        // now with the mins\\n        addMaxEqualLowerThan(5);\\n        addMaxEqualLowerThan(9);\\n        return res.size() == 5 ? res : \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822907,
                "title": "python-simplest-explained-easy-to-understand-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        # help function to turn number to clock-format:\\n        def to_clock(num):\\n            right = str(num%100)\\n            while len(right) < 2: right = \\'0\\' + right\\n            num //= 100\\n            left = str(num)\\n            while len(left) < 2: left = \\'0\\' + left\\n            return left + \\':\\' + right\\n                \\n        # get all permutations of number list\\n        per = list(itertools.permutations(A))\\n        nums = [int(\\'\\'.join(map(str,per[i]))) for i in range(len(per))]\\n        \\n        # find permutations which can be a valid time\\n        valids = [num for num in nums if num<2359 and num%100<60]\\n        \\n        if len(valids) == 0:\\n            return \"\"\\n        \\n        # use maximum of list\\n        num = max(valids)\\n        return to_clock(num)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        # help function to turn number to clock-format:\\n        def to_clock(num):\\n            right = str(num%100)\\n            while len(right) < 2: right = \\'0\\' + right\\n            num //= 100\\n            left = str(num)\\n            while len(left) < 2: left = \\'0\\' + left\\n            return left + \\':\\' + right\\n                \\n        # get all permutations of number list\\n        per = list(itertools.permutations(A))\\n        nums = [int(\\'\\'.join(map(str,per[i]))) for i in range(len(per))]\\n        \\n        # find permutations which can be a valid time\\n        valids = [num for num in nums if num<2359 and num%100<60]\\n        \\n        if len(valids) == 0:\\n            return \"\"\\n        \\n        # use maximum of list\\n        num = max(valids)\\n        return to_clock(num)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 823747,
                "title": "java-solution-easy-code",
                "content": "* ***Please upvote if helpful!!***\\n\\n```\\nclass Solution {\\n    List<List<Integer>> resultList = new ArrayList<>();\\n    public String largestTimeFromDigits(int[] numArray) {\\n\\n        if (numArray[0] == 0 && numArray[1] == 0 && numArray[2] == 0 && numArray[3] == 0) return \"00:00\";\\n\\n        String result = \"\";\\n        boolean[] visited = new boolean[numArray.length];\\n        findPermutation(numArray, new ArrayList<>(), visited);\\n        int maxNum = Integer.MIN_VALUE;\\n        int firstDigit = -1;\\n        int secondDigit = -1;\\n        int thirdDigit = -1;\\n        int fourthDigit = -1;\\n\\n        int f = 0;\\n        int s = 0;\\n        int t = 0;\\n        int fo = 0;\\n        boolean isVisited = false;\\n        for (List<Integer> list : resultList) {\\n\\n            firstDigit = list.get(0);\\n            secondDigit = list.get(1);\\n            thirdDigit = list.get(2);\\n            fourthDigit = list.get(3);\\n            int num = firstDigit * 1000 + secondDigit * 100 + thirdDigit * 10 + fourthDigit;\\n            if (num <= 2359 && thirdDigit < 6 && num > maxNum) {\\n                isVisited = true;\\n                maxNum = num;\\n                f = list.get(0);\\n                s = list.get(1);\\n                t = list.get(2);\\n                fo = list.get(3);\\n            }\\n\\n        }\\n\\n        if (isVisited)\\n            result = f + \"\" + s + \":\" + t + \"\" + fo;\\n        else\\n            result = \"\";\\n        return result;\\n\\n\\n    }\\n\\n    private void findPermutation(int[] numArray, List<Integer> currList, boolean[] visited) {\\n\\n        if (currList.size() == numArray.length) {\\n            resultList.add(new ArrayList<>(currList));\\n            return;\\n        }\\n\\n        for (int i = 0; i < numArray.length; i++) {\\n            if (visited[i]) continue;\\n            visited[i] = true;\\n            currList.add(numArray[i]);\\n            findPermutation(numArray, currList, visited);\\n            currList.remove(currList.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> resultList = new ArrayList<>();\\n    public String largestTimeFromDigits(int[] numArray) {\\n\\n        if (numArray[0] == 0 && numArray[1] == 0 && numArray[2] == 0 && numArray[3] == 0) return \"00:00\";\\n\\n        String result = \"\";\\n        boolean[] visited = new boolean[numArray.length];\\n        findPermutation(numArray, new ArrayList<>(), visited);\\n        int maxNum = Integer.MIN_VALUE;\\n        int firstDigit = -1;\\n        int secondDigit = -1;\\n        int thirdDigit = -1;\\n        int fourthDigit = -1;\\n\\n        int f = 0;\\n        int s = 0;\\n        int t = 0;\\n        int fo = 0;\\n        boolean isVisited = false;\\n        for (List<Integer> list : resultList) {\\n\\n            firstDigit = list.get(0);\\n            secondDigit = list.get(1);\\n            thirdDigit = list.get(2);\\n            fourthDigit = list.get(3);\\n            int num = firstDigit * 1000 + secondDigit * 100 + thirdDigit * 10 + fourthDigit;\\n            if (num <= 2359 && thirdDigit < 6 && num > maxNum) {\\n                isVisited = true;\\n                maxNum = num;\\n                f = list.get(0);\\n                s = list.get(1);\\n                t = list.get(2);\\n                fo = list.get(3);\\n            }\\n\\n        }\\n\\n        if (isVisited)\\n            result = f + \"\" + s + \":\" + t + \"\" + fo;\\n        else\\n            result = \"\";\\n        return result;\\n\\n\\n    }\\n\\n    private void findPermutation(int[] numArray, List<Integer> currList, boolean[] visited) {\\n\\n        if (currList.size() == numArray.length) {\\n            resultList.add(new ArrayList<>(currList));\\n            return;\\n        }\\n\\n        for (int i = 0; i < numArray.length; i++) {\\n            if (visited[i]) continue;\\n            visited[i] = true;\\n            currList.add(numArray[i]);\\n            findPermutation(numArray, currList, visited);\\n            currList.remove(currList.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823627,
                "title": "python-3-largest-time-for-given-digits",
                "content": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n\\t\\t # if 0, 1 or 2 is not present in the list then just return blank\\n        if 0 not in A and 1 not in A and 2 not in A:\\n            return \"\"\\n    \\n        max_time= \"-9\"\\n        # generate all the permuations of given digits\\n        for i in set(list(permutations(A))):    \\n\\t\\t    # keep time starting with either 0, 1, or 2. Others are invalid range.\\n            if 0 <= i[0] <= 2:    \\n                temp = str(\\'\\'.join(str(t) for t in i))\\n\\t\\t\\t\\t # check for 23:59 constraint\\n                if int(temp) <= 2359 and int(temp[2:]) < 60:    \\n                    if int(temp) > int(max_time):\\n                        max_time = temp\\n        \\n        \\n        if max_time == \"-9\":\\n            return \"\"\\n        else:\\n            return max_time[:2]+\":\"+max_time[2:]\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n\\t\\t # if 0, 1 or 2 is not present in the list then just return blank\\n        if 0 not in A and 1 not in A and 2 not in A:\\n            return \"\"\\n    \\n        max_time= \"-9\"\\n        # generate all the permuations of given digits\\n        for i in set(list(permutations(A))):    \\n\\t\\t    # keep time starting with either 0, 1, or 2. Others are invalid range.\\n            if 0 <= i[0] <= 2:    \\n                temp = str(\\'\\'.join(str(t) for t in i))\\n\\t\\t\\t\\t # check for 23:59 constraint\\n                if int(temp) <= 2359 and int(temp[2:]) < 60:    \\n                    if int(temp) > int(max_time):\\n                        max_time = temp\\n        \\n        \\n        if max_time == \"-9\":\\n            return \"\"\\n        else:\\n            return max_time[:2]+\":\"+max_time[2:]\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 244890,
                "title": "java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public static String largestTimeFromDigits(int[] A) {\\n        StringBuilder res = backtrack(new StringBuilder(), new StringBuilder(), A, new boolean[A.length]);\\n        if(res.length() == 4) {\\n        \\tres.insert(2,\":\");\\n        \\treturn res.toString();\\n        }else {\\n        \\treturn res.toString();\\n        }\\n    }\\n    \\n    private static StringBuilder backtrack(StringBuilder res, StringBuilder temp, int[] A, boolean[] used){\\n        if(temp.length() == 4 && Integer.valueOf(temp.toString()) <= 2359\\n           && Integer.valueOf(temp.substring(2).toString()) < 60){\\n            int tempTime = Integer.valueOf(temp.toString());\\n            return res.length() == 0 ? new StringBuilder(temp) : Integer.valueOf(res.toString()) > tempTime ? res : new StringBuilder(temp);\\n        }else{\\n            for(int i = 0; i < A.length; i++){\\n                if(used[i] || i > 0 && A[i] == A[i-1] && !used[i-1]) continue;\\n                used[i] = true;\\n                temp.append(A[i]);\\n                res = backtrack(res, temp, A, used);\\n                used[i] = false;\\n                temp.deleteCharAt(temp.length() - 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static String largestTimeFromDigits(int[] A) {\\n        StringBuilder res = backtrack(new StringBuilder(), new StringBuilder(), A, new boolean[A.length]);\\n        if(res.length() == 4) {\\n        \\tres.insert(2,\":\");\\n        \\treturn res.toString();\\n        }else {\\n        \\treturn res.toString();\\n        }\\n    }\\n    \\n    private static StringBuilder backtrack(StringBuilder res, StringBuilder temp, int[] A, boolean[] used){\\n        if(temp.length() == 4 && Integer.valueOf(temp.toString()) <= 2359\\n           && Integer.valueOf(temp.substring(2).toString()) < 60){\\n            int tempTime = Integer.valueOf(temp.toString());\\n            return res.length() == 0 ? new StringBuilder(temp) : Integer.valueOf(res.toString()) > tempTime ? res : new StringBuilder(temp);\\n        }else{\\n            for(int i = 0; i < A.length; i++){\\n                if(used[i] || i > 0 && A[i] == A[i-1] && !used[i-1]) continue;\\n                used[i] = true;\\n                temp.append(A[i]);\\n                res = backtrack(res, temp, A, used);\\n                used[i] = false;\\n                temp.deleteCharAt(temp.length() - 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529280,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        do{\\n            int hours = arr[0] * 10 + arr[1];\\n            int minutes = arr[2] * 10 + arr[3];\\n            \\n            if(hours<24 && minutes<60){\\n                string time = \"\";\\n                if(hours<10){\\n                    time+=\"0\";\\n                }\\n                time += to_string(hours);\\n                time += \":\";\\n                \\n                if(minutes<10){\\n                    time += \"0\";\\n                }\\n                \\n                time += to_string(minutes);\\n                return time;\\n            }\\n        }while(prev_permutation(arr.begin(), arr.end()));\\n        \\n        return \"\";\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        curMax = -1\\n        curStr = \"\"\\n        for permutation in set(permutations(arr)):\\n            a, b, c, d = permutation\\n            hours = a*10 + b\\n            minutes = c*10 + d\\n            if hours > 23 or minutes > 59:\\n                pass\\n            elif hours*60 + minutes > curMax:\\n                curMax = hours*60 + minutes\\n                curStr = str(a) + str(b) + \":\" + str(c) + str(d)\\n\\n        return curStr\\n```\\n\\n```Java []\\nclass Solution {\\n    private boolean rearrange(int maxValue,int index,int[] a){\\n        int max = -1;\\n\\t\\t\\n        for(int i = index; i<a.length;i++) if(a[i]<=maxValue && (max==-1 || a[max]<a[i])) max = i;\\n        if(max==-1) return false;\\n\\n        int temp = a[max];\\n        a[max] = a[index];\\n        a[index] = temp;\\n        return true;\\n    }\\n    public String largestTimeFromDigits(int[] a) {\\n        boolean res = (rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a)) || (rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a));\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if(!res) return sb.toString();\\n        \\n        return sb.append(String.valueOf(a[0]))\\n          .append(String.valueOf(a[1]))\\n          .append(\\':\\')\\n          .append(String.valueOf(a[2]))\\n          .append(String.valueOf(a[3])).toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        do{\\n            int hours = arr[0] * 10 + arr[1];\\n            int minutes = arr[2] * 10 + arr[3];\\n            \\n            if(hours<24 && minutes<60){\\n                string time = \"\";\\n                if(hours<10){\\n                    time+=\"0\";\\n                }\\n                time += to_string(hours);\\n                time += \":\";\\n                \\n                if(minutes<10){\\n                    time += \"0\";\\n                }\\n                \\n                time += to_string(minutes);\\n                return time;\\n            }\\n        }while(prev_permutation(arr.begin(), arr.end()));\\n        \\n        return \"\";\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        curMax = -1\\n        curStr = \"\"\\n        for permutation in set(permutations(arr)):\\n            a, b, c, d = permutation\\n            hours = a*10 + b\\n            minutes = c*10 + d\\n            if hours > 23 or minutes > 59:\\n                pass\\n            elif hours*60 + minutes > curMax:\\n                curMax = hours*60 + minutes\\n                curStr = str(a) + str(b) + \":\" + str(c) + str(d)\\n\\n        return curStr\\n```\n```Java []\\nclass Solution {\\n    private boolean rearrange(int maxValue,int index,int[] a){\\n        int max = -1;\\n\\t\\t\\n        for(int i = index; i<a.length;i++) if(a[i]<=maxValue && (max==-1 || a[max]<a[i])) max = i;\\n        if(max==-1) return false;\\n\\n        int temp = a[max];\\n        a[max] = a[index];\\n        a[index] = temp;\\n        return true;\\n    }\\n    public String largestTimeFromDigits(int[] a) {\\n        boolean res = (rearrange(2,0,a) && (a[0]==2 ? rearrange(3,1,a) : rearrange(9,1,a)) && rearrange(5,2,a) && rearrange(9,3,a)) || (rearrange(1,0,a) && rearrange(9,1,a) && rearrange(5,2,a) && rearrange(9,3,a));\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if(!res) return sb.toString();\\n        \\n        return sb.append(String.valueOf(a[0]))\\n          .append(String.valueOf(a[1]))\\n          .append(\\':\\')\\n          .append(String.valueOf(a[2]))\\n          .append(String.valueOf(a[3])).toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636459,
                "title": "python3-8-lines-permutations-t-m-96-78",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\n        ans = []\\n\\n        for d0, d1, d2, d3 in list(permutations(arr,4)):\\n            hrs, mins = 10*d0+d1, 10*d2+d3\\n\\n            if hrs < 24 and mins < 60:\\n                ans.append((hrs,mins))\\n\\n        if not ans: return \\'\\'        \\n        hrs, mins = max(ans)\\n        return  str(hrs).rjust(2,\\'0\\')+\\':\\'+ str(mins).rjust(2,\\'0\\') \\n```\\n\\n\\n[https://leetcode.com/submissions/detail/810938755/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\n        ans = []\\n\\n        for d0, d1, d2, d3 in list(permutations(arr,4)):\\n            hrs, mins = 10*d0+d1, 10*d2+d3\\n\\n            if hrs < 24 and mins < 60:\\n                ans.append((hrs,mins))\\n\\n        if not ans: return \\'\\'        \\n        hrs, mins = max(ans)\\n        return  str(hrs).rjust(2,\\'0\\')+\\':\\'+ str(mins).rjust(2,\\'0\\') \\n```",
                "codeTag": "Java"
            },
            {
                "id": 824095,
                "title": "94-62-javascript-clean-backtracking-with-short-circuit-optimization",
                "content": "```javascript\\nvar largestTimeFromDigits = function(A) {\\n    let res = \\'\\';\\n    \\n    function permute(arr, str) {\\n        if(str.length === 4) {\\n            if(+str >= +res) res = str;\\n            return;\\n        }\\n        \\n        for(let i = 0; i < arr.length; i++) {\\n            if(!str.length && arr[i] > 2) continue;\\n            if(str.length == 1 && str[0] == \\'2\\' && arr[i] > 3) continue;\\n            if(str.length == 2 && arr[i] > 5) continue;\\n            permute([...arr.slice(0, i), ...arr.slice(i+1)], str+arr[i]);\\n        }\\n    }\\n    permute(A, \\'\\');\\n    return res.slice(0, 2) + (res.length ? \\':\\' : \\'\\') + res.slice(2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar largestTimeFromDigits = function(A) {\\n    let res = \\'\\';\\n    \\n    function permute(arr, str) {\\n        if(str.length === 4) {\\n            if(+str >= +res) res = str;\\n            return;\\n        }\\n        \\n        for(let i = 0; i < arr.length; i++) {\\n            if(!str.length && arr[i] > 2) continue;\\n            if(str.length == 1 && str[0] == \\'2\\' && arr[i] > 3) continue;\\n            if(str.length == 2 && arr[i] > 5) continue;\\n            permute([...arr.slice(0, i), ...arr.slice(i+1)], str+arr[i]);\\n        }\\n    }\\n    permute(A, \\'\\');\\n    return res.slice(0, 2) + (res.length ? \\':\\' : \\'\\') + res.slice(2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 712038,
                "title": "c-4-ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string result = \"\";\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<4;j++){\\n                for(int k=0;k<4;k++){\\n                    if( i == j || j == k || k == i ){\\n                        continue;\\n                    }\\n                    string hours = to_string(A[i]) + to_string(A[j]),\\n                           minutes = to_string(A[k]) + to_string(A[6-i-j-k]),\\n                           time = hours + \":\" + minutes;\\n                    if(hours < \"24\" && minutes < \"60\" && result < time){\\n                        result = time;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string result = \"\";\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<4;j++){\\n                for(int k=0;k<4;k++){\\n                    if( i == j || j == k || k == i ){\\n                        continue;\\n                    }\\n                    string hours = to_string(A[i]) + to_string(A[j]),\\n                           minutes = to_string(A[k]) + to_string(A[6-i-j-k]),\\n                           time = hours + \":\" + minutes;\\n                    if(hours < \"24\" && minutes < \"60\" && result < time){\\n                        result = time;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919164,
                "title": "c-faster-than-100-backtracking-solution",
                "content": "# Code\\n```\\nclass Solution {\\n\\nprivate:\\n\\n    int maxTime = INT_MIN;\\n    string answer = \"\";\\n\\n    void helper(vector<int> &arr, string res, vector<bool> &visited){\\n\\n        if(visited[0] and visited[1] and visited[2] and visited[3]){\\n            if(getTime(res) > maxTime){\\n                maxTime = getTime(res);\\n                answer = res;\\n            }\\n            return;\\n        }\\n\\n        for(int i = 0 ; i < 4 ; i++){\\n            if(!visited[i]){\\n                visited[i] = true;\\n                res += to_string(arr[i]);\\n                helper(arr, res, visited);\\n                visited[i] = false;\\n                res.pop_back();\\n            }\\n        }\\n    }\\n\\n    int getTime(string res){\\n        int first = res[0] - \\'0\\';\\n        int second = res[1] - \\'0\\';\\n        int third = res[2] - \\'0\\';\\n        int fourth = res[3] - \\'0\\';\\n        int hours = first * 10 + second;\\n        int minutes = third * 10 + fourth;\\n        if(hours > 23 or minutes > 59) return INT_MIN;\\n        return hours * 60 + minutes;\\n    }\\n\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        // Intution\\n        // The solution in here is divided in total into three different steps.\\n        // Finding all the valid strings\\n        vector<bool> visited(4, false);\\n        helper(arr, \"\", visited);\\n        return answer != \"\" ? answer.substr(0, 2) + \":\" + answer.substr(2) : answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n\\n    int maxTime = INT_MIN;\\n    string answer = \"\";\\n\\n    void helper(vector<int> &arr, string res, vector<bool> &visited){\\n\\n        if(visited[0] and visited[1] and visited[2] and visited[3]){\\n            if(getTime(res) > maxTime){\\n                maxTime = getTime(res);\\n                answer = res;\\n            }\\n            return;\\n        }\\n\\n        for(int i = 0 ; i < 4 ; i++){\\n            if(!visited[i]){\\n                visited[i] = true;\\n                res += to_string(arr[i]);\\n                helper(arr, res, visited);\\n                visited[i] = false;\\n                res.pop_back();\\n            }\\n        }\\n    }\\n\\n    int getTime(string res){\\n        int first = res[0] - \\'0\\';\\n        int second = res[1] - \\'0\\';\\n        int third = res[2] - \\'0\\';\\n        int fourth = res[3] - \\'0\\';\\n        int hours = first * 10 + second;\\n        int minutes = third * 10 + fourth;\\n        if(hours > 23 or minutes > 59) return INT_MIN;\\n        return hours * 60 + minutes;\\n    }\\n\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        // Intution\\n        // The solution in here is divided in total into three different steps.\\n        // Finding all the valid strings\\n        vector<bool> visited(4, false);\\n        helper(arr, \"\", visited);\\n        return answer != \"\" ? answer.substr(0, 2) + \":\" + answer.substr(2) : answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604515,
                "title": "python3-o-1-solution-without-using-in-built-functions",
                "content": "```\\nclass Solution:    \\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        res = \\'\\'\\n        for i, a in enumerate(arr):\\n            for j, b in enumerate(arr):\\n                for k, c in enumerate(arr):\\n                    if i == j or i == k or j == k: #avoid duplicates\\n                        continue\\n                    hour, minute = str(a) + str(b), str(c) + str(arr[6 - i - j - k])\\n                    if hour < \\'24\\' and minute < \\'60\\':\\n                        res = max(res, hour + \\':\\' + minute)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:    \\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        res = \\'\\'\\n        for i, a in enumerate(arr):\\n            for j, b in enumerate(arr):\\n                for k, c in enumerate(arr):\\n                    if i == j or i == k or j == k: #avoid duplicates\\n                        continue\\n                    hour, minute = str(a) + str(b), str(c) + str(arr[6 - i - j - k])\\n                    if hour < \\'24\\' and minute < \\'60\\':\\n                        res = max(res, hour + \\':\\' + minute)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370419,
                "title": "c-easiest-solution-ever",
                "content": "class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        \\n       /* let us consider an array as example like :\\n                            arr=[1 2 3 4]\\n                          index==0 1 2 3\\n           sum of the index =(0+1+2+3)=6\\n           \\n     lets assume index i,j for hour and (i!=j) again assume index k,(6-i-j-k) for the      minute given that (i!=j && j!=k && k!=i) and automatically (6-i-j-k) differs      \\n           let\\'s run nested loops to determine largest time in the given range */\\n           \\n        string result=\"\";\\n        \\n        for(int i=0;i<4;i++){\\n            \\n            for(int j=0;j<4;j++){\\n                \\n                for(int k=0;k<4;k++){\\n                    \\n                    if(i==j||j==k||k==i){\\n                        continue;\\n                    }\\n                    \\n                    else{\\n                        \\n                        string hour=\"\";\\n                        hour=to_string(arr[i])+to_string(arr[j]);\\n                        \\n                        string minute=\"\";\\n                        minute=to_string(arr[k])+to_string(arr[6-i-j-k]);\\n                        \\n                        string s=hour+\":\"+minute;\\n                        \\n                        // Condition checking\\n                        \\n                        if(hour<\"24\" && minute<\"60\" && s>result){\\n                            result=s;\\n                        }\\n                        \\n                        \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n        \\n        /* Time Complexity O(4*4*4) , Space Complexity O(1) */\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        \\n       /* let us consider an array as example like :\\n                            arr=[1 2 3 4]\\n                          index==0 1 2 3\\n           sum of the index =(0+1+2+3)=6\\n           \\n     lets assume index i,j for hour and (i!=j) again assume index k,(6-i-j-k) for the      minute given that (i!=j && j!=k && k!=i) and automatically (6-i-j-k) differs      \\n           let\\'s run nested loops to determine largest time in the given range */\\n           \\n        string result=\"\";\\n        \\n        for(int i=0;i<4;i++){\\n            \\n            for(int j=0;j<4;j++){\\n                \\n                for(int k=0;k<4;k++){\\n                    \\n                    if(i==j||j==k||k==i){\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 854491,
                "title": "c-faster-than-100",
                "content": "```\\n\\tstring largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        do {\\n            if (arr[2] > 5) continue;\\n            if (arr[0] == 2 && arr[1] <= 3 || arr[0] == 1 || arr[0] == 0) {\\n                return to_string(arr[0]) + to_string(arr[1]) + \":\" + to_string(arr[2]) + to_string(arr[3]);\\n            }\\n        } while (prev_permutation(arr.begin(), arr.end()));\\n        return \"\";\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tstring largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        do {\\n            if (arr[2] > 5) continue;\\n            if (arr[0] == 2 && arr[1] <= 3 || arr[0] == 1 || arr[0] == 0) {\\n                return to_string(arr[0]) + to_string(arr[1]) + \":\" + to_string(arr[2]) + to_string(arr[3]);\\n            }\\n        } while (prev_permutation(arr.begin(), arr.end()));\\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 824210,
                "title": "python-3-solution",
                "content": "def largestTimeFromDigits(self, A: List[int]) -> str:\\n        maxVal=\"-1\"\\n        \\n        for i in list(permutations(A)):\\n            if 0<=i[0] <=2:\\n                tempVal= str(\\'\\'.join(str(n) for n in i))\\n                if int(tempVal)<2400 and  int(tempVal[2:])<=59 :\\n                    if tempVal > maxVal:\\n                        maxVal=tempVal\\n        if maxVal==\"-1\":\\n            return \"\"\\n        else:\\n            return maxVal[:2]+ \":\" + maxVal[2:]\\n        ``\\n                        \\n",
                "solutionTags": [],
                "code": "def largestTimeFromDigits(self, A: List[int]) -> str:\\n        maxVal=\"-1\"\\n        \\n        for i in list(permutations(A)):\\n            if 0<=i[0] <=2:\\n                tempVal= str(\\'\\'.join(str(n) for n in i))\\n                if int(tempVal)<2400 and  int(tempVal[2:])<=59 :\\n                    if tempVal > maxVal:\\n                        maxVal=tempVal\\n        if maxVal==\"-1\":\\n            return \"\"\\n        else:\\n            return maxVal[:2]+ \":\" + maxVal[2:]\\n        ``\\n                        \\n",
                "codeTag": "Python3"
            },
            {
                "id": 824060,
                "title": "python-using-custom-lt-gt-and-eq",
                "content": "```\\nclass ttime:\\n    def __init__(self, arr):\\n        arr = list(arr)\\n        self.h = arr[0] * 10 + arr[1]\\n        self.m = arr[2] * 10 + arr[3]\\n    \\n    def valid(self):\\n        return 0 <= self.h < 24 and 0 <= self.m < 60\\n    \\n    def __lt__(self, other):\\n        return self.h < other.h or (self.h == other.h and self.m < other.m)\\n    \\n    def __gt__(self, other):\\n        return self.h > other.h or (self.h == other.h and self.m > other.m)\\n    \\n    def __eq__(self, other):\\n        return self.h == other.h and self.m == other.m\\n    \\n    def get_string(self):\\n        return str(self.h).zfill(2) + \\':\\' + str(self.m).zfill(2) \\n    \\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        def permute(perm_arr, perm):\\n            if not perm_arr and ttime(perm).valid(): self.perm_list.append(ttime(perm))\\n            for i in range(len(perm_arr)):\\n                permute(perm_arr[:i] + perm_arr[i + 1:], perm + [perm_arr[i]])\\n        \\n        self.perm_list = []\\n        permute(A, [])\\n        return max(self.perm_list).get_string() if self.perm_list else \"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass ttime:\\n    def __init__(self, arr):\\n        arr = list(arr)\\n        self.h = arr[0] * 10 + arr[1]\\n        self.m = arr[2] * 10 + arr[3]\\n    \\n    def valid(self):\\n        return 0 <= self.h < 24 and 0 <= self.m < 60\\n    \\n    def __lt__(self, other):\\n        return self.h < other.h or (self.h == other.h and self.m < other.m)\\n    \\n    def __gt__(self, other):\\n        return self.h > other.h or (self.h == other.h and self.m > other.m)\\n    \\n    def __eq__(self, other):\\n        return self.h == other.h and self.m == other.m\\n    \\n    def get_string(self):\\n        return str(self.h).zfill(2) + \\':\\' + str(self.m).zfill(2) \\n    \\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        def permute(perm_arr, perm):\\n            if not perm_arr and ttime(perm).valid(): self.perm_list.append(ttime(perm))\\n            for i in range(len(perm_arr)):\\n                permute(perm_arr[:i] + perm_arr[i + 1:], perm + [perm_arr[i]])\\n        \\n        self.perm_list = []\\n        permute(A, [])\\n        return max(self.perm_list).get_string() if self.perm_list else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823752,
                "title": "python-3-today-s-one-liner",
                "content": "Find the max permutation where the first 2 digits are < 24 and the last 2 digits are < 60. Default to empty string if not found.\\n\\n```python\\nclass Solution: largestTimeFromDigits = lambda _,A: max((\\'{}{}:{}{}\\'.format(a,b,c,d) for a,b,c,d in permutations(A) if (a < 2 if a != 2 else b < 4) and c < 6), default=\"\")\\n```\\n\\nWrapped for readability:\\n```python\\nclass Solution: largestTimeFromDigits = lambda _,A: \\\\\\n  max(( \\\\\\n      (\\'{}{}:{}{}\\'.format(a,b,c,d) \\\\\\n      for a,b,c,d in permutations(A) \\\\\\n      if (a < 2 if a != 2 else b < 4) and c < 6 \\\\\\n    ), \\\\\\n    default=\"\")\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution: largestTimeFromDigits = lambda _,A: max((\\'{}{}:{}{}\\'.format(a,b,c,d) for a,b,c,d in permutations(A) if (a < 2 if a != 2 else b < 4) and c < 6), default=\"\")\\n```\n```python\\nclass Solution: largestTimeFromDigits = lambda _,A: \\\\\\n  max(( \\\\\\n      (\\'{}{}:{}{}\\'.format(a,b,c,d) \\\\\\n      for a,b,c,d in permutations(A) \\\\\\n      if (a < 2 if a != 2 else b < 4) and c < 6 \\\\\\n    ), \\\\\\n    default=\"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823371,
                "title": "largest-time-for-given-digits-in-c",
                "content": "Just check all permutations and update hour, minute. If valid result found, format it and return.\\n\\n```\\n\\nbool isValid(int hour, int minute) {\\n  return hour < 24 && minute < 60;\\n}\\n\\nbool isGreater(int hour1, int minute1, int hour2, int minute2) {\\n  return (hour1 > hour2 || (hour1 == hour2 && minute1 > minute2));\\n}\\n\\nvoid checkHourMinite(int tmpHour, int tmpMinute, int* hour, int* minute) {\\n  if (isValid(tmpHour, tmpMinute) && isGreater(tmpHour, tmpMinute, *hour, *minute)) { \\n    *hour = tmpHour;\\n    *minute = tmpMinute; \\n  } \\n}\\n\\nvoid getMaxHourMinutes(int a, int b, int c, int d, int* hour, int* minute) {\\n  checkHourMinite(a * 10 + b, c * 10 + d, hour, minute);\\n  checkHourMinite(a * 10 + b, d * 10 + c, hour, minute);\\n  checkHourMinite(b * 10 + a, c * 10 + d, hour, minute);\\n  checkHourMinite(b * 10 + a, d * 10 + c, hour, minute);\\n\\n  checkHourMinite(c * 10 + d, a * 10 + b, hour, minute);\\n  checkHourMinite(c * 10 + d, b * 10 + a, hour, minute);\\n  checkHourMinite(d * 10 + c, a * 10 + b, hour, minute);\\n  checkHourMinite(d * 10 + c, b * 10 + a, hour, minute); \\n}\\n\\nchar * largestTimeFromDigits(int* A, int ASize){\\n  char* result = malloc(sizeof(char)*6);\\n  result[5] = \\'\\\\0\\';\\n\\n  int ok = 0;\\n\\n  int maxHour = -1;\\n  int maxMinute = -1;\\n  getMaxHourMinutes(A[0], A[1], A[2], A[3], &maxHour, &maxMinute);  \\n  getMaxHourMinutes(A[0], A[2], A[1], A[3], &maxHour, &maxMinute);\\n  getMaxHourMinutes(A[0], A[3], A[1], A[2], &maxHour, &maxMinute); \\n  if (maxHour == -1) {\\n    result[0] = \\'\\\\0\\';\\n  } else {\\n    sprintf(result, \"%02d:%02d\", maxHour, maxMinute);\\n  }\\n\\n  return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nbool isValid(int hour, int minute) {\\n  return hour < 24 && minute < 60;\\n}\\n\\nbool isGreater(int hour1, int minute1, int hour2, int minute2) {\\n  return (hour1 > hour2 || (hour1 == hour2 && minute1 > minute2));\\n}\\n\\nvoid checkHourMinite(int tmpHour, int tmpMinute, int* hour, int* minute) {\\n  if (isValid(tmpHour, tmpMinute) && isGreater(tmpHour, tmpMinute, *hour, *minute)) { \\n    *hour = tmpHour;\\n    *minute = tmpMinute; \\n  } \\n}\\n\\nvoid getMaxHourMinutes(int a, int b, int c, int d, int* hour, int* minute) {\\n  checkHourMinite(a * 10 + b, c * 10 + d, hour, minute);\\n  checkHourMinite(a * 10 + b, d * 10 + c, hour, minute);\\n  checkHourMinite(b * 10 + a, c * 10 + d, hour, minute);\\n  checkHourMinite(b * 10 + a, d * 10 + c, hour, minute);\\n\\n  checkHourMinite(c * 10 + d, a * 10 + b, hour, minute);\\n  checkHourMinite(c * 10 + d, b * 10 + a, hour, minute);\\n  checkHourMinite(d * 10 + c, a * 10 + b, hour, minute);\\n  checkHourMinite(d * 10 + c, b * 10 + a, hour, minute); \\n}\\n\\nchar * largestTimeFromDigits(int* A, int ASize){\\n  char* result = malloc(sizeof(char)*6);\\n  result[5] = \\'\\\\0\\';\\n\\n  int ok = 0;\\n\\n  int maxHour = -1;\\n  int maxMinute = -1;\\n  getMaxHourMinutes(A[0], A[1], A[2], A[3], &maxHour, &maxMinute);  \\n  getMaxHourMinutes(A[0], A[2], A[1], A[3], &maxHour, &maxMinute);\\n  getMaxHourMinutes(A[0], A[3], A[1], A[2], &maxHour, &maxMinute); \\n  if (maxHour == -1) {\\n    result[0] = \\'\\\\0\\';\\n  } else {\\n    sprintf(result, \"%02d:%02d\", maxHour, maxMinute);\\n  }\\n\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823341,
                "title": "java-10lines-easy",
                "content": "```\\npublic String largestTimeFromDigits(int[] A) {\\n        String res = \"\";\\n        for(int i =0; i< 4;i++){\\n            for(int j = 0; j < 4;j++){\\n                for(int k = 0; k < 4; k++){\\n                    if(i == j || j == k || i == k) continue;\\n                    String hour = A[i] + \"\" + A[j];\\n                    String min = A[k] + \"\" + A[6-i-j-k];\\n                    String time = hour + \":\" + min;\\n                    if(hour.compareTo(\"24\") < 0 && min.compareTo(\"60\") < 0)\\n                        res = res.compareTo(time) < 0 ? time : res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String largestTimeFromDigits(int[] A) {\\n        String res = \"\";\\n        for(int i =0; i< 4;i++){\\n            for(int j = 0; j < 4;j++){\\n                for(int k = 0; k < 4; k++){\\n                    if(i == j || j == k || i == k) continue;\\n                    String hour = A[i] + \"\" + A[j];\\n                    String min = A[k] + \"\" + A[6-i-j-k];\\n                    String time = hour + \":\" + min;\\n                    if(hour.compareTo(\"24\") < 0 && min.compareTo(\"60\") < 0)\\n                        res = res.compareTo(time) < 0 ? time : res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751721,
                "title": "java-backtracking-solution",
                "content": "I tried this in a mock exam. I had one hour and 2 questions. I did the other question in 10 mins. I was trying to solve this one using simple if else logics then after 40 mins realized I could not do it. Then I thought, lets try backtracking solution where you pick one digit and then try putting the rest on other places and see if it works. I was able to solve it within 5-6 mins. \\n```\\nclass Solution {\\n    int[] nums;\\n    String ans = \"\";\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        this.nums = nums;\\n        List<Integer> l = new ArrayList<>();\\n        for(int i: A)l.add(i);\\n        Collections.sort(l, Collections.reverseOrder());\\n        \\n        backtrack(l, \"\", \"\");\\n        return ans;\\n    }\\n    private boolean validHour(String hour){\\n        if(hour.length() == 2 && Integer.valueOf(hour) < 24) return true;\\n        return false;\\n    }\\n    \\n    private boolean validMin(String hour){\\n        if(hour.length() == 2 && Integer.valueOf(hour) < 60) return true;\\n        return false;\\n    }\\n    \\n    public boolean backtrack(List<Integer> l, String hour, String min){\\n        \\n        if(hour.length() == 2 && min.length()==2){\\n            if(validHour(hour) && validMin(min)){\\n                ans = hour + \":\" + min;\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        if(hour.length() < 2){\\n            for(int i=0; i<l.size(); i++){\\n                Integer h = l.remove(i);\\n                \\n                String hr = hour + h;\\n                \\n                if(backtrack(l, hr, min)){\\n                    return true;\\n                }\\n                l.add(i, h);\\n            }            \\n        }\\n        \\n        if(min.length() < 2){\\n            for(int i=0; i<l.size(); i++){\\n                Integer m = l.remove(i);\\n                \\n                String mi = min + m;\\n                \\n                if(backtrack(l, hour, mi)){\\n                    return true;\\n                }\\n                l.add(i, m);\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] nums;\\n    String ans = \"\";\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        this.nums = nums;\\n        List<Integer> l = new ArrayList<>();\\n        for(int i: A)l.add(i);\\n        Collections.sort(l, Collections.reverseOrder());\\n        \\n        backtrack(l, \"\", \"\");\\n        return ans;\\n    }\\n    private boolean validHour(String hour){\\n        if(hour.length() == 2 && Integer.valueOf(hour) < 24) return true;\\n        return false;\\n    }\\n    \\n    private boolean validMin(String hour){\\n        if(hour.length() == 2 && Integer.valueOf(hour) < 60) return true;\\n        return false;\\n    }\\n    \\n    public boolean backtrack(List<Integer> l, String hour, String min){\\n        \\n        if(hour.length() == 2 && min.length()==2){\\n            if(validHour(hour) && validMin(min)){\\n                ans = hour + \":\" + min;\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        if(hour.length() < 2){\\n            for(int i=0; i<l.size(); i++){\\n                Integer h = l.remove(i);\\n                \\n                String hr = hour + h;\\n                \\n                if(backtrack(l, hr, min)){\\n                    return true;\\n                }\\n                l.add(i, h);\\n            }            \\n        }\\n        \\n        if(min.length() < 2){\\n            for(int i=0; i<l.size(); i++){\\n                Integer m = l.remove(i);\\n                \\n                String mi = min + m;\\n                \\n                if(backtrack(l, hour, mi)){\\n                    return true;\\n                }\\n                l.add(i, m);\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687711,
                "title": "ruby-2-line-solution",
                "content": "```\\n# @param {Integer[]} a\\n# @return {String}\\ndef largest_time_from_digits(a)\\n  a.permutation.map { |b| \\'%d%d:%d%d\\' % b }.select { |t| valid?(t) }.max || \\'\\'\\nend\\n\\nprivate def valid?(str)\\n  str.match?(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/)\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} a\\n# @return {String}\\ndef largest_time_from_digits(a)\\n  a.permutation.map { |b| \\'%d%d:%d%d\\' % b }.select { |t| valid?(t) }.max || \\'\\'\\nend\\n\\nprivate def valid?(str)\\n  str.match?(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 538181,
                "title": "c-faster-than-95-83-less-than-100-mem-o-1",
                "content": "O(1) because the size of A is set to 4.\\n\\nRuntime: 100 ms\\nMemory Usage: 24.9 MB\\n\\n```\\n    public string LargestTimeFromDigits(int[] A) {\\n        StringBuilder st = new StringBuilder();\\n        HashSet<int> used = new HashSet<int>();\\n        int maxTime = -1;\\n        string result = string.Empty;\\n        \\n        BuildString(st, used, A, 0, 0, ref maxTime, ref result);\\n        return result;\\n    }\\n    \\n    private void BuildString(StringBuilder st, HashSet<int> used, int[] A, int hours, int minutes, ref int maxTime, ref string result)\\n    {\\n        if (used.Count == A.Length)\\n        {\\n            if (st.Length == 4 && hours * 60 + minutes > maxTime) {\\n                maxTime = hours * 60 + minutes;\\n                st.Insert(2,\":\");\\n                result = st.ToString();\\n                st.Remove(2,1);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0; i< A.Length; i++)\\n        {\\n            if (used.Contains(i)) { continue; }\\n            \\n            if (st.Length < 2 && hours * 10 + A[i] < 24)\\n            {\\n                st.Append(A[i]);\\n                used.Add(i);\\n                BuildString(st, used, A, hours * 10 + A[i], minutes, ref maxTime, ref result);  \\n                used.Remove(i);\\n                st.Length--;\\n            }\\n            else if (st.Length >= 2 && minutes * 10 + A[i] < 60)\\n            {\\n                st.Append(A[i]);\\n                used.Add(i);\\n                BuildString(st, used, A, hours, minutes * 10 + A[i], ref maxTime, ref result);  \\n                used.Remove(i);\\n                st.Length--;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "O(1) because the size of A is set to 4.\\n\\nRuntime: 100 ms\\nMemory Usage: 24.9 MB\\n\\n```\\n    public string LargestTimeFromDigits(int[] A) {\\n        StringBuilder st = new StringBuilder();\\n        HashSet<int> used = new HashSet<int>();\\n        int maxTime = -1;\\n        string result = string.Empty;\\n        \\n        BuildString(st, used, A, 0, 0, ref maxTime, ref result);\\n        return result;\\n    }\\n    \\n    private void BuildString(StringBuilder st, HashSet<int> used, int[] A, int hours, int minutes, ref int maxTime, ref string result)\\n    {\\n        if (used.Count == A.Length)\\n        {\\n            if (st.Length == 4 && hours * 60 + minutes > maxTime) {\\n                maxTime = hours * 60 + minutes;\\n                st.Insert(2,\":\");\\n                result = st.ToString();\\n                st.Remove(2,1);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0; i< A.Length; i++)\\n        {\\n            if (used.Contains(i)) { continue; }\\n            \\n            if (st.Length < 2 && hours * 10 + A[i] < 24)\\n            {\\n                st.Append(A[i]);\\n                used.Add(i);\\n                BuildString(st, used, A, hours * 10 + A[i], minutes, ref maxTime, ref result);  \\n                used.Remove(i);\\n                st.Length--;\\n            }\\n            else if (st.Length >= 2 && minutes * 10 + A[i] < 60)\\n            {\\n                st.Append(A[i]);\\n                used.Add(i);\\n                BuildString(st, used, A, hours, minutes * 10 + A[i], ref maxTime, ref result);  \\n                used.Remove(i);\\n                st.Length--;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 513643,
                "title": "javascript-permutation-solution",
                "content": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n  const times = permutation(A)\\n    .filter(a => ((a[0] === 2 && a[1] < 4) || a[0] < 2) && a[2] < 6) // only keep valid times\\n    .map(a => 60 * (a[0] * 10 + a[1]) + a[2] * 10 + a[3]); // convert to minutes\\n  return times.length ? convert(Math.max(...times)) : \\'\\';\\n};\\n\\n// convert minutes back to time\\nconst convert = time => {\\n  const m = time % 60;\\n  const m2 = m % 10;\\n  const m1 = (m - m2) / 10;\\n  const h = (time - m) / 60;\\n  const h2 = h % 10;\\n  const h1 = (h - h2) / 10;\\n  return `${h1}${h2}:${m1}${m2}`;\\n};\\n\\n// Heap\\'s algorithm to generate permutations\\nconst permutation = arr => {\\n  const generate = (arr, n) => {\\n    if (n == 1) {\\n      result.push(arr.slice());\\n      return;\\n    }\\n    for (var i = 0; i < n; i++) {\\n      generate(arr, n - 1);\\n      if (n % 2 === 0) {\\n        [arr[i], arr[n - 1]] = [arr[n - 1], arr[i]];\\n      } else {\\n        [arr[0], arr[n - 1]] = [arr[n - 1], arr[0]];\\n      }\\n    }\\n  };\\n  const result = [];\\n  generate(arr, arr.length);\\n  return result;\\n};\\n```\\n\\n* 172/172 cases passed (52 ms)\\n* Your runtime beats 96.08 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (35.8 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n  const times = permutation(A)\\n    .filter(a => ((a[0] === 2 && a[1] < 4) || a[0] < 2) && a[2] < 6) // only keep valid times\\n    .map(a => 60 * (a[0] * 10 + a[1]) + a[2] * 10 + a[3]); // convert to minutes\\n  return times.length ? convert(Math.max(...times)) : \\'\\';\\n};\\n\\n// convert minutes back to time\\nconst convert = time => {\\n  const m = time % 60;\\n  const m2 = m % 10;\\n  const m1 = (m - m2) / 10;\\n  const h = (time - m) / 60;\\n  const h2 = h % 10;\\n  const h1 = (h - h2) / 10;\\n  return `${h1}${h2}:${m1}${m2}`;\\n};\\n\\n// Heap\\'s algorithm to generate permutations\\nconst permutation = arr => {\\n  const generate = (arr, n) => {\\n    if (n == 1) {\\n      result.push(arr.slice());\\n      return;\\n    }\\n    for (var i = 0; i < n; i++) {\\n      generate(arr, n - 1);\\n      if (n % 2 === 0) {\\n        [arr[i], arr[n - 1]] = [arr[n - 1], arr[i]];\\n      } else {\\n        [arr[0], arr[n - 1]] = [arr[n - 1], arr[0]];\\n      }\\n    }\\n  };\\n  const result = [];\\n  generate(arr, arr.length);\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 475504,
                "title": "swift-fast-8m-100",
                "content": "```swift\\nclass Solution {\\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        for i in (0...23).reversed() {\\n            let h = i % 10\\n            let dh = i / 10\\n            if A.contains(dh), A.contains(h) {\\n                if let result = pickTime(A, h, dh) {\\n                    return result\\n                }\\n            }\\n        }\\n        return \"\"\\n        \\n    }\\n    \\n    func pickTime(_ from: [Int], _ valid: inout [Int]) -> Int? {\\n        for i in from {\\n            if valid.contains(i) {\\n                if let index = valid.firstIndex(of: i) {\\n                    valid.remove(at: index)\\n                }\\n                return i\\n            }\\n        }\\n        return nil\\n        \\n    }\\n    \\n    func pickTime(_ from: [Int], _ h: Int, _ dh: Int) -> String? {\\n        var numbers = from\\n        if let index = numbers.firstIndex(of: h) {\\n            numbers.remove(at: index)\\n        }\\n        if let index = numbers.firstIndex(of: dh) {\\n            numbers.remove(at: index)\\n        } else {\\n            return nil\\n        }\\n        guard let dm = pickTime([5,4,3,2,1,0], &numbers) else {\\n            return nil\\n        }\\n        let m = numbers.last!\\n        let result = \"\\\\(dh)\\\\(h):\\\\(dm)\\\\(m)\"\\n        \\n        \\n        return result\\n        \\n    }\\n}\\n```\\n\\nalso I have 2 very stupid solutions, just for fun\\n\\n```\\nclass Solution {\\n    \\n    var values: [String: String]\\n    init() {\\n       values = [:]\\n       for i in (0...23).reversed() {\\n           let h = i % 10\\n           let dh = i / 10\\n           for j in (0...59).reversed() {\\n               let m = j % 10\\n               let dm = j / 10\\n               let key = normalize([h,dh,m,dm])\\n               if values[key] == nil {\\n                   values[key] = \"\\\\(dh)\\\\(h):\\\\(dm)\\\\(m)\"\\n               }\\n\\n           }\\n       }\\n   }\\n    \\n    func normalize(_ numbers: [Int]) -> String {\\n        return numbers.sorted().map({ String($0) }).joined()\\n    }\\n    \\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        let key = normalize(A)\\n        return values[key, default: \"\"]\\n    }\\n}\\n```\\n\\nor even more, we could store calculated values\\n\\n```swift\\nclass Solution {\\n   var values: [String: String] = [\"2345\": \"23:54\", \"0007\": \"07:00\", \"0568\": \"08:56\", \"1249\": \"21:49\", \"0335\": \"05:33\", \"0557\": \"07:55\", \"2224\": \"22:42\", \"2239\": \"23:29\", \"0279\": \"09:27\", \"0455\": \"05:54\", \"0138\": \"18:30\", \"0248\": \"20:48\", \"1227\": \"22:17\", \"2346\": \"23:46\", \"2245\": \"22:54\", \"0089\": \"09:08\", \"0245\": \"20:54\", \"0244\": \"20:44\", \"1257\": \"21:57\", \"0236\": \"23:06\", \"1258\": \"21:58\", \"1599\": \"19:59\", \"0112\": \"21:10\", \"0022\": \"22:00\", \"1388\": \"18:38\", \"2257\": \"22:57\", \"0026\": \"20:06\", \"1558\": \"18:55\", \"0469\": \"09:46\", \"0058\": \"08:50\", \"1588\": \"18:58\", \"0119\": \"19:10\", \"1157\": \"17:51\", \"1133\": \"13:31\", \"0066\": \"06:06\", \"0133\": \"13:30\", \"1189\": \"19:18\", \"1278\": \"18:27\", \"1348\": \"18:43\", \"1379\": \"19:37\", \"1156\": \"16:51\", \"0358\": \"08:53\", \"2255\": \"22:55\", \"0255\": \"20:55\", \"0269\": \"09:26\", \"0457\": \"07:54\", \"2249\": \"22:49\", \"0005\": \"05:00\", \"1158\": \"18:51\", \"1555\": \"15:55\", \"0266\": \"06:26\", \"0466\": \"06:46\", \"0578\": \"08:57\", \"1337\": \"17:33\", \"0129\": \"21:09\", \"0146\": \"16:40\", \"0115\": \"15:10\", \"1339\": \"19:33\", \"0448\": \"08:44\", \"1288\": \"18:28\", \"1335\": \"15:33\", \"1117\": \"17:11\", \"0006\": \"06:00\", \"0078\": \"08:07\", \"0456\": \"06:54\", \"0289\": \"09:28\", \"1399\": \"19:39\", \"0479\": \"09:47\", \"0478\": \"08:47\", \"1147\": \"17:41\", \"1137\": \"17:31\", \"1144\": \"14:41\", \"1346\": \"16:43\", \"1477\": \"17:47\", \"0447\": \"07:44\", \"1233\": \"23:31\", \"0156\": \"16:50\", \"1155\": \"15:51\", \"0488\": \"08:48\", \"0449\": \"09:44\", \"1367\": \"17:36\", \"1377\": \"17:37\", \"0225\": \"22:50\", \"1167\": \"17:16\", \"2339\": \"23:39\", \"1267\": \"17:26\", \"1124\": \"21:41\", \"2233\": \"23:32\", \"0346\": \"06:43\", \"2226\": \"22:26\", \"1455\": \"15:54\", \"0158\": \"18:50\", \"1579\": \"19:57\", \"0278\": \"08:27\", \"0056\": \"06:50\", \"0001\": \"10:00\", \"2355\": \"23:55\", \"1115\": \"15:11\", \"1556\": \"16:55\", \"2358\": \"23:58\", \"0446\": \"06:44\", \"0088\": \"08:08\", \"0000\": \"00:00\", \"1179\": \"19:17\", \"0224\": \"22:40\", \"0025\": \"20:50\", \"0099\": \"09:09\", \"1479\": \"19:47\", \"0069\": \"09:06\", \"0136\": \"16:30\", \"1446\": \"16:44\", \"0445\": \"05:44\", \"0334\": \"04:33\", \"1358\": \"18:53\", \"1247\": \"21:47\", \"0038\": \"08:30\", \"1166\": \"16:16\", \"0256\": \"20:56\", \"0336\": \"06:33\", \"1127\": \"21:17\", \"0047\": \"07:40\", \"1223\": \"23:21\", \"0033\": \"03:30\", \"0003\": \"03:00\", \"0179\": \"19:07\", \"0226\": \"22:06\", \"2338\": \"23:38\", \"0019\": \"19:00\", \"0116\": \"16:10\", \"1568\": \"18:56\", \"1116\": \"16:11\", \"0011\": \"11:00\", \"0222\": \"22:20\", \"0126\": \"21:06\", \"0357\": \"07:53\", \"0378\": \"08:37\", \"1178\": \"18:17\", \"0458\": \"08:54\", \"0139\": \"19:30\", \"0468\": \"08:46\", \"0233\": \"23:30\", \"0014\": \"14:00\", \"0229\": \"22:09\", \"1456\": \"16:54\", \"1126\": \"21:16\", \"1125\": \"21:51\", \"0035\": \"05:30\", \"0388\": \"08:38\", \"2258\": \"22:58\", \"1113\": \"13:11\", \"1268\": \"18:26\", \"1457\": \"17:54\", \"0399\": \"09:39\", \"0168\": \"18:06\", \"0015\": \"15:00\", \"0268\": \"08:26\", \"0299\": \"09:29\", \"1145\": \"15:41\", \"1256\": \"21:56\", \"0177\": \"17:07\", \"0178\": \"18:07\", \"0135\": \"15:30\", \"2236\": \"23:26\", \"2344\": \"23:44\", \"1228\": \"22:18\", \"0048\": \"08:40\", \"0444\": \"04:44\", \"1378\": \"18:37\", \"2334\": \"23:43\", \"2348\": \"23:48\", \"0369\": \"09:36\", \"0345\": \"05:43\", \"0227\": \"22:07\", \"1345\": \"15:43\", \"0077\": \"07:07\", \"0149\": \"19:40\", \"0169\": \"19:06\", \"1118\": \"18:11\", \"2222\": \"22:22\", \"0239\": \"23:09\", \"0377\": \"07:37\", \"0333\": \"03:33\", \"0155\": \"15:50\", \"1138\": \"18:31\", \"1148\": \"18:41\", \"0028\": \"20:08\", \"0558\": \"08:55\", \"1299\": \"19:29\", \"0008\": \"08:00\", \"0039\": \"09:30\", \"1458\": \"18:54\", \"0569\": \"09:56\", \"2247\": \"22:47\", \"1199\": \"19:19\", \"1366\": \"16:36\", \"0167\": \"17:06\", \"0122\": \"22:10\", \"0037\": \"07:30\", \"0044\": \"04:40\", \"1355\": \"15:53\", \"0559\": \"09:55\", \"1368\": \"18:36\", \"0045\": \"05:40\", \"1224\": \"22:41\", \"0379\": \"09:37\", \"0577\": \"07:57\", \"0137\": \"17:30\", \"0234\": \"23:40\", \"0339\": \"09:33\", \"0235\": \"23:50\", \"1236\": \"23:16\", \"0499\": \"09:49\", \"0589\": \"09:58\", \"2337\": \"23:37\", \"0055\": \"05:50\", \"2336\": \"23:36\", \"1369\": \"19:36\", \"1134\": \"14:31\", \"1578\": \"18:57\", \"2238\": \"23:28\", \"1139\": \"19:31\", \"0134\": \"14:30\", \"2359\": \"23:59\", \"1246\": \"21:46\", \"1229\": \"22:19\", \"1279\": \"19:27\", \"2237\": \"23:27\", \"0259\": \"20:59\", \"1467\": \"17:46\", \"1468\": \"18:46\", \"0467\": \"07:46\", \"0125\": \"21:50\", \"0013\": \"13:00\", \"0267\": \"07:26\", \"0147\": \"17:40\", \"1239\": \"23:19\", \"0029\": \"20:09\", \"0246\": \"20:46\", \"1169\": \"19:16\", \"0489\": \"09:48\", \"0067\": \"07:06\", \"0017\": \"17:00\", \"1168\": \"18:16\", \"1244\": \"21:44\", \"2349\": \"23:49\", \"1114\": \"14:11\", \"2347\": \"23:47\", \"0027\": \"20:07\", \"0189\": \"19:08\", \"2357\": \"23:57\", \"1567\": \"17:56\", \"1469\": \"19:46\", \"1222\": \"22:21\", \"1259\": \"21:59\", \"2234\": \"23:42\", \"0223\": \"23:20\", \"1122\": \"22:11\", \"0117\": \"17:10\", \"0036\": \"06:30\", \"0366\": \"06:36\", \"1238\": \"23:18\", \"2333\": \"23:33\", \"0012\": \"21:00\", \"1235\": \"23:51\", \"0237\": \"23:07\", \"0566\": \"06:56\", \"0009\": \"09:00\", \"1448\": \"18:44\", \"2223\": \"23:22\", \"1159\": \"19:51\", \"1488\": \"18:48\", \"2248\": \"22:48\", \"0079\": \"09:07\", \"2229\": \"22:29\", \"0257\": \"20:57\", \"0347\": \"07:43\", \"0459\": \"09:54\", \"1559\": \"19:55\", \"0288\": \"08:28\", \"0337\": \"07:33\", \"0368\": \"08:36\", \"0049\": \"09:40\", \"1359\": \"19:53\", \"1489\": \"19:48\", \"0159\": \"19:50\", \"1188\": \"18:18\", \"0118\": \"18:10\", \"0258\": \"20:58\", \"0477\": \"07:47\", \"2335\": \"23:53\", \"0599\": \"09:59\", \"1237\": \"23:17\", \"0247\": \"20:47\", \"0567\": \"07:56\", \"2259\": \"22:59\", \"1499\": \"19:49\", \"0046\": \"06:40\", \"0127\": \"21:07\", \"0349\": \"09:43\", \"1389\": \"19:38\", \"0188\": \"18:08\", \"1336\": \"16:33\", \"1347\": \"17:43\", \"1129\": \"21:19\", \"2246\": \"22:46\", \"2228\": \"22:28\", \"1344\": \"14:43\", \"1146\": \"16:41\", \"0123\": \"23:10\", \"0228\": \"22:08\", \"1449\": \"19:44\", \"2244\": \"22:44\", \"0579\": \"09:57\", \"1135\": \"15:31\", \"1225\": \"22:51\", \"1255\": \"21:55\", \"1349\": \"19:43\", \"0124\": \"21:40\", \"1557\": \"17:55\", \"0128\": \"21:08\", \"0057\": \"07:50\", \"2235\": \"23:52\", \"0157\": \"17:50\", \"0111\": \"11:10\", \"0389\": \"09:38\", \"0144\": \"14:40\", \"0004\": \"04:00\", \"0034\": \"04:30\", \"1357\": \"17:53\", \"1234\": \"23:41\", \"1333\": \"13:33\", \"0249\": \"20:49\", \"1112\": \"21:11\", \"0166\": \"16:06\", \"0338\": \"08:33\", \"2225\": \"22:52\", \"2227\": \"22:27\", \"0555\": \"05:55\", \"0277\": \"07:27\", \"1447\": \"17:44\", \"1269\": \"19:26\", \"1356\": \"16:53\", \"1136\": \"16:31\", \"1119\": \"19:11\", \"0068\": \"08:06\", \"1248\": \"21:48\", \"0113\": \"13:10\", \"0556\": \"06:55\", \"1478\": \"18:47\", \"1277\": \"17:27\", \"0348\": \"08:43\", \"1245\": \"21:54\", \"1266\": \"16:26\", \"0023\": \"23:00\", \"1338\": \"18:33\", \"0199\": \"19:09\", \"1111\": \"11:11\", \"0356\": \"06:53\", \"0002\": \"20:00\", \"0148\": \"18:40\", \"0024\": \"20:40\", \"0367\": \"07:36\", \"2356\": \"23:56\", \"1149\": \"19:41\", \"0359\": \"09:53\", \"1444\": \"14:44\", \"0145\": \"15:40\", \"1226\": \"22:16\", \"1569\": \"19:56\", \"0588\": \"08:58\", \"1566\": \"16:56\", \"1577\": \"17:57\", \"0059\": \"09:50\", \"0016\": \"16:00\", \"0018\": \"18:00\", \"2256\": \"22:56\", \"1459\": \"19:54\", \"1445\": \"15:44\", \"1589\": \"19:58\", \"0238\": \"23:08\", \"0344\": \"04:43\", \"1334\": \"14:33\", \"1289\": \"19:28\", \"1128\": \"21:18\", \"0114\": \"14:10\", \"0355\": \"05:53\", \"1123\": \"23:11\", \"1177\": \"17:17\", \"1466\": \"16:46\"]\\n    \\n    func normalize(_ numbers: [Int]) -> String {\\n        return numbers.sorted().map({ String($0) }).joined()\\n    }\\n    \\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        let key = normalize(A)\\n        return values[key, default: \"\"]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        for i in (0...23).reversed() {\\n            let h = i % 10\\n            let dh = i / 10\\n            if A.contains(dh), A.contains(h) {\\n                if let result = pickTime(A, h, dh) {\\n                    return result\\n                }\\n            }\\n        }\\n        return \"\"\\n        \\n    }\\n    \\n    func pickTime(_ from: [Int], _ valid: inout [Int]) -> Int? {\\n        for i in from {\\n            if valid.contains(i) {\\n                if let index = valid.firstIndex(of: i) {\\n                    valid.remove(at: index)\\n                }\\n                return i\\n            }\\n        }\\n        return nil\\n        \\n    }\\n    \\n    func pickTime(_ from: [Int], _ h: Int, _ dh: Int) -> String? {\\n        var numbers = from\\n        if let index = numbers.firstIndex(of: h) {\\n            numbers.remove(at: index)\\n        }\\n        if let index = numbers.firstIndex(of: dh) {\\n            numbers.remove(at: index)\\n        } else {\\n            return nil\\n        }\\n        guard let dm = pickTime([5,4,3,2,1,0], &numbers) else {\\n            return nil\\n        }\\n        let m = numbers.last!\\n        let result = \"\\\\(dh)\\\\(h):\\\\(dm)\\\\(m)\"\\n        \\n        \\n        return result\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    var values: [String: String]\\n    init() {\\n       values = [:]\\n       for i in (0...23).reversed() {\\n           let h = i % 10\\n           let dh = i / 10\\n           for j in (0...59).reversed() {\\n               let m = j % 10\\n               let dm = j / 10\\n               let key = normalize([h,dh,m,dm])\\n               if values[key] == nil {\\n                   values[key] = \"\\\\(dh)\\\\(h):\\\\(dm)\\\\(m)\"\\n               }\\n\\n           }\\n       }\\n   }\\n    \\n    func normalize(_ numbers: [Int]) -> String {\\n        return numbers.sorted().map({ String($0) }).joined()\\n    }\\n    \\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        let key = normalize(A)\\n        return values[key, default: \"\"]\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n   var values: [String: String] = [\"2345\": \"23:54\", \"0007\": \"07:00\", \"0568\": \"08:56\", \"1249\": \"21:49\", \"0335\": \"05:33\", \"0557\": \"07:55\", \"2224\": \"22:42\", \"2239\": \"23:29\", \"0279\": \"09:27\", \"0455\": \"05:54\", \"0138\": \"18:30\", \"0248\": \"20:48\", \"1227\": \"22:17\", \"2346\": \"23:46\", \"2245\": \"22:54\", \"0089\": \"09:08\", \"0245\": \"20:54\", \"0244\": \"20:44\", \"1257\": \"21:57\", \"0236\": \"23:06\", \"1258\": \"21:58\", \"1599\": \"19:59\", \"0112\": \"21:10\", \"0022\": \"22:00\", \"1388\": \"18:38\", \"2257\": \"22:57\", \"0026\": \"20:06\", \"1558\": \"18:55\", \"0469\": \"09:46\", \"0058\": \"08:50\", \"1588\": \"18:58\", \"0119\": \"19:10\", \"1157\": \"17:51\", \"1133\": \"13:31\", \"0066\": \"06:06\", \"0133\": \"13:30\", \"1189\": \"19:18\", \"1278\": \"18:27\", \"1348\": \"18:43\", \"1379\": \"19:37\", \"1156\": \"16:51\", \"0358\": \"08:53\", \"2255\": \"22:55\", \"0255\": \"20:55\", \"0269\": \"09:26\", \"0457\": \"07:54\", \"2249\": \"22:49\", \"0005\": \"05:00\", \"1158\": \"18:51\", \"1555\": \"15:55\", \"0266\": \"06:26\", \"0466\": \"06:46\", \"0578\": \"08:57\", \"1337\": \"17:33\", \"0129\": \"21:09\", \"0146\": \"16:40\", \"0115\": \"15:10\", \"1339\": \"19:33\", \"0448\": \"08:44\", \"1288\": \"18:28\", \"1335\": \"15:33\", \"1117\": \"17:11\", \"0006\": \"06:00\", \"0078\": \"08:07\", \"0456\": \"06:54\", \"0289\": \"09:28\", \"1399\": \"19:39\", \"0479\": \"09:47\", \"0478\": \"08:47\", \"1147\": \"17:41\", \"1137\": \"17:31\", \"1144\": \"14:41\", \"1346\": \"16:43\", \"1477\": \"17:47\", \"0447\": \"07:44\", \"1233\": \"23:31\", \"0156\": \"16:50\", \"1155\": \"15:51\", \"0488\": \"08:48\", \"0449\": \"09:44\", \"1367\": \"17:36\", \"1377\": \"17:37\", \"0225\": \"22:50\", \"1167\": \"17:16\", \"2339\": \"23:39\", \"1267\": \"17:26\", \"1124\": \"21:41\", \"2233\": \"23:32\", \"0346\": \"06:43\", \"2226\": \"22:26\", \"1455\": \"15:54\", \"0158\": \"18:50\", \"1579\": \"19:57\", \"0278\": \"08:27\", \"0056\": \"06:50\", \"0001\": \"10:00\", \"2355\": \"23:55\", \"1115\": \"15:11\", \"1556\": \"16:55\", \"2358\": \"23:58\", \"0446\": \"06:44\", \"0088\": \"08:08\", \"0000\": \"00:00\", \"1179\": \"19:17\", \"0224\": \"22:40\", \"0025\": \"20:50\", \"0099\": \"09:09\", \"1479\": \"19:47\", \"0069\": \"09:06\", \"0136\": \"16:30\", \"1446\": \"16:44\", \"0445\": \"05:44\", \"0334\": \"04:33\", \"1358\": \"18:53\", \"1247\": \"21:47\", \"0038\": \"08:30\", \"1166\": \"16:16\", \"0256\": \"20:56\", \"0336\": \"06:33\", \"1127\": \"21:17\", \"0047\": \"07:40\", \"1223\": \"23:21\", \"0033\": \"03:30\", \"0003\": \"03:00\", \"0179\": \"19:07\", \"0226\": \"22:06\", \"2338\": \"23:38\", \"0019\": \"19:00\", \"0116\": \"16:10\", \"1568\": \"18:56\", \"1116\": \"16:11\", \"0011\": \"11:00\", \"0222\": \"22:20\", \"0126\": \"21:06\", \"0357\": \"07:53\", \"0378\": \"08:37\", \"1178\": \"18:17\", \"0458\": \"08:54\", \"0139\": \"19:30\", \"0468\": \"08:46\", \"0233\": \"23:30\", \"0014\": \"14:00\", \"0229\": \"22:09\", \"1456\": \"16:54\", \"1126\": \"21:16\", \"1125\": \"21:51\", \"0035\": \"05:30\", \"0388\": \"08:38\", \"2258\": \"22:58\", \"1113\": \"13:11\", \"1268\": \"18:26\", \"1457\": \"17:54\", \"0399\": \"09:39\", \"0168\": \"18:06\", \"0015\": \"15:00\", \"0268\": \"08:26\", \"0299\": \"09:29\", \"1145\": \"15:41\", \"1256\": \"21:56\", \"0177\": \"17:07\", \"0178\": \"18:07\", \"0135\": \"15:30\", \"2236\": \"23:26\", \"2344\": \"23:44\", \"1228\": \"22:18\", \"0048\": \"08:40\", \"0444\": \"04:44\", \"1378\": \"18:37\", \"2334\": \"23:43\", \"2348\": \"23:48\", \"0369\": \"09:36\", \"0345\": \"05:43\", \"0227\": \"22:07\", \"1345\": \"15:43\", \"0077\": \"07:07\", \"0149\": \"19:40\", \"0169\": \"19:06\", \"1118\": \"18:11\", \"2222\": \"22:22\", \"0239\": \"23:09\", \"0377\": \"07:37\", \"0333\": \"03:33\", \"0155\": \"15:50\", \"1138\": \"18:31\", \"1148\": \"18:41\", \"0028\": \"20:08\", \"0558\": \"08:55\", \"1299\": \"19:29\", \"0008\": \"08:00\", \"0039\": \"09:30\", \"1458\": \"18:54\", \"0569\": \"09:56\", \"2247\": \"22:47\", \"1199\": \"19:19\", \"1366\": \"16:36\", \"0167\": \"17:06\", \"0122\": \"22:10\", \"0037\": \"07:30\", \"0044\": \"04:40\", \"1355\": \"15:53\", \"0559\": \"09:55\", \"1368\": \"18:36\", \"0045\": \"05:40\", \"1224\": \"22:41\", \"0379\": \"09:37\", \"0577\": \"07:57\", \"0137\": \"17:30\", \"0234\": \"23:40\", \"0339\": \"09:33\", \"0235\": \"23:50\", \"1236\": \"23:16\", \"0499\": \"09:49\", \"0589\": \"09:58\", \"2337\": \"23:37\", \"0055\": \"05:50\", \"2336\": \"23:36\", \"1369\": \"19:36\", \"1134\": \"14:31\", \"1578\": \"18:57\", \"2238\": \"23:28\", \"1139\": \"19:31\", \"0134\": \"14:30\", \"2359\": \"23:59\", \"1246\": \"21:46\", \"1229\": \"22:19\", \"1279\": \"19:27\", \"2237\": \"23:27\", \"0259\": \"20:59\", \"1467\": \"17:46\", \"1468\": \"18:46\", \"0467\": \"07:46\", \"0125\": \"21:50\", \"0013\": \"13:00\", \"0267\": \"07:26\", \"0147\": \"17:40\", \"1239\": \"23:19\", \"0029\": \"20:09\", \"0246\": \"20:46\", \"1169\": \"19:16\", \"0489\": \"09:48\", \"0067\": \"07:06\", \"0017\": \"17:00\", \"1168\": \"18:16\", \"1244\": \"21:44\", \"2349\": \"23:49\", \"1114\": \"14:11\", \"2347\": \"23:47\", \"0027\": \"20:07\", \"0189\": \"19:08\", \"2357\": \"23:57\", \"1567\": \"17:56\", \"1469\": \"19:46\", \"1222\": \"22:21\", \"1259\": \"21:59\", \"2234\": \"23:42\", \"0223\": \"23:20\", \"1122\": \"22:11\", \"0117\": \"17:10\", \"0036\": \"06:30\", \"0366\": \"06:36\", \"1238\": \"23:18\", \"2333\": \"23:33\", \"0012\": \"21:00\", \"1235\": \"23:51\", \"0237\": \"23:07\", \"0566\": \"06:56\", \"0009\": \"09:00\", \"1448\": \"18:44\", \"2223\": \"23:22\", \"1159\": \"19:51\", \"1488\": \"18:48\", \"2248\": \"22:48\", \"0079\": \"09:07\", \"2229\": \"22:29\", \"0257\": \"20:57\", \"0347\": \"07:43\", \"0459\": \"09:54\", \"1559\": \"19:55\", \"0288\": \"08:28\", \"0337\": \"07:33\", \"0368\": \"08:36\", \"0049\": \"09:40\", \"1359\": \"19:53\", \"1489\": \"19:48\", \"0159\": \"19:50\", \"1188\": \"18:18\", \"0118\": \"18:10\", \"0258\": \"20:58\", \"0477\": \"07:47\", \"2335\": \"23:53\", \"0599\": \"09:59\", \"1237\": \"23:17\", \"0247\": \"20:47\", \"0567\": \"07:56\", \"2259\": \"22:59\", \"1499\": \"19:49\", \"0046\": \"06:40\", \"0127\": \"21:07\", \"0349\": \"09:43\", \"1389\": \"19:38\", \"0188\": \"18:08\", \"1336\": \"16:33\", \"1347\": \"17:43\", \"1129\": \"21:19\", \"2246\": \"22:46\", \"2228\": \"22:28\", \"1344\": \"14:43\", \"1146\": \"16:41\", \"0123\": \"23:10\", \"0228\": \"22:08\", \"1449\": \"19:44\", \"2244\": \"22:44\", \"0579\": \"09:57\", \"1135\": \"15:31\", \"1225\": \"22:51\", \"1255\": \"21:55\", \"1349\": \"19:43\", \"0124\": \"21:40\", \"1557\": \"17:55\", \"0128\": \"21:08\", \"0057\": \"07:50\", \"2235\": \"23:52\", \"0157\": \"17:50\", \"0111\": \"11:10\", \"0389\": \"09:38\", \"0144\": \"14:40\", \"0004\": \"04:00\", \"0034\": \"04:30\", \"1357\": \"17:53\", \"1234\": \"23:41\", \"1333\": \"13:33\", \"0249\": \"20:49\", \"1112\": \"21:11\", \"0166\": \"16:06\", \"0338\": \"08:33\", \"2225\": \"22:52\", \"2227\": \"22:27\", \"0555\": \"05:55\", \"0277\": \"07:27\", \"1447\": \"17:44\", \"1269\": \"19:26\", \"1356\": \"16:53\", \"1136\": \"16:31\", \"1119\": \"19:11\", \"0068\": \"08:06\", \"1248\": \"21:48\", \"0113\": \"13:10\", \"0556\": \"06:55\", \"1478\": \"18:47\", \"1277\": \"17:27\", \"0348\": \"08:43\", \"1245\": \"21:54\", \"1266\": \"16:26\", \"0023\": \"23:00\", \"1338\": \"18:33\", \"0199\": \"19:09\", \"1111\": \"11:11\", \"0356\": \"06:53\", \"0002\": \"20:00\", \"0148\": \"18:40\", \"0024\": \"20:40\", \"0367\": \"07:36\", \"2356\": \"23:56\", \"1149\": \"19:41\", \"0359\": \"09:53\", \"1444\": \"14:44\", \"0145\": \"15:40\", \"1226\": \"22:16\", \"1569\": \"19:56\", \"0588\": \"08:58\", \"1566\": \"16:56\", \"1577\": \"17:57\", \"0059\": \"09:50\", \"0016\": \"16:00\", \"0018\": \"18:00\", \"2256\": \"22:56\", \"1459\": \"19:54\", \"1445\": \"15:44\", \"1589\": \"19:58\", \"0238\": \"23:08\", \"0344\": \"04:43\", \"1334\": \"14:33\", \"1289\": \"19:28\", \"1128\": \"21:18\", \"0114\": \"14:10\", \"0355\": \"05:53\", \"1123\": \"23:11\", \"1177\": \"17:17\", \"1466\": \"16:46\"]\\n    \\n    func normalize(_ numbers: [Int]) -> String {\\n        return numbers.sorted().map({ String($0) }).joined()\\n    }\\n    \\n    func largestTimeFromDigits(_ A: [Int]) -> String {\\n        guard A.count == 4 else {\\n            return \"\"\\n        }\\n        \\n        let key = normalize(A)\\n        return values[key, default: \"\"]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439679,
                "title": "java-1-ms",
                "content": "```\\n// (0-2)_ (0-3)_ : (0-5)_ (0-9)_\\npublic String largestTimeFromDigits(int[] A) {\\n\\tArrays.sort(A);\\n\\tfor (int i = 3; i >= 0; i--) {\\n\\t\\tif (A[i] <= 2) {\\n\\t\\t\\tfor (int j = 3; j >= 0; j--) {\\n\\t\\t\\t\\tif ((A[i] != 2 || A[j] <= 3) && i != j) {\\n\\t\\t\\t\\t\\tfor (int k = 3; k >= 0; k--) {\\n\\t\\t\\t\\t\\t\\tif (A[k] <= 5 && i != k && j != k) {\\n\\t\\t\\t\\t\\t\\t\\t// 6 comes from 0+1+2+3 which are indexes of array so left index is calculated from 6 - i,j,k\\n\\t\\t\\t\\t\\t\\t\\treturn \"\" + A[i] + A[j] + \":\" + A[k] + A[6 - i - j - k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn \"\";\\n}",
                "solutionTags": [],
                "code": "```\\n// (0-2)_ (0-3)_ : (0-5)_ (0-9)_\\npublic String largestTimeFromDigits(int[] A) {\\n\\tArrays.sort(A);\\n\\tfor (int i = 3; i >= 0; i--) {\\n\\t\\tif (A[i] <= 2) {\\n\\t\\t\\tfor (int j = 3; j >= 0; j--) {\\n\\t\\t\\t\\tif ((A[i] != 2 || A[j] <= 3) && i != j) {\\n\\t\\t\\t\\t\\tfor (int k = 3; k >= 0; k--) {\\n\\t\\t\\t\\t\\t\\tif (A[k] <= 5 && i != k && j != k) {\\n\\t\\t\\t\\t\\t\\t\\t// 6 comes from 0+1+2+3 which are indexes of array so left index is calculated from 6 - i,j,k\\n\\t\\t\\t\\t\\t\\t\\treturn \"\" + A[i] + A[j] + \":\" + A[k] + A[6 - i - j - k];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn \"\";\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 406661,
                "title": "python3-6-line-via-permutation",
                "content": "It is tempting to think that this problem falls in the regime of \"greedy algorithm\". But a closer look reveals that one has to enumerate all possibilities and find the largest one due to complicated constraints on digits. \\n\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        hh = mm = -1\\n        for x in set(permutations(A, 4)): \\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60 and 60*h + m > 60*hh + mm: hh, mm = h, m\\n        return f\"{hh:02}:{mm:02}\" if hh >= 0 else \"\"\\n```\\n\\nSome comment: In practice, I\\'d write the comparison part as below. But in Python, tuple comparison is a lot slower comparing to number comparison. So to improve the percentage, the exising style is used. \\n\\n```\\n(h, m) > (hour, minute)\\n```\\n\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        def permutations(i=0): \\n            \"\"\"Return all permutations via generator.\"\"\"\\n            if i == len(A): yield A\\n            for ii in range(i, len(A)): \\n                A[i], A[ii] = A[ii], A[i]\\n                yield from permutations(i+1)\\n                A[i], A[ii] = A[ii], A[i]\\n        \\n        hh = mm = -1\\n        for x in permutations(): \\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60 and 60*hh + mm < 60*h + m: hh, mm = h, m \\n        return f\"{hh:02}:{mm:02}\" if hh >= 0 else \"\"\\n```\\n\\nEdited on 12/16/2020\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        def fn(i): \\n            \"\"\"Return unique permutations of arr.\"\"\"\\n            if i == 4: yield arr\\n            else: \\n                seen = set()\\n                for ii in range(i, 4):\\n                    if arr[ii] not in seen: \\n                        seen.add(arr[ii])\\n                        arr[i], arr[ii] = arr[ii], arr[i]\\n                        yield from fn(i+1)\\n                        arr[i], arr[ii] = arr[ii], arr[i]\\n        \\n        hh = mm = -1\\n        for x in fn(0):\\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60: hh, mm = max((hh, mm), (h, m))\\n        return f\"{hh:02}:{mm:02}\" if hh > -1 else \"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        hh = mm = -1\\n        for x in set(permutations(A, 4)): \\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60 and 60*h + m > 60*hh + mm: hh, mm = h, m\\n        return f\"{hh:02}:{mm:02}\" if hh >= 0 else \"\"\\n```\n```\\n(h, m) > (hour, minute)\\n```\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        def permutations(i=0): \\n            \"\"\"Return all permutations via generator.\"\"\"\\n            if i == len(A): yield A\\n            for ii in range(i, len(A)): \\n                A[i], A[ii] = A[ii], A[i]\\n                yield from permutations(i+1)\\n                A[i], A[ii] = A[ii], A[i]\\n        \\n        hh = mm = -1\\n        for x in permutations(): \\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60 and 60*hh + mm < 60*h + m: hh, mm = h, m \\n        return f\"{hh:02}:{mm:02}\" if hh >= 0 else \"\"\\n```\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        def fn(i): \\n            \"\"\"Return unique permutations of arr.\"\"\"\\n            if i == 4: yield arr\\n            else: \\n                seen = set()\\n                for ii in range(i, 4):\\n                    if arr[ii] not in seen: \\n                        seen.add(arr[ii])\\n                        arr[i], arr[ii] = arr[ii], arr[i]\\n                        yield from fn(i+1)\\n                        arr[i], arr[ii] = arr[ii], arr[i]\\n        \\n        hh = mm = -1\\n        for x in fn(0):\\n            h = 10*x[0] + x[1]\\n            m = 10*x[2] + x[3]\\n            if h < 24 and m < 60: hh, mm = max((hh, mm), (h, m))\\n        return f\"{hh:02}:{mm:02}\" if hh > -1 else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352795,
                "title": "solution-in-python-3-beats-100",
                "content": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n    \\tT, M = [], 0\\n    \\tfor t in set(permutations(A)):\\n    \\t\\th = t[0]*10 + t[1]\\n    \\t\\tm = 60*h + 10*t[2] + t[3]\\n    \\t\\tif h <= 23 and t[2] in [0,1,2,3,4,5] and m < 1440 and m > M: M, T = m, t\\n    \\treturn f\"{T[0]}{T[1]}:{T[2]}{T[3]}\" if len(T) !=0 else \"00:00\" if A == [0,0,0,0] else \"\"\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCodeID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n    \\tT, M = [], 0\\n    \\tfor t in set(permutations(A)):\\n    \\t\\th = t[0]*10 + t[1]\\n    \\t\\tm = 60*h + 10*t[2] + t[3]\\n    \\t\\tif h <= 23 and t[2] in [0,1,2,3,4,5] and m < 1440 and m > M: M, T = m, t\\n    \\treturn f\"{T[0]}",
                "codeTag": "Java"
            },
            {
                "id": 239233,
                "title": "c-solution",
                "content": "```\\nvoid permutation(int* A, int l , int r, int* count, int** table)\\n{\\n    if(l == r)\\n    {\\n        for(int i = 0; i < 4; i++)\\n        {\\n            table[*count][i] = A[i];\\n        }\\n        *count += 1;\\n        return;\\n    }\\n    else\\n    {\\n        for (int i = l; i <= r; i++)\\n        {\\n            int temp;\\n            temp = A[l];\\n            A[l] = A[i];\\n            A[i] = temp;\\n            permutation(A, l+1, r, count, table);\\n            temp = A[l];\\n            A[l] = A[i];\\n            A[i] = temp;\\n        }\\n    }\\n}\\n\\nchar* largestTimeFromDigits(int* A, int ASize) {\\n    int** table = malloc(sizeof(int*)*24);\\n    int count = 0;\\n    int max = -1;\\n    for(int i = 0; i < 24; i++)\\n    {\\n        table[i] = calloc(4, sizeof(int));\\n    }\\n    char* ans = calloc(6, sizeof(char));\\n    permutation(A, 0, ASize-1, &count, table);\\n    int temp;\\n    \\n    for(int i = 0; i < 24; i++)\\n    {\\n        if(table[i][0] == 2)\\n        {\\n            if(table[i][1] < 4)\\n            {\\n                if(table[i][2] < 6)\\n                {\\n                    temp = table[i][0]*1000 + table[i][1]*100 + table[i][2]*10 + table[i][3];\\n                    if (temp > max) max = temp;\\n                }\\n            }\\n        }\\n        else if(table[i][0] < 2)\\n        {\\n            if(table[i][2] < 6)\\n            {\\n                temp = table[i][0]*1000 + table[i][1]*100 + table[i][2]*10 + table[i][3];\\n                if (temp > max) max = temp;\\n            }\\n        }\\n    }\\n    if(max <0) return ans;\\n    ans[2] = \\':\\';\\n    ans[5] = \\'\\\\0\\';\\n    ans[4] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[3] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[1] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[0] = max % 10 + \\'0\\';\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid permutation(int* A, int l , int r, int* count, int** table)\\n{\\n    if(l == r)\\n    {\\n        for(int i = 0; i < 4; i++)\\n        {\\n            table[*count][i] = A[i];\\n        }\\n        *count += 1;\\n        return;\\n    }\\n    else\\n    {\\n        for (int i = l; i <= r; i++)\\n        {\\n            int temp;\\n            temp = A[l];\\n            A[l] = A[i];\\n            A[i] = temp;\\n            permutation(A, l+1, r, count, table);\\n            temp = A[l];\\n            A[l] = A[i];\\n            A[i] = temp;\\n        }\\n    }\\n}\\n\\nchar* largestTimeFromDigits(int* A, int ASize) {\\n    int** table = malloc(sizeof(int*)*24);\\n    int count = 0;\\n    int max = -1;\\n    for(int i = 0; i < 24; i++)\\n    {\\n        table[i] = calloc(4, sizeof(int));\\n    }\\n    char* ans = calloc(6, sizeof(char));\\n    permutation(A, 0, ASize-1, &count, table);\\n    int temp;\\n    \\n    for(int i = 0; i < 24; i++)\\n    {\\n        if(table[i][0] == 2)\\n        {\\n            if(table[i][1] < 4)\\n            {\\n                if(table[i][2] < 6)\\n                {\\n                    temp = table[i][0]*1000 + table[i][1]*100 + table[i][2]*10 + table[i][3];\\n                    if (temp > max) max = temp;\\n                }\\n            }\\n        }\\n        else if(table[i][0] < 2)\\n        {\\n            if(table[i][2] < 6)\\n            {\\n                temp = table[i][0]*1000 + table[i][1]*100 + table[i][2]*10 + table[i][3];\\n                if (temp > max) max = temp;\\n            }\\n        }\\n    }\\n    if(max <0) return ans;\\n    ans[2] = \\':\\';\\n    ans[5] = \\'\\\\0\\';\\n    ans[4] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[3] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[1] = max % 10 + \\'0\\';\\n    max /= 10;\\n    ans[0] = max % 10 + \\'0\\';\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 200580,
                "title": "c-simple-code-next-permutation",
                "content": "Using the next_permutation in c++, we can simply generate all permutations and just check 1 by 1.\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int ans = -1;\\n        string s;\\n        do {\\n            int h = A[0] * 10 + A[1];\\n            int m = A[2] * 10 + A[3];\\n            if(h >= 24 || m >= 60) continue;\\n            if(h * 60 + m > ans) {\\n                ans = h * 60 + m;\\n                s.clear();\\n                s.push_back(A[0] + 48);\\n                s.push_back(A[1] + 48);\\n                s.push_back(\\':\\');\\n                s.push_back(A[2] + 48);\\n                s.push_back(A[3] + 48);\\n            }\\n        } while(next_permutation(A.begin(), A.end()));\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int ans = -1;\\n        string s;\\n        do {\\n            int h = A[0] * 10 + A[1];\\n            int m = A[2] * 10 + A[3];\\n            if(h >= 24 || m >= 60) continue;\\n            if(h * 60 + m > ans) {\\n                ans = h * 60 + m;\\n                s.clear();\\n                s.push_back(A[0] + 48);\\n                s.push_back(A[1] + 48);\\n                s.push_back(\\':\\');\\n                s.push_back(A[2] + 48);\\n                s.push_back(A[3] + 48);\\n            }\\n        } while(next_permutation(A.begin(), A.end()));\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949801,
                "title": "easy-python-solution-strings-permutations",
                "content": "# Code\\n```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\n        x = permutations(arr)\\n        ans = []\\n        currTime = \"\"\\n        for i in x:\\n            h, m = \"\", \"\"\\n            for j in i[:2]:\\n                h += str(j)\\n            for j in i[2:]:\\n                m += str(j)\\n            \\n            if h >= \"00\" and h <= \"23\" and m >= \"00\" and m <= \"59\":\\n                if currTime == \"\":\\n                    currTime = f\"{h}:{m}\"\\n                else:\\n                    if currTime < f\"{h}:{m}\":\\n                        currTime = f\"{h}:{m}\"\\n        return currTime\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\n        x = permutations(arr)\\n        ans = []\\n        currTime = \"\"\\n        for i in x:\\n            h, m = \"\", \"\"\\n            for j in i[:2]:\\n                h += str(j)\\n            for j in i[2:]:\\n                m += str(j)\\n            \\n            if h >= \"00\" and h <= \"23\" and m >= \"00\" and m <= \"59\":\\n                if currTime == \"\":\\n                    currTime = f\"{h}:{m}\"\\n                else:\\n                    if currTime < f\"{h}:{m}\":\\n                        currTime = f\"{h}:{m}\"\\n        return currTime\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764422,
                "title": "using-if-else-if-and-only-loop-brute-force-solution-in-java",
                "content": "Here is the  basic and most brute force approach solution.  Over here I have made the basic If\\'s that are needed to keep in mind to solve it. \\n\\n\\n# Complexity\\n- Time complexity: The Time complexity is O(nlog). \\n\\n- Space complexity: The space Complexity is O(n);\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        List<Integer> list=new ArrayList<>();\\n        int p1=Integer.MIN_VALUE;\\n        int p2=Integer.MIN_VALUE;\\n        //Adding elements to the list\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            list.add(arr[i]);\\n        }\\n        //for hour need to get the first digit...1 or 2.. or 0\\n        //when list contains 2 zeores....\\n        if(list.contains(0))\\n        {\\n            List<Integer> l1= new ArrayList<>(list);\\n            int count=0;\\n            while(l1.contains(0) && count<2)\\n            {\\n                l1.remove((Integer)0);\\n                count++;\\n            }\\n            if(count==2)\\n            {\\n                Collections.sort(l1);\\n                System.out.println(l1);\\n                String str=\"\";\\n                if(l1.get(1)<=2 && l1.get(0)<=2)\\n                {\\n                    return l1.get(1)+\"\"+l1.get(0)+\":00\";\\n                }\\n                if(l1.get(0)==0 && l1.get(1)==0)\\n                {\\n                    return \"00:00\";\\n                } \\n                if(l1.get(0)==1 && l1.get(1)<=9 && l1.get(1)>2)\\n                {\\n                    return l1.get(0)+\"\"+l1.get(1)+\":\"+\"0\"+\"0\"; \\n                }\\n                if(l1.get(0)==2 && l1.get(1)<=3)\\n                {\\n                    return l1.get(0)+\"\"+l1.get(1)+\":\"+\"0\"+\"0\"; \\n                }\\n\\n                if(l1.get(0)==2 && l1.get(1)<=5 )\\n                {\\n                    return l1.get(0)+\"0:\"+l1.get(1)+\"0\";\\n                }\\n                if(l1.get(0)==2 && l1.get(1)>=5 )\\n                {\\n                    return l1.get(0)+\"0:\"+\"0\"+l1.get(1);\\n                }\\n                if(l1.get(1)<=1 && l1.get(0)<=1)\\n                {\\n                    return l1.get(1)+\"\"+l1.get(0)+\":00\";\\n                }\\n                else if(l1.get(0)>5)\\n                {\\n                    return \"0\"+l1.get(1)+\":0\"+l1.get(0);\\n                }\\n                return \"0\"+l1.get(1)+\":\"+l1.get(0)+\"0\"; \\n            }\\n        }\\n            for(int i=2;i>=0;i--)\\n            {\\n                if(list.contains(i))\\n                {\\n                    p1=i;// 2\\n                    list.remove((Integer)i);\\n                    break;\\n                }\\n            }\\n        int flag=0;\\n        if(p1==2)\\n        {\\n            for(int i=3;i>=0;i--)\\n            {\\n                if(list.contains(i))\\n                {\\n                    p2=i;\\n                    list.remove((Integer)i);\\n                    break;\\n                }\\n            }\\n        }\\n        else if(p1<=1)\\n        {\\n            for(int i=9;i>=0;i--)\\n            {\\n                if(list.contains(i))\\n                {\\n                    p2=i;\\n                    list.remove((Integer)i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(p1==Integer.MIN_VALUE || p2==Integer.MIN_VALUE)\\n        {\\n            return \"\";\\n        }\\n        Collections.sort(list);\\n        String str=\"\";\\n        if(list.get(0)==0)\\n        {\\n            if(list.get(1)<=5)\\n            {\\n                return p1+\"\"+p2+\":\"+list.get(1)+\"\"+list.get(0);\\n            }\\n            else if(list.get(1)>5)\\n            {\\n                return p1+\"\"+p2+\":\"+list.get(0)+\"\"+list.get(1);\\n            }\\n        }\\n        int dd1=list.get(0)+list.get(1)*10;\\n        int dd2=list.get(0)*10+list.get(1);\\n        if(dd1>=dd2 && dd1<=59)\\n        {\\n            str=dd1+\"\";\\n        }\\n        else if(dd2<dd1 && dd2<=59)\\n        {\\n            str=dd2+\"\";\\n        }\\n        else if(dd1>59 && dd2>59)\\n        {\\n            if(list.get(0)>5)\\n            {\\n                if(p2==0)\\n                {\\n                    return p2+\"\"+list.get(1)+\":\"+p1+\"\"+list.get(0);\\n                }\\n                else if(p1==0 && p2<=5)\\n                {\\n                    return p1+\"\"+list.get(1)+\":\"+p2+\"\"+list.get(0);\\n                }\\n                else if(p2==1)\\n                {\\n                    return p2+\"\"+list.get(1)+\":\"+p1+\"\"+list.get(0);\\n                }\\n                return \"\";\\n            }\\n            else if(p2==2 && p1>=0)\\n            {\\n                return \"\";\\n            }\\n            return \"\";\\n        }\\n        str=p1+\"\"+p2+\":\"+str;\\n        return str;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        List<Integer> list=new ArrayList<>();\\n        int p1=Integer.MIN_VALUE;\\n        int p2=Integer.MIN_VALUE;\\n        //Adding elements to the list\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            list.add(arr[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2358664,
                "title": "c-iterative-solution-backward-time-travel",
                "content": "A clock has 4 digits. For each position, there are some limitations. For example, in the first position of a time, you can put only 0, 1, or 2. The same goes for the other positions too. If you want to do this then the problem will become so complicated. So, here I come up with a brute-force approach. Just start the time from 23:59, then run a simple loop. In each loop the time will go backward by 1 minute, i.e 23:59, then  23:58, 23:57... The loop will end when the time is 00:00. For each time, check if all digits in the current time are present in the given array. We can check it by mapping the given digits. If we find all digits we can return the current time, which is our answer. If we finish our loop without a valid solution then the answer is empty string. Check the code for more clarification. :)  \\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int min = 59;\\n        int hour = 23;\\n        int mp[12] = {0};\\n        for (auto it : arr) {\\n            mp[it]++;\\n        }\\n        while (1) {\\n            string s;\\n            string m, h;\\n            m = to_string(min);\\n            h = to_string(hour);\\n            if (m.size() == 1)m = \\'0\\' + m;\\n            if (h.size() == 1)h = \\'0\\' + h;\\n            int tmp[12];\\n            for (int i = 0; i < 10; i++) {\\n                tmp[i] = mp[i];\\n\\n            }\\n            s = h + \":\" + m;\\n            bool f = true;\\n            for (int i = 0; i < 5 and f; i++) {\\n                if (i == 2)continue;\\n                if (tmp[s[i] - \\'0\\']) {\\n                    tmp[s[i] - \\'0\\']--;\\n                }\\n                else f = false;\\n            }\\n            if (f)return s;\\n            min--;\\n            if (min < 0) {\\n                min = 59;\\n                hour--;\\n            }\\n            if (hour < 0)break;\\n        }\\n        return \"\";\\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int min = 59;\\n        int hour = 23;\\n        int mp[12] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 2243093,
                "title": "generate-permutation-and-get-the-conditionally-max-one",
                "content": "```\\nvoid perm(vector<vector<int> > &res,int ind,int n , vector<int> &t,vector<int> a)\\n{\\n    if(ind == n)\\n    {\\n        res.push_back(t);\\n        return;\\n    }\\n    \\n    for(int i=ind;i<n;i++)\\n    {\\n        t.push_back(a[i]);\\n        swap(a[i],a[ind]);\\n        \\n        perm(res,ind+1,n,t,a);\\n        swap(a[i],a[ind]);\\n        t.pop_back();\\n    }\\n    \\n    \\n}\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& a) {\\n        \\n       vector<vector<int> > res;\\n       \\n        vector<int > t;\\n        perm(res,0,4,t,a);\\n        int ind = -1;\\n        sort(res.begin(),res.end());\\n        for(int i=0;i<res.size();i++)\\n        {\\n            \\n            \\n            if(res[i][0]<=2 && res[i][1]<=3 || res[i][0]<=1 )\\n            {\\n                if(res[i][2] <6)\\n                    ind = i;\\n            }\\n            else\\n            {\\n                break;                \\n            }\\n        }\\n        \\n        if(ind == -1)\\n            return \"\";\\n        \\n        \\n        t = res[ind];\\n        string ans = to_string(t[0])+to_string(t[1])+\":\"+ to_string(t[2])+to_string(t[3]);\\n        \\n      return ans;  \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvoid perm(vector<vector<int> > &res,int ind,int n , vector<int> &t,vector<int> a)\\n{\\n    if(ind == n)\\n    {\\n        res.push_back(t);\\n        return;\\n    }\\n    \\n    for(int i=ind;i<n;i++)\\n    {\\n        t.push_back(a[i]);\\n        swap(a[i],a[ind]);\\n        \\n        perm(res,ind+1,n,t,a);\\n        swap(a[i],a[ind]);\\n        t.pop_back();\\n    }\\n    \\n    \\n}\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& a) {\\n        \\n       vector<vector<int> > res;\\n       \\n        vector<int > t;\\n        perm(res,0,4,t,a);\\n        int ind = -1;\\n        sort(res.begin(),res.end());\\n        for(int i=0;i<res.size();i++)\\n        {\\n            \\n            \\n            if(res[i][0]<=2 && res[i][1]<=3 || res[i][0]<=1 )\\n            {\\n                if(res[i][2] <6)\\n                    ind = i;\\n            }\\n            else\\n            {\\n                break;                \\n            }\\n        }\\n        \\n        if(ind == -1)\\n            return \"\";\\n        \\n        \\n        t = res[ind];\\n        string ans = to_string(t[0])+to_string(t[1])+\":\"+ to_string(t[2])+to_string(t[3]);\\n        \\n      return ans;  \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093775,
                "title": "c-backtracking-permutation-approach",
                "content": "```\\npublic class Solution {\\n    public string LargestTimeFromDigits(int[] arr)\\n    {\\n        string result = string.Empty;\\n        HashSet<string> times = new HashSet<string>();\\n        \\n        // Find all permutations\\n        Backtrack(arr, 0, arr.Length - 1, ref times);\\n\\n        if (times.Count == 0)\\n            return result;\\n\\n        // Find out the maximum time from permutation\\n        int maxHour = 0;\\n        int maxMinute = 0;\\n        foreach(string time in times) \\n        {\\n            //time format = \"HH:mm\"\\n            int hr = Convert.ToInt32(time.Substring(0, 2));\\n            int minute = Convert.ToInt32(time.Substring(3,2));\\n            \\n            //Only update if hour is greater, or same hour with same or greater minutes\\n            if(hr > maxHour || (hr == maxHour && minute >= maxMinute)) \\n            {\\n                maxHour = hr;\\n                maxMinute = minute;\\n                result = time;\\n            }\\n        }\\n\\n        return result;\\n    }\\n    \\n    public static int[] Swap(ref int[] arr, int i, int j) \\n    {\\n        var temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n        return arr;\\n    }\\n    \\n    // Check if its a valid time and add to the hashset\\n    public static void AddValidTime(string time, ref HashSet<string> times)\\n    {\\n        //The format is -- HH:mm \\n        string hour = $\"{time[0]}{time[1]}\";\\n        string minute = $\"{time[2]}{time[3]}\";\\n        if (Convert.ToInt32(hour) < 24 && Convert.ToInt32(minute) < 60)\\n        {\\n            time = $\"{hour}:{minute}\";\\n            times.Add(time);\\n        }\\n    }\\n\\n    public static void Backtrack(int[] arr, int left, int right, ref HashSet<string> times) \\n    {\\n        // Base case\\n        if(left == right) \\n        {\\n            // Only add to the permutation list if it is a valid time\\n            string permutation = string.Join(string.Empty, arr);\\n            AddValidTime(permutation, ref times);\\n            return;\\n        }\\n        else \\n        {\\n            for (int i = left; i <= right; i++)\\n            {\\n                Swap(ref arr, left, i);\\n                Backtrack(arr, left + 1, right, ref times);\\n                Swap(ref arr, left, i);\\n            }\\n        }\\n\\n        return;\\n\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/daadbec4-5b0a-4d95-ab6a-8407f52bd994_1653985012.9550817.png)\\n\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\npublic class Solution {\\n    public string LargestTimeFromDigits(int[] arr)\\n    {\\n        string result = string.Empty;\\n        HashSet<string> times = new HashSet<string>();\\n        \\n        // Find all permutations\\n        Backtrack(arr, 0, arr.Length - 1, ref times);\\n\\n        if (times.Count == 0)\\n            return result;\\n\\n        // Find out the maximum time from permutation\\n        int maxHour = 0;\\n        int maxMinute = 0;\\n        foreach(string time in times) \\n        {\\n            //time format = \"HH:mm\"\\n            int hr = Convert.ToInt32(time.Substring(0, 2));\\n            int minute = Convert.ToInt32(time.Substring(3,2));\\n            \\n            //Only update if hour is greater, or same hour with same or greater minutes\\n            if(hr > maxHour || (hr == maxHour && minute >= maxMinute)) \\n            {\\n                maxHour = hr;\\n                maxMinute = minute;\\n                result = time;\\n            }\\n        }\\n\\n        return result;\\n    }\\n    \\n    public static int[] Swap(ref int[] arr, int i, int j) \\n    {\\n        var temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n        return arr;\\n    }\\n    \\n    // Check if its a valid time and add to the hashset\\n    public static void AddValidTime(string time, ref HashSet<string> times)\\n    {\\n        //The format is -- HH:mm \\n        string hour = $\"{time[0]}{time[1]}\";\\n        string minute = $\"{time[2]}{time[3]}\";\\n        if (Convert.ToInt32(hour) < 24 && Convert.ToInt32(minute) < 60)\\n        {\\n            time = $\"{hour}:{minute}\";\\n            times.Add(time);\\n        }\\n    }\\n\\n    public static void Backtrack(int[] arr, int left, int right, ref HashSet<string> times) \\n    {\\n        // Base case\\n        if(left == right) \\n        {\\n            // Only add to the permutation list if it is a valid time\\n            string permutation = string.Join(string.Empty, arr);\\n            AddValidTime(permutation, ref times);\\n            return;\\n        }\\n        else \\n        {\\n            for (int i = left; i <= right; i++)\\n            {\\n                Swap(ref arr, left, i);\\n                Backtrack(arr, left + 1, right, ref times);\\n                Swap(ref arr, left, i);\\n            }\\n        }\\n\\n        return;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856698,
                "title": "runtime-1-ms-faster-than-100-00-of-java-online-submissions-for-largest-time-for-given-digits",
                "content": "```public class LargestTimeForGivenDigits {\\n    int[] arr;\\n    int[] count = new int[10];\\n    int countOfNrGreaterThan5 = 0;\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        this.arr = arr;\\n        for (int i : arr) {\\n            count[i] += 1;\\n            if (i > 5) {\\n                countOfNrGreaterThan5++;\\n            }\\n            if (i >= 6 && count[i] > 2) {\\n                return \"\";\\n            }\\n            if (countOfNrGreaterThan5 >= 3) {\\n                return \"\";\\n            }\\n        }\\n\\n\\n        int hr1 = get1stHrIndex();\\n        if (hr1 == -1) {\\n            return \"\";\\n        }\\n        int hr2 = get2ndHrIndex(hr1);\\n        if (hr2 == -1) {\\n            return \"\";\\n        }\\n        int min1 = get1stMinuteIndex();\\n        if (min1 == -1) {\\n            return \"\";\\n        }\\n        int min2 = get2ndMinuteIndex();\\n        if (min2 == -1) {\\n            return \"\";\\n        }\\n        StringBuilder sb = new StringBuilder(5);\\n        return sb.append(hr1).append(hr2).append(\":\").append(min1).append(min2).toString();\\n    }\\n\\n    private int get2ndMinuteIndex() {\\n        return findByLoopingNTo0(9);\\n    }\\n\\n    private int get1stMinuteIndex() {\\n        return findByLoopingNTo0(5);\\n    }\\n\\n    private int get2ndHrIndex(int hr1) {\\n        if (hr1 == 2) {\\n            return findByLoopingNTo0(3);\\n        }\\n        return findByLoopingNTo0(9);\\n    }\\n\\n    private int get1stHrIndex() {\\n\\n        int i = 2;\\n        if (countOfNrGreaterThan5 >= 2) {\\n            i = 1;\\n        }\\n        return findByLoopingNTo0(i);\\n    }\\n\\n    private int findByLoopingNTo0(int n){\\n        for (int i = n; i >= 0; i--) {\\n            if (count[i] > 0) {\\n                count[i] -= 1;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "```public class LargestTimeForGivenDigits {\\n    int[] arr;\\n    int[] count = new int[10];\\n    int countOfNrGreaterThan5 = 0;\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        this.arr = arr;\\n        for (int i : arr) {\\n            count[i] += 1;\\n            if (i > 5) {\\n                countOfNrGreaterThan5++;\\n            }\\n            if (i >= 6 && count[i] > 2) {\\n                return \"\";\\n            }\\n            if (countOfNrGreaterThan5 >= 3) {\\n                return \"\";\\n            }\\n        }\\n\\n\\n        int hr1 = get1stHrIndex();\\n        if (hr1 == -1) {\\n            return \"\";\\n        }\\n        int hr2 = get2ndHrIndex(hr1);\\n        if (hr2 == -1) {\\n            return \"\";\\n        }\\n        int min1 = get1stMinuteIndex();\\n        if (min1 == -1) {\\n            return \"\";\\n        }\\n        int min2 = get2ndMinuteIndex();\\n        if (min2 == -1) {\\n            return \"\";\\n        }\\n        StringBuilder sb = new StringBuilder(5);\\n        return sb.append(hr1).append(hr2).append(\":\").append(min1).append(min2).toString();\\n    }\\n\\n    private int get2ndMinuteIndex() {\\n        return findByLoopingNTo0(9);\\n    }\\n\\n    private int get1stMinuteIndex() {\\n        return findByLoopingNTo0(5);\\n    }\\n\\n    private int get2ndHrIndex(int hr1) {\\n        if (hr1 == 2) {\\n            return findByLoopingNTo0(3);\\n        }\\n        return findByLoopingNTo0(9);\\n    }\\n\\n    private int get1stHrIndex() {\\n\\n        int i = 2;\\n        if (countOfNrGreaterThan5 >= 2) {\\n            i = 1;\\n        }\\n        return findByLoopingNTo0(i);\\n    }\\n\\n    private int findByLoopingNTo0(int n){\\n        for (int i = n; i >= 0; i--) {\\n            if (count[i] > 0) {\\n                count[i] -= 1;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1784653,
                "title": "faster-than-100-in-python",
                "content": "\\t\\tmax_time = -1\\n        max_time_str = \"\"\\n        for n1 in [0,1,2,3]:\\n            for n2 in [0,1,2,3]:\\n                if n2 == n1:\\n                    continue\\n                d1 = arr[n1]*10 + arr[n2]\\n                if d1>23:\\n                    continue\\n                for n3 in [0,1,2,3]:\\n                    if n3 == n1 or n3 == n2:\\n                        continue\\n                    for n4 in [0,1,2,3]:\\n                        if n4 == n1 or n4 == n2 or n4 == n3:\\n                            continue\\n                        d2 = arr[n3]*10 + arr[n4]\\n                        if d2>59:\\n                            continue\\n                        this_time = d1*100+d2\\n                        if this_time > max_time:\\n                            max_time = this_time\\n                            max_time_str = str(arr[n1])+str(arr[n2])+\":\"+str(arr[n3])+str(arr[n4])\\n        return max_time_str\\n```",
                "solutionTags": [],
                "code": "\\t\\tmax_time = -1\\n        max_time_str = \"\"\\n        for n1 in [0,1,2,3]:\\n            for n2 in [0,1,2,3]:\\n                if n2 == n1:\\n                    continue\\n                d1 = arr[n1]*10 + arr[n2]\\n                if d1>23:\\n                    continue\\n                for n3 in [0,1,2,3]:\\n                    if n3 == n1 or n3 == n2:\\n                        continue\\n                    for n4 in [0,1,2,3]:\\n                        if n4 == n1 or n4 == n2 or n4 == n3:\\n                            continue\\n                        d2 = arr[n3]*10 + arr[n4]\\n                        if d2>59:\\n                            continue\\n                        this_time = d1*100+d2\\n                        if this_time > max_time:\\n                            max_time = this_time\\n                            max_time_str = str(arr[n1])+str(arr[n2])+\":\"+str(arr[n3])+str(arr[n4])\\n        return max_time_str\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1707920,
                "title": "python-regex-and-itertools-permutations",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\t\\t# create regex for valid times\\n        time_re = re.compile(\\'[01][0-9]:[0-5][0-9]|2[0-3]:[0-5][0-9]\\')\\n        ans = \\'\\'\\n        for a,b,c,d in itertools.permutations(arr):\\n\\t\\t\\t# concat each number into a time string\\n            each_time = str(a) + str(b) + \\':\\' + str(c) + str(d)\\n\\t\\t\\t# compare each valid time string to the max so far.\\n            if time_re.match(each_time):\\n                ans = max(ans, each_time)\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n\\t\\t# create regex for valid times\\n        time_re = re.compile(\\'[01][0-9]:[0-5][0-9]|2[0-3]:[0-5][0-9]\\')\\n        ans = \\'\\'\\n        for a,b,c,d in itertools.permutations(arr):\\n\\t\\t\\t# concat each number into a time string\\n            each_time = str(a) + str(b) + \\':\\' + str(c) + str(d)\\n\\t\\t\\t# compare each valid time string to the max so far.\\n            if time_re.match(each_time):\\n                ans = max(ans, each_time)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704853,
                "title": "simple-commented-c",
                "content": "```\\n/*\\n    -Approach:\\n    -format of time is :\"HH:MM\" \\n    -in order to form largest possible time we have to form largest value of HH & MM which is valid hour & minutes\\n    -we will try different permutations of elements given array to form largest time\\n    \\n    - we will try different permutations of indexes of array\\n    - 3 different indexes of time can be formed by using 3 different loops\\n    - 4th index of time is (6-(sum of previous 3 indexes)) \\n    -Note: Sum of all the indexes is 6 (because we 4 elements)\\n*/\\n```\\n\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    string largestTimeFromDigits(vector<int>& arr) {\\n        \\n        string ans=\"\";\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<4;j++){\\n                for(int k=0;k<4;k++){\\n                    \\n                    //we can use each digit exactly once\\n                    if(i==j || j==k || k==i)\\n                        continue;\\n                    \\n                    //possible values of hh & mm\\n                    string hh=to_string(arr[i])+to_string(arr[j]);\\n                    string mm=to_string(arr[k]) + to_string(arr[6-i-j-k]);\\n                    string _time= hh + \":\" + mm;\\n                   \\n                    //comparasion in strings are done characeter by character\\n                    if( hh < \"24\" && mm < \"60\" && _time > ans)\\n                        ans=_time;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    -Approach:\\n    -format of time is :\"HH:MM\" \\n    -in order to form largest possible time we have to form largest value of HH & MM which is valid hour & minutes\\n    -we will try different permutations of elements given array to form largest time\\n    \\n    - we will try different permutations of indexes of array\\n    - 3 different indexes of time can be formed by using 3 different loops\\n    - 4th index of time is (6-(sum of previous 3 indexes)) \\n    -Note: Sum of all the indexes is 6 (because we 4 elements)\\n*/\\n```\n```\\n\\nclass Solution {\\npublic:\\n    \\n    string largestTimeFromDigits(vector<int>& arr) {\\n        \\n        string ans=\"\";\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<4;j++){\\n                for(int k=0;k<4;k++){\\n                    \\n                    //we can use each digit exactly once\\n                    if(i==j || j==k || k==i)\\n                        continue;\\n                    \\n                    //possible values of hh & mm\\n                    string hh=to_string(arr[i])+to_string(arr[j]);\\n                    string mm=to_string(arr[k]) + to_string(arr[6-i-j-k]);\\n                    string _time= hh + \":\" + mm;\\n                   \\n                    //comparasion in strings are done characeter by character\\n                    if( hh < \"24\" && mm < \"60\" && _time > ans)\\n                        ans=_time;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634912,
                "title": "949-python3-in-case-the-interviewer-asks-u-to-write-the-permutation-using-backtracking",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        def backtrack(curr):\\n            if len(curr) == n:\\n                return [list(curr)]\\n            res = []\\n            for i in range(n):\\n                if i not in curr:\\n                    res.extend(backtrack(curr + [i]))\\n            return res\\n\\n        n, res = len(arr), -1\\n\\n        for i1, i2, i3, i4 in backtrack([]):\\n            h, m = arr[i1] * 10 + arr[i2], arr[i3] * 10 + arr[i4]\\n            if h < 24 and m < 60:\\n                res = max(res, h * 60 + m)\\n\\n        return \"{:02d}:{:02d}\".format(res // 60, res % 60) if res != -1 else \"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        def backtrack(curr):\\n            if len(curr) == n:\\n                return [list(curr)]\\n            res = []\\n            for i in range(n):\\n                if i not in curr:\\n                    res.extend(backtrack(curr + [i]))\\n            return res\\n\\n        n, res = len(arr), -1\\n\\n        for i1, i2, i3, i4 in backtrack([]):\\n            h, m = arr[i1] * 10 + arr[i2], arr[i3] * 10 + arr[i4]\\n            if h < 24 and m < 60:\\n                res = max(res, h * 60 + m)\\n\\n        return \"{:02d}:{:02d}\".format(res // 60, res % 60) if res != -1 else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584831,
                "title": "fastest-python3-solution-in-just-1-line-of-actual-code",
                "content": "```python\\nfrom itertools import permutations\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        return max(map(lambda t: \"{}{}:{}{}\".format(*t) if 10*t[0]+t[1] < 24 and 10*t[2]+t[3] < 60 else \"\", permutations(arr)))\\n\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom itertools import permutations\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        return max(map(lambda t: \"{}{}:{}{}\".format(*t) if 10*t[0]+t[1] < 24 and 10*t[2]+t[3] < 60 else \"\", permutations(arr)))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455545,
                "title": "c-solution",
                "content": "```class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string result;\\n        for(int i=0;i<=3;++i){\\n           for(int j=0;j<=3;++j){\\n                for(int k=0;k<=3;++k){\\n                    if(i==j or j==k or k==i)\\n                        continue;\\n                    string hh = to_string(arr[i]) + to_string(arr[j]);\\n                    string mm = to_string(arr[k]) + to_string(arr[6-i-j-k]);\\n                    \\n                    string temp = hh + \":\" + mm;\\n                    \\n                    if(hh < \"24\" and mm < \"60\" and temp > result){\\n                        result = temp;\\n                    }\\n                }\\n            } \\n        }\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string result;\\n        for(int i=0;i<=3;++i){\\n           for(int j=0;j<=3;++j){\\n                for(int k=0;k<=3;++k){\\n                    if(i==j or j==k or k==i)\\n                        continue;\\n                    string hh = to_string(arr[i]) + to_string(arr[j]);\\n                    string mm = to_string(arr[k]) + to_string(arr[6-i-j-k]);\\n                    \\n                    string temp = hh + \":\" + mm;\\n                    \\n                    if(hh < \"24\" and mm < \"60\" and temp > result){\\n                        result = temp;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1405149,
                "title": "python-1-liner-92",
                "content": "\\n```\\ndef largestTimeFromDigits(self, arr: List[int]) -> str:\\n        return max((f\"{a}{b}:{c}{d}\" for a,b,c,d in permutations(arr) \\n                   if f\"{a}{b}\" < \"24\" and f\"{c}{d}\" < \"60\"), default = \"\")\\n ```",
                "solutionTags": [],
                "code": "```\\ndef largestTimeFromDigits(self, arr: List[int]) -> str:\\n        return max((f\"{a}{b}:{c}{d}\" for a,b,c,d in permutations(arr) \\n                   if f\"{a}{b}\" < \"24\" and f\"{c}{d}\" < \"60\"), default = \"\")\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 1377045,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string str;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 3; i >= 0; str += char(arr[i--] + \\'0\\'));\\n        do {\\n            if (str.substr(0, 2) < \"24\" && str.substr(2) < \"60\")\\n                return str.substr(0, 2) + \":\" + str.substr(2);\\n        } while (prev_permutation(str.begin(), str.end()));\\n        return \"\" ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string str;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 3; i >= 0; str += char(arr[i--] + \\'0\\'));\\n        do {\\n            if (str.substr(0, 2) < \"24\" && str.substr(2) < \"60\")\\n                return str.substr(0, 2) + \":\" + str.substr(2);\\n        } while (prev_permutation(str.begin(), str.end()));\\n        return \"\" ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 912416,
                "title": "java-0-ms",
                "content": "There are two valid options:\\n- 0..1; any; 0..5; any;\\n- 2; 0..3; 0..5; any;\\n\\nSo for the first case we need to have at least one digit to be in range of 0..1 and at least two digits in range of 0..5. It\\'s because 0..5 range includes 0..1.\\n\\nThe second case is slightly more complicated. \\'2\\' is a must. For range 0..3 we need to have at least two digits because \\'2\\' falls into this rang. Then we need to have one more for range 0..5 and again, because it includes 0..3 and \\'2\\' it should be 3+.\\n\\nPresent input as an array of ten elements each containing number of digits from input. For example for input [2, 9, 9, 1] it will be\\n[ 0, 1, 1, 0, 0, 0, 0, 0, 0, 2 ]\\n[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\\n\\ncalculate baskets:\\n[0..1] - 1\\n[0..3] - 2\\n[0..5] - 2\\n\\nAs we see the condition for [2; 0..3; 0..5; any] is not fullfilled. While we have \\'2\\' and 0..3 range, we lack digit in 0..5 range. However [0..1; any; 0..5; any] can be successfully combined.\\n\\nNow all we need to do - is to get max value from the range.\\n\\n```\\n    public static String largestTimeFromDigits(int[] input) {\\n        int[] numbers = new int[10];\\n        Arrays.fill(numbers, 0);\\n\\n        for (int n : input) {\\n            numbers[n]++;\\n        }\\n\\n        int zeroToOneBasket = numbers[0] + numbers[1];\\n        int zeroToThreeBasket = zeroToOneBasket + numbers[2] + numbers[3];\\n        int zeroToFiveBasket = zeroToThreeBasket + numbers[4] + numbers[5];\\n\\n        StringBuilder stringBuilder = new StringBuilder();\\n        if (numbers[2] > 0 && zeroToThreeBasket > 1 && zeroToFiveBasket > 2) {\\n            return stringBuilder\\n                    .append(removeMaxNLimitedBy(numbers, 2))\\n                    .append(removeMaxNLimitedBy(numbers, 3))\\n                    .append(\":\")\\n                    .append(removeMaxNLimitedBy(numbers, 5))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .toString();\\n        }\\n\\n        if (zeroToOneBasket > 0 && zeroToFiveBasket > 1) {\\n            return stringBuilder\\n                    .append(removeMaxNLimitedBy(numbers, 1))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .append(\":\")\\n                    .append(removeMaxNLimitedBy(numbers, 5))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .toString();\\n        }\\n\\n        return \"\";\\n    }\\n\\n    private static int removeMaxNLimitedBy(int[] numbers, int limitedBy) {\\n        for (int i = limitedBy; i >= 0; i--) {\\n            if (numbers[i] > 0) {\\n                numbers[i]--;\\n                return i;\\n            }\\n        }\\n\\n        throw new IllegalStateException();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public static String largestTimeFromDigits(int[] input) {\\n        int[] numbers = new int[10];\\n        Arrays.fill(numbers, 0);\\n\\n        for (int n : input) {\\n            numbers[n]++;\\n        }\\n\\n        int zeroToOneBasket = numbers[0] + numbers[1];\\n        int zeroToThreeBasket = zeroToOneBasket + numbers[2] + numbers[3];\\n        int zeroToFiveBasket = zeroToThreeBasket + numbers[4] + numbers[5];\\n\\n        StringBuilder stringBuilder = new StringBuilder();\\n        if (numbers[2] > 0 && zeroToThreeBasket > 1 && zeroToFiveBasket > 2) {\\n            return stringBuilder\\n                    .append(removeMaxNLimitedBy(numbers, 2))\\n                    .append(removeMaxNLimitedBy(numbers, 3))\\n                    .append(\":\")\\n                    .append(removeMaxNLimitedBy(numbers, 5))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .toString();\\n        }\\n\\n        if (zeroToOneBasket > 0 && zeroToFiveBasket > 1) {\\n            return stringBuilder\\n                    .append(removeMaxNLimitedBy(numbers, 1))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .append(\":\")\\n                    .append(removeMaxNLimitedBy(numbers, 5))\\n                    .append(removeMaxNLimitedBy(numbers, 9))\\n                    .toString();\\n        }\\n\\n        return \"\";\\n    }\\n\\n    private static int removeMaxNLimitedBy(int[] numbers, int limitedBy) {\\n        for (int i = limitedBy; i >= 0; i--) {\\n            if (numbers[i] > 0) {\\n                numbers[i]--;\\n                return i;\\n            }\\n        }\\n\\n        throw new IllegalStateException();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 910662,
                "title": "dfs-in-java-easy-to-understand-beats-80",
                "content": "the idea is to calculate all the valid times using backtracking,\\nand eliminate the recursion when we create a time that is not valid.\\n\\nwhen we have all the valid solutions, all we have to do is to sort the valid times by the default compare of String object, and then take the last one.\\n\\n\"\"\"\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        List<String> validTimes = dfs(arr);\\n        if(validTimes.size()==0) return \"\";\\n        Collections.sort(validTimes);\\n        String latestValidTime = validTimes.get(validTimes.size()-1);\\n        return latestValidTime.substring(0,2) + \":\" + latestValidTime.substring(2,4);\\n    }\\n    \\n    private List<String> dfs(int[] arr){\\n        List<String> validTimes = new ArrayList();\\n        Set<Integer> visitedIndexes = new HashSet();\\n        dfsHelper(validTimes, arr, \"\", visitedIndexes);\\n        return validTimes;\\n    }\\n    \\n    private void dfsHelper(List<String> validTimes, int[] arr, String builder, Set<Integer> visitedIndexes){\\n        if(visitedIndexes.size() ==4){\\n            validTimes.add(builder);\\n            return;\\n        }\\n        for(int i=0; i<4; i++){\\n            if(builder.length()==0 && arr[i] > 2) continue; //first digit is greater than 2\\n            if(builder.equals(\"2\") && arr[i] > 3) continue; //first 2 digits are greater than 24\\n            if(builder.length()==2 && arr[i] > 5) continue; // 3rd digit is greater than 5\\n            if(visitedIndexes.contains(i)) continue;\\n            visitedIndexes.add(i);\\n            dfsHelper(validTimes, arr, builder + String.valueOf(arr[i]), visitedIndexes);\\n            visitedIndexes.remove(i);\\n        }\\n    }\\n\"\"\"",
                "solutionTags": [],
                "code": "the idea is to calculate all the valid times using backtracking,\\nand eliminate the recursion when we create a time that is not valid.\\n\\nwhen we have all the valid solutions, all we have to do is to sort the valid times by the default compare of String object, and then take the last one.\\n\\n\"\"\"\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        List<String> validTimes = dfs(arr);\\n        if(validTimes.size()==0) return \"\";\\n        Collections.sort(validTimes);\\n        String latestValidTime = validTimes.get(validTimes.size()-1);\\n        return latestValidTime.substring(0,2) + \":\" + latestValidTime.substring(2,4);\\n    }\\n    \\n    private List<String> dfs(int[] arr){\\n        List<String> validTimes = new ArrayList();\\n        Set<Integer> visitedIndexes = new HashSet();\\n        dfsHelper(validTimes, arr, \"\", visitedIndexes);\\n        return validTimes;\\n    }\\n    \\n    private void dfsHelper(List<String> validTimes, int[] arr, String builder, Set<Integer> visitedIndexes){\\n        if(visitedIndexes.size() ==4){\\n            validTimes.add(builder);\\n            return;\\n        }\\n        for(int i=0; i<4; i++){\\n            if(builder.length()==0 && arr[i] > 2) continue; //first digit is greater than 2\\n            if(builder.equals(\"2\") && arr[i] > 3) continue; //first 2 digits are greater than 24\\n            if(builder.length()==2 && arr[i] > 5) continue; // 3rd digit is greater than 5\\n            if(visitedIndexes.contains(i)) continue;\\n            visitedIndexes.add(i);\\n            dfsHelper(validTimes, arr, builder + String.valueOf(arr[i]), visitedIndexes);\\n            visitedIndexes.remove(i);\\n        }\\n    }\\n\"\"\"",
                "codeTag": "Unknown"
            },
            {
                "id": 845666,
                "title": "easy-and-understandable-c-solution",
                "content": "```\\nvoid permutate(vector<int> &arr, int i, int n, vector<vector<int> > &valid){\\n    if(i>=n){\\n\\t\\t// checking if this permutation is valid or not. if it is a valid time we push it to the valid array.\\n        if( (arr[0]<2 and arr[2]<6) or (arr[0]==2 and arr[1]<4 and arr[2]<6) ){\\n            valid.push_back(arr);\\n        }\\n    } else{\\n        for(int j=i; j<n; j++){\\n            swap(arr[i], arr[j]);\\n            permutate(arr, i+1, n, valid);\\n            swap(arr[i], arr[j]);\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        vector<vector<int> > valid;\\n        permutate(arr, 0, 4, valid);\\n        \\n\\t\\t// if no valid permuations are found , return empty string.\\n        if(valid.size()==0) return \"\";\\n        \\n\\t\\t// Find the greatest time, convert it into string and return it.\\n        vector<int> ans = *max_element(valid.begin(), valid.end());\\n        string str = to_string(ans[0])+to_string(ans[1])+\":\"+to_string(ans[2])+to_string(ans[3]);\\n        return str;\\n    }\\n};\\n\\n```\\n\\nIf u like the solution then please upvote!",
                "solutionTags": [],
                "code": "```\\nvoid permutate(vector<int> &arr, int i, int n, vector<vector<int> > &valid){\\n    if(i>=n){\\n\\t\\t// checking if this permutation is valid or not. if it is a valid time we push it to the valid array.\\n        if( (arr[0]<2 and arr[2]<6) or (arr[0]==2 and arr[1]<4 and arr[2]<6) ){\\n            valid.push_back(arr);\\n        }\\n    } else{\\n        for(int j=i; j<n; j++){\\n            swap(arr[i], arr[j]);\\n            permutate(arr, i+1, n, valid);\\n            swap(arr[i], arr[j]);\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        vector<vector<int> > valid;\\n        permutate(arr, 0, 4, valid);\\n        \\n\\t\\t// if no valid permuations are found , return empty string.\\n        if(valid.size()==0) return \"\";\\n        \\n\\t\\t// Find the greatest time, convert it into string and return it.\\n        vector<int> ans = *max_element(valid.begin(), valid.end());\\n        string str = to_string(ans[0])+to_string(ans[1])+\":\"+to_string(ans[2])+to_string(ans[3]);\\n        return str;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827631,
                "title": "c-cpp-beats-100-of-solution-0-ms-simple-brute-force",
                "content": "Simple Brute force solution beats 100% of submissions. \\nThink of some corner cases, what digits can be possible on first and second place. \\nWe need maximum time, so start from max digits. \\n\\nPlease find the solution below . If this is useful to you , please help to upvote.\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string str;\\n        vector<int> count(10,0);\\n        for(int i=0;i<A.size();i++)\\n            count[A[i]]++;\\n        int i;\\n        \\n        for(i=2;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        if(str.length()==0)\\n            return str;\\n        if(str[0]==\\'2\\'){\\n            for(i=3;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            if(str.length()==1){\\n                if(count[1]>0){\\n                    str.pop_back();\\n                    str.push_back(\\'1\\');\\n                    count[2]++;\\n                    count[1]--;\\n                }   \\n                else if(count[0]>0){\\n                    str.pop_back();\\n                    str.push_back(\\'0\\');\\n                    count[2]++;\\n                    count[0]--;\\n                }\\n                else\\n                    return \"\";\\n            }\\n        }\\n        if(str[0]!=\\'2\\'){\\n            for(i=9;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n        }\\n        str+=\":\";\\n        \\n        for(i=5;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        if(str.length()==3){\\n            count[str[1]-\\'0\\']++;\\n            count[str[0]-\\'0\\']++;\\n            str=\"\";\\n            if(count[1]>0){\\n                str.push_back(\\'1\\');\\n                count[1]--;\\n            }   \\n            else if(count[0]>0){\\n                str.push_back(\\'0\\');\\n                count[0]--;\\n            }\\n            else\\n                return str;\\n            for(i=9;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            str+=\":\";\\n            for(i=5;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            if(str.length()==3)\\n                return \"\";\\n        }\\n            \\n        for(i=9;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string str;\\n        vector<int> count(10,0);\\n        for(int i=0;i<A.size();i++)\\n            count[A[i]]++;\\n        int i;\\n        \\n        for(i=2;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        if(str.length()==0)\\n            return str;\\n        if(str[0]==\\'2\\'){\\n            for(i=3;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            if(str.length()==1){\\n                if(count[1]>0){\\n                    str.pop_back();\\n                    str.push_back(\\'1\\');\\n                    count[2]++;\\n                    count[1]--;\\n                }   \\n                else if(count[0]>0){\\n                    str.pop_back();\\n                    str.push_back(\\'0\\');\\n                    count[2]++;\\n                    count[0]--;\\n                }\\n                else\\n                    return \"\";\\n            }\\n        }\\n        if(str[0]!=\\'2\\'){\\n            for(i=9;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n        }\\n        str+=\":\";\\n        \\n        for(i=5;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        if(str.length()==3){\\n            count[str[1]-\\'0\\']++;\\n            count[str[0]-\\'0\\']++;\\n            str=\"\";\\n            if(count[1]>0){\\n                str.push_back(\\'1\\');\\n                count[1]--;\\n            }   \\n            else if(count[0]>0){\\n                str.push_back(\\'0\\');\\n                count[0]--;\\n            }\\n            else\\n                return str;\\n            for(i=9;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            str+=\":\";\\n            for(i=5;i>=0;i--){\\n                if(count[i]>0){\\n                    str.push_back(i+\\'0\\');\\n                    count[i]--;\\n                    break;\\n                }\\n            }\\n            if(str.length()==3)\\n                return \"\";\\n        }\\n            \\n        for(i=9;i>=0;i--){\\n            if(count[i]>0){\\n                str.push_back(i+\\'0\\');\\n                count[i]--;\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827133,
                "title": "fixed-my-code-fails-test-on-submit-but-passes-same-test-on-run-code-what-gives",
                "content": "Anyone experience this weirdness on this or another problem.\\n\\nMy code fails a test on `Submit`, but passes that same test on `Run Code`.\\n\\nThe test is test `52` if tests are 1-indexed (I get `51/172 / 172 test cases passed.` and then this test fails). The test input is `[0,0,1,0]`, expected result `\"10:00\"`.\\n\\nWhen my code is run against this test on `Submit`, the result is incorrectly `\"00:00\"`; however, when my code is run against this test on `Run Code` using `Custom Testcase`, the result is correct (`\"10:00\"`). Was wondering if anyone has experienced this kind of discrepancy before and what might be the causes for same deterministic code running on the same input to produce different results depending on where it\\'s running. Seems odd.\\n\\nHere\\'s my code:\\n\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, nums: List[int]) -> str:\\n        res = self.findA(nums, 2, [3,5,9]) or self.findWA(nums, [1,9,5,9])\\n        return self.toTimeStr(res) if res else \"\"\\n    \\n    def findA(self, nums, a, conds, pre=[]):\\n        # nums = nums.copy()\\n        # pre = pre.copy()\\n        if a not in nums:\\n            return None\\n            \\n        nums.remove(a)\\n        pre.append(a)\\n        \\n        if not conds:\\n            return pre\\n        \\n        for b in range(conds[0], -1, -1):\\n            res = self.findA(nums, b, conds[1:], pre)\\n            if res:\\n                return res\\n        nums.append(a)\\n        pre.remove(a)\\n        return None\\n    \\n    def findWA(self, nums, conds, pre=[]):\\n        if not conds:\\n            return pre\\n        \\n        for b in range(conds[0], -1, -1):\\n            res = self.findA(nums, b, conds[1:], pre)\\n            if res:\\n                return res\\n        return None\\n    \\n    def toTimeStr(self, nums):\\n        hour = nums[0]*10 + nums[1]\\n        minute = nums[2]*10 + nums[3]\\n        return f\"{hour:02d}:{minute:02d}\"\\n        # return \"%d%d:%d%d\" % tuple(nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, nums: List[int]) -> str:\\n        res = self.findA(nums, 2, [3,5,9]) or self.findWA(nums, [1,9,5,9])\\n        return self.toTimeStr(res) if res else \"\"\\n    \\n    def findA(self, nums, a, conds, pre=[]):\\n        # nums = nums.copy()\\n        # pre = pre.copy()\\n        if a not in nums:\\n            return None\\n            \\n        nums.remove(a)\\n        pre.append(a)\\n        \\n        if not conds:\\n            return pre\\n        \\n        for b in range(conds[0], -1, -1):\\n            res = self.findA(nums, b, conds[1:], pre)\\n            if res:\\n                return res\\n        nums.append(a)\\n        pre.remove(a)\\n        return None\\n    \\n    def findWA(self, nums, conds, pre=[]):\\n        if not conds:\\n            return pre\\n        \\n        for b in range(conds[0], -1, -1):\\n            res = self.findA(nums, b, conds[1:], pre)\\n            if res:\\n                return res\\n        return None\\n    \\n    def toTimeStr(self, nums):\\n        hour = nums[0]*10 + nums[1]\\n        minute = nums[2]*10 + nums[3]\\n        return f\"{hour:02d}:{minute:02d}\"\\n        # return \"%d%d:%d%d\" % tuple(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825315,
                "title": "clean-and-production-quality-python3",
                "content": "Create valid permuations \\nwe can use `itertools` but if the interviewer says not to use it. it might take longer. The advantage in creating your own is that you wont make invalid permutations. \\n\\nMake a Dateobj so you can compare it cleanly. \\n\\n```\\n# standard permutation algorithm with dups\\ndef getValidPermutations(nums):\\n    output = []\\n    used = [False] * len(nums)\\n    def permute(curr, nums, used, output):\\n        if len(curr) > 0 and curr[0] > 2:\\n            return\\n        if len(curr) > 2 and curr[0] == 2 and curr[1] > 3:\\n            return\\n        if len(curr) > 3 and curr[2] > 5:\\n            return\\n        if len(curr) == len(nums):\\n            output.append(list(curr))\\n            return\\n        i = 0\\n        while i < len(nums):\\n            if used[i]:\\n                i += 1\\n                continue\\n            curr.append(nums[i])\\n            used[i] = True\\n            permute(curr, nums, used, output)\\n            used[i] = False\\n            curr.pop()\\n            \\n            while i < len(nums) - 1 and nums[i] == nums[i+1]:\\n                i+= 1            \\n            i += 1\\n            \\n    curr = []\\n    permute(curr, nums, used, output)\\n    return output    \\n\\n# Date object that takes in the hour and minute\\nclass DateObj:\\n    \\n    def __init__(self, hour = 0, minute = 0):\\n        self.hour = hour\\n        self.minute = minute\\n\\n    def __eq__(self, other):\\n        return self.hour == other.hour and self.minute == other.minute\\n    \\n    def __gt__(self, other):\\n        if self.hour > other.hour:\\n            return True\\n        if self.hour == other.hour and self.minute > other.minute:\\n            return True\\n        return False\\n    \\n    def convert(self, num):\\n        output = \"\"\\n        if num == 0:\\n            output = \"00\"\\n        elif 0 < num < 10:\\n            output = \"0\" + str(num % 10)\\n        else:\\n            output = str(num)\\n        return output\\n    \\n    def format(self):\\n        output = \"\"\\n        output += self.convert(self.hour)\\n        output += \":\" + self.convert(self.minute)\\n        return output\\n \\n# the actual solution\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        A = sorted(A)\\n        valid_times = getValidPermutations(A)\\n        if not valid_times:\\n            return \"\"\\n        max_time = DateObj()\\n        for times in valid_times:\\n            hour = times[0] * 10 + times[1]\\n            minute = times[2] * 10 + times[3]\\n            \\n            time = DateObj(hour, minute)\\n            max_time = max(max_time, time)\\n        \\n        return max_time.format()\\n```",
                "solutionTags": [],
                "code": "```\\n# standard permutation algorithm with dups\\ndef getValidPermutations(nums):\\n    output = []\\n    used = [False] * len(nums)\\n    def permute(curr, nums, used, output):\\n        if len(curr) > 0 and curr[0] > 2:\\n            return\\n        if len(curr) > 2 and curr[0] == 2 and curr[1] > 3:\\n            return\\n        if len(curr) > 3 and curr[2] > 5:\\n            return\\n        if len(curr) == len(nums):\\n            output.append(list(curr))\\n            return\\n        i = 0\\n        while i < len(nums):\\n            if used[i]:\\n                i += 1\\n                continue\\n            curr.append(nums[i])\\n            used[i] = True\\n            permute(curr, nums, used, output)\\n            used[i] = False\\n            curr.pop()\\n            \\n            while i < len(nums) - 1 and nums[i] == nums[i+1]:\\n                i+= 1            \\n            i += 1\\n            \\n    curr = []\\n    permute(curr, nums, used, output)\\n    return output    \\n\\n# Date object that takes in the hour and minute\\nclass DateObj:\\n    \\n    def __init__(self, hour = 0, minute = 0):\\n        self.hour = hour\\n        self.minute = minute\\n\\n    def __eq__(self, other):\\n        return self.hour == other.hour and self.minute == other.minute\\n    \\n    def __gt__(self, other):\\n        if self.hour > other.hour:\\n            return True\\n        if self.hour == other.hour and self.minute > other.minute:\\n            return True\\n        return False\\n    \\n    def convert(self, num):\\n        output = \"\"\\n        if num == 0:\\n            output = \"00\"\\n        elif 0 < num < 10:\\n            output = \"0\" + str(num % 10)\\n        else:\\n            output = str(num)\\n        return output\\n    \\n    def format(self):\\n        output = \"\"\\n        output += self.convert(self.hour)\\n        output += \":\" + self.convert(self.minute)\\n        return output\\n \\n# the actual solution\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        A = sorted(A)\\n        valid_times = getValidPermutations(A)\\n        if not valid_times:\\n            return \"\"\\n        max_time = DateObj()\\n        for times in valid_times:\\n            hour = times[0] * 10 + times[1]\\n            minute = times[2] * 10 + times[3]\\n            \\n            time = DateObj(hour, minute)\\n            max_time = max(max_time, time)\\n        \\n        return max_time.format()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824499,
                "title": "simple-brute-force-in-constant-time-most-easy-solution-try-max-to-min",
                "content": "Too much **frustate** from edge cases after that Tried Indirect Idea\\n\\n**Now try from Max time to Min time, Brute Force\\n23:59 to 00:00** \\n\\nIf we able to find then return it else empty string\\n\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        map<int,int> mp1,mp2;\\n        for(auto x:A) mp1[x]++;   //store digits in map\\n        mp2=mp1;  //2nd map to retrive count\\n        int hr=23,m=59;  //start from here to 00:00\\n        while(hr>=0)\\n        {\\n            \\n            /*\\n            Lets time 23:58\\n            h0->2 , h1->3\\n            m0->5 , m1->8\\n            \\n            */\\n            int h0=hr/10,h1=hr%10; \\n            int m0=m/10,m1=m%10;\\n            int p=0;  //check for validation\\n            \\n            if(mp1[h0]>0) mp1[h0]--; else p=1;\\n            if(mp1[h1]>0) mp1[h1]--; else p=1;\\n            if(mp1[m0]>0) mp1[m0]--; else p=1;\\n            if(mp1[m1]>0) mp1[m1]--; else p=1;\\n            \\n            if(p==0) //if we found our combination in map then rturn its string format \\n            {\\n                string s=\"\";\\n                s=to_string(h0)+to_string(h1)+\\':\\'+to_string(m0)+to_string(m1);\\n                return s;\\n            }\\n            mp1=mp2;  //retrive original count\\n            //Please note 10:60 is not valid , it\\'s actually 11:00\\n            if(m==0)  //if minute ->0 , menas we have to decrease hr by 1 and set min to 59\\n            {\\n                hr-=1;m=59;\\n            }\\n            else\\n            {\\n                m--;  //drecease till zero\\n            }\\n            \\n        }\\n        return \"\"; //oh...no time found , invalid input\\n    }\\n};\\n```\\n\\n***Time Complexity : O(24 * 60) ~ O(1)\\nSpace complexity: O(1)***\\n\\n**Feel free to comment if any improvement needed**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        map<int,int> mp1,mp2;\\n        for(auto x:A) mp1[x]++;   //store digits in map\\n        mp2=mp1;  //2nd map to retrive count\\n        int hr=23,m=59;  //start from here to 00:00\\n        while(hr>=0)\\n        {\\n            \\n            /*\\n            Lets time 23:58\\n            h0->2 , h1->3\\n            m0->5 , m1->8\\n            \\n            */\\n            int h0=hr/10,h1=hr%10; \\n            int m0=m/10,m1=m%10;\\n            int p=0;  //check for validation\\n            \\n            if(mp1[h0]>0) mp1[h0]--; else p=1;\\n            if(mp1[h1]>0) mp1[h1]--; else p=1;\\n            if(mp1[m0]>0) mp1[m0]--; else p=1;\\n            if(mp1[m1]>0) mp1[m1]--; else p=1;\\n            \\n            if(p==0) //if we found our combination in map then rturn its string format \\n            {\\n                string s=\"\";\\n                s=to_string(h0)+to_string(h1)+\\':\\'+to_string(m0)+to_string(m1);\\n                return s;\\n            }\\n            mp1=mp2;  //retrive original count\\n            //Please note 10:60 is not valid , it\\'s actually 11:00\\n            if(m==0)  //if minute ->0 , menas we have to decrease hr by 1 and set min to 59\\n            {\\n                hr-=1;m=59;\\n            }\\n            else\\n            {\\n                m--;  //drecease till zero\\n            }\\n            \\n        }\\n        return \"\"; //oh...no time found , invalid input\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824368,
                "title": "greedy-dfs-c-0ms-best100",
                "content": "```\\nclass Solution {\\npublic:\\n    string ans=\"\";\\n    bool gdfs(string a,vector<int> &A){\\n        int sz=a.size(),es[]={2,3,0,5,9},end;         // es[] acts to provide upper inclusive limit for value in particular pos\\n        if(sz==2)return gdfs(a+\\':\\',A);                // add \\':\\' in between\\n        if(sz==5){ans=a;return true;}                 // choose the first best ans, return true to stop all recusions\\n        if(a[0]<\\'2\\')es[1]=9;                          // another important ;P condition.\\n        end=es[sz];\\n        for(int i=end;i>-1;i--)                      // iterate in a greedy fashion\\n            for(auto &j:A){     \\n                if(i==j){                                       \\n                    j=-1;                                       \\n                    if(gdfs(a+char(\\'0\\'+i),A))return true;\\n                    j=i;\\n                }\\n            }\\n        return false;\\n    }\\n    string largestTimeFromDigits(vector<int>& A) {\\n        gdfs(\"\",A);\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string ans=\"\";\\n    bool gdfs(string a,vector<int> &A){\\n        int sz=a.size(),es[]={2,3,0,5,9}",
                "codeTag": "Java"
            },
            {
                "id": 824312,
                "title": "c-92-time-solution-backtracking-o-1",
                "content": "#### The idea is constrained backtracking\\nWe have the following rules:\\nHH -> have to be less than 24\\nMM -> Have to be less than 60\\n\\nCreate all possible permutations, and then save the largest one that is valid.\\nWe need to sort first to simply create ascending permutaions, but because the array is length of 4, the sort is also O(1).\\n\\n\\n#### Time complexity breakthrough:\\nSince we have only 4 items in A, we will create 4! permutations.\\nThis results in O(1)\\n\\nIf we had N length array, the complexity would be O(N!)\\n\\n#### Space complexity:\\nSame as time here.\\nDeepest recursion stack is 4.\\n\\n\\n```\\npublic class Solution {\\n    public string LargestTimeFromDigits(int[] A)\\n    {\\n        Array.Sort(A);\\n        int[] res = new int[4];\\n        int[] final_res = new int[4];\\n        bool hasFinished = false;\\n\\n        void GeneratePermutations(int i)\\n        {\\n            if (i == 4)\\n            {\\n                res.CopyTo(final_res, 0);\\n                hasFinished = true;\\n                return;\\n            }\\n\\n\\n            foreach (var (num, index) in A.Select((num, index) => (num, index)))\\n            {\\n                if (num == -1)\\n                    continue;\\n\\n                if (i == 1)\\n                {\\n                    if (res[0] * 10 + num < 24)\\n                    {\\n                        // Permute\\n                        A[index] = -1;\\n                        res[i] = num;\\n\\n                        GeneratePermutations(i + 1);\\n\\n                        // Backtrack\\n                        res[i] = -1;\\n                        A[index] = num;\\n                    }\\n                }\\n                else if (i == 3)\\n                {\\n                    if(res[2] * 10 + num < 60)\\n                    {\\n                        // permute\\n                        A[index] = -1;\\n                        res[i] = num;\\n\\n                        GeneratePermutations(i + 1);\\n\\n                        // backtrack\\n                        res[i] = -1;\\n                        A[index] = num;\\n                    }\\n                }\\n                else\\n                {\\n                    // permute\\n                    A[index] = -1;\\n                    res[i] = num;\\n\\n                    GeneratePermutations(i + 1);\\n\\n                    // backtrack\\n                    res[i] = -1;\\n                    A[index] = num;\\n                }\\n\\n            }\\n        }\\n\\n        GeneratePermutations(0);\\n\\n        if (!hasFinished)\\n        {\\n            return \"\";\\n        }\\n\\n        return string.Format(\"{0}{1}:{2}{3}\", final_res[0], final_res[1], final_res[2], final_res[3]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string LargestTimeFromDigits(int[] A)\\n    {\\n        Array.Sort(A);\\n        int[] res = new int[4];\\n        int[] final_res = new int[4];\\n        bool hasFinished = false;\\n\\n        void GeneratePermutations(int i)\\n        {\\n            if (i == 4)\\n            {\\n                res.CopyTo(final_res, 0);\\n                hasFinished = true;\\n                return;\\n            }\\n\\n\\n            foreach (var (num, index) in A.Select((num, index) => (num, index)))\\n            {\\n                if (num == -1)\\n                    continue;\\n\\n                if (i == 1)\\n                {\\n                    if (res[0] * 10 + num < 24)\\n                    {\\n                        // Permute\\n                        A[index] = -1;\\n                        res[i] = num;\\n\\n                        GeneratePermutations(i + 1);\\n\\n                        // Backtrack\\n                        res[i] = -1;\\n                        A[index] = num;\\n                    }\\n                }\\n                else if (i == 3)\\n                {\\n                    if(res[2] * 10 + num < 60)\\n                    {\\n                        // permute\\n                        A[index] = -1;\\n                        res[i] = num;\\n\\n                        GeneratePermutations(i + 1);\\n\\n                        // backtrack\\n                        res[i] = -1;\\n                        A[index] = num;\\n                    }\\n                }\\n                else\\n                {\\n                    // permute\\n                    A[index] = -1;\\n                    res[i] = num;\\n\\n                    GeneratePermutations(i + 1);\\n\\n                    // backtrack\\n                    res[i] = -1;\\n                    A[index] = num;\\n                }\\n\\n            }\\n        }\\n\\n        GeneratePermutations(0);\\n\\n        if (!hasFinished)\\n        {\\n            return \"\";\\n        }\\n\\n        return string.Format(\"{0}{1}:{2}{3}\", final_res[0], final_res[1], final_res[2], final_res[3]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824240,
                "title": "largest-time-for-given-digits-c-using-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        \\n        pair<int, int> ans{-1, -1};\\n        \\n        do\\n        {\\n            int hours, minutes;\\n            \\n            hours = A[0]*10 + A[1];\\n            minutes = A[2]*10 + A[3];\\n            if(hours < 24 && minutes < 60)\\n                ans = max(ans, make_pair(hours, minutes));\\n        } while(next_permutation(A.begin(), A.end()));\\n        \\n        if(ans == make_pair(-1, -1))\\n            return \"\";\\n        \\n        string hours, minutes;\\n        // if(hour is less than 10)\\n        if(ans.first/10 == 0)\\n            hours += \\'0\\';\\n        hours += to_string(ans.first);\\n                // if(min is less than 10)\\n        if(ans.second/10 == 0)\\n            minutes += \\'0\\';\\n        minutes += to_string(ans.second);\\n        return hours + \\':\\' + minutes;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        \\n        pair<int, int> ans{-1, -1};\\n        \\n        do\\n        {\\n            int hours, minutes;\\n            \\n            hours = A[0]*10 + A[1];\\n            minutes = A[2]*10 + A[3];\\n            if(hours < 24 && minutes < 60)\\n                ans = max(ans, make_pair(hours, minutes));\\n        } while(next_permutation(A.begin(), A.end()));\\n        \\n        if(ans == make_pair(-1, -1))\\n            return \"\";\\n        \\n        string hours, minutes;\\n        // if(hour is less than 10)\\n        if(ans.first/10 == 0)\\n            hours += \\'0\\';\\n        hours += to_string(ans.first);\\n                // if(min is less than 10)\\n        if(ans.second/10 == 0)\\n            minutes += \\'0\\';\\n        minutes += to_string(ans.second);\\n        return hours + \\':\\' + minutes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824204,
                "title": "java-count-digits-and-find-max-based-on-condition-simple-to-understand-21ms-40mb",
                "content": "\\n```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int[] nums = new int[10];\\n        int hasLessThan5 = 0;\\n        for(int a : A){\\n            nums[a]++;\\n            if(a < 6){\\n                hasLessThan5++;\\n            }\\n        }\\n        \\n        if(hasLessThan5 < 2){\\n            // will not fall under [0-2]X:[0-5]X\\n            return \"\";\\n        }\\n        \\n        String time = \"\";\\n        if(nums[2] > 0){\\n            nums[2]--;\\n            // reduce count of 2 and find max of 0-3\\n            int number = getMaxNumber(3, nums) ;\\n            if(number > -1){\\n                time = \"2\" + number + \":\";\\n//                System.out.println(time);\\n                int mins = getMaxNumber(5, nums) ;\\n                if(mins > -1){\\n//                    System.out.println(mins);\\n                    int munit = getMaxNumber(9, nums) ;\\n                    if(munit > -1){\\n//                        System.out.println(munit + \"munit hr\");\\n                        return time + mins + munit;\\n                    }\\n                    nums[mins]++;\\n                    // reset minute number\\n                }\\n                \\n                nums[number]++;\\n//                System.out.println(\"reset h \" + number + \" m \" + mins);\\n                time = \"\";\\n                // reset hour number\\n            }\\n            \\n            nums[2]++;\\n            // not valid hour with 2X or combination . Reset count of 2\\n        }\\n        \\n        if(nums[1] > 0 || nums[0] > 0){\\n            int hour = getMaxNumber(1, nums) ;\\n//            System.out.println(hour);\\n            if(hour > -1){\\n                int hunit = getMaxNumber(9, nums) ;\\n//                System.out.println(hunit);\\n                if(hunit > -1){\\n                    time = hour +\"\" + hunit + \":\";\\n                    System.out.println(time);\\n                    int mins = getMaxNumber(5, nums) ;\\n//                    System.out.println(mins);\\n                    if(mins > -1){\\n                        int munit = getMaxNumber(9, nums) ;\\n//                        System.out.println(munit + \"munit\");\\n                        if(munit > -1){\\n                            return time + mins + munit;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n    \\n    public int getMaxNumber(int upperLimit, int[] nums){\\n        for(int i = upperLimit; i >= 0; i--){\\n            if(nums[i] > 0){\\n                nums[i]--; // kept here since common for all\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int[] nums = new int[10];\\n        int hasLessThan5 = 0;\\n        for(int a : A){\\n            nums[a]++;\\n            if(a < 6){\\n                hasLessThan5++;\\n            }\\n        }\\n        \\n        if(hasLessThan5 < 2){\\n            // will not fall under [0-2]X:[0-5]X\\n            return \"\";\\n        }\\n        \\n        String time = \"\";\\n        if(nums[2] > 0){\\n            nums[2]--;\\n            // reduce count of 2 and find max of 0-3\\n            int number = getMaxNumber(3, nums) ;\\n            if(number > -1){\\n                time = \"2\" + number + \":\";\\n//                System.out.println(time);\\n                int mins = getMaxNumber(5, nums) ;\\n                if(mins > -1){\\n//                    System.out.println(mins);\\n                    int munit = getMaxNumber(9, nums) ;\\n                    if(munit > -1){\\n//                        System.out.println(munit + \"munit hr\");\\n                        return time + mins + munit;\\n                    }\\n                    nums[mins]++;\\n                    // reset minute number\\n                }\\n                \\n                nums[number]++;\\n//                System.out.println(\"reset h \" + number + \" m \" + mins);\\n                time = \"\";\\n                // reset hour number\\n            }\\n            \\n            nums[2]++;\\n            // not valid hour with 2X or combination . Reset count of 2\\n        }\\n        \\n        if(nums[1] > 0 || nums[0] > 0){\\n            int hour = getMaxNumber(1, nums) ;\\n//            System.out.println(hour);\\n            if(hour > -1){\\n                int hunit = getMaxNumber(9, nums) ;\\n//                System.out.println(hunit);\\n                if(hunit > -1){\\n                    time = hour +\"\" + hunit + \":\";\\n                    System.out.println(time);\\n                    int mins = getMaxNumber(5, nums) ;\\n//                    System.out.println(mins);\\n                    if(mins > -1){\\n                        int munit = getMaxNumber(9, nums) ;\\n//                        System.out.println(munit + \"munit\");\\n                        if(munit > -1){\\n                            return time + mins + munit;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n    \\n    public int getMaxNumber(int upperLimit, int[] nums){\\n        for(int i = upperLimit; i >= 0; i--){\\n            if(nums[i] > 0){\\n                nums[i]--; // kept here since common for all\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824133,
                "title": "python3-simple-python3-solution-5-lines",
                "content": "The size of the possible search space is `4!=24`; thus, a simple brute force solution will be enough.\\n\\nHere I used `permutation` for simplicity.\\n\\nThe time complexity of this question is `O(C)`.\\n\\n```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        ans = \"\"\\n        for p in permutations(A):\\n            if p[0] * 10 + p[1] <= 23 and p[2] <= 5:\\n                cand = \"{0}{1}:{2}{3}\".format(*p)\\n                ans = max(ans, cand)\\n        return ans\\n```\\n\\nThank you.",
                "solutionTags": [],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        ans = \"\"\\n        for p in permutations(A):\\n            if p[0] * 10 + p[1] <= 23 and p[2] <= 5:\\n                cand = \"{0}{1}:{2}{3}\".format(*p)\\n                ans = max(ans, cand)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824023,
                "title": "c-short-std-sort-std-prev-permutation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) const\\n    {\\n        sort(begin(A), end(A), greater());\\n\\n        do {\\n            if (A[0] * 10 + A[1] <= 23 && A[2] <= 5) {\\n                ostringstream oss;\\n                oss << A[0] << A[1] << \\':\\' << A[2] << A[3];\\n                return oss.str();\\n            }\\n        } while (prev_permutation(begin(A), end(A)));\\n\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) const\\n    {\\n        sort(begin(A), end(A), greater());\\n\\n        do {\\n            if (A[0] * 10 + A[1] <= 23 && A[2] <= 5) {\\n                ostringstream oss;\\n                oss << A[0] << A[1] << \\':\\' << A[2] << A[3];\\n                return oss.str();\\n            }\\n        } while (prev_permutation(begin(A), end(A)));\\n\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823732,
                "title": "javascript-dfs-backtrack-explained-99-speed",
                "content": "Compute all permutations but do not store them all at once. A DFS backtrack generates permutations dynamically and when the base condition of all digits having been used is satisfied, the resulting time is checked for validity and for whether it surpasses the maximum observed. Return the maximum found through the DFS with appropriate formatting.\\n\\n```\\nconst largestTimeFromDigits = A => {\\n    \\n    const visited = new Array(4).fill(false);   //Tracking digits used in permutation construction by index in A\\n    let max = -1, ans = [];                     //Variables for tracking maximum observed time\\n    \\n    //Given some array of numbers time representing a permutation of A that is either fully constructed or in the process of being constructed\\n    const DFSBacktrack = (time = []) => {\\n        if (time.length === 4 && isValidTime(time)){  //If the time represented by the sequence is complete and valid\\n            const timeNum = parseInt(time.join(\\'\\'));  //Get the time in number format and compare to maximum observed\\n            if (max < timeNum){ \\n                max = timeNum;                        //If a new maximum was found, record it as a number and in result array\\n                ans = [...time];\\n            }\\n            return;\\n        }    \\n        \\n        for (let i = 0; i < A.length; i++){           //If array not full, continue building the current permutation via DFS backtrack\\n            if (visited[i]) continue;\\n            visited[i] = true;\\n            time.push(A[i]);\\n            DFSBacktrack(time);\\n            visited[i] = false;\\n            time.pop();\\n        }\\n        return;\\n    };\\n    \\n    //Checks if some array of numbers time of length >= 3 representing a permuation of A qualifies as a valid time\\n    const isValidTime = time => (time[0] === 2 && time[1] < 4 && time[2] <= 5) || (time[0] <= 1 && time[2] <= 5);\\n    \\n    //Run the DFS to get the maximum time, add the semicolon and return\\n    DFSBacktrack();\\n    if (!ans.length) return \"\";\\n    ans.splice(2,0,\":\");\\n    return ans.join(\\'\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst largestTimeFromDigits = A => {\\n    \\n    const visited = new Array(4).fill(false);   //Tracking digits used in permutation construction by index in A\\n    let max = -1, ans = [];                     //Variables for tracking maximum observed time\\n    \\n    //Given some array of numbers time representing a permutation of A that is either fully constructed or in the process of being constructed\\n    const DFSBacktrack = (time = []) => {\\n        if (time.length === 4 && isValidTime(time)){  //If the time represented by the sequence is complete and valid\\n            const timeNum = parseInt(time.join(\\'\\'));  //Get the time in number format and compare to maximum observed\\n            if (max < timeNum){ \\n                max = timeNum;                        //If a new maximum was found, record it as a number and in result array\\n                ans = [...time];\\n            }\\n            return;\\n        }    \\n        \\n        for (let i = 0; i < A.length; i++){           //If array not full, continue building the current permutation via DFS backtrack\\n            if (visited[i]) continue;\\n            visited[i] = true;\\n            time.push(A[i]);\\n            DFSBacktrack(time);\\n            visited[i] = false;\\n            time.pop();\\n        }\\n        return;\\n    };\\n    \\n    //Checks if some array of numbers time of length >= 3 representing a permuation of A qualifies as a valid time\\n    const isValidTime = time => (time[0] === 2 && time[1] < 4 && time[2] <= 5) || (time[0] <= 1 && time[2] <= 5);\\n    \\n    //Run the DFS to get the maximum time, add the semicolon and return\\n    DFSBacktrack();\\n    if (!ans.length) return \"\";\\n    ans.splice(2,0,\":\");\\n    return ans.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823637,
                "title": "c-brute-force-with-linq-7-lines",
                "content": "```\\n    var digits=String.Concat(A.Select(x=>x+\"\").OrderBy(x=>x));\\n    var hora=DateTime.Parse(\"11:59 PM\"); \\n    while (hora >= DateTime.Parse(\"00:00 AM\")) \\n    {\\n        var newdig=String.Concat($\"{hora:HHmm}\".OrderBy(x=>x));\\n        if (newdig==digits) return $\"{hora:HH:mm}\"; \\n        hora=hora.AddMinutes(-1);\\n    }\\n    return \"\";\\n```",
                "solutionTags": [],
                "code": "```\\n    var digits=String.Concat(A.Select(x=>x+\"\").OrderBy(x=>x));\\n    var hora=DateTime.Parse(\"11:59 PM\"); \\n    while (hora >= DateTime.Parse(\"00:00 AM\")) \\n    {\\n        var newdig=String.Concat($\"{hora:HHmm}\".OrderBy(x=>x));\\n        if (newdig==digits) return $\"{hora:HH:mm}\"; \\n        hora=hora.AddMinutes(-1);\\n    }\\n    return \"\";\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823509,
                "title": "java-faster-than-90-simple-logic-map-based",
                "content": "```\\nclass Solution {\\n    Map<Integer, Integer> map;\\n    public String largestTimeFromDigits(int[] A) {\\n       \\n        mapReset(A);\\n        StringBuilder time = new StringBuilder();\\n        // Finding largest time in hr\\n        String hour = hourMinute(23);\\n        // If hour is not possible, return empty string\\n        if(hour.isEmpty())\\n            return \"\";\\n        int hr = Integer.parseInt(hour);\\n        // Finding largest time in minute from remaining elements\\n        time.append(hour).append(\":\").append(hourMinute(59));\\n        // Case if hours are valid and minutes are not valid eg : [2,0,6,6] -> hr = 20 and min = 66, not valid, but hr = 06 and min = 26 is valid\\n        if(map.size()>0){\\n            mapReset(A);\\n            time = new StringBuilder();\\n            // Finding new hr lower than preivous one and minute from remaining elements again\\n            time.append(hourMinute(hr-1)).append(\":\").append(hourMinute(59));\\n        }\\n        // Valid time cannot be made\\n        if(map.size()>0)\\n            return \"\";\\n        return time.toString();\\n    }\\n    \\n    public void mapReset(int[] A){\\n        map = new HashMap<>();\\n        for(int a :A)\\n            map.put(a, map.getOrDefault(a,0)+1);\\n    }\\n    \\n    public String hourMinute(int start){\\n        StringBuilder time = new StringBuilder();\\n        for(int i=start;i>=0; i--){\\n            int r = i%10;\\n            int q = i/10;\\n            if(map.containsKey(r) && map.containsKey(q)){\\n                if(r==q && map.get(r)<2)\\n                    continue;\\n                map.put(r, map.get(r)-1);\\n                if(map.get(r)==0)\\n                    map.remove(r);\\n                map.put(q, map.get(q)-1);\\n                if(map.get(q)==0)\\n                    map.remove(q);\\n                time.append(q).append(r);\\n                break;\\n            }\\n        }\\n        return time.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> map;\\n    public String largestTimeFromDigits(int[] A) {\\n       \\n        mapReset(A);\\n        StringBuilder time = new StringBuilder();\\n        // Finding largest time in hr\\n        String hour = hourMinute(23);\\n        // If hour is not possible, return empty string\\n        if(hour.isEmpty())\\n            return \"\";\\n        int hr = Integer.parseInt(hour);\\n        // Finding largest time in minute from remaining elements\\n        time.append(hour).append(\":\").append(hourMinute(59));\\n        // Case if hours are valid and minutes are not valid eg : [2,0,6,6] -> hr = 20 and min = 66, not valid, but hr = 06 and min = 26 is valid\\n        if(map.size()>0){\\n            mapReset(A);\\n            time = new StringBuilder();\\n            // Finding new hr lower than preivous one and minute from remaining elements again\\n            time.append(hourMinute(hr-1)).append(\":\").append(hourMinute(59));\\n        }\\n        // Valid time cannot be made\\n        if(map.size()>0)\\n            return \"\";\\n        return time.toString();\\n    }\\n    \\n    public void mapReset(int[] A){\\n        map = new HashMap<>();\\n        for(int a :A)\\n            map.put(a, map.getOrDefault(a,0)+1);\\n    }\\n    \\n    public String hourMinute(int start){\\n        StringBuilder time = new StringBuilder();\\n        for(int i=start;i>=0; i--){\\n            int r = i%10;\\n            int q = i/10;\\n            if(map.containsKey(r) && map.containsKey(q)){\\n                if(r==q && map.get(r)<2)\\n                    continue;\\n                map.put(r, map.get(r)-1);\\n                if(map.get(r)==0)\\n                    map.remove(r);\\n                map.put(q, map.get(q)-1);\\n                if(map.get(q)==0)\\n                    map.remove(q);\\n                time.append(q).append(r);\\n                break;\\n            }\\n        }\\n        return time.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823457,
                "title": "c-4ms-permutation-clean-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans = \"\";\\n        sort(A.begin(),A.end());\\n        do{\\n            if((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5)\\n                ans = to_string(A[0])+to_string(A[1])+\":\"+to_string(A[2])+to_string(A[3]);\\n        }while(next_permutation(A.begin(),A.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans = \"\";\\n        sort(A.begin(),A.end());\\n        do{\\n            if((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5)\\n                ans = to_string(A[0])+to_string(A[1])+\":\"+to_string(A[2])+to_string(A[3]);\\n        }while(next_permutation(A.begin(),A.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823424,
                "title": "javascript-brute-force-short-but-slow",
                "content": "```\\nvar largestTimeFromDigits = function(A) {\\n    \\n    const cmp = A.sort().join(\"\");\\n    for(let i=23; i>=0; i--){\\n        for(let j=59; j>=0; j--){\\n            if(cmp==[Math.floor(i/10),i%10,Math.floor(j/10),j%10].sort().join(\"\"))\\n                return \\'\\'+Math.floor(i/10)+i%10+\\':\\'+Math.floor(j/10)+j%10;\\n        }\\n    }\\n   \\n    return \"\";\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestTimeFromDigits = function(A) {\\n    \\n    const cmp = A.sort().join(\"\");\\n    for(let i=23; i>=0; i--){\\n        for(let j=59; j>=0; j--){\\n            if(cmp==[Math.floor(i/10),i%10,Math.floor(j/10),j%10].sort().join(\"\"))\\n                return \\'\\'+Math.floor(i/10)+i%10+\\':\\'+Math.floor(j/10)+j%10;\\n        }\\n    }\\n   \\n    return \"\";\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823276,
                "title": "java-simple-for-loops",
                "content": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        String ans = \"\";\\n        Arrays.sort(A);\\n        int max = -1;\\n        for(int i=0;i<4;i++)\\n        {\\n          for(int j=0;j<4;j++)\\n            {\\n                for(int k=0;k<4;k++)\\n                {\\n                 \\n                    for(int l=0;l<4;l++)\\n                    {\\n                        if(i!=j && i!=k &&i!=l && j!=k &&j!=l && k!=l)\\n                        {\\n                            String hr = A[i]+\"\"+A[j];\\n                            String min = A[k]+\"\"+A[l];\\n                            \\n                            if(Integer.parseInt(hr) < 24 && Integer.parseInt(min) < 60 && Integer.parseInt(hr+min+\"\") > max)\\n                            {\\n                                ans=hr+\":\"+min;\\n                                max = Integer.parseInt(hr+min);\\n                               \\n                            }\\n                                \\n                        }\\n                    }\\n                }\\n              \\n            }   \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        String ans = \"\";\\n        Arrays.sort(A);\\n        int max = -1;\\n        for(int i=0;i<4;i++)\\n        {\\n          for(int j=0;j<4;j++)\\n            {\\n                for(int k=0;k<4;k++)\\n                {\\n                 \\n                    for(int l=0;l<4;l++)\\n                    {\\n                        if(i!=j && i!=k &&i!=l && j!=k &&j!=l && k!=l)\\n                        {\\n                            String hr = A[i]+\"\"+A[j];\\n                            String min = A[k]+\"\"+A[l];\\n                            \\n                            if(Integer.parseInt(hr) < 24 && Integer.parseInt(min) < 60 && Integer.parseInt(hr+min+\"\") > max)\\n                            {\\n                                ans=hr+\":\"+min;\\n                                max = Integer.parseInt(hr+min);\\n                               \\n                            }\\n                                \\n                        }\\n                    }\\n                }\\n              \\n            }   \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823260,
                "title": "javascript-backtrack-with-comments",
                "content": "```\\n/*\\nhh:mm\\n^ 0,1,2 <-- \\n ^ 0-9, 2: 0-4\\n   ^ 0-5\\n    ^ 0-9 <- most flexible any digit can go here\\n    \\nif there\\'s a 2, put in first spot, dictates 0-4 in 2nd spot.  0-5 in 3rd spot.  if either 2nd or 3rd spot have nothing, 2 can\\'t go in 1st spot. then choose 1 in first spot and 0-5 in 3rd spot, biggest number in 2nd slot and\\nlooks like a backtracking pattern\\n\\nwith duplicates, use a bool visited array to recognize which element has been used\\n\\nA is only 4 elements, there are at most 4*3*2*1 permutations. brute force enumerate them all and check for largest one that fits conditions\\nwith an sb, we can .join and *1 to get a 4 digit number to compare to a max\\nwhen returning the string we can splice in \":\" and join\\n\\nO(1) time and space since permutations is always constant\\n*/\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n    let visited = new Array(4).fill(false)\\n    let max = -1\\n    let result = []\\n    backtrack([])\\n    return result.join(\\'\\')\\n    \\n    function backtrack(sb){\\n        if (sb.length === 4 && isValid(sb)){\\n            let time = sb.join(\\'\\')*1\\n            if (max < time){\\n                max = time\\n                result = sb.slice();\\n                result.splice(2,0,\":\")\\n            }\\n            return;\\n        }\\n        \\n        for (let i = 0; i < A.length; i++){\\n            if (visited[i]) continue\\n            visited[i] = true\\n            sb.push(A[i])\\n            backtrack(sb)\\n            visited[i] = false\\n            sb.pop()\\n        }\\n    }\\n    function isValid(sb){\\n        if (sb[0] === 2 && sb[1] < 4 && sb[2] <= 5) return true;\\n        if (sb[0] <= 1 && sb[2] <= 5) return true;\\n        return false\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nhh:mm\\n^ 0,1,2 <-- \\n ^ 0-9, 2: 0-4\\n   ^ 0-5\\n    ^ 0-9 <- most flexible any digit can go here\\n    \\nif there\\'s a 2, put in first spot, dictates 0-4 in 2nd spot.  0-5 in 3rd spot.  if either 2nd or 3rd spot have nothing, 2 can\\'t go in 1st spot. then choose 1 in first spot and 0-5 in 3rd spot, biggest number in 2nd slot and\\nlooks like a backtracking pattern\\n\\nwith duplicates, use a bool visited array to recognize which element has been used\\n\\nA is only 4 elements, there are at most 4*3*2*1 permutations. brute force enumerate them all and check for largest one that fits conditions\\nwith an sb, we can .join and *1 to get a 4 digit number to compare to a max\\nwhen returning the string we can splice in \":\" and join\\n\\nO(1) time and space since permutations is always constant\\n*/\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n    let visited = new Array(4).fill(false)\\n    let max = -1\\n    let result = []\\n    backtrack([])\\n    return result.join(\\'\\')\\n    \\n    function backtrack(sb){\\n        if (sb.length === 4 && isValid(sb)){\\n            let time = sb.join(\\'\\')*1\\n            if (max < time){\\n                max = time\\n                result = sb.slice();\\n                result.splice(2,0,\":\")\\n            }\\n            return;\\n        }\\n        \\n        for (let i = 0; i < A.length; i++){\\n            if (visited[i]) continue\\n            visited[i] = true\\n            sb.push(A[i])\\n            backtrack(sb)\\n            visited[i] = false\\n            sb.pop()\\n        }\\n    }\\n    function isValid(sb){\\n        if (sb[0] === 2 && sb[1] < 4 && sb[2] <= 5) return true;\\n        if (sb[0] <= 1 && sb[2] <= 5) return true;\\n        return false\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823242,
                "title": "c-find-permutations-and-only-check-and-compare",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string s)\\n    {\\n        if(s[0] == \\'2\\' && s[1] >= \\'4\\')\\n            return false;\\n        if(s[0] > \\'2\\')\\n            return false;\\n        \\n        if(s[2] >= \\'6\\')\\n            return false;\\n        \\n    return true;\\n    }\\n    bool cmp(string s1 , string s2)\\n    {\\n        for(int i = 0;i<4;i++)\\n        {\\n            if(s1[i] > s2[i])\\n                return true;\\n            else if(s1[i] == s2[i]){}\\n            else if(s1[i] < s2[i])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    string largestTimeFromDigits(vector<int>& A) {\\n       \\n        string temp = \"\";\\n        for(int i : A)\\n            temp += to_string(i);\\n        \\n        sort(temp.begin() , temp.end());\\n        \\n        int a = stoi(temp);\\n        if(a == 0)\\n            return \"00:00\";\\n        \\n        int count = 0;\\n     \\n        \\n        \\n        // take the cases of zero\\n       \\n        string res = \"\";\\n        string val = \"0000\";\\n        \\n        cout<<temp<<\" \";\\n        do{\\n            string x = temp;\\n            if(check(x) && cmp(x,val))\\n            {\\n                cout<<x<<\" \";\\n                res = x;\\n                val = x;\\n            }\\n        }while(next_permutation(temp.begin() , temp.end()));\\n        \\n        if(res.length() == 0)\\n            return \"\";\\n        string ans = res.substr(0,2) + \\':\\' + res.substr(2,2);\\n        \\n        return ans;\\n       \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool check(string s)\\n    {\\n        if(s[0] == \\'2\\' && s[1] >= \\'4\\')\\n            return false;\\n        if(s[0] > \\'2\\')\\n            return false;\\n        \\n        if(s[2] >= \\'6\\')\\n            return false;\\n        \\n    return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 823171,
                "title": "c-regex-pattern-matching-with-backtracking",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string res=\"\";\\n    void check(map<int,int>mp,string str,regex &pattern)\\n    {\\n        if(str.length()==2)\\n            str+=\":\";\\n        \\n        if(str.length()==5)\\n        {\\n            if(regex_match(str,pattern))\\n                res=max(res,str); //valid time\\n            \\n            return;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second!=0)\\n            {\\n                int val=it->first;\\n                mp[val]--;\\n                check(mp,str+to_string(val),pattern);\\n                mp[val]++;\\n            }\\n        }\\n    }\\n    string largestTimeFromDigits(vector<int>& A) {\\n        regex pattern(\"([0-1][0-9]:[0-5][0-9])|([2][0-3]:[0-5][0-9])\");\\n        map<int,int>mp;\\n        for(int i=0;i<A.size();i++)\\n            mp[A[i]]++;\\n\\t\\t\\t\\n        string str=\"\";\\n        check(mp,str,pattern);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string res=\"\";\\n    void check(map<int,int>mp,string str,regex &pattern)\\n    {\\n        if(str.length()==2)\\n            str+=\":\";\\n        \\n        if(str.length()==5)\\n        {\\n            if(regex_match(str,pattern))\\n                res=max(res,str); //valid time\\n            \\n            return;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second!=0)\\n            {\\n                int val=it->first;\\n                mp[val]--;\\n                check(mp,str+to_string(val),pattern);\\n                mp[val]++;\\n            }\\n        }\\n    }\\n    string largestTimeFromDigits(vector<int>& A) {\\n        regex pattern(\"([0-1][0-9]:[0-5][0-9])|([2][0-3]:[0-5][0-9])\");\\n        map<int,int>mp;\\n        for(int i=0;i<A.size();i++)\\n            mp[A[i]]++;\\n\\t\\t\\t\\n        string str=\"\";\\n        check(mp,str,pattern);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823166,
                "title": "java-easy-to-understand-solution-1ms-faster",
                "content": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        Map<Integer, Integer> timeMap = new HashMap<Integer, Integer>();\\n\\t\\tStringBuilder timeFormat = new StringBuilder();\\n\\t\\tboolean flag = false;\\n\\t\\tint len = A.length;\\n\\t\\tif (len > 4)\\n\\t\\t\\treturn \"\";\\n\\t\\tfor (int i : A)\\n\\t\\t\\ttimeMap.put(i, timeMap.getOrDefault(i, 0) + 1);\\n\\t\\tint s = 0, res = 0;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (A[i] > 5)\\n\\t\\t\\t\\tres++; // Count the Number of entries which are greater than 5.\\n\\t\\t}\\n\\t\\t// If I have more than 2 entries which are greater than 5 I cannot form a max\\n\\t\\t// time starting with 2 else I can start a max time with 2.\\n\\t\\t// Hence \\'s\\' is either 1 or 2.\\n\\t\\ts = (res >= 2) ? 1 : 2;\\n\\t\\tfor (int i = s; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the first digit of the Hour with \\'s\\'\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\"; // Reset the flag if the condition failed\\n\\t\\tflag = false;\\n\\t\\t// If the first digit of the hour starts with 2, then I\\'m allowed only till 3\\n\\t\\t// for my second digit. Hence starting with 3.\\n\\t\\tif (timeFormat.charAt(0) == \\'2\\') {\\n\\t\\t\\tfor (int i = 3; i >= 0; i--) {\\n\\t\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\ttimeFormat.append(i); // Append the second digit of the Hour\\n\\t\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else { // If the first digit of the hour starts with 1 or 0, then I\\'m allowed only till\\n\\t\\t\\t\\t\\t// 9 for my second digit. Hence starting with 9.\\n\\t\\t\\tfor (int i = 9; i >= 0; i--) {\\n\\t\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\ttimeFormat.append(i);\\n\\t\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\ttimeFormat.append(\":\"); // Append the colon to separate Hours and Minutes\\n\\t\\tflag = false;\\n\\t\\t// The max number allowed to start my first digit of the minute is 5. Hence,\\n\\t\\t// starting with 5.\\n\\t\\tfor (int i = 5; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the first digit of the Minutes\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\tflag = false;\\n\\t\\t// The max number allowed to start my second digit of the minute is 9.\\n\\t\\t// Hence, starting with 9.\\n\\t\\tfor (int i = 9; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the second digit of the Minutes\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\treturn timeFormat.toString(); // Final time\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        Map<Integer, Integer> timeMap = new HashMap<Integer, Integer>();\\n\\t\\tStringBuilder timeFormat = new StringBuilder();\\n\\t\\tboolean flag = false;\\n\\t\\tint len = A.length;\\n\\t\\tif (len > 4)\\n\\t\\t\\treturn \"\";\\n\\t\\tfor (int i : A)\\n\\t\\t\\ttimeMap.put(i, timeMap.getOrDefault(i, 0) + 1);\\n\\t\\tint s = 0, res = 0;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (A[i] > 5)\\n\\t\\t\\t\\tres++; // Count the Number of entries which are greater than 5.\\n\\t\\t}\\n\\t\\t// If I have more than 2 entries which are greater than 5 I cannot form a max\\n\\t\\t// time starting with 2 else I can start a max time with 2.\\n\\t\\t// Hence \\'s\\' is either 1 or 2.\\n\\t\\ts = (res >= 2) ? 1 : 2;\\n\\t\\tfor (int i = s; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the first digit of the Hour with \\'s\\'\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\"; // Reset the flag if the condition failed\\n\\t\\tflag = false;\\n\\t\\t// If the first digit of the hour starts with 2, then I\\'m allowed only till 3\\n\\t\\t// for my second digit. Hence starting with 3.\\n\\t\\tif (timeFormat.charAt(0) == \\'2\\') {\\n\\t\\t\\tfor (int i = 3; i >= 0; i--) {\\n\\t\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\ttimeFormat.append(i); // Append the second digit of the Hour\\n\\t\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else { // If the first digit of the hour starts with 1 or 0, then I\\'m allowed only till\\n\\t\\t\\t\\t\\t// 9 for my second digit. Hence starting with 9.\\n\\t\\t\\tfor (int i = 9; i >= 0; i--) {\\n\\t\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t\\ttimeFormat.append(i);\\n\\t\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\ttimeFormat.append(\":\"); // Append the colon to separate Hours and Minutes\\n\\t\\tflag = false;\\n\\t\\t// The max number allowed to start my first digit of the minute is 5. Hence,\\n\\t\\t// starting with 5.\\n\\t\\tfor (int i = 5; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the first digit of the Minutes\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\tflag = false;\\n\\t\\t// The max number allowed to start my second digit of the minute is 9.\\n\\t\\t// Hence, starting with 9.\\n\\t\\tfor (int i = 9; i >= 0; i--) {\\n\\t\\t\\tif (timeMap.containsKey(i) && timeMap.get(i) > 0) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\ttimeFormat.append(i); // Append the second digit of the Minutes\\n\\t\\t\\t\\ttimeMap.put(i, timeMap.get(i) - 1);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!flag)\\n\\t\\t\\treturn \"\";\\n\\t\\treturn timeFormat.toString(); // Final time\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823144,
                "title": "java-solution-using-treemap-faster-than-90-submissions",
                "content": "\\n``` \\npublic String largestTimeFromDigits(int[] arr) {\\n        String ans=\"\";\\n        TreeMap <Integer,Integer> treeMap=new TreeMap<>();\\n        for(int i:arr){\\n            treeMap.merge(i, 1, Integer::sum);\\n        }\\n\\n        int hourOneKey=2;\\n            Integer hourOne=treeMap.floorKey(hourOneKey);\\n        while(hourOne!=null && hourOne>=0){\\n            ans += hourOne;\\n            treeMap.compute(hourOne, (key, value) -> (value - 1));\\n            if (treeMap.get(hourOne) == 0) treeMap.remove(hourOne);\\n            Integer hourTwoKey = (hourOne == 2) ? 3 : 9;\\n            Integer hourTwo = treeMap.floorKey(hourTwoKey);\\n            if (hourTwo != null) {\\n                ans += hourTwo;\\n                treeMap.compute(hourTwo, (key, val) -> (val - 1));\\n                if (treeMap.get(hourTwo) == 0) treeMap.remove(hourTwo);\\n                ans += \\':\\';\\n                Integer minOne = treeMap.floorKey(5);\\n                if (minOne != null) {\\n                    ans += minOne;\\n                    treeMap.compute(minOne, (key, val) -> (val - 1));\\n                    if (treeMap.get(minOne) == 0) treeMap.remove(minOne);\\n                    ans += treeMap.firstKey();\\n                }\\n            }\\n            if (ans.length() == 5) return ans;\\n        ans=\"\";\\n        treeMap.clear();\\n            for(int i:arr){\\n                treeMap.merge(i, 1, Integer::sum);\\n            }\\n            hourOne=treeMap.floorKey(hourOne-1);\\n        }\\n\\n        return new String(\"\");\\n    }\\n",
                "solutionTags": [],
                "code": "\\n``` \\npublic String largestTimeFromDigits(int[] arr) {\\n        String ans=\"\";\\n        TreeMap <Integer,Integer> treeMap=new TreeMap<>();\\n        for(int i:arr){\\n            treeMap.merge(i, 1, Integer::sum);\\n        }\\n\\n        int hourOneKey=2;\\n            Integer hourOne=treeMap.floorKey(hourOneKey);\\n        while(hourOne!=null && hourOne>=0){\\n            ans += hourOne;\\n            treeMap.compute(hourOne, (key, value) -> (value - 1));\\n            if (treeMap.get(hourOne) == 0) treeMap.remove(hourOne);\\n            Integer hourTwoKey = (hourOne == 2) ? 3 : 9;\\n            Integer hourTwo = treeMap.floorKey(hourTwoKey);\\n            if (hourTwo != null) {\\n                ans += hourTwo;\\n                treeMap.compute(hourTwo, (key, val) -> (val - 1));\\n                if (treeMap.get(hourTwo) == 0) treeMap.remove(hourTwo);\\n                ans += \\':\\';\\n                Integer minOne = treeMap.floorKey(5);\\n                if (minOne != null) {\\n                    ans += minOne;\\n                    treeMap.compute(minOne, (key, val) -> (val - 1));\\n                    if (treeMap.get(minOne) == 0) treeMap.remove(minOne);\\n                    ans += treeMap.firstKey();\\n                }\\n            }\\n            if (ans.length() == 5) return ans;\\n        ans=\"\";\\n        treeMap.clear();\\n            for(int i:arr){\\n                treeMap.merge(i, 1, Integer::sum);\\n            }\\n            hourOne=treeMap.floorKey(hourOne-1);\\n        }\\n\\n        return new String(\"\");\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 823137,
                "title": "python3",
                "content": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        best_minutes = -1\\n        for i in permutations(A):\\n            hours = i[0] * 10 + i[1]\\n            if hours >= 24:\\n                continue\\n            minutes = i[2] * 10 + i[3]\\n            if minutes >= 60:\\n                continue\\n            total_minutes = hours * 60 + minutes\\n            if total_minutes > best_minutes:\\n                best_minutes = total_minutes\\n                best = i\\n        if best_minutes == -1:\\n            return \\'\\'\\n        best = [str(i) for i in best]\\n        return \\'\\'.join(best[:2]) + \\':\\' + \\'\\'.join(best[2:])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        best_minutes = -1\\n        for i in permutations(A):\\n            hours = i[0] * 10 + i[1]\\n            if hours >= 24:\\n                continue\\n            minutes = i[2] * 10 + i[3]\\n            if minutes >= 60:\\n                continue\\n            total_minutes = hours * 60 + minutes\\n            if total_minutes > best_minutes:\\n                best_minutes = total_minutes\\n                best = i\\n        if best_minutes == -1:\\n            return \\'\\'\\n        best = [str(i) for i in best]\\n        return \\'\\'.join(best[:2]) + \\':\\' + \\'\\'.join(best[2:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823120,
                "title": "python-calculate-all-possibility",
                "content": "Number of permutation = 4 ! = 24 so it it O(1)\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        def to_minute(arr):\\n            hour = 10 * arr[0] + arr[1]\\n            minute = 10 * arr[2] + arr[3]\\n            if hour < 24 and minute < 60: # valid time\\n                return hour * 60 + minute\\n            else:\\n                return -1\\n            \\n        def backtracking(i):\\n            if i == len(A): # finished one permutation\\n                self.res = max(self.res, to_minute(A))\\n            else:\\n                for j in range(i, len(A)):\\n                    A[i], A[j] = A[j], A[i]\\n                    backtracking(i + 1)\\n                    A[i], A[j] = A[j], A[i]\\n        \\n        def to_time(minute):\\n            if minute == -1: return \"\"\\n            hour_s = minute // 60\\n            min_s = minute % 60\\n            return \\'%02d:%02d\\' % (hour_s, min_s)\\n        \\n        self.res = -1\\n        backtracking(0)\\n        return to_time(self.res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        def to_minute(arr):\\n            hour = 10 * arr[0] + arr[1]\\n            minute = 10 * arr[2] + arr[3]\\n            if hour < 24 and minute < 60: # valid time\\n                return hour * 60 + minute\\n            else:\\n                return -1\\n            \\n        def backtracking(i):\\n            if i == len(A): # finished one permutation\\n                self.res = max(self.res, to_minute(A))\\n            else:\\n                for j in range(i, len(A)):\\n                    A[i], A[j] = A[j], A[i]\\n                    backtracking(i + 1)\\n                    A[i], A[j] = A[j], A[i]\\n        \\n        def to_time(minute):\\n            if minute == -1: return \"\"\\n            hour_s = minute // 60\\n            min_s = minute % 60\\n            return \\'%02d:%02d\\' % (hour_s, min_s)\\n        \\n        self.res = -1\\n        backtracking(0)\\n        return to_time(self.res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823100,
                "title": "simple-iterative-solution-with-video-explaination",
                "content": "https://www.youtube.com/watch?v=Y-uGoJqDtBM\\nIterative solution in constant time as the size of input array is fixed ie 4.\\n\\nTime Complexity is O(1)\\n\\n````\\nclass Solution {\\n    \\n                    // 0 1 2 3\\n                     //  max val (i +j + k) +l = 6\\n                    // l = 6 -i - j - k\\n    public String largestTimeFromDigits(int[] A) {\\n        int maxTime = -1;\\n        int maxHours = -1;\\n        int maxMin = -1;\\n        \\n        for(int i=0;i<A.length;i++){\\n            for(int j=0;j<A.length;j++){\\n                for(int k=0;k<A.length;k++){\\n                    if(i==j || j==k || k==i){\\n                        continue;\\n                    }\\n                    \\n                    int hoursTens = A[i];\\n                    int hoursUnits = A[j];\\n\\n                    int minsTens = A[k];\\n                    int minsUnit = A[6-i-j-k];\\n                    \\n                    \\n                    int hour = hoursTens*10 + hoursUnits;\\n                    \\n                    int min = minsTens * 10+ minsUnit;\\n                    \\n                    int totalTime  = hour*60 + min;\\n                    if(hour<24 && min< 60 && (totalTime)> maxTime){ //if we have a better time within hour and min constraint\\n                        maxTime = totalTime;\\n                        maxHours = hour;\\n                        maxMin = min;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(maxHours == -1 || maxMin == -1){\\n            return \"\";\\n        } else {\\n            // 9:45 => 09:45 , 7:8 = > 07:08\\n            return padding(maxHours) + \":\" + padding(maxMin); \\n        }\\n        \\n    }\\n    private String padding(int no){\\n        String str = \"\"+no;\\n        if(str.length()==1){\\n            str = \"0\" + str;\\n        }\\n        return str;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n                    // 0 1 2 3\\n                     //  max val (i +j + k) +l = 6\\n                    // l = 6 -i - j - k\\n    public String largestTimeFromDigits(int[] A) {\\n        int maxTime = -1;\\n        int maxHours = -1;\\n        int maxMin = -1;\\n        \\n        for(int i=0;i<A.length;i++){\\n            for(int j=0;j<A.length;j++){\\n                for(int k=0;k<A.length;k++){\\n                    if(i==j || j==k || k==i){\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 823055,
                "title": "largest-time-for-given-digits-using-greedy-stl-library",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans = \"\";\\n        sort(A.begin(),A.end());\\n        do{\\n            if((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5 && A[3]<=9){\\n                string temp = to_string(A[0]) + to_string(A[1]) + \\':\\' + to_string(A[2]) + to_string(A[3]);\\n                \\n                if(temp > ans)\\n                    ans = temp;\\n            }\\n            \\n        }\\n        while(next_permutation(A.begin(),A.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string ans = \"\";\\n        sort(A.begin(),A.end());\\n        do{\\n            if((A[0]==2 && A[1]<=3 || A[0]<2) && A[2]<=5 && A[3]<=9){\\n                string temp = to_string(A[0]) + to_string(A[1]) + \\':\\' + to_string(A[2]) + to_string(A[3]);\\n                \\n                if(temp > ans)\\n                    ans = temp;\\n            }\\n            \\n        }\\n        while(next_permutation(A.begin(),A.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822981,
                "title": "python-o-4-by-permutation-w-hint",
                "content": "![image](https://assets.leetcode.com/users/images/68fdc533-7cca-4b33-ac11-9413cb8a4fdc_1598950579.2524464.png)\\n\\n[image source](https://picclick.com/Car-Clock-12-Volt-Led-Digital-Dash-Panel-264092407158.html)\\n\\n---\\n\\n**Hint**:\\n\\na.\\nConsider input is 4 digits, and permutations cost is **O( 4! ) = 24**, which is **small enough**.\\n\\nTherefore we enumerate all permutation, validate its time range, and update maximum clock time.\\n\\n---\\n\\nb. \\nOuput format is **HH:MM**, remember to apply **zero padding on the front** if needed.\\n\\nFor example:\\n1:23 is wrong, which doesn\\'t match the output format.\\n**0**1:23 is correct.\\n\\n---\\n\\n```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        hour, minute = -1, -1\\n        \\n        for h1, h2, m1, m2 in permutations(A):\\n            \\n            cur_hour, cur_min = 10*h1 + h2, 10*m1 + m2\\n\\n            if cur_hour >= 24 or cur_min >= 60:\\n                \\n                # skip invaid clock time\\n                continue\\n                \\n                \\n            if cur_hour * 60 + cur_min > hour*60 + minute:\\n                # update and record maximum clock time\\n                hour, minute = cur_hour, cur_min\\n                    \\n                    \\n        if (hour, minute) == (-1, -1):\\n            return \"\"\\n        \\n        else:\\n            # convert to clock string with zero-padding on the front\\n            clock_string = [f\\'{hour:02}\\', f\\'{minute:02}\\']\\n            return \\':\\'.join( clock_string )\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about permutations](https://docs.python.org/3/library/itertools.html#itertools.permutations)\\n\\n[2] [Python official docs about f-string](https://www.python.org/dev/peps/pep-0498/#how-to-denote-f-strings)\\n\\n[3] [Wiki: 24-hour clock time](https://en.wikipedia.org/wiki/24-hour_clock)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Probability and Statistics"
                ],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        hour, minute = -1, -1\\n        \\n        for h1, h2, m1, m2 in permutations(A):\\n            \\n            cur_hour, cur_min = 10*h1 + h2, 10*m1 + m2\\n\\n            if cur_hour >= 24 or cur_min >= 60:\\n                \\n                # skip invaid clock time\\n                continue\\n                \\n                \\n            if cur_hour * 60 + cur_min > hour*60 + minute:\\n                # update and record maximum clock time\\n                hour, minute = cur_hour, cur_min\\n                    \\n                    \\n        if (hour, minute) == (-1, -1):\\n            return \"\"\\n        \\n        else:\\n            # convert to clock string with zero-padding on the front\\n            clock_string = [f\\'{hour:02}\\', f\\'{minute:02}\\']\\n            return \\':\\'.join( clock_string )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822934,
                "title": "cool-creative-python-solution",
                "content": "the idea is to try to create all permutations of times and return the max\\n\\n```\\nclass Solution:\\n    \\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        permutations = set(itertools.permutations(A))\\n        max_time = datetime.time(0, 0)\\n        flag = False\\n        my_time = \"\"\\n\\t\\t\\n        for permutation in permutations:\\n            hour = permutation[0] * 10 + permutation[1]\\n            minutes = permutation[2] * 10 + permutation[3]\\n            try:\\n                my_time = datetime.time(hour, minutes)\\n                \\n                if max_time <= my_time:\\n                    max_time = my_time\\n                    flag = True\\n                    \\n            except ValueError:\\n                pass\\n        \\n        return f\\'{max_time}\\'[:-3] if flag else \"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        permutations = set(itertools.permutations(A))\\n        max_time = datetime.time(0, 0)\\n        flag = False\\n        my_time = \"\"\\n\\t\\t\\n        for permutation in permutations:\\n            hour = permutation[0] * 10 + permutation[1]\\n            minutes = permutation[2] * 10 + permutation[3]\\n            try:\\n                my_time = datetime.time(hour, minutes)\\n                \\n                if max_time <= my_time:\\n                    max_time = my_time\\n                    flag = True\\n                    \\n            except ValueError:\\n                pass\\n        \\n        return f\\'{max_time}\\'[:-3] if flag else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751205,
                "title": "c",
                "content": "### [\\u53C2\\u8003](https://www.cnblogs.com/grandyang/p/13123589.html)\\n```C++\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        \\n        string result;\\n        \\n        sort(A.begin(), A.end());\\n        \\n        do{\\n            string hour = {char(A[0] + \\'0\\'), char(A[1] + \\'0\\')}, minute = {char(A[2] + \\'0\\'), char(A[3] + \\'0\\')};\\n            \\n            result = (hour <= \"23\" && minute <= \"59\") ? (hour + \":\" + minute) : result;\\n            \\n        } while (next_permutation(A.begin(), A.end()));\\n            \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        \\n        string result;\\n        \\n        sort(A.begin(), A.end());\\n        \\n        do{\\n            string hour = {char(A[0] + \\'0\\'), char(A[1] + \\'0\\')}, minute = {char(A[2] + \\'0\\'), char(A[3] + \\'0\\')};\\n            \\n            result = (hour <= \"23\" && minute <= \"59\") ? (hour + \":\" + minute) : result;\\n            \\n        } while (next_permutation(A.begin(), A.end()));\\n            \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732927,
                "title": "python3-straightforward-solution-with-explanation",
                "content": "class Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        # first get all possible permutations\\n        # then rule out those invalid numbers\\n        # return the max\\n        n = len(A)\\n        possible_times = []\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    for l in range(n):\\n                        if i != j and i != k and i != l and j != k and j != l and k != l:\\n                            possible_times.append(str(A[i])+str(A[j])+str(A[k])+str(A[l]))\\n        valid_times = []\\n        for i in range(len(possible_times)):\\n            if int(possible_times[i][0]) == 2:\\n                if int(possible_times[i][1]) <= 3:\\n                    if int(possible_times[i][2]) <= 5:\\n                        valid_times.append(int(possible_times[i]))\\n            elif int(possible_times[i][0]) <= 1:\\n                if int(possible_times[i][2]) <= 5:\\n                        valid_times.append(int(possible_times[i]))\\n        if len(valid_times) == 0:\\n            return(\"\")\\n        else:\\n            max_valid_time_str = str(max(valid_times))\\n            if len(max_valid_time_str) == 4:\\n                return(max_valid_time_str[0]+max_valid_time_str[1]+\\':\\'+max_valid_time_str[2]+max_valid_time_str[3])\\n            elif len(max_valid_time_str) == 3:\\n                return(\\'0\\'+max_valid_time_str[0]+\\':\\'+max_valid_time_str[1]+max_valid_time_str[2])\\n            elif len(max_valid_time_str) == 2:\\n                return(\\'0\\'+\\'0\\'+\\':\\'+max_valid_time_str[0]+max_valid_time_str[1])\\n            else:\\n                return(\\'0\\'+\\'0\\'+\\':\\'+\\'0\\'+max_valid_time_str[0])",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        \\n        # first get all possible permutations\\n        # then rule out those invalid numbers\\n        # return the max\\n        n = len(A)\\n        possible_times = []\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    for l in range(n):\\n                        if i != j and i != k and i != l and j != k and j != l and k != l:\\n                            possible_times.append(str(A[i])+str(A[j])+str(A[k])+str(A[l]))\\n        valid_times = []\\n        for i in range(len(possible_times)):\\n            if int(possible_times[i][0]) == 2:\\n                if int(possible_times[i][1]) <= 3:\\n                    if int(possible_times[i][2]) <= 5:\\n                        valid_times.append(int(possible_times[i]))\\n            elif int(possible_times[i][0]) <= 1:\\n                if int(possible_times[i][2]) <= 5:\\n                        valid_times.append(int(possible_times[i]))\\n        if len(valid_times) == 0:\\n            return(\"\")\\n        else:\\n            max_valid_time_str = str(max(valid_times))\\n            if len(max_valid_time_str) == 4:\\n                return(max_valid_time_str[0]+max_valid_time_str[1]+\\':\\'+max_valid_time_str[2]+max_valid_time_str[3])\\n            elif len(max_valid_time_str) == 3:\\n                return(\\'0\\'+max_valid_time_str[0]+\\':\\'+max_valid_time_str[1]+max_valid_time_str[2])\\n            elif len(max_valid_time_str) == 2:\\n                return(\\'0\\'+\\'0\\'+\\':\\'+max_valid_time_str[0]+max_valid_time_str[1])\\n            else:\\n                return(\\'0\\'+\\'0\\'+\\':\\'+\\'0\\'+max_valid_time_str[0])",
                "codeTag": "Java"
            },
            {
                "id": 677961,
                "title": "rust-nested-iterators-for-the-lulz",
                "content": "```\\n    pub fn largest_time_from_digits(a: Vec<i32>) -> String {\\n        \\n        let iter = (0_usize..4_usize).into_iter();\\n        let max = iter.clone()\\n            .filter(|&i| a[i] < 3)\\n            .map(|i| iter.clone()\\n                        .filter(|&j| j != i && (a[i] != 2 || a[j] < 4) )\\n                        .map(|j| iter.clone()\\n                                     .filter(|&k| k != j && k != i && a[k] < 6)\\n                                     .map(|k| iter.clone()\\n                                                 .filter(|&l| l != k && l != j && l != i)\\n                                                 .map(|l| a[i] *600 + a[j]*60 + a[k] * 10 + a[l])\\n                                                 .max()\\n                                                 \\n                                                 \\n                                        ).max()\\n                                        \\n                        ).max()\\n                        \\n                )\\n            .max();\\n        match max {\\n            Some(Some(Some(Some(x)))) => format!(\"{:0>2}:{:0>2}\", x /60, x%60),\\n        _ => \"\".to_string()\\n        }       \\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n    pub fn largest_time_from_digits(a: Vec<i32>) -> String {\\n        \\n        let iter = (0_usize..4_usize).into_iter();\\n        let max = iter.clone()\\n            .filter(|&i| a[i] < 3)\\n            .map(|i| iter.clone()\\n                        .filter(|&j| j != i && (a[i] != 2 || a[j] < 4) )\\n                        .map(|j| iter.clone()\\n                                     .filter(|&k| k != j && k != i && a[k] < 6)\\n                                     .map(|k| iter.clone()\\n                                                 .filter(|&l| l != k && l != j && l != i)\\n                                                 .map(|l| a[i] *600 + a[j]*60 + a[k] * 10 + a[l])\\n                                                 .max()\\n                                                 \\n                                                 \\n                                        ).max()\\n                                        \\n                        ).max()\\n                        \\n                )\\n            .max();\\n        match max {\\n            Some(Some(Some(Some(x)))) => format!(\"{:0>2}:{:0>2}\", x /60, x%60),\\n        _ => \"\".to_string()\\n        }       \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 671731,
                "title": "concise-and-simple-js-solution",
                "content": "```\\nvar largestTimeFromDigits = function(A) {\\n    const convert = (h, m) => (parseInt(h) * 60) + parseInt(m)\\n    \\n    const isValid = (h, m) => parseInt(h) <= 23 && parseInt(m) <= 59\\n    \\n    let permutations = []\\n    \\n    let max = 0\\n     \\n    const check = (permutation) => {\\n        let h = permutation[0]+\\'\\'+permutation[1]\\n        let m = permutation[2]+\\'\\'+permutation[3]\\n        \\n        if (isValid(h, m)) {\\n            if (!max || convert(max[0], max[1]) < convert(h, m)) max = [h, m]\\n        }\\n    }\\n    \\n    const permute = (array, index) => {\\n        if (index == array.length) check([...array])\\n        for (let i = index; i < array.length; i++) {\\n            [array[index], array[i]] = [array[i], array[index]]\\n            permute(array, index+1);\\n            [array[index], array[i]] = [array[i], array[index]]\\n        }\\n    }\\n    \\n    permute(A, 0)\\n   \\n    return max ? max[0]+\\':\\'+max[1] : \\'\\'\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar largestTimeFromDigits = function(A) {\\n    const convert = (h, m) => (parseInt(h) * 60) + parseInt(m)\\n    \\n    const isValid = (h, m) => parseInt(h) <= 23 && parseInt(m) <= 59\\n    \\n    let permutations = []\\n    \\n    let max = 0\\n     \\n    const check = (permutation) => {\\n        let h = permutation[0]+\\'\\'+permutation[1]\\n        let m = permutation[2]+\\'\\'+permutation[3]\\n        \\n        if (isValid(h, m)) {\\n            if (!max || convert(max[0], max[1]) < convert(h, m)) max = [h, m]\\n        }\\n    }\\n    \\n    const permute = (array, index) => {\\n        if (index == array.length) check([...array])\\n        for (let i = index; i < array.length; i++) {\\n            [array[index], array[i]] = [array[i], array[index]]\\n            permute(array, index+1);\\n            [array[index], array[i]] = [array[i], array[index]]\\n        }\\n    }\\n    \\n    permute(A, 0)\\n   \\n    return max ? max[0]+\\':\\'+max[1] : \\'\\'\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 568343,
                "title": "java-solution-beats-97-5-time-100-space",
                "content": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] nums) {\\n        String res = \"\";\\n        for (int a = 0; a < 4; a++) {\\n            if (nums[a] > 2) continue;\\n            for (int b = 0; b < 4; b++) {\\n                if (b == a || (nums[a] == 2 && nums[b] > 3)) continue;\\n                for (int c = 0; c < 4; c++) {\\n                    if (c == a || c == b || nums[c] > 5) continue;\\n                    int d = 6 - a - b - c;\\n                    StringBuilder sb = new StringBuilder();\\n                    sb.append(nums[a]).append(nums[b]).append(\":\").append(nums[c]).append(nums[d]);\\n\\n                    String tmp = sb.toString();\\n                    if (res.compareTo(tmp) < 0) res = tmp;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] nums) {\\n        String res = \"\";\\n        for (int a = 0; a < 4; a++) {\\n            if (nums[a] > 2) continue;\\n            for (int b = 0; b < 4; b++) {\\n                if (b == a || (nums[a] == 2 && nums[b] > 3)) continue;\\n                for (int c = 0; c < 4; c++) {\\n                    if (c == a || c == b || nums[c] > 5) continue;\\n                    int d = 6 - a - b - c;\\n                    StringBuilder sb = new StringBuilder();\\n                    sb.append(nums[a]).append(nums[b]).append(\":\").append(nums[c]).append(nums[d]);\\n\\n                    String tmp = sb.toString();\\n                    if (res.compareTo(tmp) < 0) res = tmp;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545697,
                "title": "c-permutation-and-validation",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string res = \"\";\\n        vector<string> vec;\\n        vector<bool> visited(4, false);\\n        permutation(A, vec, visited, \"\");\\n        sort(vec.rbegin(), vec.rend());\\n        for(auto a : vec) {\\n            if(isvalid(a)) {\\n                res = a;\\n                break;\\n            }\\n        }\\n        // string :: insert(iterator, char)\\n        if(res != \"\") res.insert(res.begin() + 2, \\':\\');\\n        return res;\\n    }\\n    void permutation(vector<int>& A, vector<string>& res, vector<bool>& visited, string path) {\\n        if(path.size() == A.size()) {\\n            res.push_back(path);\\n            return;\\n        }\\n        for(int i = 0; i < A.size(); i++) {\\n            if(!visited[i]) {\\n                visited[i] = true;\\n                permutation(A, res, visited, path + to_string(A[i]));\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n    bool isvalid(string s) {\\n        if(s[0] > \\'2\\') return false;\\n        if(s[0] == \\'2\\' && s[1] >= \\'4\\') return false;\\n        if(s[2] > \\'5\\') return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        string res = \"\";\\n        vector<string> vec;\\n        vector<bool> visited(4, false);\\n        permutation(A, vec, visited, \"\");\\n        sort(vec.rbegin(), vec.rend());\\n        for(auto a : vec) {\\n            if(isvalid(a)) {\\n                res = a;\\n                break;\\n            }\\n        }\\n        // string :: insert(iterator, char)\\n        if(res != \"\") res.insert(res.begin() + 2, \\':\\');\\n        return res;\\n    }\\n    void permutation(vector<int>& A, vector<string>& res, vector<bool>& visited, string path) {\\n        if(path.size() == A.size()) {\\n            res.push_back(path);\\n            return;\\n        }\\n        for(int i = 0; i < A.size(); i++) {\\n            if(!visited[i]) {\\n                visited[i] = true;\\n                permutation(A, res, visited, path + to_string(A[i]));\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n    bool isvalid(string s) {\\n        if(s[0] > \\'2\\') return false;\\n        if(s[0] == \\'2\\' && s[1] >= \\'4\\') return false;\\n        if(s[2] > \\'5\\') return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523682,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int ans = -1;        \\n        for(int i = 0; i < 4; i++) {     \\n            for(int j = 0; j < 4; j++) {\\n                    for(int k = 0; k < 4; k++) {\\n                        for(int l = 0; l < 4; l++) {\\n                            if( i != j && j != k && k != l && i != k && i != l && j != l ) {\\n                                   int hours = 10 * A[i] + A[j];\\n                                   int mins = 10 * A[k] + A[l];\\n                                   if (hours < 24 && mins < 60)\\n                                    ans = Math.max(ans, hours * 60 + mins);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n    \\n\\n        return ans >= 0 ? String.format(\"%02d:%02d\", ans / 60, ans % 60) : \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int ans = -1;        \\n        for(int i = 0; i < 4; i++) {     \\n            for(int j = 0; j < 4; j++) {\\n                    for(int k = 0; k < 4; k++) {\\n                        for(int l = 0; l < 4; l++) {\\n                            if( i != j && j != k && k != l && i != k && i != l && j != l ) {\\n                                   int hours = 10 * A[i] + A[j];\\n                                   int mins = 10 * A[k] + A[l];\\n                                   if (hours < 24 && mins < 60)\\n                                    ans = Math.max(ans, hours * 60 + mins);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n    \\n\\n        return ans >= 0 ? String.format(\"%02d:%02d\", ans / 60, ans % 60) : \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495040,
                "title": "java-code-arrayutils-help",
                "content": "Below java code uses ArrayUtils class for removing elements ,** is there any other way to calculate minutes after we get hours in this code ?**\\n\\n```\\n    public String largestTimeFromDigits(int[] A) {\\n        String ret = \"\";\\n\\t\\tString hrPrev = \"\";\\n\\t\\tString min = \"\";\\n\\t\\t// store positions of hours\\n\\t\\tint[] hrInt = new int[2];\\n\\t\\tint[] positions = { 0, 1, 2, 3 };\\n\\n\\t\\t// Calculate the hours first\\n\\t\\tfor (int i = 0; i < 4; ++i) {\\n\\t\\t\\tfor (int j = 0; j < 4; ++j) {\\n\\t\\t\\t\\tif (i == j)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tString hr = \"\" + A[i] + A[j];\\n\\t\\t\\t\\tif (hr.compareTo(\"24\") < 0 && hrPrev.compareTo(hr) < 0) {\\n\\t\\t\\t\\t\\thrPrev = hr;\\n\\t\\t\\t\\t\\thrInt[0] = i;\\n\\t\\t\\t\\t\\thrInt[1] = j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// remove hours positions from positions array\\n\\t\\tpositions = org.apache.commons.lang.ArrayUtils.removeElement(positions, hrInt[0]);\\n\\t\\tpositions = org.apache.commons.lang.ArrayUtils.removeElement(positions, hrInt[1]);\\n\\n\\t\\t// calculate the minutes now\\n\\n\\t\\tint minutes1 = A[positions[0]] * 10 + A[positions[1]];\\n\\t\\tint minutes2 = A[positions[1]] * 10 + A[positions[0]];\\n\\n\\t\\tint minutes = (minutes1 > minutes2) ? minutes1 : minutes2;\\n\\n\\t\\tif (minutes < 60) {\\n\\t\\t\\tmin = \"\" + minutes;\\n\\t\\t}\\n\\n\\t\\tif (hrPrev == \"\" || min == \"\") {\\n\\t\\t\\treturn ret;\\n\\t\\t} else {\\n\\t\\t\\tret = hrPrev + \":\" + min;\\n\\t\\t}\\n\\n\\t\\treturn ret;\\n    }\\n",
                "solutionTags": [],
                "code": "Below java code uses ArrayUtils class for removing elements ,** is there any other way to calculate minutes after we get hours in this code ?**\\n\\n```\\n    public String largestTimeFromDigits(int[] A) {\\n        String ret = \"\";\\n\\t\\tString hrPrev = \"\";\\n\\t\\tString min = \"\";\\n\\t\\t// store positions of hours\\n\\t\\tint[] hrInt = new int[2];\\n\\t\\tint[] positions = { 0, 1, 2, 3 };\\n\\n\\t\\t// Calculate the hours first\\n\\t\\tfor (int i = 0; i < 4; ++i) {\\n\\t\\t\\tfor (int j = 0; j < 4; ++j) {\\n\\t\\t\\t\\tif (i == j)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tString hr = \"\" + A[i] + A[j];\\n\\t\\t\\t\\tif (hr.compareTo(\"24\") < 0 && hrPrev.compareTo(hr) < 0) {\\n\\t\\t\\t\\t\\thrPrev = hr;\\n\\t\\t\\t\\t\\thrInt[0] = i;\\n\\t\\t\\t\\t\\thrInt[1] = j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// remove hours positions from positions array\\n\\t\\tpositions = org.apache.commons.lang.ArrayUtils.removeElement(positions, hrInt[0]);\\n\\t\\tpositions = org.apache.commons.lang.ArrayUtils.removeElement(positions, hrInt[1]);\\n\\n\\t\\t// calculate the minutes now\\n\\n\\t\\tint minutes1 = A[positions[0]] * 10 + A[positions[1]];\\n\\t\\tint minutes2 = A[positions[1]] * 10 + A[positions[0]];\\n\\n\\t\\tint minutes = (minutes1 > minutes2) ? minutes1 : minutes2;\\n\\n\\t\\tif (minutes < 60) {\\n\\t\\t\\tmin = \"\" + minutes;\\n\\t\\t}\\n\\n\\t\\tif (hrPrev == \"\" || min == \"\") {\\n\\t\\t\\treturn ret;\\n\\t\\t} else {\\n\\t\\t\\tret = hrPrev + \":\" + min;\\n\\t\\t}\\n\\n\\t\\treturn ret;\\n    }\\n",
                "codeTag": "Java"
            },
            {
                "id": 454440,
                "title": "949-largest-time-for-given-digits-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Brute Force - Permutation**\\n| O(T): O(nn) | O(S): O(nn) | Rt: 28ms | \\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        possible = itertools.permutations(A, 4)\\n        isvalid = lambda x: x[0]*10 + x[1] < 24 and x[2]*10 + x[3] < 60\\n        validTime = [i for i in possible if isvalid(i)]\\n        if not validTime: return \\'\\'\\n        rst = max(validTime, key = lambda x: (x[0]*10 + x[1], x[2]*10 + x[3]))\\n        return f\"{rst[0]}{rst[1]}:{rst[2]}{rst[3]}\"\\n```\\nAlternative: one-liner.  | Rt: 28ms |\\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        return max([f\"{i[0]}{i[1]}:{i[2]}{i[3]}\" for i in itertools.permutations(A, 4) if i[:2] < (2, 4) and i[2] < 6] or [\\'\\'])\\n```\\nReferrence: https://leetcode.com/problems/largest-time-for-given-digits/discuss/200517/Python-1-line-Check-Permutations-O(24)\\n\\n\\n**II). Sort and Permutation**\\n| O(T): O(n^2lgn) | O(S): O(nn) | Rt: 20ms | \\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        for i in itertools.permutations(sorted(A, reverse=True), 4):\\n            if i[0]*10 + i[1] < 24 and i[2]*10 + i[3] < 60: \\n                return f\"{i[0]}{i[1]}:{i[2]}{i[3]}\"\\n        return \\'\\'\\n```\\nAlternative: lengthy one-liner.  | Rt: 28ms |\\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        return next((f\"{i[0]}{i[1]}:{i[2]}{i[3]}\" for i in itertools.permutations(sorted(A, reverse=True), 4) if i[0]*10 + i[1] < 24 and i[2]*10 + i[3] < 60), \\'\\') \\n```\\nComment: pay attention to the default value of next. \\n\\n\\n**III). Brute Force**\\n| O(T): O(n^3) | O(S): O(1) | Rt: 28ms | \\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        rst = \\'\\'\\n        for i in range(4):\\n            for j in range(4):\\n                for k in range(4):\\n                    if (i == j or i == k or j == k): continue\\n                    #0, 1, 2, 3, all add up, get 6    \\n                    l = 6 - i -j - k\\n                    cur = f\"{A[i]}{A[j]}:{A[k]}{A[l]}\"\\n                    if cur[:2] > \\'23\\' or cur[3] > \\'5\\': continue\\n                    rst = max(rst, cur)\\n        return rst\\n```\\nReferrence: https://leetcode.com/problems/largest-time-for-given-digits/discuss/200693/Java-11-liner-O(64)-w-comment-6-ms.\\n",
                "solutionTags": [],
                "code": "```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        possible = itertools.permutations(A, 4)\\n        isvalid = lambda x: x[0]*10 + x[1] < 24 and x[2]*10 + x[3] < 60\\n        validTime = [i for i in possible if isvalid(i)]\\n        if not validTime: return \\'\\'\\n        rst = max(validTime, key = lambda x: (x[0]*10 + x[1], x[2]*10 + x[3]))\\n        return f\"{rst[0]}{rst[1]}:{rst[2]}{rst[3]}\"\\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        return max([f\"{i[0]}{i[1]}:{i[2]}{i[3]}\" for i in itertools.permutations(A, 4) if i[:2] < (2, 4) and i[2] < 6] or [\\'\\'])\\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        for i in itertools.permutations(sorted(A, reverse=True), 4):\\n            if i[0]*10 + i[1] < 24 and i[2]*10 + i[3] < 60: \\n                return f\"{i[0]}{i[1]}:{i[2]}{i[3]}\"\\n        return \\'\\'\\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        return next((f\"{i[0]}{i[1]}:{i[2]}{i[3]}\" for i in itertools.permutations(sorted(A, reverse=True), 4) if i[0]*10 + i[1] < 24 and i[2]*10 + i[3] < 60), \\'\\') \\n```\n```python\\n    def largestTimeFromDigits(self, A: List[int]) -> str:\\n        rst = \\'\\'\\n        for i in range(4):\\n            for j in range(4):\\n                for k in range(4):\\n                    if (i == j or i == k or j == k): continue\\n                    #0, 1, 2, 3, all add up, get 6    \\n                    l = 6 - i -j - k\\n                    cur = f\"{A[i]}{A[j]}:{A[k]}{A[l]}\"\\n                    if cur[:2] > \\'23\\' or cur[3] > \\'5\\': continue\\n                    rst = max(rst, cur)\\n        return rst\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 364813,
                "title": "java-dfs-1ms",
                "content": "\\tint res = -1;\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        boolean[] visited = new boolean[A.length];\\n        dfs(A, visited, 0);\\n        int tmp = res;\\n        StringBuilder sb = new StringBuilder();\\n        while(tmp > 0) {\\n        \\tif(sb.length() == 2)\\n        \\t\\tsb.insert(0, \\':\\');\\n        \\tsb.insert(0, tmp%10);\\n        \\ttmp/=10;\\n        }\\n        while(sb.length() < 5) {\\n        \\tif(sb.length() == 2)\\n        \\t\\tsb.insert(0, \\':\\');\\n        \\tsb.insert(0, \\'0\\');\\n        }\\n        return res >= 0 ? sb.toString() : \"\";\\n    }\\n    \\n    void dfs(int[] A, boolean[] visited, int tmp){\\n        if(isAllVisited(visited) && (tmp >= 2400 || tmp%100 >= 60)) \\n            return;\\n        if(isAllVisited(visited))\\n        \\tres = Math.max(tmp, res);\\n        for(int i=0;i<A.length;i++){\\n            if(!visited[i]){\\n                visited[i] = true;\\n                dfs(A, visited, tmp*10 + A[i]);\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n    \\n    boolean isAllVisited(boolean[] visited){\\n        for(boolean v : visited)\\n            if(!v)\\n                return false;\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "\\tint res = -1;\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        boolean[] visited = new boolean[A.length];\\n        dfs(A, visited, 0);\\n        int tmp = res;\\n        StringBuilder sb = new StringBuilder();\\n        while(tmp > 0) {\\n        \\tif(sb.length() == 2)\\n        \\t\\tsb.insert(0, \\':\\');\\n        \\tsb.insert(0, tmp%10);\\n        \\ttmp/=10;\\n        }\\n        while(sb.length() < 5) {\\n        \\tif(sb.length() == 2)\\n        \\t\\tsb.insert(0, \\':\\');\\n        \\tsb.insert(0, \\'0\\');\\n        }\\n        return res >= 0 ? sb.toString() : \"\";\\n    }\\n    \\n    void dfs(int[] A, boolean[] visited, int tmp){\\n        if(isAllVisited(visited) && (tmp >= 2400 || tmp%100 >= 60)) \\n            return;\\n        if(isAllVisited(visited))\\n        \\tres = Math.max(tmp, res);\\n        for(int i=0;i<A.length;i++){\\n            if(!visited[i]){\\n                visited[i] = true;\\n                dfs(A, visited, tmp*10 + A[i]);\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n    \\n    boolean isAllVisited(boolean[] visited){\\n        for(boolean v : visited)\\n            if(!v)\\n                return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 356682,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nStarting from highest possible timestamp `23:59`, we will go round the clock decrementing the time and stopping when we are able to find all the digits from the current timestamp. \\n\\nEasy way to check that is extract digits and sort them (`curr` in the code) and sort and compare with sorted input `a`. \\n\\n```\\npublic String largestTimeFromDigits(int[] a) {\\n        Arrays.sort(a);\\n        for(int h=23; h >= 0; h--){\\n            for(int m=59; m >= 0; m--){\\n                String s = helper(a, h, m);\\n                if(s != null)\\n                    return s;\\n            }\\n        }\\n        return \"\";\\n    }\\n    private String helper(int[] a, int h, int m){\\n        StringBuilder sb = new StringBuilder();\\n        int[] curr = new int[4];\\n        int d = m % 10;\\n        sb.append(d);\\n        curr[3] = d;\\n        m /= 10;\\n        sb.append(m);\\n        curr[2] = m;\\n        sb.append(\":\");\\n        d = h % 10;\\n        sb.append(d);\\n        curr[1] = d;\\n        h /= 10;\\n        sb.append(h);\\n        curr[0] = h;\\n        Arrays.sort(curr);\\n        for(int i=0; i < a.length; i++)\\n            if(a[i] != curr[i])\\n                return null;\\n        return sb.reverse().toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String largestTimeFromDigits(int[] a) {\\n        Arrays.sort(a);\\n        for(int h=23; h >= 0; h--){\\n            for(int m=59; m >= 0; m--){\\n                String s = helper(a, h, m);\\n                if(s != null)\\n                    return s;\\n            }\\n        }\\n        return \"\";\\n    }\\n    private String helper(int[] a, int h, int m){\\n        StringBuilder sb = new StringBuilder();\\n        int[] curr = new int[4];\\n        int d = m % 10;\\n        sb.append(d);\\n        curr[3] = d;\\n        m /= 10;\\n        sb.append(m);\\n        curr[2] = m;\\n        sb.append(\":\");\\n        d = h % 10;\\n        sb.append(d);\\n        curr[1] = d;\\n        h /= 10;\\n        sb.append(h);\\n        curr[0] = h;\\n        Arrays.sort(curr);\\n        for(int i=0; i < a.length; i++)\\n            if(a[i] != curr[i])\\n                return null;\\n        return sb.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 336615,
                "title": "easy-to-understand-javascript-solution-with-comments-52ms-94-100",
                "content": "Going down from 23 hours to 0 hours. If hours are found - check if minutes are valid.\\n\\n```\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n    let result = \\'\\';\\n    \\n    for (let hours = 23; hours >= 0; hours--) {\\n        const h = Math.floor(hours / 10);\\n        const l = hours % 10;\\n        const hI = A.indexOf(h);\\n        \\n        // check if both hour\\'s digits are in A\\n        if (hI >= 0 && A.indexOf(l, h === l ? hI + 1 : 0) >= 0) {\\n            const arr = [...A]; //copy array\\n            \\n            // remove hour\\'s digits\\n            arr.splice(hI, 1);\\n            arr.splice(arr.indexOf(l), 1);\\n            \\n            // 2 candidates for minues\\n            const mins1 = arr[0] * 10 + arr[1];\\n            const mins2 = arr[1] * 10 + arr[0];\\n            \\n            // check if candidates are valid\\n            const candidates = [];\\n            if (mins1 >= 0 && mins1 <= 59) {\\n                candidates.push(mins1);\\n            }\\n            if (mins2 >=0 && mins2 <= 59) {\\n                candidates.push(mins2);\\n            }\\n            \\n            // no valid candidates, continue loop\\n            if (candidates.length === 0) {\\n                continue;\\n            }\\n            \\n            candidates.sort();\\n            // take the biggest valid candidate\\n            const mins = candidates[candidates.length - 1];\\n            \\n            const hStr = hours < 10 ? `0${hours}` : `${hours}`;\\n            const mStr = mins < 10 ? `0${mins}` : `${mins}`;\\n            return `${hStr}:${mStr}`;\\n        }\\n    }\\n    \\n    return \\'\\';\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(A) {\\n    let result = \\'\\';\\n    \\n    for (let hours = 23; hours >= 0; hours--) {\\n        const h = Math.floor(hours / 10);\\n        const l = hours % 10;\\n        const hI = A.indexOf(h);\\n        \\n        // check if both hour\\'s digits are in A\\n        if (hI >= 0 && A.indexOf(l, h === l ? hI + 1 : 0) >= 0) {\\n            const arr = [...A]; //copy array\\n            \\n            // remove hour\\'s digits\\n            arr.splice(hI, 1);\\n            arr.splice(arr.indexOf(l), 1);\\n            \\n            // 2 candidates for minues\\n            const mins1 = arr[0] * 10 + arr[1];\\n            const mins2 = arr[1] * 10 + arr[0];\\n            \\n            // check if candidates are valid\\n            const candidates = [];\\n            if (mins1 >= 0 && mins1 <= 59) {\\n                candidates.push(mins1);\\n            }\\n            if (mins2 >=0 && mins2 <= 59) {\\n                candidates.push(mins2);\\n            }\\n            \\n            // no valid candidates, continue loop\\n            if (candidates.length === 0) {\\n                continue;\\n            }\\n            \\n            candidates.sort();\\n            // take the biggest valid candidate\\n            const mins = candidates[candidates.length - 1];\\n            \\n            const hStr = hours < 10 ? `0${hours}` : `${hours}`;\\n            const mStr = mins < 10 ? `0${mins}` : `${mins}`;\\n            return `${hStr}:${mStr}`;\\n        }\\n    }\\n    \\n    return \\'\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 318695,
                "title": "go-with-no-permutations-in-20lines",
                "content": "```\\nfunc largestTimeFromDigits(A []int) string {\\n\\tsort.Ints(A)\\n\\tfor i := 3; i >= 0; i-- {\\n\\t\\tfor j := 3; j >= 0; j-- {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tfor k := 3; k >= 0; k-- {\\n\\t\\t\\t\\tif k == i || k == j {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\th, m := 10*A[i]+A[j], 10*A[k]+A[6-i-j-k]\\n\\t\\t\\t\\tif h < 24 && m < 60 {\\n\\t\\t\\t\\t\\treturn fmt.Sprintf(\"%02d:%02d\", h, m)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn \"\"\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc largestTimeFromDigits(A []int) string {\\n\\tsort.Ints(A)\\n\\tfor i := 3; i >= 0; i-- {\\n\\t\\tfor j := 3; j >= 0; j-- {\\n\\t\\t\\tif i == j {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tfor k := 3; k >= 0; k-- {\\n\\t\\t\\t\\tif k == i || k == j {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\th, m := 10*A[i]+A[j], 10*A[k]+A[6-i-j-k]\\n\\t\\t\\t\\tif h < 24 && m < 60 {\\n\\t\\t\\t\\t\\treturn fmt.Sprintf(\"%02d:%02d\", h, m)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn \"\"\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 273984,
                "title": "c-17-lines-code-i-think-no-one-write-c-shorter-then-me",
                "content": "```\\nclass Solution {\\nprivate:\\n    inline bool valid(int hour, int minute) {\\n        return (hour < 24 && hour >= 0 && minute < 60 && minute >= 0);\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        char ans[6] = \"\", buffer[6];\\n        sort(A.begin(), A.end());\\n        do {\\n            sprintf(buffer, \"%d%d:%d%d\", A[0], A[1], A[2], A[3]);\\n            if (valid(A[0]*10+A[1], A[2]*10+A[3]) && strcmp(ans, buffer) < 0)  // actually, it\\'s needn\\'t to compare ans with buffer\\n                strcpy(ans, buffer);\\n        } while (next_permutation(A.begin(), A.end()));\\n        return string(ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    inline bool valid(int hour, int minute) {\\n        return (hour < 24 && hour >= 0 && minute < 60 && minute >= 0);\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        char ans[6] = \"\", buffer[6];\\n        sort(A.begin(), A.end());\\n        do {\\n            sprintf(buffer, \"%d%d:%d%d\", A[0], A[1], A[2], A[3]);\\n            if (valid(A[0]*10+A[1], A[2]*10+A[3]) && strcmp(ans, buffer) < 0)  // actually, it\\'s needn\\'t to compare ans with buffer\\n                strcpy(ans, buffer);\\n        } while (next_permutation(A.begin(), A.end()));\\n        return string(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246742,
                "title": "java-5ms-beats-100-sort-brute-force-stopping-on-1st-valid-time",
                "content": "Sort the array, use the brute force solution but start from largest to smallest number, so the first valid time found is the largest possible time\\n\\n```\\nclass Solution {\\n\\n    public String largestTimeFromDigits(int[] A) {       \\n        Arrays.sort(A);       \\n               \\n        String r = \"\";\\n        \\n        for(int i=3;i>=0;i--) {\\n            for(int j=3;j>=0;j--) {\\n                if(j==i) continue;\\n                for(int k=3;k>=0;k--){\\n                    if(k==j || k==i)  continue;\\n                    for(int s=3;s>=0;s--){\\n                        if(s==k||s==j||s==i) continue;\\n                        String t = time(A[i],A[j],A[k],A[s]);\\n                        if(!t.equals(\"\")) {\\n                            return t;\\n                        }                        \\n                    }\\n                }\\n            }\\n        }\\n\\n        return r;       \\n    }\\n    \\n    private String time(int a, int b, int c, int d) { \\n        if(a>2||c>5)  return \"\";\\n        if(a==2&&b>3) return \"\";\\n        \\n        StringBuilder r = new StringBuilder();\\n        \\n        r.append(a);\\n        r.append(b);\\n        r.append(\":\");\\n        r.append(c);\\n        r.append(d);\\n        \\n        return r.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public String largestTimeFromDigits(int[] A) {       \\n        Arrays.sort(A);       \\n               \\n        String r = \"\";\\n        \\n        for(int i=3;i>=0;i--) {\\n            for(int j=3;j>=0;j--) {\\n                if(j==i) continue;\\n                for(int k=3;k>=0;k--){\\n                    if(k==j || k==i)  continue;\\n                    for(int s=3;s>=0;s--){\\n                        if(s==k||s==j||s==i) continue;\\n                        String t = time(A[i],A[j],A[k],A[s]);\\n                        if(!t.equals(\"\")) {\\n                            return t;\\n                        }                        \\n                    }\\n                }\\n            }\\n        }\\n\\n        return r;       \\n    }\\n    \\n    private String time(int a, int b, int c, int d) { \\n        if(a>2||c>5)  return \"\";\\n        if(a==2&&b>3) return \"\";\\n        \\n        StringBuilder r = new StringBuilder();\\n        \\n        r.append(a);\\n        r.append(b);\\n        r.append(\":\");\\n        r.append(c);\\n        r.append(d);\\n        \\n        return r.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246468,
                "title": "use-c-next-permutation",
                "content": "C++ offers next_permutation in STL.\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<int> pos={0,1,2,3};\\n        string s=\"\";\\n        for (int i=0;i<24;++i){\\n            int hour=A[pos[0]]*10+A[pos[1]];\\n            int min=A[pos[2]]*10+A[pos[3]];\\n            if (hour>=0&&hour<=23&&min>=0&&min<=59){\\n                s=to_string(A[pos[0]])+to_string(A[pos[1]]);\\n                s+=\":\";\\n                s+=to_string(A[pos[2]])+to_string(A[pos[3]]);\\n            }\\n            next_permutation(pos.begin(),pos.end());\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        vector<int> pos={0,1,2,3};\\n        string s=\"\";\\n        for (int i=0;i<24;++i){\\n            int hour=A[pos[0]]*10+A[pos[1]];\\n            int min=A[pos[2]]*10+A[pos[3]];\\n            if (hour>=0&&hour<=23&&min>=0&&min<=59){\\n                s=to_string(A[pos[0]])+to_string(A[pos[1]]);\\n                s+=\":\";\\n                s+=to_string(A[pos[2]])+to_string(A[pos[3]]);\\n            }\\n            next_permutation(pos.begin(),pos.end());\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240461,
                "title": "python3-100-with-easy-filter",
                "content": "\\n\\'\\'\\'\\nclass Solution:\\n    def largestTimeFromDigits(self, A: \\'List[int]\\') -> \\'str\\':\\n        A.sort()\\n        if A[0]>2 or A[1]>5:#\\u52A0\\u5165\\u7C97\\u7565\\u7B5B\\u9009\\n            return(\"\")\\n        ans=\"\"\\n        from itertools import permutations\\n        mh=-1\\n        mm=-1\\n        flag=0\\n        for s in permutations(A):\\n            h = s[0]*10+s[1]\\n            m = s[2]*10+s[3]\\n            if (mh<h<24 and m<60) or (h==mh and mm<m<60):\\n                flag=1\\n                mh=h\\n                mm=m\\n        if flag:\\n      \\n            return(\"%02d:%02d\"%(mh,mm))\\n        else:\\n            return(\"\")\\n\\'\\'\\'\\n",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'\\nclass Solution:\\n    def largestTimeFromDigits(self, A: \\'List[int]\\') -> \\'str\\':\\n        A.sort()\\n        if A[0]>2 or A[1]>5:#\\u52A0\\u5165\\u7C97\\u7565\\u7B5B\\u9009\\n            return(\"\")\\n        ans=\"\"\\n        from itertools import permutations\\n        mh=-1\\n        mm=-1\\n        flag=0\\n        for s in permutations(A):\\n            h = s[0]*10+s[1]\\n            m = s[2]*10+s[3]\\n            if (mh<h<24 and m<60) or (h==mh and mm<m<60):\\n                flag=1\\n                mh=h\\n                mm=m\\n        if flag:\\n      \\n            return(\"%02d:%02d\"%(mh,mm))\\n        else:\\n            return(\"\")\\n\\'\\'\\'\\n",
                "codeTag": "Java"
            },
            {
                "id": 235821,
                "title": "c-very-short-prev-permutation-beats-100",
                "content": "Since we generate permutations in decreasing order, we know that first valid found is biggest, so we can stop our search.\\n```Cpp\\nstring largestTimeFromDigits(vector<int>& A) {\\n    sort(A.rbegin(),A.rend());\\n    char res[6];\\n    res[0]=\\'\\\\0\\';\\n    do {\\n        int h = A[0]*10+A[1];\\n        int m = A[2]*10+A[3];\\n        if(h<24 && m<60) {\\n            sprintf(res,\"%02d:%02d\",h,m);\\n            break; \\n        }\\n    } while(prev_permutation(A.begin(),A.end()));\\n    return string(res);\\n}\\n```",
                "solutionTags": [],
                "code": "```Cpp\\nstring largestTimeFromDigits(vector<int>& A) {\\n    sort(A.rbegin(),A.rend());\\n    char res[6];\\n    res[0]=\\'\\\\0\\';\\n    do {\\n        int h = A[0]*10+A[1];\\n        int m = A[2]*10+A[3];\\n        if(h<24 && m<60) {\\n            sprintf(res,\"%02d:%02d\",h,m);\\n            break; \\n        }\\n    } while(prev_permutation(A.begin(),A.end()));\\n    return string(res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201871,
                "title": "c-javascript-solution-implemented-next-permutation",
                "content": "C++\\n\\n```\\nbool isValid(vector<int> & A){\\n\\tif(((A[0]==0 && A[1]<=9) || (A[0]==1 && A[1]<=9) || (A[0]==2 && A[1]<=3)) && A[2]<=5 && A[3]<=9){\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n           \\n}\\n    \\nbool next_permut(vector<int> &A ){\\n\\tint i=A.size()-2;\\n\\n\\twhile(i>=0 && A[i]>=A[i+1]){\\n\\t\\ti--;\\n\\t}\\n\\tif(i<0){\\n\\t\\treturn false;\\n\\t}\\n\\n\\tint j=A.size()-1;\\n\\twhile(A[j]<=A[i]){\\n\\t\\tj--;\\n\\t}\\n\\tA[i]^=A[j];\\n\\tA[j]^=A[i];\\n\\tA[i]^=A[j];\\n\\n\\tj=A.size()-1;\\n\\ti++;\\n\\twhile(i<j){\\n\\t\\tA[i]^=A[j];\\n\\t\\tA[j]^=A[i];\\n\\t\\tA[i]^=A[j];\\n\\t\\ti++;\\n\\t\\tj--;\\n\\t}\\n\\treturn true;\\n}\\nstring largestTimeFromDigits(vector<int>& A) {\\n\\tsort(A.begin(),A.end());\\n\\tvector<int> out;\\n\\tdo{\\n\\t\\tif(isValid(A)){\\n\\t\\t\\tout=A;\\n\\t\\t}\\n\\t}while(next_permut(A));\\n\\n\\tif(out.size()==0){\\n\\t\\treturn \"\";\\n\\t}\\n\\t return to_string(out[0])+to_string(out[1])+\":\"+to_string(out[2])+to_string(out[3]);\\n}\\n```\\n\\nJavascript\\n```\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nlet isValid=function( A){\\n    if(((A[0]===0 && A[1]<=9) || (A[0]===1 && A[1]<=9) || (A[0]===2 && A[1]<=3)) && A[2]<=5 && A[3]<=9){\\n        return true;\\n    }\\n    return false;\\n};\\n    \\nlet next_permut= function(A ){\\n    let i=A.length-2;\\n\\n    while(i>=0 && A[i]>=A[i+1]){\\n        i--;\\n    }\\n    if(i<0){\\n        return false;\\n    }\\n\\n    let j=A.length-1;\\n    while(A[j]<=A[i]){\\n        j--;\\n    }\\n    A[i]^=A[j];\\n    A[j]^=A[i];\\n    A[i]^=A[j];\\n\\n    j=A.length-1;\\n    i++;\\n    while(i<j){\\n        A[i]^=A[j];\\n        A[j]^=A[i];\\n        A[i]^=A[j];\\n        i++;\\n        j--;\\n    }\\n    return true;\\n};\\n    \\nvar largestTimeFromDigits = function(A) {\\n   A.sort((a,b)=>parseInt(a)-parseInt(b));\\n   let out=[];\\n    do{\\n        if(isValid(A)){\\n            out=A.slice();\\n        }\\n    }while(next_permut(A));\\n\\n    if(out.length==0){\\n        return \"\";\\n    }\\n    return out[0].toString()+out[1].toString()+\":\"+out[2].toString()+out[3].toString();\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nbool isValid(vector<int> & A){\\n\\tif(((A[0]==0 && A[1]<=9) || (A[0]==1 && A[1]<=9) || (A[0]==2 && A[1]<=3)) && A[2]<=5 && A[3]<=9){\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n           \\n}\\n    \\nbool next_permut(vector<int> &A ){\\n\\tint i=A.size()-2;\\n\\n\\twhile(i>=0 && A[i]>=A[i+1]){\\n\\t\\ti--;\\n\\t}\\n\\tif(i<0){\\n\\t\\treturn false;\\n\\t}\\n\\n\\tint j=A.size()-1;\\n\\twhile(A[j]<=A[i]){\\n\\t\\tj--;\\n\\t}\\n\\tA[i]^=A[j];\\n\\tA[j]^=A[i];\\n\\tA[i]^=A[j];\\n\\n\\tj=A.size()-1;\\n\\ti++;\\n\\twhile(i<j){\\n\\t\\tA[i]^=A[j];\\n\\t\\tA[j]^=A[i];\\n\\t\\tA[i]^=A[j];\\n\\t\\ti++;\\n\\t\\tj--;\\n\\t}\\n\\treturn true;\\n}\\nstring largestTimeFromDigits(vector<int>& A) {\\n\\tsort(A.begin(),A.end());\\n\\tvector<int> out;\\n\\tdo{\\n\\t\\tif(isValid(A)){\\n\\t\\t\\tout=A;\\n\\t\\t}\\n\\t}while(next_permut(A));\\n\\n\\tif(out.size()==0){\\n\\t\\treturn \"\";\\n\\t}\\n\\t return to_string(out[0])+to_string(out[1])+\":\"+to_string(out[2])+to_string(out[3]);\\n}\\n```\n```\\n/**\\n * @param {number[]} A\\n * @return {string}\\n */\\nlet isValid=function( A){\\n    if(((A[0]===0 && A[1]<=9) || (A[0]===1 && A[1]<=9) || (A[0]===2 && A[1]<=3)) && A[2]<=5 && A[3]<=9){\\n        return true;\\n    }\\n    return false;\\n};\\n    \\nlet next_permut= function(A ){\\n    let i=A.length-2;\\n\\n    while(i>=0 && A[i]>=A[i+1]){\\n        i--;\\n    }\\n    if(i<0){\\n        return false;\\n    }\\n\\n    let j=A.length-1;\\n    while(A[j]<=A[i]){\\n        j--;\\n    }\\n    A[i]^=A[j];\\n    A[j]^=A[i];\\n    A[i]^=A[j];\\n\\n    j=A.length-1;\\n    i++;\\n    while(i<j){\\n        A[i]^=A[j];\\n        A[j]^=A[i];\\n        A[i]^=A[j];\\n        i++;\\n        j--;\\n    }\\n    return true;\\n};\\n    \\nvar largestTimeFromDigits = function(A) {\\n   A.sort((a,b)=>parseInt(a)-parseInt(b));\\n   let out=[];\\n    do{\\n        if(isValid(A)){\\n            out=A.slice();\\n        }\\n    }while(next_permut(A));\\n\\n    if(out.length==0){\\n        return \"\";\\n    }\\n    return out[0].toString()+out[1].toString()+\":\"+out[2].toString()+out[3].toString();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201327,
                "title": "brute-force-python-20ms-beats-100",
                "content": "```\\nimport itertools\\n\\nclass Solution(object):\\n    def largestTimeFromDigits(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: str\\n        \"\"\"\\n        \\n        perms = itertools.permutations(A)\\n        argbest = []\\n        best = -1\\n        for p in perms:\\n            h = p[0]*10+p[1]\\n            if h > 23:\\n                continue\\n            m = p[2]*10+p[3]\\n            if m > 59:\\n                continue\\n            cur = h * 100 + m\\n            if cur > best:\\n                best = cur\\n                argbest = p\\n        if best < 0:\\n            return \\'\\'\\n        return str(argbest[0]) + str(argbest[1]) + \\':\\' + str(argbest[2]) + str(argbest[3])\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nimport itertools\\n\\nclass Solution(object):\\n    def largestTimeFromDigits(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: str\\n        \"\"\"\\n        \\n        perms = itertools.permutations(A)\\n        argbest = []\\n        best = -1\\n        for p in perms:\\n            h = p[0]*10+p[1]\\n            if h > 23:\\n                continue\\n            m = p[2]*10+p[3]\\n            if m > 59:\\n                continue\\n            cur = h * 100 + m\\n            if cur > best:\\n                best = cur\\n                argbest = p\\n        if best < 0:\\n            return \\'\\'\\n        return str(argbest[0]) + str(argbest[1]) + \\':\\' + str(argbest[2]) + str(argbest[3])\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 201313,
                "title": "golang-recursive-and-iterative-solutions-suggestions-welcome",
                "content": "Recursive solution was easier to figure out first and runs all test cases in 4ms\\n\\n```\\nfunc largestTimeFromDigits(A []int) string {\\n    times := getTimePermutations(A)\\n    hr, min := -1, -1\\n    \\n    for i:=0;i<len(times);i++ {\\n        curHr, curMin := getTime(times[i])\\n        \\n        if curHr <=23 && curMin <= 59 && (curHr > hr || curHr == hr && curMin > min) {\\n            hr = curHr\\n            min = curMin\\n        }\\n    }\\n    \\n    ans := \"\"\\n    if hr == -1 {\\n        return ans\\n    }\\n    \\n    if hr < 10 {\\n        ans = \"0\"\\n    }\\n    ans += strconv.Itoa(hr) + \":\"\\n    \\n    if min < 10 {\\n        ans += \"0\"\\n    }\\n    ans += strconv.Itoa(min)\\n    return ans\\n}\\n\\nfunc getTimePermutations(A []int) [][]int {\\n    if len(A) == 1 {\\n        return [][]int{[]int{A[0]}}\\n    }\\n    \\n    ret := [][]int{}\\n    \\n    for i:=0;i<len(A);i++ {\\n        pickVal := A[i]\\n        remainder := []int{}\\n        remainder = append(remainder, A[:i]...)\\n        remainder = append(remainder, A[i+1:]...)\\n        \\n        permutations := getTimePermutations(remainder)\\n        \\n        for _,p := range permutations {\\n            newTime := []int{pickVal}\\n            newTime = append(newTime, p...)\\n            ret = append(ret, newTime)\\n        }\\n    }\\n    \\n    return ret\\n}\\n\\nfunc getTime(time []int) (hr, min int) {\\n    hr = time[0]*10 + time[1]\\n    min = time[2]*10 + time[3]\\n    return\\n}\\n```\\n\\nIterative solution runs all test cases in 0ms\\n```\\nfunc largestTimeFromDigits(A []int) string {\\n    maxHr, maxMin := -1, -1\\n    \\n    for i:=0;i<len(A);i++ {\\n        for j:=0;j<len(A);j++ {\\n            if j==i {\\n                continue\\n            }\\n            for k:=0;k<len(A);k++ {\\n                if k==j || k==i {\\n                    continue\\n                }\\n                \\n                l := 6-i-j-k // sum of indexes for an array of size 4: 0+1+2+3 = 6\\n                \\n                hr := A[i]*10 + A[j]\\n                min := A[k]*10 + A[l]\\n                \\n                if hr<=23 && min<=59 && (hr>maxHr || hr==maxHr && min>maxMin) {\\n                    maxHr = hr\\n                    maxMin = min\\n                }\\n            }\\n        }\\n    }\\n    \\n    if maxHr == -1 {\\n        return \"\"\\n    }\\n    \\n    ans := \"\"\\n    \\n    if maxHr<10 {\\n        ans = \"0\"\\n    }\\n    ans += strconv.Itoa(maxHr) + \":\"\\n    \\n    if maxMin<10 {\\n        ans += \"0\"\\n    }\\n    ans += strconv.Itoa(maxMin)\\n    \\n    return ans\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc largestTimeFromDigits(A []int) string {\\n    times := getTimePermutations(A)\\n    hr, min := -1, -1\\n    \\n    for i:=0;i<len(times);i++ {\\n        curHr, curMin := getTime(times[i])\\n        \\n        if curHr <=23 && curMin <= 59 && (curHr > hr || curHr == hr && curMin > min) {\\n            hr = curHr\\n            min = curMin\\n        }\\n    }\\n    \\n    ans := \"\"\\n    if hr == -1 {\\n        return ans\\n    }\\n    \\n    if hr < 10 {\\n        ans = \"0\"\\n    }\\n    ans += strconv.Itoa(hr) + \":\"\\n    \\n    if min < 10 {\\n        ans += \"0\"\\n    }\\n    ans += strconv.Itoa(min)\\n    return ans\\n}\\n\\nfunc getTimePermutations(A []int) [][]int {\\n    if len(A) == 1 {\\n        return [][]int{[]int{A[0]}}\\n    }\\n    \\n    ret := [][]int{}\\n    \\n    for i:=0;i<len(A);i++ {\\n        pickVal := A[i]\\n        remainder := []int{}\\n        remainder = append(remainder, A[:i]...)\\n        remainder = append(remainder, A[i+1:]...)\\n        \\n        permutations := getTimePermutations(remainder)\\n        \\n        for _,p := range permutations {\\n            newTime := []int{pickVal}\\n            newTime = append(newTime, p...)\\n            ret = append(ret, newTime)\\n        }\\n    }\\n    \\n    return ret\\n}\\n\\nfunc getTime(time []int) (hr, min int) {\\n    hr = time[0]*10 + time[1]\\n    min = time[2]*10 + time[3]\\n    return\\n}\\n```\n```\\nfunc largestTimeFromDigits(A []int) string {\\n    maxHr, maxMin := -1, -1\\n    \\n    for i:=0;i<len(A);i++ {\\n        for j:=0;j<len(A);j++ {\\n            if j==i {\\n                continue\\n            }\\n            for k:=0;k<len(A);k++ {\\n                if k==j || k==i {\\n                    continue\\n                }\\n                \\n                l := 6-i-j-k // sum of indexes for an array of size 4: 0+1+2+3 = 6\\n                \\n                hr := A[i]*10 + A[j]\\n                min := A[k]*10 + A[l]\\n                \\n                if hr<=23 && min<=59 && (hr>maxHr || hr==maxHr && min>maxMin) {\\n                    maxHr = hr\\n                    maxMin = min\\n                }\\n            }\\n        }\\n    }\\n    \\n    if maxHr == -1 {\\n        return \"\"\\n    }\\n    \\n    ans := \"\"\\n    \\n    if maxHr<10 {\\n        ans = \"0\"\\n    }\\n    ans += strconv.Itoa(maxHr) + \":\"\\n    \\n    if maxMin<10 {\\n        ans += \"0\"\\n    }\\n    ans += strconv.Itoa(maxMin)\\n    \\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 200984,
                "title": "java-super-easy-o-24-9ms-solution-beats-100",
                "content": "```\\n    int res=-1;\\n    public String largestTimeFromDigits(int[] A) {\\n        BT(A, new boolean[]{false,false,false,false}, new StringBuilder());\\n        if(res==-1) return \"\";\\n        String a=Integer.toString(res/60), b=Integer.toString(res%60);\\n        if(a.length()==1) a=\"0\"+a;\\n        if(b.length()==1) b=\"0\"+b;\\n        return a+\":\"+b;\\n    }\\n    \\n    public void BT(int[] A, boolean[] used, StringBuilder sb) {\\n        if(sb.length()==4) {\\n            int a=Integer.parseInt(sb.substring(0, 2).toString());\\n            int b=Integer.parseInt(sb.substring(2).toString());\\n            if(a>23||b>59) return;\\n            res=Math.max(res, a*60+b);\\n            return;\\n        }\\n        for(int i=0;i<4;i++) {\\n            if(!used[i]) {\\n                used[i]=true;\\n                BT(A, used, new StringBuilder(sb).append(A[i]));\\n                used[i]=false;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\n    int res=-1;\\n    public String largestTimeFromDigits(int[] A) {\\n        BT(A, new boolean[]{false,false,false,false}, new StringBuilder());\\n        if(res==-1) return \"\";\\n        String a=Integer.toString(res/60), b=Integer.toString(res%60);\\n        if(a.length()==1) a=\"0\"+a;\\n        if(b.length()==1) b=\"0\"+b;\\n        return a+\":\"+b;\\n    }\\n    \\n    public void BT(int[] A, boolean[] used, StringBuilder sb) {\\n        if(sb.length()==4) {\\n            int a=Integer.parseInt(sb.substring(0, 2).toString());\\n            int b=Integer.parseInt(sb.substring(2).toString());\\n            if(a>23||b>59) return;\\n            res=Math.max(res, a*60+b);\\n            return;\\n        }\\n        for(int i=0;i<4;i++) {\\n            if(!used[i]) {\\n                used[i]=true;\\n                BT(A, used, new StringBuilder(sb).append(A[i]));\\n                used[i]=false;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 200653,
                "title": "backtrack-permutation",
                "content": "```\\nclass Solution {\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        if (A == null || A.length == 0){\\n            return \"\";\\n        }\\n        boolean[] visited = new boolean[4];\\n        List<List<Integer>> resList = new ArrayList<>();\\n        permutation(resList, A, new ArrayList<Integer>(), visited);\\n        int max = Integer.MIN_VALUE;\\n        int index = -1;\\n        for (int i = 0; i < resList.size(); i++){\\n            List<Integer> list = resList.get(i);\\n            int num = convert(list);\\n            if (num > max){\\n                max = num;\\n                index = i;\\n            }\\n        }\\n        if (index == -1 || max == Integer.MIN_VALUE){\\n            return \"\";\\n        }\\n        List<Integer> res = resList.get(index);\\n        return res.get(0) + String.valueOf(res.get(1)) + \":\" + String.valueOf(res.get(2)) + res.get(3);\\n    }\\n    private void permutation(List<List<Integer>> res, int[] A, List<Integer> item, boolean[] visited){\\n        if (item.size() == A.length){\\n            res.add(new ArrayList<>(item));\\n            return;\\n        }\\n        for (int i = 0; i < A.length; i++){\\n            if (!visited[i]){\\n                visited[i] = true;\\n                item.add(A[i]);\\n                permutation(res, A, item, visited);\\n                visited[i] = false;\\n                item.remove(item.size() - 1);\\n            }\\n        }\\n    }\\n    private int convert(List<Integer> list){\\n        if (list.get(0) * 10 + list.get(1) < 24 && list.get(2) * 10 + list.get(3) < 60){\\n            return list.get(0) * 1000 + list.get(1) * 100 + list.get(2) * 10 + list.get(3);\\n        }\\n        return Integer.MIN_VALUE;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public String largestTimeFromDigits(int[] A) {\\n        if (A == null || A.length == 0){\\n            return \"\";\\n        }\\n        boolean[] visited = new boolean[4];\\n        List<List<Integer>> resList = new ArrayList<>();\\n        permutation(resList, A, new ArrayList<Integer>(), visited);\\n        int max = Integer.MIN_VALUE;\\n        int index = -1;\\n        for (int i = 0; i < resList.size(); i++){\\n            List<Integer> list = resList.get(i);\\n            int num = convert(list);\\n            if (num > max){\\n                max = num;\\n                index = i;\\n            }\\n        }\\n        if (index == -1 || max == Integer.MIN_VALUE){\\n            return \"\";\\n        }\\n        List<Integer> res = resList.get(index);\\n        return res.get(0) + String.valueOf(res.get(1)) + \":\" + String.valueOf(res.get(2)) + res.get(3);\\n    }\\n    private void permutation(List<List<Integer>> res, int[] A, List<Integer> item, boolean[] visited){\\n        if (item.size() == A.length){\\n            res.add(new ArrayList<>(item));\\n            return;\\n        }\\n        for (int i = 0; i < A.length; i++){\\n            if (!visited[i]){\\n                visited[i] = true;\\n                item.add(A[i]);\\n                permutation(res, A, item, visited);\\n                visited[i] = false;\\n                item.remove(item.size() - 1);\\n            }\\n        }\\n    }\\n    private int convert(List<Integer> list){\\n        if (list.get(0) * 10 + list.get(1) < 24 && list.get(2) * 10 + list.get(3) < 60){\\n            return list.get(0) * 1000 + list.get(1) * 100 + list.get(2) * 10 + list.get(3);\\n        }\\n        return Integer.MIN_VALUE;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200649,
                "title": "java-o-24-60",
                "content": "```\\npublic String largestTimeFromDigits(int[] A) {\\n        int[] count = new int[10];\\n        for(int a : A) count[a]++;\\n        for(int i = 23; i >= 0; i--) {\\n            int a = i / 10, b = i % 10;\\n            count[a]--;\\n            count[b]--;\\n            if (count[a] >= 0 && count[b] >= 0) {\\n                for(int j = 59; j >= 0; j--) {\\n                    int p = j / 10, q = j % 10;\\n                    count[p]--;\\n                    count[q]--;\\n                    if (count[p] >= 0 && count[q] >= 0)\\n                        return a + \"\" + b + \":\" + p + \"\" + q;\\n                    count[p]++;\\n                    count[q]++;\\n                }\\n            }\\n            count[a]++;\\n            count[b]++;\\n        }\\n        return \"\";\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String largestTimeFromDigits(int[] A) {\\n        int[] count = new int[10];\\n        for(int a : A) count[a]++;\\n        for(int i = 23; i >= 0; i--) {\\n            int a = i / 10, b = i % 10;\\n            count[a]--;\\n            count[b]--;\\n            if (count[a] >= 0 && count[b] >= 0) {\\n                for(int j = 59; j >= 0; j--) {\\n                    int p = j / 10, q = j % 10;\\n                    count[p]--;\\n                    count[q]--;\\n                    if (count[p] >= 0 && count[q] >= 0)\\n                        return a + \"\" + b + \":\" + p + \"\" + q;\\n                    count[p]++;\\n                    count[q]++;\\n                }\\n            }\\n            count[a]++;\\n            count[b]++;\\n        }\\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 200560,
                "title": "java-permutation-solution",
                "content": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        String time = \"\";\\n        String str = \"\";\\n        for (int a : A) {\\n            str += a; \\n        }\\n        \\n        List<String> list = new ArrayList<>();\\n        \\n        permutation(\"\", str, list);     \\n        \\n        for (String s : list) {\\n            s = s.substring(0, 2) + \":\" + s.substring(2);\\n            if (s.charAt(3) < \\'6\\') {\\n                if (s.charAt(0) <= \\'2\\' && s.compareTo(\"24:00\") < 0) {\\n                    time = time.compareTo(s) > 0 ? time : s;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n    \\n    \\n    private static void permutation(String prefix, String str, List<String> list) {\\n        int n = str.length();\\n        if (n == 0) list.add(prefix);\\n        else {\\n            for (int i = 0; i < n; i++)\\n            permutation(prefix + str.charAt(i), str.substring(0, i) + str.substring(i+1, n), list);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        String time = \"\";\\n        String str = \"\";\\n        for (int a : A) {\\n            str += a; \\n        }\\n        \\n        List<String> list = new ArrayList<>();\\n        \\n        permutation(\"\", str, list);     \\n        \\n        for (String s : list) {\\n            s = s.substring(0, 2) + \":\" + s.substring(2);\\n            if (s.charAt(3) < \\'6\\') {\\n                if (s.charAt(0) <= \\'2\\' && s.compareTo(\"24:00\") < 0) {\\n                    time = time.compareTo(s) > 0 ? time : s;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n    \\n    \\n    private static void permutation(String prefix, String str, List<String> list) {\\n        int n = str.length();\\n        if (n == 0) list.add(prefix);\\n        else {\\n            for (int i = 0; i < n; i++)\\n            permutation(prefix + str.charAt(i), str.substring(0, i) + str.substring(i+1, n), list);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200556,
                "title": "java-no-permutation-no-brute-force-warning-messy-code-ahead-6ms-10ms",
                "content": "Code messy AF.   [6ms-10ms]\\n```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int[] freq = new int[10];\\n        for (int i=0; i<A.length; i++) freq[A[i]]++;\\n        StringBuilder sb = new StringBuilder();\\n        int[] invalidhr = new int[24];\\n        \\n        boolean nextRound = true;\\n        while (nextRound) {\\n            sb = new StringBuilder();\\n            nextRound = false;\\n            int hr = 0;\\n            int[] table = Arrays.copyOf(freq, freq.length);\\n             for (int i=23; i>=0; i--) {\\n                int a = i/10 % 10;\\n                int b = i % 10;\\n                if ( ((a == b && table[a]>1) || (a!=b && table[a]>0 && table[b]>0)) && invalidhr[i]!=1) {  \\n                        sb.append(\"\" + a + \"\" + b);\\n                        table[a]--;\\n                        table[b]--;\\n                        hr = i;\\n                        break;\\n                }\\n            }\\n            if (sb.length()<2) return \"\";\\n            sb.append(\":\");\\n\\n            for (int i=59; i>=0; i--) {\\n                int a = i/10 % 10;\\n                int b = i % 10;\\n                if ( ((a == b && table[a]>1) || (a!=b && table[a]>0 && table[b]>0)) ) {  \\n                        sb.append(\"\" + a + \"\" + b);\\n                        table[a]--;\\n                        table[b]--;\\n                        break;\\n                }\\n            }\\n\\n            if (sb.length()<5) { \\n                nextRound = true;\\n                invalidhr[hr] = 1;\\n                // we need to find the next one.\\n            }\\n            if (!nextRound) break;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] A) {\\n        int[] freq = new int[10];\\n        for (int i=0; i<A.length; i++) freq[A[i]]++;\\n        StringBuilder sb = new StringBuilder();\\n        int[] invalidhr = new int[24];\\n        \\n        boolean nextRound = true;\\n        while (nextRound) {\\n            sb = new StringBuilder();\\n            nextRound = false;\\n            int hr = 0;\\n            int[] table = Arrays.copyOf(freq, freq.length);\\n             for (int i=23; i>=0; i--) {\\n                int a = i/10 % 10;\\n                int b = i % 10;\\n                if ( ((a == b && table[a]>1) || (a!=b && table[a]>0 && table[b]>0)) && invalidhr[i]!=1) {  \\n                        sb.append(\"\" + a + \"\" + b);\\n                        table[a]--;\\n                        table[b]--;\\n                        hr = i;\\n                        break;\\n                }\\n            }\\n            if (sb.length()<2) return \"\";\\n            sb.append(\":\");\\n\\n            for (int i=59; i>=0; i--) {\\n                int a = i/10 % 10;\\n                int b = i % 10;\\n                if ( ((a == b && table[a]>1) || (a!=b && table[a]>0 && table[b]>0)) ) {  \\n                        sb.append(\"\" + a + \"\" + b);\\n                        table[a]--;\\n                        table[b]--;\\n                        break;\\n                }\\n            }\\n\\n            if (sb.length()<5) { \\n                nextRound = true;\\n                invalidhr[hr] = 1;\\n                // we need to find the next one.\\n            }\\n            if (!nextRound) break;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200530,
                "title": "java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    String time;\\n    int[] max = {2, 3, 5, 9};\\n    public String largestTimeFromDigits(int[] A) {\\n        \\n        int[] cur = new int[4];\\n        Arrays.fill(cur, -1);\\n        \\n        findLargest(A, new boolean[4], cur, 0);\\n        return time == null ? \"\" : time;\\n    }\\n    \\n    private void findLargest(int[] A, boolean[] used, int[] cur, int pos) {\\n        if (pos == 4) {\\n            String s = \"\" + cur[0] + cur[1] + \":\" + cur[2] + cur[3];\\n            if (time == null || time.compareTo(s) < 0) {\\n                time = s;\\n            }\\n            return;\\n        }\\n        if (pos == 1) {\\n            if (cur[0] == 1 || cur[0] == 0){\\n                max[1] = 9;\\n            } else if (cur[0] == 2) {\\n                max[1] = 3;\\n            }\\n        }\\n        for (int j = 0; j < 4; j++) {\\n            if (used[j] || A[j] > max[pos]) continue;\\n            cur[pos] = A[j];\\n            used[j]  = true;\\n            findLargest(A, used, cur, pos + 1);\\n            cur[pos] = -1;\\n            used[j] = false;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    String time;\\n    int[] max = {2, 3, 5, 9}",
                "codeTag": "Java"
            },
            {
                "id": 200495,
                "title": "python-straightforward-permutation",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        h = m = -float(\"inf\")\\n        for n1, n2, n3, n4 in itertools.permutations(A):\\n            hh, mm = n1 * 10 + n2, n3 * 10 + n4\\n            if 0 <= hh <= 23 and 0 <= mm <= 59 and (hh > h or hh == h and mm > m):\\n                h, m = hh, mm\\n        sh = str(h) if h > 9 else \"0\" + str(h)\\n        sm = str(m) if m > 9 else \"0\" + str(m)\\n        return 0 <= h <= 23 and 0 <= m <= 59 and sh + \":\" + sm or \"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, A):\\n        h = m = -float(\"inf\")\\n        for n1, n2, n3, n4 in itertools.permutations(A):\\n            hh, mm = n1 * 10 + n2, n3 * 10 + n4\\n            if 0 <= hh <= 23 and 0 <= mm <= 59 and (hh > h or hh == h and mm > m):\\n                h, m = hh, mm\\n        sh = str(h) if h > 9 else \"0\" + str(h)\\n        sm = str(m) if m > 9 else \"0\" + str(m)\\n        return 0 <= h <= 23 and 0 <= m <= 59 and sh + \":\" + sm or \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099326,
                "title": "brute-forcce",
                "content": "```class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        vector<string> time;\\n        // string seconds=\"####\";\\n        for(int i=0;i<4;i++){\\n            string seconds=\"####\";\\n            string h1=to_string(arr[i]);\\n            seconds[i]=\\'$\\';\\n            for(int j=i+1;j<4;j++){\\n                string h2=to_string(arr[j]);\\n                seconds[j]=\\'$\\';\\n                \\n                string hr1=h1+h2;\\n                string hr2=h2+h1;\\n                \\n                string s1=\"-1\";\\n                string s2=\"-1\";\\n                for(int k=0;k<4;k++){\\n                    if(seconds[k]==\\'#\\'){\\n                        if(s1==\"-1\") s1=to_string(arr[k]);\\n                        else s2=to_string(arr[k]);\\n                    }\\n                }\\n                string sec1=s1+s2;\\n                string sec2=s2+s1;\\n                if(stoi(sec1)<60){\\n                    if(stoi(hr1)<24){\\n                        time.push_back(hr1+sec1);\\n                    }\\n                    if(stoi(hr2)<24){\\n                        time.push_back(hr2+sec1);\\n                    }\\n                }\\n                if(stoi(sec2)<60){\\n                    if(stoi(hr1)<24){\\n                        time.push_back(hr1+sec2);\\n                    }\\n                    if(stoi(hr2)<24){\\n                        time.push_back(hr2+sec2);\\n                    }\\n                }\\n                seconds[j]=\\'#\\';\\n                    \\n            }\\n        }\\n        sort(time.begin(),time.end());\\n        // for(auto x:time) cout<<x<<\" \";\\n        string res;\\n        if(time.size()>0)\\n        {\\n            string ans=time.back();\\n            cout<<ans;\\n            int cnt=0;\\n            for(auto c:ans){\\n                res+=c;\\n                cnt++;\\n                if(cnt==2) res+=\\':\\';\\n            }\\n        }\\n        return res;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        vector<string> time;\\n        // string seconds=\"####\";\\n        for(int i=0;i<4;i++){\\n            string seconds=\"####\";\\n            string h1=to_string(arr[i]);\\n            seconds[i]=\\'$\\';\\n            for(int j=i+1;j<4;j++){\\n                string h2=to_string(arr[j]);\\n                seconds[j]=\\'$\\';\\n                \\n                string hr1=h1+h2;\\n                string hr2=h2+h1;\\n                \\n                string s1=\"-1\";\\n                string s2=\"-1\";\\n                for(int k=0;k<4;k++){\\n                    if(seconds[k]==\\'#\\'){\\n                        if(s1==\"-1\") s1=to_string(arr[k]);\\n                        else s2=to_string(arr[k]);\\n                    }\\n                }\\n                string sec1=s1+s2;\\n                string sec2=s2+s1;\\n                if(stoi(sec1)<60){\\n                    if(stoi(hr1)<24){\\n                        time.push_back(hr1+sec1);\\n                    }\\n                    if(stoi(hr2)<24){\\n                        time.push_back(hr2+sec1);\\n                    }\\n                }\\n                if(stoi(sec2)<60){\\n                    if(stoi(hr1)<24){\\n                        time.push_back(hr1+sec2);\\n                    }\\n                    if(stoi(hr2)<24){\\n                        time.push_back(hr2+sec2);\\n                    }\\n                }\\n                seconds[j]=\\'#\\';\\n                    \\n            }\\n        }\\n        sort(time.begin(),time.end());\\n        // for(auto x:time) cout<<x<<\" \";\\n        string res;\\n        if(time.size()>0)\\n        {\\n            string ans=time.back();\\n            cout<<ans;\\n            int cnt=0;\\n            for(auto c:ans){\\n                res+=c;\\n                cnt++;\\n                if(cnt==2) res+=\\':\\';\\n            }\\n        }\\n        return res;\\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 4062057,
                "title": "43ms-handles-difficult-edge-case-o-n-log-n-time",
                "content": "This question is definitely do-able in 30 minutes or less if you have not encountered it before just really try your best to beat out the edge case early. I was able to solve this problem in 29 minutes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n# @param {Integer[]} arr\\n# @return {String}\\ndef largest_time_from_digits(arr)\\n    # Used to detect edge case where we have a 2 val and 2 vals larger\\n    # than 5 in array.\\n    digits_over_5 = 0\\n    arr.sort!{|a, b| b<=>a}\\n    nums_hash = {}\\n    arr.each do |n|\\n        if !nums_hash[n]\\n            nums_hash[n] = 0\\n        end\\n\\n        nums_hash[n] = nums_hash[n] + 1\\n        if n > 5\\n            digits_over_5 = digits_over_5 + 1\\n        end\\n    end\\n\\n    # If we have 2 val and 2 vals larger\\n    # than 5 in array the first digit cannot be a 2 \\n    # or else we invalidate the time.\\n    answer = \"\"\\n    if digits_over_5 > 1 and nums_hash[2]\\n        if nums_hash[1]\\n            answer = \"1\"\\n            nums_hash[1] = nums_hash[1] - 1\\n            if nums_hash[1] == 0\\n                nums_hash.delete 1\\n            end\\n        elsif nums_hash[0]\\n            answer = \"0\"\\n            nums_hash[0] = nums_hash[0] - 1\\n            if nums_hash[0] == 0\\n                nums_hash.delete 0\\n            end\\n        else\\n            return \"\"\\n        end\\n\\n        limiting_factors = [10, 6]\\n\\n    # In the situation where we do hit our edge case of 2 val + 2x vals larger than 5\\n    # we use our simple limiting factors array to put together our string.\\n    else\\n        limiting_factors = [3, \"x\", 6]\\n    end\\n\\n    \\n    limiting_factors.each do |limiting_factor|\\n        if limiting_factor == \"x\"\\n            if answer[0]\\n                if answer[0] == \"2\"\\n                    limiting_factor = 4\\n                else\\n                    limiting_factor = 10\\n                end\\n            else\\n                return \"\"\\n            end\\n        end\\n\\n        nums_hash.keys.each do |n|\\n            if n < limiting_factor\\n                answer = answer + n.to_s\\n                nums_hash[n] = nums_hash[n] - 1\\n                if nums_hash[n] == 0\\n                    nums_hash.delete n\\n                end\\n                break\\n            end\\n        end\\n    end\\n\\n    if answer.size < 3\\n        return \"\"\\n    else\\n        return answer[0] + answer[1] + \":\" + answer[2] + nums_hash.keys[0].to_s\\n    end\\nend\\n\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} arr\\n# @return {String}\\ndef largest_time_from_digits(arr)\\n    # Used to detect edge case where we have a 2 val and 2 vals larger\\n    # than 5 in array.\\n    digits_over_5 = 0\\n    arr.sort!{|a, b| b<=>a}\\n    nums_hash = {}\\n    arr.each do |n|\\n        if !nums_hash[n]\\n            nums_hash[n] = 0\\n        end\\n\\n        nums_hash[n] = nums_hash[n] + 1\\n        if n > 5\\n            digits_over_5 = digits_over_5 + 1\\n        end\\n    end\\n\\n    # If we have 2 val and 2 vals larger\\n    # than 5 in array the first digit cannot be a 2 \\n    # or else we invalidate the time.\\n    answer = \"\"\\n    if digits_over_5 > 1 and nums_hash[2]\\n        if nums_hash[1]\\n            answer = \"1\"\\n            nums_hash[1] = nums_hash[1] - 1\\n            if nums_hash[1] == 0\\n                nums_hash.delete 1\\n            end\\n        elsif nums_hash[0]\\n            answer = \"0\"\\n            nums_hash[0] = nums_hash[0] - 1\\n            if nums_hash[0] == 0\\n                nums_hash.delete 0\\n            end\\n        else\\n            return \"\"\\n        end\\n\\n        limiting_factors = [10, 6]\\n\\n    # In the situation where we do hit our edge case of 2 val + 2x vals larger than 5\\n    # we use our simple limiting factors array to put together our string.\\n    else\\n        limiting_factors = [3, \"x\", 6]\\n    end\\n\\n    \\n    limiting_factors.each do |limiting_factor|\\n        if limiting_factor == \"x\"\\n            if answer[0]\\n                if answer[0] == \"2\"\\n                    limiting_factor = 4\\n                else\\n                    limiting_factor = 10\\n                end\\n            else\\n                return \"\"\\n            end\\n        end\\n\\n        nums_hash.keys.each do |n|\\n            if n < limiting_factor\\n                answer = answer + n.to_s\\n                nums_hash[n] = nums_hash[n] - 1\\n                if nums_hash[n] == 0\\n                    nums_hash.delete n\\n                end\\n                break\\n            end\\n        end\\n    end\\n\\n    if answer.size < 3\\n        return \"\"\\n    else\\n        return answer[0] + answer[1] + \":\" + answer[2] + nums_hash.keys[0].to_s\\n    end\\nend\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3978551,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n private:\\n  using time_t = tuple<int, int, int, int>;\\n  static constexpr int n = 4;\\n  static constexpr int base = 10;\\n  static constexpr int min_hour = 0;\\n  static constexpr int max_hour = 23;\\n  static constexpr int min_minute = 0;\\n  static constexpr int max_minute = 59;\\n  static constexpr int minutes_per_hour = 60;\\n  static constexpr int invalid_component = -1;\\n  static constexpr char separator = \\':\\';\\n  static constexpr char zero = \\'0\\';\\n  \\n public:\\n  string largestTimeFromDigits(vector<int> &arr) {\\n    time_t largest_time{invalid_component, invalid_component, invalid_component, invalid_component};\\n    sort(arr.begin(), arr.end());\\n    do {\\n      time_t time{arr[0], arr[1], arr[2], arr[3]};\\n      if (!is_valid(time)) {\\n        continue;\\n      }\\n      \\n      if (is_empty(largest_time) || is_greater(time, largest_time)) {\\n        largest_time = move(time);\\n      }\\n    } while (next_permutation(arr.begin(), arr.end()));\\n    return is_empty(largest_time) ? string{} : to_string(largest_time);\\n  }\\n  \\n private:\\n  bool is_empty(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    return h1 == invalid_component && h2 == invalid_component && m1 == invalid_component && m2 == invalid_component;\\n  }\\n  \\n  pair<int, int> get_hour_and_minute(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    const int h = h1 * base + h2;\\n    const int m = m1 * base + m2;\\n    return make_pair(h, m);\\n  }\\n  \\n  bool is_valid(const time_t &time) {\\n    const auto [h, m] = get_hour_and_minute(time);\\n    return min_hour <= h && h <= max_hour && min_minute <= m && m <= max_minute;\\n  }\\n  \\n  int to_minute(const time_t &time) {\\n    const auto [h, m] = get_hour_and_minute(time);\\n    return h * minutes_per_hour + m;\\n  }\\n  \\n  bool is_greater(const time_t &lhs, const time_t &rhs) {\\n    return to_minute(lhs) > to_minute(rhs);\\n  }\\n  \\n  string to_string(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    string ret;\\n    ret.append(1, zero + h1).append(1, zero + h2).append(1, separator).append(1, zero + m1).append(1, zero + m2);\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(1)\\n * Space Complexity: O(1)\\n */\\nclass Solution {\\n private:\\n  using time_t = tuple<int, int, int, int>;\\n  static constexpr int n = 4;\\n  static constexpr int base = 10;\\n  static constexpr int min_hour = 0;\\n  static constexpr int max_hour = 23;\\n  static constexpr int min_minute = 0;\\n  static constexpr int max_minute = 59;\\n  static constexpr int minutes_per_hour = 60;\\n  static constexpr int invalid_component = -1;\\n  static constexpr char separator = \\':\\';\\n  static constexpr char zero = \\'0\\';\\n  \\n public:\\n  string largestTimeFromDigits(vector<int> &arr) {\\n    time_t largest_time{invalid_component, invalid_component, invalid_component, invalid_component};\\n    sort(arr.begin(), arr.end());\\n    do {\\n      time_t time{arr[0], arr[1], arr[2], arr[3]};\\n      if (!is_valid(time)) {\\n        continue;\\n      }\\n      \\n      if (is_empty(largest_time) || is_greater(time, largest_time)) {\\n        largest_time = move(time);\\n      }\\n    } while (next_permutation(arr.begin(), arr.end()));\\n    return is_empty(largest_time) ? string{} : to_string(largest_time);\\n  }\\n  \\n private:\\n  bool is_empty(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    return h1 == invalid_component && h2 == invalid_component && m1 == invalid_component && m2 == invalid_component;\\n  }\\n  \\n  pair<int, int> get_hour_and_minute(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    const int h = h1 * base + h2;\\n    const int m = m1 * base + m2;\\n    return make_pair(h, m);\\n  }\\n  \\n  bool is_valid(const time_t &time) {\\n    const auto [h, m] = get_hour_and_minute(time);\\n    return min_hour <= h && h <= max_hour && min_minute <= m && m <= max_minute;\\n  }\\n  \\n  int to_minute(const time_t &time) {\\n    const auto [h, m] = get_hour_and_minute(time);\\n    return h * minutes_per_hour + m;\\n  }\\n  \\n  bool is_greater(const time_t &lhs, const time_t &rhs) {\\n    return to_minute(lhs) > to_minute(rhs);\\n  }\\n  \\n  string to_string(const time_t &time) {\\n    const auto [h1, h2, m1, m2] = time;\\n    string ret;\\n    ret.append(1, zero + h1).append(1, zero + h2).append(1, separator).append(1, zero + m1).append(1, zero + m2);\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973855,
                "title": "solution-with-itertools-permutations-method",
                "content": "# Complexity\\n- Time complexity: `O(1)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSee coments for explanation ^\\n\\n# Code\\n```\\n# Clarification:\\n\\n# Test cases:\\n\\n# Notes:\\n# earliest 00:00 and latest 23:59\\n# hh < 24 and mm < 60\\n\\n# Plan:\\n# sort the input array in reverse order, because we want to give the greatest valid number from left to right.\\n# Get permutations with reversed sorted array and check if it\\'s valid. The permutations will go from greatest to smallest, and so if valid, it will return the greatest valid hour.\\n# Otherwise, if invalid, returns empty string.\\n\\n# Time: O(1)\\n# Our string consists of four digits and we are given 4 digits in the input arr. For the first place we have N options, for the second we have N - 1, and so on, which is equivalent to N!.\\n# However, since we know that our input array will always be 4:\\n# Permutations = 4!\\n# Sorting = 4 log (4)\\n# Both of this result in O(1)\\n\\n# Space: O(1)\\n# because list with permutations will contain 4! = O(1) space.\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        lst = list(permutations(sorted(arr, reverse = True)))\\n\\n        for h1, h2, m1, m2 in lst:\\n            if h1 * 10 + h2 < 24 and m1 * 10 + m2 < 60:\\n                return f\"{h1}{h2}:{m1}{m2}\"\\n        \\n        return \"\"\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Clarification:\\n\\n# Test cases:\\n\\n# Notes:\\n# earliest 00:00 and latest 23:59\\n# hh < 24 and mm < 60\\n\\n# Plan:\\n# sort the input array in reverse order, because we want to give the greatest valid number from left to right.\\n# Get permutations with reversed sorted array and check if it\\'s valid. The permutations will go from greatest to smallest, and so if valid, it will return the greatest valid hour.\\n# Otherwise, if invalid, returns empty string.\\n\\n# Time: O(1)\\n# Our string consists of four digits and we are given 4 digits in the input arr. For the first place we have N options, for the second we have N - 1, and so on, which is equivalent to N!.\\n# However, since we know that our input array will always be 4:\\n# Permutations = 4!\\n# Sorting = 4 log (4)\\n# Both of this result in O(1)\\n\\n# Space: O(1)\\n# because list with permutations will contain 4! = O(1) space.\\n\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        lst = list(permutations(sorted(arr, reverse = True)))\\n\\n        for h1, h2, m1, m2 in lst:\\n            if h1 * 10 + h2 < 24 and m1 * 10 + m2 < 60:\\n                return f\"{h1}{h2}:{m1}{m2}\"\\n        \\n        return \"\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973305,
                "title": "javascript-recursion",
                "content": "# Code\\n```\\nvar largestTimeFromDigits = function(arr) {\\n    let max = -1;\\n\\n    const go = (str, a) => {\\n        if (str.length === 2 && +str > 23) return; // hours need to be 23 or lower\\n        if (+str > 2359) return; // too big\\n        if (str.length === 4) {\\n            // minutes portion needs to be below 60 \\n            if (+str.substr(2) < 60) max = Math.max(max, +str);\\n            return;\\n        }\\n        for (let i = 0; i < a.length; i++) {\\n            go(str + a[i].toString(), a.slice(0, i).concat(a.slice(i + 1)))\\n        }\\n    }\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        // time can only start with 0, 1, or 2\\n        if (arr[i] < 3) go(arr[i].toString(), arr.slice(0, i).concat(arr.slice(i + 1)));\\n    }\\n    \\n    // format as hours:minutes, pad with zeroes if needed\\n    let fmt = (num) => {\\n        let str = (\\'0000\\' + num).slice(-4);\\n        return str.substr(0, 2) + \\':\\' + str.substr(2);\\n    }\\n\\n    return max === -1 ? \\'\\' : fmt(max);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestTimeFromDigits = function(arr) {\\n    let max = -1;\\n\\n    const go = (str, a) => {\\n        if (str.length === 2 && +str > 23) return; // hours need to be 23 or lower\\n        if (+str > 2359) return; // too big\\n        if (str.length === 4) {\\n            // minutes portion needs to be below 60 \\n            if (+str.substr(2) < 60) max = Math.max(max, +str);\\n            return;\\n        }\\n        for (let i = 0; i < a.length; i++) {\\n            go(str + a[i].toString(), a.slice(0, i).concat(a.slice(i + 1)))\\n        }\\n    }\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        // time can only start with 0, 1, or 2\\n        if (arr[i] < 3) go(arr[i].toString(), arr.slice(0, i).concat(arr.slice(i + 1)));\\n    }\\n    \\n    // format as hours:minutes, pad with zeroes if needed\\n    let fmt = (num) => {\\n        let str = (\\'0000\\' + num).slice(-4);\\n        return str.substr(0, 2) + \\':\\' + str.substr(2);\\n    }\\n\\n    return max === -1 ? \\'\\' : fmt(max);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3965020,
                "title": "python3-solution-using-itertools-permutations",
                "content": "# Code\\n```\\nfrom itertools import permutations \\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        time=[]\\n        for i in permutations(arr):\\n            if str(i[0])+str(i[1])<\"24\" and str(i[2])+str(i[3])<\"60\":\\n                time.append(str(i[0])+str(i[1])+\":\"+str(i[2])+str(i[3]))\\n                \\n        return max(time) if time else \"\"\\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import permutations \\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        time=[]\\n        for i in permutations(arr):\\n            if str(i[0])+str(i[1])<\"24\" and str(i[2])+str(i[3])<\"60\":\\n                time.append(str(i[0])+str(i[1])+\":\"+str(i[2])+str(i[3]))\\n                \\n        return max(time) if time else \"\"\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953733,
                "title": "c-permutations",
                "content": "```\\nclass Solution {\\n    bool isValidTime(const vector<int> &perm) {\\n        const int t = perm[0] * 1000 + perm[1] * 100 + perm[2] * 10 + perm[3];\\n        const int hh = t / 100;\\n        if(hh < 0 || hh > 23)\\n            return false;\\n        const int mm = t % 100;\\n        return mm >= 0 && mm <= 59;\\n    }\\n    string makeTime(const vector<int> &perm) {\\n        string ret(5, \\' \\');\\n        ret[0] = perm[0] + \\'0\\';\\n        ret[1] = perm[1] + \\'0\\';\\n        ret[2] = \\':\\';\\n        ret[3] = perm[2] + \\'0\\';\\n        ret[4] = perm[3] + \\'0\\';\\n        return ret;\\n    }\\n    void check_perm_rec(vector<int>& arr, int i, int N, string &t) {\\n        if(i == N) {\\n            if(isValidTime(arr)) {\\n                t = max(t, makeTime(arr));\\n            }\\n            return;\\n        }\\n        for(int j = i; j < N; ++j) {\\n            swap(arr[i], arr[j]);\\n            check_perm_rec(arr, i + 1, N, t);\\n            swap(arr[i], arr[j]);\\n        }\\n    }\\n    void check(vector<int> &arr, string &t) {\\n        check_perm_rec(arr, 0, arr.size(), t);\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string t;\\n        check(arr, t);\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isValidTime(const vector<int> &perm) {\\n        const int t = perm[0] * 1000 + perm[1] * 100 + perm[2] * 10 + perm[3];\\n        const int hh = t / 100;\\n        if(hh < 0 || hh > 23)\\n            return false;\\n        const int mm = t % 100;\\n        return mm >= 0 && mm <= 59;\\n    }\\n    string makeTime(const vector<int> &perm) {\\n        string ret(5, \\' \\');\\n        ret[0] = perm[0] + \\'0\\';\\n        ret[1] = perm[1] + \\'0\\';\\n        ret[2] = \\':\\';\\n        ret[3] = perm[2] + \\'0\\';\\n        ret[4] = perm[3] + \\'0\\';\\n        return ret;\\n    }\\n    void check_perm_rec(vector<int>& arr, int i, int N, string &t) {\\n        if(i == N) {\\n            if(isValidTime(arr)) {\\n                t = max(t, makeTime(arr));\\n            }\\n            return;\\n        }\\n        for(int j = i; j < N; ++j) {\\n            swap(arr[i], arr[j]);\\n            check_perm_rec(arr, i + 1, N, t);\\n            swap(arr[i], arr[j]);\\n        }\\n    }\\n    void check(vector<int> &arr, string &t) {\\n        check_perm_rec(arr, 0, arr.size(), t);\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        string t;\\n        check(arr, t);\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941043,
                "title": "simple-c-solution-using-backtracking-and-permutation-beats-100-of-user-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFinding all the permutation of the string that can make a valid time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDiskard the time that is not in the range of the 24 hr and 60min.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid permute(vector<int>&a, int l, int r,int &ans)\\n{\\n    if (l == r)\\n        {\\n            int hr=10*a[0]+a[1];\\n            int min=10*a[2]+a[3];\\n            if(hr<24 and min<60)\\n            {\\n                ans=max(ans,hr*60+min);\\n            }\\n        }\\n        for (int i = l; i <= r; i++) {\\n            swap(a[l], a[i]);\\n            permute(a, l + 1, r,ans);\\n            swap(a[l], a[i]);\\n        }\\n    }\\n\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=-1;\\n        permute(arr,0,n-1,ans);\\n        if(ans<0)return \"\";\\n        int hr=ans/60,min=ans%60;\\n        return to_string(hr/10)+to_string(hr%10)+\":\"+to_string(min/10)+to_string(min%10);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid permute(vector<int>&a, int l, int r,int &ans)\\n{\\n    if (l == r)\\n        {\\n            int hr=10*a[0]+a[1];\\n            int min=10*a[2]+a[3];\\n            if(hr<24 and min<60)\\n            {\\n                ans=max(ans,hr*60+min);\\n            }\\n        }\\n        for (int i = l; i <= r; i++) {\\n            swap(a[l], a[i]);\\n            permute(a, l + 1, r,ans);\\n            swap(a[l], a[i]);\\n        }\\n    }\\n\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=-1;\\n        permute(arr,0,n-1,ans);\\n        if(ans<0)return \"\";\\n        int hr=ans/60,min=ans%60;\\n        return to_string(hr/10)+to_string(hr%10)+\":\"+to_string(min/10)+to_string(min%10);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936462,
                "title": "typescript-there-2-possibility-2-0-3-0-5-0-9-and-0-1-0-9-0-5-0-9-no-permutations",
                "content": "# Intuition\\nThere 2 possible \"independent\" formats that we need to check\\n[2][0-3]:[0-5][0-9] and [0-1][0-9]:[0-5][0-9]. We need to check both because one of them might not work while another provides solution. And we can not be sure that one of them is bigger because we impose [0-3] second hour digit limit even in cases when first hour is in range [0-1]. There were 2 options either for 1 format create dependency so if we have first hour digit [0-1] don\\'t impose [0-3] limit on 2nd hour digit or just calculate 2 formats independently and compare them. I chose 2nd option as I think it\\'s easier to understand. \\n*Side node: permutations feel for me as a brute force solution. I don\\'t understand why we need to try all possible options when it\\'s not necessary.*\\n# Approach\\n1. Calculate 2 variants for 2 possible formats [2][0-3]:[0-5][0-9] and [0-1][0-9]:[0-5][0-9] choosing maximum digit for each position\\n2. If both formats work choose winner by comparing them in minutes, if only one works choose it.\\n3. Format the winner.\\n\\n# Complexity\\n- Time complexity:\\nFor each digit we select max from the rest it\\'s $$O(n)$$ so in total  $$O(n^2)$$, ignoring the fact that we do it 2 times. Comparing digits is also $$O(n)$$. Considering $$n == 4$$ of cause in practive it\\'s $$O(1)$$\\n\\n- Space complexity:\\n`leftDigits` gives us $$O(n)$$\\n\\n# Code\\n```\\nfunction largestTimeFromDigits(arr: number[]): string {\\n    function getTimeDigits(limits: number[]): number[] | undefined {\\n        let leftDigits = Array.from(arr)\\n        let resultDigits = []\\n        // select max digit for each position according limit variant\\n        for (let currentDigitLimit of limits) {\\n            let currentDigitCandidates = leftDigits.filter(x =>\\n                x <= currentDigitLimit && x >= 0\\n            )\\n            if (currentDigitCandidates.length === 0) {\\n                return undefined\\n            }\\n\\n            let currentDigit = Math.max(...currentDigitCandidates)\\n            resultDigits.push(currentDigit)\\n            let currentDigitIndex = leftDigits.indexOf(currentDigit)\\n            // exlude used digit to not use it twice\\n            leftDigits = leftDigits.filter((_, ind) => ind !== currentDigitIndex)\\n        }\\n        return resultDigits\\n    }\\n\\n    // 2 independent possible digits limits, if we try them both and compare we will get the winner\\n    let limitsVariantA = [2, 3, 5, 9]\\n    let limitsVariantB = [1, 9, 5, 9]\\n\\n    let variantA = getTimeDigits(limitsVariantA)\\n    let variantB = getTimeDigits(limitsVariantB)\\n\\n    let toMinutes = (digits: number[]) =>\\n        (digits[0] * 10 + digits[1]) * 60 + // hourse to minutes\\n        (digits[2] * 10 + digits[3])    // plus minutes\\n\\n    let winner = variantA || variantB; // any valid variant by default\\n\\n    if (variantA && variantB) {\\n        // if we have both valid variants we need to compare them\\n        winner = toMinutes(variantA) > toMinutes(variantB) ? variantA : variantB\\n    }\\n\\n    let format = (digits: number[] | undefined) =>\\n        digits ? `${digits[0]}${digits[1]}:${digits[2]}${digits[3]}` : \"\"\\n\\n    return format(winner)\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction largestTimeFromDigits(arr: number[]): string {\\n    function getTimeDigits(limits: number[]): number[] | undefined {\\n        let leftDigits = Array.from(arr)\\n        let resultDigits = []\\n        // select max digit for each position according limit variant\\n        for (let currentDigitLimit of limits) {\\n            let currentDigitCandidates = leftDigits.filter(x =>\\n                x <= currentDigitLimit && x >= 0\\n            )\\n            if (currentDigitCandidates.length === 0) {\\n                return undefined\\n            }\\n\\n            let currentDigit = Math.max(...currentDigitCandidates)\\n            resultDigits.push(currentDigit)\\n            let currentDigitIndex = leftDigits.indexOf(currentDigit)\\n            // exlude used digit to not use it twice\\n            leftDigits = leftDigits.filter((_, ind) => ind !== currentDigitIndex)\\n        }\\n        return resultDigits\\n    }\\n\\n    // 2 independent possible digits limits, if we try them both and compare we will get the winner\\n    let limitsVariantA = [2, 3, 5, 9]\\n    let limitsVariantB = [1, 9, 5, 9]\\n\\n    let variantA = getTimeDigits(limitsVariantA)\\n    let variantB = getTimeDigits(limitsVariantB)\\n\\n    let toMinutes = (digits: number[]) =>\\n        (digits[0] * 10 + digits[1]) * 60 + // hourse to minutes\\n        (digits[2] * 10 + digits[3])    // plus minutes\\n\\n    let winner = variantA || variantB; // any valid variant by default\\n\\n    if (variantA && variantB) {\\n        // if we have both valid variants we need to compare them\\n        winner = toMinutes(variantA) > toMinutes(variantB) ? variantA : variantB\\n    }\\n\\n    let format = (digits: number[] | undefined) =>\\n        digits ? `${digits[0]}${digits[1]}:${digits[2]}${digits[3]}` : \"\"\\n\\n    return format(winner)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3918553,
                "title": "c-solution-beats-100-in-runtime-and-90-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n\\n\\n        int hf = -1;\\n        int hs = -1;\\n        int mf = -1;\\n        int ms = -1;\\n\\n        int taken =-1;\\n        int taken2 = -1;\\n        int taken3 = -1;\\n\\n        int sixs = 0;\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(arr[x] >= 6)\\n                sixs++;\\n        }\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(sixs>1 && arr[x]==2)\\n                continue;\\n            if(arr[x]<=2)\\n            {\\n                if(hf<=arr[x])\\n                {\\n                    hf = arr[x];\\n                    taken = x;\\n                \\n                }\\n            }\\n           \\n        }\\n        \\n\\n        for(int x=0; x<arr.size();x++)\\n        {\\n           \\n            \\n            if(taken==x)\\n                continue;\\n            \\n             if(hf<2)\\n            {\\n                if(hs<=arr[x])\\n                {\\n                    hs = arr[x];\\n                    taken2 = x;\\n                }\\n            }\\n            else if(hf==2 && arr[x]<=3)\\n            {\\n                if(hs<=arr[x]){\\n                    hs = arr[x];\\n                    taken2 = x;\\n                }\\n            }\\n            \\n        }\\n\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(x==taken || x==taken2) continue;\\n\\n            if(arr[x]<6){\\n                \\n                if(mf<=arr[x]){\\n                mf = arr[x];\\n                taken3 = x;\\n                }\\n            }\\n            \\n        }\\n        \\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(taken!=x && taken2!=x && taken3!=x)\\n                ms = arr[x];\\n        }\\n     \\n        if(hf==-1 || hs ==-1 || mf ==-1 || ms == -1) return \"\";\\n        return  to_string(hf) + to_string(hs) + \\n        \\':\\' + to_string(mf) + to_string(ms);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n\\n\\n        int hf = -1;\\n        int hs = -1;\\n        int mf = -1;\\n        int ms = -1;\\n\\n        int taken =-1;\\n        int taken2 = -1;\\n        int taken3 = -1;\\n\\n        int sixs = 0;\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(arr[x] >= 6)\\n                sixs++;\\n        }\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(sixs>1 && arr[x]==2)\\n                continue;\\n            if(arr[x]<=2)\\n            {\\n                if(hf<=arr[x])\\n                {\\n                    hf = arr[x];\\n                    taken = x;\\n                \\n                }\\n            }\\n           \\n        }\\n        \\n\\n        for(int x=0; x<arr.size();x++)\\n        {\\n           \\n            \\n            if(taken==x)\\n                continue;\\n            \\n             if(hf<2)\\n            {\\n                if(hs<=arr[x])\\n                {\\n                    hs = arr[x];\\n                    taken2 = x;\\n                }\\n            }\\n            else if(hf==2 && arr[x]<=3)\\n            {\\n                if(hs<=arr[x]){\\n                    hs = arr[x];\\n                    taken2 = x;\\n                }\\n            }\\n            \\n        }\\n\\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(x==taken || x==taken2) continue;\\n\\n            if(arr[x]<6){\\n                \\n                if(mf<=arr[x]){\\n                mf = arr[x];\\n                taken3 = x;\\n                }\\n            }\\n            \\n        }\\n        \\n        for(int x=0;x<arr.size();x++)\\n        {\\n            if(taken!=x && taken2!=x && taken3!=x)\\n                ms = arr[x];\\n        }\\n     \\n        if(hf==-1 || hs ==-1 || mf ==-1 || ms == -1) return \"\";\\n        return  to_string(hf) + to_string(hs) + \\n        \\':\\' + to_string(mf) + to_string(ms);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861090,
                "title": "simple-verbose-python-solution",
                "content": "\\n# Complexity\\n- Time complexity: since len(arr) is a constant the time compexity of this slution is O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        \\n        hours = []\\n        # find all posible valid hour permutations in sorted order\\n        for i in range(len(arr)):\\n            for j in range(i + 1, len(arr)):\\n                hour = arr[i] * 10 + arr[j]\\n                if hour < 24:\\n                    hours.append((hour, i, j))\\n                hour = arr[j] * 10 + arr[i] \\n                if hour < 24:\\n                    hours.append((hour, j, i))\\n        hours = sorted(hours, reverse=True)\\n\\n        # find all possible valid minute permutations that go  with the \\n        # specific hour\\n        for hour, i, j in hours:\\n            \\n            for k in range(len(arr)):\\n                for l in range(k + 1, len(arr)):\\n                    if k != i and k != j and l != i and l != j:\\n                        minute1, minute2 = None, None\\n                        min = arr[k] * 10 + arr[l]\\n                        if min < 60:\\n                            minute1 = min\\n                        \\n                        min = arr[l] * 10 + arr[k]\\n                        if min < 60:\\n                            minute2 = min\\n                            \\n                        if  minute1 == None and minute2 == None:\\n                            continue\\n                        \\n                        if minute1 == None:\\n                            max_min = minute2\\n                        \\n                        elif minute2 == None:\\n                            max_min = minute1\\n                        else:\\n                            max_min = max(minute1, minute2)\\n \\n                        hour_str = f\"{hour}\" if hour > 9 else f\"0{hour}\"\\n                        min_str = f\"{max_min}\" if max_min > 9 else f\"0{max_min}\"\\n                        \\n                        return f\"{hour_str}:{min_str}\"\\n        return \"\"\\n                        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        \\n        hours = []\\n        # find all posible valid hour permutations in sorted order\\n        for i in range(len(arr)):\\n            for j in range(i + 1, len(arr)):\\n                hour = arr[i] * 10 + arr[j]\\n                if hour < 24:\\n                    hours.append((hour, i, j))\\n                hour = arr[j] * 10 + arr[i] \\n                if hour < 24:\\n                    hours.append((hour, j, i))\\n        hours = sorted(hours, reverse=True)\\n\\n        # find all possible valid minute permutations that go  with the \\n        # specific hour\\n        for hour, i, j in hours:\\n            \\n            for k in range(len(arr)):\\n                for l in range(k + 1, len(arr)):\\n                    if k != i and k != j and l != i and l != j:\\n                        minute1, minute2 = None, None\\n                        min = arr[k] * 10 + arr[l]\\n                        if min < 60:\\n                            minute1 = min\\n                        \\n                        min = arr[l] * 10 + arr[k]\\n                        if min < 60:\\n                            minute2 = min\\n                            \\n                        if  minute1 == None and minute2 == None:\\n                            continue\\n                        \\n                        if minute1 == None:\\n                            max_min = minute2\\n                        \\n                        elif minute2 == None:\\n                            max_min = minute1\\n                        else:\\n                            max_min = max(minute1, minute2)\\n \\n                        hour_str = f\"{hour}\" if hour > 9 else f\"0{hour}\"\\n                        min_str = f\"{max_min}\" if max_min > 9 else f\"0{max_min}\"\\n                        \\n                        return f\"{hour_str}:{min_str}\"\\n        return \"\"\\n                        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834863,
                "title": "steps-explained-succinct-java-solution-easy-to-understand",
                "content": "# Intuition\\nThere are two points to consider:\\n1. We already have the digits that make up the largest timestamp\\n2. We know the range of these numbers. That is the timestamp can range from 00:00 until 23:59. So the input must be a combination of these numbers\\n\\n# Approach\\n1. This is a brute force approach in which we try to get all possible combinations are match it against the input\\n2. We work our way in descending manner to get the largest match first.\\n3. We apply two for loops one for hour which begins at 23 and decrements by 1 and another inner for loop for minutes that begins at 59 and decrements by 1.\\n4. At each iteration we try to get the digits that make up that timestamp.\\n5. We do this by using division and modulus operations\\n6. Once obtained we sort this timestamp and compare against the input which is also sorted.\\n7. Return if match is found, else return \"\".\\n\\nThis is my first time posting a solution and I had a lot of help from the solutions already discussed. If you have any suggestions, corrections or inputs, they are welcome.\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        int h1=-1, h2=-1, m1=-1, m2=-1;\\n        Arrays.sort(arr);\\n        for(int h=23; h>=0; h--){\\n            for(int m=59; m>=0; m--){\\n                h1=h/10;\\n                h2=h%10;\\n                m1=m/10;\\n                m2=m%10;\\n\\n                int[] t = {h1,h2,m1,m2};\\n                Arrays.sort(t);\\n                if(Arrays.equals(arr, t)){\\n                    return h1+\"\"+h2+\":\"+m1+\"\"+m2;\\n                }\\n\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        int h1=-1, h2=-1, m1=-1, m2=-1;\\n        Arrays.sort(arr);\\n        for(int h=23; h>=0; h--){\\n            for(int m=59; m>=0; m--){\\n                h1=h/10;\\n                h2=h%10;\\n                m1=m/10;\\n                m2=m%10;\\n\\n                int[] t = {h1,h2,m1,m2};\\n                Arrays.sort(t);\\n                if(Arrays.equals(arr, t)){\\n                    return h1+\"\"+h2+\":\"+m1+\"\"+m2;\\n                }\\n\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820492,
                "title": "most-intuitive-approach",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$.\\n\\n- Space complexity: $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        time = []\\n\\n        for dig in (2, 1, 0) if sum(1 for dig in arr if dig > 5) < 2 else (1, 0):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n\\n        if len(time) < 1:\\n            return \\'\\'\\n        \\n        for dig in (3, 2, 1, 0) if time[0] == 2 else range(9, -1, -1):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n\\n        if len(time) < 2:\\n            return \\'\\'\\n        \\n        for dig in range(5, -1, -1):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n        \\n        if len(time) < 3:\\n            return \\'\\'\\n        \\n        time.append(arr[0])\\n\\n        return f\\'{time[0]}{time[1]}:{time[2]}{time[3]}\\'\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        time = []\\n\\n        for dig in (2, 1, 0) if sum(1 for dig in arr if dig > 5) < 2 else (1, 0):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n\\n        if len(time) < 1:\\n            return \\'\\'\\n        \\n        for dig in (3, 2, 1, 0) if time[0] == 2 else range(9, -1, -1):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n\\n        if len(time) < 2:\\n            return \\'\\'\\n        \\n        for dig in range(5, -1, -1):\\n            if dig in arr:\\n                time.append(dig)\\n                arr.remove(dig)\\n                break\\n        \\n        if len(time) < 3:\\n            return \\'\\'\\n        \\n        time.append(arr[0])\\n\\n        return f\\'{time[0]}{time[1]}:{time[2]}{time[3]}\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764677,
                "title": "recursion-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int cur, int c){\\n        if(c == 4){\\n            if(cur <= 2359 && cur % 100 < 60) {return cur;}\\n            return -1;\\n        }\\n        int ans = -1;\\n        for(int &i: nums){\\n            if(i <= 9){\\n                int tmp = i;\\n                i = 10;\\n                ans = max(ans, solve(nums, cur*10 + tmp, c + 1));\\n                i = tmp;\\n            }\\n        }\\n        return ans;\\n    }\\n    string largestTimeFromDigits(vector<int>& nums) {\\n        int num = solve(nums, 0, 0);\\n        if(num == -1) return \"\";\\n        if(num == 0) return \"00:00\";\\n        cout << num << endl;\\n        string str = to_string(num);\\n        while(str.size() < 4) str = \"0\" + str;\\n        return str.substr(0, 2) + \":\" + str.substr(2, 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums, int cur, int c){\\n        if(c == 4){\\n            if(cur <= 2359 && cur % 100 < 60) {return cur;}\\n            return -1;\\n        }\\n        int ans = -1;\\n        for(int &i: nums){\\n            if(i <= 9){\\n                int tmp = i;\\n                i = 10;\\n                ans = max(ans, solve(nums, cur*10 + tmp, c + 1));\\n                i = tmp;\\n            }\\n        }\\n        return ans;\\n    }\\n    string largestTimeFromDigits(vector<int>& nums) {\\n        int num = solve(nums, 0, 0);\\n        if(num == -1) return \"\";\\n        if(num == 0) return \"00:00\";\\n        cout << num << endl;\\n        string str = to_string(num);\\n        while(str.size() < 4) str = \"0\" + str;\\n        return str.substr(0, 2) + \":\" + str.substr(2, 2);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3759784,
                "title": "c-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvoid backtrack(int* hash, char *buf, int len, char *latest)\\n{\\n    if (len == 5) {\\n        if (latest[0] == 0) {\\n            strcpy(latest, buf);\\n        }\\n        else {\\n            if (latest[0] > buf[0]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[1] > buf[1]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[3] > buf[3]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[4] > buf[4]) { \\n                strcpy(latest, buf);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\n    if (len == 2) {\\n        buf[len] = \\':\\';\\n        backtrack(hash, buf, len + 1, latest);\\n    }\\n    else {\\n        for (int i = 0; i < 10; i++) {\\n\\n            if (hash[i]) {\\n\\n                if (len == 0) {\\n                    if (i >= 0 && i <= 2) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n                else if (len == 1) {\\n                    if (buf[len - 1] == \\'2\\') {\\n                        if (i >= 0 && i <= 3) {\\n                            buf[len] = i + \\'0\\';\\n                            hash[i]--;\\n                            backtrack(hash, buf, len + 1, latest);\\n                            hash[i]++;\\n                        }\\n                    }\\n                    else {\\n                        if (i >= 0 && i <= 9) {\\n                            buf[len] = i + \\'0\\';\\n                            hash[i]--;\\n                            backtrack(hash, buf, len + 1, latest);\\n                            hash[i]++;\\n                        }\\n                    }\\n\\n                }\\n                else if (len == 3) {\\n                    if (i >= 0 && i <= 5) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n                else if (len == 4) {\\n                    if (i >= 0 && i <= 9) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nchar * largestTimeFromDigits(int* arr, int arrSize){\\n    int hash[10] = {0};\\n    char buf[6] = {0};\\n    char *latest = (char *)calloc(1, sizeof(char) * 6);\\n    \\n    for (int i = 0; i < arrSize; i++) {\\n        hash[arr[i]]++;\\n    }\\n    \\n    backtrack(hash, buf, 0, latest);\\n    \\n    return latest;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Backtracking",
                    "Enumeration"
                ],
                "code": "```\\nvoid backtrack(int* hash, char *buf, int len, char *latest)\\n{\\n    if (len == 5) {\\n        if (latest[0] == 0) {\\n            strcpy(latest, buf);\\n        }\\n        else {\\n            if (latest[0] > buf[0]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[1] > buf[1]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[3] > buf[3]) {\\n                strcpy(latest, buf);\\n            }\\n            else if (latest[4] > buf[4]) { \\n                strcpy(latest, buf);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\n    if (len == 2) {\\n        buf[len] = \\':\\';\\n        backtrack(hash, buf, len + 1, latest);\\n    }\\n    else {\\n        for (int i = 0; i < 10; i++) {\\n\\n            if (hash[i]) {\\n\\n                if (len == 0) {\\n                    if (i >= 0 && i <= 2) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n                else if (len == 1) {\\n                    if (buf[len - 1] == \\'2\\') {\\n                        if (i >= 0 && i <= 3) {\\n                            buf[len] = i + \\'0\\';\\n                            hash[i]--;\\n                            backtrack(hash, buf, len + 1, latest);\\n                            hash[i]++;\\n                        }\\n                    }\\n                    else {\\n                        if (i >= 0 && i <= 9) {\\n                            buf[len] = i + \\'0\\';\\n                            hash[i]--;\\n                            backtrack(hash, buf, len + 1, latest);\\n                            hash[i]++;\\n                        }\\n                    }\\n\\n                }\\n                else if (len == 3) {\\n                    if (i >= 0 && i <= 5) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n                else if (len == 4) {\\n                    if (i >= 0 && i <= 9) {\\n                        buf[len] = i + \\'0\\';\\n                        hash[i]--;\\n                        backtrack(hash, buf, len + 1, latest);\\n                        hash[i]++;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nchar * largestTimeFromDigits(int* arr, int arrSize){\\n    int hash[10] = {0};\\n    char buf[6] = {0};\\n    char *latest = (char *)calloc(1, sizeof(char) * 6);\\n    \\n    for (int i = 0; i < arrSize; i++) {\\n        hash[arr[i]]++;\\n    }\\n    \\n    backtrack(hash, buf, 0, latest);\\n    \\n    return latest;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3746902,
                "title": "java-forming-permutations-via-backtracking",
                "content": "```\\nclass Solution {\\n    \\n    HashSet<String> seen = new HashSet<>();\\n    \\n    public String largestTimeFromDigits(int[] arr) {\\n        \\n        calculate(arr, 0);\\n        if(seen.isEmpty())\\n            return \"\";\\n        List<String> list = new ArrayList<>();\\n        list.addAll(seen);\\n        Collections.sort(list);\\n        // System.out.println(list);\\n        \\n        int index = list.size()-1;\\n        String s = list.get(index);\\n        s = s.substring(0,2) + \":\" +  s.substring(2,4);\\n        return s;\\n    }\\n    \\n    public void calculate(int[] arr, int index) {\\n        \\n        if(index==arr.length) {\\n            if(isValid(arr)) {\\n                StringBuilder sb = new StringBuilder();\\n                for(int i=0;i<arr.length;i++) {\\n                    sb.append(arr[i]);\\n                }\\n                seen.add(sb.toString());\\n                // System.out.println(sb.toString());\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<arr.length;i++) {\\n            swap(arr, index, i);\\n            calculate(arr, index+1);\\n            swap(arr, index, i);\\n        }  \\n    }\\n    \\n    public void swap(int[] arr, int i , int j) {\\n        int tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n    \\n    public boolean isValid(int[] arr) {\\n        if(arr[0]>2) return false;\\n        if(arr[0]>=2 && arr[1]>=4) return false;\\n        if(arr[2]>=6) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    \\n    HashSet<String> seen = new HashSet<>();\\n    \\n    public String largestTimeFromDigits(int[] arr) {\\n        \\n        calculate(arr, 0);\\n        if(seen.isEmpty())\\n            return \"\";\\n        List<String> list = new ArrayList<>();\\n        list.addAll(seen);\\n        Collections.sort(list);\\n        // System.out.println(list);\\n        \\n        int index = list.size()-1;\\n        String s = list.get(index);\\n        s = s.substring(0,2) + \":\" +  s.substring(2,4);\\n        return s;\\n    }\\n    \\n    public void calculate(int[] arr, int index) {\\n        \\n        if(index==arr.length) {\\n            if(isValid(arr)) {\\n                StringBuilder sb = new StringBuilder();\\n                for(int i=0;i<arr.length;i++) {\\n                    sb.append(arr[i]);\\n                }\\n                seen.add(sb.toString());\\n                // System.out.println(sb.toString());\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<arr.length;i++) {\\n            swap(arr, index, i);\\n            calculate(arr, index+1);\\n            swap(arr, index, i);\\n        }  \\n    }\\n    \\n    public void swap(int[] arr, int i , int j) {\\n        int tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n    \\n    public boolean isValid(int[] arr) {\\n        if(arr[0]>2) return false;\\n        if(arr[0]>=2 && arr[1]>=4) return false;\\n        if(arr[2]>=6) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687655,
                "title": "todays-ram",
                "content": "class Solution {\\n    public:\\n        \\n        string s=\"0000\";\\n        bool is=false;\\n        \\n        void solve(int i,vector<int> &arr,string now)\\n        {\\n            if(i==4)\\n            {\\n                if(now.substr(0,2)<=\"23\" && now.substr(2,2)<=\"59\" && (s==\"0000\" || s<now))\\n                {\\n                    is=true;\\n                    s=now;\\n                    return;\\n                }\\n                return;    \\n            }\\n            \\n            for(int j=0;j<4;j++)\\n            {\\n                if(now[j]==\\' \\')\\n                {\\n                    now[j]=(\\'0\\'+arr[i]);\\n                    solve(i+1,arr,now);\\n                    now[j]=\\' \\';\\n                }\\n            }\\n        }\\n            \\n        string largestTimeFromDigits(vector<int>& arr) \\n        {\\n            string now=\"    \"; \\n            solve(0,arr,now);\\n            if(is==false)\\n                return \"\";\\n            string res=s.substr(0,2);\\n            res+=\":\";\\n            res+=s.substr(2);\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        \\n        string s=\"0000\";\\n        bool is=false;\\n        \\n        void solve(int i,vector<int> &arr,string now)\\n        {\\n            if(i==4)\\n            {\\n                if(now.substr(0,2)<=\"23\" && now.substr(2,2)<=\"59\" && (s==\"0000\" || s<now))\\n                {\\n                    is=true;\\n                    s=now;\\n                    return;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3638784,
                "title": "simple-permutate-the-string-for-valid-times",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate all time permutations and discard non-valid solutions.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort array and convert it to a string.\\nTwo upper limits exist: 24:00 and for minutes 6;  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ ==> while will always take 4! iterations.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end()); // needed for permutations\\n \\n        string permutateTime = to_string(arr[0]) + to_string(arr[1]) + to_string(arr[2]) + to_string(arr[3]);\\n        \\n        string endTime = \"2400\";\\n        constexpr char minuteOverflow = \\'6\\'; \\n        \\n        string result = \"\";\\n        do{\\n            if( permutateTime < endTime and permutateTime[2] < minuteOverflow){\\n                result = max(permutateTime, result);\\n            }\\n        }while(next_permutation(permutateTime.begin(), permutateTime.end()));\\n \\n        return result.empty() ? \"\" : result.substr(0,2) + \":\" + result.substr(2,2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end()); // needed for permutations\\n \\n        string permutateTime = to_string(arr[0]) + to_string(arr[1]) + to_string(arr[2]) + to_string(arr[3]);\\n        \\n        string endTime = \"2400\";\\n        constexpr char minuteOverflow = \\'6\\'; \\n        \\n        string result = \"\";\\n        do{\\n            if( permutateTime < endTime and permutateTime[2] < minuteOverflow){\\n                result = max(permutateTime, result);\\n            }\\n        }while(next_permutation(permutateTime.begin(), permutateTime.end()));\\n \\n        return result.empty() ? \"\" : result.substr(0,2) + \":\" + result.substr(2,2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632821,
                "title": "try-all-and-check-for-the-latest",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) \\n    {\\n       //the length of the string is 5\\n        //hh:mm\\n        \\n        //00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 (24)\\n        //00 -> 59 (60)\\n        //24 * 60 = 1440\\n\\n        string str = \"??:??\";\\n        //we need to fill the string str\\n\\n        int idx = 0;\\n        string ans=\"\";\\n        int n = str.length();\\n        fun(arr,str,idx,ans,n);\\n        return ans;\\n    }\\n    bool isValid(string str)\\n    {\\n        int hrs = 0;\\n        hrs = (hrs*10) + (str[0] - \\'0\\');\\n        hrs = (hrs*10) + (str[1] - \\'0\\');\\n\\n        if(hrs < 0 or hrs >= 24) return false;\\n\\n        int mins = 0;\\n        mins = (mins*10) + (str[3] - \\'0\\');\\n        mins = (mins*10) + (str[4] - \\'0\\');\\n\\n        if(mins < 0 or mins >= 60) return false;\\n\\n        return true;\\n    }\\n    bool isLatest(string &str , string &ans)\\n    {\\n        if(ans.length() == 0)\\n        return true;\\n\\n        int currhrs = 0;\\n        int prvhrs = 0;\\n\\n        currhrs = (currhrs*10) + (str[0] - \\'0\\');\\n        currhrs = (currhrs*10) + (str[1] - \\'0\\');\\n  \\n     \\n        prvhrs = (prvhrs*10) + (ans[0] - \\'0\\');\\n        prvhrs = (prvhrs*10) + (ans[1] - \\'0\\');\\n\\n        //if(currhrs == 0 and prvhrs == 1) cout<<\"hello\"<<endl;\\n        if(currhrs > prvhrs) return true;\\n        else if(currhrs < prvhrs) return false;\\n\\n        int currmins = 0;\\n        int prvmins = 0;\\n\\n        currmins = (currmins*10) + (str[3] - \\'0\\');\\n        currmins = (currmins*10) + (str[4] - \\'0\\');\\n\\n        prvmins = (prvmins*10) + (ans[3] - \\'0\\');\\n        prvmins = (prvmins*10) + (ans[4] - \\'0\\');\\n\\n        if(currmins > prvmins) return true;\\n\\n       // cout<<str<<\" \"<<ans<<endl;\\n        return false;\\n        \\n    }\\n    void fun(vector<int>&arr,string &str,int idx,string &ans,int &n)\\n    {\\n        if(idx >= n)\\n        {\\n            if(isValid(str) == true and isLatest(str,ans) == true)\\n            {\\n                ans = str;\\n            }\\n            //cout<<\"ans = \"<<ans<<endl;\\n            return;\\n        }\\n        if(str[idx] == \\'?\\')\\n        {\\n             for(int i=0;i<arr.size();i++)\\n             {\\n                 int val = arr[i];\\n                 if(arr[i] != -1)\\n                 {\\n                   arr[i] = -1;\\n                   str[idx] = char(val +\\' 0\\');\\n                   fun(arr,str,idx+1,ans,n);\\n                   str[idx] = \\'?\\';\\n                   arr[i] = val;\\n                }\\n             }\\n        }\\n        else if(str[idx] != \\'?\\')   //:\\n        {\\n            fun(arr,str,idx+1,ans,n);\\n        }\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) \\n    {\\n       //the length of the string is 5\\n        //hh:mm\\n        \\n        //00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 (24)\\n        //00 -> 59 (60)\\n        //24 * 60 = 1440\\n\\n        string str = \"??:??\";\\n        //we need to fill the string str\\n\\n        int idx = 0;\\n        string ans=\"\";\\n        int n = str.length();\\n        fun(arr,str,idx,ans,n);\\n        return ans;\\n    }\\n    bool isValid(string str)\\n    {\\n        int hrs = 0;\\n        hrs = (hrs*10) + (str[0] - \\'0\\');\\n        hrs = (hrs*10) + (str[1] - \\'0\\');\\n\\n        if(hrs < 0 or hrs >= 24) return false;\\n\\n        int mins = 0;\\n        mins = (mins*10) + (str[3] - \\'0\\');\\n        mins = (mins*10) + (str[4] - \\'0\\');\\n\\n        if(mins < 0 or mins >= 60) return false;\\n\\n        return true;\\n    }\\n    bool isLatest(string &str , string &ans)\\n    {\\n        if(ans.length() == 0)\\n        return true;\\n\\n        int currhrs = 0;\\n        int prvhrs = 0;\\n\\n        currhrs = (currhrs*10) + (str[0] - \\'0\\');\\n        currhrs = (currhrs*10) + (str[1] - \\'0\\');\\n  \\n     \\n        prvhrs = (prvhrs*10) + (ans[0] - \\'0\\');\\n        prvhrs = (prvhrs*10) + (ans[1] - \\'0\\');\\n\\n        //if(currhrs == 0 and prvhrs == 1) cout<<\"hello\"<<endl;\\n        if(currhrs > prvhrs) return true;\\n        else if(currhrs < prvhrs) return false;\\n\\n        int currmins = 0;\\n        int prvmins = 0;\\n\\n        currmins = (currmins*10) + (str[3] - \\'0\\');\\n        currmins = (currmins*10) + (str[4] - \\'0\\');\\n\\n        prvmins = (prvmins*10) + (ans[3] - \\'0\\');\\n        prvmins = (prvmins*10) + (ans[4] - \\'0\\');\\n\\n        if(currmins > prvmins) return true;\\n\\n       // cout<<str<<\" \"<<ans<<endl;\\n        return false;\\n        \\n    }\\n    void fun(vector<int>&arr,string &str,int idx,string &ans,int &n)\\n    {\\n        if(idx >= n)\\n        {\\n            if(isValid(str) == true and isLatest(str,ans) == true)\\n            {\\n                ans = str;\\n            }\\n            //cout<<\"ans = \"<<ans<<endl;\\n            return;\\n        }\\n        if(str[idx] == \\'?\\')\\n        {\\n             for(int i=0;i<arr.size();i++)\\n             {\\n                 int val = arr[i];\\n                 if(arr[i] != -1)\\n                 {\\n                   arr[i] = -1;\\n                   str[idx] = char(val +\\' 0\\');\\n                   fun(arr,str,idx+1,ans,n);\\n                   str[idx] = \\'?\\';\\n                   arr[i] = val;\\n                }\\n             }\\n        }\\n        else if(str[idx] != \\'?\\')   //:\\n        {\\n            fun(arr,str,idx+1,ans,n);\\n        }\\n    } \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3576635,
                "title": "python-brute-force-approach-using-basic-data-structure",
                "content": "# Intuition\\nSolving with basic data structure\\n\\n# Approach\\nCreate a hash table to keep all possible combinations and then find all possible or valid time and keep them in list and then find the latest time from the list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n   def largestTimeFromDigits(self, arr):\\n     \\n        nums = {}\\n        for i in range(4):\\n            for j in range(4):\\n                if i != j:\\n                    num = arr[i]*10 + arr[j]\\n                    nums[tuple([i,j])] = num\\n\\n        possible_ans = []\\n        for indx_hh in nums:\\n            if nums[indx_hh] < 24:\\n                for indx_mm in nums:\\n                    # ensure one digit used only once\\n                    if len(set(indx_mm + indx_hh)) < 4:\\n                        continue\\n                    if nums[indx_mm] < 60:\\n                        possible_ans.append([nums[indx_hh], nums[indx_mm]])\\n        if possible_ans:\\n            possible_ans.sort()\\n            hh, mm  = possible_ans[-1:][0]\\n            # print (final)\\n            # hh, mm  = final[0], final[1]\\n            return f\"{hh:02d}:{mm:02d}\"\\n   \\n        return \"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n   def largestTimeFromDigits(self, arr):\\n     \\n        nums = {}\\n        for i in range(4):\\n            for j in range(4):\\n                if i != j:\\n                    num = arr[i]*10 + arr[j]\\n                    nums[tuple([i,j])] = num\\n\\n        possible_ans = []\\n        for indx_hh in nums:\\n            if nums[indx_hh] < 24:\\n                for indx_mm in nums:\\n                    # ensure one digit used only once\\n                    if len(set(indx_mm + indx_hh)) < 4:\\n                        continue\\n                    if nums[indx_mm] < 60:\\n                        possible_ans.append([nums[indx_hh], nums[indx_mm]])\\n        if possible_ans:\\n            possible_ans.sort()\\n            hh, mm  = possible_ans[-1:][0]\\n            # print (final)\\n            # hh, mm  = final[0], final[1]\\n            return f\"{hh:02d}:{mm:02d}\"\\n   \\n        return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556991,
                "title": "python3-permutations",
                "content": "\\n```\\nclass Solution:\\n    def checkTime(self, t):\\n        if t[0] > 2:\\n            return False\\n        if t[0] == 2 and t[1] > 3:\\n            return False\\n        if t[2] > 5:\\n            return False\\n        \\n        return True\\n            \\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        ret = (-1,-1,-1,-1)\\n        for t in itertools.permutations(arr):\\n            if self.checkTime(t) and (t > ret):\\n                ret = t\\n        \\n        return \"\" if ret == (-1,-1,-1,-1) else \"{}{}:{}{}\".format(ret[0],ret[1],ret[2],ret[3])\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkTime(self, t):\\n        if t[0] > 2:\\n            return False\\n        if t[0] == 2 and t[1] > 3:\\n            return False\\n        if t[2] > 5:\\n            return False\\n        \\n        return True\\n            \\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        ret = (-1,-1,-1,-1)\\n        for t in itertools.permutations(arr):\\n            if self.checkTime(t) and (t > ret):\\n                ret = t\\n        \\n        return \"\" if ret == (-1,-1,-1,-1) else \"{}{}:{}{}\".format(ret[0],ret[1],ret[2],ret[3])\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542995,
                "title": "js-solution-using-recursion-to-generate-all-possible-permutations",
                "content": "```\\nvar largestTimeFromDigits = function(arr) {\\n    \\n    //variables to store max hour and max minute\\n    let maxh;\\n    let maxm;\\n  \\n    //finds max hour and min by checking all possible permuations\\n    function perms(digits, selec){\\n        \\n        //stop condition if no more digits to choose from\\n        if(digits.length === 0){\\n            \\n            //stringify hour and minute separately\\n            let h = [selec[0], selec[1]].join(\"\")\\n            let m = [selec[2], selec[3]].join(\"\")\\n            \\n            //check if hour and minute are valid and within range\\n            if(h <= 23 && m <= 59){\\n                \\n                //store hour and minute if first valid combination\\n                if(!maxh){\\n                    maxh = h\\n                    maxm = m\\n                }\\n                //check if hour is greater than current max hour\\n                else if(h > maxh){\\n                    maxh = h;\\n                    maxm = m\\n                }\\n                //if hour is same as current max hour, check if minute is greater than current max minute\\n                else if(h === maxh && m > maxm){\\n                    maxh = h;\\n                    maxm = m\\n                }\\n            }\\n            \\n            return;\\n        }\\n        \\n        for(let i=0;i<digits.length;i++){\\n            \\n            //choose digit\\n            selec.push(digits[i])\\n            \\n            //filter digit out of array \\n            let rest = digits.filter((digit,index) => index !== i);\\n            \\n            //generate permutations with rest of digits\\n            perms(rest,selec)\\n            \\n            //pop off last selected digit\\n            selec.pop()\\n        }\\n    }\\n    \\n    //generate permuations and find max hour and min\\n    perms(arr, [])\\n    \\n    // check if max hour was ever set, and if so return max 24 hour time, else return empty string\\n    return maxh ? `${maxh}:${maxm}`: \"\"\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar largestTimeFromDigits = function(arr) {\\n    \\n    //variables to store max hour and max minute\\n    let maxh;\\n    let maxm;\\n  \\n    //finds max hour and min by checking all possible permuations\\n    function perms(digits, selec){\\n        \\n        //stop condition if no more digits to choose from\\n        if(digits.length === 0){\\n            \\n            //stringify hour and minute separately\\n            let h = [selec[0], selec[1]].join(\"\")\\n            let m = [selec[2], selec[3]].join(\"\")\\n            \\n            //check if hour and minute are valid and within range\\n            if(h <= 23 && m <= 59){\\n                \\n                //store hour and minute if first valid combination\\n                if(!maxh){\\n                    maxh = h\\n                    maxm = m\\n                }\\n                //check if hour is greater than current max hour\\n                else if(h > maxh){\\n                    maxh = h;\\n                    maxm = m\\n                }\\n                //if hour is same as current max hour, check if minute is greater than current max minute\\n                else if(h === maxh && m > maxm){\\n                    maxh = h;\\n                    maxm = m\\n                }\\n            }\\n            \\n            return;\\n        }\\n        \\n        for(let i=0;i<digits.length;i++){\\n            \\n            //choose digit\\n            selec.push(digits[i])\\n            \\n            //filter digit out of array \\n            let rest = digits.filter((digit,index) => index !== i);\\n            \\n            //generate permutations with rest of digits\\n            perms(rest,selec)\\n            \\n            //pop off last selected digit\\n            selec.pop()\\n        }\\n    }\\n    \\n    //generate permuations and find max hour and min\\n    perms(arr, [])\\n    \\n    // check if max hour was ever set, and if so return max 24 hour time, else return empty string\\n    return maxh ? `${maxh}:${maxm}`: \"\"\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526827,
                "title": "simple-java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        Arrays.sort(arr); \\n        String result = \"\";\\n\\n        for (int h = 23; h >= 0; h--) {\\n            for (int m = 59; m >= 0; m--) {\\n                int[] digits = { h / 10, h % 10, m / 10, m % 10 };\\n                Arrays.sort(digits); \\n\\n                if (Arrays.equals(arr, digits)) {\\n                    result = String.format(\"%02d:%02d\", h, m);\\n                    return result;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    } \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestTimeFromDigits(int[] arr) {\\n        Arrays.sort(arr); \\n        String result = \"\";\\n\\n        for (int h = 23; h >= 0; h--) {\\n            for (int m = 59; m >= 0; m--) {\\n                int[] digits = { h / 10, h % 10, m / 10, m % 10 };\\n                Arrays.sort(digits); \\n\\n                if (Arrays.equals(arr, digits)) {\\n                    result = String.format(\"%02d:%02d\", h, m);\\n                    return result;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    } \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497997,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        result = -1\\n        n = len(arr)\\n        def compare():\\n            nonlocal result\\n            hours = arr[0] * 10 + arr[1]\\n            minutes = arr[2] * 10 + arr[3]\\n            if hours < 24 and minutes < 60:\\n                result = max(result, hours * 60 + minutes)\\n\\n        def backtrack(i):\\n            if i == n:\\n                compare()\\n            for j in range(i, n):\\n                arr[i], arr[j] = arr[j], arr[i]\\n                backtrack(i + 1)\\n                arr[i], arr[j] = arr[j], arr[i]\\n\\n        backtrack(0)\\n        if result == -1:\\n            return \"\"\\n        else:\\n            hours = result // 60\\n            minutes = result % 60\\n            return \"{:02d}:{:02d}\".format(hours, minutes)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        result = -1\\n        n = len(arr)\\n        def compare():\\n            nonlocal result\\n            hours = arr[0] * 10 + arr[1]\\n            minutes = arr[2] * 10 + arr[3]\\n            if hours < 24 and minutes < 60:\\n                result = max(result, hours * 60 + minutes)\\n\\n        def backtrack(i):\\n            if i == n:\\n                compare()\\n            for j in range(i, n):\\n                arr[i], arr[j] = arr[j], arr[i]\\n                backtrack(i + 1)\\n                arr[i], arr[j] = arr[j], arr[i]\\n\\n        backtrack(0)\\n        if result == -1:\\n            return \"\"\\n        else:\\n            hours = result // 60\\n            minutes = result % 60\\n            return \"{:02d}:{:02d}\".format(hours, minutes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434292,
                "title": "c-simple-solution-easy-to-understand-solution-with-steps",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(24 * 60 * 4!),\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        string time;\\n        do {\\n            int hours = arr[0] * 10 + arr[1]; // compute the hours from the first two digits\\n            int minutes = arr[2] * 10 + arr[3]; // compute the minutes from the last two digits\\n            if(hours < 24 && minutes <60){ // check if the time is valid\\n                time = (hours < 10) ? \"0\" : \"\";\\n                time += to_string(hours); \\n                time += \":\";\\n                time += (minutes < 10) ? \"0\" : \"\";\\n                time += to_string(minutes); \\n            }\\n        } while(next_permutation(arr.begin(),arr.end())); // generate all possible permutations of the array\\n        return time;  // return the latest valid time\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        string time;\\n        do {\\n            int hours = arr[0] * 10 + arr[1]; // compute the hours from the first two digits\\n            int minutes = arr[2] * 10 + arr[3]; // compute the minutes from the last two digits\\n            if(hours < 24 && minutes <60){ // check if the time is valid\\n                time = (hours < 10) ? \"0\" : \"\";\\n                time += to_string(hours); \\n                time += \":\";\\n                time += (minutes < 10) ? \"0\" : \"\";\\n                time += to_string(minutes); \\n            }\\n        } while(next_permutation(arr.begin(),arr.end())); // generate all possible permutations of the array\\n        return time;  // return the latest valid time\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417786,
                "title": "python-simple-looping",
                "content": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        res = [0] * 5\\n        c = Counter(arr)\\n        great5 = 0\\n        for key in c:\\n            if key > 5:\\n                great5 += c[key]\\n                \\n        #set the size of the ranges for each position\\n        cycl = {0:3, 1:4, 2:0,3:6,4:10}\\n        \\n        #O(1)\\n        for i in range(5):\\n            #spacer\\n            if i == 2:\\n                continue\\n            assigned = False\\n            \\n            #edge case\\n            #we were allowed to take 2 so fill the second slot in with the largest number we have remaining\\n            if i == 1 and int(res[0]) < 2:\\n                #4 at most\\n                mx = max(c)\\n                res[i] = str(mx)\\n                c[mx] -=1\\n                if c[mx] == 0:\\n                    del c[mx]\\n                continue\\n                \\n            #try all number ranges for the given postion and take the largest\\n            for j in range(cycl[i] -1,-1,-1):\\n                #edge case\\n                #if there are more than 2 numbers greater than 5 in the list than we cant take 2 as the first number since we will need it in the second position\\n                if i == 0 and j == 2 and great5 >= 2:\\n                    continue\\n                \\n                #if we have this number remaining use it and remove it from our dict\\n                if j in c:\\n                    assigned = True\\n                    res[i] = str(j)\\n                    c[j] -=1\\n                    if c[j] == 0:\\n                        del c[j]\\n                    break\\n            \\n            #we could not assign this position\\n            if not assigned:\\n                return \"\"\\n        \\n        res[2] = \":\"\\n        return \\'\\'.join(res)\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        \\n        res = [0] * 5\\n        c = Counter(arr)\\n        great5 = 0\\n        for key in c:\\n            if key > 5:\\n                great5 += c[key]\\n                \\n        #set the size of the ranges for each position\\n        cycl = {0:3, 1:4, 2:0,3:6,4:10}",
                "codeTag": "Java"
            },
            {
                "id": 3377329,
                "title": "c-easy-to-understand-solution-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int n=arr.size();\\n        string hr=\"\",min=\"\";\\n        vector<string> times;\\n        for (int i=0;i<4;i++) {\\n            for (int j=0;j<4;j++) {\\n                if (j!=i) {\\n                    hr += to_string(arr[i]);\\n                    hr += to_string(arr[j]);\\n                    for (int k=0;k<4;k++) {\\n                        if (k!=i && k!=j) {\\n                            min += to_string(arr[k]);\\n                            for (int l=0;l<4;l++) {\\n                                if (l!=i && l!=j && l!=k) {\\n                                    min += to_string(arr[l]);\\n                                    times.push_back(hr+\":\"+min);\\n                                }\\n                            }\\n                        }\\n                        min=\"\";\\n                    }\\n                }\\n                hr=\"\";\\n            }\\n        }\\n        // sort in descending order\\n        sort(times.begin(),times.end(),[](const string& a,const string& b) {\\n            if (stoi(a.substr(0,2)) > stoi(b.substr(0,2))) {\\n                return true;\\n            }else if (stoi(a.substr(0,2)) < stoi(b.substr(0,2))) {\\n                return false;\\n            }else {\\n                if (stoi(a.substr(3,2)) > stoi(b.substr(3,2))) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        });\\n        for (int i=0;i<24;i++) {\\n            if (stoi(times[i].substr(0,2)) <= 23 && stoi(times[i].substr(3,2)) <= 59) {\\n                return times[i];\\n            } \\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        int n=arr.size();\\n        string hr=\"\",min=\"\";\\n        vector<string> times;\\n        for (int i=0;i<4;i++) {\\n            for (int j=0;j<4;j++) {\\n                if (j!=i) {\\n                    hr += to_string(arr[i]);\\n                    hr += to_string(arr[j]);\\n                    for (int k=0;k<4;k++) {\\n                        if (k!=i && k!=j) {\\n                            min += to_string(arr[k]);\\n                            for (int l=0;l<4;l++) {\\n                                if (l!=i && l!=j && l!=k) {\\n                                    min += to_string(arr[l]);\\n                                    times.push_back(hr+\":\"+min);\\n                                }\\n                            }\\n                        }\\n                        min=\"\";\\n                    }\\n                }\\n                hr=\"\";\\n            }\\n        }\\n        // sort in descending order\\n        sort(times.begin(),times.end(),[](const string& a,const string& b) {\\n            if (stoi(a.substr(0,2)) > stoi(b.substr(0,2))) {\\n                return true;\\n            }else if (stoi(a.substr(0,2)) < stoi(b.substr(0,2))) {\\n                return false;\\n            }else {\\n                if (stoi(a.substr(3,2)) > stoi(b.substr(3,2))) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        });\\n        for (int i=0;i<24;i++) {\\n            if (stoi(times[i].substr(0,2)) <= 23 && stoi(times[i].substr(3,2)) <= 59) {\\n                return times[i];\\n            } \\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372155,
                "title": "python-backtracking-no-library-functions",
                "content": "# Intuition\\nThis seemed like a backtracking problem because we want to greedily assign the largest digits first and then gradually try lower options if that doesn\\'t lead to a solution.\\n\\n# Approach\\nWe keep a stack for the current solution in `sol` and we explore at most 4 levels (one for each digit spot). Custom logic for the maximum digit of each level.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where $$n$$ is the length of the sought solution (in this case, $$4$$)\\n\\n- Space complexity: $$O(n)$$, where $$n$$ is the length of the sought solution (in this case, $$4$$)\\n\\n# Code\\n```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        arr,sol=Counter(arr),[]\\n        def backtrack(l: int):\\n            if l==0: maxdigit=2\\n            elif l==1: maxdigit=3 if sol[0]==2 else 9\\n            elif l==2: maxdigit=5\\n            elif l==3: maxdigit=9\\n            else: return f\"{sol[0]}{sol[1]}:{sol[2]}{sol[3]}\"\\n            for o in list(range(maxdigit,-1,-1)):\\n                if o in arr and arr[o]>0:\\n                    arr[o]-=1\\n                    sol.append(o)\\n                    res=backtrack(l+1)\\n                    if res!=\"\": return res\\n                    arr[o]+=1\\n                    sol.pop()\\n            return \"\"\\n        return backtrack(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\\n        arr,sol=Counter(arr),[]\\n        def backtrack(l: int):\\n            if l==0: maxdigit=2\\n            elif l==1: maxdigit=3 if sol[0]==2 else 9\\n            elif l==2: maxdigit=5\\n            elif l==3: maxdigit=9\\n            else: return f\"{sol[0]}{sol[1]}:{sol[2]}{sol[3]}\"\\n            for o in list(range(maxdigit,-1,-1)):\\n                if o in arr and arr[o]>0:\\n                    arr[o]-=1\\n                    sol.append(o)\\n                    res=backtrack(l+1)\\n                    if res!=\"\": return res\\n                    arr[o]+=1\\n                    sol.pop()\\n            return \"\"\\n        return backtrack(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367607,
                "title": "java-solution-permutation",
                "content": "# Code\\n```\\nclass Solution {\\n    int time = 0;\\n    int maxTime = Integer.MIN_VALUE;\\n    String result  = \"\";\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        int n = arr.length;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i < n; i++){\\n            sb.append(String.valueOf(arr[i]));\\n        }\\n        \\n        getPermutations(\"\",sb.toString());\\n        \\n        return result == \"\"\\n                ? \"\" \\n                : result.substring(0,2) + \":\" + result.substring(2);\\n    }\\n\\n    public void getPermutations(String prefix, String str){\\n        int n = str.length();\\n        if(n == 0 && prefix.charAt(0) - \\'0\\' < 3 && prefix.charAt(2) - \\'0\\' < 6 \\n                && !(prefix.charAt(0)- \\'0\\' == 2 && prefix.charAt(1) - \\'0\\' > 3)){\\n                    \\n            time = (Integer.valueOf(prefix.substring(0,2))*60) + Integer.valueOf(prefix.substring(2));\\n            if(time > maxTime){\\n                maxTime = time;\\n                result = prefix;\\n            }\\n        }else{\\n            for(int i = 0; i < n; i++){\\n                getPermutations(prefix+str.charAt(i), str.substring(0,i)+str.substring(i+1));\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int time = 0;\\n    int maxTime = Integer.MIN_VALUE;\\n    String result  = \"\";\\n\\n    public String largestTimeFromDigits(int[] arr) {\\n        int n = arr.length;\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i < n; i++){\\n            sb.append(String.valueOf(arr[i]));\\n        }\\n        \\n        getPermutations(\"\",sb.toString());\\n        \\n        return result == \"\"\\n                ? \"\" \\n                : result.substring(0,2) + \":\" + result.substring(2);\\n    }\\n\\n    public void getPermutations(String prefix, String str){\\n        int n = str.length();\\n        if(n == 0 && prefix.charAt(0) - \\'0\\' < 3 && prefix.charAt(2) - \\'0\\' < 6 \\n                && !(prefix.charAt(0)- \\'0\\' == 2 && prefix.charAt(1) - \\'0\\' > 3)){\\n                    \\n            time = (Integer.valueOf(prefix.substring(0,2))*60) + Integer.valueOf(prefix.substring(2));\\n            if(time > maxTime){\\n                maxTime = time;\\n                result = prefix;\\n            }\\n        }else{\\n            for(int i = 0; i < n; i++){\\n                getPermutations(prefix+str.charAt(i), str.substring(0,i)+str.substring(i+1));\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348920,
                "title": "recursion-permutation-of-string-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public void helper(String s,TreeSet<String>set,String t){\\n        if(t.length()==4){\\n            set.add(t);\\n            return;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            String r = s.substring(0,i)+s.substring(i+1);\\n            helper(r,set,t+c);\\n        }\\n    }\\n    public String largestTimeFromDigits(int[] arr) {\\n        Arrays.sort(arr);\\n        String s=\"\";\\n        for(int i=0;i<4;i++) s+=Integer.toString(arr[i]);\\n        TreeSet<String> set = new TreeSet<>();\\n        helper(s,set,\"\");\\n        TreeSet<String> seter = new TreeSet<>();\\n        for(String x:set){\\n            if(x.substring(0,2).compareTo(\"24\")<0 && x.substring(2).compareTo(\"60\")<0)\\n            seter.add(x);\\n        }\\n        if(seter.size()==0) return \"\";\\n        String r = seter.last().substring(0,2)+\":\"+seter.last().substring(2);\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\n    public void helper(String s,TreeSet<String>set,String t){\\n        if(t.length()==4){\\n            set.add(t);\\n            return;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            String r = s.substring(0,i)+s.substring(i+1);\\n            helper(r,set,t+c);\\n        }\\n    }\\n    public String largestTimeFromDigits(int[] arr) {\\n        Arrays.sort(arr);\\n        String s=\"\";\\n        for(int i=0;i<4;i++) s+=Integer.toString(arr[i]);\\n        TreeSet<String> set = new TreeSet<>();\\n        helper(s,set,\"\");\\n        TreeSet<String> seter = new TreeSet<>();\\n        for(String x:set){\\n            if(x.substring(0,2).compareTo(\"24\")<0 && x.substring(2).compareTo(\"60\")<0)\\n            seter.add(x);\\n        }\\n        if(seter.size()==0) return \"\";\\n        String r = seter.last().substring(0,2)+\":\"+seter.last().substring(2);\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346672,
                "title": "simple-typescript-javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(arr) {\\n    var result;\\n    for(var i =0; i<4; i++){\\n        for (var j=0; j<4 ; j++){\\n            for (var k =0; k<4; k++){\\n                if(i==j || j==k || k==i)\\n                    continue;\\n                var hh = arr[i].toString()+arr[j].toString();\\n                var mm = arr[k].toString()+arr[6-i-j-k].toString();\\n                var _time = hh+\":\"+mm;\\n                if(hh<\"24\" && mm<\"60\" && (_time>result || result==undefined))\\n                    result = _time;\\n            }\\n        }\\n    }\\n    if(result == undefined)\\n        return \"\";\\n    else\\n        return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {string}\\n */\\nvar largestTimeFromDigits = function(arr) {\\n    var result;\\n    for(var i =0; i<4; i++){\\n        for (var j=0; j<4 ; j++){\\n            for (var k =0; k<4; k++){\\n                if(i==j || j==k || k==i)\\n                    continue;\\n                var hh = arr[i].toString()+arr[j].toString();\\n                var mm = arr[k].toString()+arr[6-i-j-k].toString();\\n                var _time = hh+\":\"+mm;\\n                if(hh<\"24\" && mm<\"60\" && (_time>result || result==undefined))\\n                    result = _time;\\n            }\\n        }\\n    }\\n    if(result == undefined)\\n        return \"\";\\n    else\\n        return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3338937,
                "title": "c",
                "content": "```\\nclass Solution {\\n    int time = -1 ;\\n    const int upperBound = 24 * 60 ;\\n    void dfs(vector<bool>&used, vector<int>&arr, int cur, vector<int>&tmp){\\n        if(cur == 4){\\n            int hour = tmp[0]*10 + tmp[1] ;\\n            int minute = tmp[2]*10 + tmp[3] ;\\n            if(minute >= 60)\\n                return ;\\n            int curTime = hour * 60 + minute ;\\n            if(curTime < upperBound) \\n                time = max(time, curTime) ;              \\n            return ;\\n        }\\n        for(int i = 0; i < 4; i++){\\n            if(used[i])\\n                continue ;\\n            used[i] = true ;\\n            tmp[cur] = arr[i] ;\\n            dfs(used, arr, cur+1, tmp) ;\\n            used[i] = false ;\\n        }\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end()) ;\\n        if(arr[0] > 2 || (arr[0] == 2 && arr[1] > 3))\\n            return \"\" ;\\n\\n        vector<bool>used(4) ;\\n        vector<int>tmp(4) ;\\n        dfs(used, arr, 0, tmp) ;\\n        if(time == -1)\\n            return \"\" ;\\n        string ret ;\\n        int hour = time/60 ;\\n        int minute = time %60 ;\\n\\n        if(hour < 10)\\n            ret += \"0\" + to_string(hour) ;\\n        else\\n            ret += to_string(hour) ;\\n        ret += \":\" ;\\n        \\n        if(minute < 10)\\n            ret += \"0\" + to_string(minute) ;\\n        else\\n            ret += to_string(minute) ;\\n\\n        return ret ;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int time = -1 ;\\n    const int upperBound = 24 * 60 ;\\n    void dfs(vector<bool>&used, vector<int>&arr, int cur, vector<int>&tmp){\\n        if(cur == 4){\\n            int hour = tmp[0]*10 + tmp[1] ;\\n            int minute = tmp[2]*10 + tmp[3] ;\\n            if(minute >= 60)\\n                return ;\\n            int curTime = hour * 60 + minute ;\\n            if(curTime < upperBound) \\n                time = max(time, curTime) ;              \\n            return ;\\n        }\\n        for(int i = 0; i < 4; i++){\\n            if(used[i])\\n                continue ;\\n            used[i] = true ;\\n            tmp[cur] = arr[i] ;\\n            dfs(used, arr, cur+1, tmp) ;\\n            used[i] = false ;\\n        }\\n    }\\npublic:\\n    string largestTimeFromDigits(vector<int>& arr) {\\n        sort(arr.begin(), arr.end()) ;\\n        if(arr[0] > 2 || (arr[0] == 2 && arr[1] > 3))\\n            return \"\" ;\\n\\n        vector<bool>used(4) ;\\n        vector<int>tmp(4) ;\\n        dfs(used, arr, 0, tmp) ;\\n        if(time == -1)\\n            return \"\" ;\\n        string ret ;\\n        int hour = time/60 ;\\n        int minute = time %60 ;\\n\\n        if(hour < 10)\\n            ret += \"0\" + to_string(hour) ;\\n        else\\n            ret += to_string(hour) ;\\n        ret += \":\" ;\\n        \\n        if(minute < 10)\\n            ret += \"0\" + to_string(minute) ;\\n        else\\n            ret += to_string(minute) ;\\n\\n        return ret ;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325015,
                "title": "java-easy-to-understand-permutations",
                "content": "```\\nclass Solution {\\n    private void generatePermutations(int ind, int[] arr, ArrayList<int[]> al) {\\n        if(ind == 4){\\n            al.add(arr.clone());\\n            return;\\n        }\\n        for(int i = ind;i < 4;i++) {\\n            swap(arr, ind, i);\\n            generatePermutations(ind + 1, arr, al);\\n            swap(arr, ind, i);\\n        }\\n    }\\n    private void swap( int[] arr, int i, int j) {\\n            int temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] =  temp;\\n    }\\n    public String largestTimeFromDigits(int[] arr) {\\n        ArrayList<int[]> al = new ArrayList<>();\\n        generatePermutations(0, arr, al);\\n        StringBuilder sb = new StringBuilder();\\n        int max = 0;\\n        for(int[] a : al) {\\n           int hh = a[0] * 10 + a[1];\\n           int mm = a[2] * 10 + a[3];\\n      \\n           if(hh >= 0 && hh <= 23) {\\n               if(mm >= 0 && mm <= 59){\\n                   if(hh * 100 + mm >= max){\\n                        max = hh * 100 + mm;\\n                        sb = new StringBuilder();\\n                  \\n                        if(hh <= 9 && mm <= 9){\\n                            sb.append(\"0\").append(Integer.toString(hh)).append(\":\").append(\"0\").append(Integer.toString(mm));\\n                        }\\n                        else if(hh <= 9)\\n                            sb.append(\"0\").append(Integer.toString(hh)).append(\":\").append(Integer.toString(mm));\\n                        else if(mm <= 9)\\n                            sb.append(Integer.toString(hh)).append(\":\").append(\"0\").append(Integer.toString(mm));\\n                        else \\n                            sb.append(Integer.toString(hh)).append(\":\").append(Integer.toString(mm));\\n                       \\n                     }\\n                }\\n            }\\n       \\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private void generatePermutations(int ind, int[] arr, ArrayList<int[]> al) {\\n        if(ind == 4){\\n            al.add(arr.clone());\\n            return;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1795252,
                "content": [
                    {
                        "username": "DanQingReader",
                        "content": "stupid question"
                    },
                    {
                        "username": "decostar",
                        "content": "No Brother :(\\n"
                    },
                    {
                        "username": "akhaled01",
                        "content": "isnt the largest possible time for array (1, 2, 3, 4) 23:43?"
                    },
                    {
                        "username": "njculpin",
                        "content": "no, \"can be made using each digit exactly once\""
                    },
                    {
                        "username": "charlie-_-",
                        "content": "No, it\\'s 23:41. You can only use each digit once. "
                    }
                ]
            },
            {
                "id": 1989416,
                "content": [
                    {
                        "username": "DanQingReader",
                        "content": "stupid question"
                    },
                    {
                        "username": "decostar",
                        "content": "No Brother :(\\n"
                    },
                    {
                        "username": "akhaled01",
                        "content": "isnt the largest possible time for array (1, 2, 3, 4) 23:43?"
                    },
                    {
                        "username": "njculpin",
                        "content": "no, \"can be made using each digit exactly once\""
                    },
                    {
                        "username": "charlie-_-",
                        "content": "No, it\\'s 23:41. You can only use each digit once. "
                    }
                ]
            }
        ]
    }
]