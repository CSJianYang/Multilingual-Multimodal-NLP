[
    {
        "title": "Count Vowel Strings in Ranges",
        "question_content": "You are given a 0-indexed array of strings words and a 2D array of integers queries.\nEach query queries[i] = [li, ri] asks us to find the number of strings present in the range li to ri (both inclusive) of words that start and end with a vowel.\nReturn an array ans of size queries.length, where ans[i] is the answer to the ith query.\nNote that the vowel letters are 'a', 'e', 'i', 'o', and 'u'.\n&nbsp;\nExample 1:\n\nInput: words = [\"aba\",\"bcb\",\"ece\",\"aa\",\"e\"], queries = [[0,2],[1,4],[1,1]]\nOutput: [2,3,0]\nExplanation: The strings starting and ending with a vowel are \"aba\", \"ece\", \"aa\" and \"e\".\nThe answer to the query [0,2] is 2 (strings \"aba\" and \"ece\").\nto query [1,4] is 3 (strings \"ece\", \"aa\", \"e\").\nto query [1,1] is 0.\nWe return [2,3,0].\n\nExample 2:\n\nInput: words = [\"a\",\"e\",\"i\"], queries = [[0,2],[0,1],[2,2]]\nOutput: [3,2,1]\nExplanation: Every string satisfies the conditions, so we return [3,2,1].\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 105\n\t1 <= words[i].length <= 40\n\twords[i] consists only of lowercase English letters.\n\tsum(words[i].length) <= 3 * 105\n\t1 <= queries.length <= 105\n\t0 <= li <= ri <&nbsp;words.length",
        "solutions": [
            {
                "id": 3143758,
                "title": "prefix-sum-array-very-simple-and-easy-to-understand-solution",
                "content": "### Up vote if you like this solution.\\n\\n# Approach\\nAs there is no mutation in the array word we can simply take prifix sum.\\n\\n=>  [\"aba\",\"bcb\",\"ece\",\"aa\",\"e\"] \\n=>  [ 1,     0,    1,   1,  1]  ( converted above array to 0/1 array -  set 1 if first and last character of the word are both vowel)\\n=>[0, 1,     1,    2,   3,  4]  ( evaluated prefix sum array)\\n\\nNote : there is an extra 0 at the begining which ease the query evaluation.\\n\\n# Code\\n```\\n\\n    bool check(char c){ \\n        if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' ||  c == \\'u\\') return true; \\n        return false;\\n    }\\n\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> v, ans;\\n        v.push_back(0);\\n        for(auto w: words){ \\n            if( check(w[0]) && check(w.back()) ) v.push_back( v.back() + 1);  \\n            else v.push_back( v.back() );\\n        }\\n        for(auto q: queries) ans.push_back(v[q[1]+1] - v[q[0]]);\\n        return ans;\\n    }\\n\\n```\\nHere is an article of my recent interview experience at Amazon, you may like : \\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n    bool check(char c){ \\n        if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' ||  c == \\'u\\') return true; \\n        return false;\\n    }\\n\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> v, ans;\\n        v.push_back(0);\\n        for(auto w: words){ \\n            if( check(w[0]) && check(w.back()) ) v.push_back( v.back() + 1);  \\n            else v.push_back( v.back() );\\n        }\\n        for(auto q: queries) ans.push_back(v[q[1]+1] - v[q[0]]);\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3143768,
                "title": "prefix-sum-easy-solution",
                "content": "# Complexity\\n- Time ```O(N) #where N is size of words list```\\n\\n- Space ```O(N)``` \\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def vowelStrings(self, words, queries):\\n        prefix = [0]\\n        sum_ = 0\\n        for word in words:\\n            if word[0] in \\'aeiou\\' and word[-1] in \\'aeiou\\':\\n                sum_ += 1\\n            prefix.append(sum_)\\n        res = []\\n        for l, r in queries:\\n            res.append(prefix[r + 1] - prefix[l])\\n        return res\\n```\\nUpVote, if you like it **:)**\\n",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```O(N) #where N is size of words list```\n```O(N)```\n```\\nclass Solution(object):\\n    def vowelStrings(self, words, queries):\\n        prefix = [0]\\n        sum_ = 0\\n        for word in words:\\n            if word[0] in \\'aeiou\\' and word[-1] in \\'aeiou\\':\\n                sum_ += 1\\n            prefix.append(sum_)\\n        res = []\\n        for l, r in queries:\\n            res.append(prefix[r + 1] - prefix[l])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143721,
                "title": "prefix-sum",
                "content": "**C++**\\n```cpp\\nvector<int> vowelStrings(vector<string>& ws, vector<vector<int>>& queries) {\\n    unordered_set<char> vw({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n    vector<int> ps(1), res;\\n    for (const auto &w : ws)\\n        ps.push_back(ps.back() + (vw.count(w.front()) && vw.count(w.back())));\\n    for (const auto &q : queries)\\n        res.push_back(ps[q[1] + 1] - ps[q[0]]);\\n    return res;  \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> vowelStrings(vector<string>& ws, vector<vector<int>>& queries) {\\n    unordered_set<char> vw({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n    vector<int> ps(1), res;\\n    for (const auto &w : ws)\\n        ps.push_back(ps.back() + (vw.count(w.front()) && vw.count(w.back())));\\n    for (const auto &q : queries)\\n        res.push_back(ps[q[1] + 1] - ps[q[0]]);\\n    return res;  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3144407,
                "title": "c-beats-100-prefix-sum-o-q",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we try to do brute force then we have check for all  queries and traverse n times that will be q*n time so will give tle.\\nNow if we observe we have given ranges we can pre calculate in an array upto each index and check how many strings ae there which start and end with vowel then we can answer any query in O(1) so we can use prefix sum here that will give us sum of all the strings which start and end with vowel upto any index i .\\nso if we have to check for an range (i,j) answer = pref[j]-pref[i-1]\\nthat will give us the answer of given range in O(1). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo have a prefix array in which we push 1 if curr string is vowel and pef[i-1] (for all the strins till index i). \\nThen we just check for each query by using this fromula $$pref[j]-pref[i-1]$$\\n# Complexity \\n- Time complexity:$$O(n+q)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# UpVote If HelpFull \\uD83D\\uDD3C\\uD83D\\uDD3C\\uD83D\\uDD3C\\uD83D\\uDD3C\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char x)\\n{\\n    if (x == \\'a\\' || x == \\'e\\' || x == \\'i\\' ||\\n        x == \\'o\\' || x == \\'u\\' || x == \\'A\\' ||\\n        x == \\'E\\' || x == \\'I\\' || x == \\'O\\' || x == \\'U\\')\\n        return true;\\n    else\\n        return false;\\n}\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int>pref(words.size()+1);\\n        int i=0;\\n        for(auto x:words){\\n            \\n                pref[i+1]=pref[i]+(isVowel(x[0]) and isVowel(x[x.size()-1]));\\n            i++;\\n           \\n        }\\n        vector<int> ans;\\n        for (int i = 0; i < queries.size(); i++) {\\n            ans.push_back(pref[queries[i][1] + 1] - pref[queries[i][0]]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char x)\\n{\\n    if (x == \\'a\\' || x == \\'e\\' || x == \\'i\\' ||\\n        x == \\'o\\' || x == \\'u\\' || x == \\'A\\' ||\\n        x == \\'E\\' || x == \\'I\\' || x == \\'O\\' || x == \\'U\\')\\n        return true;\\n    else\\n        return false;\\n}\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int>pref(words.size()+1);\\n        int i=0;\\n        for(auto x:words){\\n            \\n                pref[i+1]=pref[i]+(isVowel(x[0]) and isVowel(x[x.size()-1]));\\n            i++;\\n           \\n        }\\n        vector<int> ans;\\n        for (int i = 0; i < queries.size(); i++) {\\n            ans.push_back(pref[queries[i][1] + 1] - pref[queries[i][0]]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143881,
                "title": "java-prefix-sum-explained",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n``` java []\\n// We will say a word satisfies us if its first and last character are vowels\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int n = words.length;\\n        // we will create a prefix sum array whose index i will tell us \\n        // how many words satisfy us from index 0 till index i\\n        int[] pref = new int[n];    \\n        // if the first word itself saitisfy us, we will put 1 in index 0\\n        // which means till index 0 we have 1 satisfactory string\\n        String s = words[0];\\n        if (isVowel(s.charAt(0)) && isVowel(s.charAt(s.length() - 1))) {\\n            pref[0] = 1;\\n        }\\n        // start iterating from index 1\\n        for (int i = 1; i < n; i++) {\\n            s = words[i];\\n            // if current word is satisfactory\\n            if (isVowel(s.charAt(0)) && isVowel(s.charAt(s.length() - 1))) {\\n                // number of satisfactory words increases by 1 at current index\\n                pref[i] = 1 + pref[i-1];\\n            } else {    // otherwise it remains the same\\n                pref[i] = pref[i-1];\\n            }\\n        }\\n\\n        // create answer array\\n        int[] ans = new int[queries.length];    \\n        for (int i = 0; i < queries.length; i++) {\\n            int l = queries[i][0];  // get left bound\\n            int r = queries[i][1];  // get right bound\\n            // our words in range l to r (inclusive) is the\\n            // difference of satisfactory words till index `r` and index l-1\\n            // why `l-1` and not `l`? because `l` is inclusive\\n            // in case l is 0, means we want from index 0 itself till \\'r\\' \\n            // so its directly pref[r]\\n            ans[i] = pref[r] - ((l == 0)? 0 : pref[l-1]);            \\n        }\\n\\n        return ans;     // return the answer array\\n    }\\n\\n    // method to tell is passed in character is a vowel or not\\n    private boolean isVowel(char c) {\\n        return Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\').contains(c);\\n    }\\n}\\n```\\n--- \\n#### Clean solution:\\n``` java []\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int n = words.length;\\n        int[] pref = new int[n];\\n        String s = words[0];\\n        if (isVowel(s.charAt(0)) && isVowel(s.charAt(s.length() - 1))) {\\n            pref[0] = 1;\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            s = words[i];\\n            boolean b = isVowel(s.charAt(0)) && isVowel(s.charAt(s.length() - 1));\\n            pref[i] = pref[i-1] + (b? 1 : 0);\\n        }\\n        \\n        int[] ans = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            int l = queries[i][0];\\n            int r = queries[i][1];\\n            ans[i] = pref[r] - ((l == 0)? 0 : pref[l-1]);            \\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean isVowel(char c) {\\n        return Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\').contains(c);\\n    }\\n}\\n```\\n--- \\nLet $$n$$ and $$k$$ be the length of the arrays `words` and `queries` respectively.\\n##### Time complexity: $$O(n + k)$$\\n##### Space complexity: $$O(n + k)$$\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "``` java []\\n// We will say a word satisfies us if its first and last character are vowels\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int n = words.length;\\n        // we will create a prefix sum array whose index i will tell us \\n        // how many words satisfy us from index 0 till index i\\n        int[] pref = new int[n];    \\n        // if the first word itself saitisfy us, we will put 1 in index 0\\n        // which means till index 0 we have 1 satisfactory string\\n        String s = words[0];\\n        if (isVowel(s.charAt(0)) && isVowel(s.charAt(s.length() - 1))) {\\n            pref[0] = 1;\\n        }\\n        // start iterating from index 1\\n        for (int i = 1; i < n; i++) {\\n            s = words[i];\\n            // if current word is satisfactory\\n            if (isVowel(s.charAt(0)) && isVowel(s.charAt(s.length() - 1))) {\\n                // number of satisfactory words increases by 1 at current index\\n                pref[i] = 1 + pref[i-1];\\n            } else {    // otherwise it remains the same\\n                pref[i] = pref[i-1];\\n            }\\n        }\\n\\n        // create answer array\\n        int[] ans = new int[queries.length];    \\n        for (int i = 0; i < queries.length; i++) {\\n            int l = queries[i][0];  // get left bound\\n            int r = queries[i][1];  // get right bound\\n            // our words in range l to r (inclusive) is the\\n            // difference of satisfactory words till index `r` and index l-1\\n            // why `l-1` and not `l`? because `l` is inclusive\\n            // in case l is 0, means we want from index 0 itself till \\'r\\' \\n            // so its directly pref[r]\\n            ans[i] = pref[r] - ((l == 0)? 0 : pref[l-1]);            \\n        }\\n\\n        return ans;     // return the answer array\\n    }\\n\\n    // method to tell is passed in character is a vowel or not\\n    private boolean isVowel(char c) {\\n        return Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\').contains(c);\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int n = words.length;\\n        int[] pref = new int[n];\\n        String s = words[0];\\n        if (isVowel(s.charAt(0)) && isVowel(s.charAt(s.length() - 1))) {\\n            pref[0] = 1;\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            s = words[i];\\n            boolean b = isVowel(s.charAt(0)) && isVowel(s.charAt(s.length() - 1));\\n            pref[i] = pref[i-1] + (b? 1 : 0);\\n        }\\n        \\n        int[] ans = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            int l = queries[i][0];\\n            int r = queries[i][1];\\n            ans[i] = pref[r] - ((l == 0)? 0 : pref[l-1]);            \\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean isVowel(char c) {\\n        return Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\').contains(c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143946,
                "title": "c-3-approaches-brute-force-segment-tree-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- BRUTE FORCE : Simply determine number of words staisfying condition between query range with loop\\n- SEGMENT TREE : Create a Segment tree by first creating an array of 0,1 (1 if word in words array start and end with vowel and 0 otherwise). N evaluate range sum between segments of tree \\n- PREFIX SUM : Create array of 0,1 similar to previous approch and find prefix sum.for every query we have start and end. Determine the difference between the range and store it in ans.\\n\\n# Complexity\\n- Time complexity: \\n- m = queries length\\n- n = words length \\n- BRUTE FORCE : O(m^n)  Each Query Executed in O(n) worst case\\n- SEGMENT TREE : O(m*logn)  Each Query Executed in O(logn) worst case\\n- BRUTE FORCE : O(m+n)  Each Query Executed in O(1) worst case\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//BRUTE FORCE \\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        unordered_set<char> vowels;\\n        vowels.insert(\\'a\\');\\n        vowels.insert(\\'e\\');\\n        vowels.insert(\\'i\\');\\n        vowels.insert(\\'o\\');\\n        vowels.insert(\\'u\\');\\n\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int value=0;\\n            for(int j=queries[i][0];j<=queries[i][1];j++){\\n                if(vowels.count(words[j][0])>0 && vowels.count(words[j][words[j].size()-1])>0){\\n                    value++;\\n                }\\n            }\\n            ans.push_back(value);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n```\\n//SEGMENT TREE \\n\\nclass Solution {\\n    \\npublic:\\n    vector<int> seg;\\n    int n;\\n        \\n    int buildTree(vector<int>& nums, vector<int>& seg, int l, int r, int index){\\n        if(l==r){\\n            seg[index]=nums[l];\\n            return nums[l];\\n        }\\n        \\n        int mid=l+(r-l)/2;\\n        \\n        int LeftSum=buildTree(nums,seg,l,mid,2*index+1);\\n        int RightSum=buildTree(nums,seg,mid+1,r,2*index+2);\\n        seg[index]=LeftSum+RightSum;\\n        return seg[index];\\n    }\\n    \\n    int RangeSumTree(vector<int>& seg,int segIndex, int l, int r, int rangeLeft, int rangeRight){\\n        if(r<rangeLeft || l>rangeRight) return 0;\\n        if(l>=rangeLeft && r<=rangeRight) return seg[segIndex];\\n        \\n        int mid=l+(r-l)/2;\\n        int LeftSum=RangeSumTree(seg,2*segIndex+1,l,mid,rangeLeft,rangeRight);\\n        int RightSum=RangeSumTree(seg,2*segIndex+2,mid+1,r,rangeLeft,rangeRight);\\n        return LeftSum+RightSum;        \\n    }\\n\\n\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        unordered_set<char> vowels;\\n        vowels.insert(\\'a\\');\\n        vowels.insert(\\'e\\');\\n        vowels.insert(\\'i\\');\\n        vowels.insert(\\'o\\');\\n        vowels.insert(\\'u\\');\\n        \\n        \\n        vector<int> nums(words.size());\\n        for(int i=0;i<words.size();i++){\\n            int start=0, end=words[i].size()-1;\\n            if(vowels.count(words[i][start])>0 && vowels.count(words[i][end])>0) nums[i]=1;\\n            else nums[i]=0;\\n        }\\n        \\n        n=nums.size();\\n        seg.resize(n*4);\\n        buildTree(nums,seg,0,n-1,0);\\n        \\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int value=RangeSumTree(seg,0,0,nums.size()-1,queries[i][0],queries[i][1]);\\n            ans.push_back(value);\\n        }\\n        return ans;       \\n    }\\n};\\n```\\n\\n```\\n// PREFIX SUM \\n\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        unordered_set<char> vowels;\\n        vowels.insert(\\'a\\');\\n        vowels.insert(\\'e\\');\\n        vowels.insert(\\'i\\');\\n        vowels.insert(\\'o\\');\\n        vowels.insert(\\'u\\');\\n\\n        vector<int> nums(words.size());\\n        for(int i=0;i<words.size();i++){\\n            int start=0, end=words[i].size()-1;\\n            if(vowels.count(words[i][start])>0 && vowels.count(words[i][end])>0) nums[i]=1;\\n            else nums[i]=0;\\n        }\\n\\n        //Evaluate prefix sum \\n        for(int i=1;i<nums.size();i++){\\n            nums[i]=nums[i]+nums[i-1];\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int start=queries[i][0];\\n            int end=queries[i][1];\\n\\n            if(start==0){\\n                ans.push_back(nums[end]);\\n            }\\n            else{\\n                ans.push_back(nums[end]-nums[start-1]);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Segment Tree",
                    "Prefix Sum"
                ],
                "code": "```\\n//BRUTE FORCE \\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        unordered_set<char> vowels;\\n        vowels.insert(\\'a\\');\\n        vowels.insert(\\'e\\');\\n        vowels.insert(\\'i\\');\\n        vowels.insert(\\'o\\');\\n        vowels.insert(\\'u\\');\\n\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int value=0;\\n            for(int j=queries[i][0];j<=queries[i][1];j++){\\n                if(vowels.count(words[j][0])>0 && vowels.count(words[j][words[j].size()-1])>0){\\n                    value++;\\n                }\\n            }\\n            ans.push_back(value);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n//SEGMENT TREE \\n\\nclass Solution {\\n    \\npublic:\\n    vector<int> seg;\\n    int n;\\n        \\n    int buildTree(vector<int>& nums, vector<int>& seg, int l, int r, int index){\\n        if(l==r){\\n            seg[index]=nums[l];\\n            return nums[l];\\n        }\\n        \\n        int mid=l+(r-l)/2;\\n        \\n        int LeftSum=buildTree(nums,seg,l,mid,2*index+1);\\n        int RightSum=buildTree(nums,seg,mid+1,r,2*index+2);\\n        seg[index]=LeftSum+RightSum;\\n        return seg[index];\\n    }\\n    \\n    int RangeSumTree(vector<int>& seg,int segIndex, int l, int r, int rangeLeft, int rangeRight){\\n        if(r<rangeLeft || l>rangeRight) return 0;\\n        if(l>=rangeLeft && r<=rangeRight) return seg[segIndex];\\n        \\n        int mid=l+(r-l)/2;\\n        int LeftSum=RangeSumTree(seg,2*segIndex+1,l,mid,rangeLeft,rangeRight);\\n        int RightSum=RangeSumTree(seg,2*segIndex+2,mid+1,r,rangeLeft,rangeRight);\\n        return LeftSum+RightSum;        \\n    }\\n\\n\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        unordered_set<char> vowels;\\n        vowels.insert(\\'a\\');\\n        vowels.insert(\\'e\\');\\n        vowels.insert(\\'i\\');\\n        vowels.insert(\\'o\\');\\n        vowels.insert(\\'u\\');\\n        \\n        \\n        vector<int> nums(words.size());\\n        for(int i=0;i<words.size();i++){\\n            int start=0, end=words[i].size()-1;\\n            if(vowels.count(words[i][start])>0 && vowels.count(words[i][end])>0) nums[i]=1;\\n            else nums[i]=0;\\n        }\\n        \\n        n=nums.size();\\n        seg.resize(n*4);\\n        buildTree(nums,seg,0,n-1,0);\\n        \\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int value=RangeSumTree(seg,0,0,nums.size()-1,queries[i][0],queries[i][1]);\\n            ans.push_back(value);\\n        }\\n        return ans;       \\n    }\\n};\\n```\n```\\n// PREFIX SUM \\n\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        unordered_set<char> vowels;\\n        vowels.insert(\\'a\\');\\n        vowels.insert(\\'e\\');\\n        vowels.insert(\\'i\\');\\n        vowels.insert(\\'o\\');\\n        vowels.insert(\\'u\\');\\n\\n        vector<int> nums(words.size());\\n        for(int i=0;i<words.size();i++){\\n            int start=0, end=words[i].size()-1;\\n            if(vowels.count(words[i][start])>0 && vowels.count(words[i][end])>0) nums[i]=1;\\n            else nums[i]=0;\\n        }\\n\\n        //Evaluate prefix sum \\n        for(int i=1;i<nums.size();i++){\\n            nums[i]=nums[i]+nums[i-1];\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int start=queries[i][0];\\n            int end=queries[i][1];\\n\\n            if(start==0){\\n                ans.push_back(nums[end]);\\n            }\\n            else{\\n                ans.push_back(nums[end]-nums[start-1]);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143723,
                "title": "beginners-prefix-sum-solution-with-explanation-and-clean-code",
                "content": "# Intuition\\n1. We need to calculate the number of words whose starting character and ending character is vowel for each range given in queries array.\\n2. We can do by checking starting character and ending character is vowel or not for every word for each range, but this will leads to TLE.\\n3. If we precompute the value once this will save time from checking every time, this can be done using prefix sum.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a preComputePrefix array of size n+1 because we initialise value of 0-index with 0 and accordingly we calculate.\\n2. Now we compute preComputePrefix same as prefix sum by adding 1 to previous preComputePrefix value if firstChar and lastChar is vowel, else we use previous preComputePrefix value.\\n3. Now we simply calculate the range by preComputePrefix[endIdx+1] - preComputePrefix[strIdx] in O(1) time for each query.\\n\\n# Complexity\\n- Time complexity: O(N) \\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    where N is size of words array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //checking character is vowel or not\\n    bool isVowel(char c){\\n        if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\')\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n\\t//size of words array\\n        int n=words.size();\\n        \\n        //stores the precomputed prefix array\\n        vector<long long> preComputePrefix(n+1,0);\\n\\n        //precomputing the prefix array\\n        for(int i=0;i<n;i++){\\n            char firstChar=words[i][0];\\n            char lastChar=words[i][words[i].size()-1];\\n            \\n            //if first and last character is vowel then we add 1 to previous \\n            //prefix computed value else we use previous calculated value.\\n            if(isVowel(firstChar) && isVowel(lastChar))\\n                preComputePrefix[i+1]=preComputePrefix[i]+1;\\n            else\\n                preComputePrefix[i+1]=preComputePrefix[i];\\n        }\\n        \\n        //ans array stores the count of words in range\\n        vector<int> ans;\\n\\n        //calculating the count in given range\\n        for(int i=0;i<queries.size();i++){\\n            int strIdx=queries[i][0];\\n            int endIdx=queries[i][1];\\n            \\n            //count of words is determined by pref[endIdx]-pref[strIdx]\\n            //endIdx+1 is because of we assume pref[0]=0 and index will start from 1\\n            int cnt=preComputePrefix[endIdx+1]-preComputePrefix[strIdx];\\n            \\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //checking character is vowel or not\\n    bool isVowel(char c){\\n        if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\')\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n\\t//size of words array\\n        int n=words.size();\\n        \\n        //stores the precomputed prefix array\\n        vector<long long> preComputePrefix(n+1,0);\\n\\n        //precomputing the prefix array\\n        for(int i=0;i<n;i++){\\n            char firstChar=words[i][0];\\n            char lastChar=words[i][words[i].size()-1];\\n            \\n            //if first and last character is vowel then we add 1 to previous \\n            //prefix computed value else we use previous calculated value.\\n            if(isVowel(firstChar) && isVowel(lastChar))\\n                preComputePrefix[i+1]=preComputePrefix[i]+1;\\n            else\\n                preComputePrefix[i+1]=preComputePrefix[i];\\n        }\\n        \\n        //ans array stores the count of words in range\\n        vector<int> ans;\\n\\n        //calculating the count in given range\\n        for(int i=0;i<queries.size();i++){\\n            int strIdx=queries[i][0];\\n            int endIdx=queries[i][1];\\n            \\n            //count of words is determined by pref[endIdx]-pref[strIdx]\\n            //endIdx+1 is because of we assume pref[0]=0 and index will start from 1\\n            int cnt=preComputePrefix[endIdx+1]-preComputePrefix[strIdx];\\n            \\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153203,
                "title": "python-3-4-lines-w-explanation-and-example-t-m-100-27",
                "content": "Here\\'s the plan:\\n- We construct a`lambda`boolean function`vowels`to assess whether the word qualifies.\\n- We map`words`using this function.\\n- We construct`pref`, a prefix sum list.\\n- We use`pref`to answer the queries.\\n```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n                                                                # Example:\\n                                                                #    words = [\\'aba\\',\\'bcb\\',\\'ece\\',\\'aa\\',\\'e\\'] \\n                                                                #  queries = [[0,2], [1,4], [1,1]]\\n\\n        vowels = lambda w: w[0] in \\'aeiou\\' and w[-1] in \\'aeiou\\' #  <-- boolean function  \\n\\n        words = map(vowels, words)                              #    words = [True, False, True, True, True]\\n        \\n        pref = list(accumulate(words, initial = 0))             #     pref = [0, 1, 1, 2, 3, 4]\\n        \\n        return [pref[r+1] - pref[l] for l,r in queries]         #   return [2-0, 4-1, 1-1] = [2,3,0]\\n```\\n[https://leetcode.com/problems/count-vowel-strings-in-ranges/submissions/892925367/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n                                                                # Example:\\n                                                                #    words = [\\'aba\\',\\'bcb\\',\\'ece\\',\\'aa\\',\\'e\\'] \\n                                                                #  queries = [[0,2], [1,4], [1,1]]\\n\\n        vowels = lambda w: w[0] in \\'aeiou\\' and w[-1] in \\'aeiou\\' #  <-- boolean function  \\n\\n        words = map(vowels, words)                              #    words = [True, False, True, True, True]\\n        \\n        pref = list(accumulate(words, initial = 0))             #     pref = [0, 1, 1, 2, 3, 4]\\n        \\n        return [pref[r+1] - pref[l] for l,r in queries]         #   return [2-0, 4-1, 1-1] = [2,3,0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143797,
                "title": "python3-solution-prefix-sum",
                "content": "# Intution\\nIt is a standard range query question which can be solved using `Prefix Sum`\\n\\n# Approach\\nAt index `i` of Array `A` , it contains the no. of words which have first and last character vowel upto `i`. To find the no. of such words we need to subtract the no. words upto `l` from `r`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        n = len(words)\\n        A = [0] * (n + 1)\\n        vowel = \\'aeiou\\'\\n        ans = []\\n        for i in range(n):\\n            A[i + 1] = A[i] + (1 if words[i][0] in vowel and words[i][-1] in vowel else 0)\\n        for l, r in queries:\\n            ans.append(A[r + 1] - A[l])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        n = len(words)\\n        A = [0] * (n + 1)\\n        vowel = \\'aeiou\\'\\n        ans = []\\n        for i in range(n):\\n            A[i + 1] = A[i] + (1 if words[i][0] in vowel and words[i][-1] in vowel else 0)\\n        for l, r in queries:\\n            ans.append(A[r + 1] - A[l])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143784,
                "title": "prefix-sum-c-easy-simple-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvow(char &ch){\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\'\\n          || ch == \\'u\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& w, vector<vector<int>>& q) {\\n        int n=w.size();\\n        \\n        vector<int> pre(n,0);\\n        int cnt=0;\\n        for(int i=0; i<n; i++){\\n            string s=w[i];\\n            char f=s[0],l=s[s.size()-1];\\n            \\n            //check vowels\\n            if(isvow(f) && isvow(l)){\\n                cnt++;\\n            }\\n            \\n            pre[i]=cnt;\\n        }\\n        vector<int> ans(q.size());\\n        int i=0;\\n        \\n        //for(int i=0; i<pre.size(); i++) cout<<pre[i]<<\" \";\\n        for(auto &it: q){\\n            int s=it[0],e=it[1];\\n            if(s == 0){\\n                ans[i++] = pre[e];\\n            }\\n            else{\\n                ans[i++] = pre[e]-pre[s-1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n# Do Upvote, if you understood the solution!\\n\\n![Upvote Please.jpeg](https://assets.leetcode.com/users/images/d5101224-82fe-416d-8312-9db5503d5eaf_1675570314.5551138.jpeg)\\n\\nHappy coding :)\\n",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvow(char &ch){\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\'\\n          || ch == \\'u\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& w, vector<vector<int>>& q) {\\n        int n=w.size();\\n        \\n        vector<int> pre(n,0);\\n        int cnt=0;\\n        for(int i=0; i<n; i++){\\n            string s=w[i];\\n            char f=s[0],l=s[s.size()-1];\\n            \\n            //check vowels\\n            if(isvow(f) && isvow(l)){\\n                cnt++;\\n            }\\n            \\n            pre[i]=cnt;\\n        }\\n        vector<int> ans(q.size());\\n        int i=0;\\n        \\n        //for(int i=0; i<pre.size(); i++) cout<<pre[i]<<\" \";\\n        for(auto &it: q){\\n            int s=it[0],e=it[1];\\n            if(s == 0){\\n                ans[i++] = pre[e];\\n            }\\n            else{\\n                ans[i++] = pre[e]-pre[s-1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3143694,
                "title": "java-prefix-sum-very-easy-and-efficient-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int n = words.length;\\n        int m = queries.length;\\n        int[] preSum = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            String word = words[i - 1];\\n            if (word.length() >= 1 && vowel(word.charAt(0)) && vowel(word.charAt(word.length() - 1))) {\\n                preSum[i] = preSum[i - 1] + 1;\\n            } else {\\n                preSum[i] = preSum[i - 1];\\n            }\\n        }\\n        int[] arr = new int[m];\\n        for (int i = 0; i < m; i++) {\\n            int a = queries[i][0];\\n            int b = queries[i][1];\\n            arr[i] = preSum[b + 1] - preSum[a];\\n        }\\n        return arr;\\n    }\\n    \\n    private boolean vowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int n = words.length;\\n        int m = queries.length;\\n        int[] preSum = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            String word = words[i - 1];\\n            if (word.length() >= 1 && vowel(word.charAt(0)) && vowel(word.charAt(word.length() - 1))) {\\n                preSum[i] = preSum[i - 1] + 1;\\n            } else {\\n                preSum[i] = preSum[i - 1];\\n            }\\n        }\\n        int[] arr = new int[m];\\n        for (int i = 0; i < m; i++) {\\n            int a = queries[i][0];\\n            int b = queries[i][1];\\n            arr[i] = preSum[b + 1] - preSum[a];\\n        }\\n        return arr;\\n    }\\n    \\n    private boolean vowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143828,
                "title": "c-prefix-sum-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) \\n    {\\n        set<char> vowels = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        vector<int> prefix_sum, res;\\n        int cnt=0;\\n        \\n        for(auto &it : words)\\n        {\\n            if(vowels.count(it[0])==1 && vowels.count(it[it.size()-1])) cnt++;\\n                \\n            prefix_sum.push_back(cnt);\\n        }\\n        \\n        for(auto &it:queries)\\n        {\\n            if(it[0] > 0)\\n                cnt = prefix_sum[it[1]] - prefix_sum[it[0]-1];\\n            else\\n                cnt = prefix_sum[it[1]];\\n            \\n            res.push_back(cnt);\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\n\\n# Please upvote if you find this solution helpful",
                "solutionTags": [
                    "C++",
                    "String",
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) \\n    {\\n        set<char> vowels = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        vector<int> prefix_sum, res;\\n        int cnt=0;\\n        \\n        for(auto &it : words)\\n        {\\n            if(vowels.count(it[0])==1 && vowels.count(it[it.size()-1])) cnt++;\\n                \\n            prefix_sum.push_back(cnt);\\n        }\\n        \\n        for(auto &it:queries)\\n        {\\n            if(it[0] > 0)\\n                cnt = prefix_sum[it[1]] - prefix_sum[it[0]-1];\\n            else\\n                cnt = prefix_sum[it[1]];\\n            \\n            res.push_back(cnt);\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150054,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* First make an array which store whether the given word starts and end with vowel or not.\\n* Calculate prefix sum of that array.\\n* Then calculate the numbers in that given range from prefix sum array. \\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isVowel(char ch)\\n    {\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\')\\n            return true;\\n        return false;\\n    }\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int prefsum[]=new int[words.length];\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(isVowel(words[i].charAt(0)) && isVowel(words[i].charAt(words[i].length()-1)))\\n                prefsum[i]=1;\\n            else\\n                prefsum[i]=0;\\n        }\\n        for(int i=1;i<prefsum.length;i++)\\n            prefsum[i]=prefsum[i]+prefsum[i-1];\\n        \\n        int ans[]=new int[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            if(queries[i][0]==0)\\n                ans[i]=prefsum[queries[i][1]];\\n            else\\n                ans[i]=prefsum[queries[i][1]]-prefsum[queries[i][0]-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isVowel(char ch)\\n    {\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\')\\n            return true;\\n        return false;\\n    }\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int prefsum[]=new int[words.length];\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(isVowel(words[i].charAt(0)) && isVowel(words[i].charAt(words[i].length()-1)))\\n                prefsum[i]=1;\\n            else\\n                prefsum[i]=0;\\n        }\\n        for(int i=1;i<prefsum.length;i++)\\n            prefsum[i]=prefsum[i]+prefsum[i-1];\\n        \\n        int ans[]=new int[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            if(queries[i][0]==0)\\n                ans[i]=prefsum[queries[i][1]];\\n            else\\n                ans[i]=prefsum[queries[i][1]]-prefsum[queries[i][0]-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144908,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size();\\n        vector<int> dp(n);\\n        int i=0;\\n        for(string s:words)\\n        {\\n            int l=s.size();\\n            l--;\\n            if((s[0]==\\'a\\' || s[0]==\\'e\\' || s[0]==\\'i\\' || s[0]==\\'o\\' || s[0]==\\'u\\') && \\n            (s[l]==\\'a\\' || s[l]==\\'e\\' || s[l]==\\'i\\' || s[l]==\\'o\\' || s[l]==\\'u\\'))\\n            dp[i]=1;\\n            i++;\\n        }\\n        for(int i=1;i<n;i++)\\n        dp[i]+=dp[i-1];\\n        vector<int> ans;\\n        for(vector<int> v:queries)\\n        {\\n            if(v[0]==0)\\n            ans.push_back(dp[v[1]]);\\n            else\\n            ans.push_back(dp[v[1]]-dp[v[0]-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size();\\n        vector<int> dp(n);\\n        int i=0;\\n        for(string s:words)\\n        {\\n            int l=s.size();\\n            l--;\\n            if((s[0]==\\'a\\' || s[0]==\\'e\\' || s[0]==\\'i\\' || s[0]==\\'o\\' || s[0]==\\'u\\') && \\n            (s[l]==\\'a\\' || s[l]==\\'e\\' || s[l]==\\'i\\' || s[l]==\\'o\\' || s[l]==\\'u\\'))\\n            dp[i]=1;\\n            i++;\\n        }\\n        for(int i=1;i<n;i++)\\n        dp[i]+=dp[i-1];\\n        vector<int> ans;\\n        for(vector<int> v:queries)\\n        {\\n            if(v[0]==0)\\n            ans.push_back(dp[v[1]]);\\n            else\\n            ans.push_back(dp[v[1]]-dp[v[0]-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144192,
                "title": "c-prefix-sum-easy-85-time-75-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(string s){\\n      int n = s.size();\\n      if((s[0] == \\'a\\' or s[0] == \\'e\\' or s[0] == \\'i\\' or s[0] == \\'o\\' or s[0] == \\'u\\') and (s[n - 1] == \\'a\\' or s[n - 1] == \\'e\\' or s[n - 1] == \\'i\\' or s[n - 1] == \\'o\\' or s[n - 1] == \\'u\\'))\\n        return 1;\\n      return 0;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& q) {\\n      int n = words.size();\\n      vector<int> v(n, 0);\\n      for(int i = 0; i < n; i++){\\n        v[i] = helper(words[i]);\\n      }\\n      vector<int> psum(n, v[0]);\\n      for(int i = 1; i < n; i++){\\n        psum[i] = v[i] + psum[i - 1];\\n      }\\n      vector<int> ans(q.size(), 0);\\n      for(int i = 0; i < q.size(); i++){\\n        int l = q[i][0], r = q[i][1];\\n        if(!v[l] and !v[r]){\\n          ans[i] = psum[r] - psum[l];\\n        } else if(!v[l]){\\n          ans[i] = psum[r] - psum[l];\\n        } else if(!v[r]){\\n          ans[i] = psum[r] - psum[l] + 1;\\n        } else {\\n          ans[i] = psum[r] - psum[l] + 1;\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(string s){\\n      int n = s.size();\\n      if((s[0] == \\'a\\' or s[0] == \\'e\\' or s[0] == \\'i\\' or s[0] == \\'o\\' or s[0] == \\'u\\') and (s[n - 1] == \\'a\\' or s[n - 1] == \\'e\\' or s[n - 1] == \\'i\\' or s[n - 1] == \\'o\\' or s[n - 1] == \\'u\\'))\\n        return 1;\\n      return 0;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& q) {\\n      int n = words.size();\\n      vector<int> v(n, 0);\\n      for(int i = 0; i < n; i++){\\n        v[i] = helper(words[i]);\\n      }\\n      vector<int> psum(n, v[0]);\\n      for(int i = 1; i < n; i++){\\n        psum[i] = v[i] + psum[i - 1];\\n      }\\n      vector<int> ans(q.size(), 0);\\n      for(int i = 0; i < q.size(); i++){\\n        int l = q[i][0], r = q[i][1];\\n        if(!v[l] and !v[r]){\\n          ans[i] = psum[r] - psum[l];\\n        } else if(!v[l]){\\n          ans[i] = psum[r] - psum[l];\\n        } else if(!v[r]){\\n          ans[i] = psum[r] - psum[l] + 1;\\n        } else {\\n          ans[i] = psum[r] - psum[l] + 1;\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143853,
                "title": "c-prefix-sum-beginner-friendly-code",
                "content": "![image](https://assets.leetcode.com/users/images/7df4768c-4ea7-4013-ae71-3fb0b3830ae9_1675570137.227791.png)\\n\\n**T->O(n+m) && S->O(n+m)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> vowelStrings(vector<string>& w, vector<vector<int>>& q) {\\n\\t\\t\\t\\tint n = w.size();\\n\\t\\t\\t\\tint m = q.size();\\n\\t\\t\\t\\tvector <int> ans(m,0);\\n\\t\\t\\t\\tvector <int> v(n,0);\\n\\n\\t\\t\\t\\tfor(int i = 0 ; i < n ; i++){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//Condition for first letter being a vowel\\n\\t\\t\\t\\t\\tbool first = (w[i][0] == \\'a\\' || w[i][0] == \\'e\\' || w[i][0] == \\'i\\' || w[i][0] == \\'o\\' || w[i][0] == \\'u\\');\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//Condition for last letter being a vowel\\n\\t\\t\\t\\t\\tint s = w[i].size();\\n\\t\\t\\t\\t\\tbool last = (w[i][s-1] == \\'a\\' || w[i][s-1] == \\'e\\' || w[i][s-1] == \\'i\\' || w[i][s-1] == \\'o\\' || w[i][s-1] == \\'u\\');\\n\\n\\t\\t\\t\\t\\tif(first && last){\\n\\t\\t\\t\\t\\t\\tif(i>0) v[i] = v[i-1]+1;\\n\\t\\t\\t\\t\\t\\telse v[i] = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(i>0) v[i] = v[i-1];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor(int i = 0 ; i < m ; i++){\\n\\t\\t\\t\\t\\tif(q[i][0] > 0) ans[i] = v[q[i][1]]-v[q[i][0]-1];\\n\\t\\t\\t\\t\\telse ans[i] = v[q[i][1]];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> vowelStrings(vector<string>& w, vector<vector<int>>& q) {\\n\\t\\t\\t\\tint n = w.size();\\n\\t\\t\\t\\tint m = q.size();\\n\\t\\t\\t\\tvector <int> ans(m,0);\\n\\t\\t\\t\\tvector <int> v(n,0);\\n\\n\\t\\t\\t\\tfor(int i = 0 ; i < n ; i++){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//Condition for first letter being a vowel\\n\\t\\t\\t\\t\\tbool first = (w[i][0] == \\'a\\' || w[i][0] == \\'e\\' || w[i][0] == \\'i\\' || w[i][0] == \\'o\\' || w[i][0] == \\'u\\');\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//Condition for last letter being a vowel\\n\\t\\t\\t\\t\\tint s = w[i].size();\\n\\t\\t\\t\\t\\tbool last = (w[i][s-1] == \\'a\\' || w[i][s-1] == \\'e\\' || w[i][s-1] == \\'i\\' || w[i][s-1] == \\'o\\' || w[i][s-1] == \\'u\\');\\n\\n\\t\\t\\t\\t\\tif(first && last){\\n\\t\\t\\t\\t\\t\\tif(i>0) v[i] = v[i-1]+1;\\n\\t\\t\\t\\t\\t\\telse v[i] = 1;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3143682,
                "title": "simple-java-solution-using-prefix-sum",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the size of the words array\\n\\n- Space complexity: $$O(n)$$ where n is the size of the words array\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        Map<Integer,Integer> nm=new HashMap<>();\\n        int i=0;\\n        int b[]=new int[words.length];\\n        for(String p:words)\\n        {\\n            int f=0;\\n            char c=p.charAt(0);\\n            char d=p.charAt(p.length()-1);\\n            if((c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\') && (d==\\'a\\' || d==\\'e\\' || d==\\'i\\' || d==\\'o\\' || d==\\'u\\'))\\n            {\\n                nm.put(i,1);\\n                f++;\\n            }\\n            if(f==1)\\n            {\\n                b[i]=1;\\n            }\\n            if(i>0)\\n            {\\n                b[i]+=b[i-1];\\n            }\\n            i++;\\n        }\\n        int m=0;\\n        int a[]=new int[queries.length];\\n        for(int p[]: queries)\\n        {\\n            int c=0;\\n            if(p[1]==0)\\n            {\\n                if(nm.containsKey(p[1]))\\n                {\\n                    c++;\\n                }\\n                a[m++]=c;\\n            }\\n            else if(p[0]==0)\\n            {\\n                a[m++]=b[p[1]];\\n            }\\n            else\\n            {\\n                a[m++]=b[p[1]]-(b[p[0]-1]);\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        Map<Integer,Integer> nm=new HashMap<>();\\n        int i=0;\\n        int b[]=new int[words.length];\\n        for(String p:words)\\n        {\\n            int f=0;\\n            char c=p.charAt(0);\\n            char d=p.charAt(p.length()-1);\\n            if((c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\') && (d==\\'a\\' || d==\\'e\\' || d==\\'i\\' || d==\\'o\\' || d==\\'u\\'))\\n            {\\n                nm.put(i,1);\\n                f++;\\n            }\\n            if(f==1)\\n            {\\n                b[i]=1;\\n            }\\n            if(i>0)\\n            {\\n                b[i]+=b[i-1];\\n            }\\n            i++;\\n        }\\n        int m=0;\\n        int a[]=new int[queries.length];\\n        for(int p[]: queries)\\n        {\\n            int c=0;\\n            if(p[1]==0)\\n            {\\n                if(nm.containsKey(p[1]))\\n                {\\n                    c++;\\n                }\\n                a[m++]=c;\\n            }\\n            else if(p[0]==0)\\n            {\\n                a[m++]=b[p[1]];\\n            }\\n            else\\n            {\\n                a[m++]=b[p[1]]-(b[p[0]-1]);\\n            }\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526879,
                "title": "c-easy-to-understnad",
                "content": "Maintain a prefix array that contain all words that count of all words that start and end with vowels.\\nprefix array at index i have count of all possible words that start and end with vowels.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        vector<int> v(n+1,0);\\n        for(int i = 0; i < n; i++){\\n            if((words[i][0]==\\'a\\'||words[i][0]==\\'e\\'||words[i][0]==\\'i\\'||words[i][0]==\\'o\\'||words[i][0]==\\'u\\')&&(words[i][words[i].length()-1]==\\'a\\'||words[i][words[i].length()-1]==\\'e\\'||words[i][words[i].length()-1]==\\'i\\'||words[i][words[i].length()-1]==\\'o\\'||words[i][words[i].length()-1]==\\'u\\')){\\n                v[i+1] = 1;\\n            }\\n            v[i+1] += v[i];\\n        }\\n        vector<int> ans;\\n        for(auto &i: queries){\\n            ans.push_back(v[i[1]+1]-v[i[0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        vector<int> v(n+1,0);\\n        for(int i = 0; i < n; i++){\\n            if((words[i][0]==\\'a\\'||words[i][0]==\\'e\\'||words[i][0]==\\'i\\'||words[i][0]==\\'o\\'||words[i][0]==\\'u\\')&&(words[i][words[i].length()-1]==\\'a\\'||words[i][words[i].length()-1]==\\'e\\'||words[i][words[i].length()-1]==\\'i\\'||words[i][words[i].length()-1]==\\'o\\'||words[i][words[i].length()-1]==\\'u\\')){\\n                v[i+1] = 1;\\n            }\\n            v[i+1] += v[i];\\n        }\\n        vector<int> ans;\\n        for(auto &i: queries){\\n            ans.push_back(v[i[1]+1]-v[i[0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224858,
                "title": "segment-tree-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int build(int n,int i,int j,vector<int> &v,vector<int> &tree){\\n        if(i==j){\\n            tree[n] = v[i];\\n            return tree[n];\\n        }\\n        int mid = (j-i)/2+i;\\n        int left = build(n*2+1,i,mid,v,tree);\\n        int right = build(n*2+2,mid+1,j,v,tree);\\n        return tree[n] = left+right;\\n    }\\n    int query(int l,int r,int n,vector<int> &tree,int i,int j){\\n        if(r<i||l>j)return 0;\\n        if(l<=i&&r>=j)return tree[n];\\n        int mid = (j-i)/2+i;\\n        int left = query(l,r,2*n+1,tree,i,mid);\\n        int right = query(l,r,2*n+2,tree,mid+1,j);\\n        return left+right;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> v;\\n        for(auto &i: words){\\n            v.push_back((i[i.length()-1]==\\'a\\'||i[i.length()-1]==\\'o\\'||i[i.length()-1]==\\'i\\'||i[i.length()-1]==\\'e\\'||i[i.length()-1]==\\'u\\')&&(i[0]==\\'a\\'||i[0]==\\'e\\'||i[0]==\\'o\\'||i[0]==\\'i\\'||i[0]==\\'u\\'));\\n        }\\n        // for(auto &i: v)cout<<i<<\" \";\\n        int n = v.size();\\n        vector<int> tree(n*4,0);\\n        \\n        build(0,0,n-1,v,tree);\\n        v.clear();\\n        for(auto &i: queries){\\n            v.push_back(query(i[0],i[1],0,tree,0,n-1));\\n        }return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int build(int n,int i,int j,vector<int> &v,vector<int> &tree){\\n        if(i==j){\\n            tree[n] = v[i];\\n            return tree[n];\\n        }\\n        int mid = (j-i)/2+i;\\n        int left = build(n*2+1,i,mid,v,tree);\\n        int right = build(n*2+2,mid+1,j,v,tree);\\n        return tree[n] = left+right;\\n    }\\n    int query(int l,int r,int n,vector<int> &tree,int i,int j){\\n        if(r<i||l>j)return 0;\\n        if(l<=i&&r>=j)return tree[n];\\n        int mid = (j-i)/2+i;\\n        int left = query(l,r,2*n+1,tree,i,mid);\\n        int right = query(l,r,2*n+2,tree,mid+1,j);\\n        return left+right;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> v;\\n        for(auto &i: words){\\n            v.push_back((i[i.length()-1]==\\'a\\'||i[i.length()-1]==\\'o\\'||i[i.length()-1]==\\'i\\'||i[i.length()-1]==\\'e\\'||i[i.length()-1]==\\'u\\')&&(i[0]==\\'a\\'||i[0]==\\'e\\'||i[0]==\\'o\\'||i[0]==\\'i\\'||i[0]==\\'u\\'));\\n        }\\n        // for(auto &i: v)cout<<i<<\" \";\\n        int n = v.size();\\n        vector<int> tree(n*4,0);\\n        \\n        build(0,0,n-1,v,tree);\\n        v.clear();\\n        for(auto &i: queries){\\n            v.push_back(query(i[0],i[1],0,tree,0,n-1));\\n        }return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3160401,
                "title": "python-easy-solution-beats-96-95-solutions-prefix-sum",
                "content": "# Python Easy Solution||Prefix Sum||Beats 96.95% Solutions\\n\\n# Approach\\nPreProcess and create the prefix sum array of count of valid words.Valid Words are those words which starts with vowel and ends with vowel.\\n\\nThen Easily iterate through given queries array and calculate the count of valid words in given range using prefix sum array.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        ##### PreProcessing:- Creating prefix sum array of count of valid words\\n        \\n        d={\"a\":1,\"e\":1,\"i\":1,\"o\":1,\"u\":1}\\n        preProcess=[0]*(len(words)+1)\\n        count=0\\n        for i in range(len(words)):\\n            if words[i][0] in d and words[i][-1] in d:\\n                count+=1\\n            preProcess[i+1]=count      \\n        \\n        #### Main Method  #####\\n\\n        ans=[]\\n        for i in range(len(queries)):\\n            start=queries[i][0]\\n            end=queries[i][1]\\n            count=preProcess[end+1]-preProcess[start]\\n            ans.append(count)\\n        return ans          \\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        ##### PreProcessing:- Creating prefix sum array of count of valid words\\n        \\n        d={\"a\":1,\"e\":1,\"i\":1,\"o\":1,\"u\":1}\\n        preProcess=[0]*(len(words)+1)\\n        count=0\\n        for i in range(len(words)):\\n            if words[i][0] in d and words[i][-1] in d:\\n                count+=1\\n            preProcess[i+1]=count      \\n        \\n        #### Main Method  #####\\n\\n        ans=[]\\n        for i in range(len(queries)):\\n            start=queries[i][0]\\n            end=queries[i][1]\\n            count=preProcess[end+1]-preProcess[start]\\n            ans.append(count)\\n        return ans          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144418,
                "title": "c-easy-to-understand-prefix-sum",
                "content": "# Intuition\\nWe have to take record of each traversal so that we have not to repeat query for same string.\\n\\n# Approach\\nPrefix Sum\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool fun(vector<string>&  words,int i){\\n    \\n            char c1=words[i][0],c2=words[i][words[i].length()-1];\\n            if((c1==\\'a\\' || c1==\\'e\\' || c1==\\'i\\' || c1==\\'o\\' || c1==\\'u\\' ) && (c2==\\'a\\' || c2==\\'e\\' || c2==\\'i\\' || c2==\\'o\\' || c2==\\'u\\' ))\\n                return true;\\n            else\\n            return false;\\n    }\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& q) {\\n        vector<int> ans(q.size(),0);\\n        vector<int> v(words.size()+1);\\n        v[0]=0;\\n        for(int i=1;i<=words.size();i++){\\n            if(fun(words,i-1))\\n                v[i]=v[i-1]+1;          //equation for prefix sum\\n            else\\n                v[i]=v[i-1];\\n        }\\n        for(int i=0;i<q.size();i++){\\n            int s=q[i][0],e=q[i][1];\\n            ans[i]=v[e+1]-v[s];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool fun(vector<string>&  words,int i){\\n    \\n            char c1=words[i][0],c2=words[i][words[i].length()-1];\\n            if((c1==\\'a\\' || c1==\\'e\\' || c1==\\'i\\' || c1==\\'o\\' || c1==\\'u\\' ) && (c2==\\'a\\' || c2==\\'e\\' || c2==\\'i\\' || c2==\\'o\\' || c2==\\'u\\' ))\\n                return true;\\n            else\\n            return false;\\n    }\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& q) {\\n        vector<int> ans(q.size(),0);\\n        vector<int> v(words.size()+1);\\n        v[0]=0;\\n        for(int i=1;i<=words.size();i++){\\n            if(fun(words,i-1))\\n                v[i]=v[i-1]+1;          //equation for prefix sum\\n            else\\n                v[i]=v[i-1];\\n        }\\n        for(int i=0;i<q.size();i++){\\n            int s=q[i][0],e=q[i][1];\\n            ans[i]=v[e+1]-v[s];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143935,
                "title": "c-most-easy-solution-using-prefix-array",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size();\\n        vector<int> pref(n+1,0);\\n        vector<int> ans;\\n        unordered_set<char> st;\\n        st.insert(\\'a\\');\\n        st.insert(\\'e\\');\\n        st.insert(\\'i\\');\\n        st.insert(\\'o\\');\\n        st.insert(\\'u\\');\\n        int y=words[0].size();\\n        if(st.find(words[0][0])!=st.end() and st.find(words[0][y-1])!=st.end())\\n            pref[1]=1;\\n        for(int i=1;i<words.size();i++)\\n        {\\n            int sz=words[i].size();\\n           if(st.find(words[i][0])!=st.end() and st.find(words[i][sz-1])!=st.end())\\n               pref[i+1]=1;\\n            pref[i+1]+=pref[i];\\n        }\\n        for(auto it:queries)\\n        {\\n            ans.push_back(pref[it[1]+1]-pref[it[0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size();\\n        vector<int> pref(n+1,0);\\n        vector<int> ans;\\n        unordered_set<char> st;\\n        st.insert(\\'a\\');\\n        st.insert(\\'e\\');\\n        st.insert(\\'i\\');\\n        st.insert(\\'o\\');\\n        st.insert(\\'u\\');\\n        int y=words[0].size();\\n        if(st.find(words[0][0])!=st.end() and st.find(words[0][y-1])!=st.end())\\n            pref[1]=1;\\n        for(int i=1;i<words.size();i++)\\n        {\\n            int sz=words[i].size();\\n           if(st.find(words[i][0])!=st.end() and st.find(words[i][sz-1])!=st.end())\\n               pref[i+1]=1;\\n            pref[i+1]+=pref[i];\\n        }\\n        for(auto it:queries)\\n        {\\n            ans.push_back(pref[it[1]+1]-pref[it[0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143898,
                "title": "easy-c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char x)\\n    {\\n       return x == \\'a\\' || x == \\'e\\' || x == \\'i\\' || x == \\'o\\' || x == \\'u\\';\\n        \\n    }\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) \\n    {\\n        int n = queries.size();\\n        int len = words.size();\\n        vector<int > res; \\n        int pre[len]; \\n \\n\\n    if (isVowel(words[0][0]) && isVowel(words[0][words[0].size()-1])) \\n        pre[0] = 1; \\n\\n    else \\n        pre[0] = 0; \\n\\n\\n    for (int i = 1; i < len; i++)\\n    {\\n        if (isVowel(words[i][0]) && \\n         isVowel(words[i][words[i].size()-1])) \\n            pre[i] = 1 + pre[i - 1];\\n\\n        else\\n            pre[i] = pre[i - 1]; \\n\\n    }\\n        \\n    for(int i=0; i<queries.size(); i++)\\n    {\\n      if(queries[i][0] == 0)\\n      {\\n         res.push_back(pre[queries[i][1]]);\\n      }\\n        \\n      else \\n     {\\n          int val = pre[queries[i][1]]\\n                - pre[queries[i][0]-1];\\n      res.push_back(val);\\n    }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nIf it helps , then Upvote please \\uD83D\\uDE0A\\uD83D\\uDE0A",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char x)\\n    {\\n       return x == \\'a\\' || x == \\'e\\' || x == \\'i\\' || x == \\'o\\' || x == \\'u\\';\\n        \\n    }\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) \\n    {\\n        int n = queries.size();\\n        int len = words.size();\\n        vector<int > res; \\n        int pre[len]; \\n \\n\\n    if (isVowel(words[0][0]) && isVowel(words[0][words[0].size()-1])) \\n        pre[0] = 1; \\n\\n    else \\n        pre[0] = 0; \\n\\n\\n    for (int i = 1; i < len; i++)\\n    {\\n        if (isVowel(words[i][0]) && \\n         isVowel(words[i][words[i].size()-1])) \\n            pre[i] = 1 + pre[i - 1];\\n\\n        else\\n            pre[i] = pre[i - 1]; \\n\\n    }\\n        \\n    for(int i=0; i<queries.size(); i++)\\n    {\\n      if(queries[i][0] == 0)\\n      {\\n         res.push_back(pre[queries[i][1]]);\\n      }\\n        \\n      else \\n     {\\n          int val = pre[queries[i][1]]\\n                - pre[queries[i][0]-1];\\n      res.push_back(val);\\n    }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143817,
                "title": "prefix-vs-segment-tree",
                "content": "**1. Prefix** \\n+ As counting includes `addition operation`, we can go for prefix precomputation also.\\n> [L , R] = [0, R] - [0, L - 1] \\n# C++\\n\\n    bool isvowel(char ch){\\n        return ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n    }\\n\\t\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        vector<int> pref(n);\\n        \\n        // precompute the count of strings till every index...\\n        for(int i = 0;i < n; ++i){\\n\\t\\t    pref[i] = isvowel(words[i][0]) && isvowel(words[i].back());\\n            if(i > 0) pref[i] += pref[i - 1];\\n\\t\\t}\\n        \\n        // Now for every query, get answer from prefix array for Ranges....\\n        vector<int> ans;\\n        ans.reserve(size(queries));\\n        for(auto x : queries){\\n            if(x[0] == 0) ans.push_back(pref[x[1]]);\\n            else ans.push_back(pref[x[1]] - pref[x[0] - 1]);\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n**2. Segment Tree**\\n+ Another way is Segment tree used to range queries.\\n# C++\\n     class segment{\\n        vector<int> tree;\\n     public:\\n        segment(int n){\\n            tree.resize(4 * n);\\n        }\\n        \\n        bool isvowel(char ch){\\n            return ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n        }\\n        \\n        // build tree -> [precompute count in range]\\n        void build(vector<string> &A, int node, int low, int high){\\n            if(low == high){\\n                if(isvowel(A[low][0]) && isvowel(A[low].back())) tree[node] = 1;\\n                return;\\n            }\\n            \\n            int mid = low + (high - low) / 2;\\n            build(A, 2 * node, low, mid);\\n            build(A, 2 * node + 1, mid + 1, high);\\n            tree[node] = tree[2 * node] + tree[2 * node + 1];\\n        }\\n        \\n        \\n        // Query  -> Returns count in given range\\n        int query(int node, int low, int high, int left, int right){\\n            // no overlap\\n            if(right < low || left > high) return 0;\\n            \\n            // complete overlap\\n            if(low >= left && high <= right) return tree[node];\\n            \\n            // partial overlap\\n            int mid = low + (high - low) / 2;\\n            int A = query(2 * node, low, mid, left, right);           // Returns count in given range\\n            int B = query(2 * node + 1, mid + 1, high, left, right);  // Returns count in given range\\n            return A + B;\\n        }\\n        \\n        bool isvowel(char ch){\\n            return ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n        }\\n        \\n    };\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        segment st(n);\\n        st.build(words, 1, 0, n - 1);\\n        vector<int> ans;\\n        for(auto x : queries)\\n            ans.push_back(st.query(1, 0, n - 1, x[0], x[1]));\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**1. Prefix** \\n+ As counting includes `addition operation`, we can go for prefix precomputation also.\\n> [L , R] = [0, R] - [0, L - 1] \\n# C++\\n\\n    bool isvowel(char ch){\\n        return ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n    }\\n\\t\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        vector<int> pref(n);\\n        \\n        // precompute the count of strings till every index...\\n        for(int i = 0;i < n; ++i){\\n\\t\\t    pref[i] = isvowel(words[i][0]) && isvowel(words[i].back());\\n            if(i > 0) pref[i] += pref[i - 1];\\n\\t\\t}\\n        \\n        // Now for every query, get answer from prefix array for Ranges....\\n        vector<int> ans;\\n        ans.reserve(size(queries));\\n        for(auto x : queries){\\n            if(x[0] == 0) ans.push_back(pref[x[1]]);\\n            else ans.push_back(pref[x[1]] - pref[x[0] - 1]);\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n**2. Segment Tree**\\n+ Another way is Segment tree used to range queries.\\n# C++\\n     class segment{\\n        vector<int> tree;\\n     public:\\n        segment(int n){\\n            tree.resize(4 * n);\\n        }\\n        \\n        bool isvowel(char ch){\\n            return ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n        }\\n        \\n        // build tree -> [precompute count in range]\\n        void build(vector<string> &A, int node, int low, int high){\\n            if(low == high){\\n                if(isvowel(A[low][0]) && isvowel(A[low].back())) tree[node] = 1;\\n                return;\\n            }\\n            \\n            int mid = low + (high - low) / 2;\\n            build(A, 2 * node, low, mid);\\n            build(A, 2 * node + 1, mid + 1, high);\\n            tree[node] = tree[2 * node] + tree[2 * node + 1];\\n        }\\n        \\n        \\n        // Query  -> Returns count in given range\\n        int query(int node, int low, int high, int left, int right){\\n            // no overlap\\n            if(right < low || left > high) return 0;\\n            \\n            // complete overlap\\n            if(low >= left && high <= right) return tree[node];\\n            \\n            // partial overlap\\n            int mid = low + (high - low) / 2;\\n            int A = query(2 * node, low, mid, left, right);           // Returns count in given range\\n            int B = query(2 * node + 1, mid + 1, high, left, right);  // Returns count in given range\\n            return A + B;\\n        }\\n        \\n        bool isvowel(char ch){\\n            return ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n        }\\n        \\n    };\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        segment st(n);\\n        st.build(words, 1, 0, n - 1);\\n        vector<int> ans;\\n        for(auto x : queries)\\n            ans.push_back(st.query(1, 0, n - 1, x[0], x[1]));\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3143773,
                "title": "prefix-sum-preprocessing-well-explained-beginner-friendly-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust, after seeing the constraints  i.e., words.length==10^5\\nUsing brute force with two for loops gonna be a TLE. (10^5 * 10^5 > 10^8)\\nSo, got a conclusion that we can pre process the stuff of the given conditions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitially, we can just check whether the words are starting and ending with vowels. If it was, then we will just flagging with 1 in the pref array. \\nAnd then we will be performing summation of prefix sum array.\\nIn the end doing the required stuff.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N+M)$$\\nwhere N is words.length and M is queries.length\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\nwhere N is words.length and M is queries.length\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        String vowels=\"aeiou\";\\n        \\n        int[] pref=new int[words.length];\\n        //initially pref array contains 0 so o indicates false with not starting and ending with vowels.\\n        \\n        for(int i=0;i<words.length;i++)\\n        {\\n            String s=words[i];\\n            \\n            if(vowels.contains(\"\"+s.charAt(0))  && vowels.contains(\"\"+s.charAt(s.length()-1)))\\n            {\\n                // flagging with 1\\n                pref[i]=1;\\n            }\\n            \\n        }\\n        \\n        for(int i=1;i<pref.length;i++)\\n        {\\n            //prefix summation\\n            pref[i]=pref[i-1]+pref[i];\\n        }\\n        \\n        // System.out.println(Arrays.toString(pref));\\n        \\n        //result array\\n        int[] res=new int[queries.length];\\n        int ind=0;\\n        \\n        for(int[] t:queries)\\n        {\\n            int first=t[0];\\n            int last=t[1];\\n            \\n            int ans=0;\\n\\n            // checking for out of bound case\\n            if(first==0)\\n            {\\n                ans=pref[last];\\n            }\\n            else\\n            {\\n                //Here the queries range is included [first,last] so we need to include first index\\n                ans=pref[last]-pref[first-1];\\n            }\\n            \\n            res[ind++]=ans;\\n            \\n            \\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n}\\n```\\n\\n![upvotecat.jpg](https://assets.leetcode.com/users/images/9aaafe3f-8ea5-47da-85d3-f8e9671c87cc_1675569149.846279.jpeg)",
                "solutionTags": [
                    "Java",
                    "String",
                    "Interactive",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        String vowels=\"aeiou\";\\n        \\n        int[] pref=new int[words.length];\\n        //initially pref array contains 0 so o indicates false with not starting and ending with vowels.\\n        \\n        for(int i=0;i<words.length;i++)\\n        {\\n            String s=words[i];\\n            \\n            if(vowels.contains(\"\"+s.charAt(0))  && vowels.contains(\"\"+s.charAt(s.length()-1)))\\n            {\\n                // flagging with 1\\n                pref[i]=1;\\n            }\\n            \\n        }\\n        \\n        for(int i=1;i<pref.length;i++)\\n        {\\n            //prefix summation\\n            pref[i]=pref[i-1]+pref[i];\\n        }\\n        \\n        // System.out.println(Arrays.toString(pref));\\n        \\n        //result array\\n        int[] res=new int[queries.length];\\n        int ind=0;\\n        \\n        for(int[] t:queries)\\n        {\\n            int first=t[0];\\n            int last=t[1];\\n            \\n            int ans=0;\\n\\n            // checking for out of bound case\\n            if(first==0)\\n            {\\n                ans=pref[last];\\n            }\\n            else\\n            {\\n                //Here the queries range is included [first,last] so we need to include first index\\n                ans=pref[last]-pref[first-1];\\n            }\\n            \\n            res[ind++]=ans;\\n            \\n            \\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022567,
                "title": "count-vowel-strings-o-n-javascript-memory-91-30-meaningful-vars",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(N)\\n```\\nconst vowels = { a: true, e: true, i: true, o: true, u: true };\\nvar vowelStrings = function(words, queries) {\\n    for (let index = 0; index < words.length; index++) {\\n        if (vowels[words[index][0]] && vowels[words[index][words[index].length - 1]]) {\\n            if (!index) {\\n                words[index] = 1;\\n            } else {\\n                words[index] = 1 + words[index - 1];\\n            }\\n        } else {\\n            if (!index) {\\n                words[index] = 0;\\n            } else {\\n                words[index] = words[index - 1];\\n            }\\n        }\\n    }\\n    const output = [];\\n    for (let index = 0; index < queries.length; index++) {\\n        const [startIndex, endIndex] = queries[index];\\n        let len = words[endIndex] - (words[startIndex - 1] || 0);\\n        output.push(len);\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst vowels = { a: true, e: true, i: true, o: true, u: true };\\nvar vowelStrings = function(words, queries) {\\n    for (let index = 0; index < words.length; index++) {\\n        if (vowels[words[index][0]] && vowels[words[index][words[index].length - 1]]) {\\n            if (!index) {\\n                words[index] = 1;\\n            } else {\\n                words[index] = 1 + words[index - 1];\\n            }\\n        } else {\\n            if (!index) {\\n                words[index] = 0;\\n            } else {\\n                words[index] = words[index - 1];\\n            }\\n        }\\n    }\\n    const output = [];\\n    for (let index = 0; index < queries.length; index++) {\\n        const [startIndex, endIndex] = queries[index];\\n        let len = words[endIndex] - (words[startIndex - 1] || 0);\\n        output.push(len);\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596599,
                "title": "well-explained-99-24-efficient-java-sol",
                "content": "# Intuition\\n    So well , in this question , they have asked us to find the number of vowel\\n    strings in the given ranges.\\n    A vowel string here in this problem is defined as a String that starts and \\n    ends with an vowel.\\n\\n    So that\\'s all about the problem , it is being asked to return the number of\\n    such substrings.\\n\\n# Approach\\n    This is a classy prefix sum problem .\\n    1) \\u2B07\\uFE0F\\n    At the very first step , as I have explained in the intution abt the \\n    strings that we CAN consider to be valid , we need to create a function\\n    that accept a string and check if its first and last characters are valid \\n\\n    2) Here we create a prefix array , and increase the val of the prefix while \\n    iterating over the String[]words and increase the prefix score if we found a \\n    valid string \\n\\n    After that create a Array of size queries.legnth that stores the ans \\n    at i-th index for the i-th query .\\n\\n    Iterate over all the arrays in the queries and here we have simple 2 \\n    cases \\n\\n    Case 1 ) The left bound is zero \\n            If the left bound is zero , return the ans to query as \\n            prefix_arr[high_bound]\\n    Case 2 ) The left bounf is not zero   \\n            Return the answer as\\n            prefix_arr[high_bound]-prefix_arr[left_bound]\\n    \\n    \\n\\n# Complexity\\n- Time complexity:\\n    O(N + M) , N for Words.length and M for queries.length \\n- Space complexity\\n    Same as time complexity .\\n# Code\\n```\\nclass Solution {\\n    // this function returns true if both first and last characters of the\\n    // string is a vowel.\\n    static boolean valid_word(String s) {\\n\\t\\tchar c_start = s.charAt(0);\\n\\t\\tchar c_end = s.charAt(s.length()-1);\\n\\t\\tboolean flag1 = (c_start==\\'a\\'||c_start==\\'e\\'||c_start==\\'i\\'||c_start==\\'o\\'||c_start==\\'u\\')?true:false;\\n\\t\\tboolean flag2 = (c_end==\\'a\\'||c_end==\\'e\\'||c_end==\\'i\\'||c_end==\\'o\\'||c_end==\\'u\\')?true:false;\\n\\t\\treturn flag1&&flag2;\\n\\t}\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int[] prefix_arr = new int[words.length]; // inits the prefix array\\n\\t\\tprefix_arr[0] = valid_word(words[0]) ? 1  : 0; // if 1 words is returned \\n        // as true , then set the default val as 1 else zero\\n\\t\\t\\n\\t\\tfor(int i=1;i<words.length;++i) {\\n\\t\\t\\tif(valid_word(words[i])) {prefix_arr[i]=prefix_arr[i-1]+1;}\\n\\t\\t\\telse {prefix_arr[i]=prefix_arr[i-1];}\\n\\t\\t}\\n\\t\\t// so in this way we have created our prefix arr \\u2B06\\uFE0F  \\n\\n        // explained these steps below in the appoach section \\n\\t\\tint[]res = new int[queries.length];\\n\\t\\tfor(int i=0;i<queries.length;++i) {\\n\\t\\t\\tint upper_bound = queries[i][1] , lower_bound = queries[i][0];\\n\\t\\t\\tint val = (lower_bound==0) ? prefix_arr[upper_bound] : prefix_arr[upper_bound]-prefix_arr[lower_bound-1];\\n\\t\\t\\tres[i] = val;\\n\\t\\t}\\n\\t\\treturn res;\\n        \\n        // DO UPVOTE \\uD83D\\uDE01\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    // this function returns true if both first and last characters of the\\n    // string is a vowel.\\n    static boolean valid_word(String s) {\\n\\t\\tchar c_start = s.charAt(0);\\n\\t\\tchar c_end = s.charAt(s.length()-1);\\n\\t\\tboolean flag1 = (c_start==\\'a\\'||c_start==\\'e\\'||c_start==\\'i\\'||c_start==\\'o\\'||c_start==\\'u\\')?true:false;\\n\\t\\tboolean flag2 = (c_end==\\'a\\'||c_end==\\'e\\'||c_end==\\'i\\'||c_end==\\'o\\'||c_end==\\'u\\')?true:false;\\n\\t\\treturn flag1&&flag2;\\n\\t}\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int[] prefix_arr = new int[words.length]; // inits the prefix array\\n\\t\\tprefix_arr[0] = valid_word(words[0]) ? 1  : 0; // if 1 words is returned \\n        // as true , then set the default val as 1 else zero\\n\\t\\t\\n\\t\\tfor(int i=1;i<words.length;++i) {\\n\\t\\t\\tif(valid_word(words[i])) {prefix_arr[i]=prefix_arr[i-1]+1;}\\n\\t\\t\\telse {prefix_arr[i]=prefix_arr[i-1];}\\n\\t\\t}\\n\\t\\t// so in this way we have created our prefix arr \\u2B06\\uFE0F  \\n\\n        // explained these steps below in the appoach section \\n\\t\\tint[]res = new int[queries.length];\\n\\t\\tfor(int i=0;i<queries.length;++i) {\\n\\t\\t\\tint upper_bound = queries[i][1] , lower_bound = queries[i][0];\\n\\t\\t\\tint val = (lower_bound==0) ? prefix_arr[upper_bound] : prefix_arr[upper_bound]-prefix_arr[lower_bound-1];\\n\\t\\t\\tres[i] = val;\\n\\t\\t}\\n\\t\\treturn res;\\n        \\n        // DO UPVOTE \\uD83D\\uDE01\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248622,
                "title": "prefix-sum-hashtable-easy-c-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> vowelStrings(vector<string> &words, vector<vector< int>> &q)\\n        {\\n           \\tunordered_set<char> s={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n            const int maxsize = 1e5 + 1;\\n            int arr[maxsize] = { 0 };\\n            for (int i = 0; i < words.size(); i++)\\n            {\\n                if (s.find(words[i].front()) != s.end() and s.find(words[i].back()) != s.end())//checking condition for the word to begin and end with a vowel.\\n                    arr[i] = 1;\\n\\n                if (i != 0)//calculating prefix sum to get range query answer in const time.\\n                    arr[i] = arr[i] + arr[i - 1];\\n            }\\n            vector<int> ans;\\n            for (int i = 0; i < q.size(); i++)//calculating answer for each query.\\n            {\\n                if (q[i][0] == 0)\\n                    ans.push_back(arr[q[i][1]]);\\n                else\\n                    ans.push_back(arr[q[i][1]] - arr[q[i][0] - 1]);\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> vowelStrings(vector<string> &words, vector<vector< int>> &q)\\n        {\\n           \\tunordered_set<char> s={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n            const int maxsize = 1e5 + 1;\\n            int arr[maxsize] = { 0 };\\n            for (int i = 0; i < words.size(); i++)\\n            {\\n                if (s.find(words[i].front()) != s.end() and s.find(words[i].back()) != s.end())//checking condition for the word to begin and end with a vowel.\\n                    arr[i] = 1;\\n\\n                if (i != 0)//calculating prefix sum to get range query answer in const time.\\n                    arr[i] = arr[i] + arr[i - 1];\\n            }\\n            vector<int> ans;\\n            for (int i = 0; i < q.size(); i++)//calculating answer for each query.\\n            {\\n                if (q[i][0] == 0)\\n                    ans.push_back(arr[q[i][1]]);\\n                else\\n                    ans.push_back(arr[q[i][1]] - arr[q[i][0] - 1]);\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158296,
                "title": "python-straightforward-solution-with-prefix-sum",
                "content": "\\n# Code\\n```python\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        vowels = \\'aeiou\\'\\n        counts = [0] * len(words)\\n        for i, word in enumerate(words):\\n            if word[0] in vowels and word[-1] in vowels:\\n                counts[i] = 1\\n        acc = list(accumulate(counts, initial=0))\\n        res = []\\n        for l, r in queries:\\n            res.append(acc[r + 1] - acc[l])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        vowels = \\'aeiou\\'\\n        counts = [0] * len(words)\\n        for i, word in enumerate(words):\\n            if word[0] in vowels and word[-1] in vowels:\\n                counts[i] = 1\\n        acc = list(accumulate(counts, initial=0))\\n        res = []\\n        for l, r in queries:\\n            res.append(acc[r + 1] - acc[l])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152435,
                "title": "javascript-beats-100",
                "content": "\\n\\n# Code\\n```\\nvar vowelStrings = function(words, queries) {\\n    let pref = new Array(words.length+1).fill(0);\\n    let i=0;\\n    for(let x of words){\\n        pref[i+1]=pref[i]+(isVowel(x[0]) && isVowel(x[x.length-1]));\\n        i++;\\n    }\\n    let ans = [];\\n    for (let i = 0; i < queries.length; i++) {\\n        ans.push(pref[queries[i][1] + 1] - pref[queries[i][0]]);\\n    }\\n    return ans;\\n};\\n\\nfunction isVowel(x)\\n{\\n    if (x == \\'a\\' || x == \\'e\\' || x == \\'i\\' ||\\n        x == \\'o\\' || x == \\'u\\' || x == \\'A\\' ||\\n        x == \\'E\\' || x == \\'I\\' || x == \\'O\\' || x == \\'U\\')\\n        return true;\\n    else\\n        return false;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar vowelStrings = function(words, queries) {\\n    let pref = new Array(words.length+1).fill(0);\\n    let i=0;\\n    for(let x of words){\\n        pref[i+1]=pref[i]+(isVowel(x[0]) && isVowel(x[x.length-1]));\\n        i++;\\n    }\\n    let ans = [];\\n    for (let i = 0; i < queries.length; i++) {\\n        ans.push(pref[queries[i][1] + 1] - pref[queries[i][0]]);\\n    }\\n    return ans;\\n};\\n\\nfunction isVowel(x)\\n{\\n    if (x == \\'a\\' || x == \\'e\\' || x == \\'i\\' ||\\n        x == \\'o\\' || x == \\'u\\' || x == \\'A\\' ||\\n        x == \\'E\\' || x == \\'I\\' || x == \\'O\\' || x == \\'U\\')\\n        return true;\\n    else\\n        return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3149305,
                "title": "python-3-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        d={}\\n        for x in range(97,123):\\n            d[chr(x)]=0\\n        d[\"a\"]=1\\n        d[\"e\"]=1\\n        d[\"i\"]=1\\n        d[\"o\"]=1\\n        d[\\'u\\']=1\\n        le=len(words)\\n        l=[0]*len(words)\\n        y=0\\n        for x in words:\\n            if d[x[0]]==1 and d[x[-1]]==1:\\n                l[y]=1\\n            y+=1\\n        p_sum=[0]*len(words)\\n        prefix=0\\n        for x in range(len(l)):\\n            prefix+=l[x]\\n            p_sum[x]=prefix\\n        print(p_sum)\\n        l=[]\\n        for x in range(0,len(queries)):\\n            c=queries[x][1]\\n            d=queries[x][0]\\n            if queries[x][0]==0:\\n                l.append(p_sum[c])\\n            else:\\n                l.append(p_sum[c]-p_sum[d-1])\\n        return l\\n\\n        \\n\\n\\n            \\n                \\n\\n            \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        d={}\\n        for x in range(97,123):\\n            d[chr(x)]=0\\n        d[\"a\"]=1\\n        d[\"e\"]=1\\n        d[\"i\"]=1\\n        d[\"o\"]=1\\n        d[\\'u\\']=1\\n        le=len(words)\\n        l=[0]*len(words)\\n        y=0\\n        for x in words:\\n            if d[x[0]]==1 and d[x[-1]]==1:\\n                l[y]=1\\n            y+=1\\n        p_sum=[0]*len(words)\\n        prefix=0\\n        for x in range(len(l)):\\n            prefix+=l[x]\\n            p_sum[x]=prefix\\n        print(p_sum)\\n        l=[]\\n        for x in range(0,len(queries)):\\n            c=queries[x][1]\\n            d=queries[x][0]\\n            if queries[x][0]==0:\\n                l.append(p_sum[c])\\n            else:\\n                l.append(p_sum[c]-p_sum[d-1])\\n        return l\\n\\n        \\n\\n\\n            \\n                \\n\\n            \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147684,
                "title": "easy-to-understand-solution-beats-100-prefixsum-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCalculating the prefix sum as number of string contaning vowels upto i th index.\\nThen calclating the queries [a,b] as prefix[b]-prefix[a];\\n\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n) for traversing on the queries and words array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n) for storing prefix sum.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool chk(string& s){\\n        unordered_set<char>st={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        if(st.find(s[0])!=st.end() and st.find(s[s.size()-1])!=st.end()) return true;\\n        return false;\\n    }\\n\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<vector<int>>tmp;   \\n        // storing prefix as prefix_sum and also storing that current string is vowel or not. \\n        //{perfix_sum,is_vowel};\\n        \\n        int pre=0;\\n        for(auto i : words){  \\n            if(chk(i)){\\n                pre+=1;\\n                tmp.push_back({pre,1});\\n            }else{\\n                tmp.push_back({pre,0});\\n            }\\n        }    \\n        int k=0;\\n\\n        vector<int>ans;\\n        for(auto i : queries){\\n            int a = i[0],b=i[1];\\n            \\n            if(tmp[a][1]==0){\\n                ans.push_back(tmp[b][0]-tmp[a][0]);\\n            }\\n            else if(tmp[a][1]==1){\\n                ans.push_back(tmp[b][0]-tmp[a][0]+1);\\n                //adding +1 because the first string of queries [a,b] is vowel.\\n                // so to include the ath index string we add +1.\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n\\n// 1 2 3\\n// 0 1 2\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool chk(string& s){\\n        unordered_set<char>st={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        if(st.find(s[0])!=st.end() and st.find(s[s.size()-1])!=st.end()) return true;\\n        return false;\\n    }\\n\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<vector<int>>tmp;   \\n        // storing prefix as prefix_sum and also storing that current string is vowel or not. \\n        //{perfix_sum,is_vowel};\\n        \\n        int pre=0;\\n        for(auto i : words){  \\n            if(chk(i)){\\n                pre+=1;\\n                tmp.push_back({pre,1});\\n            }else{\\n                tmp.push_back({pre,0});\\n            }\\n        }    \\n        int k=0;\\n\\n        vector<int>ans;\\n        for(auto i : queries){\\n            int a = i[0],b=i[1];\\n            \\n            if(tmp[a][1]==0){\\n                ans.push_back(tmp[b][0]-tmp[a][0]);\\n            }\\n            else if(tmp[a][1]==1){\\n                ans.push_back(tmp[b][0]-tmp[a][0]+1);\\n                //adding +1 because the first string of queries [a,b] is vowel.\\n                // so to include the ath index string we add +1.\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n\\n// 1 2 3\\n// 0 1 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146832,
                "title": "java-prefix-sum-15-lines-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount vowel strings as 1 and other strings as 0. Compute a prefix sum array for all the strings. For each of the queries compute the answer as the difference of the prefix sums between the ending and starting words.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n + m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  private boolean isVowel(char c) {\\n    return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n  }\\n  \\n  public int[] vowelStrings(String[] words, int[][] queries) {\\n    var n = queries.length;\\n    var m = words.length;\\n    var count = new int[m+1];\\n    var sum = 0;\\n    \\n    for (var i=0; i<m; i++) {\\n      if (isVowel(words[i].charAt(0))\\n          && isVowel(words[i].charAt(words[i].length() - 1)))\\n        sum++;\\n      \\n      count[i+1] = sum;\\n    }\\n    var ans = new int[n];\\n    \\n    for (var i=0; i<n; i++)\\n      ans[i] = count[queries[i][1] + 1] - count[queries[i][0]];\\n    \\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n  private boolean isVowel(char c) {\\n    return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n  }\\n  \\n  public int[] vowelStrings(String[] words, int[][] queries) {\\n    var n = queries.length;\\n    var m = words.length;\\n    var count = new int[m+1];\\n    var sum = 0;\\n    \\n    for (var i=0; i<m; i++) {\\n      if (isVowel(words[i].charAt(0))\\n          && isVowel(words[i].charAt(words[i].length() - 1)))\\n        sum++;\\n      \\n      count[i+1] = sum;\\n    }\\n    var ans = new int[n];\\n    \\n    for (var i=0; i<n; i++)\\n      ans[i] = count[queries[i][1] + 1] - count[queries[i][0]];\\n    \\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146458,
                "title": "java-easy-to-understand-array-and-loop-only",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int[] ans=new int[queries.length];\\n        int[] str=new int[words.length];\\n        for(int i=0;i<words.length;i++){\\n            str[i]=check(words[i]);\\n        }\\n\\n        for(int i=0;i < queries.length;i++){\\n            int sum=0;\\n            int x= queries[i][0];\\n            int y=queries[i][1];\\n            for(int j=x;j<=y;j++){\\n                sum += str[j];\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n    public int check(String word){\\n        char f=word.charAt(0);\\n        char l=word.charAt(word.length()-1);\\n        if((f == \\'a\\' || f == \\'e\\' || f == \\'i\\' || f == \\'o\\' || f == \\'u\\') && (l == \\'a\\' || l == \\'e\\' || l == \\'i\\' || l == \\'o\\' || l == \\'u\\')){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int[] ans=new int[queries.length];\\n        int[] str=new int[words.length];\\n        for(int i=0;i<words.length;i++){\\n            str[i]=check(words[i]);\\n        }\\n\\n        for(int i=0;i < queries.length;i++){\\n            int sum=0;\\n            int x= queries[i][0];\\n            int y=queries[i][1];\\n            for(int j=x;j<=y;j++){\\n                sum += str[j];\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n    public int check(String word){\\n        char f=word.charAt(0);\\n        char l=word.charAt(word.length()-1);\\n        if((f == \\'a\\' || f == \\'e\\' || f == \\'i\\' || f == \\'o\\' || f == \\'u\\') && (l == \\'a\\' || l == \\'e\\' || l == \\'i\\' || l == \\'o\\' || l == \\'u\\')){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145608,
                "title": "javascript-prefix-running-sum",
                "content": "```\\nvar vowelStrings = function(words, queries) {\\n    \\n    const vowels = new Set([\\'a\\', \\'e\\', \\'i\\', \\'o\\',\\'u\\']);\\n    \\n    let running = [0];\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        \\n        const word = words[i], last = running[i], counts = vowels.has(word[0]) && vowels.has(word[word.length - 1]);\\n        \\n        running.push(last + (counts ? 1 : 0));\\n    }\\n    \\n    let ans = [];\\n    \\n    for(const [start, end] of queries) {\\n        ans.push(running[end + 1] - running[start]);\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\nvar vowelStrings = function(words, queries) {\\n    \\n    const vowels = new Set([\\'a\\', \\'e\\', \\'i\\', \\'o\\',\\'u\\']);\\n    \\n    let running = [0];\\n    \\n    for(let i = 0; i < words.length; i++) {\\n        \\n        const word = words[i], last = running[i], counts = vowels.has(word[0]) && vowels.has(word[word.length - 1]);\\n        \\n        running.push(last + (counts ? 1 : 0));\\n    }\\n    \\n    let ans = [];\\n    \\n    for(const [start, end] of queries) {\\n        ans.push(running[end + 1] - running[start]);\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3144436,
                "title": "prefix-sum-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        Set<Character> hs = new HashSet<>(Arrays.asList(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'));\\n        boolean[] arb = new boolean[words.length];\\n        int idx=0;\\n        for(String s:words){\\n            if(hs.contains(s.charAt(0))&&hs.contains(s.charAt(s.length()-1))){\\n                arb[idx]=true;\\n            }\\n            idx++;\\n        }\\n        int[] prefix = new int[words.length];\\n        prefix[0]=arb[0]?1:0;\\n        for(int i=1;i<words.length;i++){\\n            prefix[i]=prefix[i-1]+(arb[i]?1:0);\\n        }\\n        int[] ans_array = new int[queries.length];\\n         for(int i=0;i<queries.length;i++){\\n            int f=queries[i][0];\\n            int l=queries[i][1];\\n            ans_array[i]=prefix[l]-(f==0?0:prefix[f-1]);\\n        }\\n        return ans_array;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        Set<Character> hs = new HashSet<>(Arrays.asList(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'));\\n        boolean[] arb = new boolean[words.length];\\n        int idx=0;\\n        for(String s:words){\\n            if(hs.contains(s.charAt(0))&&hs.contains(s.charAt(s.length()-1))){\\n                arb[idx]=true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3144031,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int ans[]=new int[queries.length];\\n        int d[]=new int[words.length];\\n        int k=0,i=1;\\n        String str=\"aeiou\";\\n        for(String s:words){\\n            if(i==1){\\n                if(str.contains(\"\"+s.charAt(0))&&str.contains(\"\"+s.charAt(s.length()-1)))d[k]=1;\\n                else d[k]=0;\\n                i=0;\\n            }else{\\n                if(str.contains(\"\"+s.charAt(0))&&str.contains(\"\"+s.charAt(s.length()-1)))d[k]=d[k-1]+1;\\n                else d[k]=d[k-1];\\n            }\\n            k++;\\n        }\\n       // System.out.println(Arrays.toString(d));\\n        for(int j=0;j<ans.length;j++)\\n        {\\n            int f=queries[j][0];\\n            int s=queries[j][1];\\n            if(f==0){\\n                ans[j]=d[s];\\n            }else{\\n                ans[j]=d[s]-d[f-1];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int ans[]=new int[queries.length];\\n        int d[]=new int[words.length];\\n        int k=0,i=1;\\n        String str=\"aeiou\";\\n        for(String s:words){\\n            if(i==1){\\n                if(str.contains(\"\"+s.charAt(0))&&str.contains(\"\"+s.charAt(s.length()-1)))d[k]=1;\\n                else d[k]=0;\\n                i=0;\\n            }else{\\n                if(str.contains(\"\"+s.charAt(0))&&str.contains(\"\"+s.charAt(s.length()-1)))d[k]=d[k-1]+1;\\n                else d[k]=d[k-1];\\n            }\\n            k++;\\n        }\\n       // System.out.println(Arrays.toString(d));\\n        for(int j=0;j<ans.length;j++)\\n        {\\n            int f=queries[j][0];\\n            int s=queries[j][1];\\n            if(f==0){\\n                ans[j]=d[s];\\n            }else{\\n                ans[j]=d[s]-d[f-1];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143880,
                "title": "prefix-sum-approach-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n         int n = words.length;\\n        int[] prefix = new int[n+1];\\n        for(int i=0; i<n; i++){\\n            prefix[i+1] = prefix[i] + (isVowel(words[i].charAt(0)) && isVowel(words[i].charAt(words[i].length()-1)) ? 1 : 0);\\n        }\\n        \\n        int[] res = new int[queries.length];\\n        for(int i=0; i<queries.length; i++){\\n             res[i] = prefix[queries[i][1]+1] - prefix[queries[i][0]];\\n        }\\n        return res;\\n    \\n    }\\n    public boolean isVowel(char vo){\\n        return vo == \\'a\\' || vo ==\\'e\\' || vo ==\\'i\\' || vo == \\'o\\' || vo ==\\'u\\';\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n         int n = words.length;\\n        int[] prefix = new int[n+1];\\n        for(int i=0; i<n; i++){\\n            prefix[i+1] = prefix[i] + (isVowel(words[i].charAt(0)) && isVowel(words[i].charAt(words[i].length()-1)) ? 1 : 0);\\n        }\\n        \\n        int[] res = new int[queries.length];\\n        for(int i=0; i<queries.length; i++){\\n             res[i] = prefix[queries[i][1]+1] - prefix[queries[i][0]];\\n        }\\n        return res;\\n    \\n    }\\n    public boolean isVowel(char vo){\\n        return vo == \\'a\\' || vo ==\\'e\\' || vo ==\\'i\\' || vo == \\'o\\' || vo ==\\'u\\';\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143864,
                "title": "cpp-easy-solution-using-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> preprocess(vector<string>& words) {\\n        set<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        vector<int> prefix(words.size());\\n        for (int i = 0; i < words.size(); i++) {\\n            if (vowels.count(words[i][0]) == 1 && vowels.count(words[i][words[i].length() - 1]) == 1) {\\n                prefix[i] = 1;\\n            }\\n        }\\n        for (int i = 1; i < prefix.size(); i++) {\\n            prefix[i] += prefix[i - 1];\\n        }\\n        return prefix;\\n    }\\n    \\n    int checker(vector<int> range, vector<int>& prefix) {\\n        if (range[0] == 0) {\\n            return prefix[range[1]];\\n        } else {\\n            return prefix[range[1]] - prefix[range[0] - 1];\\n        }\\n    }\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) { \\n        vector<int> prefix = preprocess(words);\\n        vector<int> ans;\\n        for (int i = 0; i < queries.size(); i++) {\\n            ans.push_back(checker(queries[i], prefix));\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> preprocess(vector<string>& words) {\\n        set<char> vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        vector<int> prefix(words.size());\\n        for (int i = 0; i < words.size(); i++) {\\n            if (vowels.count(words[i][0]) == 1 && vowels.count(words[i][words[i].length() - 1]) == 1) {\\n                prefix[i] = 1;\\n            }\\n        }\\n        for (int i = 1; i < prefix.size(); i++) {\\n            prefix[i] += prefix[i - 1];\\n        }\\n        return prefix;\\n    }\\n    \\n    int checker(vector<int> range, vector<int>& prefix) {\\n        if (range[0] == 0) {\\n            return prefix[range[1]];\\n        } else {\\n            return prefix[range[1]] - prefix[range[0] - 1];\\n        }\\n    }\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) { \\n        vector<int> prefix = preprocess(words);\\n        vector<int> ans;\\n        for (int i = 0; i < queries.size(); i++) {\\n            ans.push_back(checker(queries[i], prefix));\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143734,
                "title": "clean-simple-java",
                "content": "\\n```java []\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int acpt[] = new int[words.length];\\n        for(int i=0; i<words.length; i++)   acpt[i] = check(words[i]);\\n        for(int i=1; i<words.length; i++)   acpt[i] += acpt[i-1];\\n        int res[] = new int[queries.length];\\n        for(int i=0; i<queries.length; i++)\\n            res[i] = acpt[queries[i][1]]-(queries[i][0] == 0 ? 0 : acpt[queries[i][0]-1]);\\n        return res;\\n    }\\n    int check(String s){\\n        String v = \"aeiouAEIOU\";\\n        return v.contains(s.charAt(0)+\"\") && v.contains(s.charAt(s.length()-1)+\"\") ? 1 : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int acpt[] = new int[words.length];\\n        for(int i=0; i<words.length; i++)   acpt[i] = check(words[i]);\\n        for(int i=1; i<words.length; i++)   acpt[i] += acpt[i-1];\\n        int res[] = new int[queries.length];\\n        for(int i=0; i<queries.length; i++)\\n            res[i] = acpt[queries[i][1]]-(queries[i][0] == 0 ? 0 : acpt[queries[i][0]-1]);\\n        return res;\\n    }\\n    int check(String s){\\n        String v = \"aeiouAEIOU\";\\n        return v.contains(s.charAt(0)+\"\") && v.contains(s.charAt(s.length()-1)+\"\") ? 1 : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143728,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n    bool isVowel(const char&ch){\\n        return (ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\');\\n    }\\n    vector<int> vowelStrings(vector<string>&v, vector<vector<int>>&q) {\\n        ll n=v.size(), m=q.size();\\n        vi(ll)pre(n);\\n        pre[0]=isVowel(v[0][0]) && isVowel(v[0].back());\\n        for(ll i=1;i<n;++i){\\n            pre[i]=pre[i-1]+(isVowel(v[i][0]) && isVowel(v[i].back()));\\n        }\\n        vi(int)ans(m);\\n        for(ll i=0;i<m;++i){\\n            ll l=q[i][0], r=q[i][1];\\n            ans[i]=pre[r]-(l?pre[l-1]:0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n    bool isVowel(const char&ch){\\n        return (ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\');\\n    }\\n    vector<int> vowelStrings(vector<string>&v, vector<vector<int>>&q) {\\n        ll n=v.size(), m=q.size();\\n        vi(ll)pre(n);\\n        pre[0]=isVowel(v[0][0]) && isVowel(v[0].back());\\n        for(ll i=1;i<n;++i){\\n            pre[i]=pre[i-1]+(isVowel(v[i][0]) && isVowel(v[i].back()));\\n        }\\n        vi(int)ans(m);\\n        for(ll i=0;i<m;++i){\\n            ll l=q[i][0], r=q[i][1];\\n            ans[i]=pre[r]-(l?pre[l-1]:0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143683,
                "title": "prefixsum",
                "content": "**Cpp**\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isVowel(char ch) {\\n        \\n        return (ch == \\'a\\' or ch == \\'e\\' or ch == \\'i\\' or ch == \\'o\\' or ch == \\'u\\');\\n    }\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        \\n        int n(size(words));\\n        vector<int> prefix(n, 0);\\n        \\n        for (int i=0; i<n; i++) {\\n            prefix[i] = (i ? prefix[i-1] : 0) + (isVowel(words[i].front()) and isVowel(words[i].back()));\\n        }\\n        \\n        vector<int> ans;\\n        for (auto q : queries) {\\n            \\n            int x(q[0]), y(q[1]);\\n            ans.push_back((x == 0) ? prefix[y] : prefix[y]-prefix[x-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        \\n        n = len(words)\\n        prefix = [0]*n\\n\\t\\tvowels  = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        \\n        for i in range(n):\\n            prefix[i] = (prefix[i-1]  if i>0 else 0) + (words[i][0] in vowels and words[i][-1] in vowels)\\n        \\n        ans = []\\n        \\n        for q in queries:\\n            \\n            x, y = q[0], q[1]; \\n            ans.append(prefix[y] if (x == 0) else prefix[y]-prefix[x-1]);\\n        \\n        return ans;\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isVowel(char ch) {\\n        \\n        return (ch == \\'a\\' or ch == \\'e\\' or ch == \\'i\\' or ch == \\'o\\' or ch == \\'u\\');\\n    }\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        \\n        int n(size(words));\\n        vector<int> prefix(n, 0);\\n        \\n        for (int i=0; i<n; i++) {\\n            prefix[i] = (i ? prefix[i-1] : 0) + (isVowel(words[i].front()) and isVowel(words[i].back()));\\n        }\\n        \\n        vector<int> ans;\\n        for (auto q : queries) {\\n            \\n            int x(q[0]), y(q[1]);\\n            ans.push_back((x == 0) ? prefix[y] : prefix[y]-prefix[x-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        \\n        n = len(words)\\n        prefix = [0]*n\\n\\t\\tvowels  = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        \\n        for i in range(n):\\n            prefix[i] = (prefix[i-1]  if i>0 else 0) + (words[i][0] in vowels and words[i][-1] in vowels)\\n        \\n        ans = []\\n        \\n        for q in queries:\\n            \\n            x, y = q[0], q[1]; \\n            ans.append(prefix[y] if (x == 0) else prefix[y]-prefix[x-1]);\\n        \\n        return ans;\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361848,
                "title": "c-prefix-sum-4-cases",
                "content": "if my last sum presfix == current sum prefix (then no increment current-last)\\nif my last sum prefix < current sum prefix (then current-last+1)\\n\\nhandle two cases seperately\\n\\nwhen x is 0 i.e , ans will be prefix[y];\\n\\nwhen x == y ,ie ans can either be zero or one \\n    zero if last prefix sum == current prefix sum\\n    else 1\\n\\n# Code\\n```\\nclass Solution {\\n   public:\\n   vector < int > vowelStrings(vector < string > & words, vector < vector < int >> & queries) {\\n      vector < int > ans(words.size(),0);\\n      int tsum = 0;\\n      for (int s = 0; s < words.size(); s++) {\\n          \\n         if ((words[s][0] == \\'a\\' || words[s][0] == \\'e\\' || words[s][0] == \\'i\\' ||\\n               words[s][0] == \\'o\\' || words[s][0] == \\'u\\') &&\\n            (words[s][words[s].length() - 1] == \\'a\\' || words[s][words[s].length() - 1] == \\'e\\' || words[s][words[s].length() - 1] == \\'i\\' ||\\n               words[s][words[s].length() - 1] == \\'o\\' || words[s][words[s].length() - 1] == \\'u\\')) {\\n                   tsum+=1;\\n         }\\n         ans[s] = tsum;\\n      }\\n      vector<int> res;\\n      for(int i=0;i<queries.size();i++){\\n        int x = queries[i][0];\\n        int y = queries[i][1];\\n        if(x == 0){\\n            res.push_back(ans[y]);\\n        }else if(x == y){\\n            if(ans[x]>ans[x-1]){\\n                 res.push_back(ans[y] - ans[x] + 1);\\n            }else{\\n                 res.push_back(ans[y] - ans[x]);\\n            }\\n        }else if(ans[x]>ans[x-1]){\\n            res.push_back(ans[y] - ans[x] + 1);\\n            //res.push_back()\\n        }else if(ans[x] == ans[x-1]){\\n            res.push_back(ans[y] - ans[x]);\\n        }else{\\n\\n        }\\n\\n      \\n\\n\\n      }\\n      return res;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n   vector < int > vowelStrings(vector < string > & words, vector < vector < int >> & queries) {\\n      vector < int > ans(words.size(),0);\\n      int tsum = 0;\\n      for (int s = 0; s < words.size(); s++) {\\n          \\n         if ((words[s][0] == \\'a\\' || words[s][0] == \\'e\\' || words[s][0] == \\'i\\' ||\\n               words[s][0] == \\'o\\' || words[s][0] == \\'u\\') &&\\n            (words[s][words[s].length() - 1] == \\'a\\' || words[s][words[s].length() - 1] == \\'e\\' || words[s][words[s].length() - 1] == \\'i\\' ||\\n               words[s][words[s].length() - 1] == \\'o\\' || words[s][words[s].length() - 1] == \\'u\\')) {\\n                   tsum+=1;\\n         }\\n         ans[s] = tsum;\\n      }\\n      vector<int> res;\\n      for(int i=0;i<queries.size();i++){\\n        int x = queries[i][0];\\n        int y = queries[i][1];\\n        if(x == 0){\\n            res.push_back(ans[y]);\\n        }else if(x == y){\\n            if(ans[x]>ans[x-1]){\\n                 res.push_back(ans[y] - ans[x] + 1);\\n            }else{\\n                 res.push_back(ans[y] - ans[x]);\\n            }\\n        }else if(ans[x]>ans[x-1]){\\n            res.push_back(ans[y] - ans[x] + 1);\\n            //res.push_back()\\n        }else if(ans[x] == ans[x-1]){\\n            res.push_back(ans[y] - ans[x]);\\n        }else{\\n\\n        }\\n\\n      \\n\\n\\n      }\\n      return res;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185276,
                "title": "simple-c-solution-using-prefix-sum-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        set<char>st;\\n\\t\\t\\n\\t\\t// Adding the vowels to the set.\\n        st.insert(\\'a\\');\\n        st.insert(\\'e\\');\\n        st.insert(\\'i\\');\\n        st.insert(\\'o\\');\\n        st.insert(\\'u\\');\\n        vector<int>prefixSum;\\n        prefixSum.push_back(0);\\n        for(int i = 0; i < words.size(); i++) {\\n\\t\\t\\n\\t\\t\\t// If the current string satify the conditions then increment the previous value of the Prefix Sum and add it to the array.\\n            if(st.find(words[i][0]) != st.end() and st.find(words[i][words[i].size() - 1]) != st.end()) {\\n                prefixSum.push_back(prefixSum.back() + 1);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Else just add the previous value to the array.\\n            else {\\n                prefixSum.push_back(prefixSum.back());\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i = 0; i < queries.size(); i++) {\\n            ans.push_back(prefixSum[queries[i][1] + 1] - prefixSum[queries[i][0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        set<char>st;\\n\\t\\t\\n\\t\\t// Adding the vowels to the set.\\n        st.insert(\\'a\\');\\n        st.insert(\\'e\\');\\n        st.insert(\\'i\\');\\n        st.insert(\\'o\\');\\n        st.insert(\\'u\\');\\n        vector<int>prefixSum;\\n        prefixSum.push_back(0);\\n        for(int i = 0; i < words.size(); i++) {\\n\\t\\t\\n\\t\\t\\t// If the current string satify the conditions then increment the previous value of the Prefix Sum and add it to the array.\\n            if(st.find(words[i][0]) != st.end() and st.find(words[i][words[i].size() - 1]) != st.end()) {\\n                prefixSum.push_back(prefixSum.back() + 1);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Else just add the previous value to the array.\\n            else {\\n                prefixSum.push_back(prefixSum.back());\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i = 0; i < queries.size(); i++) {\\n            ans.push_back(prefixSum[queries[i][1] + 1] - prefixSum[queries[i][0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153009,
                "title": "c-solution-presum",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<char> vov= {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& q) {\\n        int ln= words.size();\\n        vector<int> arr(ln+1,0);\\n        \\n        for(int i=0;i<ln;i++){\\n            arr[i+1] = (vov.count(words[i][0]) && vov.count(words[i].back())) ? arr[i]+1 : arr[i];\\n        }\\n        \\n        vector<int>ans;\\n        for(auto &x:q) ans.push_back(arr[x[1]+1] - arr[x[0]]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<char> vov= {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& q) {\\n        int ln= words.size();\\n        vector<int> arr(ln+1,0);\\n        \\n        for(int i=0;i<ln;i++){\\n            arr[i+1] = (vov.count(words[i][0]) && vov.count(words[i].back())) ? arr[i]+1 : arr[i];\\n        }\\n        \\n        vector<int>ans;\\n        for(auto &x:q) ans.push_back(arr[x[1]+1] - arr[x[0]]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151925,
                "title": "by-prefix-sum-simple-and-easy-solution",
                "content": "# Approach\\n1:- store which word is contain start and end volel char in 0/1.(temp)\\n2:- prefix sum of temp arrray\\n3:- sovle queries by pref(ending-starting) and store.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int>temp,pref(words.size()+1);\\n        unordered_map<char,int>mp;\\n        mp[\\'a\\']=1;mp[\\'e\\']=1;mp[\\'i\\']=1;mp[\\'o\\']=1;mp[\\'u\\']=1;\\n        for(int i=0;i<words.size();i++){\\n            int n=words[i].size();\\n            int start=mp.count(words[i][0]);\\n            int end=mp.count(words[i][n-1]);\\n            if(start==1 && end==1){\\n                temp.push_back(1);\\n            }else{\\n                temp.push_back(0);\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<temp.size();i++){\\n            sum+=temp[i];\\n            pref[i+1]=sum;\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++){\\n            ans.push_back(pref[queries[i][1] + 1] - pref[queries[i][0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int>temp,pref(words.size()+1);\\n        unordered_map<char,int>mp;\\n        mp[\\'a\\']=1;mp[\\'e\\']=1;mp[\\'i\\']=1;mp[\\'o\\']=1;mp[\\'u\\']=1;\\n        for(int i=0;i<words.size();i++){\\n            int n=words[i].size();\\n            int start=mp.count(words[i][0]);\\n            int end=mp.count(words[i][n-1]);\\n            if(start==1 && end==1){\\n                temp.push_back(1);\\n            }else{\\n                temp.push_back(0);\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<temp.size();i++){\\n            sum+=temp[i];\\n            pref[i+1]=sum;\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++){\\n            ans.push_back(pref[queries[i][1] + 1] - pref[queries[i][0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145674,
                "title": "c-and-python-100-faster-0ms-solution-easy-to-understand-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nPrefix Sum\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**C++ Solution:-**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' ||  c == \\'u\\';\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> p;\\n        vector<int> res;\\n        p.push_back(0);\\n        for(auto &w:words) {\\n            p.push_back(p.back() + (isVowel(w[0]) && isVowel(w.back())));\\n        }\\n        for(auto &q:queries) {\\n            res.push_back(p[q[1]+1] - p[q[0]]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Python Solution:-**\\n```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        \\n        def isVowel(s):\\n            if (s == \\'a\\' or s == \\'e\\' or s == \\'i\\' or s == \\'o\\' or s == \\'u\\'):\\n                return 1\\n            else:\\n                return 0\\n            \\n        res = []\\n        prefixSum = [0]\\n        for i in range(len(words)):\\n            prefixSum.append(isVowel(words[i][0]) and isVowel(words[i][-1]))\\n        for i in range(1, len(prefixSum)):\\n            prefixSum[i] += prefixSum[i-1]\\n        for i in range(len(queries)):\\n            res.append(prefixSum[queries[i][1]+1]-prefixSum[queries[i][0]])\\n        return res\\n            \\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' ||  c == \\'u\\';\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> p;\\n        vector<int> res;\\n        p.push_back(0);\\n        for(auto &w:words) {\\n            p.push_back(p.back() + (isVowel(w[0]) && isVowel(w.back())));\\n        }\\n        for(auto &q:queries) {\\n            res.push_back(p[q[1]+1] - p[q[0]]);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        \\n        def isVowel(s):\\n            if (s == \\'a\\' or s == \\'e\\' or s == \\'i\\' or s == \\'o\\' or s == \\'u\\'):\\n                return 1\\n            else:\\n                return 0\\n            \\n        res = []\\n        prefixSum = [0]\\n        for i in range(len(words)):\\n            prefixSum.append(isVowel(words[i][0]) and isVowel(words[i][-1]))\\n        for i in range(1, len(prefixSum)):\\n            prefixSum[i] += prefixSum[i-1]\\n        for i in range(len(queries)):\\n            res.append(prefixSum[queries[i][1]+1]-prefixSum[queries[i][0]])\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145423,
                "title": "python-faster-than-100-easy-understanding-clean-concise-code",
                "content": "\\n# Complexity\\n- Time complexity: O(len(words) + len(queries))\\n- Space complexity: O(len(words) + len(queries))\\n\\n# Code\\n```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n        preCompute = [0]\\n        sm = 0\\n        for word in words:\\n            if word[0] in vowels and word[-1] in vowels:\\n                sm +=1\\n            preCompute.append(sm)\\n        res = []\\n        for l,r in queries:\\n            res.append(preCompute[r+1]-preCompute[l])\\n        return res\\n```\\nYou Can also Look At My SDE Prep Repo [\\uD83E\\uDDE2 GitHub](https://github.com/Ayon-SSP/The-SDE-Prep) myrepoo",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n        preCompute = [0]\\n        sm = 0\\n        for word in words:\\n            if word[0] in vowels and word[-1] in vowels:\\n                sm +=1\\n            preCompute.append(sm)\\n        res = []\\n        for l,r in queries:\\n            res.append(preCompute[r+1]-preCompute[l])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145036,
                "title": "c-using-lowerbound-and-upperbound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvowel(char c1){\\n        if(c1==\\'a\\' || c1==\\'e\\' || c1==\\'i\\' || c1==\\'o\\' || c1==\\'u\\') return true;\\n        return false;    \\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& q) {\\n        vector<int> gg;\\n        int len1 = words.size();\\n        int len2 = q.size();\\n        vector<int> vp;\\n        for(int i=0;i<len1;i++){\\n            int temp = words[i].size();\\n            if(isvowel(words[i][0]) && isvowel(words[i][temp-1])) vp.push_back(i);\\n        }\\n        for(int i=0;i<len2;i++){\\n            int x = q[i][0];\\n            int y = q[i][1];\\n           int l = lower_bound(vp.begin(),vp.end(),x)-vp.begin();\\n            int u = upper_bound(vp.begin(),vp.end(),y)-vp.begin();\\n            gg.push_back(abs(u-l));\\n        }\\n        return gg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvowel(char c1){\\n        if(c1==\\'a\\' || c1==\\'e\\' || c1==\\'i\\' || c1==\\'o\\' || c1==\\'u\\') return true;\\n        return false;    \\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& q) {\\n        vector<int> gg;\\n        int len1 = words.size();\\n        int len2 = q.size();\\n        vector<int> vp;\\n        for(int i=0;i<len1;i++){\\n            int temp = words[i].size();\\n            if(isvowel(words[i][0]) && isvowel(words[i][temp-1])) vp.push_back(i);\\n        }\\n        for(int i=0;i<len2;i++){\\n            int x = q[i][0];\\n            int y = q[i][1];\\n           int l = lower_bound(vp.begin(),vp.end(),x)-vp.begin();\\n            int u = upper_bound(vp.begin(),vp.end(),y)-vp.begin();\\n            gg.push_back(abs(u-l));\\n        }\\n        return gg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144679,
                "title": "easy-and-user-friendly-solution-using-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefix Sum\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int>ans,ans2;\\n        vector<int>v;\\n        \\n        for(auto x:words){\\n            string s=x;\\n            if((s[0]==\\'a\\' ||s[0]==\\'e\\'||s[0]==\\'i\\'||s[0]==\\'o\\'||s[0]==\\'u\\' )&&(s[s.size()-1]==\\'a\\'||s[s.size()-1]==\\'e\\'||s[s.size()-1]==\\'i\\'||s[s.size()-1]==\\'o\\'||s[s.size()-1]==\\'u\\')){\\n                v.push_back(1);\\n            }\\n            else{\\n                v.push_back(0);\\n            }\\n        }\\n        int sum=0;\\n        for(auto x:v){\\n            cout<<x<<\" \";\\n            sum+=x;\\n            ans.push_back(sum);\\n            \\n        }\\n        cout<<\"\\\\n\";\\n        for(auto x:ans) cout<<x<<\" \";\\n        cout<<\"\\\\n\";\\n        for(int i=0;i<queries.size();i++){\\n            int l=queries[i][0];\\n            int r=queries[i][1];\\n            int q;\\n            if(l>=1){\\n                q=ans[r]-ans[l-1];\\n            }\\n            else{\\n                q=ans[r];\\n            }\\n            ans2.push_back(q);\\n        }\\n        \\n        return ans2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int>ans,ans2;\\n        vector<int>v;\\n        \\n        for(auto x:words){\\n            string s=x;\\n            if((s[0]==\\'a\\' ||s[0]==\\'e\\'||s[0]==\\'i\\'||s[0]==\\'o\\'||s[0]==\\'u\\' )&&(s[s.size()-1]==\\'a\\'||s[s.size()-1]==\\'e\\'||s[s.size()-1]==\\'i\\'||s[s.size()-1]==\\'o\\'||s[s.size()-1]==\\'u\\')){\\n                v.push_back(1);\\n            }\\n            else{\\n                v.push_back(0);\\n            }\\n        }\\n        int sum=0;\\n        for(auto x:v){\\n            cout<<x<<\" \";\\n            sum+=x;\\n            ans.push_back(sum);\\n            \\n        }\\n        cout<<\"\\\\n\";\\n        for(auto x:ans) cout<<x<<\" \";\\n        cout<<\"\\\\n\";\\n        for(int i=0;i<queries.size();i++){\\n            int l=queries[i][0];\\n            int r=queries[i][1];\\n            int q;\\n            if(l>=1){\\n                q=ans[r]-ans[l-1];\\n            }\\n            else{\\n                q=ans[r];\\n            }\\n            ans2.push_back(q);\\n        }\\n        \\n        return ans2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3144673,
                "title": "c-solution-using-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to process a range query. So if we precompute PrefixSum, then we can process all the queries in O(1) time. To precompute, we just need to check whether a string starts and ends with a vowel.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n## Steps\\n- Step 1: Declare a dp array.\\n- Step 2: Cxheck which string starts and ends with a vowel. Store 1 for true and 0 for false.\\n- Step 3: Compute the prefixSum array.\\n- Step 4: Process all the queries: ans = queries[r] - queries[l - 1];\\n# Complexity\\n- Time complexity: O(n + m)\\n    - O(n) to compute the prefixSum array (dp).\\n    - O(m) to process all the queries.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n    - O(n) to store the priffixSum (dp array).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        vector <int> dp(n, 0);\\n        for (int i=0; i<n; ++i) {\\n            string curr = words[i];\\n            int p = curr.size();\\n            if ((curr[0] == \\'a\\' || curr[0] == \\'e\\' || curr[0] == \\'i\\' || curr[0] == \\'o\\' || curr[0] == \\'u\\') && (curr[p - 1] == \\'a\\' || curr[p - 1] == \\'e\\' || curr[p - 1] == \\'i\\' || curr[p - 1] == \\'o\\' || curr[p - 1] == \\'u\\')) dp[i] = 1;\\n            else dp[i] = 0;\\n        }\\n        for (int i=1; i<n; ++i) dp[i] = dp[i] + dp[i - 1];\\n        vector <int> ans;\\n        for (vector <int> query: queries) {\\n            int curr = dp[query[1]];\\n            if (query[0] > 0) curr -= dp[query[0] - 1];\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        vector <int> dp(n, 0);\\n        for (int i=0; i<n; ++i) {\\n            string curr = words[i];\\n            int p = curr.size();\\n            if ((curr[0] == \\'a\\' || curr[0] == \\'e\\' || curr[0] == \\'i\\' || curr[0] == \\'o\\' || curr[0] == \\'u\\') && (curr[p - 1] == \\'a\\' || curr[p - 1] == \\'e\\' || curr[p - 1] == \\'i\\' || curr[p - 1] == \\'o\\' || curr[p - 1] == \\'u\\')) dp[i] = 1;\\n            else dp[i] = 0;\\n        }\\n        for (int i=1; i<n; ++i) dp[i] = dp[i] + dp[i - 1];\\n        vector <int> ans;\\n        for (vector <int> query: queries) {\\n            int curr = dp[query[1]];\\n            if (query[0] > 0) curr -= dp[query[0] - 1];\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144659,
                "title": "100-fast-and-space-optimised-c-solution-prefix-sum",
                "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    bool isvow(char ch){\\n        if (ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> pref(words.size(),0);\\n        vector<int> ans;\\n        if (isvow(words[0][0]) && isvow(words[0].back()))pref[0]++;\\n        for (int i=1; i<words.size(); i++){\\n            if (isvow(words[i][0]) && isvow(words[i].back()))pref[i]++;\\n            pref[i]+= pref[i-1];\\n        }\\n        //for (int i=1; i<words.size(); i++)pref[i]= pref[i]+pref[i-1];\\n        for (auto val: pref)cout<<val<<\" \";\\n        for (int i=0; i<queries.size(); i++){\\n            int l= queries[i][0];\\n            int r= queries[i][1];\\n            int chk;\\n            if (l!=0)chk= pref[l-1];\\n            else chk=0;\\n            int val= (pref[r]-chk);\\n            //if (l==0)val+=pref[l];\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvow(char ch){\\n        if (ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\')return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> pref(words.size(),0);\\n        vector<int> ans;\\n        if (isvow(words[0][0]) && isvow(words[0].back()))pref[0]++;\\n        for (int i=1; i<words.size(); i++){\\n            if (isvow(words[i][0]) && isvow(words[i].back()))pref[i]++;\\n            pref[i]+= pref[i-1];\\n        }\\n        //for (int i=1; i<words.size(); i++)pref[i]= pref[i]+pref[i-1];\\n        for (auto val: pref)cout<<val<<\" \";\\n        for (int i=0; i<queries.size(); i++){\\n            int l= queries[i][0];\\n            int r= queries[i][1];\\n            int chk;\\n            if (l!=0)chk= pref[l-1];\\n            else chk=0;\\n            int val= (pref[r]-chk);\\n            //if (l==0)val+=pref[l];\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3144517,
                "title": "javascript-binary-search-187ms",
                "content": "Main idea:\\n(1) save all valid index into an array (ia)\\n(2) for each query, we only needs to find the first/smallest index >= l (lower_bound()), and last/max index <= r (upper_bound() - 1), each query answer is last/max index - first/smallest index + 1\\n```\\n///////////////////////////// Template ////////////////////////////////\\nconst isVowel = (c) => \\'aeiou\\'.indexOf(c) != -1;\\n\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n///////////////////////////////////////////////////////////////////\\n\\nconst vowelStrings = (a, queries) => {\\n    let ia = [], res = [], bi = new Bisect();\\n    for (let i = 0; i < a.length; i++) {\\n        let s = a[i];\\n        if (isVowel(s[0]) && isVowel(s[s.length - 1])) ia.push(i);\\n    }\\n    for (const [l, r] of queries) {\\n        let lb = bi.bisect_left(ia, l); // >= l\\n        let rb = bi.bisect_right(ia, r) - 1; // <= r\\n        res.push(rb - lb + 1);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Binary Search"
                ],
                "code": "```\\n///////////////////////////// Template ////////////////////////////////\\nconst isVowel = (c) => \\'aeiou\\'.indexOf(c) != -1;\\n\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n///////////////////////////////////////////////////////////////////\\n\\nconst vowelStrings = (a, queries) => {\\n    let ia = [], res = [], bi = new Bisect();\\n    for (let i = 0; i < a.length; i++) {\\n        let s = a[i];\\n        if (isVowel(s[0]) && isVowel(s[s.length - 1])) ia.push(i);\\n    }\\n    for (const [l, r] of queries) {\\n        let lb = bi.bisect_left(ia, l); // >= l\\n        let rb = bi.bisect_right(ia, r) - 1; // <= r\\n        res.push(rb - lb + 1);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3144087,
                "title": "beats-100-time-complexity-and-100-space-complexity-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& q) {\\n        vector <int> v;\\n        for(int j=0;j<words.size();j++)\\n        {\\n            int s = words[j].size();\\n            if((words[j][0] == \\'a\\'|| words[j][0] == \\'e\\' || words[j][0] == \\'i\\' || words[j][0] == \\'o\\' || words[j][0] == \\'u\\') && (words[j][s-1] == \\'a\\'|| words[j][s-1] == \\'e\\' || words[j][s-1] == \\'i\\' || words[j][s-1] == \\'o\\' || words[j][s-1] == \\'u\\'))\\n                {\\n                    v.push_back(1);\\n                }\\n            else\\n            {\\n                v.push_back(0);\\n            }\\n        }\\n        vector <int> prearr(v.size(),0);\\n        prearr[0] = v[0];\\n        vector <int> ans;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            prearr[i] = prearr[i-1]+v[i];\\n        }\\n        for(int i=0;i<q.size();i++)\\n        {\\n            if(q[i][0] == 0)\\n            {\\n                ans.push_back(prearr[q[i][1]]);\\n            }\\n            else\\n            {\\n                ans.push_back(prearr[q[i][1]]-prearr[q[i][0]-1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& q) {\\n        vector <int> v;\\n        for(int j=0;j<words.size();j++)\\n        {\\n            int s = words[j].size();\\n            if((words[j][0] == \\'a\\'|| words[j][0] == \\'e\\' || words[j][0] == \\'i\\' || words[j][0] == \\'o\\' || words[j][0] == \\'u\\') && (words[j][s-1] == \\'a\\'|| words[j][s-1] == \\'e\\' || words[j][s-1] == \\'i\\' || words[j][s-1] == \\'o\\' || words[j][s-1] == \\'u\\'))\\n                {\\n                    v.push_back(1);\\n                }\\n            else\\n            {\\n                v.push_back(0);\\n            }\\n        }\\n        vector <int> prearr(v.size(),0);\\n        prearr[0] = v[0];\\n        vector <int> ans;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            prearr[i] = prearr[i-1]+v[i];\\n        }\\n        for(int i=0;i<q.size();i++)\\n        {\\n            if(q[i][0] == 0)\\n            {\\n                ans.push_back(prearr[q[i][1]]);\\n            }\\n            else\\n            {\\n                ans.push_back(prearr[q[i][1]]-prearr[q[i][0]-1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143940,
                "title": "prefix-array-beats-100-in-time-space-c",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) \\n    {\\n        int n=words.size();\\n        vector<int> prefix(n);\\n        for(int x=0; x<n; x++)\\n        {\\n            int l=words[x].size();\\n            string s=words[x];\\n            if((s[0]==\\'a\\' || s[0]==\\'e\\' || s[0]==\\'i\\' || s[0]==\\'o\\' || s[0]==\\'u\\') && (s[l-1]==\\'a\\' || s[l-1]==\\'e\\' || s[l-1]==\\'i\\' || s[l-1]==\\'o\\' || s[l-1]==\\'u\\')) prefix[x]=1;\\n        }\\n        for(int x=1; x<n; x++) prefix[x]=prefix[x-1]+prefix[x];\\n        int q=queries.size();\\n        vector<int> ans(q);\\n        for(int x=0; x<q; x++)\\n        {\\n            int r=queries[x][1];\\n            int l=queries[x][0];\\n            if(l==0) ans[x]=prefix[r];\\n            else ans[x]=prefix[r]-prefix[l-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) \\n    {\\n        int n=words.size();\\n        vector<int> prefix(n);\\n        for(int x=0; x<n; x++)\\n        {\\n            int l=words[x].size();\\n            string s=words[x];\\n            if((s[0]==\\'a\\' || s[0]==\\'e\\' || s[0]==\\'i\\' || s[0]==\\'o\\' || s[0]==\\'u\\') && (s[l-1]==\\'a\\' || s[l-1]==\\'e\\' || s[l-1]==\\'i\\' || s[l-1]==\\'o\\' || s[l-1]==\\'u\\')) prefix[x]=1;\\n        }\\n        for(int x=1; x<n; x++) prefix[x]=prefix[x-1]+prefix[x];\\n        int q=queries.size();\\n        vector<int> ans(q);\\n        for(int x=0; x<q; x++)\\n        {\\n            int r=queries[x][1];\\n            int l=queries[x][0];\\n            if(l==0) ans[x]=prefix[r];\\n            else ans[x]=prefix[r]-prefix[l-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143934,
                "title": "java-prefix-sum-hashmap",
                "content": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        Map<String,Boolean> map = new HashMap<>();\\n        for(String i: words) {\\n            if(map.containsKey(i)) continue;\\n            if(isVowel(i)) map.put(i,true);\\n            else map.put(i,false);\\n        }\\n        int[] pref = new int[words.length];\\n        if(map.get(words[0])) pref[0] = 1;\\n        for(int i = 1; i < words.length; i++) {\\n            if(map.get(words[i])) pref[i] = pref[i - 1] + 1;\\n            else pref[i] = pref[i - 1];\\n        }\\n        int[] ans = new int[queries.length];\\n        int k = 0;\\n        for(int[] i: queries) {\\n            int l = i[0];\\n            int r = i[1];\\n            ans[k++] = pref[r] - pref[l] + (map.get(words[l]) ? 1 : 0);\\n        }\\n        return ans;\\n    }\\n    private boolean isVowel(String str) {\\n        String vowel = \"aeiou\";\\n        if(vowel.indexOf(str.charAt(0)) >= 0 && vowel.indexOf(str.charAt(str.length() - 1)) >= 0) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        Map<String,Boolean> map = new HashMap<>();\\n        for(String i: words) {\\n            if(map.containsKey(i)) continue;\\n            if(isVowel(i)) map.put(i,true);\\n            else map.put(i,false);\\n        }\\n        int[] pref = new int[words.length];\\n        if(map.get(words[0])) pref[0] = 1;\\n        for(int i = 1; i < words.length; i++) {\\n            if(map.get(words[i])) pref[i] = pref[i - 1] + 1;\\n            else pref[i] = pref[i - 1];\\n        }\\n        int[] ans = new int[queries.length];\\n        int k = 0;\\n        for(int[] i: queries) {\\n            int l = i[0];\\n            int r = i[1];\\n            ans[k++] = pref[r] - pref[l] + (map.get(words[l]) ? 1 : 0);\\n        }\\n        return ans;\\n    }\\n    private boolean isVowel(String str) {\\n        String vowel = \"aeiou\";\\n        if(vowel.indexOf(str.charAt(0)) >= 0 && vowel.indexOf(str.charAt(str.length() - 1)) >= 0) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143909,
                "title": "java-simple-prefixsum",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        HashSet<Character> hs = new HashSet<>();\\n        hs.add(\\'a\\');\\n        hs.add(\\'e\\');\\n        hs.add(\\'i\\');\\n        hs.add(\\'o\\');\\n        hs.add(\\'u\\');\\n        \\n        int N = words.length;\\n        int[] arr = new int[N];\\n        for(int i=0; i<N; i++) {\\n            if(hs.contains(words[i].charAt(0)) && hs.contains(words[i].charAt(words[i].length()-1))){\\n                arr[i] = 1;\\n            }\\n        }\\n        \\n        int[] prefix = new int[N];\\n        prefix[0] = arr[0];\\n        for(int i=1; i<N; i++) {\\n            prefix[i] = prefix[i-1]+arr[i];\\n        }\\n        \\n        int[] ansArr = new int[queries.length];\\n        \\n        for(int i=0; i<queries.length; i++) {\\n            int[] q = queries[i];\\n            int s = q[0];\\n            int e = q[1];\\n            \\n            int cnt = prefix[e];\\n            \\n            if(s-1>=0) {\\n                cnt -= prefix[s-1];\\n            }\\n            \\n            ansArr[i] = cnt;\\n        }\\n        \\n        return ansArr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        HashSet<Character> hs = new HashSet<>();\\n        hs.add(\\'a\\');\\n        hs.add(\\'e\\');\\n        hs.add(\\'i\\');\\n        hs.add(\\'o\\');\\n        hs.add(\\'u\\');\\n        \\n        int N = words.length;\\n        int[] arr = new int[N];\\n        for(int i=0; i<N; i++) {\\n            if(hs.contains(words[i].charAt(0)) && hs.contains(words[i].charAt(words[i].length()-1))){\\n                arr[i] = 1;\\n            }\\n        }\\n        \\n        int[] prefix = new int[N];\\n        prefix[0] = arr[0];\\n        for(int i=1; i<N; i++) {\\n            prefix[i] = prefix[i-1]+arr[i];\\n        }\\n        \\n        int[] ansArr = new int[queries.length];\\n        \\n        for(int i=0; i<queries.length; i++) {\\n            int[] q = queries[i];\\n            int s = q[0];\\n            int e = q[1];\\n            \\n            int cnt = prefix[e];\\n            \\n            if(s-1>=0) {\\n                cnt -= prefix[s-1];\\n            }\\n            \\n            ansArr[i] = cnt;\\n        }\\n        \\n        return ansArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143844,
                "title": "hashing-prefix-sum-approach-optimized-code-c-weekly",
                "content": "Approach : \\n1. First of all create a bool hash to store if the string in words start from vowel and ends with a vowel.\\n```\\n vector<int>hash (words.size(),0);\\n      \\n        int ptr = 0;\\n        for(auto it : words){\\n            int s = it.size()-1;\\n            if((it[0] == \\'a\\' ||it[0] == \\'e\\' || it[0] == \\'i\\' || it[0] == \\'o\\' || it[0] == \\'u\\') && (it[s] == \\'a\\' ||it[s] == \\'e\\' || it[s] == \\'i\\' || it[s] == \\'o\\' || it[s] == \\'u\\')  )hash[ptr]++;\\n            ptr++;\\n        }\\n```\\n2. Now create a sum vector to store prefix sum.\\n```\\nvector<int>sum;\\n        int s =0;\\n        for(auto it : hash){\\n            s+=it;\\n            sum.push_back(s);\\n        }\\n```\\n3. Here if you iterate using brute force that gives TLE. So using prefix sum \\nI come up with three formulas ->>\\n```\\n  int l = it[0];\\n            int d = it[1];\\n            \\n            if(l==0)ans.push_back(sum[d]);\\n\\t\\t\\t// This is the case where we need to check from the starting\\n            else if(l==d){\\n                if(hash[l])\\n                    ans.push_back(1); \\n                else\\n                    ans.push_back(0);}\\n\\t\\t\\t// this is the case where we need to check only the string on l || d\\n            else ans.push_back(sum[d]-sum[l-1]);\\n\\t\\t\\t\\n\\t\\t\\t//this is the general formula , otherwise\\n```\\n\\nCode : \\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int>hash (words.size(),0);\\n        vector<int>ans;\\n        if(words.size()==0 || queries.size()==0){\\n            return ans;\\n        }\\n        int ptr = 0;\\n        for(auto it : words){\\n            int s = it.size()-1;\\n            if((it[0] == \\'a\\' ||it[0] == \\'e\\' || it[0] == \\'i\\' || it[0] == \\'o\\' || it[0] == \\'u\\') && (it[s] == \\'a\\' ||it[s] == \\'e\\' || it[s] == \\'i\\' || it[s] == \\'o\\' || it[s] == \\'u\\')  )hash[ptr]++;\\n            ptr++;\\n        }\\n        \\n        vector<int>sum;\\n        int s =0;\\n        for(auto it : hash){\\n            s+=it;\\n            sum.push_back(s);\\n        }\\n        \\n        // for(auto it : sum)cout<<it<<\" \";\\n        \\n        for(auto it : queries){\\n            int l = it[0];\\n            int d = it[1];\\n            \\n            if(l==0)ans.push_back(sum[d]);\\n            else if(l==d){\\n                if(hash[l])\\n                    ans.push_back(1); \\n                else\\n                    ans.push_back(0);}\\n            else ans.push_back(sum[d]-sum[l-1]);\\n        }\\n\\n        \\n\\n        \\n        \\n    \\n        return ans;\\n    }\\n};\\n```\\n\\nPLs DO UPVOTE  if you like !!!",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n vector<int>hash (words.size(),0);\\n      \\n        int ptr = 0;\\n        for(auto it : words){\\n            int s = it.size()-1;\\n            if((it[0] == \\'a\\' ||it[0] == \\'e\\' || it[0] == \\'i\\' || it[0] == \\'o\\' || it[0] == \\'u\\') && (it[s] == \\'a\\' ||it[s] == \\'e\\' || it[s] == \\'i\\' || it[s] == \\'o\\' || it[s] == \\'u\\')  )hash[ptr]++;\\n            ptr++;\\n        }\\n```\n```\\nvector<int>sum;\\n        int s =0;\\n        for(auto it : hash){\\n            s+=it;\\n            sum.push_back(s);\\n        }\\n```\n```\\n  int l = it[0];\\n            int d = it[1];\\n            \\n            if(l==0)ans.push_back(sum[d]);\\n\\t\\t\\t// This is the case where we need to check from the starting\\n            else if(l==d){\\n                if(hash[l])\\n                    ans.push_back(1); \\n                else\\n                    ans.push_back(0);}\\n\\t\\t\\t// this is the case where we need to check only the string on l || d\\n            else ans.push_back(sum[d]-sum[l-1]);\\n\\t\\t\\t\\n\\t\\t\\t//this is the general formula , otherwise\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int>hash (words.size(),0);\\n        vector<int>ans;\\n        if(words.size()==0 || queries.size()==0){\\n            return ans;\\n        }\\n        int ptr = 0;\\n        for(auto it : words){\\n            int s = it.size()-1;\\n            if((it[0] == \\'a\\' ||it[0] == \\'e\\' || it[0] == \\'i\\' || it[0] == \\'o\\' || it[0] == \\'u\\') && (it[s] == \\'a\\' ||it[s] == \\'e\\' || it[s] == \\'i\\' || it[s] == \\'o\\' || it[s] == \\'u\\')  )hash[ptr]++;\\n            ptr++;\\n        }\\n        \\n        vector<int>sum;\\n        int s =0;\\n        for(auto it : hash){\\n            s+=it;\\n            sum.push_back(s);\\n        }\\n        \\n        // for(auto it : sum)cout<<it<<\" \";\\n        \\n        for(auto it : queries){\\n            int l = it[0];\\n            int d = it[1];\\n            \\n            if(l==0)ans.push_back(sum[d]);\\n            else if(l==d){\\n                if(hash[l])\\n                    ans.push_back(1); \\n                else\\n                    ans.push_back(0);}\\n            else ans.push_back(sum[d]-sum[l-1]);\\n        }\\n\\n        \\n\\n        \\n        \\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3143838,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        res=[0]\\n        for word in words:\\n            if word[0] in \\'aeiou\\' and word[-1] in \\'aeiou\\':\\n                res.append(res[-1]+1)\\n            else:\\n                res.append(res[-1])\\n\\n\\n        ans=[]\\n        for l,r in queries:\\n            ans.append(res[r+1]-res[l])\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        res=[0]\\n        for word in words:\\n            if word[0] in \\'aeiou\\' and word[-1] in \\'aeiou\\':\\n                res.append(res[-1]+1)\\n            else:\\n                res.append(res[-1])\\n\\n\\n        ans=[]\\n        for l,r in queries:\\n            ans.append(res[r+1]-res[l])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143830,
                "title": "python-solution-easy-to-understand-for-beginners-prefix-sum",
                "content": "```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        vowels = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}\\n        for word in words:\\n            if word[0] in vowels and word[-1] in vowels:\\n                ans.append(1)\\n            else:\\n                ans.append(0)\\n        for i in range(len(ans)-1):\\n            ans[i+1] += ans[i]\\n        mans = []\\n        for q in queries:\\n            p = ans[q[1]]-ans[q[0]]\\n            if words[q[0]][0] in vowels and words[q[0]][-1] in vowels:\\n                p += 1\\n            mans.append(p)\\n        return mans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        vowels = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}\\n        for word in words:\\n            if word[0] in vowels and word[-1] in vowels:\\n                ans.append(1)\\n            else:\\n                ans.append(0)\\n        for i in range(len(ans)-1):\\n            ans[i+1] += ans[i]\\n        mans = []\\n        for q in queries:\\n            p = ans[q[1]]-ans[q[0]]\\n            if words[q[0]][0] in vowels and words[q[0]][-1] in vowels:\\n                p += 1\\n            mans.append(p)\\n        return mans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143826,
                "title": "prefix-sum-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char ch){\\n        return ch == \\'a\\' or ch == \\'e\\' or ch ==\\'i\\' or ch==\\'o\\' or ch == \\'u\\';\\n    };\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n         int n = words.size();\\n         vector<int> dp, ans;\\n         dp.push_back(0);\\n         for(int i =0;i<words.size();i++){\\n             if(isVowel(words[i][0]) and isVowel(words[i].back()))dp.push_back(1);\\n             else dp.push_back(0);\\n         };\\n         for(int i= 1;i<=n;i++){\\n             dp[i]+=dp[i-1];\\n         }\\n         for(auto q:queries){\\n             int l = q[0], r = q[1];\\n             ans.push_back(dp[r+1] - dp[l]);\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char ch){\\n        return ch == \\'a\\' or ch == \\'e\\' or ch ==\\'i\\' or ch==\\'o\\' or ch == \\'u\\';\\n    };\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n         int n = words.size();\\n         vector<int> dp, ans;\\n         dp.push_back(0);\\n         for(int i =0;i<words.size();i++){\\n             if(isVowel(words[i][0]) and isVowel(words[i].back()))dp.push_back(1);\\n             else dp.push_back(0);\\n         };\\n         for(int i= 1;i<=n;i++){\\n             dp[i]+=dp[i-1];\\n         }\\n         for(auto q:queries){\\n             int l = q[0], r = q[1];\\n             ans.push_back(dp[r+1] - dp[l]);\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143819,
                "title": "js-easy-regex",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar checkString = function(str){\\n    return /^[aeiou]$|^[aeiou].*[aeiou]$/.test(str);\\n};\\n\\nvar vowelStrings = function(words, queries) {\\n    const len = words.length;\\n    let pre = new Array(len + 1).fill(0);\\n    for (let i = 0; i < len; i++) {\\n        if (checkString(words[i])) pre[i + 1] = pre[i] + 1;\\n        else pre[i + 1] = pre[i];\\n    }\\n    const answer = [];\\n    for (let [s, e] of queries) {\\n        answer.push(pre[e + 1] - pre[s]);\\n    }\\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\nvar checkString = function(str){\\n    return /^[aeiou]$|^[aeiou].*[aeiou]$/.test(str);\\n};\\n\\nvar vowelStrings = function(words, queries) {\\n    const len = words.length;\\n    let pre = new Array(len + 1).fill(0);\\n    for (let i = 0; i < len; i++) {\\n        if (checkString(words[i])) pre[i + 1] = pre[i] + 1;\\n        else pre[i + 1] = pre[i];\\n    }\\n    const answer = [];\\n    for (let [s, e] of queries) {\\n        answer.push(pre[e + 1] - pre[s]);\\n    }\\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3143774,
                "title": "c-simple-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n         int n = words.size();\\n        vector<int>v(n),pre(n);\\n        int i=0;\\n        for(auto x: words){\\n            int l=x.size()-1;\\nif((x[0]==\\'a\\' or x[0]==\\'e\\' or x[0]==\\'i\\' or x[0]==\\'o\\' or x[0]==\\'u\\')\\n    and (x[l]==\\'a\\' or x[l]==\\'e\\' or x[l]==\\'i\\' or x[l]==\\'o\\' or x[l]==\\'u\\'))\\n    v[i++]=1;\\n            else v[i++]=0;\\n             }\\n        pre[0]=v[0];\\n        for(int i=1; i<n; i++) pre[i]=pre[i-1]+v[i];\\n        int q=queries.size();\\n        vector<int>ans(q,0);\\n        for(int i=0; i<q; i++){\\n            int low=queries[i][0];\\n            int high=queries[i][1];\\n            if(low==0)  ans[i]=pre[high];\\n            else ans[i]=pre[high]-pre[low-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n         int n = words.size();\\n        vector<int>v(n),pre(n);\\n        int i=0;\\n        for(auto x: words){\\n            int l=x.size()-1;\\nif((x[0]==\\'a\\' or x[0]==\\'e\\' or x[0]==\\'i\\' or x[0]==\\'o\\' or x[0]==\\'u\\')\\n    and (x[l]==\\'a\\' or x[l]==\\'e\\' or x[l]==\\'i\\' or x[l]==\\'o\\' or x[l]==\\'u\\'))\\n    v[i++]=1;\\n            else v[i++]=0;\\n             }\\n        pre[0]=v[0];\\n        for(int i=1; i<n; i++) pre[i]=pre[i-1]+v[i];\\n        int q=queries.size();\\n        vector<int>ans(q,0);\\n        for(int i=0; i<q; i++){\\n            int low=queries[i][0];\\n            int high=queries[i][1];\\n            if(low==0)  ans[i]=pre[high];\\n            else ans[i]=pre[high]-pre[low-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143709,
                "title": "c-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef vector<int> vi;\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vi dp;\\n        set<char> vowels{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        int cnt = 0;\\n        for (auto word : words) {\\n            if (vowels.count(word[0]) and vowels.count(word[word.size()-1]))    {\\n                cnt++;\\n            }\\n            dp.push_back(cnt);\\n        }\\n        vi ans;\\n        for (auto que : queries)    {\\n            int l = que[0], r = que[1];\\n            if (l != 0) {\\n                ans.push_back(dp[r]-dp[l-1]);\\n            }   else    {\\n                ans.push_back(dp[r]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef vector<int> vi;\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vi dp;\\n        set<char> vowels{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        int cnt = 0;\\n        for (auto word : words) {\\n            if (vowels.count(word[0]) and vowels.count(word[word.size()-1]))    {\\n                cnt++;\\n            }\\n            dp.push_back(cnt);\\n        }\\n        vi ans;\\n        for (auto que : queries)    {\\n            int l = que[0], r = que[1];\\n            if (l != 0) {\\n                ans.push_back(dp[r]-dp[l-1]);\\n            }   else    {\\n                ans.push_back(dp[r]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143706,
                "title": "c-prefix-sum-easy-way",
                "content": "> IF IT\\'S HELPFUL, PLEASE UPVOTE !!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\'|| c == \\'o\\' || c == \\'u\\';\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size(); \\n        vector<int> prefix(n+1, 0);\\n        for(int i = 0; i < n; i++) {\\n            if(isVowel(words[i][0]) && isVowel(words[i][words[i].size() - 1])) prefix[i+1] += 1;\\n            prefix[i+1] += prefix[i];\\n        }\\n        \\n        \\n        vector<int> ans;\\n        for(auto q : queries) {\\n            int cal = prefix[q[1] + 1] - prefix[q[0]];\\n            ans.push_back(cal);\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\'|| c == \\'o\\' || c == \\'u\\';\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size(); \\n        vector<int> prefix(n+1, 0);\\n        for(int i = 0; i < n; i++) {\\n            if(isVowel(words[i][0]) && isVowel(words[i][words[i].size() - 1])) prefix[i+1] += 1;\\n            prefix[i+1] += prefix[i];\\n        }\\n        \\n        \\n        vector<int> ans;\\n        for(auto q : queries) {\\n            int cal = prefix[q[1] + 1] - prefix[q[0]];\\n            ans.push_back(cal);\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143670,
                "title": "c-easy-solution-range-sum-query-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    //checking if the the string starts and end with vowel\\n    bool check(string s){\\n        int n = s.length();\\n        if((s[0]==\\'a\\'|| s[0]==\\'e\\'|| s[0]==\\'i\\'|| s[0]==\\'o\\'|| s[0]==\\'u\\') &&\\n           (s[n-1]==\\'a\\'|| s[n-1]==\\'e\\'|| s[n-1]==\\'i\\'|| s[n-1]==\\'o\\'|| s[n-1]==\\'u\\')) return true;\\n        \\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& quer) {\\n        int n = words.size();\\n        \\n        vector<int> isVo(n, 0);\\n        \\n        int sum=0;\\n        \\n        //if the string satisfy the given condition then store 1 else 0\\n        for(int i=0; i<n; i++){\\n            if(check(words[i])){\\n                isVo[i] = 1;\\n            }else{\\n                isVo[i] = 0;\\n            }\\n        }\\n        \\n        \\n        vector<int> pre(n, 0);\\n        pre[0] = isVo[0];\\n        \\n        //making the prefix array for range sum query\\n        for(int i=1; i<n; i++){\\n            pre[i] = isVo[i] + pre[i-1];  \\n        }\\n        \\n        \\n        vector<int> ans;\\n        \\n        //range sum query to find the total number of string in given range\\n        for(int i=0; i<quer.size(); i++){\\n            int l = quer[i][0];\\n            int r = quer[i][1];\\n            \\n            if(l==0){\\n                ans.push_back(pre[r]);\\n            }else{\\n                ans.push_back((pre[r]-pre[l-1]));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //checking if the the string starts and end with vowel\\n    bool check(string s){\\n        int n = s.length();\\n        if((s[0]==\\'a\\'|| s[0]==\\'e\\'|| s[0]==\\'i\\'|| s[0]==\\'o\\'|| s[0]==\\'u\\') &&\\n           (s[n-1]==\\'a\\'|| s[n-1]==\\'e\\'|| s[n-1]==\\'i\\'|| s[n-1]==\\'o\\'|| s[n-1]==\\'u\\')) return true;\\n        \\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& quer) {\\n        int n = words.size();\\n        \\n        vector<int> isVo(n, 0);\\n        \\n        int sum=0;\\n        \\n        //if the string satisfy the given condition then store 1 else 0\\n        for(int i=0; i<n; i++){\\n            if(check(words[i])){\\n                isVo[i] = 1;\\n            }else{\\n                isVo[i] = 0;\\n            }\\n        }\\n        \\n        \\n        vector<int> pre(n, 0);\\n        pre[0] = isVo[0];\\n        \\n        //making the prefix array for range sum query\\n        for(int i=1; i<n; i++){\\n            pre[i] = isVo[i] + pre[i-1];  \\n        }\\n        \\n        \\n        vector<int> ans;\\n        \\n        //range sum query to find the total number of string in given range\\n        for(int i=0; i<quer.size(); i++){\\n            int l = quer[i][0];\\n            int r = quer[i][1];\\n            \\n            if(l==0){\\n                ans.push_back(pre[r]);\\n            }else{\\n                ans.push_back((pre[r]-pre[l-1]));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143667,
                "title": "c-easiest-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool is_vowel(char c) {\\n    return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n            int n = words.size();\\n    vector<int> prefix_sum(n, 0);\\n    for (int i = 0; i < n; i++) {\\n        if (is_vowel(words[i][0]) && is_vowel(words[i][words[i].length() - 1])) {\\n            prefix_sum[i] = 1;\\n        }\\n        if (i > 0) {\\n            prefix_sum[i] += prefix_sum[i - 1];\\n        }\\n    }\\n    vector<int> ans;\\n    for (const auto& query : queries) {\\n        int l = query[0];\\n        int r = query[1];\\n        int count = prefix_sum[r];\\n        if (l > 0) {\\n            count -= prefix_sum[l - 1];\\n        }\\n        ans.push_back(count);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool is_vowel(char c) {\\n    return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n            int n = words.size();\\n    vector<int> prefix_sum(n, 0);\\n    for (int i = 0; i < n; i++) {\\n        if (is_vowel(words[i][0]) && is_vowel(words[i][words[i].length() - 1])) {\\n            prefix_sum[i] = 1;\\n        }\\n        if (i > 0) {\\n            prefix_sum[i] += prefix_sum[i - 1];\\n        }\\n    }\\n    vector<int> ans;\\n    for (const auto& query : queries) {\\n        int l = query[0];\\n        int r = query[1];\\n        int count = prefix_sum[r];\\n        if (l > 0) {\\n            count -= prefix_sum[l - 1];\\n        }\\n        ans.push_back(count);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143640,
                "title": "c-easy-and-simple-solution-using-prefix-sum",
                "content": "\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(char ch){\\n        if(ch==\\'a\\' ||ch==\\'e\\' ||ch==\\'i\\' ||ch==\\'o\\' ||ch==\\'u\\' ) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        vector<int>temp;\\n        int count=0;\\n        for(int i=0;i<words.size();i++){\\n                string str= words[i];\\n                \\n                if(check(words[i][0]) && check(str[str.length()-1])) count++;\\n            temp.push_back(count);\\n        }\\n       \\n        for(int i=0;i<queries.size();i++){\\n            \\n            int x=queries[i][0];\\n            int y=queries[i][1];\\n          \\n           \\n            int second=temp[y];\\n           \\n            int third=x>0 ? temp[x-1] : 0;\\n            \\n            ans.push_back(second-third);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(char ch){\\n        if(ch==\\'a\\' ||ch==\\'e\\' ||ch==\\'i\\' ||ch==\\'o\\' ||ch==\\'u\\' ) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        vector<int>temp;\\n        int count=0;\\n        for(int i=0;i<words.size();i++){\\n                string str= words[i];\\n                \\n                if(check(words[i][0]) && check(str[str.length()-1])) count++;\\n            temp.push_back(count);\\n        }\\n       \\n        for(int i=0;i<queries.size();i++){\\n            \\n            int x=queries[i][0];\\n            int y=queries[i][1];\\n          \\n           \\n            int second=temp[y];\\n           \\n            int third=x>0 ? temp[x-1] : 0;\\n            \\n            ans.push_back(second-third);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057472,
                "title": "solution-with-explanation",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        vowels={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}\\n        result=list()\\n\\n        #Check for the right words\\n        for word in range(len(words)):\\n            if words[word][0] in vowels and words[word][-1] in vowels:\\n                words[word]=1\\n            else:\\n                words[word]=0\\n        #prefix sum\\n        words = list(accumulate(words))\\n\\n        #solution\\n        for querie in queries:\\n            if querie[0]!=0:\\n                result.append(words[querie[1]]-words[querie[0]-1])\\n            else:\\n                result.append(words[querie[1]])\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        vowels={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}\\n        result=list()\\n\\n        #Check for the right words\\n        for word in range(len(words)):\\n            if words[word][0] in vowels and words[word][-1] in vowels:\\n                words[word]=1\\n            else:\\n                words[word]=0\\n        #prefix sum\\n        words = list(accumulate(words))\\n\\n        #solution\\n        for querie in queries:\\n            if querie[0]!=0:\\n                result.append(words[querie[1]]-words[querie[0]-1])\\n            else:\\n                result.append(words[querie[1]])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039828,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        int n=words.size();\\n        unordered_set<char> st;\\n        st.insert(\\'a\\');\\n        st.insert(\\'e\\');\\n        st.insert(\\'i\\');\\n        st.insert(\\'o\\');\\n        st.insert(\\'u\\');\\n        vector<int> prefix(n,0);\\n        for(int i=0;i<n;i++){\\n            string s=words[i];\\n            if(st.count(s[0]) && st.count(s[s.size()-1])){\\n                if(i!=0){\\n                    prefix[i]=prefix[i-1]+1;\\n                }\\n                else{\\n                    prefix[i]=1;\\n                }\\n            }\\n            else{\\n                if(i!=0){\\n                    prefix[i]=prefix[i-1];\\n                }\\n                else{\\n                    prefix[i]=0;\\n                }\\n            }\\n        }\\n        // for(auto it: prefix){\\n        //     cout<<it<<\" \";\\n        // }\\n        for(auto it: queries){\\n            int low=it[0];\\n            int high=it[1];\\n            int val;\\n            if(low>0){\\n                val=prefix[high]-prefix[low-1];\\n            }\\n            else{\\n                val=prefix[high];\\n            }\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        int n=words.size();\\n        unordered_set<char> st;\\n        st.insert(\\'a\\');\\n        st.insert(\\'e\\');\\n        st.insert(\\'i\\');\\n        st.insert(\\'o\\');\\n        st.insert(\\'u\\');\\n        vector<int> prefix(n,0);\\n        for(int i=0;i<n;i++){\\n            string s=words[i];\\n            if(st.count(s[0]) && st.count(s[s.size()-1])){\\n                if(i!=0){\\n                    prefix[i]=prefix[i-1]+1;\\n                }\\n                else{\\n                    prefix[i]=1;\\n                }\\n            }\\n            else{\\n                if(i!=0){\\n                    prefix[i]=prefix[i-1];\\n                }\\n                else{\\n                    prefix[i]=0;\\n                }\\n            }\\n        }\\n        // for(auto it: prefix){\\n        //     cout<<it<<\" \";\\n        // }\\n        for(auto it: queries){\\n            int low=it[0];\\n            int high=it[1];\\n            int val;\\n            if(low>0){\\n                val=prefix[high]-prefix[low-1];\\n            }\\n            else{\\n                val=prefix[high];\\n            }\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4023463,
                "title": "c-beats-57-15-of-solutions-simplest-easiest-optimal-solution-using-prefix-sum",
                "content": "# Complexity\\n- Time complexity:\\nO(max(n, m)) **where n = words.size() and m = queries.size().**\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    bool isVowel(char ch) {\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') \\n            return true;\\n        return false;\\n    }\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n\\n        vector<int> ans, v;\\n\\n        v.push_back(0);\\n\\n        for(int i=0; i<words.size(); i++) {\\n            if(isVowel(words[i][0]) and isVowel(words[i][words[i].size()-1])) v.push_back(v.back() + 1);\\n            else v.push_back(v.back());\\n        }\\n\\n        for(auto it : queries) {\\n            ans.push_back(v[it[1]+1] - v[it[0]]);\\n        }  \\n\\n        return ans;      \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    bool isVowel(char ch) {\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') \\n            return true;\\n        return false;\\n    }\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n\\n        vector<int> ans, v;\\n\\n        v.push_back(0);\\n\\n        for(int i=0; i<words.size(); i++) {\\n            if(isVowel(words[i][0]) and isVowel(words[i][words[i].size()-1])) v.push_back(v.back() + 1);\\n            else v.push_back(v.back());\\n        }\\n\\n        for(auto it : queries) {\\n            ans.push_back(v[it[1]+1] - v[it[0]]);\\n        }  \\n\\n        return ans;      \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020696,
                "title": "c-best-simplest-optimal-solution-using-prefix-sum",
                "content": "# Complexity\\n- Time complexity:\\nO(max(n, m)) **where n = words.size() and m = queries.size().**\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    bool isVowel(char ch) {\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') \\n            return true;\\n        return false;\\n    }\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n\\n        vector<int> ans, v;\\n\\n        v.push_back(0);\\n\\n        for(int i=0; i<words.size(); i++) {\\n            if(isVowel(words[i][0]) and isVowel(words[i][words[i].size()-1])) v.push_back(v.back() + 1);\\n            else v.push_back(v.back());\\n        }\\n\\n        for(auto it : queries) {\\n            ans.push_back(v[it[1]+1] - v[it[0]]);\\n        }  \\n\\n        return ans;      \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool isVowel(char ch) {\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') \\n            return true;\\n        return false;\\n    }\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n\\n        vector<int> ans, v;\\n\\n        v.push_back(0);\\n\\n        for(int i=0; i<words.size(); i++) {\\n            if(isVowel(words[i][0]) and isVowel(words[i][words[i].size()-1])) v.push_back(v.back() + 1);\\n            else v.push_back(v.back());\\n        }\\n\\n        for(auto it : queries) {\\n            ans.push_back(v[it[1]+1] - v[it[0]]);\\n        }  \\n\\n        return ans;      \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992399,
                "title": "count-vowel-strings-in-ranges",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int[] result = new int[queries.length];\\n        int[] prefix = new int[words.length+1];\\n        HashSet<Character> hs = new HashSet<Character>();\\n        hs.add(\\'a\\');\\n        hs.add(\\'e\\');\\n        hs.add(\\'i\\');\\n        hs.add(\\'o\\');\\n        hs.add(\\'u\\');\\n        for(int i=0;i<words.length;i++)\\n        {\\n            int count=0;\\n            if(hs.contains(words[i].charAt(0))==true&&hs.contains(words[i].charAt(words[i].length()-1))==true)\\n            count++;\\n            prefix[i+1] = prefix[i]+count; \\n        }\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int l = queries[i][0];\\n            int r = queries[i][1]+1;\\n            result[i] = prefix[r]-prefix[l];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int[] result = new int[queries.length];\\n        int[] prefix = new int[words.length+1];\\n        HashSet<Character> hs = new HashSet<Character>();\\n        hs.add(\\'a\\');\\n        hs.add(\\'e\\');\\n        hs.add(\\'i\\');\\n        hs.add(\\'o\\');\\n        hs.add(\\'u\\');\\n        for(int i=0;i<words.length;i++)\\n        {\\n            int count=0;\\n            if(hs.contains(words[i].charAt(0))==true&&hs.contains(words[i].charAt(words[i].length()-1))==true)\\n            count++;\\n            prefix[i+1] = prefix[i]+count; \\n        }\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int l = queries[i][0];\\n            int r = queries[i][1]+1;\\n            result[i] = prefix[r]-prefix[l];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985780,
                "title": "c-explanation-o-n",
                "content": "# Approach\\n\\nWe create a running sum vector where we only increment $i$th element if the $i$th element in `words` is \"vowelled\". That in the second cycle allows us to figure out number of \"vowelled\" words in-between $i$ and $j$ indices by simply subtracting number at the leftmost-index-minus-one from the number under the rigth-most one.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```c++\\nclass Solution {\\n    bool is_vowelled(const string &s) {\\n        const string vowels = \"aeiou\";\\n        return vowels.find(s.back()) != string::npos\\n            && vowels.find(s.front()) != string::npos;\\n    }\\npublic:\\n    vector<int> vowelStrings(const vector<string>& words, const vector<vector<int>>& queries) {\\n        vector<unsigned> runningSum(words.size());\\n        unsigned sum = 0;\\n        for (size_t i = 0; i < words.size(); ++i) {\\n            if (is_vowelled(words[i]))\\n                sum++;\\n            runningSum[i] = sum;\\n        }\\n        vector<int> result(queries.size());\\n        for (size_t i = 0; i < queries.size(); ++i) {\\n            const auto& q = queries[i];\\n            result[i] = runningSum[q[1]] - (q[0] == 0? 0 : runningSum[q[0] - 1]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass Solution {\\n    bool is_vowelled(const string &s) {\\n        const string vowels = \"aeiou\";\\n        return vowels.find(s.back()) != string::npos\\n            && vowels.find(s.front()) != string::npos;\\n    }\\npublic:\\n    vector<int> vowelStrings(const vector<string>& words, const vector<vector<int>>& queries) {\\n        vector<unsigned> runningSum(words.size());\\n        unsigned sum = 0;\\n        for (size_t i = 0; i < words.size(); ++i) {\\n            if (is_vowelled(words[i]))\\n                sum++;\\n            runningSum[i] = sum;\\n        }\\n        vector<int> result(queries.size());\\n        for (size_t i = 0; i < queries.size(); ++i) {\\n            const auto& q = queries[i];\\n            result[i] = runningSum[q[1]] - (q[0] == 0? 0 : runningSum[q[0] - 1]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977640,
                "title": "python-solution-easy-solution",
                "content": "# Code Explanation:\\n\\n- The code is designed to count the number of words in a given list that start and end with vowels within specified ranges for a set of queries.\\n\\n---\\n\\n\\n**Here\\'s a step-by-step explanation of the code:**\\n\\n- It initializes an empty list called cumulative_counts of the same length as the words list. This list will store the cumulative count of words that start and end with vowels as it iterates through the words list.\\n\\n- The code then iterates through each word in the words list using a for loop. For each word, it checks whether the first and last characters are vowels (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'). If both the first and last characters are vowels, it increments the count in the cumulative_counts list by 1. This count represents the cumulative number of words in the words list that start and end with vowels up to the current word.\\n\\n- After processing all the words in the words list, the cumulative_counts list contains cumulative counts for each word. If cumulative_counts[i] is the count of words that start and end with vowels up to index i (inclusive) in the words list.\\n\\n- The code initializes an empty list called results to store the results for the queries.\\n\\n- It iterates through the queries list, where each query is represented as a list [start, end]. For each query, it calculates the count of words that start and end with vowels within the specified range by subtracting cumulative_counts[start - 1] (if start is not 0) from cumulative_counts[end]. This provides the count of such words within the query range.\\n\\n- The calculated count is appended to the results list.\\n\\n- Finally, the code returns the results list, which contains the counts of words that start and end with vowels for each query.\\n\\n---\\n\\n\\n# Time Complexity:\\n\\n- Initializing the cumulative_counts list takes O(N) time, where N is the number of words in the words list.\\n\\n- Calculating the cumulative counts for words also takes O(N) time because it involves iterating through the words list once.\\n\\n- Processing the queries takes O(Q) time, where Q is the number of queries. For each query, it performs a constant amount of work.\\n\\n- The overall time complexity of the code is O(N + Q).\\n\\n---\\n\\n\\n# Space Complexity:\\n\\n- The cumulative_counts list is used to store cumulative counts for each word and takes up O(N) space.\\n\\n- The results list also takes up O(Q) space to store the results for each query.\\n\\n- The overall space complexity of the code is O(N + Q).\\n\\n---\\n\\n\\nIn summary, the code efficiently calculates the cumulative counts of words starting and ending with vowels and then uses these counts to answer queries within the specified ranges. The time and space complexity are both linear in the number of words and queries.\\n\\n# Code\\n```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        # Initialize a list to store cumulative counts of vowel-starting-and-ending words\\n        cumulative_counts = [0] * len(words)\\n        \\n        # Calculate cumulative counts of vowel-starting-and-ending words\\n        for i in range(len(words)):\\n            word = words[i]\\n            starts_with_vowel = word[0] in (\"a\", \"e\", \"i\", \"o\", \"u\")\\n            ends_with_vowel = word[-1] in (\"a\", \"e\", \"i\", \"o\", \"u\")\\n            \\n            if starts_with_vowel and ends_with_vowel:\\n                cumulative_counts[i] = cumulative_counts[i - 1] + 1\\n            else:\\n                cumulative_counts[i] = cumulative_counts[i - 1] if i != 0 else 0\\n        \\n        results = []  # List to store results for each query\\n        \\n        # Calculate results for each query\\n        for query in queries:\\n            start_index, end_index = query\\n            start_count = 0 if start_index == 0 else cumulative_counts[start_index - 1]\\n            result = cumulative_counts[end_index] - start_count\\n            results.append(result)\\n        \\n        return results\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        # Initialize a list to store cumulative counts of vowel-starting-and-ending words\\n        cumulative_counts = [0] * len(words)\\n        \\n        # Calculate cumulative counts of vowel-starting-and-ending words\\n        for i in range(len(words)):\\n            word = words[i]\\n            starts_with_vowel = word[0] in (\"a\", \"e\", \"i\", \"o\", \"u\")\\n            ends_with_vowel = word[-1] in (\"a\", \"e\", \"i\", \"o\", \"u\")\\n            \\n            if starts_with_vowel and ends_with_vowel:\\n                cumulative_counts[i] = cumulative_counts[i - 1] + 1\\n            else:\\n                cumulative_counts[i] = cumulative_counts[i - 1] if i != 0 else 0\\n        \\n        results = []  # List to store results for each query\\n        \\n        # Calculate results for each query\\n        for query in queries:\\n            start_index, end_index = query\\n            start_count = 0 if start_index == 0 else cumulative_counts[start_index - 1]\\n            result = cumulative_counts[end_index] - start_count\\n            results.append(result)\\n        \\n        return results\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973927,
                "title": "java-clean-code-prefix-sum-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private final static String VOWELS = \"aeiou\";\\n\\n    private boolean isVowel(char c) {\\n        return VOWELS.indexOf(c) != -1;\\n    }\\n\\n    private boolean isVowelString(String s) {\\n        if (s.isEmpty()) {\\n            return false;\\n        }\\n        return isVowel(s.charAt(0)) && isVowel(s.charAt(s.length() - 1));\\n    }\\n\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int n = words.length;\\n        int[] prefixSum = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            prefixSum[i] = isVowelString(words[i]) ? 1 : 0;\\n            if (i > 0) {\\n                prefixSum[i] += prefixSum[i - 1];\\n            }\\n        }\\n\\n        int[] res = new int[queries.length];\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            int last = prefixSum[queries[i][1]];\\n            int first = (queries[i][0] > 0) ? prefixSum[queries[i][0] - 1] : 0;\\n            res[i] = last - first;\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private final static String VOWELS = \"aeiou\";\\n\\n    private boolean isVowel(char c) {\\n        return VOWELS.indexOf(c) != -1;\\n    }\\n\\n    private boolean isVowelString(String s) {\\n        if (s.isEmpty()) {\\n            return false;\\n        }\\n        return isVowel(s.charAt(0)) && isVowel(s.charAt(s.length() - 1));\\n    }\\n\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int n = words.length;\\n        int[] prefixSum = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            prefixSum[i] = isVowelString(words[i]) ? 1 : 0;\\n            if (i > 0) {\\n                prefixSum[i] += prefixSum[i - 1];\\n            }\\n        }\\n\\n        int[] res = new int[queries.length];\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            int last = prefixSum[queries[i][1]];\\n            int first = (queries[i][0] > 0) ? prefixSum[queries[i][0] - 1] : 0;\\n            res[i] = last - first;\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957675,
                "title": "fastest-prefixsum-approach",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char& ch) {\\n        return ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n    }\\n\\n    bool isValidString(string& word) {\\n        return isVowel(word[0]) && isVowel(word[word.size() - 1]); \\n    }\\n\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> prefix = {0};\\n\\n        for(string& word : words) {\\n            if(!isValidString(word)) {\\n                prefix.push_back(prefix.back());\\n            } else {\\n                prefix.push_back(prefix.back() + 1);\\n            }\\n        }\\n\\n        vector<int> ans;\\n\\n        for(vector<int>& query : queries) {\\n            int start = query[0];\\n            int end = query[1] + 1;\\n\\n            ans.push_back(prefix[end] - prefix[start]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char& ch) {\\n        return ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n    }\\n\\n    bool isValidString(string& word) {\\n        return isVowel(word[0]) && isVowel(word[word.size() - 1]); \\n    }\\n\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> prefix = {0};\\n\\n        for(string& word : words) {\\n            if(!isValidString(word)) {\\n                prefix.push_back(prefix.back());\\n            } else {\\n                prefix.push_back(prefix.back() + 1);\\n            }\\n        }\\n\\n        vector<int> ans;\\n\\n        for(vector<int>& query : queries) {\\n            int start = query[0];\\n            int end = query[1] + 1;\\n\\n            ans.push_back(prefix[end] - prefix[start]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922981,
                "title": "easy-solution-prefix-sum-fastest-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool istrue(string s){\\n        int n=s.size();\\n        char a1=s[0];\\n        char a2=s[n-1];\\n        if((a1==\\'a\\' || a1==\\'e\\' || a1==\\'i\\' || a1==\\'o\\' || a1==\\'u\\') && (a2==\\'a\\' || a2==\\'e\\' || a2==\\'i\\' || a2==\\'o\\' || a2==\\'u\\'))return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size();\\n        vector<int> prefix(n,0);\\n        if(istrue(words[0]))prefix[0]=1;\\n        for(int i=1;i<n;i++){\\n            int x=0;\\n            if(istrue(words[i]))x=1;\\n            prefix[i]=x+prefix[i-1];\\n        }\\n        vector<int> ans;\\n        for(auto &e: queries){\\n            int left=e[0];\\n            int right=e[1];\\n            int index;\\n            if(left==0)ans.push_back(prefix[right]);\\n            else ans.push_back(prefix[right]-prefix[left-1]);\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool istrue(string s){\\n        int n=s.size();\\n        char a1=s[0];\\n        char a2=s[n-1];\\n        if((a1==\\'a\\' || a1==\\'e\\' || a1==\\'i\\' || a1==\\'o\\' || a1==\\'u\\') && (a2==\\'a\\' || a2==\\'e\\' || a2==\\'i\\' || a2==\\'o\\' || a2==\\'u\\'))return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size();\\n        vector<int> prefix(n,0);\\n        if(istrue(words[0]))prefix[0]=1;\\n        for(int i=1;i<n;i++){\\n            int x=0;\\n            if(istrue(words[i]))x=1;\\n            prefix[i]=x+prefix[i-1];\\n        }\\n        vector<int> ans;\\n        for(auto &e: queries){\\n            int left=e[0];\\n            int right=e[1];\\n            int index;\\n            if(left==0)ans.push_back(prefix[right]);\\n            else ans.push_back(prefix[right]-prefix[left-1]);\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889202,
                "title": "c-easy-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& w, vector<vector<int>>& q) {\\n        int s=0,j=0;\\n        map<int,int> p;vector<int> v;\\n        for(auto i : w)\\n        {\\n            int n=i.size();\\n            if((i[0]==\\'a\\'||i[0]==\\'i\\'||i[0]==\\'o\\'||i[0]==\\'u\\'||i[0]==\\'e\\')&&(i[n-1]==\\'a\\'||i[n-1]==\\'i\\'||i[n-1]==\\'o\\'||i[n-1]==\\'u\\'||i[n-1]==\\'e\\'))\\n            s++;\\n\\n            p[j++]=s;\\n        }\\n        for(auto i : q)\\n                  v.push_back(p[i[1]]-p[i[0]-1]);\\n          \\n          return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& w, vector<vector<int>>& q) {\\n        int s=0,j=0;\\n        map<int,int> p;vector<int> v;\\n        for(auto i : w)\\n        {\\n            int n=i.size();\\n            if((i[0]==\\'a\\'||i[0]==\\'i\\'||i[0]==\\'o\\'||i[0]==\\'u\\'||i[0]==\\'e\\')&&(i[n-1]==\\'a\\'||i[n-1]==\\'i\\'||i[n-1]==\\'o\\'||i[n-1]==\\'u\\'||i[n-1]==\\'e\\'))\\n            s++;\\n\\n            p[j++]=s;\\n        }\\n        for(auto i : q)\\n                  v.push_back(p[i[1]]-p[i[0]-1]);\\n          \\n          return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879903,
                "title": "c-prefix-sum-array-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(string x)\\n    {\\n        char a = x[0];\\n        int n = x.size();\\n        char b = x[n-1];\\n        if(a == \\'a\\' || a == \\'e\\' || a == \\'i\\' || a == \\'o\\' || a == \\'u\\')\\n        {\\n            if(b == \\'a\\' || b == \\'e\\' || b == \\'i\\' || b == \\'o\\' || b == \\'u\\')\\n            {\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        vector<int> v1;\\n        vector<int> ans;\\n        v1.push_back(0);\\n        for(auto x : words)\\n        {\\n            v1.push_back(check(x));\\n        }\\n        for(int i = 1 ; i <= n ; i++)\\n        {\\n            v1[i] += v1[i-1];\\n        }\\n        for(auto x : queries)\\n        {\\n            ans.push_back(v1[x[1]+1]-v1[x[0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(string x)\\n    {\\n        char a = x[0];\\n        int n = x.size();\\n        char b = x[n-1];\\n        if(a == \\'a\\' || a == \\'e\\' || a == \\'i\\' || a == \\'o\\' || a == \\'u\\')\\n        {\\n            if(b == \\'a\\' || b == \\'e\\' || b == \\'i\\' || b == \\'o\\' || b == \\'u\\')\\n            {\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        vector<int> v1;\\n        vector<int> ans;\\n        v1.push_back(0);\\n        for(auto x : words)\\n        {\\n            v1.push_back(check(x));\\n        }\\n        for(int i = 1 ; i <= n ; i++)\\n        {\\n            v1[i] += v1[i-1];\\n        }\\n        for(auto x : queries)\\n        {\\n            ans.push_back(v1[x[1]+1]-v1[x[0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879412,
                "title": "javascript-2559-count-vowel-strings-in-ranges",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar vowelStrings = function (ws, qs) {\\n  let n = ws.length\\n\\n  let f = new Array(n).fill(0)\\n  let i = -1\\n  for (let w of ws) {\\n    i++\\n    if (\\n      /[aeiou]/.test(w[0]) && //\\n      /[aeiou]/.test(w.at(-1))\\n    )\\n      f[i] = 1\\n  }\\n\\n  let pre = new Array(n)\\n  for (let i = 0, /**/ s = 0; i < n; i++) pre[i] = s += f[i]\\n\\n  let an = []\\n  for (let [s, e] of qs) {\\n    an.push(pre[e] - (pre[s - 1] || 0))\\n  }\\n  return an\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar vowelStrings = function (ws, qs) {\\n  let n = ws.length\\n\\n  let f = new Array(n).fill(0)\\n  let i = -1\\n  for (let w of ws) {\\n    i++\\n    if (\\n      /[aeiou]/.test(w[0]) && //\\n      /[aeiou]/.test(w.at(-1))\\n    )\\n      f[i] = 1\\n  }\\n\\n  let pre = new Array(n)\\n  for (let i = 0, /**/ s = 0; i < n; i++) pre[i] = s += f[i]\\n\\n  let an = []\\n  for (let [s, e] of qs) {\\n    an.push(pre[e] - (pre[s - 1] || 0))\\n  }\\n  return an\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854099,
                "title": "beats-95-81-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        vector<int> ans(n);\\n        vector<int> res;\\n        for(int i=0;i<n;i++)\\n        {\\n            string str = words[i];\\n            int l = str.length()-1;\\n            if((str[0]==\\'a\\' || str[0]==\\'e\\' || str[0]==\\'i\\' || str[0]==\\'o\\' || str[0]==\\'u\\')&&(str[l]==\\'a\\' || str[l]==\\'e\\'||str[l]==\\'i\\'||str[l]==\\'o\\'||str[l]==\\'u\\'))\\n            {\\n                ans[i] = 1;\\n            }\\n        }\\n\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n\\n        for(auto i:queries)\\n        {\\n            int f = i[0];\\n            int s = i[1];\\n            if(f==0)\\n            res.push_back(ans[s]);\\n            else\\n            res.push_back(ans[s]-ans[f-1]);\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        vector<int> ans(n);\\n        vector<int> res;\\n        for(int i=0;i<n;i++)\\n        {\\n            string str = words[i];\\n            int l = str.length()-1;\\n            if((str[0]==\\'a\\' || str[0]==\\'e\\' || str[0]==\\'i\\' || str[0]==\\'o\\' || str[0]==\\'u\\')&&(str[l]==\\'a\\' || str[l]==\\'e\\'||str[l]==\\'i\\'||str[l]==\\'o\\'||str[l]==\\'u\\'))\\n            {\\n                ans[i] = 1;\\n            }\\n        }\\n\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n\\n        for(auto i:queries)\\n        {\\n            int f = i[0];\\n            int s = i[1];\\n            if(f==0)\\n            res.push_back(ans[s]);\\n            else\\n            res.push_back(ans[s]-ans[f-1]);\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849525,
                "title": "beat-97-easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        vowel=[\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        ans=[]\\n        for i in range(len(words)):\\n            t=words[i][0]\\n            v=words[i][-1]\\n            if (t in vowel) and v in vowel:\\n                words[i]=1\\n            else:\\n                words[i]=0\\n        Sum=0\\n        for j in range(len(words)):\\n            words[j]=Sum+words[j]\\n            Sum=words[j]\\n        for p in range(len(queries)):\\n            first=queries[p][0]\\n            second=queries[p][1]\\n            if first==0:\\n                ans.append(words[second])\\n            else:\\n                ans.append(words[second]-words[first-1])\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        vowel=[\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        ans=[]\\n        for i in range(len(words)):\\n            t=words[i][0]\\n            v=words[i][-1]\\n            if (t in vowel) and v in vowel:\\n                words[i]=1\\n            else:\\n                words[i]=0\\n        Sum=0\\n        for j in range(len(words)):\\n            words[j]=Sum+words[j]\\n            Sum=words[j]\\n        for p in range(len(queries)):\\n            first=queries[p][0]\\n            second=queries[p][1]\\n            if first==0:\\n                ans.append(words[second])\\n            else:\\n                ans.append(words[second]-words[first-1])\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848125,
                "title": "c-solution-beats-99",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n+q)\\nwhere n is the size of words array\\nand q is the size of queries vector\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string s)\\n    {\\n        int n=s.size();\\n        if( (s[0]==\\'a\\' || s[0]==\\'e\\' || s[0]==\\'i\\' || s[0]==\\'o\\' || s[0]==\\'u\\')  &&\\n            (s[n-1]==\\'a\\' || s[n-1]==\\'e\\' || s[n-1]==\\'i\\' || s[n-1]==\\'o\\' || s[n-1]==\\'u\\' ) )\\n            return true;\\n\\n        return false;    \\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size();\\n        vector<int> psum(n);\\n        psum[0]= (check(words[0])) ? 1 : 0 ;\\n        for(int i=1;i<n;i++)\\n            psum[i] = psum[i-1] + check(words[i]) ;\\n\\n        vector<int> ans(queries.size());\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            if(queries[i][0]==0)\\n                ans[i]=psum[queries[i][1]];\\n            else\\n                ans[i]=psum[queries[i][1]] - psum[queries[i][0]-1];    \\n        }     \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s)\\n    {\\n        int n=s.size();\\n        if( (s[0]==\\'a\\' || s[0]==\\'e\\' || s[0]==\\'i\\' || s[0]==\\'o\\' || s[0]==\\'u\\')  &&\\n            (s[n-1]==\\'a\\' || s[n-1]==\\'e\\' || s[n-1]==\\'i\\' || s[n-1]==\\'o\\' || s[n-1]==\\'u\\' ) )\\n            return true;\\n\\n        return false;    \\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size();\\n        vector<int> psum(n);\\n        psum[0]= (check(words[0])) ? 1 : 0 ;\\n        for(int i=1;i<n;i++)\\n            psum[i] = psum[i-1] + check(words[i]) ;\\n\\n        vector<int> ans(queries.size());\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            if(queries[i][0]==0)\\n                ans[i]=psum[queries[i][1]];\\n            else\\n                ans[i]=psum[queries[i][1]] - psum[queries[i][0]-1];    \\n        }     \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818619,
                "title": "prefix-sum",
                "content": "```\\nvector<int> vowelStrings(vector<string>& w, vector<vector<int>>& q)\\n{\\n\\tint d[100001]{};\\n\\tunordered_set us{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n\\tfor(int i{}; i<size(w); ++i)\\n\\t\\td[i+1] = d[i] + (us.count(w[i].front()) and us.count(w[i].back())); \\n\\n\\tvector<int> out;\\n\\tfor(const auto & q : q)\\n\\t\\tout.push_back(d[q[1]+1]-d[q[0]]);\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> vowelStrings(vector<string>& w, vector<vector<int>>& q)\\n{\\n\\tint d[100001]{};\\n\\tunordered_set us{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n\\tfor(int i{}; i<size(w); ++i)\\n\\t\\td[i+1] = d[i] + (us.count(w[i].front()) and us.count(w[i].back())); \\n\\n\\tvector<int> out;\\n\\tfor(const auto & q : q)\\n\\t\\tout.push_back(d[q[1]+1]-d[q[0]]);\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3789535,
                "title": "set-vector-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& w, vector<vector<int>>& q) {\\n        set<char>st={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        vector<int>pref,ans;int count=0;\\n       for(int i=0;i<w.size();i++){\\n         int f=w[i][0],s=w[i][w[i].size()-1];\\n         if(st.find(f)!=st.end()&&st.find(s)!=st.end())count++;\\n         pref.push_back(count);\\n        }\\n        for(int i=0;i<q.size();i++){\\n        int f=q[i][0],s=q[i][1];\\n        if(st.find(w[f][0])!=st.end()&&st.find(w[f][w[f].size()-1])!=st.end ())     {ans.push_back(pref[s]-pref[f]+1);}\\n        else ans.push_back(pref[s]-pref[f]);}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& w, vector<vector<int>>& q) {\\n        set<char>st={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        vector<int>pref,ans;int count=0;\\n       for(int i=0;i<w.size();i++){\\n         int f=w[i][0],s=w[i][w[i].size()-1];\\n         if(st.find(f)!=st.end()&&st.find(s)!=st.end())count++;\\n         pref.push_back(count);\\n        }\\n        for(int i=0;i<q.size();i++){\\n        int f=q[i][0],s=q[i][1];\\n        if(st.find(w[f][0])!=st.end()&&st.find(w[f][w[f].size()-1])!=st.end ())     {ans.push_back(pref[s]-pref[f]+1);}\\n        else ans.push_back(pref[s]-pref[f]);}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772325,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int presum[]=new int[words.length];\\n        for(int i=0;i<words.length;i++){\\n            boolean b=false;\\n            String l=words[i];\\n            int n=l.length()-1;\\n            if ((l.charAt(0) == \\'a\\' || l.charAt(0) == \\'e\\' || l.charAt(0) == \\'i\\' || l.charAt(0) == \\'o\\' || l.charAt(0) == \\'u\\') && (l.charAt(n) == \\'a\\' || l.charAt(n) == \\'e\\' || l.charAt(n) == \\'i\\' || l.charAt(n) == \\'o\\' || l.charAt(n) == \\'u\\')) {\\n\\n                b=true;\\n            }\\n            if(b){\\n                if(i==0){\\n                    presum[i]=1;\\n                }\\n                else{\\n                    presum[i]=presum[i-1]+1;\\n                }\\n            }\\n            else{\\n                if(i>0){\\n                presum[i]=presum[i-1]+presum[i];\\n                }\\n            }\\n        }\\n        int ans[]=new int[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            int lo=queries[i][0];\\n            int up=queries[i][1];\\n            ans[i]=(lo==0)?presum[up]:presum[up]-presum[lo-1];\\n            }\\n            return ans;\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int presum[]=new int[words.length];\\n        for(int i=0;i<words.length;i++){\\n            boolean b=false;\\n            String l=words[i];\\n            int n=l.length()-1;\\n            if ((l.charAt(0) == \\'a\\' || l.charAt(0) == \\'e\\' || l.charAt(0) == \\'i\\' || l.charAt(0) == \\'o\\' || l.charAt(0) == \\'u\\') && (l.charAt(n) == \\'a\\' || l.charAt(n) == \\'e\\' || l.charAt(n) == \\'i\\' || l.charAt(n) == \\'o\\' || l.charAt(n) == \\'u\\')) {\\n\\n                b=true;\\n            }\\n            if(b){\\n                if(i==0){\\n                    presum[i]=1;\\n                }\\n                else{\\n                    presum[i]=presum[i-1]+1;\\n                }\\n            }\\n            else{\\n                if(i>0){\\n                presum[i]=presum[i-1]+presum[i];\\n                }\\n            }\\n        }\\n        int ans[]=new int[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            int lo=queries[i][0];\\n            int up=queries[i][1];\\n            ans[i]=(lo==0)?presum[up]:presum[up]-presum[lo-1];\\n            }\\n            return ans;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769526,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] VowelStrings(string[] words, int[][] queries) {\\n        var res = new int[queries.GetLength(0)];\\n        var vowelString = new int[words.Length + 1];\\n        for(int idx = 0; idx < words.Length; idx++) {\\n            if(IsVowel(words[idx][0]) && IsVowel(words[idx][^1]))\\n                vowelString[idx + 1] = 1 + vowelString[idx];\\n            else\\n                vowelString[idx + 1] = vowelString[idx];\\n        }\\n\\n        for(int idx = 0; idx < queries.GetLength(0); idx++)\\n            res[idx] = vowelString[queries[idx][1] + 1] - vowelString[queries[idx][0]];\\n\\n        return res;\\n    }\\n\\n    private bool IsVowel(char chr) {\\n        return chr == \\'a\\' || chr == \\'e\\' || chr == \\'i\\' || chr == \\'o\\' || chr == \\'u\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] VowelStrings(string[] words, int[][] queries) {\\n        var res = new int[queries.GetLength(0)];\\n        var vowelString = new int[words.Length + 1];\\n        for(int idx = 0; idx < words.Length; idx++) {\\n            if(IsVowel(words[idx][0]) && IsVowel(words[idx][^1]))\\n                vowelString[idx + 1] = 1 + vowelString[idx];\\n            else\\n                vowelString[idx + 1] = vowelString[idx];\\n        }\\n\\n        for(int idx = 0; idx < queries.GetLength(0); idx++)\\n            res[idx] = vowelString[queries[idx][1] + 1] - vowelString[queries[idx][0]];\\n\\n        return res;\\n    }\\n\\n    private bool IsVowel(char chr) {\\n        return chr == \\'a\\' || chr == \\'e\\' || chr == \\'i\\' || chr == \\'o\\' || chr == \\'u\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757670,
                "title": "count-vowel-strings-in-ranges-easy-solution-fast-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        if(c==\\'a\\' or c==\\'e\\' or c==\\'i\\' or c==\\'o\\' or c==\\'u\\')\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) \\n    {\\n        vector<int>ans;\\n        vector<int>pre;\\n\\n        pre.push_back(0);\\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            if(isVowel(words[i][0]) and isVowel(words[i].back()))\\n            {\\n                pre.push_back(pre.back()+1);\\n            }\\n            else\\n            {\\n                pre.push_back(pre.back());\\n            }\\n        }\\n\\n        for(int i = 0; i<queries.size(); i++)\\n        {\\n            ans.push_back(pre[queries[i][1]+1]-pre[queries[i][0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        if(c==\\'a\\' or c==\\'e\\' or c==\\'i\\' or c==\\'o\\' or c==\\'u\\')\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) \\n    {\\n        vector<int>ans;\\n        vector<int>pre;\\n\\n        pre.push_back(0);\\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            if(isVowel(words[i][0]) and isVowel(words[i].back()))\\n            {\\n                pre.push_back(pre.back()+1);\\n            }\\n            else\\n            {\\n                pre.push_back(pre.back());\\n            }\\n        }\\n\\n        for(int i = 0; i<queries.size(); i++)\\n        {\\n            ans.push_back(pre[queries[i][1]+1]-pre[queries[i][0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718708,
                "title": "less-complexity-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        List<Integer> vowel = new ArrayList<>();\\n        int[] occ = new int[queries.length];\\n        int num = 0;\\n        for(int i=0; i<words.length;i++){\\n            int last = words[i].length()-1;\\n            if((words[i].charAt(0) == \\'a\\' || words[i].charAt(0) == \\'e\\' || words[i].charAt(0) == \\'i\\' || words[i].charAt(0) == \\'o\\' || words[i].charAt(0) == \\'u\\') && (words[i].charAt(last) == \\'a\\' || words[i].charAt(last) == \\'e\\' || words[i].charAt(last) == \\'i\\' || words[i].charAt(last) == \\'o\\' ||words[i].charAt(last) == \\'u\\')){\\n                num++;\\n                vowel.add(num);\\n            }\\n            else{\\n                vowel.add(num);\\n            }\\n        }\\n        System.out.println(vowel);\\n        for(int j=0; j<queries.length;j++){\\n            if(queries[j][0] == 0){\\n                occ[j] = vowel.get(queries[j][1]);\\n            }\\n            else {\\n                occ[j] = vowel.get(queries[j][1]) - vowel.get(queries[j][0]-1);\\n            }\\n\\n        }\\n        return occ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        List<Integer> vowel = new ArrayList<>();\\n        int[] occ = new int[queries.length];\\n        int num = 0;\\n        for(int i=0; i<words.length;i++){\\n            int last = words[i].length()-1;\\n            if((words[i].charAt(0) == \\'a\\' || words[i].charAt(0) == \\'e\\' || words[i].charAt(0) == \\'i\\' || words[i].charAt(0) == \\'o\\' || words[i].charAt(0) == \\'u\\') && (words[i].charAt(last) == \\'a\\' || words[i].charAt(last) == \\'e\\' || words[i].charAt(last) == \\'i\\' || words[i].charAt(last) == \\'o\\' ||words[i].charAt(last) == \\'u\\')){\\n                num++;\\n                vowel.add(num);\\n            }\\n            else{\\n                vowel.add(num);\\n            }\\n        }\\n        System.out.println(vowel);\\n        for(int j=0; j<queries.length;j++){\\n            if(queries[j][0] == 0){\\n                occ[j] = vowel.get(queries[j][1]);\\n            }\\n            else {\\n                occ[j] = vowel.get(queries[j][1]) - vowel.get(queries[j][0]-1);\\n            }\\n\\n        }\\n        return occ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667131,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector <int> ans(queries.size());\\n        vector <int>sum;\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string temp=words[i];\\n            int n=temp.size()-1;\\n            if((temp[0]==\\'a\\'||temp[0]==\\'e\\'|| temp[0]==\\'i\\' || temp[0]==\\'o\\'|| temp[0]==\\'u\\')&&(temp[n]==\\'a\\'||temp[n]==\\'e\\'|| temp[n]==\\'i\\' || temp[n]==\\'o\\'|| temp[n]==\\'u\\')) count++;\\n            sum.push_back(count);\\n\\n        }\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int x=0;\\n            if(queries[i][0]-1 >=0) x=sum[queries[i][0]-1];\\n            int y=sum[queries[i][1]];\\n            ans[i]=y-x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector <int> ans(queries.size());\\n        vector <int>sum;\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string temp=words[i];\\n            int n=temp.size()-1;\\n            if((temp[0]==\\'a\\'||temp[0]==\\'e\\'|| temp[0]==\\'i\\' || temp[0]==\\'o\\'|| temp[0]==\\'u\\')&&(temp[n]==\\'a\\'||temp[n]==\\'e\\'|| temp[n]==\\'i\\' || temp[n]==\\'o\\'|| temp[n]==\\'u\\')) count++;\\n            sum.push_back(count);\\n\\n        }\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int x=0;\\n            if(queries[i][0]-1 >=0) x=sum[queries[i][0]-1];\\n            int y=sum[queries[i][1]];\\n            ans[i]=y-x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666253,
                "title": "easy-cpp-sol",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool check(string s,int n){\\n    if((s[0]==\\'a\\' || s[0]==\\'e\\'|| s[0]==\\'o\\'||s[0]==\\'i\\'||s[0]==\\'u\\') && (s[n-1]==\\'a\\' || s[n-1]==\\'e\\'|| s[n-1]==\\'o\\'||s[n-1]==\\'i\\'||s[n-1]==\\'u\\')   ) return true;\\n    return false;\\n}\\n    vector<int> vowelStrings(vector<string>& s, vector<vector<int>>& query) { int n1 = s.size(), n2=query.size();\\n    vector<int> vow;\\n    int dp[n1];\\n if(check(s[0], s[0].size())) dp[0]=1;\\n      else dp[0]=0;\\n    for(int i=1;i<n1;i++){\\n        if(check(s[i], s[i].size())) dp[i]=dp[i-1]+1;\\n      else dp[i]=dp[i-1];\\n    }\\n    for(int i=0;i<n2;i++){\\n        if(query[i][0])  {query[i][0]-= 1;\\n    \\n        int sum= dp[query[i][1]]-dp[query[i][0]];\\n        vow.push_back(sum);}\\n        else vow.push_back(dp[query[i][1]]);\\n    }\\n  return vow;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool check(string s,int n){\\n    if((s[0]==\\'a\\' || s[0]==\\'e\\'|| s[0]==\\'o\\'||s[0]==\\'i\\'||s[0]==\\'u\\') && (s[n-1]==\\'a\\' || s[n-1]==\\'e\\'|| s[n-1]==\\'o\\'||s[n-1]==\\'i\\'||s[n-1]==\\'u\\')   ) return true;\\n    return false;\\n}\\n    vector<int> vowelStrings(vector<string>& s, vector<vector<int>>& query) { int n1 = s.size(), n2=query.size();\\n    vector<int> vow;\\n    int dp[n1];\\n if(check(s[0], s[0].size())) dp[0]=1;\\n      else dp[0]=0;\\n    for(int i=1;i<n1;i++){\\n        if(check(s[i], s[i].size())) dp[i]=dp[i-1]+1;\\n      else dp[i]=dp[i-1];\\n    }\\n    for(int i=0;i<n2;i++){\\n        if(query[i][0])  {query[i][0]-= 1;\\n    \\n        int sum= dp[query[i][1]]-dp[query[i][0]];\\n        vow.push_back(sum);}\\n        else vow.push_back(dp[query[i][1]]);\\n    }\\n  return vow;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663779,
                "title": "c-easy-string-and-prefix-sum-of-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n     vector<int> v;\\n     int cnt=0;\\n      v.push_back(0);\\n     for(string it:words){\\n         bool c=0;\\n         string p=it;\\n         int k=p.size()-1;\\n         if(p[0]==\\'a\\' or p[0]==\\'e\\' or p[0]==\\'i\\' or p[0]==\\'o\\' or p[0]==\\'u\\'){\\n             if(p[k]==\\'a\\' or p[k]==\\'e\\' or p[k]==\\'i\\' or p[k]==\\'o\\' or p[k]==\\'u\\'){\\n                c=true;\\n             }\\n            }\\n        if(c) cnt++;\\n        v.push_back(cnt);\\n     }\\n     vector<int>ans;\\n    for(auto it:queries){\\n        ans.push_back(v[it[1]+1]-v[it[0]]);\\n    }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n     vector<int> v;\\n     int cnt=0;\\n      v.push_back(0);\\n     for(string it:words){\\n         bool c=0;\\n         string p=it;\\n         int k=p.size()-1;\\n         if(p[0]==\\'a\\' or p[0]==\\'e\\' or p[0]==\\'i\\' or p[0]==\\'o\\' or p[0]==\\'u\\'){\\n             if(p[k]==\\'a\\' or p[k]==\\'e\\' or p[k]==\\'i\\' or p[k]==\\'o\\' or p[k]==\\'u\\'){\\n                c=true;\\n             }\\n            }\\n        if(c) cnt++;\\n        v.push_back(cnt);\\n     }\\n     vector<int>ans;\\n    for(auto it:queries){\\n        ans.push_back(v[it[1]+1]-v[it[0]]);\\n    }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637120,
                "title": "very-easily-understandable-for-beginners-no-complex-idea",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\none function to check a char is vowel\\none function is to check that given string is valid as per given conditions or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate a array of count to store no of valid string upto that given index in the words.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool vowel(char c){\\n        if(c==\\'a\\'|| c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\'){\\n            return true;\\n        } return false;\\n    }\\n     int isvowels(string s){\\n         if(s.size()==1 && vowel(s[0])){\\n             return 1;\\n         }\\n         else if(vowel(s[0]) && vowel(s[s.size()-1])){\\n             return 1;\\n         }\\n         return 0;\\n     }\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        vector<int>count(words.size(),0);\\n        if(isvowels(words[0])==1){\\n            count[0]=1;\\n        }\\n        else{\\n            count[0]=0;\\n        }\\n        for(int i=1;i<words.size();i++){\\n            count[i]=count[i-1]+isvowels(words[i]);\\n        }\\n        cout<<count[0];\\n        for(long long  i=0;i<queries.size();i++){\\n            if(isvowels(words[queries[i][0]])==1){\\n                ans.push_back(count[queries[i][1]]-count[queries[i][0]]+1);\\n            }\\n            else{\\n             ans.push_back(count[queries[i][1]]-count[queries[i][0]]);\\n            }\\n        }\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool vowel(char c){\\n        if(c==\\'a\\'|| c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\'){\\n            return true;\\n        } return false;\\n    }\\n     int isvowels(string s){\\n         if(s.size()==1 && vowel(s[0])){\\n             return 1;\\n         }\\n         else if(vowel(s[0]) && vowel(s[s.size()-1])){\\n             return 1;\\n         }\\n         return 0;\\n     }\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        vector<int>count(words.size(),0);\\n        if(isvowels(words[0])==1){\\n            count[0]=1;\\n        }\\n        else{\\n            count[0]=0;\\n        }\\n        for(int i=1;i<words.size();i++){\\n            count[i]=count[i-1]+isvowels(words[i]);\\n        }\\n        cout<<count[0];\\n        for(long long  i=0;i<queries.size();i++){\\n            if(isvowels(words[queries[i][0]])==1){\\n                ans.push_back(count[queries[i][1]]-count[queries[i][0]]+1);\\n            }\\n            else{\\n             ans.push_back(count[queries[i][1]]-count[queries[i][0]]);\\n            }\\n        }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3635044,
                "title": "easy-solution-beats-100-in-space-and-time",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    int check(string word){\\n        int ans = 0;\\n        int n = word.size();\\n        if((word[0] == \\'a\\' or word[0] == \\'e\\' or word[0] == \\'i\\' or word[0] == \\'o\\' or word[0]== \\'u\\') and (word[n-1] == \\'a\\' or word[n-1] == \\'e\\' or word[n-1] == \\'i\\' or word[n-1] == \\'o\\' or word[n-1] == \\'u\\')){\\n            ans += 1;\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        vector<int> prefix(n,0);\\n        vector<int> ans;\\n        prefix[0] = check(words[0]);\\n        for(int  i = 1; i < n; i++){\\n            prefix[i] += prefix[i-1] + check(words[i]);\\n        }\\n\\n        for(int i = 0; i < queries.size(); i++){\\n            int l1 = queries[i][0];\\n            int r1 = queries[i][1];\\n            int val = prefix[r1];\\n            if(l1 != 0){\\n                val -= prefix[l1-1];\\n            }\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int check(string word){\\n        int ans = 0;\\n        int n = word.size();\\n        if((word[0] == \\'a\\' or word[0] == \\'e\\' or word[0] == \\'i\\' or word[0] == \\'o\\' or word[0]== \\'u\\') and (word[n-1] == \\'a\\' or word[n-1] == \\'e\\' or word[n-1] == \\'i\\' or word[n-1] == \\'o\\' or word[n-1] == \\'u\\')){\\n            ans += 1;\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        vector<int> prefix(n,0);\\n        vector<int> ans;\\n        prefix[0] = check(words[0]);\\n        for(int  i = 1; i < n; i++){\\n            prefix[i] += prefix[i-1] + check(words[i]);\\n        }\\n\\n        for(int i = 0; i < queries.size(); i++){\\n            int l1 = queries[i][0];\\n            int r1 = queries[i][1];\\n            int val = prefix[r1];\\n            if(l1 != 0){\\n                val -= prefix[l1-1];\\n            }\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617855,
                "title": "c-solution-using-prefix-sum-with-t-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        vector<int> v(n+1,0);\\n        for(int i=0;i<n;++i){\\n            int sz = words[i].size();\\n            if((words[i][0] == \\'a\\' || words[i][0] == \\'e\\' || words[i][0] == \\'i\\' || words[i][0] == \\'o\\' || words[i][0] == \\'u\\') &&(words[i][sz-1] == \\'a\\' || words[i][sz-1] == \\'e\\' || words[i][sz-1] == \\'i\\' || words[i][sz-1] == \\'o\\' || words[i][sz-1] == \\'u\\')){\\n                v[i+1] = 1;\\n            }\\n            v[i+1] += v[i];\\n        }\\n        \\n        vector<int> ans;\\n        for(int i=0;i<queries.size();++i){\\n            ans.push_back(v[queries[i][1]+1]-v[queries[i][0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        vector<int> v(n+1,0);\\n        for(int i=0;i<n;++i){\\n            int sz = words[i].size();\\n            if((words[i][0] == \\'a\\' || words[i][0] == \\'e\\' || words[i][0] == \\'i\\' || words[i][0] == \\'o\\' || words[i][0] == \\'u\\') &&(words[i][sz-1] == \\'a\\' || words[i][sz-1] == \\'e\\' || words[i][sz-1] == \\'i\\' || words[i][sz-1] == \\'o\\' || words[i][sz-1] == \\'u\\')){\\n                v[i+1] = 1;\\n            }\\n            v[i+1] += v[i];\\n        }\\n        \\n        vector<int> ans;\\n        for(int i=0;i<queries.size();++i){\\n            ans.push_back(v[queries[i][1]+1]-v[queries[i][0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587659,
                "title": "lc-2559-m-python3-prefix-sum",
                "content": "Converting `words` to `bins` and using the prefix sum of `bins` to calculate the result.\\nTC: $\\\\Omicron(\\\\max(m, n))$, where `m = len(words)`, `n = len(queries)`.\\n\\n```Python3 []\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n        bins = [1 if word[0] in vowels and word[-1] in vowels else 0 for word in words]\\n        pf_sum = list(accumulate(bins, initial=0))\\n\\n        return [pf_sum[query[1]+1] - pf_sum[query[0]] for query in queries]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n        bins = [1 if word[0] in vowels and word[-1] in vowels else 0 for word in words]\\n        pf_sum = list(accumulate(bins, initial=0))\\n\\n        return [pf_sum[query[1]+1] - pf_sum[query[0]] for query in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573815,
                "title": "easy-solution-4-lines",
                "content": "# Code\\n```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        count, vowel = [0], \\'aeiou\\'\\n        for word in words:\\n            count.append(count[-1] + (1 if word[0] in vowel and word[-1] in vowel else 0))\\n        return [count[e+1] - (count[s] if s else 0) for s, e in queries]\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        count, vowel = [0], \\'aeiou\\'\\n        for word in words:\\n            count.append(count[-1] + (1 if word[0] in vowel and word[-1] in vowel else 0))\\n        return [count[e+1] - (count[s] if s else 0) for s, e in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567747,
                "title": "java-solution-with-prefix-sum-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        HashSet<Character> vowels = new HashSet<>(Arrays.asList(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'));\\n        int n = words.length;\\n        int[] validWords = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            char startChar = words[i].charAt(0);\\n            char endChar = words[i].charAt(words[i].length() - 1);\\n            validWords[i] = (vowels.contains(startChar) && vowels.contains(endChar)) ? 1 : 0;\\n        }\\n        \\n        int[] prefix = new int[n];\\n        prefix[0] = validWords[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i - 1] + validWords[i];\\n        }\\n        \\n        int[] output = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            int start = queries[i][0];\\n            int end = queries[i][1];\\n            output[i] = (start == 0) ? prefix[end] : prefix[end] - prefix[start - 1];\\n        }\\n        \\n        return output;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        HashSet<Character> vowels = new HashSet<>(Arrays.asList(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'));\\n        int n = words.length;\\n        int[] validWords = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            char startChar = words[i].charAt(0);\\n            char endChar = words[i].charAt(words[i].length() - 1);\\n            validWords[i] = (vowels.contains(startChar) && vowels.contains(endChar)) ? 1 : 0;\\n        }\\n        \\n        int[] prefix = new int[n];\\n        prefix[0] = validWords[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i - 1] + validWords[i];\\n        }\\n        \\n        int[] output = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            int start = queries[i][0];\\n            int end = queries[i][1];\\n            output[i] = (start == 0) ? prefix[end] : prefix[end] - prefix[start - 1];\\n        }\\n        \\n        return output;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546027,
                "title": "cpp-solution-code-like-a-pro",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n<!-- Please upvote if you like this solution -->\\nclass Solution {\\npublic:\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size();\\n        vector<int> ans(n+1,0);\\n        unordered_map<char,int> mp;\\n        mp[\\'a\\']=1;\\n        mp[\\'e\\']=1;\\n        mp[\\'i\\']=1;\\n        mp[\\'o\\']=1;\\n        mp[\\'u\\']=1;\\n        for(int i=0;i<words.size();i++){\\n            string st=words[i];\\n            if(mp[st[0]]&&mp[st[st.size()-1]]){\\n                ans[i+1]=1;\\n            }            \\n        }\\n        for(int i=1;i<ans.size();i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        int m=queries.size();\\n        int i=0;\\n        vector<int> res(m,0);\\n        for(auto it: queries){\\n            int start=it[0];\\n            int end=it[1];\\n            res[i]=ans[end+1]-ans[start];\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\n<!-- Please upvote if you like this solution -->\\nclass Solution {\\npublic:\\n    \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size();\\n        vector<int> ans(n+1,0);\\n        unordered_map<char,int> mp;\\n        mp[\\'a\\']=1;\\n        mp[\\'e\\']=1;\\n        mp[\\'i\\']=1;\\n        mp[\\'o\\']=1;\\n        mp[\\'u\\']=1;\\n        for(int i=0;i<words.size();i++){\\n            string st=words[i];\\n            if(mp[st[0]]&&mp[st[st.size()-1]]){\\n                ans[i+1]=1;\\n            }            \\n        }\\n        for(int i=1;i<ans.size();i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        int m=queries.size();\\n        int i=0;\\n        vector<int> res(m,0);\\n        for(auto it: queries){\\n            int start=it[0];\\n            int end=it[1];\\n            res[i]=ans[end+1]-ans[start];\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538376,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn vowel_strings(words: Vec<String>, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        use std::collections::HashSet;\\n        let vowels = vec![\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n            .into_iter()\\n            .collect::<HashSet<_>>();\\n        let mut prefix = vec![0];\\n        for (i, w) in words.iter().enumerate() {\\n            let w = w.chars().collect::<Vec<_>>();\\n            prefix.push(\\n                prefix[i]\\n                    + if vowels.contains(&w[0]) && vowels.contains(&w[w.len() - 1]) {\\n                        1\\n                    } else {\\n                        0\\n                    },\\n            );\\n        }\\n        let mut ans = vec![];\\n        for q in queries {\\n            ans.push(prefix[q[1] as usize + 1] - prefix[q[0] as usize]);\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn vowel_strings(words: Vec<String>, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        use std::collections::HashSet;\\n        let vowels = vec![\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n            .into_iter()\\n            .collect::<HashSet<_>>();\\n        let mut prefix = vec![0];\\n        for (i, w) in words.iter().enumerate() {\\n            let w = w.chars().collect::<Vec<_>>();\\n            prefix.push(\\n                prefix[i]\\n                    + if vowels.contains(&w[0]) && vowels.contains(&w[w.len() - 1]) {\\n                        1\\n                    } else {\\n                        0\\n                    },\\n            );\\n        }\\n        let mut ans = vec![];\\n        for q in queries {\\n            ans.push(prefix[q[1] as usize + 1] - prefix[q[0] as usize]);\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520398,
                "title": "simple-and-easy-to-understand-prefix-sum-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        vector<int> dummy(words.size(), 0);\\n        \\n        string s = \"aeiou\";\\n        \\n        int k = 0;\\n        for(auto st: words){\\n           if(s.find(st[0]) != string::npos && s.find(st.back()) != string::npos){\\n                    dummy[k++] = 1;\\n                }else{\\n                    dummy[k++] = 0;\\n                }    \\n        }\\n            \\n        for(int i = 1;i < dummy.size();i++){\\n            dummy[i] += dummy[i-1];\\n        }\\n        for(auto q: queries){\\n            int s = q[0];\\n            int e = q[1];\\n            if(s == 0){\\n                ans.push_back(dummy[e]);\\n            }else{\\n                ans.push_back(dummy[e]-dummy[s-1]);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        vector<int> dummy(words.size(), 0);\\n        \\n        string s = \"aeiou\";\\n        \\n        int k = 0;\\n        for(auto st: words){\\n           if(s.find(st[0]) != string::npos && s.find(st.back()) != string::npos){\\n                    dummy[k++] = 1;\\n                }else{\\n                    dummy[k++] = 0;\\n                }    \\n        }\\n            \\n        for(int i = 1;i < dummy.size();i++){\\n            dummy[i] += dummy[i-1];\\n        }\\n        for(auto q: queries){\\n            int s = q[0];\\n            int e = q[1];\\n            if(s == 0){\\n                ans.push_back(dummy[e]);\\n            }else{\\n                ans.push_back(dummy[e]-dummy[s-1]);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501326,
                "title": "c-prefixsum-not-a-medium-level-question",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        return c==\\'a\\' or c==\\'e\\' or c==\\'i\\' or c==\\'o\\' or c==\\'u\\';\\n    }\\n\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        int N = queries.size();\\n        vector<int> ans(N);\\n\\n        vector<int> isValid(n, 0);\\n\\n        for(int i=0; i<n; i++) {\\n            string s = words[i];\\n            isValid[i] = (i>0? isValid[i-1] : 0);\\n\\n            if(isVowel(s[0]) && isVowel(s[s.size()-1])) {\\n                isValid[i]++;\\n            }\\n        }\\n\\n        for(int i=0; i<N; i++) {\\n            int l = queries[i][0], r = queries[i][1];\\n            ans[i] = isValid[r] - (l>0? isValid[l-1] : 0);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        return c==\\'a\\' or c==\\'e\\' or c==\\'i\\' or c==\\'o\\' or c==\\'u\\';\\n    }\\n\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        int N = queries.size();\\n        vector<int> ans(N);\\n\\n        vector<int> isValid(n, 0);\\n\\n        for(int i=0; i<n; i++) {\\n            string s = words[i];\\n            isValid[i] = (i>0? isValid[i-1] : 0);\\n\\n            if(isVowel(s[0]) && isVowel(s[s.size()-1])) {\\n                isValid[i]++;\\n            }\\n        }\\n\\n        for(int i=0; i<N; i++) {\\n            int l = queries[i][0], r = queries[i][1];\\n            ans[i] = isValid[r] - (l>0? isValid[l-1] : 0);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496554,
                "title": "functional-c-std-transform-inclusive-scan",
                "content": "\\n\\n# Code\\n```\\nauto is_vowel = [](const char c){\\n    return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'; \\n}; \\n\\nauto is_valid_word = [](const string& word ){\\n    return static_cast<int>(is_vowel(word.front()) && is_vowel(word.back())); \\n}; \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        std::vector<int> ps(words.size()+1,0); \\n        std::transform_inclusive_scan(words.begin(),words.end(),ps.begin()+1, std::plus<int>{}, is_valid_word); \\n\\n        vector<int> ans(queries.size()); \\n        for(int i = 0; i <ans.size(); ++i){  \\n            ans[i] = ps[queries[i][1]+1]-ps[queries[i][0]]; \\n        }\\n\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nauto is_vowel = [](const char c){\\n    return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\'; \\n}; \\n\\nauto is_valid_word = [](const string& word ){\\n    return static_cast<int>(is_vowel(word.front()) && is_vowel(word.back())); \\n}; \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        std::vector<int> ps(words.size()+1,0); \\n        std::transform_inclusive_scan(words.begin(),words.end(),ps.begin()+1, std::plus<int>{}, is_valid_word); \\n\\n        vector<int> ans(queries.size()); \\n        for(int i = 0; i <ans.size(); ++i){  \\n            ans[i] = ps[queries[i][1]+1]-ps[queries[i][0]]; \\n        }\\n\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488718,
                "title": "count-vowel-strings-in-ranges",
                "content": "----------------- Easy C++ Solution ---------------------\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        static const unordered_set<char> Vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        vector<int> pre(size(words) + 1);\\n        for (int i = 0; i < size(words); ++i) {\\n            pre[i + 1] = pre[i] + static_cast<int>(Vowel.count(words[i][0]) && Vowel.count(words[i].back()));\\n        }\\n        vector<int> ans;\\n        for (const auto& q : queries) {\\n            ans.emplace_back(pre[q[1] + 1] - pre[q[0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        static const unordered_set<char> Vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        vector<int> pre(size(words) + 1);\\n        for (int i = 0; i < size(words); ++i) {\\n            pre[i + 1] = pre[i] + static_cast<int>(Vowel.count(words[i][0]) && Vowel.count(words[i].back()));\\n        }\\n        vector<int> ans;\\n        for (const auto& q : queries) {\\n            ans.emplace_back(pre[q[1] + 1] - pre[q[0]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393108,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n  bool isVowel(char ch)\\n  {\\n      if (ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\') return true;\\n      return false;\\n  }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size();\\n        vector<int>pre(n+1,0);\\n        if (isVowel(words[0][0]) && isVowel(words[0][words[0].size()-1])) pre[0]=1;\\n        for (int i=1;i<words.size();i++)\\n        {\\n            if (isVowel(words[i][0]) && isVowel(words[i][words[i].size()-1]))\\n            {\\n                pre[i]=1+pre[i-1];\\n            }\\n            else pre[i]=pre[i-1];\\n        }\\n        vector<int>ans(queries.size());\\n        int i=0;\\n        for (auto it:queries)\\n        {\\n            ans[i]=pre[it[1]];\\n            if (it[0]!=0) ans[i]-=pre[it[0]-1];\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool isVowel(char ch)\\n  {\\n      if (ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\') return true;\\n      return false;\\n  }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size();\\n        vector<int>pre(n+1,0);\\n        if (isVowel(words[0][0]) && isVowel(words[0][words[0].size()-1])) pre[0]=1;\\n        for (int i=1;i<words.size();i++)\\n        {\\n            if (isVowel(words[i][0]) && isVowel(words[i][words[i].size()-1]))\\n            {\\n                pre[i]=1+pre[i-1];\\n            }\\n            else pre[i]=pre[i-1];\\n        }\\n        vector<int>ans(queries.size());\\n        int i=0;\\n        for (auto it:queries)\\n        {\\n            ans[i]=pre[it[1]];\\n            if (it[0]!=0) ans[i]-=pre[it[0]-1];\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383449,
                "title": "intuitive-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const string vowels = \"aeiou\";\\n    bool vowel(char ch) {\\n        return vowels.find(ch) != -1;\\n    }\\n\\n    bool se(const string& str) {\\n        return vowel(*str.begin()) and vowel(*str.rbegin());\\n    }\\n\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n\\n        int len = words.size();\\n        vector<int> ses(len + 1);\\n        for (int i = 0; i < len; ++i) {\\n            ses[i + 1] = ses[i] + se(words[i]);\\n        }\\n\\n        vector<int> res;\\n        for (auto q : queries) {\\n            res.push_back(ses[q[1] + 1] - ses[q[0]]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const string vowels = \"aeiou\";\\n    bool vowel(char ch) {\\n        return vowels.find(ch) != -1;\\n    }\\n\\n    bool se(const string& str) {\\n        return vowel(*str.begin()) and vowel(*str.rbegin());\\n    }\\n\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n\\n        int len = words.size();\\n        vector<int> ses(len + 1);\\n        for (int i = 0; i < len; ++i) {\\n            ses[i + 1] = ses[i] + se(words[i]);\\n        }\\n\\n        vector<int> res;\\n        for (auto q : queries) {\\n            res.push_back(ses[q[1] + 1] - ses[q[0]]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372154,
                "title": "java-solution-prefix-sum",
                "content": "# Complexity\\n- Time complexity: O(N+Q), where N is the length of array \"words\" and Q is the number of queries in the input 2D integer array \"queries\".\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int[] prifixSum = new int[words.length];\\n\\n        int count = 0;\\n        for(int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            if(isVowel(word.charAt(0)) && isVowel(word.charAt(word.length() - 1))) {\\n                count++;\\n                prifixSum[i] = count;\\n            } else {\\n                prifixSum[i] = count;\\n            }\\n        }\\n\\n        int[] ans = new int[queries.length];\\n        \\n        for(int i = 0; i < queries.length; i++) {\\n            int startIndex = queries[i][0];\\n            int endIndex = queries[i][1];\\n\\n            if(startIndex == 0) {\\n                ans[i] = prifixSum[endIndex];\\n            } else {\\n                ans[i] = (prifixSum[endIndex] - prifixSum[startIndex]) + (prifixSum[startIndex] - prifixSum[startIndex - 1]);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    boolean isVowel(char ch) {\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int[] prifixSum = new int[words.length];\\n\\n        int count = 0;\\n        for(int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            if(isVowel(word.charAt(0)) && isVowel(word.charAt(word.length() - 1))) {\\n                count++;\\n                prifixSum[i] = count;\\n            } else {\\n                prifixSum[i] = count;\\n            }\\n        }\\n\\n        int[] ans = new int[queries.length];\\n        \\n        for(int i = 0; i < queries.length; i++) {\\n            int startIndex = queries[i][0];\\n            int endIndex = queries[i][1];\\n\\n            if(startIndex == 0) {\\n                ans[i] = prifixSum[endIndex];\\n            } else {\\n                ans[i] = (prifixSum[endIndex] - prifixSum[startIndex]) + (prifixSum[startIndex] - prifixSum[startIndex - 1]);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    boolean isVowel(char ch) {\\n        if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371307,
                "title": "esay-prifix-sum-c",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->o(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->o(N)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& w, vector<vector<int>>& queries) {\\n         int  n=w.size();\\n          vector<int> prefix(n+1,0);\\n       \\n            \\n            for(int i=0;i<w.size();i++){\\n                string s=w[i];\\n                int t=s.size()-1;\\n                if((s[0] == \\'a\\'|| s[0] == \\'e\\'|| s[0] == \\'i\\'|| s[0] == \\'o\\'|| s[0] == \\'u\\') and (s[t] == \\'a\\'|| s[t] == \\'e\\'|| s[t] == \\'i\\'|| s[t] == \\'o\\'|| s[t] == \\'u\\')) prefix[i+1] += 1;\\n                 prefix[i+1] += prefix[i];\\n                \\n                \\n            \\n            \\n}\\n\\n  vector<int> ans;\\n        for(auto q : queries) {\\n            int cal = prefix[q[1] + 1] - prefix[q[0]];\\n            ans.push_back(cal);\\n        }\\n        return ans;   \\n\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/*class Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& w, vector<vector<int>>& q) {\\n         int  n=q.size(); vector<int> v; int j=0;\\n        while(n){\\n            int cnt=0;\\n            \\n            for(int i=q[j][0];i<=q[j][1];i++){\\n                string s=w[i];\\n                int t=s.size()-1;\\n                if((s[0] == \\'a\\'|| s[0] == \\'e\\'|| s[0] == \\'i\\'|| s[0] == \\'o\\'|| s[0] == \\'u\\') and (s[t] == \\'a\\'|| s[t] == \\'e\\'|| s[t] == \\'i\\'|| s[t] == \\'o\\'|| s[t] == \\'u\\')){\\n                    cnt++;\\n                }\\n            }\\n            v.push_back(cnt);\\n            n--;\\n            j++;\\n            \\n            \\n}\\n        return v;\\n    }\\n};*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& w, vector<vector<int>>& queries) {\\n         int  n=w.size();\\n          vector<int> prefix(n+1,0);\\n       \\n            \\n            for(int i=0;i<w.size();i++){\\n                string s=w[i];\\n                int t=s.size()-1;\\n                if((s[0] == \\'a\\'|| s[0] == \\'e\\'|| s[0] == \\'i\\'|| s[0] == \\'o\\'|| s[0] == \\'u\\') and (s[t] == \\'a\\'|| s[t] == \\'e\\'|| s[t] == \\'i\\'|| s[t] == \\'o\\'|| s[t] == \\'u\\')) prefix[i+1] += 1;\\n                 prefix[i+1] += prefix[i];\\n                \\n                \\n            \\n            \\n}\\n\\n  vector<int> ans;\\n        for(auto q : queries) {\\n            int cal = prefix[q[1] + 1] - prefix[q[0]];\\n            ans.push_back(cal);\\n        }\\n        return ans;   \\n\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/*class Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& w, vector<vector<int>>& q) {\\n         int  n=q.size(); vector<int> v; int j=0;\\n        while(n){\\n            int cnt=0;\\n            \\n            for(int i=q[j][0];i<=q[j][1];i++){\\n                string s=w[i];\\n                int t=s.size()-1;\\n                if((s[0] == \\'a\\'|| s[0] == \\'e\\'|| s[0] == \\'i\\'|| s[0] == \\'o\\'|| s[0] == \\'u\\') and (s[t] == \\'a\\'|| s[t] == \\'e\\'|| s[t] == \\'i\\'|| s[t] == \\'o\\'|| s[t] == \\'u\\')){\\n                    cnt++;\\n                }\\n            }\\n            v.push_back(cnt);\\n            n--;\\n            j++;\\n            \\n            \\n}\\n        return v;\\n    }\\n};*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349750,
                "title": "easy-solution-python-hashmaps-prefix-sum",
                "content": "# Code\\n```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n       \\n        def getVowels(string):\\n            cond1 = string[0] == \\'a\\' or string[0] == \\'e\\' or string[0] == \\'i\\' or string[0] == \\'o\\' or string[0] == \\'u\\'\\n            cond2 = string[-1] == \\'a\\' or string[-1] == \\'e\\' or string[-1] == \\'i\\' or string[-1] == \\'o\\' or string[-1] == \\'u\\'\\n            if cond1 and cond2:\\n                return 1\\n            return 0 \\n\\n        store = {}\\n        store[-1] = 0\\n        ans = []\\n        temp = 0\\n        for i in range(len(words)):\\n            temp += getVowels(words[i])\\n            store[i] = temp\\n        for query in queries:\\n            count = 0\\n            ans.append(store[query[-1]] - store[query[0]-1])\\n        return ans\\n        \\n```\\nDo upvote if you like the Solution :)",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n       \\n        def getVowels(string):\\n            cond1 = string[0] == \\'a\\' or string[0] == \\'e\\' or string[0] == \\'i\\' or string[0] == \\'o\\' or string[0] == \\'u\\'\\n            cond2 = string[-1] == \\'a\\' or string[-1] == \\'e\\' or string[-1] == \\'i\\' or string[-1] == \\'o\\' or string[-1] == \\'u\\'\\n            if cond1 and cond2:\\n                return 1\\n            return 0 \\n\\n        store = {}\\n        store[-1] = 0\\n        ans = []\\n        temp = 0\\n        for i in range(len(words)):\\n            temp += getVowels(words[i])\\n            store[i] = temp\\n        for query in queries:\\n            count = 0\\n            ans.append(store[query[-1]] - store[query[0]-1])\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338612,
                "title": "simple-java-solution",
                "content": "# Simple JAVA Solution\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        \\n        int l = words.length;\\n        int a[] = new int[l];\\n\\n        a[0] = isTrue(words[0]);\\n\\n        for(int i=1;i<l;i++)\\n        {\\n            a[i] = a[i-1] + isTrue(words[i]);\\n        }\\n        int n = queries.length;\\n        int ans[] = new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            int s = queries[i][0], e = queries[i][1];\\n            \\n            if(s==0) ans[i] = a[e];\\n            else ans[i] = a[e] - a[s-1];\\n\\n        }\\n        \\n        return ans;\\n    }\\n    public int isTrue(String s)\\n    {\\n        int l = s.length();\\n        String vow = \"aeiou\";\\n        return (vow.contains(s.charAt(0)+\"\") && vow.contains(s.charAt(l-1)+\"\")) ? 1 : 0 ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        \\n        int l = words.length;\\n        int a[] = new int[l];\\n\\n        a[0] = isTrue(words[0]);\\n\\n        for(int i=1;i<l;i++)\\n        {\\n            a[i] = a[i-1] + isTrue(words[i]);\\n        }\\n        int n = queries.length;\\n        int ans[] = new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            int s = queries[i][0], e = queries[i][1];\\n            \\n            if(s==0) ans[i] = a[e];\\n            else ans[i] = a[e] - a[s-1];\\n\\n        }\\n        \\n        return ans;\\n    }\\n    public int isTrue(String s)\\n    {\\n        int l = s.length();\\n        String vow = \"aeiou\";\\n        return (vow.contains(s.charAt(0)+\"\") && vow.contains(s.charAt(l-1)+\"\")) ? 1 : 0 ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335236,
                "title": "easy-solution-in-java-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPREFIX SUM\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPREFIX SUM\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n          int pre[]=new int[words.length];\\n          int flag=0; \\n          for(int i=0;i<words.length;i++)\\n          {\\n              int l=0;\\n              int r=words[i].length()-1;\\n              if(words[i].charAt(l)==\\'a\\'||words[i].charAt(l)==\\'e\\'||words[i].charAt(l)==\\'i\\'||words[i].charAt(l)==\\'o\\'||words[i].charAt(l)==\\'u\\')\\n              {\\n                   flag++;\\n              }\\n              if(flag==1)\\n              {\\n                  if(words[i].charAt(r)==\\'a\\'||words[i].charAt(r)==\\'e\\'||words[i].charAt(r)==\\'i\\'||words[i].charAt(r)==\\'o\\'||words[i].charAt(r)==\\'u\\')\\n              {\\n                   flag++;\\n              } \\n              }\\n              if(flag==2)\\n              {\\n                  if(i==0)\\n                  {\\n                      pre[i]=1;\\n                  }\\n                  else\\n                  {\\n                    pre[i]=pre[i-1]+1;\\n                  }\\n              }\\n              else\\n              {\\n                  if(i==0)\\n                  {\\n                      pre[i]=0;\\n                  }\\n                  else\\n                  {    \\n                  pre[i]=pre[i-1];\\n                  }\\n              }\\n              flag=0;\\n          }\\n        int val[]=new int[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int x=queries[i][0];\\n            int y=queries[i][1];\\n            if(x==0)\\n            {\\n                val[i]=pre[y];\\n            }\\n            else\\n            {\\n                int m=pre[x-1];\\n                int n=pre[y];\\n                val[i]=n-m;\\n            }\\n        }\\n        for(int i=0;i<pre.length;i++)\\n        {\\n            System.out.print(pre[i]+\" \");\\n        }\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n          int pre[]=new int[words.length];\\n          int flag=0; \\n          for(int i=0;i<words.length;i++)\\n          {\\n              int l=0;\\n              int r=words[i].length()-1;\\n              if(words[i].charAt(l)==\\'a\\'||words[i].charAt(l)==\\'e\\'||words[i].charAt(l)==\\'i\\'||words[i].charAt(l)==\\'o\\'||words[i].charAt(l)==\\'u\\')\\n              {\\n                   flag++;\\n              }\\n              if(flag==1)\\n              {\\n                  if(words[i].charAt(r)==\\'a\\'||words[i].charAt(r)==\\'e\\'||words[i].charAt(r)==\\'i\\'||words[i].charAt(r)==\\'o\\'||words[i].charAt(r)==\\'u\\')\\n              {\\n                   flag++;\\n              } \\n              }\\n              if(flag==2)\\n              {\\n                  if(i==0)\\n                  {\\n                      pre[i]=1;\\n                  }\\n                  else\\n                  {\\n                    pre[i]=pre[i-1]+1;\\n                  }\\n              }\\n              else\\n              {\\n                  if(i==0)\\n                  {\\n                      pre[i]=0;\\n                  }\\n                  else\\n                  {    \\n                  pre[i]=pre[i-1];\\n                  }\\n              }\\n              flag=0;\\n          }\\n        int val[]=new int[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int x=queries[i][0];\\n            int y=queries[i][1];\\n            if(x==0)\\n            {\\n                val[i]=pre[y];\\n            }\\n            else\\n            {\\n                int m=pre[x-1];\\n                int n=pre[y];\\n                val[i]=n-m;\\n            }\\n        }\\n        for(int i=0;i<pre.length;i++)\\n        {\\n            System.out.print(pre[i]+\" \");\\n        }\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331824,
                "title": "rust-solution-using-prefix-sum",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfn helper(a: char) -> bool {\\n  match a {\\n    \\'a\\' => true,\\n    \\'i\\' => true,\\n    \\'u\\' => true,\\n    \\'e\\' => true,\\n    \\'o\\' => true,\\n    _ => false\\n  }\\n}\\n\\nimpl Solution {\\n  pub fn vowel_strings(words: Vec<String>, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n    let n = words.len();\\n    let m = queries.len();\\n    let mut memo = vec![0;n+1];\\n\\n    for i in 0..n {\\n      memo[i+1] = memo[i];\\n      let words = words[i].chars().collect::<Vec<char>>();\\n      if helper(words[0]) && helper(words[words.len()-1]) {\\n        memo[i+1] += 1;\\n      }\\n    }\\n\\n    let mut result = vec![0;m];\\n    for i in 0..m {\\n      let l = queries[i][0] as usize;\\n      let r = queries[i][1] as usize;\\n      result[i] = memo[r+1] - memo[l];\\n    }\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Prefix Sum"
                ],
                "code": "```\\nfn helper(a: char) -> bool {\\n  match a {\\n    \\'a\\' => true,\\n    \\'i\\' => true,\\n    \\'u\\' => true,\\n    \\'e\\' => true,\\n    \\'o\\' => true,\\n    _ => false\\n  }\\n}\\n\\nimpl Solution {\\n  pub fn vowel_strings(words: Vec<String>, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n    let n = words.len();\\n    let m = queries.len();\\n    let mut memo = vec![0;n+1];\\n\\n    for i in 0..n {\\n      memo[i+1] = memo[i];\\n      let words = words[i].chars().collect::<Vec<char>>();\\n      if helper(words[0]) && helper(words[words.len()-1]) {\\n        memo[i+1] += 1;\\n      }\\n    }\\n\\n    let mut result = vec![0;m];\\n    for i in 0..m {\\n      let l = queries[i][0] as usize;\\n      let r = queries[i][1] as usize;\\n      result[i] = memo[r+1] - memo[l];\\n    }\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3319102,
                "title": "prefix-sum-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isCorrect(string s){\\n        int n = s.length()-1;\\n        if(\\n            (s[0] == \\'a\\' || s[0] == \\'e\\' ||s[0] == \\'i\\' || s[0] == \\'o\\' || s[0] == \\'u\\') \\n          &&\\n            (s[n] == \\'a\\' || s[n] == \\'e\\' ||s[n] == \\'i\\' || s[n] == \\'o\\' || s[n] == \\'u\\')\\n          )\\n            return true;\\n        \\n        return false;            \\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> pre(words.size(), 0);\\n        if(isCorrect(words[0])) pre[0] = 1;\\n        \\n        for(int i=1;i<pre.size();i++) \\n            pre[i] = pre[i-1] + (isCorrect(words[i])==1);\\n        \\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            \\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            \\n            if(left==0) ans.push_back(pre[right]);\\n            else ans.push_back( pre[right] - pre[left-1] );\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCorrect(string s){\\n        int n = s.length()-1;\\n        if(\\n            (s[0] == \\'a\\' || s[0] == \\'e\\' ||s[0] == \\'i\\' || s[0] == \\'o\\' || s[0] == \\'u\\') \\n          &&\\n            (s[n] == \\'a\\' || s[n] == \\'e\\' ||s[n] == \\'i\\' || s[n] == \\'o\\' || s[n] == \\'u\\')\\n          )\\n            return true;\\n        \\n        return false;            \\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> pre(words.size(), 0);\\n        if(isCorrect(words[0])) pre[0] = 1;\\n        \\n        for(int i=1;i<pre.size();i++) \\n            pre[i] = pre[i-1] + (isCorrect(words[i])==1);\\n        \\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            \\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            \\n            if(left==0) ans.push_back(pre[right]);\\n            else ans.push_back( pre[right] - pre[left-1] );\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316800,
                "title": "c-prefix-sum-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTried to brute force first, but then had to go to prefix sums instead.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefix sums, precalculate how many vowel-strings up to offset. Then look in that table to get difference.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(#words + #queries)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(#words)\\nFor the prefix sum table.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    inline bool is_vowel(const char c) {\\n        switch(c) {\\n            case \\'a\\':\\n            case \\'e\\':\\n            case \\'i\\':\\n            case \\'o\\':\\n            case \\'u\\':\\n                return true;\\n            default:\\n                return false;\\n        }\\n    }\\n    int is_vowelstring(const string& s) {\\n        return is_vowel(s.front())  &&\\n               is_vowel(s.back()) ? 1 : 0;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> prefix_sums;\\n        prefix_sums.push_back(is_vowelstring(words[0]));\\n        for(int i=1; i < words.size(); ++i) {\\n            prefix_sums.push_back(\\n                prefix_sums[i-1] + \\n                is_vowelstring(words[i])\\n            );\\n        }\\n        vector<int> res {};\\n        for(const vector<int>& q: queries) {\\n            int s = q[0], e = q[1];\\n            int cnt = 0;\\n            int sub = s > 0 ? prefix_sums[s-1] : 0;\\n            res.push_back(prefix_sums[e] - sub);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    inline bool is_vowel(const char c) {\\n        switch(c) {\\n            case \\'a\\':\\n            case \\'e\\':\\n            case \\'i\\':\\n            case \\'o\\':\\n            case \\'u\\':\\n                return true;\\n            default:\\n                return false;\\n        }\\n    }\\n    int is_vowelstring(const string& s) {\\n        return is_vowel(s.front())  &&\\n               is_vowel(s.back()) ? 1 : 0;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> prefix_sums;\\n        prefix_sums.push_back(is_vowelstring(words[0]));\\n        for(int i=1; i < words.size(); ++i) {\\n            prefix_sums.push_back(\\n                prefix_sums[i-1] + \\n                is_vowelstring(words[i])\\n            );\\n        }\\n        vector<int> res {};\\n        for(const vector<int>& q: queries) {\\n            int s = q[0], e = q[1];\\n            int cnt = 0;\\n            int sub = s > 0 ? prefix_sums[s-1] : 0;\\n            res.push_back(prefix_sums[e] - sub);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314728,
                "title": "prefix-sum-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size();\\n        vector<int>v(n+1,0);\\n        for(int i=0;i<n;i++){\\n            int p=words[i].size()-1;\\n            if((words[i][0]==\\'a\\' || words[i][0]==\\'i\\' \\n            || words[i][0]==\\'e\\' || words[i][0]==\\'o\\' \\n            || words[i][0]==\\'u\\') && \\n            (words[i][p]==\\'a\\' || words[i][p]==\\'i\\' || words[i][p]==\\'e\\' \\n            || words[i][p]==\\'o\\' || words[i][p]==\\'u\\')) v[i+1]=1;\\n        }\\n        vector<int>ans;\\n        for(int i=1;i<=n;i++){\\n            v[i]=v[i]+v[i-1];\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            int start=queries[i][0];\\n            int end=queries[i][1];\\n            ans.push_back(v[end+1]-v[start]);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size();\\n        vector<int>v(n+1,0);\\n        for(int i=0;i<n;i++){\\n            int p=words[i].size()-1;\\n            if((words[i][0]==\\'a\\' || words[i][0]==\\'i\\' \\n            || words[i][0]==\\'e\\' || words[i][0]==\\'o\\' \\n            || words[i][0]==\\'u\\') && \\n            (words[i][p]==\\'a\\' || words[i][p]==\\'i\\' || words[i][p]==\\'e\\' \\n            || words[i][p]==\\'o\\' || words[i][p]==\\'u\\')) v[i+1]=1;\\n        }\\n        vector<int>ans;\\n        for(int i=1;i<=n;i++){\\n            v[i]=v[i]+v[i-1];\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            int start=queries[i][0];\\n            int end=queries[i][1];\\n            ans.push_back(v[end+1]-v[start]);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310467,
                "title": "java-4ms-using-count-array",
                "content": "# Intuition\\nCreated array arr and filled with cumulative sum of vowel words.\\nThen created result array and for each query I found the difference from cumulative sum from array of indices [end] and [start - 1].\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int[] arr = new int[words.length];\\n        arr[0] = isVowelWord(words[0]) ? 1 : 0;\\n        for (int i = 1; i < words.length; i++) arr[i] = isVowelWord(words[i]) ? arr[i - 1] + 1 : arr[i - 1];\\n        int[] res = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) res[i] = queries[i][0] == 0 ? arr[queries[i][1]] : arr[queries[i][1]] - arr[queries[i][0] - 1];\\n        return res;\\n    }\\n\\n    private boolean isVowelWord(String s) {\\n        return isVowel(s.charAt(0)) && isVowel(s.charAt(s.length() - 1));\\n    }\\n\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int[] arr = new int[words.length];\\n        arr[0] = isVowelWord(words[0]) ? 1 : 0;\\n        for (int i = 1; i < words.length; i++) arr[i] = isVowelWord(words[i]) ? arr[i - 1] + 1 : arr[i - 1];\\n        int[] res = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) res[i] = queries[i][0] == 0 ? arr[queries[i][1]] : arr[queries[i][1]] - arr[queries[i][0] - 1];\\n        return res;\\n    }\\n\\n    private boolean isVowelWord(String s) {\\n        return isVowel(s.charAt(0)) && isVowel(s.charAt(s.length() - 1));\\n    }\\n\\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303683,
                "title": "brute-force-to-optimized-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to ```\\nCode block\\n```solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Brute Force\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int[] ans = new int[queries.length];\\n        HashMap<String,Boolean> map = new HashMap<>();\\n        for(int i=0;i<words.length;i++){\\n            char ch = words[i].charAt(0);\\n            char ch1=words[i].charAt(words[i].length()-1);\\n            if((ch==\\'a\\'|| ch==\\'i\\'||ch==\\'e\\'||ch==\\'o\\'|| ch==\\'u\\') && (ch1==\\'a\\'|| ch1==\\'e\\'||ch1==\\'i\\'|| ch1==\\'o\\' || ch1==\\'u\\') ){\\n                map.put(words[i],true);\\n            }\\n            else{\\n                map.put(words[i],false);\\n            }\\n        }\\n        \\n        for(int i=0;i<queries.length;i++){\\n            for(int j=queries[i][0];j<=queries[i][1];j++){\\n                if(map.get(words[j])==true) ans[i]++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n\\n```\\n//Optimized Solution\\nclass Solution {\\n        public int[] vowelStrings(String[] words, int[][] queries) {\\n        int n=words.length;\\n        int[] ans = new int[queries.length];\\n        int[] pref = new int[n];\\n        int m=words[0].length();\\n        if((words[0].charAt(0)==\\'a\\' || words[0].charAt(0)==\\'e\\' || words[0].charAt(0)==\\'i\\' || words[0].charAt(0)==\\'o\\' || words[0].charAt(0)==\\'u\\')){\\n        if((words[0].charAt(m-1)==\\'a\\' || words[0].charAt(m-1)==\\'e\\' || words[0].charAt(m-1)==\\'i\\' || words[0].charAt(m-1)==\\'o\\' || words[0].charAt(m-1)==\\'u\\')){\\n        pref[0]=1;\\n        }\\n        }\\n        for(int i=1;i<n;i++){\\n        if((words[i].charAt(0)==\\'a\\' || words[i].charAt(0)==\\'e\\' || words[i].charAt(0)==\\'i\\' || words[i].charAt(0)==\\'o\\' || words[i].charAt(0)==\\'u\\')){\\n        m=words[i].length();\\n        if((words[i].charAt(m-1)==\\'a\\' || words[i].charAt(m-1)==\\'e\\' || words[i].charAt(m-1)==\\'i\\' || words[i].charAt(m-1)==\\'o\\' || words[i].charAt(m-1)==\\'u\\')){\\n        pref[i]=pref[i-1] + 1;\\n        }\\n        else pref[i]=pref[i-1];\\n        }\\n        else pref[i]=pref[i-1];\\n        }\\n        for(int i=0;i<queries.length;i++){\\n        int x=queries[i][0];\\n        int y=queries[i][1];\\n        if(x==0){\\n        ans[i] = pref[y];\\n        }\\n        else ans[i] = pref[y]-pref[x - 1];\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nCode block\\n```\n```\\n//Brute Force\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int[] ans = new int[queries.length];\\n        HashMap<String,Boolean> map = new HashMap<>();\\n        for(int i=0;i<words.length;i++){\\n            char ch = words[i].charAt(0);\\n            char ch1=words[i].charAt(words[i].length()-1);\\n            if((ch==\\'a\\'|| ch==\\'i\\'||ch==\\'e\\'||ch==\\'o\\'|| ch==\\'u\\') && (ch1==\\'a\\'|| ch1==\\'e\\'||ch1==\\'i\\'|| ch1==\\'o\\' || ch1==\\'u\\') ){\\n                map.put(words[i],true);\\n            }\\n            else{\\n                map.put(words[i],false);\\n            }\\n        }\\n        \\n        for(int i=0;i<queries.length;i++){\\n            for(int j=queries[i][0];j<=queries[i][1];j++){\\n                if(map.get(words[j])==true) ans[i]++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```\\n//Optimized Solution\\nclass Solution {\\n        public int[] vowelStrings(String[] words, int[][] queries) {\\n        int n=words.length;\\n        int[] ans = new int[queries.length];\\n        int[] pref = new int[n];\\n        int m=words[0].length();\\n        if((words[0].charAt(0)==\\'a\\' || words[0].charAt(0)==\\'e\\' || words[0].charAt(0)==\\'i\\' || words[0].charAt(0)==\\'o\\' || words[0].charAt(0)==\\'u\\')){\\n        if((words[0].charAt(m-1)==\\'a\\' || words[0].charAt(m-1)==\\'e\\' || words[0].charAt(m-1)==\\'i\\' || words[0].charAt(m-1)==\\'o\\' || words[0].charAt(m-1)==\\'u\\')){\\n        pref[0]=1;\\n        }\\n        }\\n        for(int i=1;i<n;i++){\\n        if((words[i].charAt(0)==\\'a\\' || words[i].charAt(0)==\\'e\\' || words[i].charAt(0)==\\'i\\' || words[i].charAt(0)==\\'o\\' || words[i].charAt(0)==\\'u\\')){\\n        m=words[i].length();\\n        if((words[i].charAt(m-1)==\\'a\\' || words[i].charAt(m-1)==\\'e\\' || words[i].charAt(m-1)==\\'i\\' || words[i].charAt(m-1)==\\'o\\' || words[i].charAt(m-1)==\\'u\\')){\\n        pref[i]=pref[i-1] + 1;\\n        }\\n        else pref[i]=pref[i-1];\\n        }\\n        else pref[i]=pref[i-1];\\n        }\\n        for(int i=0;i<queries.length;i++){\\n        int x=queries[i][0];\\n        int y=queries[i][1];\\n        if(x==0){\\n        ans[i] = pref[y];\\n        }\\n        else ans[i] = pref[y]-pref[x - 1];\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295827,
                "title": "detailed-explanation-easy-to-understand",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a new vector to store number of vowels from position 0 to ith position.\\n2. Traverse the vector and keep adding and storing number of vowels at ith position.\\n3. Finally traverse through the queries vector and calculate number of vowels between the range by using the created vector and store the results in the result vector.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        // Initialize size of words vector and a counter variable to store number of vowels encountered during traversing.\\n        int n = words.size(), sum = 0;\\n\\n        // Create a vector to store number of vowels at ith position\\n        vector<int> vowels_sum;\\n\\n        // Vector to store the result\\n        vector<int> result;\\n\\n        // Traverse through the words vector\\n        for(int i = 0; i < n; i++){\\n            // Get the size of ith word\\n            int word_n = words[i].size();\\n\\n            // Get first and last letters of ith word\\n            char first = words[i][0], last = words[i][word_n-1];\\n\\n            // Increment the counter if vowels is present at both first and last position.\\n            if((first == \\'a\\' || first == \\'e\\' || first == \\'i\\' || first == \\'o\\' || first == \\'u\\') && (last == \\'a\\' || last == \\'e\\' || last == \\'i\\' || last == \\'o\\' || last == \\'u\\')){\\n                sum++;\\n            }\\n\\n            // Insert the number of vowels encountered in the vector\\n            vowels_sum.push_back(sum);\\n        }\\n\\n        // Traverse through the queries vector\\n        for(int i = 0; i < queries.size(); i++){\\n            // Get left and right range values\\n            int left = queries[i][0], right = queries[i][1], left_no, right_no, diff;\\n\\n            // If left part of range is greater than zero then store number before leftmost range from vowels_sum else store zero\\n            if(left > 0)\\n                left_no = vowels_sum[left-1];\\n            else\\n                left_no = 0;\\n\\n            // Store number from vowels_sum corresponding  to rightmost range \\n            right_no = vowels_sum[right];\\n\\n            // Calculate the difference between sums\\n            diff = right_no - left_no;\\n\\n            // Push the difference in result vector\\n            result.push_back(diff);\\n        }\\n\\n        // Return the result vector\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        // Initialize size of words vector and a counter variable to store number of vowels encountered during traversing.\\n        int n = words.size(), sum = 0;\\n\\n        // Create a vector to store number of vowels at ith position\\n        vector<int> vowels_sum;\\n\\n        // Vector to store the result\\n        vector<int> result;\\n\\n        // Traverse through the words vector\\n        for(int i = 0; i < n; i++){\\n            // Get the size of ith word\\n            int word_n = words[i].size();\\n\\n            // Get first and last letters of ith word\\n            char first = words[i][0], last = words[i][word_n-1];\\n\\n            // Increment the counter if vowels is present at both first and last position.\\n            if((first == \\'a\\' || first == \\'e\\' || first == \\'i\\' || first == \\'o\\' || first == \\'u\\') && (last == \\'a\\' || last == \\'e\\' || last == \\'i\\' || last == \\'o\\' || last == \\'u\\')){\\n                sum++;\\n            }\\n\\n            // Insert the number of vowels encountered in the vector\\n            vowels_sum.push_back(sum);\\n        }\\n\\n        // Traverse through the queries vector\\n        for(int i = 0; i < queries.size(); i++){\\n            // Get left and right range values\\n            int left = queries[i][0], right = queries[i][1], left_no, right_no, diff;\\n\\n            // If left part of range is greater than zero then store number before leftmost range from vowels_sum else store zero\\n            if(left > 0)\\n                left_no = vowels_sum[left-1];\\n            else\\n                left_no = 0;\\n\\n            // Store number from vowels_sum corresponding  to rightmost range \\n            right_no = vowels_sum[right];\\n\\n            // Calculate the difference between sums\\n            diff = right_no - left_no;\\n\\n            // Push the difference in result vector\\n            result.push_back(diff);\\n        }\\n\\n        // Return the result vector\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292398,
                "title": "c-brute-force-tle-optimized-prefix-sum-approach",
                "content": "# Code-1: Brute Force: TLE\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) \\n    {\\n        vector<int>answer;\\n        for(int i = 0; i<queries.size(); i++)\\n        {\\n            int count = 0;\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            for(int j = left; j<=right; j++)\\n            {\\n                if( \\n                    (\\n                        words[j][0] == \\'a\\' or \\n                        words[j][0] == \\'e\\' or \\n                        words[j][0] == \\'i\\' or \\n                        words[j][0] == \\'o\\' or \\n                        words[j][0] == \\'u\\' \\n                    ) \\n                    and \\n                    (\\n                        words[j].back() == \\'a\\' or\\n                        words[j].back() == \\'e\\' or\\n                        words[j].back() == \\'i\\' or\\n                        words[j].back() == \\'o\\' or\\n                        words[j].back() == \\'u\\'\\n                    )\\n                ) count++;\\n            }\\n            answer.push_back(count);\\n        }\\n        return answer;\\n    }\\n};\\n```\\n# Code-2: Optimized Version of Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isvowel(char ch)\\n    {\\n        if(ch == \\'a\\' or ch == \\'e\\' or ch == \\'i\\' or ch == \\'o\\' or ch == \\'u\\') return true;\\n\\n        return false;\\n    }\\n\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) \\n    {\\n        vector<int>prefix;\\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            if( isvowel(words[i][0]) and isvowel(words[i].back()) )\\n            {\\n                prefix.push_back(1);\\n            }\\n            else prefix.push_back(0);\\n        }\\n\\n        for(int i = 1; i<prefix.size(); i++)\\n        {\\n            prefix[i] += prefix[i-1];\\n        }\\n        vector<int>answer;\\n        for(int i = 0; i<queries.size(); i++)\\n        {\\n            if(queries[i][0]>0)\\n            {\\n                answer.push_back( prefix[queries[i].back()] - prefix[queries[i][0]-1] );\\n            }\\n            else \\n            {\\n                answer.push_back( prefix[queries[i].back()] );\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) \\n    {\\n        vector<int>answer;\\n        for(int i = 0; i<queries.size(); i++)\\n        {\\n            int count = 0;\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            for(int j = left; j<=right; j++)\\n            {\\n                if( \\n                    (\\n                        words[j][0] == \\'a\\' or \\n                        words[j][0] == \\'e\\' or \\n                        words[j][0] == \\'i\\' or \\n                        words[j][0] == \\'o\\' or \\n                        words[j][0] == \\'u\\' \\n                    ) \\n                    and \\n                    (\\n                        words[j].back() == \\'a\\' or\\n                        words[j].back() == \\'e\\' or\\n                        words[j].back() == \\'i\\' or\\n                        words[j].back() == \\'o\\' or\\n                        words[j].back() == \\'u\\'\\n                    )\\n                ) count++;\\n            }\\n            answer.push_back(count);\\n        }\\n        return answer;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    bool isvowel(char ch)\\n    {\\n        if(ch == \\'a\\' or ch == \\'e\\' or ch == \\'i\\' or ch == \\'o\\' or ch == \\'u\\') return true;\\n\\n        return false;\\n    }\\n\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) \\n    {\\n        vector<int>prefix;\\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            if( isvowel(words[i][0]) and isvowel(words[i].back()) )\\n            {\\n                prefix.push_back(1);\\n            }\\n            else prefix.push_back(0);\\n        }\\n\\n        for(int i = 1; i<prefix.size(); i++)\\n        {\\n            prefix[i] += prefix[i-1];\\n        }\\n        vector<int>answer;\\n        for(int i = 0; i<queries.size(); i++)\\n        {\\n            if(queries[i][0]>0)\\n            {\\n                answer.push_back( prefix[queries[i].back()] - prefix[queries[i][0]-1] );\\n            }\\n            else \\n            {\\n                answer.push_back( prefix[queries[i].back()] );\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289255,
                "title": "sweets-and-simple-solution-specially-for-beginner-easy-approach-straight-forward-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n      vector<int> prisum;\\n      vector<int> ans;\\n      int sum=0;\\n      int len=words.size();\\n      for(int i=0;i<len;i++){\\n          if((words[i][0]==\\'a\\' || words[i][0]==\\'e\\' || words[i][0]==\\'i\\' || words[i][0]==\\'o\\' || words[i][0]==\\'u\\') && (words[i][words[i].size()-1]==\\'a\\' || words[i][words[i].size()-1]==\\'e\\' || words[i][words[i].size()-1]==\\'i\\' || words[i][words[i].size()-1]==\\'o\\' || words[i][words[i].size()-1]==\\'u\\')){\\n              sum=sum+1;\\n              prisum.push_back(sum);\\n          }\\n          else\\n          prisum.push_back(sum);\\n\\n          //cout<<sum<<endl;\\n      }\\n \\n      int qLen=queries.size();\\n      //cout<<qLen<<endl;\\n      for(int i=0;i<qLen;i++){\\n          if(queries[i][0]==0){\\n          ans.push_back(abs(prisum[queries[i][1]]));\\n          //cout<<abs(prisum[queries[i][1]])<<endl;\\n          }\\n          else if(queries[i][0]==queries[i][1]){\\n          ans.push_back(abs(prisum[queries[i][0]]-prisum[queries[i][0]-1]));\\n          //cout<<abs(prisum[queries[i][0]]-prisum[queries[i][0]-1])<<endl;\\n          }\\n          else{\\n          ans.push_back(abs(prisum[queries[i][0]-1]-prisum[queries[i][1]]));\\n          ///cout<<abs(prisum[queries[i][0]-1]-prisum[queries[i][1]]<<endl;\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n      vector<int> prisum;\\n      vector<int> ans;\\n      int sum=0;\\n      int len=words.size();\\n      for(int i=0;i<len;i++){\\n          if((words[i][0]==\\'a\\' || words[i][0]==\\'e\\' || words[i][0]==\\'i\\' || words[i][0]==\\'o\\' || words[i][0]==\\'u\\') && (words[i][words[i].size()-1]==\\'a\\' || words[i][words[i].size()-1]==\\'e\\' || words[i][words[i].size()-1]==\\'i\\' || words[i][words[i].size()-1]==\\'o\\' || words[i][words[i].size()-1]==\\'u\\')){\\n              sum=sum+1;\\n              prisum.push_back(sum);\\n          }\\n          else\\n          prisum.push_back(sum);\\n\\n          //cout<<sum<<endl;\\n      }\\n \\n      int qLen=queries.size();\\n      //cout<<qLen<<endl;\\n      for(int i=0;i<qLen;i++){\\n          if(queries[i][0]==0){\\n          ans.push_back(abs(prisum[queries[i][1]]));\\n          //cout<<abs(prisum[queries[i][1]])<<endl;\\n          }\\n          else if(queries[i][0]==queries[i][1]){\\n          ans.push_back(abs(prisum[queries[i][0]]-prisum[queries[i][0]-1]));\\n          //cout<<abs(prisum[queries[i][0]]-prisum[queries[i][0]-1])<<endl;\\n          }\\n          else{\\n          ans.push_back(abs(prisum[queries[i][0]-1]-prisum[queries[i][1]]));\\n          ///cout<<abs(prisum[queries[i][0]-1]-prisum[queries[i][1]]<<endl;\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3287418,
                "title": "java",
                "content": "First try to solve the easy level version of this question:\\nhttps://leetcode.com/problems/count-the-number-of-vowel-strings-in-range/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a prefix array `where prefix[i] denotes the vowel strings till i-th index`\\n- arr array denotes `arr[i] = 1` if `words[i] is a vowel string` \\n- get the prefix sum, in the prefix array \\n- store the ans of the k-th query in ans[k]\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int arr[] = new int[words.length];\\n        int ans[] = new int[queries.length];\\n        \\n        arr[0] = (has(words[0]))?1:0;\\n        int prefix[] = new int[words.length];\\n        prefix[0] = arr[0];\\n        \\n        for(int i=1;i<words.length;i++){\\n            if(has(words[i])){\\n                arr[i]++;\\n            }\\n            prefix[i] = prefix[i-1] + arr[i];\\n        }\\n        for(int k=0;k<ans.length;k++){\\n            int l = queries[k][0], r = queries[k][1];\\n            int count = 0;\\n            \\n            if(l==r){\\n                ans[k] = arr[r];\\n            }else{\\n                count = (l>0)?prefix[r]-prefix[l-1]: prefix[r];\\n                ans[k] = count;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean has(String word){\\n        int count =0, n = word.length()-1;\\n        if(word.charAt(0)==\\'a\\' || word.charAt(0)==\\'e\\' || \\n            word.charAt(0)==\\'i\\' ||word.charAt(0)== \\'o\\' || \\n            word.charAt(0)==\\'u\\'){\\n            count++;\\n        }\\n        if(word.charAt(n)==\\'a\\' || word.charAt(n)==\\'e\\' || \\n            word.charAt(n)==\\'i\\' ||word.charAt(n)== \\'o\\' || \\n            word.charAt(n)==\\'u\\'){\\n            count++;\\n        }\\n        \\n        return count==2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int arr[] = new int[words.length];\\n        int ans[] = new int[queries.length];\\n        \\n        arr[0] = (has(words[0]))?1:0;\\n        int prefix[] = new int[words.length];\\n        prefix[0] = arr[0];\\n        \\n        for(int i=1;i<words.length;i++){\\n            if(has(words[i])){\\n                arr[i]++;\\n            }\\n            prefix[i] = prefix[i-1] + arr[i];\\n        }\\n        for(int k=0;k<ans.length;k++){\\n            int l = queries[k][0], r = queries[k][1];\\n            int count = 0;\\n            \\n            if(l==r){\\n                ans[k] = arr[r];\\n            }else{\\n                count = (l>0)?prefix[r]-prefix[l-1]: prefix[r];\\n                ans[k] = count;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean has(String word){\\n        int count =0, n = word.length()-1;\\n        if(word.charAt(0)==\\'a\\' || word.charAt(0)==\\'e\\' || \\n            word.charAt(0)==\\'i\\' ||word.charAt(0)== \\'o\\' || \\n            word.charAt(0)==\\'u\\'){\\n            count++;\\n        }\\n        if(word.charAt(n)==\\'a\\' || word.charAt(n)==\\'e\\' || \\n            word.charAt(n)==\\'i\\' ||word.charAt(n)== \\'o\\' || \\n            word.charAt(n)==\\'u\\'){\\n            count++;\\n        }\\n        \\n        return count==2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287269,
                "title": "check-the-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        char vow[]{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n\\n        int dp[100001]={0};\\n\\n        for(int i=0;i<words.size();i++){\\n\\n            if(count(vow,vow+5,words[i][0])>0 && count(vow,vow+5,words[i].back())>0)\\n                dp[i]=1;\\n\\n            if(i>0)dp[i]+=dp[i-1];\\n\\n        }\\n        vector<int> vec;\\n\\n        for(int i=0;i<queries.size();i++){\\n\\n            int c = dp[queries[i][1]];\\n\\n            if(queries[i][0]!=0)c-=dp[queries[i][0]-1];\\n            \\n            vec.push_back(c);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        char vow[]{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n\\n        int dp[100001]={0};\\n\\n        for(int i=0;i<words.size();i++){\\n\\n            if(count(vow,vow+5,words[i][0])>0 && count(vow,vow+5,words[i].back())>0)\\n                dp[i]=1;\\n\\n            if(i>0)dp[i]+=dp[i-1];\\n\\n        }\\n        vector<int> vec;\\n\\n        for(int i=0;i<queries.size();i++){\\n\\n            int c = dp[queries[i][1]];\\n\\n            if(queries[i][0]!=0)c-=dp[queries[i][0]-1];\\n            \\n            vec.push_back(c);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248322,
                "title": "beginner-friendly-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> res ; \\n        int n  = words.size() ; \\n        vector<int> prefix(n,0);\\n        int sz = words[0].size()-1;\\n        if(words[0][0]==\\'a\\' ||words[0][0]==\\'e\\' ||words[0][0]==\\'i\\' ||words[0][0]==\\'o\\' ||words[0][0]==\\'u\\')\\n        if(words[0][sz]==\\'a\\' ||words[0][sz]==\\'e\\' ||words[0][sz]==\\'i\\' ||words[0][sz]==\\'o\\' ||words[0][sz]==\\'u\\')\\n        prefix[0] = 1;  \\n\\n\\n        for(int i = 1; i< n;i++)\\n        {\\n        prefix[i] = prefix[i] + prefix[i-1] ; \\n        sz = words[i].size()-1;\\n        if(words[i][0]==\\'a\\' ||words[i][0]==\\'e\\' ||words[i][0]==\\'i\\' ||words[i][0]==\\'o\\' ||words[i][0]==\\'u\\')\\n        if(words[i][sz]==\\'a\\' ||words[i][sz]==\\'e\\' ||words[i][sz]==\\'i\\' ||words[i][sz]==\\'o\\' ||words[i][sz]==\\'u\\')\\n        prefix[i] ++ ; \\n\\n        }\\n\\n        for(int i = 0; i < queries.size();i++)\\n        {\\n       if(queries[i][0]==0)\\n       res.push_back(prefix[queries[i][1]]);\\n       else \\n       res.push_back(prefix[queries[i][1]] - prefix[queries[i][0]-1]);\\n        }\\n\\n        return res; \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> res ; \\n        int n  = words.size() ; \\n        vector<int> prefix(n,0);\\n        int sz = words[0].size()-1;\\n        if(words[0][0]==\\'a\\' ||words[0][0]==\\'e\\' ||words[0][0]==\\'i\\' ||words[0][0]==\\'o\\' ||words[0][0]==\\'u\\')\\n        if(words[0][sz]==\\'a\\' ||words[0][sz]==\\'e\\' ||words[0][sz]==\\'i\\' ||words[0][sz]==\\'o\\' ||words[0][sz]==\\'u\\')\\n        prefix[0] = 1;  \\n\\n\\n        for(int i = 1; i< n;i++)\\n        {\\n        prefix[i] = prefix[i] + prefix[i-1] ; \\n        sz = words[i].size()-1;\\n        if(words[i][0]==\\'a\\' ||words[i][0]==\\'e\\' ||words[i][0]==\\'i\\' ||words[i][0]==\\'o\\' ||words[i][0]==\\'u\\')\\n        if(words[i][sz]==\\'a\\' ||words[i][sz]==\\'e\\' ||words[i][sz]==\\'i\\' ||words[i][sz]==\\'o\\' ||words[i][sz]==\\'u\\')\\n        prefix[i] ++ ; \\n\\n        }\\n\\n        for(int i = 0; i < queries.size();i++)\\n        {\\n       if(queries[i][0]==0)\\n       res.push_back(prefix[queries[i][1]]);\\n       else \\n       res.push_back(prefix[queries[i][1]] - prefix[queries[i][0]-1]);\\n        }\\n\\n        return res; \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240810,
                "title": "c-binary-seach-o-nlogn-solution",
                "content": "# Intuition\\nJust Think of upper Bound and lower bound.\\n\\ntemp array is list of all indexes of valid words\\n\\nlowerboud is equal to smallest number that is >= queries[i][0] and <=\\nqueries[i][1]\\n\\nupperboud is equal to largest number that is >= queries[i][0] and <=\\nqueries[i][1]\\n\\nans=index of upperbound - index of lowerbound + 1\\n \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(NLOGN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n     \\n     bool isVowel(char c){\\n\\n         return c==\\'a\\' or c==\\'e\\' or c==\\'i\\' or c==\\'o\\' or c==\\'u\\';\\n     }\\n\\n\\n      \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        \\n        vector<int> ans(queries.size(),0);\\n\\n\\n        vector<int> temp;\\n\\n        for(int i=0;i<words.size();i++){\\n              string p=words[i];\\n\\n              if(isVowel(p.front()) and isVowel(p.back())){\\n                  temp.push_back(i);\\n              }\\n        }\\n\\n\\n\\n        for(int i=0;i<queries.size();i++){\\n            int lower=queries[i][0];\\n            int upper=queries[i][1];\\n\\n\\n            int idx1=-1;\\n            int val1=-1;\\n            int idx2=-1;\\n            int val2=-1;\\n\\n            // first binary search\\n\\n            int low=0;\\n            int high=temp.size()-1;\\n\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n\\n                if(temp[mid]>=lower and temp[mid]<=upper){\\n                    val1=temp[mid];\\n                    idx1=mid;\\n\\n                    high=mid-1;\\n                }\\n                else if(temp[mid]<lower)\\n                low=mid+1;\\n                else\\n                high=mid-1;\\n            }\\n\\n\\n            if(idx1==-1)\\n            continue;\\n\\n\\n            low=0;\\n            high=temp.size()-1;\\n\\n// second binary search\\n\\n              while(low<=high){\\n                int mid=low+(high-low)/2;\\n\\n                if(temp[mid]>=lower and temp[mid]<=upper){\\n                    val2=temp[mid];\\n                    idx2=mid;\\n\\n                    low=mid+1;\\n                }\\n                else if(temp[mid]<lower)\\n                low=mid+1;\\n                else\\n                high=mid-1;\\n            }\\n              \\n                if(idx2==-1)\\n            continue;\\n\\n\\n            ans[i]=idx2-idx1+1;\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n     \\n     bool isVowel(char c){\\n\\n         return c==\\'a\\' or c==\\'e\\' or c==\\'i\\' or c==\\'o\\' or c==\\'u\\';\\n     }\\n\\n\\n      \\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        \\n        vector<int> ans(queries.size(),0);\\n\\n\\n        vector<int> temp;\\n\\n        for(int i=0;i<words.size();i++){\\n              string p=words[i];\\n\\n              if(isVowel(p.front()) and isVowel(p.back())){\\n                  temp.push_back(i);\\n              }\\n        }\\n\\n\\n\\n        for(int i=0;i<queries.size();i++){\\n            int lower=queries[i][0];\\n            int upper=queries[i][1];\\n\\n\\n            int idx1=-1;\\n            int val1=-1;\\n            int idx2=-1;\\n            int val2=-1;\\n\\n            // first binary search\\n\\n            int low=0;\\n            int high=temp.size()-1;\\n\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n\\n                if(temp[mid]>=lower and temp[mid]<=upper){\\n                    val1=temp[mid];\\n                    idx1=mid;\\n\\n                    high=mid-1;\\n                }\\n                else if(temp[mid]<lower)\\n                low=mid+1;\\n                else\\n                high=mid-1;\\n            }\\n\\n\\n            if(idx1==-1)\\n            continue;\\n\\n\\n            low=0;\\n            high=temp.size()-1;\\n\\n// second binary search\\n\\n              while(low<=high){\\n                int mid=low+(high-low)/2;\\n\\n                if(temp[mid]>=lower and temp[mid]<=upper){\\n                    val2=temp[mid];\\n                    idx2=mid;\\n\\n                    low=mid+1;\\n                }\\n                else if(temp[mid]<lower)\\n                low=mid+1;\\n                else\\n                high=mid-1;\\n            }\\n              \\n                if(idx2==-1)\\n            continue;\\n\\n\\n            ans[i]=idx2-idx1+1;\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237362,
                "title": "prefix-sum-easy-c",
                "content": "# Intuition\\nprefix sum\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& q) {\\n        vector<int> v ;\\n        vector<int> ans ;\\n        int a =0;\\n        unordered_map<char , int> m ;\\n        string tmp =  \"aeiou\";\\n        for(auto i : tmp){\\n            m[i]++;\\n        }\\n        for(int i =0 ; i<words.size();i++){\\n            int j = words[i].size()-1;\\nif(m.count(words[i][0])==1 and m.count(words[i][j])==1){\\n    a++ ;\\n} \\nv.push_back(a);\\n        }\\n\\nfor(int i  =0;i<q.size();i++){\\n    int s = 0;\\n    if( q[i][0]>0){\\ns-= v[q[i][0]-1];\\n    }\\n    s+= v[q[i][1]];\\n    ans.push_back(s);\\n}\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& q) {\\n        vector<int> v ;\\n        vector<int> ans ;\\n        int a =0;\\n        unordered_map<char , int> m ;\\n        string tmp =  \"aeiou\";\\n        for(auto i : tmp){\\n            m[i]++;\\n        }\\n        for(int i =0 ; i<words.size();i++){\\n            int j = words[i].size()-1;\\nif(m.count(words[i][0])==1 and m.count(words[i][j])==1){\\n    a++ ;\\n} \\nv.push_back(a);\\n        }\\n\\nfor(int i  =0;i<q.size();i++){\\n    int s = 0;\\n    if( q[i][0]>0){\\ns-= v[q[i][0]-1];\\n    }\\n    s+= v[q[i][1]];\\n    ans.push_back(s);\\n}\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232877,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& q) {\\n        vector<int>v(words.size(),0);\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string s=words[i];\\n            if(isvowel(s[0])==true and isvowel(s[s.length()-1])==true)\\n            {\\n                v[i]++;\\n            }\\n        }\\n        for(int i=1;i<v.size();i++)\\n        {\\n            v[i]+=v[i-1];\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int s=q[i][0];\\n            int e=q[i][1];\\n            if(s==0)\\n            {\\n                ans.push_back(v[e]);\\n            }\\n            else\\n            {\\n                ans.push_back(v[e]-v[s-1]);\\n            }\\n        }\\n        return ans;\\n    }\\n    bool isvowel(char &ch)\\n    {\\n        if(ch==\\'a\\' or ch==\\'e\\' or ch==\\'i\\' or ch==\\'o\\' or ch==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& q) {\\n        vector<int>v(words.size(),0);\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string s=words[i];\\n            if(isvowel(s[0])==true and isvowel(s[s.length()-1])==true)\\n            {\\n                v[i]++;\\n            }\\n        }\\n        for(int i=1;i<v.size();i++)\\n        {\\n            v[i]+=v[i-1];\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int s=q[i][0];\\n            int e=q[i][1];\\n            if(s==0)\\n            {\\n                ans.push_back(v[e]);\\n            }\\n            else\\n            {\\n                ans.push_back(v[e]-v[s-1]);\\n            }\\n        }\\n        return ans;\\n    }\\n    bool isvowel(char &ch)\\n    {\\n        if(ch==\\'a\\' or ch==\\'e\\' or ch==\\'i\\' or ch==\\'o\\' or ch==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226256,
                "title": "c-brute-force",
                "content": "```\\n/**\\n    <--- brute force\\n    | O(max(n, m)), where n = words.size() and m = queries.size()\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        int m = queries.size();\\n\\n        // preSumHasVowels[i] -- the number of word start and end with vowels in words[0:i]\\n        vector<int> preSumHasVowels(n);\\n        int preSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            int hasVowel = isStartAndEndWithVowels(words[i]);\\n            preSum += hasVowel;\\n            preSumHasVowels[i] = preSum;\\n        }\\n\\n        vector<int> ans(m);\\n        for (int i = 0; i < m; i++) {\\n            auto query = queries[i];\\n            // cout([query[0], query[1]]) = preSumHasVowels(query[1]) -  preSumHasVowels(query[0] - 1)\\n            ans[i] = query[0] == 0 ? preSumHasVowels[query[1]] : preSumHasVowels[query[1]] -  preSumHasVowels[query[0] - 1];\\n        }\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    static bool isStartAndEndWithVowels(string& str) {\\n        string vowels = \"aeiou\";\\n        \\n        return vowels.find(str[0]) != string::npos\\n               &&  \\n               vowels.find(str[str.size() - 1]) != string::npos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n    <--- brute force\\n    | O(max(n, m)), where n = words.size() and m = queries.size()\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        int m = queries.size();\\n\\n        // preSumHasVowels[i] -- the number of word start and end with vowels in words[0:i]\\n        vector<int> preSumHasVowels(n);\\n        int preSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            int hasVowel = isStartAndEndWithVowels(words[i]);\\n            preSum += hasVowel;\\n            preSumHasVowels[i] = preSum;\\n        }\\n\\n        vector<int> ans(m);\\n        for (int i = 0; i < m; i++) {\\n            auto query = queries[i];\\n            // cout([query[0], query[1]]) = preSumHasVowels(query[1]) -  preSumHasVowels(query[0] - 1)\\n            ans[i] = query[0] == 0 ? preSumHasVowels[query[1]] : preSumHasVowels[query[1]] -  preSumHasVowels[query[0] - 1];\\n        }\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    static bool isStartAndEndWithVowels(string& str) {\\n        string vowels = \"aeiou\";\\n        \\n        return vowels.find(str[0]) != string::npos\\n               &&  \\n               vowels.find(str[str.size() - 1]) != string::npos;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3226183,
                "title": "easy-prefix-sum-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) \\n    {\\n           vector<int>prefix;\\n           for(int i=0;i<words.size();i++)\\n           {\\n               string word = words[i];\\n               if(fun(word[0])==true and fun(word[word.length()-1])==true)\\n               {\\n                   prefix.push_back(1);\\n               }\\n               else\\n               {\\n                   prefix.push_back(0);\\n               }\\n           }    \\n           for(int i=0;i<prefix.size();i++)\\n           {\\n               if(i == 0) continue;\\n               prefix[i] = prefix[i] + prefix[i-1];\\n           }\\n           vector<int>ans;\\n\\n           for(int i=0;i<queries.size();i++)\\n           {\\n               int start = queries[i][0];\\n               int end = queries[i][1];\\n\\n               if(start == 0)\\n               ans.push_back(prefix[end]);\\n               else\\n               ans.push_back(prefix[end] - prefix[start-1]);\\n           }\\n           return ans;\\n    }\\n    bool fun(char &ch)\\n    {\\n        if(ch == \\'a\\' or ch==\\'e\\' or ch ==\\'i\\' or ch ==\\'o\\' or ch ==\\'u\\')\\n        return true;\\n\\n        return false;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) \\n    {\\n           vector<int>prefix;\\n           for(int i=0;i<words.size();i++)\\n           {\\n               string word = words[i];\\n               if(fun(word[0])==true and fun(word[word.length()-1])==true)\\n               {\\n                   prefix.push_back(1);\\n               }\\n               else\\n               {\\n                   prefix.push_back(0);\\n               }\\n           }    \\n           for(int i=0;i<prefix.size();i++)\\n           {\\n               if(i == 0) continue;\\n               prefix[i] = prefix[i] + prefix[i-1];\\n           }\\n           vector<int>ans;\\n\\n           for(int i=0;i<queries.size();i++)\\n           {\\n               int start = queries[i][0];\\n               int end = queries[i][1];\\n\\n               if(start == 0)\\n               ans.push_back(prefix[end]);\\n               else\\n               ans.push_back(prefix[end] - prefix[start-1]);\\n           }\\n           return ans;\\n    }\\n    bool fun(char &ch)\\n    {\\n        if(ch == \\'a\\' or ch==\\'e\\' or ch ==\\'i\\' or ch ==\\'o\\' or ch ==\\'u\\')\\n        return true;\\n\\n        return false;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226091,
                "title": "solution-using-array-only",
                "content": "```\\nclass Solution {\\n    vector<char> vow = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\npublic:\\n    bool isVowelString(string str)\\n    {\\n        bool firstLetter = false;\\n        bool lastLetter = false;\\n        if(str.size() == 0) return false;\\n        \\n        for(int i = 0; i < 5; i++)\\n        {\\n            if(str[0] == vow[i]) firstLetter = true;\\n            if(str[str.size()-1] == vow[i]) lastLetter = true;\\n        }\\n        return (firstLetter&&lastLetter);\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> arr(words.size(), 0);\\n        \\n        int currVow = 0;\\n        for(int i = 0; i < words.size(); i++)\\n        {\\n            if(isVowelString(words[i])){\\n                ++currVow;\\n            }\\n            arr[i] = currVow;\\n        }\\n        \\n        vector<int> res;\\n        for(int i = 0; i < queries.size(); i++)\\n        {\\n            int l = queries[i][0];\\n            int h = queries[i][1];\\n            \\n            if(l > 0)\\n            {\\n                res.push_back(arr[h]-arr[l-1]);\\n            }else\\n            {\\n                res.push_back(arr[h]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    vector<char> vow = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\npublic:\\n    bool isVowelString(string str)\\n    {\\n        bool firstLetter = false;\\n        bool lastLetter = false;\\n        if(str.size() == 0) return false;\\n        \\n        for(int i = 0; i < 5; i++)\\n        {\\n            if(str[0] == vow[i]) firstLetter = true;\\n            if(str[str.size()-1] == vow[i]) lastLetter = true;\\n        }\\n        return (firstLetter&&lastLetter);\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> arr(words.size(), 0);\\n        \\n        int currVow = 0;\\n        for(int i = 0; i < words.size(); i++)\\n        {\\n            if(isVowelString(words[i])){\\n                ++currVow;\\n            }\\n            arr[i] = currVow;\\n        }\\n        \\n        vector<int> res;\\n        for(int i = 0; i < queries.size(); i++)\\n        {\\n            int l = queries[i][0];\\n            int h = queries[i][1];\\n            \\n            if(l > 0)\\n            {\\n                res.push_back(arr[h]-arr[l-1]);\\n            }else\\n            {\\n                res.push_back(arr[h]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202770,
                "title": "python-simple-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def vowelStrings(self, words, queries):\\n        n, ans = len(queries), []\\n\\n        for i in words:\\n            if i[0] in \"aeiou\" and i[-1] in \"aeiou\":\\n                ans += [1]\\n            else:\\n                ans += [0]\\n\\n        prefix_sum = [0]\\n\\n        for i in ans:\\n            prefix_sum.append(prefix_sum[-1] + i)\\n\\n        result = []\\n\\n        for i,j in queries:\\n            result += [prefix_sum[j+1]-prefix_sum[i]]\\n\\n        return result\\n\\n        \\n\\n\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def vowelStrings(self, words, queries):\\n        n, ans = len(queries), []\\n\\n        for i in words:\\n            if i[0] in \"aeiou\" and i[-1] in \"aeiou\":\\n                ans += [1]\\n            else:\\n                ans += [0]\\n\\n        prefix_sum = [0]\\n\\n        for i in ans:\\n            prefix_sum.append(prefix_sum[-1] + i)\\n\\n        result = []\\n\\n        for i,j in queries:\\n            result += [prefix_sum[j+1]-prefix_sum[i]]\\n\\n        return result\\n\\n        \\n\\n\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201783,
                "title": "space-optimized",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        return c==\\'a\\'||c==\\'e\\'||c==\\'i\\'||c==\\'o\\'||c==\\'u\\';\\n    }\\n    bool satisfy(string &s)\\n    {\\n        return isVowel(s[0])&&isVowel(s.back());\\n    }\\n    vector<int> vowelStrings(vector<string>& sums, vector<vector<int>>& queries) {\\n        for(int i=0;i<sums.size();i++)\\n        {\\n            if(satisfy(sums[i]))\\n                sums[i]=\"1\";\\n            else\\n                sums[i]=\"0\";\\n        }\\n        for(int i=1;i<sums.size();i++)\\n            sums[i]=to_string(stoi(sums[i-1]) +stoi(sums[i]) );\\n        vector<int>ans;\\n        for(auto query:queries)\\n        {\\n            if(query[0])\\n                ans.push_back(stoi(sums[query[1]])-stoi(sums[query[0]-1]));\\n            else\\n                ans.push_back(stoi(sums[query[1]]));\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        return c==\\'a\\'||c==\\'e\\'||c==\\'i\\'||c==\\'o\\'||c==\\'u\\';\\n    }\\n    bool satisfy(string &s)\\n    {\\n        return isVowel(s[0])&&isVowel(s.back());\\n    }\\n    vector<int> vowelStrings(vector<string>& sums, vector<vector<int>>& queries) {\\n        for(int i=0;i<sums.size();i++)\\n        {\\n            if(satisfy(sums[i]))\\n                sums[i]=\"1\";\\n            else\\n                sums[i]=\"0\";\\n        }\\n        for(int i=1;i<sums.size();i++)\\n            sums[i]=to_string(stoi(sums[i-1]) +stoi(sums[i]) );\\n        vector<int>ans;\\n        for(auto query:queries)\\n        {\\n            if(query[0])\\n                ans.push_back(stoi(sums[query[1]])-stoi(sums[query[0]-1]));\\n            else\\n                ans.push_back(stoi(sums[query[1]]));\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201684,
                "title": "javascript-short-95-runtime",
                "content": "```\\nconst vowelStrings = (w, q) => {\\n  const isVowel = (c) => c == \"a\" || c == \"e\" || c == \"i\" || c == \"o\" || c == \"u\";\\n\\n  let count = new Array(w.length + 1).fill(0);\\n  w.forEach(\\n    (str, i) =>\\n      (count[i + 1] = count[i] + (isVowel(str[0]) && isVowel(str[str.length - 1])))\\n  );\\n\\n  return q.map(([l, r]) => count[r + 1] - count[l]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst vowelStrings = (w, q) => {\\n  const isVowel = (c) => c == \"a\" || c == \"e\" || c == \"i\" || c == \"o\" || c == \"u\";\\n\\n  let count = new Array(w.length + 1).fill(0);\\n  w.forEach(\\n    (str, i) =>\\n      (count[i + 1] = count[i] + (isVowel(str[0]) && isVowel(str[str.length - 1])))\\n  );\\n\\n  return q.map(([l, r]) => count[r + 1] - count[l]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3201139,
                "title": "prefix-sum-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n   bool isvalid(string word){\\n       char st=word[0],en=word[word.size()-1];\\n       if((st==\\'a\\' || st==\\'e\\' || st==\\'i\\' || st==\\'o\\' || st==\\'u\\')&& (en==\\'a\\' || en==\\'e\\' || en==\\'i\\' || en==\\'o\\' || en==\\'u\\')){\\n           return true;\\n       }\\n       return false;\\n   }\\n\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),i=0;\\n        vector<int>ans;\\n        vector<int>psum(n+1,0);\\n        for(auto it:words){\\n           psum[i+1]=psum[i]+isvalid(it);\\n           i++;\\n        }\\n        for(auto it:queries){\\n            int s=it[0],en=it[1];\\n            ans.push_back(psum[en+1]-psum[s]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n   bool isvalid(string word){\\n       char st=word[0],en=word[word.size()-1];\\n       if((st==\\'a\\' || st==\\'e\\' || st==\\'i\\' || st==\\'o\\' || st==\\'u\\')&& (en==\\'a\\' || en==\\'e\\' || en==\\'i\\' || en==\\'o\\' || en==\\'u\\')){\\n           return true;\\n       }\\n       return false;\\n   }\\n\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),i=0;\\n        vector<int>ans;\\n        vector<int>psum(n+1,0);\\n        for(auto it:words){\\n           psum[i+1]=psum[i]+isvalid(it);\\n           i++;\\n        }\\n        for(auto it:queries){\\n            int s=it[0],en=it[1];\\n            ans.push_back(psum[en+1]-psum[s]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200950,
                "title": "golang-simple-solution",
                "content": "```go\\nfunc vowelStrings(words []string, queries [][]int) []int {\\n\\tcounter := make([]int, len(words)+1)\\n\\tanswer := make([]int, 0, len(queries))\\n\\tfor i, w := range words {\\n\\t\\tcounter[i+1] = counter[i]\\n\\t\\tswitch w[0] {\\n\\t\\tcase \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\':\\n\\t\\tdefault:\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tswitch w[len(w)-1] {\\n\\t\\tcase \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\':\\n\\t\\tdefault:\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcounter[i+1]++\\n\\t}\\n\\tfor _, q := range queries {\\n\\t\\tanswer = append(answer, counter[q[1]+1]-counter[q[0]])\\n\\t}\\n\\treturn answer\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc vowelStrings(words []string, queries [][]int) []int {\\n\\tcounter := make([]int, len(words)+1)\\n\\tanswer := make([]int, 0, len(queries))\\n\\tfor i, w := range words {\\n\\t\\tcounter[i+1] = counter[i]\\n\\t\\tswitch w[0] {\\n\\t\\tcase \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\':\\n\\t\\tdefault:\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tswitch w[len(w)-1] {\\n\\t\\tcase \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\':\\n\\t\\tdefault:\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcounter[i+1]++\\n\\t}\\n\\tfor _, q := range queries {\\n\\t\\tanswer = append(answer, counter[q[1]+1]-counter[q[0]])\\n\\t}\\n\\treturn answer\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3197176,
                "title": "python-prefix-sum-2-liner-the-best",
                "content": "# Complexity\\n- Time complexity: $$O(m+n)$$\\n- Space complexity: $$O(m+n)$$\\n\\nThe Best!\\n\\n# Code\\n```py\\ndef vowelStrings(self, words: list[str], queries: list[list[int]]) -> list[int]:\\n    counts = list(chain([0], accumulate(w[0] in \\'aeiou\\' and w[-1] in \\'aeiou\\' for w in words)))\\n    return [counts[r+1]-counts[l] for l, r in queries]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\ndef vowelStrings(self, words: list[str], queries: list[list[int]]) -> list[int]:\\n    counts = list(chain([0], accumulate(w[0] in \\'aeiou\\' and w[-1] in \\'aeiou\\' for w in words)))\\n    return [counts[r+1]-counts[l] for l, r in queries]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3196904,
                "title": "c-prefix-sum-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        vector<int> temp(n,0);\\n        set<char> st;\\n        st.insert(\\'a\\');\\n        st.insert(\\'e\\');\\n        st.insert(\\'i\\');\\n        st.insert(\\'o\\');\\n        st.insert(\\'u\\');\\n        int cnt = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int start = 0;\\n            int end = words[i].size()-1;\\n            if(st.find(words[i][start]) != st.end() && st.find(words[i][end]) != st.end())\\n            {\\n                cnt++;\\n            }\\n            temp[i] = cnt;\\n        }\\n        vector<int> ans;\\n        for(auto it:queries)\\n        {\\n            int l = it[0];\\n            int r = it[1];\\n            if(l == 0)\\n            {\\n                ans.push_back(temp[r]);\\n            }\\n            else\\n            {\\n                ans.push_back(temp[r]-temp[l-1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n = words.size();\\n        vector<int> temp(n,0);\\n        set<char> st;\\n        st.insert(\\'a\\');\\n        st.insert(\\'e\\');\\n        st.insert(\\'i\\');\\n        st.insert(\\'o\\');\\n        st.insert(\\'u\\');\\n        int cnt = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int start = 0;\\n            int end = words[i].size()-1;\\n            if(st.find(words[i][start]) != st.end() && st.find(words[i][end]) != st.end())\\n            {\\n                cnt++;\\n            }\\n            temp[i] = cnt;\\n        }\\n        vector<int> ans;\\n        for(auto it:queries)\\n        {\\n            int l = it[0];\\n            int r = it[1];\\n            if(l == 0)\\n            {\\n                ans.push_back(temp[r]);\\n            }\\n            else\\n            {\\n                ans.push_back(temp[r]-temp[l-1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196134,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int[]arr = new int[words.length + 1];\\n        int sum = 0;\\n        for(int i = 0;i<words.length;i++){\\n            char a = words[i].charAt(0);\\n            char b = words[i].charAt(words[i].length()-1);\\n            if((a == \\'a\\' || a == \\'e\\' || a == \\'i\\' || a == \\'o\\' || a == \\'u\\') && (b == \\'a\\' || b == \\'e\\' || b == \\'i\\' || b == \\'o\\' || b == \\'u\\'))\\n                sum++;\\n            arr[i] = sum;\\n        }\\n        int[]res = new int[queries.length];\\n        int m = 0;\\n        for(int i = 0;i < queries.length;i++){\\n            if(queries[i][0] == 0)\\n                res[i] = arr[queries[i][1]];\\n            else\\n                res[i] = arr[queries[i][1]] - arr[queries[i][0]-1];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int[]arr = new int[words.length + 1];\\n        int sum = 0;\\n        for(int i = 0;i<words.length;i++){\\n            char a = words[i].charAt(0);\\n            char b = words[i].charAt(words[i].length()-1);\\n            if((a == \\'a\\' || a == \\'e\\' || a == \\'i\\' || a == \\'o\\' || a == \\'u\\') && (b == \\'a\\' || b == \\'e\\' || b == \\'i\\' || b == \\'o\\' || b == \\'u\\'))\\n                sum++;\\n            arr[i] = sum;\\n        }\\n        int[]res = new int[queries.length];\\n        int m = 0;\\n        for(int i = 0;i < queries.length;i++){\\n            if(queries[i][0] == 0)\\n                res[i] = arr[queries[i][1]];\\n            else\\n                res[i] = arr[queries[i][1]] - arr[queries[i][0]-1];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194759,
                "title": "linear-solution-99-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/088ae39c-eb8d-4404-aac4-be2c1c2bede2_1676575095.8046222.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        pre_sum = [0] * (len(words) + 1)\\n        count = 0\\n        for i, w in enumerate(words, start=1):\\n            if w[0] in Solution.vowels and w[-1] in Solution.vowels:\\n                count += 1\\n            pre_sum[i] = count\\n        return [pre_sum[j + 1] - pre_sum[i] for i, j in queries]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        pre_sum = [0] * (len(words) + 1)\\n        count = 0\\n        for i, w in enumerate(words, start=1):\\n            if w[0] in Solution.vowels and w[-1] in Solution.vowels:\\n                count += 1\\n            pre_sum[i] = count\\n        return [pre_sum[j + 1] - pre_sum[i] for i, j in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192476,
                "title": "python3-simplest-solution-o-n-time-and-space",
                "content": "```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        prefixSum=[0]*(len(words)+1)\\n        count=[0]*len(words)\\n        ans=[]\\n        vowels=(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\')\\n        for i,word in enumerate(words):\\n            if word[0] in vowels and word[-1] in vowels:\\n                count[i]=1\\n        prefixSum[0]=count[0]\\n        for i in range(1,len(words)):\\n            prefixSum[i]=count[i]+prefixSum[i-1]\\n        for query in queries:\\n            start,end=query\\n            ans.append(prefixSum[end]-prefixSum[start-1])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        prefixSum=[0]*(len(words)+1)\\n        count=[0]*len(words)\\n        ans=[]\\n        vowels=(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\')\\n        for i,word in enumerate(words):\\n            if word[0] in vowels and word[-1] in vowels:\\n                count[i]=1\\n        prefixSum[0]=count[0]\\n        for i in range(1,len(words)):\\n            prefixSum[i]=count[i]+prefixSum[i-1]\\n        for query in queries:\\n            start,end=query\\n            ans.append(prefixSum[end]-prefixSum[start-1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190931,
                "title": "python-terrible-2-liner",
                "content": "Bad code\\n```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        pref = list(accumulate(words, lambda prev, w: prev + (w[0] in \\'aeiou\\' and w[-1] in \\'aeiou\\'), initial=0))\\n        return [pref[j + 1] - pref[i + 1] + (words[i][0] in \\'aeiou\\' and words[i][-1] in \\'aeiou\\') for i, j in queries]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        pref = list(accumulate(words, lambda prev, w: prev + (w[0] in \\'aeiou\\' and w[-1] in \\'aeiou\\'), initial=0))\\n        return [pref[j + 1] - pref[i + 1] + (words[i][0] in \\'aeiou\\' and words[i][-1] in \\'aeiou\\') for i, j in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187599,
                "title": "c-easy-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char i){\\n        return i==\\'a\\'||i==\\'e\\'||i==\\'o\\'||i==\\'i\\'||i==\\'u\\';\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> pre(size(words)+1,0),ans;\\n        int ind=0;\\n        for(auto&i:words){\\n            if(isVowel(i[0])&&isVowel(i[size(i)-1]))pre[ind+1]=pre[ind]+1;\\n            else pre[ind+1]=pre[ind];\\n            ++ind;\\n        }\\n        for(auto&i:queries)ans.push_back(pre[i[1]+1]-pre[i[0]]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char i){\\n        return i==\\'a\\'||i==\\'e\\'||i==\\'o\\'||i==\\'i\\'||i==\\'u\\';\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        vector<int> pre(size(words)+1,0),ans;\\n        int ind=0;\\n        for(auto&i:words){\\n            if(isVowel(i[0])&&isVowel(i[size(i)-1]))pre[ind+1]=pre[ind]+1;\\n            else pre[ind+1]=pre[ind];\\n            ++ind;\\n        }\\n        for(auto&i:queries)ans.push_back(pre[i[1]+1]-pre[i[0]]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187170,
                "title": "scala-2-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def vowelStrings(words: Array[String], queries: Array[Array[Int]]): Array[Int] = {\\n        val as = words.map(n => if(\"aeiou\".contains(n.head) & \"aeiou\".contains(n.last)) 1 else 0).scanLeft(0)(_ +_)\\n        queries.map(n => as(n(1) + 1) - as(n(0)))\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def vowelStrings(words: Array[String], queries: Array[Array[Int]]): Array[Int] = {\\n        val as = words.map(n => if(\"aeiou\".contains(n.head) & \"aeiou\".contains(n.last)) 1 else 0).scanLeft(0)(_ +_)\\n        queries.map(n => as(n(1) + 1) - as(n(0)))\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3185337,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[] vowelStrings(String[] words, int[][] queries) {\\n    int ans[] = new int[queries.length], ps[] = new int[words.length+1];\\n\\n    for(int i = 0; i != words.length; i++)\\n      ps[i+1] += ps[i] + isVowel(words[i]);\\n\\n    for(int i = 0; i != queries.length; i++)\\n      ans[i] = ps[queries[i][1]+1] - ps[queries[i][0]];\\n\\n    return ans;\\n  }\\n\\n  private int isVowel(String w){\\n    int x = w.length() - 1;\\n    if( (w.charAt(0) == \\'a\\' ||\\n         w.charAt(0) == \\'o\\' ||\\n         w.charAt(0) == \\'u\\' ||\\n         w.charAt(0) == \\'i\\' ||\\n         w.charAt(0) == \\'e\\') &&\\n        (w.charAt(x) == \\'a\\' ||\\n         w.charAt(x) == \\'o\\' ||\\n         w.charAt(x) == \\'u\\' ||\\n         w.charAt(x) == \\'i\\' ||\\n         w.charAt(x) == \\'e\\')) return 1;\\n\\n       return 0;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int[] vowelStrings(String[] words, int[][] queries) {\\n    int ans[] = new int[queries.length], ps[] = new int[words.length+1];\\n\\n    for(int i = 0; i != words.length; i++)\\n      ps[i+1] += ps[i] + isVowel(words[i]);\\n\\n    for(int i = 0; i != queries.length; i++)\\n      ans[i] = ps[queries[i][1]+1] - ps[queries[i][0]];\\n\\n    return ans;\\n  }\\n\\n  private int isVowel(String w){\\n    int x = w.length() - 1;\\n    if( (w.charAt(0) == \\'a\\' ||\\n         w.charAt(0) == \\'o\\' ||\\n         w.charAt(0) == \\'u\\' ||\\n         w.charAt(0) == \\'i\\' ||\\n         w.charAt(0) == \\'e\\') &&\\n        (w.charAt(x) == \\'a\\' ||\\n         w.charAt(x) == \\'o\\' ||\\n         w.charAt(x) == \\'u\\' ||\\n         w.charAt(x) == \\'i\\' ||\\n         w.charAt(x) == \\'e\\')) return 1;\\n\\n       return 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184682,
                "title": "java-easy-solution-with-explanation",
                "content": "**If you like my solution, Please Upvote!!**\\n\\n# Approach\\n1. Create an array to Precompute the prefix sum of strings that start and end with vowels.\\n2. Create a method isVowel to store vowels.\\n3. Subtract prefix sum for range [l-1, r] to find the number of strings starting and ending with vowels.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n         int arr[] = new int[words.length];\\n         int ans[] = new int[queries.length];\\n         int count = 0;\\n        for(int i=0;i<words.length;i++){\\n           if(isVowel(words[i].charAt(0)) && isVowel(words[i].charAt(words[i].length()-1))){\\n               arr[i] = 1;\\n           }\\n        }\\n        for(int i=1;i<arr.length;i++){\\n            arr[i] += arr[i-1];\\n        }\\n        for(int i=0;i<queries.length;i++){\\n            if(queries[i][0] == 0){\\n               count = arr[queries[i][1]];\\n            }else\\n               count = arr[queries[i][1]]-arr[queries[i][0]-1];  \\n               ans[i] = count;\\n        }\\n        return ans;\\n    }\\n    boolean isVowel(char c){\\n        return c==\\'a\\'||c==\\'e\\'||c==\\'i\\'||c==\\'o\\'||c==\\'u\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n         int arr[] = new int[words.length];\\n         int ans[] = new int[queries.length];\\n         int count = 0;\\n        for(int i=0;i<words.length;i++){\\n           if(isVowel(words[i].charAt(0)) && isVowel(words[i].charAt(words[i].length()-1))){\\n               arr[i] = 1;\\n           }\\n        }\\n        for(int i=1;i<arr.length;i++){\\n            arr[i] += arr[i-1];\\n        }\\n        for(int i=0;i<queries.length;i++){\\n            if(queries[i][0] == 0){\\n               count = arr[queries[i][1]];\\n            }else\\n               count = arr[queries[i][1]]-arr[queries[i][0]-1];  \\n               ans[i] = count;\\n        }\\n        return ans;\\n    }\\n    boolean isVowel(char c){\\n        return c==\\'a\\'||c==\\'e\\'||c==\\'i\\'||c==\\'o\\'||c==\\'u\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184308,
                "title": "nothing-fancy-simple-7-lines-of-python-code",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        vow , l = \\'aeiou\\' , [0]\\n        for i in words:\\n            if i[0] in vow and i[-1] in vow:\\n                l.append(l[-1]+1)\\n            else:\\n                l.append(l[-1]+0)\\n        return [ l[right+1] - l[left] for left , right in queries]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\\n        vow , l = \\'aeiou\\' , [0]\\n        for i in words:\\n            if i[0] in vow and i[-1] in vow:\\n                l.append(l[-1]+1)\\n            else:\\n                l.append(l[-1]+0)\\n        return [ l[right+1] - l[left] for left , right in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182674,
                "title": "java-4ms-query-range-and-clean-code",
                "content": "# Approach\\n1. As we observe, we can identity this to be a range query problem: the sum of vowel strings between two ranges\\n2. Use an int[] count to count how many (rolling sum) vowel strings there are from i to n\\n   - EG: [\"aba\",\"bcb\",\"ece\",\"aa\",\"e\",\"p\"] => [1,1,2,3,4,4]\\n3. For each query, based on the given range [i,j], determine the diff between  count[j] - count[i-1].\\n    - EG: range = [2,4]\\n    - count[1] = 1, count[4] = 4. 4-1 = 3 (ece, aa, e)\\n4. Return the query range answer;  \\n\\n# Complexity\\n- Time complexity:$$O(n + n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(26 + n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private boolean[] vowels;\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        setVowels();\\n        int[] vowelCount = countVowelStrings(words);\\n        int[] queryAnswer = new int[queries.length];\\n        int left, right;\\n        for(int i = 0; i < queries.length; i++) {\\n            left = queries[i][0] == 0 ? 0 : vowelCount[queries[i][0] - 1];\\n            right = vowelCount[queries[i][1]];\\n            queryAnswer[i] = right -  left;\\n        }\\n        return queryAnswer;\\n\\n    }\\n\\n    private int[] countVowelStrings(String[] words) {\\n        int[] vowelCount =  new int[words.length];\\n        vowelCount[0] = isVowelValid(words[0]) ? 1 : 0;\\n        for (int i = 1; i < words.length; i++) {\\n            vowelCount[i] = vowelCount[i-1] + (isVowelValid(words[i]) ? 1 : 0);\\n        }\\n        return vowelCount;\\n    }\\n\\n    private boolean isVowelValid(String s) {\\n        return vowels[s.charAt(0) - \\'a\\'] && vowels[s.charAt(s.length() - 1) - \\'a\\'];\\n    }\\n\\n    private void setVowels() {\\n        if (vowels == null) {\\n            vowels = new boolean[26];\\n            vowels[\\'a\\' - \\'a\\'] = true;\\n            vowels[\\'e\\' - \\'a\\'] = true;\\n            vowels[\\'i\\' - \\'a\\'] = true;\\n            vowels[\\'o\\' - \\'a\\'] = true;\\n            vowels[\\'u\\' - \\'a\\'] = true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private boolean[] vowels;\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        setVowels();\\n        int[] vowelCount = countVowelStrings(words);\\n        int[] queryAnswer = new int[queries.length];\\n        int left, right;\\n        for(int i = 0; i < queries.length; i++) {\\n            left = queries[i][0] == 0 ? 0 : vowelCount[queries[i][0] - 1];\\n            right = vowelCount[queries[i][1]];\\n            queryAnswer[i] = right -  left;\\n        }\\n        return queryAnswer;\\n\\n    }\\n\\n    private int[] countVowelStrings(String[] words) {\\n        int[] vowelCount =  new int[words.length];\\n        vowelCount[0] = isVowelValid(words[0]) ? 1 : 0;\\n        for (int i = 1; i < words.length; i++) {\\n            vowelCount[i] = vowelCount[i-1] + (isVowelValid(words[i]) ? 1 : 0);\\n        }\\n        return vowelCount;\\n    }\\n\\n    private boolean isVowelValid(String s) {\\n        return vowels[s.charAt(0) - \\'a\\'] && vowels[s.charAt(s.length() - 1) - \\'a\\'];\\n    }\\n\\n    private void setVowels() {\\n        if (vowels == null) {\\n            vowels = new boolean[26];\\n            vowels[\\'a\\' - \\'a\\'] = true;\\n            vowels[\\'e\\' - \\'a\\'] = true;\\n            vowels[\\'i\\' - \\'a\\'] = true;\\n            vowels[\\'o\\' - \\'a\\'] = true;\\n            vowels[\\'u\\' - \\'a\\'] = true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180979,
                "title": "prefix-sum-simple-c-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c){\\n        return (c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\');\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& q) {\\n        //use prefix sum concept to get number of words in certain range\\n        //add 1 if word starts and ends with vowel\\n        vector<int> pre(words.size(),0);\\n        for(int i=0;i<words.size();i++)\\n        {\\n            int len=words[i].size();\\n            if(isVowel(words[i][0]) && isVowel(words[i][len-1]))\\n            {\\n                pre[i]=1;\\n            }\\n            if(i>0)\\n                pre[i]+=pre[i-1];\\n        }\\n        vector<int> res(q.size());\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int l=q[i][0],r=q[i][1];\\n            int curr=pre[r];\\n            if(l>0)\\n                curr-=pre[l-1];\\n            res[i]=curr;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c){\\n        return (c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\');\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& q) {\\n        //use prefix sum concept to get number of words in certain range\\n        //add 1 if word starts and ends with vowel\\n        vector<int> pre(words.size(),0);\\n        for(int i=0;i<words.size();i++)\\n        {\\n            int len=words[i].size();\\n            if(isVowel(words[i][0]) && isVowel(words[i][len-1]))\\n            {\\n                pre[i]=1;\\n            }\\n            if(i>0)\\n                pre[i]+=pre[i-1];\\n        }\\n        vector<int> res(q.size());\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int l=q[i][0],r=q[i][1];\\n            int curr=pre[r];\\n            if(l>0)\\n                curr-=pre[l-1];\\n            res[i]=curr;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178450,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func vowelStrings(_ w: [String], _ q: [[Int]]) -> [Int] {\\n        q.reduce(into: ([Int](), w.reduce(into:[0]) {$0.append($0.last! + ((\"aeiou\".contains($1.first!) && \"aeiou\".contains($1.last!)) ? 1:0))})) {$0.0.append($0.1[$1[1]+1]-$0.1[$1[0]])}.0\\n    }\\n}\\n```\\n\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func vowelStrings(_ words: [String], _ queries: [[Int]]) -> [Int] {\\n        queries.reduce(into: (\\n            result: [Int](), \\n            prefixSums: // calculated once at beginning of `reduce`. Read-only thereafter.\\n\\t\\t\\t\\twords.reduce(into: [0]) { prefixSums, word in\\n                    prefixSums.append(\\n\\t\\t\\t\\t\\t\\tprefixSums.last! + \\n\\t\\t\\t\\t\\t\\t((\"aeiou\".contains(word.first!) && \"aeiou\".contains(word.last!)) ? 1 : 0)\\n\\t\\t\\t\\t\\t)\\n                 }\\n        )) { data, query in\\n            data.result.append(data.prefixSums[query[1]+1] - data.prefixSums[query[0]])\\n        }.result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func vowelStrings(_ w: [String], _ q: [[Int]]) -> [Int] {\\n        q.reduce(into: ([Int](), w.reduce(into:[0]) {$0.append($0.last! + ((\"aeiou\".contains($1.first!) && \"aeiou\".contains($1.last!)) ? 1:0))})) {$0.0.append($0.1[$1[1]+1]-$0.1[$1[0]])}.0\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func vowelStrings(_ words: [String], _ queries: [[Int]]) -> [Int] {\\n        queries.reduce(into: (\\n            result: [Int](), \\n            prefixSums: // calculated once at beginning of `reduce`. Read-only thereafter.\\n\\t\\t\\t\\twords.reduce(into: [0]) { prefixSums, word in\\n                    prefixSums.append(\\n\\t\\t\\t\\t\\t\\tprefixSums.last! + \\n\\t\\t\\t\\t\\t\\t((\"aeiou\".contains(word.first!) && \"aeiou\".contains(word.last!)) ? 1 : 0)\\n\\t\\t\\t\\t\\t)\\n                 }\\n        )) { data, query in\\n            data.result.append(data.prefixSums[query[1]+1] - data.prefixSums[query[0]])\\n        }.result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176054,
                "title": "java-solution-using-prefix-sum",
                "content": "pre\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int prefix[]=new int[words.length];\\n        HashSet<Character> list=new HashSet<>();\\n        list.add(\\'a\\');\\n        list.add(\\'e\\');\\n        list.add(\\'i\\');\\n        list.add(\\'o\\');\\n        list.add(\\'u\\');\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(list.contains(words[i].charAt(0)) && list.contains(words[i].charAt(words[i].length()-1)))\\n            {\\n                if(i!=0)\\n                    prefix[i]=prefix[i-1]+1;\\n                else\\n                    prefix[i]=1;\\n            }\\n            else if(i!=0)\\n             prefix[i]=prefix[i-1];\\n        }\\n        int ans[]=new int[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int left=queries[i][0];\\n            int right=queries[i][1];\\n            if(left!=0 && right!=0)\\n            {\\n                ans[i]=prefix[right]-prefix[left]+(prefix[left]-prefix[left-1]);\\n            }\\n            else\\n            {\\n                ans[i]=prefix[right];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[] vowelStrings(String[] words, int[][] queries) {\\n        int prefix[]=new int[words.length];\\n        HashSet<Character> list=new HashSet<>();\\n        list.add(\\'a\\');\\n        list.add(\\'e\\');\\n        list.add(\\'i\\');\\n        list.add(\\'o\\');\\n        list.add(\\'u\\');\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(list.contains(words[i].charAt(0)) && list.contains(words[i].charAt(words[i].length()-1)))\\n            {\\n                if(i!=0)\\n                    prefix[i]=prefix[i-1]+1;\\n                else\\n                    prefix[i]=1;\\n            }\\n            else if(i!=0)\\n             prefix[i]=prefix[i-1];\\n        }\\n        int ans[]=new int[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int left=queries[i][0];\\n            int right=queries[i][1];\\n            if(left!=0 && right!=0)\\n            {\\n                ans[i]=prefix[right]-prefix[left]+(prefix[left]-prefix[left-1]);\\n            }\\n            else\\n            {\\n                ans[i]=prefix[right];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1788357,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1837860,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1788398,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1789586,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1789573,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1803872,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1799641,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1790904,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1790494,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1789600,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1788357,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1837860,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1788398,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1789586,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1789573,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1803872,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1799641,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1790904,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1790494,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            },
            {
                "id": 1789600,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "Whoever writes theses questions please can you keep it simple, it\\'s so hard to understand the question."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Yeah It is easier to misunderstand the question \\uD83D\\uDE05"
                    },
                    {
                        "username": "rdforte",
                        "content": "100% agree"
                    },
                    {
                        "username": "Dastagir_Mulani_101",
                        "content": "The Person who have written the Last Testcase deserves the Salute, for dedicatedly designing such a long testcase\\uD83D\\uDE04\\uD83D\\uDE06\\uD83D\\uDE02"
                    },
                    {
                        "username": "rdforte",
                        "content": "can someone please explain to me what this question is asking?"
                    },
                    {
                        "username": "rdforte",
                        "content": "[@imprayas12](/imprayas12) legend thanks for the explanation!"
                    },
                    {
                        "username": "imprayas12",
                        "content": "We are given queries. In each query there\\'s a left and right index given, We have to count the number of strings in \"words\" array between those two indices which start and end with a vowel alphabet. Answer for each query will be stored in the answer array, on same index as current query.\\nEg: \\nquery[i]  = {{1,2},{2,4}}\\nwords = {asterik,five,one,three,ioe}\\nans = \\n{\\n{1 -> (one)},\\n{2 ->(one,ioe)}\\n}\\n\\nYou can have a look at my solution for more clear idea.\\n\\nhttps://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3143934/java-prefix-sum-hashmap/"
                    },
                    {
                        "username": "S_Basu",
                        "content": "##### Related Concepts/ Topics :\n- **Prefix Sum**\n- *String*\n- *Array*"
                    },
                    {
                        "username": "ejscfj",
                        "content": "I got this exact question as part of the Workday OA that I did this week. Guessing someone got their inspiration from that lol. "
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "92/93 testcases passed\\n\\nvowels_list= \"aeiou\"\\n        res= []\\n        for i in range(len(queries)):\\n            l= queries[i][0]\\n            r= queries[i][1]\\n            count= 0\\n            for j in range(l, r+1):\\n                word= words[j]\\n                if (word[0] in vowels_list) and (word[-1] in vowels_list):\\n                    count+= 1\\n            res.append(count)\\n        return (res)\\n\\nit shows time limit exceeded,\\n\\n[\"jt\",\"fvd\",\"blef\",\"rhd\",\"d\",\"vp\",\"ghag\",\"xpx\",\"j\",\"kw\",\"ye\",\"d\",\"bt\",\"l\",\"d\",\"df\",\"erqb\",\"dh\",\"hns\",\"dkx\",\"j\",\"a\",\"mhas\",\"n\",\"q\",\"e\",\"lu\",\"t\",\"du\",\"cc\",\"r\",\"e\",\"lrvw\",\"p\",\"dohz\",\"ax\",\"lm\",\"ft\",\"lwg\",\"sli\",\"m\",\"fm\",\"skm\",\"wly\",\"c\",\"cc\",\"x\",\"doay\",\"copp\",\"sy\",\"v\",\"ysw\",\"rz\",\"j\",\"q\",\"cng\",\"lha\",\"ihn\",\"lcpq\",\"b\",\"rndz\",\"lqb\",\"ep\",\"d\",\"gyvj\",\"ykm\",\"xxn\",\"olkp\",\"xx\",\"dkb\",\"hyf\",\"nucx\",\"ggdh\",\"k\",\"j\",\"g\",\"vex\",\"f\",\"tiy\",\"fts\"........\\n\\nlet me know the changes in my code please.?"
                    },
                    {
                        "username": "JustBored",
                        "content": "the TC for your solution is too inefficient if you don't use prefix sum"
                    },
                    {
                        "username": "francolai",
                        "content": "Brute forcing is too inefficient. Think of a way so that we don\\'t have to revisit indices that have been visited.\\nFor example query1 = [1, 4], query2 = [3, 5]. We have already went through index 3, 4 in query1 we don\\'t want to go through those indices again for query2."
                    },
                    {
                        "username": "randuladela",
                        "content": "for me as well bro ,Last test case didnt pass "
                    },
                    {
                        "username": "komal_tater",
                        "content": "Why do we use the concept of prefix sum here? How to look at the question and understand this ?"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "because iterating in range for each query may take linear time and for q queries we might end up getting tle \\nso preffix array is used here we find till r how many such word exist - till l-1 such word exist\\n\\nso it is a genral intution \\nlet\\'s suppose you are going on a long path and you are asked about a previous location that how much distant from your current location what you would prefeer to do is to substract distance of asked location from beginning to the current distance \\n\\ngot the idea ....\\n"
                    },
                    {
                        "username": "user4851h",
                        "content": " ` class Solution {\\npublic:\\n    bool check(string word){\\n        if(word[0]==word[word.length()-1] && (word[0]==\\'a\\'||word[0]==\\'e\\'||word[0]==\\'i\\'||word[0]==\\'o\\'||word[0]==\\'u\\')) return true;\\n        return false;\\n    }\\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n        int n=words.size(),c=check(words[0])?1:0;\\n        vector<int> prefix(n,0);\\n        prefix[0]=c;\\n        for(int i=1;i<n;i++){\\n            if(check(words[i])) c++;\\n            prefix[i]=c;\\n        }\\n        \\n        vector<int> res;\\n        for(auto it:queries){\\n            if(it[0]==0) res.push_back(prefix[it[1]]);\\n            else res.push_back(prefix[it[1]]-prefix[it[0]-1]);\\n        }return res;\\n    }\\n}; `\\n\\n\\n\\n\\nIts not accepting my Solution.Can anyone help?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Improves a reading skill**"
                    },
                    {
                        "username": "S_Basu",
                        "content": "After using Prefix Sum it was **Accepted** \nPreviously I made a submission that was just counting the number of \"Vowel Strings\" for each given range i.e. without using Prefix Sum, but it was giving **Time Limit Exceeded** \n## [Accepted JAVA Solution](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/3147605/easy-java-solution-beats100/)\n"
                    },
                    {
                        "username": "ashishnethi",
                        "content": "yah true\\n"
                    }
                ]
            }
        ]
    }
]