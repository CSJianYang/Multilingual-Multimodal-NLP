[
    {
        "title": "Partitioning Into Minimum Number Of Deci-Binary Numbers",
        "question_content": "A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not.\nGiven a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n.\n&nbsp;\nExample 1:\n\nInput: n = \"32\"\nOutput: 3\nExplanation: 10 + 11 + 11 = 32\n\nExample 2:\n\nInput: n = \"82734\"\nOutput: 8\n\nExample 3:\n\nInput: n = \"27346209830709182346\"\nOutput: 9\n\n&nbsp;\nConstraints:\n\n\t1 <= n.length <= 105\n\tn consists of only digits.\n\tn does not contain any leading zeros and represents a positive integer.",
        "solutions": [
            {
                "id": 970318,
                "title": "java-c-python-just-return-max-digit",
                "content": "# Prove\\nAssume max digit in `n` is `x`.\\nBecause deci-binary only contains 0 and 1,\\nwe need at least `x` numbers to sum up a digit `x`.\\n\\nNow we contruct an answer,\\nTake n = 135 as an example,\\nwe initilize 5 deci-binary number with lengh = 3,\\na1 = 000\\na2 = 000\\na3 = 000\\na4 = 000\\na5 = 000\\n\\nFor the first digit, we fill the first `n[0]` number with 1\\nFor the second digit, we fill the first `n[1]` number with 1\\nFor the third digit, we fill the first `n[2]` number with 1\\n\\nSo we have\\na1 = 111\\na2 = 011\\na3 = 011\\na4 = 001\\na5 = 001\\n\\nFinally, we have 111+11+11+1+1=135.\\n<br>\\n\\n# Complexity\\nTime `O(L)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int minPartitions(String n) {\\n        int res = 0;\\n        for (int i = 0; i < n.length(); ++i)\\n            res = Math.max(res, n.charAt(i) - \\'0\\');\\n        return res;\\n    }\\n```\\n**Java, 1-line**\\nall by @blackspinner\\n```java\\n    public int minPartitions(String n) {\\n        return n.chars().max().getAsInt() - \\'0\\';\\n    }\\n```\\n**C++:**\\n```cpp\\n    int minPartitions(string n) {\\n        return *max_element(begin(n), end(n)) - \\'0\\';\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def minPartitions(self, x):\\n        return int(max(x))\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minPartitions(String n) {\\n        int res = 0;\\n        for (int i = 0; i < n.length(); ++i)\\n            res = Math.max(res, n.charAt(i) - \\'0\\');\\n        return res;\\n    }\\n```\n```java\\n    public int minPartitions(String n) {\\n        return n.chars().max().getAsInt() - \\'0\\';\\n    }\\n```\n```cpp\\n    int minPartitions(string n) {\\n        return *max_element(begin(n), end(n)) - \\'0\\';\\n    }\\n```\n```py\\n    def minPartitions(self, x):\\n        return int(max(x))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2202690,
                "title": "one-main-observation-interview-tips-java-explained",
                "content": "### Logic:\\nThis question is super deceptive. At first, you might come to the conclusion that this is a DP problem similar to [Coin Change](https://leetcode.com/problems/coin-change/). However, there is a super useful trick that comes with the fact that all deci-binary numbers consist of 1\\'s and 0\\'s.\\n\\n> Note: Keep in mind in this question that <ins>deci-binary</ins> numbers are not binary numbers. As in, the deci-binary number 10 is \"ten\", not 2 (as it would be in binary). With this out of the way, let\\'s get to that observation!\\n\\n### The Main Observation:\\nLet\\'s use the string `n = \"25941\"` for our example.\\nOne way to think about this number, or any number, is that for our deci-binary numbers to sum up to `n`, each digit `d` needs to consist of exactly `d` 1\\'s. For example, our first digit is 2 which suggests that we need 2 1\\'s to make up that number.\\n\\n![image](https://assets.leetcode.com/users/images/47192914-689e-4427-8747-2686f82e39cf_1656290612.6005726.png)\\n\\nAs you can see, if we follow the above principle for all the numbers, our answer will quite simply be **the largest digit in the string**.\\nTherefore, all we\\'d need to do is loop through each character in our string and keep track of the largest digit. If we ever come across a 9, we can return 9 straight away since that would be the maximum.\\n___\\n### How could I have come up with this solution?\\nThis is definitely a question worth considering. How would one know that the solution is not a DP solution? <ins>We need to look at the question constraints and hints hidden in the description of the question</ins>.\\n\\nOne major hint was our input. We were given a String, not an int. The string can be really long as implied by the constraints of its length. Just from this, we can already conclude that we can\\'t just change our String to an integer. This already puts the coin change strategy out of the picture. \\n\\nAnother hint would come from the fact that the numbers only consist of 1\\'s and 0\\'s and that `n` is strictly positive. \\n\\nFrom here, it\\'s important to think about a linear solution to the question since the length of the string could be quite large. With all of these things put into consideration, you should have more than enough information to assume that there\\'s probably some trick involved in the question that\\'s specific to the description of this question. The best thing to do from here is to draw out some short yet distinct examples and try and extract out any patterns.\\n\\n> Interview tip: In an interview, you likely won\\'t be given any of these constraints straight away. This question is a really good example that demonstrates the importance of <ins>clarifying the question</ins> during an interview. Make sure you always clarify the constraints of the problem with the interviewer as well as the input and output types.\\n\\nI hope this helps!\\n___\\n### Code:\\nIf you have any questions, suggestions or improvements, feel free to let me know!\\n```java\\npublic int minPartitions(String n) {\\n\\tint max = 0;\\n\\tfor (int i=0; i<n.length(); i++) {\\n\\t\\tif (n.charAt(i) - \\'0\\' == 9) return 9;\\n\\t\\tmax = Math.max(max, (n.charAt(i) - \\'0\\'));\\n\\t}\\n\\treturn max;\\n}\\n```\\n**Time complexity:** `O(m)` where `m` is the length of the string `n`.\\n**Space complexity:** `O(1)`",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```java\\npublic int minPartitions(String n) {\\n\\tint max = 0;\\n\\tfor (int i=0; i<n.length(); i++) {\\n\\t\\tif (n.charAt(i) - \\'0\\' == 9) return 9;\\n\\t\\tmax = Math.max(max, (n.charAt(i) - \\'0\\'));\\n\\t}\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1039096,
                "title": "detailed-easiest-explanation-of-solution",
                "content": "I was trying it hard for several days , then checked out the discussion group for some hints.\\nI really got surprised by the one-liner solutions. I\\'m just providing here the detailed explanation to the solution for others to get help from it.\\n\\n**In Python**\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(n)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/ce5d9e47-fc18-4d63-9558-3f335ace4ca4_1611844240.6971185.png)\\n\\n\\n**If you find this helpful, please upvote to motivate me to do it regularly!! Thank You.**\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202648,
                "title": "c-java-python-easy-one-liner-with-explanation",
                "content": "For this one, we would just rely on simple maths.\\n> Example: **n = \"153\"**\\n> \\nNow let\\'s break down each digit with required number of ones as we can use only `0` or `1` in deci-binaries.\\n>**1** -  1 0 0 0 0   \\n>**5** -  1 1 1 1 1\\n>**3** -  1 1 1 0 0 \\n> Added zero padding to the tail to align with max number of in `n`.\\n> \\nNow if you consider each above entry as an array, you can group digits at same index to form a number. Something like this:\\n> **111 + 011 + 011 + 010 + 010 = 153**\\n> \\nSo in all you require `5` deci-binaries to form the required `153`.\\n\\nNow let\\'s take another example:\\n> **n = \"3271\"**\\n> **3** - 1 1 1 0 0 0 0\\n> **2** - 1 1 0 0 0 0 0\\n> **7** - 1 1 1 1 1 1 1 \\n> **1** - 1 0 0 0 0 0 0\\n\\nNow after grouping digits at same index:\\n> **1111 + 1110 + 1010 + 0010 + 0010 + 0010 + 0010 = 3271**\\n> \\nHere we requred `7` deci-binaries.\\n\\nNow taking both the examples into account, we can observe the minimum number of deci-binaries required to create the required `n` is the max digit in the input `n`.\\n\\nBelow is my implementation based on above observation:\\n**Python3**\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n))            \\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(n.begin(), n.end()) - \\'0\\';\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        int res = 0;\\n        for (int i = 0; i < n.length(); i++) {\\n            res = Math.max(res, n.charAt(i) - \\'0\\');\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nIf `len` is the length of the input string `n`,\\n**Time - O(len)**\\n**Space - O(1)**\\n\\n--- \\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n))            \\n```\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(n.begin(), n.end()) - \\'0\\';\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        int res = 0;\\n        for (int i = 0; i < n.length(); i++) {\\n            res = Math.max(res, n.charAt(i) - \\'0\\');\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231721,
                "title": "python-math-strict-proof-oneliner-explained",
                "content": "We asked the question: what is minimum number of deci-binary numbers we can have, so it is **example + estimate** problem. It means that for strict proof you should have two parts:\\n1. Estimation: say, that for number `n`, minimum number of parts is some number `f(n)`, that is it is impossible to make it with lesser number of parts.\\n2. Example: provide example, where we have exaclty `f(n)` parts. \\n\\nIf it was math olympiad, and you skip one of the parts, usually you will get only half of the points (it really depends of these two parts, one of the parts can be very easy and another difficult, but you for sure will lose some points). We are in programming olympiad setup, so we do not need to have strict proof here, but if it is interview you still need. So, what is our guess. We have `0` and `1` only, so let us try to proof that answer is **maximum digit** in our number.\\n\\n1. **Estimation**. Let us for simplicity consider number `9182436`, so we need to prove that it is impossible to partition it into `8` parts. Indeed, if we sum numbers with digits only `0` or `1`, then we can have digits `<=8`, so there is no way we can get our number. Similarly it will work for all other numbers.\\n2. **Example**. Let us consider again number `9182436`. Now, we need to give example, how it can be partitioned into `9` numbers, or prove that this example exists. Here the process is the following. Let us look at all digits, which are not-zero, and subtract `1` from all of them: we have `9182436 = 8071325 + 1111111`, then repeat this process: `= 7060214 + 1011111 + 1111111` and so on. How many times we need to repeat this process? Exactly `9` in fact, because each time biggest digit is reduced by `1`. Here we considered number `9182436` for more intutions, exaclty the same idea will work on all numbers.\\n\\nSo, we proved, that **maximum digit** is the correct answer. Note, that estimation and example have quite similar structure, but nevertheless you still need to provide both of them to have a strict proof. It is similar to when you need to prove that one statement is equivalent to another, you need to prove it in both sides. I think this is the reason why problem is marked medium, not easy.\\n\\n\\n#### Complexity\\nTime is just `O(n)` to find the biggest digit and space is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minPartitions(self, n):\\n        return max(int(i) for i in n)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def minPartitions(self, n):\\n        return max(int(i) for i in n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231469,
                "title": "simple-solution-w-explanation-max-digit-1-liners",
                "content": "\\u2714\\uFE0F ***Solution***\\n\\nWe can observe that since we only have deci-binary (1s and 0s) to sum up to given number `n`, we need atleast *`n[i]`* deci-binary numbers to sum up to *`n[i]`*, where `n[i]` is the ith digit of given number.\\n\\n```\\nEg. \\n1. Consider n=\"9\"\\n=> We need to add 1 for 9 times to get n\\n2. n = \"4201\"\\n=> We can add    1101\\n               + 1100\\n               + 1000 \\n               + 1000 \\n             -------\\n\\t\\t\\t     4201\\nor any other combination which doesnt matter for this quesiton to get n. \\n\\nNotice how we require atleast MAX_DIGIT number of deci-binary numbers, where MAX_DIGIT is max digit in n.\\n```\\n\\nSo, we only need to find the maximum digit in the given number `n` and that would be the minimum number of deci-binary numbers required.\\n\\n\\n\\n**C++**\\n```\\nint minPartitions(string& n) {\\n\\tint ans = 0;\\n\\tfor(auto& ch : n) ans = max(ans, ch - \\'0\\');\\n\\treturn ans;\\n\\t// or simply -\\n\\t// return *max_element(begin(n), end(n)) - \\'0\\';\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef minPartitions(self, n: str) -> int:\\n\\treturn max(n)\\n```\\n\\n---\\n\\n**JavaScript**\\n```\\nconst minPartitions = n => Math.max(...n)\\n```\\n\\n---\\n\\n**Java**\\n```\\npublic int minPartitions(String n) {\\n\\treturn n.chars().max().getAsInt() - \\'0\\';\\n}\\n```\\n\\n\\n---\\n\\n\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nEg. \\n1. Consider n=\"9\"\\n=> We need to add 1 for 9 times to get n\\n2. n = \"4201\"\\n=> We can add    1101\\n               + 1100\\n               + 1000 \\n               + 1000 \\n             -------\\n\\t\\t\\t     4201\\nor any other combination which doesnt matter for this quesiton to get n. \\n\\nNotice how we require atleast MAX_DIGIT number of deci-binary numbers, where MAX_DIGIT is max digit in n.\\n```\n```\\nint minPartitions(string& n) {\\n\\tint ans = 0;\\n\\tfor(auto& ch : n) ans = max(ans, ch - \\'0\\');\\n\\treturn ans;\\n\\t// or simply -\\n\\t// return *max_element(begin(n), end(n)) - \\'0\\';\\n}\\n```\n```\\ndef minPartitions(self, n: str) -> int:\\n\\treturn max(n)\\n```\n```\\nconst minPartitions = n => Math.max(...n)\\n```\n```\\npublic int minPartitions(String n) {\\n\\treturn n.chars().max().getAsInt() - \\'0\\';\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2202970,
                "title": "c-detailed-explained-beats-100-tc-o-n",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Explanation:**\\n\\n\\n* We need the minimum number of positive deci-binary numbers needed so that they sum up to the given number in string format.\\n* We can only use 0 and 1.\\n* So we just gave to subtract the maximum value made out of 0 and 1, and keep on doing so until the net resultant becomes 0.\\n\\n**Use this ASCII table for reference**\\n![image](https://assets.leetcode.com/users/images/d4ab5f81-9284-4fc6-9abd-66ef76658adc_1656297502.747139.gif)\\n\\n\\n\\n**Lets do a dry run and and see how it works:-**\\n```\\nGiven test_case -\\nInput: n = \"82734\"\\nOutput: 8\\n\\n\\n\\n    82734\\n(-) 11111(max value)\\n-------------\\n\\t71662\\n(-) 11111(max value)\\n-------------\\n\\t60511\\n(-) 10111(max value, as one of the positions became 0)\\n-------------\\n\\t50400\\n(-) 10100(max value, as two of the positions became 0)\\n-------------\\n\\t40300\\n(-) 10100(max value)\\n-------------\\n\\t30200\\n(-) 10100(max value)\\n-------------\\n\\t20000\\n(-) 10000(max value)\\n-------------\\n\\t10000\\n(-) 10000(max value)\\n-------------\\n\\t00000(net resultant is now 0)\\n\\nWe can observe that total no. of iterations made is 8 which is the required answer.\\nThe no. of iteration is directly proportional to the maximum value of digit in the given string.\\n```\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int len = n.length();\\n        int max_digit_in_string = 0;\\n        \\n        for(auto element : n)\\n        {\\n            // convert the string number into integer number by subtracting the ascii value.\\n            int digit = element - \\'0\\';\\n            max_digit_in_string = max(max_digit_in_string,digit);\\n        }\\n        \\n        return max_digit_in_string;\\n    }\\n};\\n```\\n\\nTC -> `O(n)`",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nGiven test_case -\\nInput: n = \"82734\"\\nOutput: 8\\n\\n\\n\\n    82734\\n(-) 11111(max value)\\n-------------\\n\\t71662\\n(-) 11111(max value)\\n-------------\\n\\t60511\\n(-) 10111(max value, as one of the positions became 0)\\n-------------\\n\\t50400\\n(-) 10100(max value, as two of the positions became 0)\\n-------------\\n\\t40300\\n(-) 10100(max value)\\n-------------\\n\\t30200\\n(-) 10100(max value)\\n-------------\\n\\t20000\\n(-) 10000(max value)\\n-------------\\n\\t10000\\n(-) 10000(max value)\\n-------------\\n\\t00000(net resultant is now 0)\\n\\nWe can observe that total no. of iterations made is 8 which is the required answer.\\nThe no. of iteration is directly proportional to the maximum value of digit in the given string.\\n```\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int len = n.length();\\n        int max_digit_in_string = 0;\\n        \\n        for(auto element : n)\\n        {\\n            // convert the string number into integer number by subtracting the ascii value.\\n            int digit = element - \\'0\\';\\n            max_digit_in_string = max(max_digit_in_string,digit);\\n        }\\n        \\n        return max_digit_in_string;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970270,
                "title": "c-python-explanation-with-image-and-example-max-digit-o-n",
                "content": "***Main moto is to find maximum digit and return its value.***\\n\\nHere we require only  ` Deci-binary numbers`  which consits of only `0 and 1`.\\nSo if we find the maximum digit from the string then it is the answer. \\nBecause:\\n.\\n**Example**\\n.\\nLets say we have number  **`1423`**\\nThen number of 1\\'s required to make `One is 1` , `Four is 4` , `Two is 2`, and `Three is 3`\\nIt is represented like this: \\n![image](https://assets.leetcode.com/users/images/5ecfed3e-0840-48c4-b1e9-a978c39fa412_1607831965.5998409.png)\\n\\nSince they have asked for minimum number of positive deci-binary numbers needed so that they sum up to n, **[ here  `n` is `1423` ]**.\\nSo from above image we can say that \\n```\\n\\t1 1 1 1 \\n\\t0 1 1 1\\n \\t0 1 0 1\\n+   0 1 0 0\\n  ___________\\n\\t1 4 2 3\\n```\\n\\t\\nHence we require \\'4 minimum number of positive deci-binary numbers needed so that they sum up to 1423\\'\\nIn general we can say that the **`Maximum Digit`**` in the number represents the minimum number of positive deci-binary numbers needed so that they sum up to n\\' \\n\\n\\n**Given example in the question**\\n```\\n32\\n```\\n![image](https://assets.leetcode.com/users/images/b1cefea0-ecb3-4904-8930-571f932c0afc_1607832266.666806.png)\\nAnswer  = 3\\n\\n***C++***\\n\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        char tem = \\'0\\';\\n        for(char c:n){\\n            if(c > tem) { tem = c;}\\n        }\\n        return tem-\\'0\\';\\n    }\\n};\\n\\n```\\nOR\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n\\t\\treturn *max_element(begin(n), end(n)) - \\'0\\';\\n    }\\n};\\n\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        tem = \\'0\\'\\n        for c in n:\\n            if(c > tem):\\n                tem = c\\n        return int(tem) \\n```",
                "solutionTags": [],
                "code": "```\\n\\t1 1 1 1 \\n\\t0 1 1 1\\n \\t0 1 0 1\\n+   0 1 0 0\\n  ___________\\n\\t1 4 2 3\\n```\n```\\n32\\n```\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        char tem = \\'0\\';\\n        for(char c:n){\\n            if(c > tem) { tem = c;}\\n        }\\n        return tem-\\'0\\';\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n\\t\\treturn *max_element(begin(n), end(n)) - \\'0\\';\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        tem = \\'0\\'\\n        for c in n:\\n            if(c > tem):\\n                tem = c\\n        return int(tem) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231505,
                "title": "js-python-java-c-simple-iterative-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIf each deci-binary number has no higher than a **1** in each position, then it will take at least **x** numbers to achieve an **x** in any given position of **n**. This means that the largest character in any position in **n** will determine how many deci-binary numbers must be added together to obtain **n**.\\n\\nFor visual proof, we can think of **n** as a graph of its digits:\\n![Visual 1](https://i.imgur.com/rn13iSv.png)\\nThen we can think of a graph as a stack of numbers to be added:\\n![Visual 2](https://i.imgur.com/0CqWfzM.png)\\nThis stack must necessarily then be as tall as the largest single digit in **n**.\\n\\nWe can quite easily separate the characters of **n**, find the max, and return that number.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of the input string **n**_\\n - _**Space Complexity: O(N) or O(1)** depending on whether or not we split **n** to an array first_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 46.4MB** (beats 99% / 48%).\\n```javascript\\nconst minPartitions = n => Math.max(...n.split(\\'\\'))\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **56ms / 15.3MB** (beats 75% / 27%).\\n```python\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(n)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **3ms / 39.2MB** (beats 99% / 95%).\\n```java\\nclass Solution {\\n    public int minPartitions(String n) {\\n        char best = \\'0\\';\\n        for (char c : n.toCharArray())\\n            if (c > best) best = c;\\n        return best - \\'0\\';\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **28ms / 13.4MB** (beats 96% / 97%).\\n```c++\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        char best = \\'0\\';\\n        for (auto& c : n)\\n            if (c > best) best = c;\\n        return best - \\'0\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nconst minPartitions = n => Math.max(...n.split(\\'\\'))\\n```\n```python\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(n)\\n```\n```java\\nclass Solution {\\n    public int minPartitions(String n) {\\n        char best = \\'0\\';\\n        for (char c : n.toCharArray())\\n            if (c > best) best = c;\\n        return best - \\'0\\';\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        char best = \\'0\\';\\n        for (auto& c : n)\\n            if (c > best) best = c;\\n        return best - \\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970267,
                "title": "c-one-liner-o-n-time",
                "content": "\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\nSimply return the maximum digit in `n`.\\n\\nWe can express the `n` in this way -- turn each digit into a column of `1`s.\\n\\nFor example `n = 212301`\\n\\n```\\n2 1 2 3 0 1\\n\\n0 0 0 1 0 0\\n1 0 1 1 0 0\\n1 1 1 1 0 1\\n```\\n\\nThe rows are the deci-binary numbers we use to partition `n`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-219/problems/partitioning-into-minimum-number-of-deci-binary-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(begin(n), end(n)) - \\'0\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n2 1 2 3 0 1\\n\\n0 0 0 1 0 0\\n1 0 1 1 0 0\\n1 1 1 1 0 1\\n```\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-219/problems/partitioning-into-minimum-number-of-deci-binary-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(begin(n), end(n)) - \\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202655,
                "title": "python-c-java-return-max-digit-with-math-proof",
                "content": "**Intuition**\\nIf the largest digit in n is `max_digit`, then you need at least `max_digit` deci-binary numbers to sum up to that number. This is because you need at least `max_digit` 1\\'s to sum up to `max_digit`.\\n\\n**Proof**\\nYour interviewer will ask you to prove your solution is correct. To find the steps for how to prove this solution works, join the discord **https://discord.gg/m9MRe9ZR**.\\n\\n**Example**\\nFor `n=513`, we can have the following 5 deci-binary numbers.\\n111\\n101\\n101\\n100\\n100\\nWe have 111 + 101 + 101 + 100 + 100 = 513.\\n\\n**Implementation**\\nIterate through all the digits in `n`. Cast the characters to int and take the maximum digit.\\n\\n**Python**\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(int(digit) for digit in n)\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int max_digit = 0;\\n        for (char digit: n) {\\n            max_digit = max(max_digit, digit - \\'0\\');\\n        }\\n        return max_digit;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        return n.chars().max().getAsInt() - \\'0\\';\\n    }\\n}\\n```\\n\\n**Time Complexity**: O(length) - Looping through each character in n.\\n**Space Complexity**: O(1) - Amount of space used is independent of the input. \\n\\nBe sure to upvote if you liked this explanation!\\n\\nJoin our discord **https://discord.gg/m9MRe9ZR** for a community of people prepping for interview.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(int(digit) for digit in n)\\n```\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int max_digit = 0;\\n        for (char digit: n) {\\n            max_digit = max(max_digit, digit - \\'0\\');\\n        }\\n        return max_digit;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        return n.chars().max().getAsInt() - \\'0\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202615,
                "title": "c-java-python-1-line-code-full-explanation",
                "content": "Time Complexity : **O(N)**, Space Complexity : **O(1)**\\n\\n***Upvite if found Helpful :***\\n\\n**Intuition :**\\n\\n* A binary number may only contain 0 or 1. So deci-binary numbers are decimal numbers which contains only 0 and 1s. So when we add them they add up as decimal numbers.\\n* To\\xA0obtain a perticular digit of decimal we need only that many 1s. For example for making 7 we need 7, 1s so in turn we need minimum 7 deci-binary numbers. \\n* So we can see for making up a number we need `minimum deci-binary numbers to make the greatest digit of the number`. In all of those numbers the index at which greatest digit is present in original number will be 1. For other digits add 1 in their index in  asmany deci-binary numbers needed and then add 0 in the index for remaining numbers.\\n* So the max digit of the string (number) is the required answer. \\n\\nExample :\\n*Use desktop mode in smartphones to see example in corrent way*\\n\\n```\\nDecimal Number given :   2 5 7 0 4 6       ->  Max digit = 7\\n\\nBinary numbers needed :  1 1 1 0 1 1\\n                         1 1 1 0 1 1 \\n                           1 1 0 1 1\\n\\t\\t\\t\\t\\t\\t   1 1 0 1 1       ->  Total numbers needed = 7\\n                           1 1 0 0 1\\n                             1 0 0 1\\n                             1 0 0 0\\n```\\n\\n**Implementation :**\\n\\n**C++ :**\\n* We just need to find the max element by `*max_element(n.begin(), n.end())`\\n* Here as the digit returned will be in char format so `we substract \\'0\\' from it to make it int`.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element (n.begin(), n.end()) - \\'0\\';\\n    }\\n};\\n```\\n\\n\\n**Java :**\\n* Return the max element as `n.chars().max().getAsInt() - \\'0\\'`.\\n* `\\'0\\'` is substracted to get the max digit as `n.chars().max().getAsInt()` will give the ascii value of the max digit.\\n```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        return n.chars().max().getAsInt() - \\'0\\';\\n    }\\n}\\n```\\n\\n\\n**Python :**\\n* Just return the max digit by `max (n)`.\\n\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max (n)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nDecimal Number given :   2 5 7 0 4 6       ->  Max digit = 7\\n\\nBinary numbers needed :  1 1 1 0 1 1\\n                         1 1 1 0 1 1 \\n                           1 1 0 1 1\\n\\t\\t\\t\\t\\t\\t   1 1 0 1 1       ->  Total numbers needed = 7\\n                           1 1 0 0 1\\n                             1 0 0 1\\n                             1 0 0 0\\n```\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element (n.begin(), n.end()) - \\'0\\';\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        return n.chars().max().getAsInt() - \\'0\\';\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max (n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990360,
                "title": "python-3-detailed-explanation",
                "content": "I was trying this question for numerous days after the contest. \\n\\nFinally I decided to take few hints from the discuss section and see what I was missing. Surprisingly all I saw was 1 line solutions just returning the max element with practically no explanation. The people who provided detailed code had very less explanation.\\n\\nI am adding this explanation to help someone like me who is looking out for detailed understanding of how the one line solution `max(n)` works. \\n\\nIn order to explain this let us check out the second example from the question itself which is `n=\"82734\"`\\n\\nThe most simple reasoning to get started is the if we need minimum numbers to make a sum, we should start with adding highest numbers, which in this case is numbers started with `1`. For example, in decreasing order `111`, `110`, `101`, `100` and so on.\\n\\nLet us trace the above and see how it works:-\\n\\n82734\\n(-) 11111(max value)\\n`--------`\\n71662\\n(-) 11111(max value)\\n`--------`\\n60511\\n(-) 10111(max value, as one of the positions become 0)\\n`--------`\\n50400\\n(-) 10100(max values, as 2 of the positions become 0)\\n`-------`\\n40300\\n(-) 10100(same as prev step)\\n`-------`\\n30200\\n(-) 10100(same as prev step)\\n`-------`\\n20000\\n(-)10000(all but one positions 0)\\n`-------`\\n10000\\n(-)10000(same as prev step)\\n`------`\\n0\\n\\nHere after 8 counts the sum become hence that is the answer. In simple words, we check the max digit and that is the number of time above process runs.\\n\\n\\nBelow is the sample code I wrote to understand. Note that the code is only for demo purpose and will give TLE on submission\\n\\n\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        start = [1] * len(n)\\n        temp = [int(x) for x in n]\\n        count = 0\\n        \\n        while True:\\n            if Counter(start)[0] == len(start):\\n                return count\\n            \\n            for i in range(len(temp)):\\n                temp[i] = temp[i] - start[i]\\n                if temp[i] == 0:\\n                    start[i] = 0\\n            \\n            count += 1\\n        \\n\\t\\t```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        start = [1] * len(n)\\n        temp = [int(x) for x in n]\\n        count = 0\\n        \\n        while True:\\n            if Counter(start)[0] == len(start):\\n                return count\\n            \\n            for i in range(len(temp)):\\n                temp[i] = temp[i] - start[i]\\n                if temp[i] == 0:\\n                    start[i] = 0\\n            \\n            count += 1\\n        \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 970405,
                "title": "c-beginner-friendly-easy-understanding",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=0;\\n        for (char c: n) ans = max(c-\\'0\\',ans);\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(n.begin(),n.end()) - \\'0\\';\\n\\t}\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=0;\\n        for (char c: n) ans = max(c-\\'0\\',ans);\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(n.begin(),n.end()) - \\'0\\';\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231514,
                "title": "partitioning-into-minimum-number-of-deci-binary-numbers-js-python-java-c-easy-sol-w-expl",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIf each deci-binary number has no higher than a **1** in each position, then it will take at least **x** numbers to achieve an **x** in any given position of **n**. This means that the largest character in any position in **n** will determine how many deci-binary numbers must be added together to obtain **n**.\\n\\nFor visual proof, we can think of **n** as a graph of its digits:\\n![Visual 1](https://i.imgur.com/rn13iSv.png)\\nThen we can think of a graph as a stack of numbers to be added:\\n![Visual 2](https://i.imgur.com/0CqWfzM.png)\\nThis stack must necessarily then be as tall as the largest single digit in **n**.\\n\\nWe can quite easily separate the characters of **n**, find the max, and return that number.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of the input string **n**_\\n - _**Space Complexity: O(N) or O(1)** depending on whether or not we split **n** to an array first_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 46.4MB** (beats 99% / 48%).\\n```javascript\\nconst minPartitions = n => Math.max(...n.split(\\'\\'))\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **56ms / 15.3MB** (beats 75% / 27%).\\n```python\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(n)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **3ms / 39.2MB** (beats 99% / 95%).\\n```java\\nclass Solution {\\n    public int minPartitions(String n) {\\n        char best = \\'0\\';\\n        for (char c : n.toCharArray())\\n            if (c > best) best = c;\\n        return best - \\'0\\';\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **28ms / 13.4MB** (beats 96% / 97%).\\n```c++\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        char best = \\'0\\';\\n        for (auto& c : n)\\n            if (c > best) best = c;\\n        return best - \\'0\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst minPartitions = n => Math.max(...n.split(\\'\\'))\\n```\n```python\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(n)\\n```\n```java\\nclass Solution {\\n    public int minPartitions(String n) {\\n        char best = \\'0\\';\\n        for (char c : n.toCharArray())\\n            if (c > best) best = c;\\n        return best - \\'0\\';\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        char best = \\'0\\';\\n        for (auto& c : n)\\n            if (c > best) best = c;\\n        return best - \\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202947,
                "title": "c-easy-code-w-explanation",
                "content": "The number of deci-binary numbers we need will atleast be the largest digit of the given decimal number.Lets say a digit is 9 in the decimal number , then we need atleast 9 deci binary numbers with digit 1 so that it adds upto 9. Similarly ,lets say the number is 24 then we need atleast 4 numbers to make a 4 and 2 numbers to make a 2 .Therefore we can set the digits 0 in two numbers, 01+01+11+11 = 24\\n\\n```\\nint k = 1;\\n        for(int i=0;i<n.size();i++)k = max(k,n[i]-\\'0\\');\\n        \\n        return k;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint k = 1;\\n        for(int i=0;i<n.size();i++)k = max(k,n[i]-\\'0\\');\\n        \\n        return k;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3197624,
                "title": "simple-java-runtime-0-ms-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPartitions(String n) {\\n\\n        int max=0;\\n        for(int i=0;i<n.length();i++){\\n            if(n.charAt(i)-\\'0\\'==9)\\n                return 9;\\n            max=Math.max(max,n.charAt(i)-\\'0\\');\\n            \\n        }\\n        return max;\\n    }\\n}\\n```\\n![8873f9b1-dfa4-4d9c-bb67-1b6db9d65e35_1674992431.3815322.jpeg](https://assets.leetcode.com/users/images/ab7be274-88c6-4f25-b0e9-fc22abb28deb_1676643948.4427328.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPartitions(String n) {\\n\\n        int max=0;\\n        for(int i=0;i<n.length();i++){\\n            if(n.charAt(i)-\\'0\\'==9)\\n                return 9;\\n            max=Math.max(max,n.charAt(i)-\\'0\\');\\n            \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203359,
                "title": "c-linq",
                "content": "```\\npublic class Solution\\n{\\n    public int MinPartitions(string n) => n.Max() - \\'0\\';\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinPartitions(string n) => n.Max() - \\'0\\';\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202937,
                "title": "java-0ms-beat-100-video-explanation",
                "content": "https://www.youtube.com/watch?v=ILwiBBEzbj8",
                "solutionTags": [
                    "Java"
                ],
                "code": "https://www.youtube.com/watch?v=ILwiBBEzbj8",
                "codeTag": "Unknown"
            },
            {
                "id": 2202747,
                "title": "c-one-line",
                "content": "**Solved LIVE ON TWITCH.  Everyday 6pm PT.  Link in profile.**\\n\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(n.begin(), n.end()) - \\'0\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(n.begin(), n.end()) - \\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231988,
                "title": "theory-explained-java",
                "content": "The problem is to find minimum number of **deci-binary** numbers that sumup to given number **n**.\\n\\nConsider this as target sum problem, where you can have infinite supply of deci-binary numbers and target is **n**.\\n\\nLet\\'s try with simple case,\\n* n=7\\nnow we can use only `1` deci-binary number that is less than n, and by adding this 7 times we will have `1 * 7=7` n. so answer would be **7**\\n\\n* n=153\\nconsidering maximum deci-binary number less than n is **111**, \\nsubtracting it from **n** will be **042**.\\nnow deci-binary can be **11** only coz left most digit is 0, subtracting from n we will have **031**\\nrepeating these steps, we will have 0 after **5** operatins.\\n\\n*Now think of this way you have **k** digits in number **n** and you have to neutralize it using **1 and 0** so you can only decrease a digit by **1** at a time and if its already **0** woah that digit is neutralized. \\nSo now can we just see the maximum digit in **n** and neutralize it? coz other digits might be 0 before it.*\\n\\nThink of that using n=1563984\\nwe will have to do 9 operations coz till i got to neutrilize 9, i will have other digits at 0.\\n\\n# CODE\\n\\n```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        int max=0;\\n        for(int i=0;i<n.length();i++){\\n            int ch=n.charAt(i)-\\'0\\';\\n            max=Math.max(max,ch);\\n        }\\n        return max;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        int max=0;\\n        for(int i=0;i<n.length();i++){\\n            int ch=n.charAt(i)-\\'0\\';\\n            max=Math.max(max,ch);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213938,
                "title": "simple-cpp-code-better-than-98-time-complexity-and-99-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhighest digit in the string is number of deci-binary  numbers its gonna take\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlooping through string once to find the highest valued digit\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        std::string::iterator itr=n.begin(),temp=n.begin();\\n        while(itr!=n.end())\\n        {\\n            if(*itr>*temp)\\n                temp=itr;\\n            itr++;\\n        }\\n        return *temp-48;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        std::string::iterator itr=n.begin(),temp=n.begin();\\n        while(itr!=n.end())\\n        {\\n            if(*itr>*temp)\\n                temp=itr;\\n            itr++;\\n        }\\n        return *temp-48;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989105,
                "title": "javascript-1-line",
                "content": "first:\\n```\\nvar minPartitions = function(n) {\\n    return Math.max(...Array.from(n, x=>+x))\\n};\\n```\\nsecond:\\n```\\nvar minPartitions = function(n) {    \\n    let max=0\\n    for (let i of n) {\\n        max = max < i ? i : max\\n    }\\n    return max\\n};\\n```\\nthird:\\n```\\nvar minPartitions = function(n) {   \\n return Math.max(...n);\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvar minPartitions = function(n) {\\n    return Math.max(...Array.from(n, x=>+x))\\n};\\n```\n```\\nvar minPartitions = function(n) {    \\n    let max=0\\n    for (let i of n) {\\n        max = max < i ? i : max\\n    }\\n    return max\\n};\\n```\n```\\nvar minPartitions = function(n) {   \\n return Math.max(...n);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 970276,
                "title": "1689-python-simple-solution-with-explanation",
                "content": "* We have to return the **largest digit** present in the input number n\\n* Since we are given a **string as an input** so looping each digit is possible\\n* All we have to do is loop through all digit and compare in order to get the largest digit\\n\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        \\n        ans = 0\\n        for i in n:\\n            if int(i)>ans:\\n                ans = int(i)\\n        return ans\\n```\\n\\n**EXAMPLE:**\\n\\nlet us assume n = 6402\\n\\n**decrease one number from each digit of n and place it in same index of deci-binary**\\nthen all such deci-binary numbers that will sum up to 6402 will be:\\n\\n0. 0000 (n=6402) # initial step\\n\\n1. 1101 (n=5301)\\n\\n2. 1101 (n=4200)\\n\\n3. 1100 (n=3100)\\n\\n4. 1100 (n=2000)\\n\\n5. 1000 (n=1000)\\n\\n6. 1000 (n=0000)\\n\\nIf we sum up all these numbers then it will be equal to 6402\\n\\nnotice one thing that you will have to decrease the digit that many times, i.e. if the digit is 4 then you have to decrement 4-times in order to create a number that consists nothings but zeroes and ones.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        \\n        ans = 0\\n        for i in n:\\n            if int(i)>ans:\\n                ans = int(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2509728,
                "title": "100-solution-with-explanation-and-without-a-complex-algorithm",
                "content": "*It is important to think before writing code.*\\nWe don\\'t need any algorithm to calculate the required number of binary digits. All we need is to find the **largest digit** in the string.\\n\\n```\\n100 = 100\\n// 1 minimum number\\n\\n2 = 1 + 1\\n// 2 minimum numbers\\n\\n130 = 110 + 10 + 10\\n// 3 minimum numbers\\n\\n1234 = 1111 + 111 + 11 + 1\\n// 4 minimum numbers\\n\\n142967 =\\n111111 +\\n 11111 +\\n 10111 +\\n 10111 +\\n   111 +\\n   111 +\\n   101 +\\n   100 + \\n   100\\n// 9 minimum numbers\\n```\\n\\nAnd it doesn\\'t matter how long is string\\n\\n**Please upvote if it was helpful!**\\n\\n``` Dart []\\nclass Solution {\\n  int minPartitions(String n) {\\n    // 9 is the largest digit, so if it\\'s in the string, \\n    // there\\'s no point looking any further\\n    if (n.contains(\\'9\\')) return 9;\\n\\n    int result = 0;\\n    for (int i = 0; i < n.length; i++) {\\n      result = max(result, int.parse(n[i]));\\n    }\\n    return result;\\n  }\\n}\\n```\\n``` Dart []\\nclass Solution {\\n  int minPartitions(String n) {\\n    // It works but I don\\'t like the way it looks\\n    if (n.contains(\\'9\\')) return 9;\\n    if (n.contains(\\'8\\')) return 8;\\n    if (n.contains(\\'7\\')) return 7;\\n    if (n.contains(\\'6\\')) return 6;\\n    if (n.contains(\\'5\\')) return 5;\\n    if (n.contains(\\'4\\')) return 4;\\n    if (n.contains(\\'3\\')) return 3;\\n    if (n.contains(\\'2\\')) return 2;\\n    return 1;\\n  }\\n}\\n```\\n[Submission Detail](https://leetcode.com/submissions/detail/788064461/)",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\n100 = 100\\n// 1 minimum number\\n\\n2 = 1 + 1\\n// 2 minimum numbers\\n\\n130 = 110 + 10 + 10\\n// 3 minimum numbers\\n\\n1234 = 1111 + 111 + 11 + 1\\n// 4 minimum numbers\\n\\n142967 =\\n111111 +\\n 11111 +\\n 10111 +\\n 10111 +\\n   111 +\\n   111 +\\n   101 +\\n   100 + \\n   100\\n// 9 minimum numbers\\n```\n``` Dart []\\nclass Solution {\\n  int minPartitions(String n) {\\n    // 9 is the largest digit, so if it\\'s in the string, \\n    // there\\'s no point looking any further\\n    if (n.contains(\\'9\\')) return 9;\\n\\n    int result = 0;\\n    for (int i = 0; i < n.length; i++) {\\n      result = max(result, int.parse(n[i]));\\n    }\\n    return result;\\n  }\\n}\\n```\n``` Dart []\\nclass Solution {\\n  int minPartitions(String n) {\\n    // It works but I don\\'t like the way it looks\\n    if (n.contains(\\'9\\')) return 9;\\n    if (n.contains(\\'8\\')) return 8;\\n    if (n.contains(\\'7\\')) return 7;\\n    if (n.contains(\\'6\\')) return 6;\\n    if (n.contains(\\'5\\')) return 5;\\n    if (n.contains(\\'4\\')) return 4;\\n    if (n.contains(\\'3\\')) return 3;\\n    if (n.contains(\\'2\\')) return 2;\\n    return 1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767864,
                "title": "python-3-80ms-simple-one-liner-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280640,
                "title": "c-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=0;\\n        vector<int>arr;\\n        for(int i=0;i<n.length();i++)\\n        {\\n            arr.emplace_back(n[i]-\\'0\\');\\n        }\\n        sort(arr.rbegin(),arr.rend());\\n        ans=arr[0];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=0;\\n        vector<int>arr;\\n        for(int i=0;i<n.length();i++)\\n        {\\n            arr.emplace_back(n[i]-\\'0\\');\\n        }\\n        sort(arr.rbegin(),arr.rend());\\n        ans=arr[0];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203417,
                "title": "partitioning-into-minimum-number-of-deci-binary-numbers-java-solution",
                "content": "**The minimum no of deci-binary numbers needed =  max digit of the number**\\ne.g, if n=4, we will have to add \\'1\\' 4 times to get 4\\n```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        \\n        if(n.length() == 0)\\n            return 0;\\n        int maxDigit = 0;\\n        if(n.length() == 1)\\n            maxDigit = Integer.parseInt(n.charAt(0)+\"\");\\n        for(int i=0;i<n.length();i++)\\n        {\\n            char ch = n.charAt(i);\\n            int dig = Integer.parseInt(ch+\"\");\\n            maxDigit = Math.max(maxDigit,dig);\\n        }\\n        return maxDigit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        \\n        if(n.length() == 0)\\n            return 0;\\n        int maxDigit = 0;\\n        if(n.length() == 1)\\n            maxDigit = Integer.parseInt(n.charAt(0)+\"\");\\n        for(int i=0;i<n.length();i++)\\n        {\\n            char ch = n.charAt(i);\\n            int dig = Integer.parseInt(ch+\"\");\\n            maxDigit = Math.max(maxDigit,dig);\\n        }\\n        return maxDigit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742554,
                "title": "c-1-liner-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(begin(n), end(n))-\\'0\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(begin(n), end(n))-\\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604785,
                "title": "c-easiest-solution-you-will-find",
                "content": "The digit which i maximum will be the answer as it will require maximum no of 1\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n      int len=n.length();\\n      char max=\\'0\\';\\n      for(int i=0;i<len;i++){\\n        if(n[i]>max)\\n          max=n[i];\\n      }\\n      max=max-48; //to change ascii value to original character\\n      return max;\\n    }\\n};\\n```\\nPlease upvote",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n      int len=n.length();\\n      char max=\\'0\\';\\n      for(int i=0;i<len;i++){\\n        if(n[i]>max)\\n          max=n[i];\\n      }\\n      max=max-48; //to change ascii value to original character\\n      return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233157,
                "title": "java-simple-and-easy-t-o-n-s-o-1-solution-4-ms-faster-than-87-04-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\nComplexity\\nTime   : O(n) where n is number of digits in number\\nSpace : O(1)\\n\\n```\\nclass Solution {\\n    public int minPartitions(String digits) {\\n        /*\\n          Approach\\n          1. Minimum Number Of Deci-Binary Numbers will be the maximum digit in the number\\n          \\n          e.g \\n          32 - > 3\\n          82734 -> 8\\n          27346209830709182346 -> 9\\n        */\\n        \\n        int maxDigit = 0;\\n        \\n        for(char digit : digits.toCharArray()){\\n            maxDigit = Math.max(maxDigit, digit - \\'0\\');\\n            \\n            if(maxDigit == 9) break;\\n        }\\n        \\n        return maxDigit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPartitions(String digits) {\\n        /*\\n          Approach\\n          1. Minimum Number Of Deci-Binary Numbers will be the maximum digit in the number\\n          \\n          e.g \\n          32 - > 3\\n          82734 -> 8\\n          27346209830709182346 -> 9\\n        */\\n        \\n        int maxDigit = 0;\\n        \\n        for(char digit : digits.toCharArray()){\\n            maxDigit = Math.max(maxDigit, digit - \\'0\\');\\n            \\n            if(maxDigit == 9) break;\\n        }\\n        \\n        return maxDigit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232285,
                "title": "c-python-math",
                "content": "Idea: math[1][[2](http://https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution/)]\\nSolution: Return the max digit in the string\\nProof: For a given string, we find the maximum number m, we create m binary strings.\\nfor each one, check each digit, if it\\u2019s greater than 0, we mark 1 at that position and decrease the digit by 1.\\n\\ne.g. 21534\\nmax is 5, we need five binary strings.\\n1: 11111: 21534 -> 10423\\n2: 10111: 10423 -> 00312\\n3: 00111: 00312 -> 00201\\n4: 00101: 00201 -> 00100\\n5: 00100: 00100 -> 00000\\n\\nWe can ignore the leading zeros.\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n\\n\\nApproach 1: C++\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(begin(n), end(n)) -\\'0\\';        \\n    }\\n};\\n```\\n\\n\\nApproach 2: Python\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n)) \\n```\\nReference:\\n[1] https://zxi.mytechroad.com/blog/math/leetcode-1689-partitioning-into-minimum-number-of-deci-binary-numbers/\\n[2] https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution/",
                "solutionTags": [
                    "Python",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(begin(n), end(n)) -\\'0\\';        \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n)) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231524,
                "title": "partitioning-into-minimum-number-of-deci-binary-numbers-4-lines-explained",
                "content": "The main idea is, It doesnot matter how big the number is, what matters is how can we reduce a position in given string to `0`. So, Our answer is just to find the maximum digit in the given string.\\n```\\nLet\\'s take a randome number, s = \"6756348\"\\nStep-1 : 6756348 - 1111111 = 5645237\\nstep- 2: 5645237 - 1111111 = 4534126\\nstep- 3: 4534126 - 1111111 = 3423015\\nstep- 4: 3423015 - 1111011 = 2312004\\nstep-5:  2312004 - 1111001 = 1201003\\nstep- 6: 1201003 - 1101001 =  100002\\nstep- 7:  100002 -  100001 =       1\\nstep- 8:       1 -       1 =       0\\n\\nTherefore, we just need maximum digit times to sum up to the given string using Deci-Binary Numbers \\n```\\n\\n**DO UPVOTE if you find it helpful!!**\\n```\\nint minPartitions(string n) {\\n        int maxi =0;\\n        for(char c:n){\\n            maxi = max(maxi, c-\\'0\\');\\n        return maxi;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nLet\\'s take a randome number, s = \"6756348\"\\nStep-1 : 6756348 - 1111111 = 5645237\\nstep- 2: 5645237 - 1111111 = 4534126\\nstep- 3: 4534126 - 1111111 = 3423015\\nstep- 4: 3423015 - 1111011 = 2312004\\nstep-5:  2312004 - 1111001 = 1201003\\nstep- 6: 1201003 - 1101001 =  100002\\nstep- 7:  100002 -  100001 =       1\\nstep- 8:       1 -       1 =       0\\n\\nTherefore, we just need maximum digit times to sum up to the given string using Deci-Binary Numbers \\n```\n```\\nint minPartitions(string n) {\\n        int maxi =0;\\n        for(char c:n){\\n            maxi = max(maxi, c-\\'0\\');\\n        return maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 970291,
                "title": "java-short-one-pass-solution",
                "content": "In order to use as less as number possible, we need to use a as large as number for each time! To use the largest number, we need to fix as many as 1 possible. \\n\\nSo if we take a try, we can find each number we use can provide us **exactly one 1**. In order to statisfy the largest digit in the string, we should use the \\n\\nSo the largest digit in the string should be the answer!\\n```\\n    public int minPartitions(String n) {\\n        int r = 0;\\n        for (int i=0; i<n.length(); i++) {\\n            r = Math.max(r, n.charAt(i) - \\'0\\');\\n        }\\n        return r;     \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minPartitions(String n) {\\n        int r = 0;\\n        for (int i=0; i<n.length(); i++) {\\n            r = Math.max(r, n.charAt(i) - \\'0\\');\\n        }\\n        return r;     \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3316325,
                "title": "python-one-line",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n\\n        return max(int(i) for i in n)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n\\n        return max(int(i) for i in n)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213935,
                "title": "simple-cpp-code-better-than-98-time-complexity-and-99-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhighest digit in the string is number of deci-binary  numbers its gonna take\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlooping through string once to find the highest valued digit\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        std::string::iterator itr=n.begin(),temp=n.begin();\\n        while(itr!=n.end())\\n        {\\n            if(*itr>*temp)\\n                temp=itr;\\n            itr++;\\n        }\\n        return *temp-48;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        std::string::iterator itr=n.begin(),temp=n.begin();\\n        while(itr!=n.end())\\n        {\\n            if(*itr>*temp)\\n                temp=itr;\\n            itr++;\\n        }\\n        return *temp-48;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137223,
                "title": "python3-beats-91-67-one-liner-self-explanatory",
                "content": "# **Note:**\\n**Check the hint given in description to understand the solution.**\\n# Code\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n))       \\n```\\n**Please upvote if you find it helpful.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n))       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663363,
                "title": "easy-understanding-c",
                "content": "class Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int m=n.size();\\n        int x=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            x=max(n[i]-\\'0\\',x);\\n        }\\n        return x;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int m=n.size();\\n        int x=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            x=max(n[i]-\\'0\\',x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2347255,
                "title": "c-1-line-code-logical-approach",
                "content": "![image](https://assets.leetcode.com/users/images/9de9ebef-f2c8-40ac-9943-ab548f92a820_1659033205.7287357.png)\\n\\n***This question is in Medium only because of the logic part and not because of the code part.***\\n\\n***Logic-> Think about if the input was only one digit. Then you need to add up as many ones as the value of this digit.If the input has multiple digits, then you can solve for each digit independently, and merge the answers to form numbers that add up to that input. Thus the answer is equal to the max digit.***\\n\\n**n==n.size()\\nT->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minPartitions(string n) {\\n\\t\\t\\treturn *max_element(n.begin(),n.end())-\\'0\\';\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minPartitions(string n) {\\n\\t\\t\\treturn *max_element(n.begin(),n.end())-\\'0\\';\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2205199,
                "title": "python3-can-t-believe-this-solution-99-faster",
                "content": "**Upvote and let others also see \\uD83D\\uDE02\\uD83D\\uDC4C\\u2764\\uFE0F**\\n.\\n\\n* By observation we can say we only have deci-binary (0, 1) to sum up to given number n, we need atleast n[i] deci-binary numbers to sum up to n[i], where n[i] is the ith digit of given number.\\n\\n*  Consider n=\"9\",  We need to add 1 for 9 times to get n so the largest number in the str will aslo be \"9\"\\n\\n* So when we pass str in our max fn it will take max char by comparing characters with ASCII Numbers, thus we get max number\\n\\n* ***Note: I can\\'t figure out why on returning the max as sring its not giving error as return type is strictly integer. If you know then please let everyone know in comments*** \\n\\n\\n.\\n***Runtime: 31 ms, faster than 99.74% of Python3** online submissions for Partitioning Into Minimum Number Of Deci-Binary Numbers. **Memory Usage: 11.7 MB, less than 93.73% of Python3** online submissions for Partitioning Into Minimum Number Of Deci-Binary Numbers.*\\n.\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int: \\n        return max(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int: \\n        return max(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204369,
                "title": "one-line-js",
                "content": "notice the pattern you will see it to\\n\\n```\\nconst minPartitions = n=> Math.max(...n);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst minPartitions = n=> Math.max(...n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2203428,
                "title": "c-simple-solution-with-explanation",
                "content": "In the question we were asked to to find the numer of deci-binary numbers that can sum up to the original number(string).\\nSo lets understand this by an example take the string 300 which can be the sum of 100 + 100 + 100 from this we understand that **number of deci-binary numbers is just the maximum number in the given string.**\\nsome more examples\\n1242 = 1000 + 0111 + 0010 + 0010 => total count = 4 === maximum digit in string\\n54632 = 11111 + 11111 + 11110 + 11100 + 10100 + 00100 => total count = 6\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        char ch;     // \\n        for(char c : n){\\n            ch = max(c,ch);\\n        }\\n        int ans = ch - \\'0\\';\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minPartitions(string n) {\\n        char ch;     // \\n        for(char c : n){\\n            ch = max(c,ch);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2203353,
                "title": "4-line-code-c-easy-to-understand",
                "content": "At first sight, it might looks like a question involving calculations or even recursive calls for the intermediate substrings formed ( atleast that\\'s what I thought first ).\\nBut, that\\'s not the case, all you need to do is **return max digit present in the string.**\\n\\nTime Complexity - **O(no. of digits)**\\nSpace Complexity - **O(1)**\\n```\\n\\tint minPartitions(string n) {\\n        int ans = 0;\\n        for(int i=0;i<n.size();i++) ans = max(ans, n[i] - \\'0\\');\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "At first sight, it might looks like a question involving calculations or even recursive calls for the intermediate substrings formed ( atleast that\\'s what I thought first ).\\nBut, that\\'s not the case, all you need to do is **return max digit present in the string.**\\n\\nTime Complexity - **O(no. of digits)**\\nSpace Complexity - **O(1)**\\n```\\n\\tint minPartitions(string n) {\\n        int ans = 0;\\n        for(int i=0;i<n.size();i++) ans = max(ans, n[i] - \\'0\\');\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1516399,
                "title": "if-you-understand-the-magic-behind-you-d-understand-that-this-question-is-a-joke",
                "content": "Let me Explain:\\nlets take a number:\\n9746218542\\n\\nnow greedily approach the problem, let\\'s keep on subtracting the biggest possible number from it: \\n\\n9746218542 - 11111111111 = 8635107431\\n8635107431 - 11111101111 = 7524006320\\n7524006320 - 1111001110  = 6413005210\\n6413005210 - 1111001110 = 5302004100\\n5302004100 - 1101001100 = 4201003000\\n4201003000 - 1101001000 = 3100002000\\n3100002000 - 1100001000 = 2000001000\\n2000001000 - 1000001000 = 1000000000 (no need to subtract anything now, because it\\'s already a decibinary number)\\n\\nNow see,  there are total of 9 steps. \\n\\nLet\\'s do one thing, try for yourself and derive the steps for: 4621854279\\nagain, this will also take 9 steps. \\n\\nAre you getting it? The total number of steps = the largest digit\\n\\n\\n```\\ndef minPartitions(self, n: str) -> int:\\n\\treturn max(n)\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\ndef minPartitions(self, n: str) -> int:\\n\\treturn max(n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1231751,
                "title": "partitioning-into-minimum-number-of-deci-binary-numbers-c-explained",
                "content": "**LOGIC:**\\nLet\\'s understand the logic with an example.\\nn = \"82734\"\\nIn my first code, maxx contains the char which is maximum and minn stores the opposite.\\nSo for this example, maxx==8 and minn==2\\nWe give the answer as maxx which is 8.\\n\\nBut how is it working??\\n\\n**Explanation:**  The optimal method for using least number of deci-binary number is to try to make a number having all digits as minn (i.e. 22222 in our case) and later if the number formed is not of all zeros or ones then we need to add some more deci-binary numbers to make this number (i.e. 22222) to a deci-binary which is ```n[0]-\\'0\\' - 1``` (i.e. 2-1 in our case) so that every char becomes one which is a deci-binary number. So, now we just need to add 1 in final answer (for remaining number 11111 in our case).\\n\\nLet us understand a bit more!\\nFor ```82734``` we first subtract numbers which make it ```22222``` which are (8-2 => maxx-minn numbers) then we subtract (2-1 => minn-1) numbers from it (in case when the resulting number in not deci-binary) and finally when a deci-bianry number formed we need to subtract that one last number (add 1 in result for subtracting 11111 from 11111).\\n\\nWhy `82734` will convert to `22222` in maxx-minn numbers?\\nTry subtracting numbers in the following way and you will get it.\\n```\\n82734 - 10111 = 72623\\n72623 - 10101 = 62522\\n62522 - 10100 = 52422\\n52422 - 10100 = 42322\\n42322 - 10100 = 32222\\n32222 - 10000 = 22222\\nwhich are 6 numbers\\n\\nI hope you get it.\\nIf not try some more examples on your own and you will get it.\\n```\\n\\nSo answer would be ``` (maxx-minn) + (minn-1) + 1``` which evaluates to ```maxx``` as final answer\\n**Code1:**\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int maxx = INT_MIN;\\n        int minn = INT_MAX;\\n        \\n        for(int i=0;i<n.length();i++)\\n        {\\n            maxx = max(maxx, n[i]-\\'0\\');\\n            minn = min(minn, n[i]-\\'0\\');\\n        }\\n        return (maxx-minn)+(minn-1)+1;\\n    }\\n};\\n\\n```\\n\\n\\nFrom the code above we can see that  (maxx-minn)+(minn-1)+1 is nothing but equal to maxx, so we do not require minn\\n**Code2:**\\n\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=INT_MIN;\\n        for(int i=0;i<n.length();i++)\\n            if(n[i]-\\'0\\'>ans)\\n                ans=n[i]-\\'0\\';\\n        return ans;\\n    }\\n};\\n```\\nDO **UPVOTE** IF YOU LIKED IT!!",
                "solutionTags": [],
                "code": "```n[0]-\\'0\\' - 1```\n```82734```\n```22222```\n```\\n82734 - 10111 = 72623\\n72623 - 10101 = 62522\\n62522 - 10100 = 52422\\n52422 - 10100 = 42322\\n42322 - 10100 = 32222\\n32222 - 10000 = 22222\\nwhich are 6 numbers\\n\\nI hope you get it.\\nIf not try some more examples on your own and you will get it.\\n```\n``` (maxx-minn) + (minn-1) + 1```\n```maxx```\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int maxx = INT_MIN;\\n        int minn = INT_MAX;\\n        \\n        for(int i=0;i<n.length();i++)\\n        {\\n            maxx = max(maxx, n[i]-\\'0\\');\\n            minn = min(minn, n[i]-\\'0\\');\\n        }\\n        return (maxx-minn)+(minn-1)+1;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=INT_MIN;\\n        for(int i=0;i<n.length();i++)\\n            if(n[i]-\\'0\\'>ans)\\n                ans=n[i]-\\'0\\';\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231489,
                "title": "partitioning-into-minimum-number-of-deci-binary-numbers-max-digit-explained",
                "content": "\\u2714\\uFE0F ***Solution***\\n\\nWe can observe that since we only have deci-binary (1s and 0s) to sum up to given number `n`, we need atleast *`n[i]`* deci-binary numbers to sum up to *`n[i]`*, where `n[i]` is the ith digit of given number.\\n\\n```\\nEg. \\n1. Consider n=\"9\"\\n=> We need to add 1 for 9 times to get n\\n2. n = \"4201\"\\n=> We can add    1101\\n               + 1100\\n               + 1000 \\n               + 1000 \\n             -------\\n\\t\\t\\t     4201\\nor any other combination which doesnt matter for this quesiton to get n. \\n\\nNotice how we require atleast MAX_DIGIT number of deci-binary numbers, where MAX_DIGIT is max digit in n.\\n```\\n\\nSo, we only need to find the maximum digit in the given number `n` and that would be the minimum number of deci-binary numbers required.\\n\\n\\n\\n**C++**\\n```\\nint minPartitions(string& n) {\\n\\tint ans = 0;\\n\\tfor(auto& ch : n) ans = max(ans, ch - \\'0\\');\\n\\treturn ans;\\n\\t// or simply -\\n\\t// return *max_element(begin(n), end(n)) - \\'0\\';\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef minPartitions(self, n: str) -> int:\\n\\treturn max(n)\\n```\\n\\n---\\n\\n**JavaScript**\\n```\\nconst minPartitions = n => Math.max(...n)\\n```\\n\\n---\\n\\n**Java**\\n```\\npublic int minPartitions(String n) {\\n\\treturn n.chars().max().getAsInt() - \\'0\\';\\n}\\n```\\n\\n\\n---\\n\\n\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nEg. \\n1. Consider n=\"9\"\\n=> We need to add 1 for 9 times to get n\\n2. n = \"4201\"\\n=> We can add    1101\\n               + 1100\\n               + 1000 \\n               + 1000 \\n             -------\\n\\t\\t\\t     4201\\nor any other combination which doesnt matter for this quesiton to get n. \\n\\nNotice how we require atleast MAX_DIGIT number of deci-binary numbers, where MAX_DIGIT is max digit in n.\\n```\n```\\nint minPartitions(string& n) {\\n\\tint ans = 0;\\n\\tfor(auto& ch : n) ans = max(ans, ch - \\'0\\');\\n\\treturn ans;\\n\\t// or simply -\\n\\t// return *max_element(begin(n), end(n)) - \\'0\\';\\n}\\n```\n```\\ndef minPartitions(self, n: str) -> int:\\n\\treturn max(n)\\n```\n```\\nconst minPartitions = n => Math.max(...n)\\n```\n```\\npublic int minPartitions(String n) {\\n\\treturn n.chars().max().getAsInt() - \\'0\\';\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1189381,
                "title": "93-72-a-perfect-example-of-why-recognizing-patterns-in-questions-is-very-important",
                "content": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(set(n))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(set(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1039964,
                "title": "2-easy-method-explain-1-line-c-code-explain-ascii-value-how-use",
                "content": "\\n    \\n /*   first  remember all ascii val     \\n**\\'0\\' => 48 \\n\\'1\\' => 49 \\n\\'2\\' => 50 \\n\\'3\\' => 51 \\n\\'4\\' => 52 \\n\\'5\\' => 53 \\n\\'6\\' => 54 \\n\\'7\\' => 55 \\n\\'8\\' => 56 \\n\\'9\\' => 57 **\\n\\n/*********************   EXPLANATION **********************/\\n   using asciii  val  in this  here  means  \\n\\t1.   ans = 51(3) - 48(0)  = 3  here   max(3,0) = 3     0 rep = 48(ascii val)\\n\\t2.   ans = 52(2) - 48(0)  = 2  here   max(2,3) = 3\\n   \\nso ans  is   3   in first case ans  same  here  to all cases  try  it  your self to dry run \\n         \\n**first approch**\\n\\n\\n```\\n   class Solution {\\n   public: \\n       int minPartitions(string n) {\\n            int answer=0;\\n           \\n           for (char c: n) answer = max(c-\\'0\\',answer);\\n           \\n           return answer;\\n       }\\n   };\\n```\\n\\n**second method**\\n\\n\\n```\\nclass Solution {\\npublic: \\n     int minPartitions(string n) {\\n            temp=0;\\n            int mx=0;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                temp=s[i]-\\'0\\';\\n                mx=max(temp, mx);\\n            }\\n              return mx;\\n            }\\n\\t   };\\n```\\n\\n\\t  \\n",
                "solutionTags": [],
                "code": "```\\n   class Solution {\\n   public: \\n       int minPartitions(string n) {\\n            int answer=0;\\n           \\n           for (char c: n) answer = max(c-\\'0\\',answer);\\n           \\n           return answer;\\n       }\\n   };\\n```\n```\\nclass Solution {\\npublic: \\n     int minPartitions(string n) {\\n            temp=0;\\n            int mx=0;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                temp=s[i]-\\'0\\';\\n                mx=max(temp, mx);\\n            }\\n              return mx;\\n            }\\n\\t   };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025071,
                "title": "c-o-n-100-runtime-detailed-explanation",
                "content": "```\\npublic class Solution {\\n    public int MinPartitions(string n) {\\n        int highest = 0;\\n        for (int i = 0; i < n.Length; i++)\\n        {\\n            highest = Math.Max(highest,n[i]-\\'0\\');\\n            //optional\\n            if(highest == 9){\\n                return highest;\\n            }\\n        }\\n        return highest;\\n    }\\n}\\n```\\n\\nWhen a specified number minus off a Deci-Binary Number, the maxium you can take off at each position is 1. So lets say we have 9921, we would want to take away -1111, which returns 8810, next -1110, being 7700, and repeat, but as you see, once a position reaches 0, we do not need to take away anymore from this position.\\n\\nWhat this means is we want to look through the string, converting each character to an integer while doing this, and finding the maxium number in the string as this will be the amount of times it takes to get to 0. E.g. 2321, would take 3 attemps, 1191, would take 9 attempts, 600 would take 6 attempts etc.\\n\\nSo implementing this in code, we can see, we go through the string and checking if the current integer at that position is higher than the highest value you have already found:\\n```\\nhighest = Math.Max(highest,n[i]-\\'0\\');\\n```\\n*highest* being the highest value you have obtained currently, and *n[i]-\\'0\\'* which converts the character to an integer form (p.s. do not do this in normal code only if you know you will always get an integer from converting it or else if a non-integer is there, the code will break easily!)\\n\\nThe next line after this (checking if the number is 9) is completely optional, this is just because the maxium amount of attempts it takes is 9 anyway, so you cannot get anymore than that. If you know you are going to have very very large numbers where a 9 is likely to be present, its very usefull to do this to cut the time down.\\n```\\nif(highest == 9){\\n    return highest;\\n}\\n```\\n\\nAt the end, we return the highest number and this will likely give 100% run-time (I found submitting it different times gave different results ranging between 95-100%)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinPartitions(string n) {\\n        int highest = 0;\\n        for (int i = 0; i < n.Length; i++)\\n        {\\n            highest = Math.Max(highest,n[i]-\\'0\\');\\n            //optional\\n            if(highest == 9){\\n                return highest;\\n            }\\n        }\\n        return highest;\\n    }\\n}\\n```\n```\\nhighest = Math.Max(highest,n[i]-\\'0\\');\\n```\n```\\nif(highest == 9){\\n    return highest;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998059,
                "title": "java-100-performant-very-easy-solution-o-n",
                "content": "Solution to this problem is obtained when we return the maximum digit in the number `n`. But the way we compute the maximum is important in terms of performance. We must avoid type conversions (or parsing) as much as possible.\\n\\nIn the solution below, `char`s are compared to find the maximum instead of comparing them after conversion to `int`s. The maximum is converted to `int` only at the end of the method.\\n\\n```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        char max = \\'0\\';\\n        for (char c : n.toCharArray()) {\\n            if (c > max) max = c;\\n        }\\n        return max - \\'0\\';\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        char max = \\'0\\';\\n        for (char c : n.toCharArray()) {\\n            if (c > max) max = c;\\n        }\\n        return max - \\'0\\';\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978723,
                "title": "rust",
                "content": "```rust\\nfn min_partitions(n: String) -> i32 {\\n        n.chars()\\n            .max()\\n            .unwrap()\\n            .to_digit(10)\\n            .unwrap() as i32\\n}\\n```\\n\\nSolution 2:\\n```rust\\nfn min_partitions(n: String) -> i32 {\\n     n.chars()\\n\\t\\t.map(|c| c.to_digit(10).unwrap() as i32)\\n\\t\\t.max()\\n\\t\\t.unwrap()  \\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nfn min_partitions(n: String) -> i32 {\\n        n.chars()\\n            .max()\\n            .unwrap()\\n            .to_digit(10)\\n            .unwrap() as i32\\n}\\n```\n```rust\\nfn min_partitions(n: String) -> i32 {\\n     n.chars()\\n\\t\\t.map(|c| c.to_digit(10).unwrap() as i32)\\n\\t\\t.max()\\n\\t\\t.unwrap()  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3487633,
                "title": "c-c-javascript-fast-and-easy-solution-explained",
                "content": "# Intuition:\\nThe maximum digit in a positive deci-binary number is 1.\\nTherefore, the minimum number of positive deci-binary numbers needed to sum up to a decimal number is equal to the maximum digit in that number.\\nWe can obtain the maximum digit in a decimal number by converting the string to a list of digits, and then taking the maximum value using the max() function.\\nFinally, we convert the maximum value to an integer and return it as the result.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n![photo_2023-05-05_10-35-44.jpg](https://assets.leetcode.com/users/images/2fd227ed-93ad-4951-8baf-a7d2e8483851_1683265122.1535394.jpeg)\\n![photo_2023-05-05_10-35-54.jpg](https://assets.leetcode.com/users/images/fe4de285-701d-4f14-8b8b-445f5b1365a4_1683265128.9528122.jpeg)\\n\\n```javascript []\\nvar minPartitions = function(n) {\\n    let maxDigit = 0;\\n  for (let i = 0; i < n.length; i++) {\\n    let digit = parseInt(n[i]);\\n    if (digit > maxDigit) {\\n      maxDigit = digit;\\n    }\\n    if (maxDigit == 9) {\\n      return 9;\\n    }\\n  }\\n  return maxDigit;\\n};\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int maxDigit = 0;\\n        for (char c : n) {\\n            maxDigit = max(maxDigit, c - \\'0\\');\\n            if (maxDigit == 9) {\\n                return 9;\\n            }\\n        }\\n        return maxDigit;\\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n    public int MinPartitions(string n) {\\n     int maxDigit = 0;\\n        foreach (char c in n) {\\n            maxDigit = Math.Max(maxDigit, c - \\'0\\');\\n            if (maxDigit == 9) {\\n                return 9;\\n            }\\n        }\\n        return maxDigit;\\n    }\\n}\\n```\\n![photo_2023-05-05_10-36-00.jpg](https://assets.leetcode.com/users/images/99fba748-e102-4d08-8094-cb5f2a1e400e_1683265134.4439325.jpeg)\\n![Vote.png](https://assets.leetcode.com/users/images/cf3800b1-e6d6-4f79-b542-0c2f7661da8f_1683265354.5707788.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "JavaScript"
                ],
                "code": "```javascript []\\nvar minPartitions = function(n) {\\n    let maxDigit = 0;\\n  for (let i = 0; i < n.length; i++) {\\n    let digit = parseInt(n[i]);\\n    if (digit > maxDigit) {\\n      maxDigit = digit;\\n    }\\n    if (maxDigit == 9) {\\n      return 9;\\n    }\\n  }\\n  return maxDigit;\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int maxDigit = 0;\\n        for (char c : n) {\\n            maxDigit = max(maxDigit, c - \\'0\\');\\n            if (maxDigit == 9) {\\n                return 9;\\n            }\\n        }\\n        return maxDigit;\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public int MinPartitions(string n) {\\n     int maxDigit = 0;\\n        foreach (char c in n) {\\n            maxDigit = Math.Max(maxDigit, c - \\'0\\');\\n            if (maxDigit == 9) {\\n                return 9;\\n            }\\n        }\\n        return maxDigit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269952,
                "title": "java-beats-82-2-one-line-solution-very-easy-approach",
                "content": "# Intuition\\nthe highest no in string n will be equal to the total partitions you will do  \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        \\n        return n.chars().max().getAsInt() -\\'0\\';\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        \\n        return n.chars().max().getAsInt() -\\'0\\';\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170699,
                "title": "99-99-faster-find-max-digit",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        char c = \\'0\\';\\n        for(auto &i: n){\\n            c = max(c,i);\\n        }\\n        return c-\\'0\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        char c = \\'0\\';\\n        for(auto &i: n){\\n            c = max(c,i);\\n        }\\n        return c-\\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682726,
                "title": "c-easy-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=INT_MIN;\\n        \\n        for(int i=0;i<n.size();i++){\\n            ans=max(ans,(n[i]-\\'0\\'));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=INT_MIN;\\n        \\n        for(int i=0;i<n.size();i++){\\n            ans=max(ans,(n[i]-\\'0\\'));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434958,
                "title": "partitioning-into-minimum-number-of-deci-binary-numbers",
                "content": "Try to express the string(number) in sum of **1\\'s.**\\nfor eg :- 32 \\na) 3:->  1 +1+1\\nb) 2 :-> 1+1\\nWe observe it has three  1\\'s in 3 and two 1\\'s in 2.\\nNow 32 can be written as:-\\n32:- 10  +  11 + 11\\n\\nNow what we observed that total number of \"minimum number of positive deci-binary \" **depends on the the maximum of the two characters** , i.e. 3.\\n\\n**Summary :-** ***The solution is pretty easy just iterate over every character of string and compare each other, the character having the largest value will be the answer you will return.***\\n\\n\\n\\n```\\nint minPartitions(string n) {\\n        int ans=0;\\n        for(int i=0 ; i<n.size();i++){\\n            ans = max(ans,n[i]-\\'0\\');\\n        }\\n        return ans;\\n    }\\n```\\n\\n***Please upvote if you understood . Thanks  :)***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minPartitions(string n) {\\n        int ans=0;\\n        for(int i=0 ; i<n.size();i++){\\n            ans = max(ans,n[i]-\\'0\\');\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2203297,
                "title": "partitioning-into-minimum-number-of-deci-binary-numbers-cpp-100-00-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int l=n.size(),ans=INT_MIN,d;\\n        for(int i=0; i<l; i++){\\n            d=n[i]-48;\\n            ans=max(ans,d);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int l=n.size(),ans=INT_MIN,d;\\n        for(int i=0; i<l; i++){\\n            d=n[i]-48;\\n            ans=max(ans,d);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203196,
                "title": "partitioning-into-minimum-number-of-deci-binary-numbers-daily-day27-2022",
                "content": "```\\n int minPartitions(string n) {\\n      #finding the largest digit present in given string , since it will require the maximum count to turn into zero.\\n        int m=0;\\n        for(auto x:n)\\n            if(x-48 > m)\\n                m=x-48;\\n        \\n        return m;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n int minPartitions(string n) {\\n      #finding the largest digit present in given string , since it will require the maximum count to turn into zero.\\n        int m=0;\\n        for(auto x:n)\\n            if(x-48 > m)\\n                m=x-48;\\n        \\n        return m;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2202801,
                "title": "c-2-lines-pain-aur-kya-bolu-what-more-to-say",
                "content": "```\\nBhot dard h bhai----------------------------------------------------->>>>>>>>>>> ( There is a lot of pain )------------------------------------------------------->>>>>>>>>>>>>>>>>>>>>\\n\\n\\n\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n      int pain=0;\\n    \\n        for(char tears: n){\\n        int curr_situation=tears-48;\\n        pain=max(curr_situation,pain);\\n        } \\n       return pain; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minPartitions(string n) {\\n      int pain=0;\\n    \\n        for(char tears: n){\\n        int curr_situation=tears-48;\\n        pain=max(curr_situation,pain);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1706568,
                "title": "python3-easiest-and-fastest-as-f",
                "content": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(n)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577753,
                "title": "java-thought-process-alongwith-sequence-observations-point",
                "content": "```\\n/ *\\n    Binary representation of every number i. (0 <= i <= N)\\n    gives us deci-binary.\\n    \\n    For example: \"0\", \"1\", \"10\", \"11\", \"100\", \"101\", \"110\", \"111\", \"1000\", etc.\\n    \\n    Let\\'s look at what is the minimum number of deci-binary required\\n    for different values of N.\\n    \\n    NOTE: N doesn\\'t contains any leading zeros.\\n    \\n    N       Deci-Binaries               Minimum Count\\n    1           {\"1\"}                         1\\n    2         {\"1\", \"1\"}                      2   \\n    3         {\"1\", \"1\", \"1\"}                 3\\n    ..          ..                            ..\\n    ..          ..                            ..\\n    9          {\"1\", \"1\", \"1\", ..9 1\\'s}        9\\n    10         {\"10\"}                          1\\n    11         {\"11\"}                          1\\n    12         {\"11\", \"1\"}                     2\\n    13         {\"11\", \"1\", \"1\"}                3\\n    14         {\"11\", \"1\", \"1\", \"1\"}           4\\n    ...\\n    ..\\n    20         {\"10\", \"10\"}                    2\\n    21         {\"11\", \"10\"}                    2\\n    22         {\"11\", \"11\"}                    2\\n    23         {\"11\", \"11\", \"1\"}               3\\n    ..\\n    ..\\n    29         {\"11\", \"11\", .. 7 1\\'s}          9\\n    30         {\"10\", \"10\", \"10\"}              3\\n    31-33      {\"10/11\", \"11\", \"10/11\"}        3\\n    \\n    \\n    Conclusions:\\n    -----------\\n    \\n        Let\\'s say : minCount(String n) -> returns minimum number of deci-binaries\\n        required so that they sum up to n.\\n    \\n        We can conclude some points from above sequence.\\n        \\n        1. When number of digits in given N is 1. (like: N = d1(single digit))\\n           our optimal answer would be: N\\n        \\n        2. When number of digits in given N is more than 1. (like: N = d1d2d3..dN(last digit in N))\\n           our optimal answer would be maximum of\\n           max(minCount(d1), minCount(d2), minCount(d3), ..........., minCount(dN))\\n           \\n           From the first point we can see that the digit which is the largest one has\\n           maximum number of deci-binaries.\\n           \\n           so therefore, among d1d2d3d3...dN digits. Digit with maximum value is our answer  \\n*/\\nclass Solution {\\n    public int minPartitions(String n) {\\n        int length = n.length(), maxDigit = 0;\\n        for(int i = 0; i < length; i += 1) {\\n            int digit = n.charAt(i) - \\'0\\';\\n            if(digit == 9) return digit;\\n            maxDigit = Math.max(digit, maxDigit);\\n        }\\n        return maxDigit;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/ *\\n    Binary representation of every number i. (0 <= i <= N)\\n    gives us deci-binary.\\n    \\n    For example: \"0\", \"1\", \"10\", \"11\", \"100\", \"101\", \"110\", \"111\", \"1000\", etc.\\n    \\n    Let\\'s look at what is the minimum number of deci-binary required\\n    for different values of N.\\n    \\n    NOTE: N doesn\\'t contains any leading zeros.\\n    \\n    N       Deci-Binaries               Minimum Count\\n    1           {\"1\"}                         1\\n    2         {\"1\", \"1\"}                      2   \\n    3         {\"1\", \"1\", \"1\"}                 3\\n    ..          ..                            ..\\n    ..          ..                            ..\\n    9          {\"1\", \"1\", \"1\", ..9 1\\'s}        9\\n    10         {\"10\"}                          1\\n    11         {\"11\"}                          1\\n    12         {\"11\", \"1\"}                     2\\n    13         {\"11\", \"1\", \"1\"}                3\\n    14         {\"11\", \"1\", \"1\", \"1\"}           4\\n    ...\\n    ..\\n    20         {\"10\", \"10\"}                    2\\n    21         {\"11\", \"10\"}                    2\\n    22         {\"11\", \"11\"}                    2\\n    23         {\"11\", \"11\", \"1\"}               3\\n    ..\\n    ..\\n    29         {\"11\", \"11\", .. 7 1\\'s}          9\\n    30         {\"10\", \"10\", \"10\"}              3\\n    31-33      {\"10/11\", \"11\", \"10/11\"}        3\\n    \\n    \\n    Conclusions:\\n    -----------\\n    \\n        Let\\'s say : minCount(String n) -> returns minimum number of deci-binaries\\n        required so that they sum up to n.\\n    \\n        We can conclude some points from above sequence.\\n        \\n        1. When number of digits in given N is 1. (like: N = d1(single digit))\\n           our optimal answer would be: N\\n        \\n        2. When number of digits in given N is more than 1. (like: N = d1d2d3..dN(last digit in N))\\n           our optimal answer would be maximum of\\n           max(minCount(d1), minCount(d2), minCount(d3), ..........., minCount(dN))\\n           \\n           From the first point we can see that the digit which is the largest one has\\n           maximum number of deci-binaries.\\n           \\n           so therefore, among d1d2d3d3...dN digits. Digit with maximum value is our answer  \\n*/\\nclass Solution {\\n    public int minPartitions(String n) {\\n        int length = n.length(), maxDigit = 0;\\n        for(int i = 0; i < length; i += 1) {\\n            int digit = n.charAt(i) - \\'0\\';\\n            if(digit == 9) return digit;\\n            maxDigit = Math.max(digit, maxDigit);\\n        }\\n        return maxDigit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482158,
                "title": "javascript-solution-one-line-80-48-96ms",
                "content": "*\"A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros.\"*\\n\\nThis lets us know that we can only use numbers that have 0 or 1 as their digits to find a sum for `n` using the least amount of numbers possible (example: 1, 10, 101). Since we can only increase each digit by 1, this leaves us with the task of finding the digit with the largest number and adding our way up to it with 1\\'s. \\n\\nexample: `n = 4`: \\n- since we can only increase by 0 or 1, the least amount of numbers used to solve this will be 4 \\n\\t- 1 + 1 + 1 + 1 = 4. \\n\\nexample: `n = 341`: \\n- In this example we must use 3 triple-digit numbers that will satisfy 300, 4 double-digit numbers that will satisfy 40, and 1 single-digit number that will satisfy 1.\\n\\t- 100 + 100 + 100 + 10 + 10 + 10 + 10 + 1 = 341\\n- We can simplify this solution by adding some of the numbers together without increasing any digits to greater than 1.\\n\\t- 111 + 110 + 110 + 10 = 341.\\n\\t- ![image](https://assets.leetcode.com/users/images/8edb8e77-10e5-4404-a425-354f75e5fe45_1632445799.7555642.png)\\n\\n\\nThese examples lead us to 1 solution: Find the digit with the largest number within `n`. To do so, we can simply run one line of code `Math.max(...n.split(\\'\\'))`. \\n- `n.split(\\'\\')` will seperate each digit from `n` into an array\\n- `...n` will spread the array setting it up for the next method\\n- `Math.max()` will return the largest number within the array giving us our answer\\n\\n**Solution:**\\n```\\nvar minPartitions = (n) => Math.max(...n.split(\\'\\'))\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minPartitions = (n) => Math.max(...n.split(\\'\\'))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1397665,
                "title": "just-two-words-explained",
                "content": "Deci- Binary numbers contain only 1s and 0s\\nYou need to substract 1s from any digit by its same number of time to bring it till zero.\\nExample :\\n\\n1. 1 digit no:\\n\\t3-> 3\\n\\t\\t-  1\\n\\t\\t-  1\\n\\t\\t-  1\\n\\t\\t-----\\n\\t\\t   0\\n\\tso total number of binary numbers needed to sum up three are = 1+1+1 =3\\n\\t\\n2. 2 digit number\\n\\t\\t   45\\n\\t\\t- 11\\n\\t\\t- 11\\n\\t\\t- 11\\n\\t\\t- 11\\n\\t\\t- 01\\n\\tTotal numbers needed (5) = 11 + 11 + 11 + 11 + 01 = 45\\n\\t\\nKeep in mind, your  goal is to bring each digit of number to zero. if it reaches to zero, leave it. It will be preceeded by 0 in next number. (as we did 01 in last example)\\nSo the maximum number of times you need to subtract \\'one\\' from any digit is the same number,\\nHence, the max of digit will be the answer.\\n\\n\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(n)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Deci- Binary numbers contain only 1s and 0s\\nYou need to substract 1s from any digit by its same number of time to bring it till zero.\\nExample :\\n\\n1. 1 digit no:\\n\\t3-> 3\\n\\t\\t-  1\\n\\t\\t-  1\\n\\t\\t-  1\\n\\t\\t-----\\n\\t\\t   0\\n\\tso total number of binary numbers needed to sum up three are = 1+1+1 =3\\n\\t\\n2. 2 digit number\\n\\t\\t   45\\n\\t\\t- 11\\n\\t\\t- 11\\n\\t\\t- 11\\n\\t\\t- 11\\n\\t\\t- 01\\n\\tTotal numbers needed (5) = 11 + 11 + 11 + 11 + 01 = 45\\n\\t\\nKeep in mind, your  goal is to bring each digit of number to zero. if it reaches to zero, leave it. It will be preceeded by 0 in next number. (as we did 01 in last example)\\nSo the maximum number of times you need to subtract \\'one\\' from any digit is the same number,\\nHence, the max of digit will be the answer.\\n\\n\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(n)",
                "codeTag": "Java"
            },
            {
                "id": 1259429,
                "title": "python-1line",
                "content": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232938,
                "title": "c-solution",
                "content": "We know that in deciBinary numbers we can have only 0 and 1.\\nConsider the following example\\nn= 345\\nApproch: Pick the maximum number out of n.\\nx=5 //Maximum of n\\nNow we have 5 deciBinary number initally 0 with length 3\\ndeciBinary1 =000\\ndeciBinary2 =000\\ndeciBinary3=000\\ndeciBinary4=000\\ndeciBinary5=000\\n\\nNow to find the deciBinary numbers\\nWe have 345, \\nmake the 0th column of first 3 deciBinary numbers 1 as n[0] = 3\\nmake the 1st column of first 4 deciBinary numbers  1 as n[1] = 4\\nmake the 2nd column of 5 deciBinary numbers 1 as n[2] = 5\\n\\ndeciBinary1 =    1     1    1\\ndeciBinary2 =    1     1    1\\ndeciBinary3=     1     1    1\\ndeciBinary4=     0     1    1\\ndeciBinary5=     0     0    1\\n\\nAdding all ones column wise\\nAddition result: 3     4     5\\n\\t\\t\\t\\nSo the output is 5\\nAs it is the maximum of n.\\n\\nC++ code:\\n\\nint minPartitions(string n) {\\n        char temp=\\'0\\';\\n        for(char c:n)\\n            if(c>temp){ temp=c; }\\n        return temp-\\'0\\';\\n    }\\n\\tOR\\n\\tJust return this line\\n\\treturn *max_element(begin(n), end(n)) - \\'0\\';",
                "solutionTags": [
                    "C"
                ],
                "code": "We know that in deciBinary numbers we can have only 0 and 1.\\nConsider the following example\\nn= 345\\nApproch: Pick the maximum number out of n.\\nx=5 //Maximum of n\\nNow we have 5 deciBinary number initally 0 with length 3\\ndeciBinary1 =000\\ndeciBinary2 =000\\ndeciBinary3=000\\ndeciBinary4=000\\ndeciBinary5=000\\n\\nNow to find the deciBinary numbers\\nWe have 345, \\nmake the 0th column of first 3 deciBinary numbers 1 as n[0] = 3\\nmake the 1st column of first 4 deciBinary numbers  1 as n[1] = 4\\nmake the 2nd column of 5 deciBinary numbers 1 as n[2] = 5\\n\\ndeciBinary1 =    1     1    1\\ndeciBinary2 =    1     1    1\\ndeciBinary3=     1     1    1\\ndeciBinary4=     0     1    1\\ndeciBinary5=     0     0    1\\n\\nAdding all ones column wise\\nAddition result: 3     4     5\\n\\t\\t\\t\\nSo the output is 5\\nAs it is the maximum of n.\\n\\nC++ code:\\n\\nint minPartitions(string n) {\\n        char temp=\\'0\\';\\n        for(char c:n)\\n            if(c>temp){ temp=c; }\\n        return temp-\\'0\\';\\n    }\\n\\tOR\\n\\tJust return this line\\n\\treturn *max_element(begin(n), end(n)) - \\'0\\';",
                "codeTag": "Unknown"
            },
            {
                "id": 1232508,
                "title": "95-faster-c-solution",
                "content": "*Largest digit in the string will be the output\\nFor example : Input n = \"31467\"\\nOutput : 7 \\n*\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(n.begin(), n.end()) - \\'0\\';\\n    }\\n}; \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(n.begin(), n.end()) - \\'0\\';\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231467,
                "title": "c-simplest-one-liner-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(n.begin(), n.end()) - \\'0\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(n.begin(), n.end()) - \\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144564,
                "title": "4-solutions-simple-easy-to-understand-recursive-iterative-python",
                "content": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        self.mem = {}\\n        return self.oneLiner(n)\\n    \\n    def oneLiner(self, target):\\n        return max([int(i) for i in target])\\n    \\n    def recursiveAfterLookingAtHint(self, target):\\n        if len(target) == 1: return int(target)\\n        elif target == \"\": return float(\"-inf\")\\n        return max(\\n            self.recursiveAfterLookingAtHint(target[:len(target)//2]),\\n            self.recursiveAfterLookingAtHint(target[len(target)//2:])\\n        )\\n    \\n    # No difference because it\\'s a tail recursion :(\\n    def recursiveWithMemo(self, target):\\n        if target == \"0\": return 0\\n        elif target in self.mem: return self.mem[target]\\n        elif target < \"0\": return float(\"inf\")\\n        val = \"\"\\n        for ch in target:\\n            if int(ch) >= 1: val += \"1\"\\n            else: val += \"0\"\\n        self.mem[target] = 1 + self.recursiveWithMemo(str(int(target) - int(val)))\\n        return self.mem[target]\\n    \\n    def recursiveWithoutMemo(self, target):\\n        if target == \"0\": return 0\\n        elif target < \"0\": return float(\"inf\")\\n        val = \"\"\\n        for ch in target:\\n            if int(ch) >= 1: val += \"1\"\\n            else: val += \"0\"\\n        return 1 + self.recursiveWithoutMemo(str(int(target) - int(val)))\\n        \\n        \\n        \\n        \\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        self.mem = {}\\n        return self.oneLiner(n)\\n    \\n    def oneLiner(self, target):\\n        return max([int(i) for i in target])\\n    \\n    def recursiveAfterLookingAtHint(self, target):\\n        if len(target) == 1: return int(target)\\n        elif target == \"\": return float(\"-inf\")\\n        return max(\\n            self.recursiveAfterLookingAtHint(target[:len(target)//2]),\\n            self.recursiveAfterLookingAtHint(target[len(target)//2:])\\n        )\\n    \\n    # No difference because it\\'s a tail recursion :(\\n    def recursiveWithMemo(self, target):\\n        if target == \"0\": return 0\\n        elif target in self.mem: return self.mem[target]\\n        elif target < \"0\": return float(\"inf\")\\n        val = \"\"\\n        for ch in target:\\n            if int(ch) >= 1: val += \"1\"\\n            else: val += \"0\"\\n        self.mem[target] = 1 + self.recursiveWithMemo(str(int(target) - int(val)))\\n        return self.mem[target]\\n    \\n    def recursiveWithoutMemo(self, target):\\n        if target == \"0\": return 0\\n        elif target < \"0\": return float(\"inf\")\\n        val = \"\"\\n        for ch in target:\\n            if int(ch) >= 1: val += \"1\"\\n            else: val += \"0\"\\n        return 1 + self.recursiveWithoutMemo(str(int(target) - int(val)))\\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075311,
                "title": "rust-one-liner",
                "content": "```rust\\npub fn min_partitions(n: String) -> i32 {\\n    *n.as_bytes().iter().max().unwrap() as i32 - 48\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn min_partitions(n: String) -> i32 {\\n    *n.as_bytes().iter().max().unwrap() as i32 - 48\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1067534,
                "title": "c-1-liner-o-n",
                "content": "```\\nreturn n.Max() - \\'0\\';",
                "solutionTags": [],
                "code": "```\\nreturn n.Max() - \\'0\\';",
                "codeTag": "Unknown"
            },
            {
                "id": 992026,
                "title": "java-o-lg-n-solution",
                "content": "```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        int max = 0;\\n        for (char c: n.toCharArray())max=Math.max(max,c-48);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        int max = 0;\\n        for (char c: n.toCharArray())max=Math.max(max,c-48);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 985410,
                "title": "one-line-javascript-solution-o-n-time-complexity",
                "content": "```\\nvar minPartitions = function(n) {\\n    return Math.max(...n);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minPartitions = function(n) {\\n    return Math.max(...n);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 976689,
                "title": "java-3-lines-of-code-beats-98-08",
                "content": "memory usage beats 76.66 % of java submissions.\\nruntime beats 98.08 % of java submissions.\\n\\n```\\npublic int minPartitions(String n) {\\n\\tint max =\\'0\\';\\n\\tfor(char c : n.toCharArray()) max = Math.max(max,c); \\n\\treturn max-\\'0\\';\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minPartitions(String n) {\\n\\tint max =\\'0\\';\\n\\tfor(char c : n.toCharArray()) max = Math.max(max,c); \\n\\treturn max-\\'0\\';\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 972542,
                "title": "why-is-this-medium",
                "content": "I thought I was missing something but this was actually the solution. I feel like the difficulty level should be easy instead.\\n\\nRun-time is `O(N)`, space is `O(1)`. \\n\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *std::max_element(n.begin(), n.end())-\\'0\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *std::max_element(n.begin(), n.end())-\\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970328,
                "title": "java-3-liner",
                "content": "```\\npublic int minPartitions(String n) {\\n\\tint result = 0;\\n\\tfor(char c: n.toCharArray()) result = Math.max(result, (c-\\'0\\'));\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minPartitions(String n) {\\n\\tint result = 0;\\n\\tfor(char c: n.toCharArray()) result = Math.max(result, (c-\\'0\\'));\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3562949,
                "title": "c-1-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI simply need to find the largest digit in the string\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach utilizes the max_element function to find the maximum character (digit) in the string n. Since the characters represent ASCII values, subtracting 48 (the ASCII value of \\'0\\') gives the actual numeric value of the digit.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n    auto ans = std::max_element(n.begin(), n.end()); return *ans-48;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n    auto ans = std::max_element(n.begin(), n.end()); return *ans-48;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396511,
                "title": "python3-easy-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$, where n is the length of the input string n.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219273,
                "title": "easiest-3-line-code-in-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        sort(n.begin(),n.end());\\n        int ans=n[n.size()-1]-\\'0\\';\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        sort(n.begin(),n.end());\\n        int ans=n[n.size()-1]-\\'0\\';\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103946,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=0;\\n        for(auto i:n){\\n            int number=i-48;\\n            ans=max(ans,number);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=0;\\n        for(auto i:n){\\n            int number=i-48;\\n            ans=max(ans,number);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070361,
                "title": "c-probably-most-easiest-one",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        auto mx=0;\\n        for(auto i:n){\\n            if(mx<i) mx=i;\\n            if(mx==\\'9\\') return 9;\\n        }\\n        return (mx-\\'0\\');\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        auto mx=0;\\n        for(auto i:n){\\n            if(mx<i) mx=i;\\n            if(mx==\\'9\\') return 9;\\n        }\\n        return (mx-\\'0\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013888,
                "title": "c-solution-easy-to-undersatnd",
                "content": "Runtime: 26 ms, faster than 93.68% of C++ online submissions for Partitioning Into Minimum Number Of Deci-Binary Numbers.\\nMemory Usage: 13.6 MB, less than 19.12% of C++ online submissions for Partitioning Into Minimum \\nNumber Of Deci-Binary Numbers.\\n\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        \\n        int max=INT_MIN;\\n        for(int i=0;i<n.size();i++){\\n            int m=n[i]-\\'0\\';\\n            if(max<m)\\n            {\\n                max=m;\\n            }\\n        }\\n        return max;\\n    }\\n};",
                "solutionTags": [
                    "String",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int minPartitions(string n) {\\n        \\n        int max=INT_MIN;\\n        for(int i=0;i<n.size();i++){\\n            int m=n[i]-\\'0\\';\\n            if(max<m)\\n            {\\n                max=m;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2998631,
                "title": "easy-java-soln-with-expplanation-and-proof",
                "content": "We just return the max digit,\\nsince the max a number can contribute is 1.\\n**Proof**\\nAssume max digit in n is x.\\nBecause deci-binary only contains 0 and 1,\\nwe need at least x numbers to sum up a digit x.\\n\\nNow we contruct an answer,\\nTake n = 135 as an example,\\nwe initilize 5 deci-binary number with lengh = 3,\\na1 = 000\\na2 = 000\\na3 = 000\\na4 = 000\\na5 = 000\\n\\nFor the first digit, we fill the first n[0] number with 1\\nFor the second digit, we fill the first n[1] number with 1\\nFor the third digit, we fill the first n[2] number with 1\\n\\nSo we have\\na1 = 111\\na2 = 011\\na3 = 011\\na4 = 001\\na5 = 001\\n\\nFinally, we have 111+11+11+1+1=135.\\n\\n\\nComplexity\\nTime O(L)\\nSpace O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPartitions(String n) {\\n      int l = n.length();\\n      int max = (int)n.charAt(0);\\n      for(int i=1;i<l;i++)\\n      {\\n          max=Math.max(max,(int)n.charAt(i));\\n      }  \\n      return max-48;//this step is essential to convert **Bold**the ascii value to decimal value.try dry running with few examples you would get it\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPartitions(String n) {\\n      int l = n.length();\\n      int max = (int)n.charAt(0);\\n      for(int i=1;i<l;i++)\\n      {\\n          max=Math.max(max,(int)n.charAt(i));\\n      }  \\n      return max-48;//this step is essential to convert **Bold**the ascii value to decimal value.try dry running with few examples you would get it\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882693,
                "title": "c-o-n-easy-solution-c",
                "content": "# Intuition\\nThe number of partitions needed is equal to the largest single number in the string.\\n\\n# Approach\\nIterate through string \\'n\\' assigning max = current piece of \\'n\\' if it is greater than the temp val (this will be a ASCII value at first so we need to -48 to get the real number). If temp ever == 9 just return 9 since that is the max max. \\n\\n# Complexity\\n- Time complexity:\\nO(n):\\n    - n = given string length / length until 9 is found.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int temp;\\n        int max = -1;\\n\\n        for (auto i: n) {\\n            temp = i - 48;\\n            if (temp == 9) {\\n                max = 9;\\n                break;\\n            }\\n            if (temp > max) {\\n                max = temp;\\n            }\\n        }\\n\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int temp;\\n        int max = -1;\\n\\n        for (auto i: n) {\\n            temp = i - 48;\\n            if (temp == 9) {\\n                max = 9;\\n                break;\\n            }\\n            if (temp > max) {\\n                max = temp;\\n            }\\n        }\\n\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860189,
                "title": "simple-c-solution-with-explanation-must-check",
                "content": "# Intuition\\n\\n```\\n/* logic :\\n         Let\\'s consider the number 32\\n         As we know that we have to add the deci-binary number (ie. 0 or 1).\\n         From given number for last digit ie 2 \\n                                             |--> we need two 1.\\n                                              _1\\n                                              _1\\n\\n                                             |--> and for 3 we need Three 1\\n                                               1_\\n                                               1_\\n                                               1_\\n\\n                                             Now we will need minimum number,\\n\\n                                             Hence numbers are\\n                                             10\\n                                           + 11\\n                                           + 11\\n                                           -------\\n                                             32\\n\\n    Simiply we need to find the maximum value digit from the given String.\\n*/\\n```\\n----\\n\\n**Solution:**\\n\\n---\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans = 0;\\n\\n        for(char x:n)\\n        {\\n            int curr = x-48;\\n            ans = max(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n----\\n\\n**Analysis:**\\n\\n----\\n**Time Complexity:** ```O(n)``` Where n is the length of the string\\n**Space Complexity:** ```O(1)```Because we don\\'t use extra Space.\\n\\n\\n---\\n\\nIf this solution Helps you then please ```UPVOTE```.\\nTill then **Keep Learning, Keep Growing !!!!**\\n\\nThank You!!!\\n\\n---\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/* logic :\\n         Let\\'s consider the number 32\\n         As we know that we have to add the deci-binary number (ie. 0 or 1).\\n         From given number for last digit ie 2 \\n                                             |--> we need two 1.\\n                                              _1\\n                                              _1\\n\\n                                             |--> and for 3 we need Three 1\\n                                               1_\\n                                               1_\\n                                               1_\\n\\n                                             Now we will need minimum number,\\n\\n                                             Hence numbers are\\n                                             10\\n                                           + 11\\n                                           + 11\\n                                           -------\\n                                             32\\n\\n    Simiply we need to find the maximum value digit from the given String.\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans = 0;\\n\\n        for(char x:n)\\n        {\\n            int curr = x-48;\\n            ans = max(ans,curr);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```O(n)```\n```O(1)```\n```UPVOTE```",
                "codeTag": "Java"
            },
            {
                "id": 2829835,
                "title": "3-liner-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int maxi = INT_MIN;\\n        for(auto x : n) maxi = max(maxi, x-\\'0\\');\\n        return maxi;\\n        \\n        // int maxi = INT_MIN, element;\\n        // for(int i = 0; i < n.size(); i++){\\n        //     element = n[i]-\\'0\\';\\n        //     maxi = max(maxi, element);\\n        // }\\n        // return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int maxi = INT_MIN;\\n        for(auto x : n) maxi = max(maxi, x-\\'0\\');\\n        return maxi;\\n        \\n        // int maxi = INT_MIN, element;\\n        // for(int i = 0; i < n.size(); i++){\\n        //     element = n[i]-\\'0\\';\\n        //     maxi = max(maxi, element);\\n        // }\\n        // return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539232,
                "title": "java-fastest-solution-100-faster",
                "content": "class Solution {\\n\\n    public int minPartitions(String n) {\\n        for (char i = \\'9\\'; i >= \\'0\\'; i--) {\\n            if (n.indexOf(i) >= 0)\\n                return i - \\'0\\';\\n        }\\n        return 0;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int minPartitions(String n) {\\n        for (char i = \\'9\\'; i >= \\'0\\'; i--) {\\n            if (n.indexOf(i) >= 0)\\n                return i - \\'0\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2509867,
                "title": "python-one-line-code",
                "content": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276531,
                "title": "c-simple-solution-with-simple-explanation",
                "content": "we can use only 0 and 1 to make the given number.\\nif n = 4\\nthen we use 1+1+1+1 = 4\\nSo, the minimum number of positive deci-binary numbers are : 4 (1,1,1,1)\\n\\nif n = 32\\nthen we use \\n-> 32-11 = 21 \\n-> 21-11 = 10\\n-> 10-10 = 0  \\nSo, the minimum number of positive deci-binary numbers are : 3 (11,11,10)\\n\\nHence, we can see here that the max digit in the given string n is our ans.\\n\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n\\t    // take first char from given string n as ans\\n        char ans = n[0];\\n        for(int i=1; i<n.length(); i++) {\\n\\t\\t    // compare all the characters of string n from index 1 to length()-1 \\n            if(n[i]>ans) {\\n\\t\\t\\t\\t// store the char with higher number in ans\\n                ans = n[i];\\n            }\\n        }\\n\\t\\t// convert ans into int data type\\n        return ans-\\'0\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n\\t    // take first char from given string n as ans\\n        char ans = n[0];\\n        for(int i=1; i<n.length(); i++) {\\n\\t\\t    // compare all the characters of string n from index 1 to length()-1 \\n            if(n[i]>ans) {\\n\\t\\t\\t\\t// store the char with higher number in ans\\n                ans = n[i];\\n            }\\n        }\\n\\t\\t// convert ans into int data type\\n        return ans-\\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246437,
                "title": "c-just-return-maximum-digit",
                "content": "we want to find maximum digit, because for marking that digit those many 1s are required hence, we need that many numbers to make it.\\none line solution using c++ stl fun max_element()\\n\\n```\\n    int minPartitions(string n) {\\n        return *max_element(n.begin(), n.end()) - \\'0\\';\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int minPartitions(string n) {\\n        return *max_element(n.begin(), n.end()) - \\'0\\';\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2221844,
                "title": "c-o-n-4-liner-code",
                "content": "Just simply return the highest number found in string\\n\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n       int ans=0;\\n        for(auto it:n)\\n            ans =max(ans,it-\\'0\\');\\n        return  ans;\\n    }\\n};\\n```\\n\\n*How this works ?*\\nconsider  **32**\\n32 = 11 + 11 + 10\\n\\nfor **59**\\n59 =  ( 11 + 11 + 11 + 11 + 11 ) + 1 + 1 + 1 + 1 *// total 9 digits required*\\n\\nfor **121**\\n121 =  110 + 11 *// 2 numbers only*\\n\\nformula = base + remaining = heighest number\\n\\nenjoy **; )**\\n\\n\\nif you find this usefull, feel free to upvote it;",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n       int ans=0;\\n        for(auto it:n)\\n            ans =max(ans,it-\\'0\\');\\n        return  ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218137,
                "title": "python-one-line-explained",
                "content": "We need to use deci-binary numbers to sum up to some number `x`\\n\\nLet\\'s take `\"82734\"` as an example.\\n\\nSumming up to that number, or reducing it to \"00000\" is the same thing, so let\\'s reduce to 0 since it\\'s easier to explain.\\n\\nTo reduce `80000` to 0, we will subtract by 8 * 10000.\\n\\nTo reduce `82000` we would have (`8 * 10000`) + (`2 * 1000`) but since we can use any combination of 1\\'s and 0\\'s, we will multiply by\\n`2*11000` and `6*10000`. Total of **8 deci-binary numbers used**\\n\\nFrom this example, we can deduce that the minimum number of positive deci-binary numbers is just the maximum digit that we can find in the string n.\\n\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206403,
                "title": "java-sample-solutions",
                "content": "public int minPartitions(String n) {   \\n\\n        char b =\\'0\\';\\n        for(char c:n.toCharArray())\\n            if(c>b) b=c;\\n        return b-\\'0\\';\\n    }",
                "solutionTags": [],
                "code": "public int minPartitions(String n) {   \\n\\n        char b =\\'0\\';\\n        for(char c:n.toCharArray())\\n            if(c>b) b=c;\\n        return b-\\'0\\';\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2206062,
                "title": "1689-partitioning-into-minimum-number-of-deci-binary-numbers",
                "content": "Here we require only Deci-binary numbers which consits of only 0 and 1.\\nSo if we find the maximum digit from the string then it is the answer.![image](https://assets.leetcode.com/users/images/9b41d162-b66b-4b49-ac1b-859db7689e7a_1656348745.3170848.jpeg)\\n\\n\\nas we know here only 0 and 1 is allowed.\\n\\nin python ::\\n\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n))\\n\\n\\n\\n***# effectively the maximum digit present in the \\'n\\' is here who decides that how many 1\\'s will be present . The total no. of 1\\'s required to sum up to form the maximum digit is the deciding that how many numbers required for the total sum up.\\n=> return max(n) or return int(max(n))***",
                "solutionTags": [
                    "Python"
                ],
                "code": "Here we require only Deci-binary numbers which consits of only 0 and 1.\\nSo if we find the maximum digit from the string then it is the answer.![image](https://assets.leetcode.com/users/images/9b41d162-b66b-4b49-ac1b-859db7689e7a_1656348745.3170848.jpeg)\\n\\n\\nas we know here only 0 and 1 is allowed.\\n\\nin python ::\\n\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n))\\n\\n\\n\\n***# effectively the maximum digit present in the \\'n\\' is here who decides that how many 1\\'s will be present . The total no. of 1\\'s required to sum up to form the maximum digit is the deciding that how many numbers required for the total sum up.\\n=> return max(n) or return int(max(n))***",
                "codeTag": "Java"
            },
            {
                "id": 2205916,
                "title": "v-easy-c-code-strings",
                "content": "class Solution {\\n\\npublic:\\n\\n    int minPartitions(string n) {\\n        \\n        char max = \\'\\\\0\\';\\n        for(int i=0;i<n.length();i++){\\n            if(n[i]>max){\\n                cout<<n[i]<<\"\\\\n\";\\n                max = n[i];\\n            }\\n            \\n        }\\n        int ans = max-\\'0\\';\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\n\\npublic:\\n\\n    int minPartitions(string n) {\\n        \\n        char max = \\'\\\\0\\';\\n        for(int i=0;i<n.length();i++){\\n            if(n[i]>max){\\n                cout<<n[i]<<\"\\\\n\";\\n                max = n[i];\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 2205426,
                "title": "why-it-is-medium-problem-why-not-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=0;\\n        for(auto i:n){\\n            ans=max(ans,i-\\'0\\');\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=0;\\n        for(auto i:n){\\n            ans=max(ans,i-\\'0\\');\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2205399,
                "title": "golang-iterative-solution-o-n-time-o-1-space",
                "content": "```\\n// * Iterative Solution | O(n) Time | O(1) Space\\n\\nfunc minPartitions(n string) int {\\n\\tlargestDigit := 0\\n\\tfor _, v := range n {\\n\\t\\tlargestDigit = findMax(largestDigit, int(v-\\'0\\'))\\n\\t}\\n\\n\\treturn largestDigit\\n}\\n\\nfunc findMax(a, b int) int {\\n\\tif a >= b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Iterator"
                ],
                "code": "```\\n// * Iterative Solution | O(n) Time | O(1) Space\\n\\nfunc minPartitions(n string) int {\\n\\tlargestDigit := 0\\n\\tfor _, v := range n {\\n\\t\\tlargestDigit = findMax(largestDigit, int(v-\\'0\\'))\\n\\t}\\n\\n\\treturn largestDigit\\n}\\n\\nfunc findMax(a, b int) int {\\n\\tif a >= b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2205198,
                "title": "python-1-line-solution-simple-o-n-time-easy-with-explanation",
                "content": "**Explanation**: \\n\\nWe just need to figure out the maximum digit present in the string. That will be our answer.\\n\\n**Intution behind this approach:**\\n1) Think about if the input was only one digit. Then you need to add up as many ones\\n  as the value of this digit.\\n2) If the input has multiple digits, then you can solve for each digit independently,\\n  and merge the answers to form numbers that add up to that input.\\n3) Thus, the answer is equal to the max digit present in the input number.\\n\\n*Please do upvote if you find this helpful!*\\n\\n**Time Complexity:** O(n)\\nReason: Finding the maximum value will take O(n) time internally\\n\\n**Code:**\\n```\\ndef minPartitions(self, n: str) -> int:\\n        return max(map(int, list(n)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef minPartitions(self, n: str) -> int:\\n        return max(map(int, list(n)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2204589,
                "title": "scala-1-liner-3-approaches-100-faster-100-less-memory",
                "content": "**Approach 1**\\n```\\nobject Solution {\\n  def minPartitions(n: String): Int = n.max - \\'0\\'\\n}\\n\\n//Runtime: 1034 ms, faster than 16.67% of Scala online submissions for Partitioning Into Minimum Number Of Deci-Binary Numbers.\\n//Memory Usage: 83.7 MB, less than 66.67% of Scala online submissions for Partitioning Into Minimum Number Of Deci-Binary Numbers.\\n```\\n\\n**Approach 2**\\n```\\nobject Solution {\\n  def minPartitions(n: String): Int = (\\'9\\'.toInt to \\'0\\'.toInt by -1).find(n.contains(_)).get - \\'0\\'\\n}\\n\\n//Runtime: 931 ms, faster than 33.33% of Scala online submissions for Partitioning Into Minimum Number Of Deci-Binary Numbers.\\n//Memory Usage: 83.5 MB, less than 66.67% of Scala online submissions for Partitioning Into Minimum Number Of Deci-Binary Numbers.\\n```\\n\\n**Approach 3**\\nTailrec with greedy approach for max (9)\\n```\\nobject Solution {\\n  def minPartitions(n: String): Int = {\\n    @scala.annotation.tailrec\\n    def helper(i: Int = 0, max: Int = 0): Int = if (i == n.length || max == 9) max - \\'0\\' else helper(i + 1, max max n(i))\\n\\n    helper()\\n  }\\n}\\n\\n//Runtime: 580 ms, faster than 100.00% of Scala online submissions for Partitioning Into Minimum Number Of Deci-Binary Numbers.\\n//Memory Usage: 53.2 MB, less than 100.00% of Scala online submissions for Partitioning Into Minimum Number Of Deci-Binary Numbers.\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def minPartitions(n: String): Int = n.max - \\'0\\'\\n}\\n\\n//Runtime: 1034 ms, faster than 16.67% of Scala online submissions for Partitioning Into Minimum Number Of Deci-Binary Numbers.\\n//Memory Usage: 83.7 MB, less than 66.67% of Scala online submissions for Partitioning Into Minimum Number Of Deci-Binary Numbers.\\n```\n```\\nobject Solution {\\n  def minPartitions(n: String): Int = (\\'9\\'.toInt to \\'0\\'.toInt by -1).find(n.contains(_)).get - \\'0\\'\\n}\\n\\n//Runtime: 931 ms, faster than 33.33% of Scala online submissions for Partitioning Into Minimum Number Of Deci-Binary Numbers.\\n//Memory Usage: 83.5 MB, less than 66.67% of Scala online submissions for Partitioning Into Minimum Number Of Deci-Binary Numbers.\\n```\n```\\nobject Solution {\\n  def minPartitions(n: String): Int = {\\n    @scala.annotation.tailrec\\n    def helper(i: Int = 0, max: Int = 0): Int = if (i == n.length || max == 9) max - \\'0\\' else helper(i + 1, max max n(i))\\n\\n    helper()\\n  }\\n}\\n\\n//Runtime: 580 ms, faster than 100.00% of Scala online submissions for Partitioning Into Minimum Number Of Deci-Binary Numbers.\\n//Memory Usage: 53.2 MB, less than 100.00% of Scala online submissions for Partitioning Into Minimum Number Of Deci-Binary Numbers.\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2204529,
                "title": "c-one-step-solution-o-n",
                "content": "___ just find the maximum digit in the string \\n___ because we can only take 1 \\\\ 0 \\n___ so to reach maximum digit we need at least string=maximum digit\\n\\n\\'\\'\\'\\nint minPartitions(string n) {\\n        int ans=1;\\n        for(int i=0;i<n.size();i++){\\n            if((n[i]-\\'0\\')>ans)ans=(n[i]-\\'0\\');\\n        }\\n        return ans;\\n    }\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "___ just find the maximum digit in the string \\n___ because we can only take 1 \\\\ 0 \\n___ so to reach maximum digit we need at least string=maximum digit\\n\\n\\'\\'\\'\\nint minPartitions(string n) {\\n        int ans=1;\\n        for(int i=0;i<n.size();i++){\\n            if((n[i]-\\'0\\')>ans)ans=(n[i]-\\'0\\');\\n        }\\n        return ans;\\n    }\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2203735,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return(max(n))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return(max(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203731,
                "title": "c-one-liner-super-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n      return  *max_element( begin(n),  end(n) ) -  \\'0\\';  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n      return  *max_element( begin(n),  end(n) ) -  \\'0\\';  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203587,
                "title": "c-one-liner",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(n.begin(),n.end())-\\'0\\';\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        return *max_element(n.begin(),n.end())-\\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203560,
                "title": "c-way-too-easy-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n       int mn = INT_MIN; \\n       for(char x: n){\\n           int temp = x -\\'0\\' ;\\n           mn = max(mn,temp);\\n       }\\n      return mn;  \\n    }\\n}; \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n       int mn = INT_MIN; \\n       for(char x: n){\\n           int temp = x -\\'0\\' ;\\n           mn = max(mn,temp);\\n       }\\n      return mn;  \\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203253,
                "title": "easy-math-observation-based-question",
                "content": "see in this question if we carefully observe for all then the number  of deci binary numbers needed will alyaws be equal to largest digit present in string always . \\neg : 8 2 7 3 4 is formed by:\\n        1 1 1 1 1\\n\\t\\t1 1 1 1 1\\n\\t\\t1 0 1 1 1\\n\\t\\t1 0 1 0 1\\n\\t\\t1 0 1 0 0 \\n\\t\\t1 0 1 0 0\\n\\t\\t1 0 1 0 0\\n\\t\\t1 0 0 0 0\\n\\t\\t so 8 numbers we need bt this logic easy code:\\n\\t\\t\\n```\\n\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int maxD=INT_MIN;\\n        //int curr_maxd=INT_MIN;\\n        for(int i=0;i<n.size();i++){\\n            int d=n[i]-\\'0\\';\\n            maxD=max(maxD,d);\\n        }\\n        return maxD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int maxD=INT_MIN;\\n        //int curr_maxd=INT_MIN;\\n        for(int i=0;i<n.size();i++){\\n            int d=n[i]-\\'0\\';\\n            maxD=max(maxD,d);\\n        }\\n        return maxD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203201,
                "title": "4-line-and-1-line-solution-time-o-n-space-o-1-c",
                "content": "**Upvote If Helpful ;)**\\n\\n**1. Normal \"For\" loop based approach** (4 lines)\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) \\n    {\\n        char maxch=\\'0\\';\\n        for(auto&x: n)\\n            maxch=max(maxch,x);\\n        return maxch-\\'0\\';\\n    }\\n};\\n```\\n\\n**2. STL based approach** (1 Liner)\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) \\n\\t{\\n        return *max_element(n.begin(), n.end()) - \\'0\\';\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) \\n    {\\n        char maxch=\\'0\\';\\n        for(auto&x: n)\\n            maxch=max(maxch,x);\\n        return maxch-\\'0\\';\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) \\n\\t{\\n        return *max_element(n.begin(), n.end()) - \\'0\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203174,
                "title": "python3-simple-fastest-solution",
                "content": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        res = 0\\n        for i in n: res = max(res, int(i))\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        res = 0\\n        for i in n: res = max(res, int(i))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202967,
                "title": "c-one-liner-solution-c-stl",
                "content": "**Find the largest digit in the given string and that would be the required answer, as the minimum number of operations that need to be performed to make it 0 is actually equal to the maximum value of the digit in the given string.**\\n```\\n int minPartitions(string n) {\\n        return *max_element(n.begin(), n.end())- 48; //STL function to find the max element in the given string and we subtract 48 from it as ASCII value of 0 is 48 and the max element being a char in the string, we need to subtract it from ASCII value of 0 to get its integer value. We can even subtract \\'0\\' instead of 48, there is no difference in the output.\\n    }\\n```\\n**Please do vote and share my approach if you find it helpful. Thanks in Advance!!! Let me know your doubts regarding my approach through comment section, I would be happy to reply back!!**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n int minPartitions(string n) {\\n        return *max_element(n.begin(), n.end())- 48; //STL function to find the max element in the given string and we subtract 48 from it as ASCII value of 0 is 48 and the max element being a char in the string, we need to subtract it from ASCII value of 0 to get its integer value. We can even subtract \\'0\\' instead of 48, there is no difference in the output.\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2202911,
                "title": "cpp-81-faster-using-ascii-logic-short-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string s) {\\n        char c = *max_element(s.begin(),s.end());\\n        int ans = (int)c-48;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string s) {\\n        char c = *max_element(s.begin(),s.end());\\n        int ans = (int)c-48;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202882,
                "title": "max-valued-digit",
                "content": "You just need to check what is the maximum number of digit in the given string.\\n\\n**Why?**\\n\\nThis is only becuase in a binary number there are only 1 or 0. So, you need atleast max_digit number of 1s to add up.\\nThe max_number could only lie 0 - 9.\\n\\n**Please Upvote^ if you like the solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        char max_digit = \\'0\\';\\n        \\n        for(auto ch: n)\\n            max_digit = max(max_digit, ch);\\n        \\n        return (max_digit - \\'0\\'); // \\'0\\' is subtracted, so that the integer ascii value is equal to int(max_digit);\\n    }\\n};\\n```\\n\\nThank you everyone!\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        char max_digit = \\'0\\';\\n        \\n        for(auto ch: n)\\n            max_digit = max(max_digit, ch);\\n        \\n        return (max_digit - \\'0\\'); // \\'0\\' is subtracted, so that the integer ascii value is equal to int(max_digit);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202874,
                "title": "maximum-digit-in-string",
                "content": "```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        int res = 0;\\n        for(char ch : n.toCharArray()){\\n            if(res< (ch-\\'0\\')) res = ch-\\'0\\'; \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        int res = 0;\\n        for(char ch : n.toCharArray()){\\n            if(res< (ch-\\'0\\')) res = ch-\\'0\\'; \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202856,
                "title": "1-liner-code-easy-faster-than-93-5",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=0;\\n        for(auto x:n)\\n        {\\n            ans=max(ans,x-\\'0\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=0;\\n        for(auto x:n)\\n        {\\n            ans=max(ans,x-\\'0\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202651,
                "title": "elixir-one-line-solution",
                "content": "```elixir\\ndefmodule Solution do\\n  @spec min_partitions(n :: String.t) :: integer\\n  def min_partitions(n) do\\n    String.graphemes(n) |> Enum.max() |> String.to_integer()\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```elixir\\ndefmodule Solution do\\n  @spec min_partitions(n :: String.t) :: integer\\n  def min_partitions(n) do\\n    String.graphemes(n) |> Enum.max() |> String.to_integer()\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2202626,
                "title": "c-w-example-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    82734\\n    _____\\n    11111 +\\n    11111 +\\n    10111 +\\n    10101 +\\n    10100 +\\n    10100 +\\n    10100 +\\n    10000\\n    \\n    Hence the minimum number of positive deci-binary partitions is just the maximum digit of n\\n    */\\n    int minPartitions(string n) {\\n      int res = 0;\\n      for (char ch : n)\\n        res = max(res, ch - \\'0\\');\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    82734\\n    _____\\n    11111 +\\n    11111 +\\n    10111 +\\n    10101 +\\n    10100 +\\n    10100 +\\n    10100 +\\n    10000\\n    \\n    Hence the minimum number of positive deci-binary partitions is just the maximum digit of n\\n    */\\n    int minPartitions(string n) {\\n      int res = 0;\\n      for (char ch : n)\\n        res = max(res, ch - \\'0\\');\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181124,
                "title": "python-faster-than-99-one-liner",
                "content": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max({*n})",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max({*n}",
                "codeTag": "Java"
            },
            {
                "id": 1939991,
                "title": "c-genuine3-line-code",
                "content": "```\\nint minPartitions(string n) {\\n        char p = \\'0\\';\\n        for(auto i : n)p=max(p,i);\\n        return p-\\'0\\';\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minPartitions(string n) {\\n        char p = \\'0\\';\\n        for(auto i : n)p=max(p,i);\\n        return p-\\'0\\';\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1878670,
                "title": "java-easy-short",
                "content": "** IF YOU LIKE MY SOLUTION, THEN PLEASE DO UPVOTE**\\n```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        \\n        int len = n.length();\\n        int maxDigit = -1;\\n        \\n        for(int i = 0; i < len; i++) {\\n            int digit = ((int)(n.charAt(i)) - 48);\\n            if(digit > maxDigit) maxDigit = digit;\\n        }\\n        \\n        return maxDigit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        \\n        int len = n.length();\\n        int maxDigit = -1;\\n        \\n        for(int i = 0; i < len; i++) {\\n            int digit = ((int)(n.charAt(i)) - 48);\\n            if(digit > maxDigit) maxDigit = digit;\\n        }\\n        \\n        return maxDigit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791546,
                "title": "c-100-faster-greedy",
                "content": "**\\tIntuition- suppose we have a number 987 since each digit must be 1 or 0 we need minimum \\n\\t9 1\\'s to make 9 and 8 1\\'s to make 8 and 7 1\\'s to make 7. So our answer would be maximum\\n\\tdigit we are having in our given string.\\n\\tEdge case- If we are given \\'1\\' then we need only 1 deci-binary string which is 1 itself.**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t int helper(string n){\\n\\t\\t\\tint max=0;\\n\\t\\t\\tfor(auto &it:n){\\n\\t\\t\\t\\tif(it-\\'0\\'>max)\\n\\t\\t\\t\\t\\tmax=it-\\'0\\';\\n\\t\\t\\t}\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\t\\tint minPartitions(string n) {\\n\\t\\t\\t int t =helper(n);\\n\\t\\t\\t if(t<1) return 0;\\n\\t\\t\\treturn t;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t int helper(string n){\\n\\t\\t\\tint max=0;\\n\\t\\t\\tfor(auto &it:n){\\n\\t\\t\\t\\tif(it-\\'0\\'>max)\\n\\t\\t\\t\\t\\tmax=it-\\'0\\';\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1763877,
                "title": "simple-python-one-liner",
                "content": "Since each number can only have 1\\'s & 0\\'s, every number can only account for 1 part of every digit *(Meaning 4 has 4 parts, 9 has 9 parts and 0 has 0 parts)*. So the count of total numbers required is the maximum number of parts available in the string. \\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662211,
                "title": "building-intuition-and-then-optimizing-code",
                "content": "```\\n/**\\n     * Each time we are iterating through the String we are subtracting 1 from the digit which is non-zero\\n     * for example : 82734\\n     * 1st pass\\n     *  removed 11111,so now the num is 71623\\n     * 2nd pass\\n     *  removed 11111,so now the num is 60512\\n     * 3rd pass\\n     *  removed 10111,so now the num is 50401\\n     * 4th pass\\n     *  removed 10101,so now the num is 40300\\n     * 5th, 6th, 7th pass\\n     *  remove 10100, so now the num is 10000\\n     * 8th pass\\n     *  remove 10000,so now the num is 00000\\n     * So our answer is 8,since 8 passes\\n     * */\\n    public int minPartitions(String n) {\\n        int count = 1,ans= 0;\\n        char[] arr = n.toCharArray();\\n        while(count !=0 ){\\n            count = 0;\\n            for(int i=0;i<arr.length;i++){\\n                if(arr[i] != \\'0\\'){\\n                    count++;\\n                    arr[i]--;\\n                }\\n            }\\n            if(count > 0) ans++;\\n        }\\n        return ans;\\n    }\\n```\\n\\n* **Now Optimizing the code**\\n*       Now if we observe carefully the above solution, when we make a pass , each time we reduce the digit by 1.\\n* \\t  So the maximum number of pass we will have to make is the maximum digit in the string,\\n      and that will be our answer.\\n     \\n  \\n\\t  public int minPartitions(String n) {\\n         int ans= -1;\\n         for(int i=0;i<n.length();i++){\\n             ans= Math.max(ans,n.charAt(i)-\\'0\\');\\n         }\\n         return ans;\\n     }\\n\\t",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n/**\\n     * Each time we are iterating through the String we are subtracting 1 from the digit which is non-zero\\n     * for example : 82734\\n     * 1st pass\\n     *  removed 11111,so now the num is 71623\\n     * 2nd pass\\n     *  removed 11111,so now the num is 60512\\n     * 3rd pass\\n     *  removed 10111,so now the num is 50401\\n     * 4th pass\\n     *  removed 10101,so now the num is 40300\\n     * 5th, 6th, 7th pass\\n     *  remove 10100, so now the num is 10000\\n     * 8th pass\\n     *  remove 10000,so now the num is 00000\\n     * So our answer is 8,since 8 passes\\n     * */\\n    public int minPartitions(String n) {\\n        int count = 1,ans= 0;\\n        char[] arr = n.toCharArray();\\n        while(count !=0 ){\\n            count = 0;\\n            for(int i=0;i<arr.length;i++){\\n                if(arr[i] != \\'0\\'){\\n                    count++;\\n                    arr[i]--;\\n                }\\n            }\\n            if(count > 0) ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1622321,
                "title": "4-lines-easy-java-solution",
                "content": "**Upvote if you Got It** \\uD83D\\uDE42\\n**Hint:** Think about if the input was only one digit. Then you need to add up as many ones as the value of this digit. If the input has multiple digits, then you can solve for each digit independently, and merge the answers to form numbers that add up to that input. Thus the answer is equal to the max digit.\\n\\nclass Solution {\\n\\n    public int minPartitions(String n) {\\n        int max = 0;\\n        for(char c:n.toCharArray())\\n            max = Math.max(c-\\'0\\',max);\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int minPartitions(String n) {\\n        int max = 0;\\n        for(char c:n.toCharArray())\\n            max = Math.max(c-\\'0\\',max);\\n        return max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1589160,
                "title": "my-best-solution",
                "content": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:            \\n        return max(set(n)) #max works faster on shrink data set. Cast srt to set is faster than getting max element from the whole list.\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:            \\n        return max(set(n)) #max works faster on shrink data set. Cast srt to set is faster than getting max element from the whole list.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508262,
                "title": "2-lines-java-code",
                "content": "class Solution {\\n    public int minPartitions(String n) {\\n        int i=Integer.MIN_VALUE;\\n        for(char ch:n.toCharArray())\\n        {\\n            int temp=Character.getNumericValue(ch);\\n            i=Math.max(i,temp);\\n        }\\n        return i;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minPartitions(String n) {\\n        int i=Integer.MIN_VALUE;\\n        for(char ch:n.toCharArray())\\n        {\\n            int temp=Character.getNumericValue(ch);\\n            i=Math.max(i,temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1294637,
                "title": "simple-java-o-n",
                "content": "class Solution {\\n    public int minPartitions(String n) {\\n        int a=n.length();\\n        int max=-1;\\n    for(int i=0;i<a;i++){\\n    if(Integer.parseInt(String.valueOf(n.charAt(i)))>max){\\n        max=Integer.parseInt(String.valueOf(n.charAt(i)));\\n\\t\\t\\t}    \\n\\t\\t}\\n        return max;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minPartitions(String n) {\\n        int a=n.length();\\n        int max=-1;\\n    for(int i=0;i<a;i++){\\n    if(Integer.parseInt(String.valueOf(n.charAt(i)))>max){\\n        max=Integer.parseInt(String.valueOf(n.charAt(i)));\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1251081,
                "title": "golang-solution-with-explanation-and-images",
                "content": "The idea of this solution is that the max digit in `n` will be the result. But you might be wondering why this works.\\n\\nThis works because the max digit can only be made by adding the max digit number of `1`\\'s. If you don\\'t understand, look at the following image: ![image](https://assets.leetcode.com/users/images/82cf1d24-261f-42fe-997e-7dd61755342d_1622814930.4995308.jpeg)\\n The first image is an example, and the second example is for anyone who doesn\\'t understand the first example.\\n\\n**The Code:**\\n\\n``` go\\nfunc minPartitions(n string) int {\\n\\tmax := \\'0\\'\\n\\n\\tfor _, i := range n {\\n\\t\\tif i > max {\\n\\t\\t\\tmax = i\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn int(max - \\'0\\')\\n}\\n```",
                "solutionTags": [],
                "code": "``` go\\nfunc minPartitions(n string) int {\\n\\tmax := \\'0\\'\\n\\n\\tfor _, i := range n {\\n\\t\\tif i > max {\\n\\t\\t\\tmax = i\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn int(max - \\'0\\')\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1232187,
                "title": "python-python3-solution-with-explanation",
                "content": "**Example:**\\n\\n1).  n = \"32\"\\n3 has 3 number of 1\\'s (i.e) 1 1 1 = 3\\n2 has 2 number of 1\\'s (i.e) 1 1 0 = 2\\nFill the blank spaces with zeros the add the numbers eventually you get **n** as **addition value**\\nHere the number 3 has maximum number of one\\'s so return the 3 for minimum Number of Deci-Binary Numbers.\\n2). n = \"82734\"\\n8 has 3 number of 1\\'s (i.e) 1 1 1 1 1 1 1 1 = 8\\n2 has 2 number of 1\\'s (i.e) 1 1 0 0 0 0 0 0 = 2\\n7 has 7 number of 1\\'s (i.e) 1 1 1 1 1 1 1 0 = 7\\n3 has 3 number of 1\\'s (i.e) 1 1 1 0 0 0 0 0 = 3\\n4 has 4 number of 1\\'s (i.e) 1 1 1 1 0 0 0 0 = 4\\nHere the number 8 has maximum number of one\\'s so return the 8 for minimum Number of Deci-Binary Numbers.\\n\\n**Code:**\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        numLis = map(int,list(n))\\n        return max(numLis)\\n```\\n\\n***We rise by lifting others***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        numLis = map(int,list(n))\\n        return max(numLis)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231718,
                "title": "simple-java-solution",
                "content": "Hint: Find the largest number in the string.\\n\\nDo upvote if you like the solution to keep me motivated \\uD83D\\uDE0A\\u270C\\n\\n```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0 ; i < n.length() ; i++) {\\n            int ch = Character.getNumericValue(n.charAt(i));\\n            max = Math.max(ch,max);\\n        }\\n        return max;\\n    }\\n}\\n\\n\\n/* \\nTC : O(n)\\nSC: O(1)\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0 ; i < n.length() ; i++) {\\n            int ch = Character.getNumericValue(n.charAt(i));\\n            max = Math.max(ch,max);\\n        }\\n        return max;\\n    }\\n}\\n\\n\\n/* \\nTC : O(n)\\nSC: O(1)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204225,
                "title": "java-8-one-liner-with-explanation",
                "content": "```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        return n.chars().max().getAsInt() -\\'0\\';\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        return n.chars().max().getAsInt() -\\'0\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120654,
                "title": "faster-than-94-04-max-digit",
                "content": "```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        int ans = 0;\\n        for ( char c : n.toCharArray() ) {\\n            ans = Math.max( c-\\'0\\', ans );\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        int ans = 0;\\n        for ( char c : n.toCharArray() ) {\\n            ans = Math.max( c-\\'0\\', ans );\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087588,
                "title": "java-simple-loop-3ms-beats-100-o-n-length",
                "content": "\\n    public int minPartitions(String n) {\\n        int max = 0;\\n\\t\\tfor (char ch : n.toCharArray()) {\\n\\t\\t\\tif (ch - \\'0\\' > max)\\n\\t\\t\\t\\tmax = ch - \\'0\\';\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    public int minPartitions(String n) {\\n        int max = 0;\\n\\t\\tfor (char ch : n.toCharArray()) {\\n\\t\\t\\tif (ch - \\'0\\' > max)\\n\\t\\t\\t\\tmax = ch - \\'0\\';\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 991484,
                "title": "c-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int m_max = 0, k;\\n        for(auto& c : n) {\\n            k = c - \\'0\\';\\n            if(k > m_max) {\\n                m_max = k;\\n            }\\n        }\\n        return m_max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int m_max = 0, k;\\n        for(auto& c : n) {\\n            k = c - \\'0\\';\\n            if(k > m_max) {\\n                m_max = k;\\n            }\\n        }\\n        return m_max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970358,
                "title": "python-o-n-solution",
                "content": "It should be a easy problem, the idea is to find the numbers contains 0, 1, so the max digitin the given N will be answer that many 1 0 combination numbers we need to add to the given number.\\n\\nFor eg: 32, we need 3\\n\\n32 - 11 => 21\\n21 - 11 => 10\\n10 - 10 => 0\\n\\n```\\ndef minPartitions(n):\\n    for i in range(9, -1, -1):\\n        if str(i) in n:\\n            return i\\n\\n    return 0",
                "solutionTags": [],
                "code": "It should be a easy problem, the idea is to find the numbers contains 0, 1, so the max digitin the given N will be answer that many 1 0 combination numbers we need to add to the given number.\\n\\nFor eg: 32, we need 3\\n\\n32 - 11 => 21\\n21 - 11 => 10\\n10 - 10 => 0\\n\\n```\\ndef minPartitions(n):\\n    for i in range(9, -1, -1):\\n        if str(i) in n:\\n            return i\\n\\n    return 0",
                "codeTag": "Python3"
            },
            {
                "id": 970314,
                "title": "python-o-n-return-max-digit",
                "content": "Just return the maximum digit.\\n\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        digits = set()\\n        for d in n:\\n            digits.add(d)\\n\\t\\t\\t\\n        return (int(max(digits)))\\n```\\nWe can exit early if we find 9\\n\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        digits = set()\\n        for d in n:\\n            if d == \\'9\\':\\n                return 9\\n            digits.add(d)\\n\\t\\t\\t\\n        return int(max(digits))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        digits = set()\\n        for d in n:\\n            digits.add(d)\\n\\t\\t\\t\\n        return (int(max(digits)))\\n```\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        digits = set()\\n        for d in n:\\n            if d == \\'9\\':\\n                return 9\\n            digits.add(d)\\n\\t\\t\\t\\n        return int(max(digits))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970254,
                "title": "c-max-only-4-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int res = 0;\\n        for(int i =0 ; i < n.size();++i){\\n            res = max(res,n[i]-\\'0\\');\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int res = 0;\\n        for(int i =0 ; i < n.size();++i){\\n            res = max(res,n[i]-\\'0\\');\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970252,
                "title": "a-few-solutions",
                "content": "Return the integer value of the maximum digit of the input string `s`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var minPartitions = { s: String -> s.max()!!.toInt() - \\'0\\'.toInt() }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minPartitions = s => Math.max(...s.split(\\'\\').map(Number));\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    minPartitions = lambda self, s: max(int(c) for c in s)\\n```\\n\\n*Rust*\\n```\\nimpl Solution {\\n    pub fn min_partitions(s: String) -> i32 {\\n        s.chars().map(|c| c.to_digit(10).unwrap()).max().unwrap() as i32\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string s) { return *max_element(s.begin(), s.end()) - \\'0\\'; }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var minPartitions = { s: String -> s.max()!!.toInt() - \\'0\\'.toInt() }\\n}\\n```\n```\\nlet minPartitions = s => Math.max(...s.split(\\'\\').map(Number));\\n```\n```\\nclass Solution:\\n    minPartitions = lambda self, s: max(int(c) for c in s)\\n```\n```\\nimpl Solution {\\n    pub fn min_partitions(s: String) -> i32 {\\n        s.chars().map(|c| c.to_digit(10).unwrap()).max().unwrap() as i32\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string s) { return *max_element(s.begin(), s.end()) - \\'0\\'; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085555,
                "title": "beginner-friendly-simple-tricky-solution-in-python3-and-javascript-typescript",
                "content": "# Intuition\\nThe problem description is the following:\\n- there\\'s a `n` string, that\\'s a valid positive integer\\n- our goal is to calculate, how many **deci-binary** integers it contains \\n\\nFollowing to the statement, **deci-binary** integer is that, which has only `1`-s and `0`-s as digits with **no leading zeroes**.\\n\\nInstead of thinking **HOW to find** this numbers, let\\'s pay your attention at these notes.\\n```\\n# Example\\nn = \\'692\\'\\n\\n# As always we can start from top to bottom like\\ndigits = \\'111\\' => n = \\'692\\' - \\'111\\' == \\'581\\'...\\n=> n = \\'26\\' => \\'15\\' => \\'4\\' ... => \\'1\\' \\n# And we think that this will work.\\n\\n# Try to practice reducing an integer like in the task example =>\\nn = \\'82734\\'\\n# and y\\'ll see, that this approach WON\\'T lead us \\n# to the optimal solution!\\n\\n# For this moment we can try to iterate vice-versa, i.e. bottom-up,\\n# but with some trick\\n\\n# Consider an integer like 692 again and\\nn = \\'692\\'\\n\\n# 1. break down the integer into digits 6-9-2 or 600 + 90 + 2 \\n# and start from the least digit\\n# 2. calculate HOW many numbers we can sum up to get\\n# a current integer\\n# 3. y\\'ll find, that maximum count of integers you need\\n# to sum up is THE LARGEST digit!\\n```\\n\\n# Approach\\n1. declare an `ans` variable\\n2. iterate over `n` string\\n3. define the maximum digits count and store in `ans`\\n4. return `ans`\\n\\n# Complexity\\n- Time complexity: **O(n)** to iterate over `n`\\n- Space complexity: **O(1)**, we don\\'t allocate extra space\\n\\n\\n# Code in JavaScript/TypeScript\\n```\\nfunction minPartitions(n: string): number {\\n    let ans = 0\\n\\n    for (let i = 0; i < n.length; i++) {\\n        ans = Math.max(ans, +n[i])\\n    }\\n\\n    return ans\\n};\\n```\\n\\n# Code in Python3\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max([int(x) for x in n])\\n```",
                "solutionTags": [
                    "Python3",
                    "TypeScript",
                    "String",
                    "Greedy"
                ],
                "code": "```\\n# Example\\nn = \\'692\\'\\n\\n# As always we can start from top to bottom like\\ndigits = \\'111\\' => n = \\'692\\' - \\'111\\' == \\'581\\'...\\n=> n = \\'26\\' => \\'15\\' => \\'4\\' ... => \\'1\\' \\n# And we think that this will work.\\n\\n# Try to practice reducing an integer like in the task example =>\\nn = \\'82734\\'\\n# and y\\'ll see, that this approach WON\\'T lead us \\n# to the optimal solution!\\n\\n# For this moment we can try to iterate vice-versa, i.e. bottom-up,\\n# but with some trick\\n\\n# Consider an integer like 692 again and\\nn = \\'692\\'\\n\\n# 1. break down the integer into digits 6-9-2 or 600 + 90 + 2 \\n# and start from the least digit\\n# 2. calculate HOW many numbers we can sum up to get\\n# a current integer\\n# 3. y\\'ll find, that maximum count of integers you need\\n# to sum up is THE LARGEST digit!\\n```\n```\\nfunction minPartitions(n: string): number {\\n    let ans = 0\\n\\n    for (let i = 0; i < n.length; i++) {\\n        ans = Math.max(ans, +n[i])\\n    }\\n\\n    return ans\\n};\\n```\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return max([int(x) for x in n])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065514,
                "title": "short-solution-in-c",
                "content": "maximum digit in the string will be the answer\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=0;\\n        for(char c: n){\\n            int x = c - \\'0\\';\\n            ans = max(ans,x);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=0;\\n        for(char c: n){\\n            int x = c - \\'0\\';\\n            ans = max(ans,x);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937067,
                "title": "easiest-solution-fast-java",
                "content": "# Code\\n```\\nclass Solution{\\n    public int minPartitions(String n){\\n        int a = 0;\\n        for(int i=0; i<n.length(); i++){\\n            int x = n.charAt(i)-\\'0\\';\\n            a = Math.max(a, x);\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public int minPartitions(String n){\\n        int a = 0;\\n        for(int i=0; i<n.length(); i++){\\n            int x = n.charAt(i)-\\'0\\';\\n            a = Math.max(a, x);\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904841,
                "title": "c-python-sol-with-explanation",
                "content": "# Intuition\\n\\n```C++ []\\n// since we want to form minimum numbers,\\n// for ex- 23\\n// for 2 - 1,1 we cant use 0 as it will increase the minimum value\\n// for 3-1,1,1 we can use 3 ones in tens place and 2 ones in ones place hence ans is 3.\\n// as u see the result will be the greatest number in the string.\\n\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int m=0;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]-\\'0\\'>m)\\n            m=n[i]-\\'0\\';\\n        }\\n        return m;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        m=0\\n        for i in n:\\n            if int(i)>m:\\n                m=int(i)\\n        return m;\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "String",
                    "Greedy"
                ],
                "code": "```C++ []\\n// since we want to form minimum numbers,\\n// for ex- 23\\n// for 2 - 1,1 we cant use 0 as it will increase the minimum value\\n// for 3-1,1,1 we can use 3 ones in tens place and 2 ones in ones place hence ans is 3.\\n// as u see the result will be the greatest number in the string.\\n\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int m=0;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]-\\'0\\'>m)\\n            m=n[i]-\\'0\\';\\n        }\\n        return m;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        m=0\\n        for i in n:\\n            if int(i)>m:\\n                m=int(i)\\n        return m;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851142,
                "title": "java-simple-solution-100-beats-with-explanation",
                "content": "# Approach\\n\\nApproach and Logic:\\nThe given solution utilizes a simple approach to find the minimum deci-binary number needed to form the given decimal number. The basic idea is to find the largest digit in the given decimal number, and that digit will determine the number of deci-binary numbers required.\\n\\n\\n1. Initialize a variable `max` to `Integer.MIN_VALUE`. This variable will keep track of the largest digit found in the decimal number.\\n\\n2. Convert the input decimal number represented as a string (`n`) to a character array, `chars`.\\n\\n3. Iterate through each character (`c`) in the character array `chars`.\\n\\n4. For each character, calculate the corresponding digit value by subtracting the character \\'0\\' from it. This works because the characters \\'0\\' to \\'9\\' have consecutive Unicode values, so subtracting the character \\'0\\' from any digit character (\\'0\\' to \\'9\\') gives the numeric value of the digit.\\n\\n5. Check if the current digit value is greater than the current maximum (`max`). If it is, update `max` with the current digit value.\\n\\n6. After iterating through all the characters, the variable `max` will contain the largest digit in the decimal number.\\n\\n7. Finally, return the value of `max` as the result, which represents the minimum number of positive deci-binary numbers needed to form the given decimal number.\\n\\nExplanation with Examples:\\nLet\\'s take the first example given in the problem statement to understand the approach:\\n\\nExample 1: Input: n = \"32\"\\n- Initialize `max` as `Integer.MIN_VALUE` (i.e., a very large negative value).\\n- Iterate through each character in the string \"32\":\\n  - For the first character \\'3\\', the digit value is 3. Since `max` is smaller than 3, update `max` to 3.\\n  - For the second character \\'2\\', the digit value is 2. Since `max` is already 3 and 3 is greater than 2, `max` remains 3.\\n- After iterating through all the characters, `max` will be 3, which is the largest digit in the decimal number \"32\".\\n- Return `max` (i.e., 3) as the result, which indicates that a minimum of 3 positive deci-binary numbers are needed to form the decimal number \"32\".\\n- The deci-binary numbers could be 10 + 11 + 11 = 32.\\n\\nThe approach follows a simple logic of finding the largest digit in the decimal number, and that digit determines the number of deci-binary numbers required. This solution works efficiently for the given problem constraints and produces the correct output.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n   public int minPartitions(String n) {\\n        int max = Integer.MIN_VALUE;\\n        char[] chars = n.toCharArray();\\n\\n        for (char c : chars)\\n            if (max < c - \\'0\\')\\n                max = c - \\'0\\';\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n   public int minPartitions(String n) {\\n        int max = Integer.MIN_VALUE;\\n        char[] chars = n.toCharArray();\\n\\n        for (char c : chars)\\n            if (max < c - \\'0\\')\\n                max = c - \\'0\\';\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715265,
                "title": "simple-and-easy-solution",
                "content": "# Intuition\\nThe quistion is designed such a manner if we found the max element of the array we will get the count of 1s. \\ne.g. 32\\'s count is 3 cause the heighest is 3. Similarly example 2 and 3. Do the MAth by yourself and you will understand.\\n\\n# Approach\\n1. Declaire a max varriable.\\n2. convert strin array to char array.\\n3. convert the char to int.\\n4. found the max value and update.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        int max = Integer.MIN_VALUE;\\n        char charr[] = n.toCharArray();\\n        for(int i=0; i<charr.length; i++){\\n            if(max < charr[i]-\\'0\\')  max = charr[i]-\\'0\\';\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minPartitions(String n) {\\n        int max = Integer.MIN_VALUE;\\n        char charr[] = n.toCharArray();\\n        for(int i=0; i<charr.length; i++){\\n            if(max < charr[i]-\\'0\\')  max = charr[i]-\\'0\\';\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573801,
                "title": "1-line-code-solution-for-partitioning-into-minimum-number-of-deci-binary-numbers-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# 1. Optimized Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply sort the string and return the first index integer\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        sort(n.begin(), n.end(), greater<int>());\\n        return (int)n[0]-48;\\n    }\\n};\\n```\\n# 2. Brute Force Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing for and while loops\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int i, flag=0, count=0;\\n        while(true)\\n        {\\n            for(i=0 ; i<n.length() ; i++)\\n            {\\n                if((int)n[i]-48>0)\\n                {\\n                    flag=1;\\n                    n[i] = (int)n[i]-1;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                break;\\n            }\\n            else\\n            {\\n                count++;\\n                flag=0;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/3e32e5cd-259b-4d74-bf03-28acd5c062d8_1685333716.11601.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        sort(n.begin(), n.end(), greater<int>());\\n        return (int)n[0]-48;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int i, flag=0, count=0;\\n        while(true)\\n        {\\n            for(i=0 ; i<n.length() ; i++)\\n            {\\n                if((int)n[i]-48>0)\\n                {\\n                    flag=1;\\n                    n[i] = (int)n[i]-1;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                break;\\n            }\\n            else\\n            {\\n                count++;\\n                flag=0;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441947,
                "title": "golang",
                "content": "# Intuition\\n**\\u0417\\u0430\\u0434\\u0430\\u0447\\u0430**: \\u0434\\u0430\\u043D\\u0430 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0430 **n**, \\u043A\\u043E\\u0442\\u043E\\u0440\\u0430\\u044F \\u043F\\u0440\\u0435\\u0434\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0441\\u043E\\u0431\\u043E\\u0439 \\u043F\\u043E\\u043B\\u043E\\u0436\\u0438\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0435 \\u0434\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E\\u0435 \\u0446\\u0435\\u043B\\u043E\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E. \\u041D\\u0443\\u0436\\u043D\\u043E \\u043D\\u0430\\u0439\\u0442\\u0438 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u043F\\u043E\\u043B\\u043E\\u0436\\u0438\\u0442\\u0435\\u043B\\u044C\\u043D\\u044B\\u0445 \\u0434\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E-\\u0434\\u0432\\u043E\\u0438\\u0447\\u043D\\u044B\\u0445 \\u0447\\u0438\\u0441\\u0435\\u043B, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0435 \\u0432 \\u0441\\u0443\\u043C\\u043C\\u0435 \\u0434\\u0430\\u044E\\u0442 **n**.\\n\\n# Approach\\n#### **\\u041F\\u0440\\u0438\\u043C\\u0435\\u0440:**\\n**\\u041F\\u0443\\u0441\\u0442\\u044C n = \"32\".**\\n\\n\\u041D\\u0443\\u0436\\u043D\\u043E \\u043D\\u0430\\u0439\\u0442\\u0438 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u043F\\u043E\\u043B\\u043E\\u0436\\u0438\\u0442\\u0435\\u043B\\u044C\\u043D\\u044B\\u0445 \\u0434\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E-\\u0434\\u0432\\u043E\\u0438\\u0447\\u043D\\u044B\\u0445 \\u0447\\u0438\\u0441\\u0435\\u043B, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0435 \\u0432 \\u0441\\u0443\\u043C\\u043C\\u0435 \\u0434\\u0430\\u044E\\u0442 **32**.\\n\\n\\u0414\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E-\\u0434\\u0432\\u043E\\u0438\\u0447\\u043D\\u044B\\u0435 \\u0447\\u0438\\u0441\\u043B\\u0430 \\u043C\\u043E\\u0433\\u0443\\u0442 \\u0441\\u043E\\u0434\\u0435\\u0440\\u0436\\u0430\\u0442\\u044C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0446\\u0438\\u0444\\u0440\\u044B **0** \\u0438 **1**.\\n\\n**\\u041D\\u0430\\u043F\\u0440\\u0438\\u043C\\u0435\\u0440**, \\u0434\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E-\\u0434\\u0432\\u043E\\u0438\\u0447\\u043D\\u043E\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E **10** \\u0441\\u043E\\u043E\\u0442\\u0432\\u0435\\u0442\\u0441\\u0442\\u0432\\u0443\\u0435\\u0442 \\u0447\\u0438\\u0441\\u043B\\u0443 **2** \\u0432 \\u0434\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E\\u0439 \\u0441\\u0438\\u0441\\u0442\\u0435\\u043C\\u0435 \\u0441\\u0447\\u0438\\u0441\\u043B\\u0435\\u043D\\u0438\\u044F, \\u0430 \\u0434\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E-\\u0434\\u0432\\u043E\\u0438\\u0447\\u043D\\u043E\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E **1110** \\u0441\\u043E\\u043E\\u0442\\u0432\\u0435\\u0442\\u0441\\u0442\\u0432\\u0443\\u0435\\u0442 \\u0447\\u0438\\u0441\\u043B\\u0443 **14**. \\u041D\\u0430\\u043C \\u043D\\u0443\\u0436\\u043D\\u043E \\u043D\\u0430\\u0439\\u0442\\u0438 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0434\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E-\\u0434\\u0432\\u043E\\u0438\\u0447\\u043D\\u044B\\u0445 \\u0447\\u0438\\u0441\\u0435\\u043B, \\u0441\\u0443\\u043C\\u043C\\u0430 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0445 \\u0440\\u0430\\u0432\\u043D\\u0430 **32**.\\n\\n**\\u041D\\u0430\\u043F\\u0440\\u0438\\u043C\\u0435\\u0440**, \\u043C\\u044B \\u043C\\u043E\\u0436\\u0435\\u043C \\u043F\\u0440\\u0435\\u0434\\u0441\\u0442\\u0430\\u0432\\u0438\\u0442\\u044C \\u0447\\u0438\\u0441\\u043B\\u043E **32** \\u0441 \\u043F\\u043E\\u043C\\u043E\\u0449\\u044C\\u044E **3** \\u0434\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E-\\u0434\\u0432\\u043E\\u0438\\u0447\\u043D\\u044B\\u0445 \\u0447\\u0438\\u0441\\u0435\\u043B: **11111 (31)**, **1 (1)**, **10 (2)**. \\u0412 \\u044D\\u0442\\u043E\\u043C \\u0441\\u043B\\u0443\\u0447\\u0430\\u0435 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0434\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E-\\u0434\\u0432\\u043E\\u0438\\u0447\\u043D\\u044B\\u0445 \\u0447\\u0438\\u0441\\u0435\\u043B, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0435 \\u043D\\u0443\\u0436\\u043D\\u044B \\u0434\\u043B\\u044F \\u043F\\u043E\\u043B\\u0443\\u0447\\u0435\\u043D\\u0438\\u044F **32**, \\u0440\\u0430\\u0432\\u043D\\u043E **3**.\\n\\n### **\\u0410\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F:**\\n\\n##### **1. \\u0418\\u043D\\u0438\\u0446\\u0438\\u0430\\u043B\\u0438\\u0437\\u0438\\u0440\\u0443\\u0439\\u0442\\u0435 \\u043F\\u0435\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u0443\\u044E maxDigit \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C 0.**\\n\\u0414\\u043B\\u044F \\u0442\\u043E\\u0433\\u043E, \\u0447\\u0442\\u043E\\u0431\\u044B \\u043D\\u0430\\u0439\\u0442\\u0438 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0434\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E-\\u0434\\u0432\\u043E\\u0438\\u0447\\u043D\\u044B\\u0445 \\u0447\\u0438\\u0441\\u0435\\u043B, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0435 \\u043D\\u0443\\u0436\\u043D\\u044B \\u0434\\u043B\\u044F \\u043F\\u043E\\u043B\\u0443\\u0447\\u0435\\u043D\\u0438\\u044F **n**, \\u043D\\u0430\\u043C \\u043D\\u0443\\u0436\\u043D\\u043E \\u0437\\u043D\\u0430\\u0442\\u044C, \\u043A\\u0430\\u043A\\u043E\\u0439 \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B \\u0435\\u0441\\u0442\\u044C \\u0432 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0435 **n**. \\u042D\\u0442\\u043E \\u043F\\u043E\\u0437\\u0432\\u043E\\u043B\\u0438\\u0442 \\u043D\\u0430\\u043C \\u0443\\u0437\\u043D\\u0430\\u0442\\u044C, \\u043A\\u0430\\u043A\\u043E\\u0439 \\u0434\\u043E\\u043B\\u0436\\u043D\\u0430 \\u0431\\u044B\\u0442\\u044C \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u0430\\u044F \\u0446\\u0438\\u0444\\u0440\\u0430 \\u0432 \\u0434\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E-\\u0434\\u0432\\u043E\\u0438\\u0447\\u043D\\u044B\\u0445 \\u0447\\u0438\\u0441\\u043B\\u0430\\u0445, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0435 \\u043C\\u044B \\u0431\\u0443\\u0434\\u0435\\u043C \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C. \\u0414\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u043C\\u044B \\u0438\\u043D\\u0438\\u0446\\u0438\\u0430\\u043B\\u0438\\u0437\\u0438\\u0440\\u0443\\u0435\\u043C \\u043F\\u0435\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u0443\\u044E **maxDigit** \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\u043C **0**.\\n##### **2. \\u041F\\u0440\\u043E\\u0445\\u043E\\u0434\\u0438\\u0442\\u0435 \\u043F\\u043E \\u043A\\u0430\\u0436\\u0434\\u043E\\u043C\\u0443 \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u0443 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438 n, \\u0438 \\u0434\\u043B\\u044F \\u043A\\u0430\\u0436\\u0434\\u043E\\u0433\\u043E \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u0430 \\u0432\\u044B\\u043F\\u043E\\u043B\\u043D\\u0438\\u0442\\u0435 \\u0441\\u043B\\u0435\\u0434\\u0443\\u044E\\u0449\\u0438\\u0435 \\u0448\\u0430\\u0433\\u0438:**\\n* \\u041F\\u0440\\u0435\\u043E\\u0431\\u0440\\u0430\\u0437\\u0443\\u0439\\u0442\\u0435 \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B \\u0432 \\u0446\\u0435\\u043B\\u043E\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E \\u0438 \\u0441\\u043E\\u0445\\u0440\\u0430\\u043D\\u0438\\u0442\\u0435 \\u0435\\u0433\\u043E \\u0432 \\u043F\\u0435\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u0443\\u044E **digit**.\\n* \\u0415\\u0441\\u043B\\u0438 **digit** \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435 **maxDigit**, \\u043E\\u0431\\u043D\\u043E\\u0432\\u0438\\u0442\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 **maxDigit**.\\n\\n\\u0414\\u0430\\u043B\\u0435\\u0435, \\u043C\\u044B \\u043F\\u0440\\u043E\\u0445\\u043E\\u0434\\u0438\\u043C \\u043F\\u043E \\u043A\\u0430\\u0436\\u0434\\u043E\\u043C\\u0443 \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u0443 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438 **n**, \\u0438 \\u0434\\u043B\\u044F \\u043A\\u0430\\u0436\\u0434\\u043E\\u0433\\u043E \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u0430 \\u043C\\u044B \\u0434\\u0435\\u043B\\u0430\\u0435\\u043C \\u0441\\u043B\\u0435\\u0434\\u0443\\u044E\\u0449\\u0435\\u0435:\\n\\n* \\u041F\\u0440\\u0435\\u043E\\u0431\\u0440\\u0430\\u0437\\u0443\\u0435\\u043C \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B \\u0432 \\u0446\\u0435\\u043B\\u043E\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E \\u0438 \\u0441\\u043E\\u0445\\u0440\\u0430\\u043D\\u044F\\u0435\\u043C \\u0435\\u0433\\u043E \\u0432 \\u043F\\u0435\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u0443\\u044E **digit**.\\n* \\u0415\\u0441\\u043B\\u0438 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 **digit** \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435 \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0433\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u044F **maxDigit**, \\u043C\\u044B \\u043E\\u0431\\u043D\\u043E\\u0432\\u043B\\u044F\\u0435\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 **maxDigit**.\\n\\n\\u0422\\u0430\\u043A\\u0438\\u043C \\u043E\\u0431\\u0440\\u0430\\u0437\\u043E\\u043C, \\u043F\\u043E\\u0441\\u043B\\u0435 \\u0437\\u0430\\u0432\\u0435\\u0440\\u0448\\u0435\\u043D\\u0438\\u044F \\u0446\\u0438\\u043A\\u043B\\u0430 \\u043F\\u043E \\u0441\\u0442\\u0440\\u043E\\u043A\\u0435 **n** \\u043C\\u044B \\u043F\\u043E\\u043B\\u0443\\u0447\\u0438\\u043C \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u0435\\u0441\\u0442\\u044C \\u0432 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0435. \\u042D\\u0442\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 \\u043F\\u043E\\u043A\\u0430\\u0436\\u0435\\u0442 \\u043D\\u0430\\u043C, \\u043A\\u0430\\u043A\\u0443\\u044E \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u0443\\u044E \\u0446\\u0438\\u0444\\u0440\\u0443 \\u043C\\u044B \\u043C\\u043E\\u0436\\u0435\\u043C \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C \\u043F\\u0440\\u0438 \\u043F\\u043E\\u0441\\u0442\\u0440\\u043E\\u0435\\u043D\\u0438\\u0438 \\u0434\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E-\\u0434\\u0432\\u043E\\u0438\\u0447\\u043D\\u044B\\u0445 \\u0447\\u0438\\u0441\\u0435\\u043B.\\n\\n##### **3. \\u0412\\u0435\\u0440\\u043D\\u0438\\u0442\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 maxDigit.**\\n\\n\\u041F\\u043E\\u0441\\u043B\\u0435 \\u0442\\u043E\\u0433\\u043E, \\u043A\\u0430\\u043A \\u043C\\u044B \\u043F\\u043E\\u043B\\u0443\\u0447\\u0438\\u043B\\u0438 \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B \\u0432 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0435 **n**, \\u043C\\u044B \\u0432\\u043E\\u0437\\u0432\\u0440\\u0430\\u0449\\u0430\\u0435\\u043C \\u0435\\u0433\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435. \\u042D\\u0442\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 \\u043F\\u043E\\u043A\\u0430\\u0437\\u044B\\u0432\\u0430\\u0435\\u0442, \\u043A\\u0430\\u043A\\u0443\\u044E \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u0443\\u044E \\u0446\\u0438\\u0444\\u0440\\u0443 \\u043C\\u044B \\u043C\\u043E\\u0436\\u0435\\u043C \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C \\u043F\\u0440\\u0438 \\u043F\\u043E\\u0441\\u0442\\u0440\\u043E\\u0435\\u043D\\u0438\\u0438 \\u0434\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E-\\u0434\\u0432\\u043E\\u0438\\u0447\\u043D\\u044B\\u0445 \\u0447\\u0438\\u0441\\u0435\\u043B.\\n\\n### **\\u041F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0440\\u0430\\u0431\\u043E\\u0442\\u044B \\u0430\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C\\u0430:**\\n\\n**\\u041F\\u0443\\u0441\\u0442\\u044C n = \"32\".**\\n\\n\\u041C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u044B\\u0439 \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B \\u0432 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0435 **n** \\u0440\\u0430\\u0432\\u0435\\u043D **3**, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u043C\\u044B \\u043C\\u043E\\u0436\\u0435\\u043C \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0446\\u0438\\u0444\\u0440\\u044B **0**, **1**, **2** \\u0438 **3** \\u043F\\u0440\\u0438 \\u043F\\u043E\\u0441\\u0442\\u0440\\u043E\\u0435\\u043D\\u0438\\u0438 \\u0434\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E-\\u0434\\u0432\\u043E\\u0438\\u0447\\u043D\\u044B\\u0445 \\u0447\\u0438\\u0441\\u0435\\u043B.\\n\\n\\u041C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u0434\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E-\\u0434\\u0432\\u043E\\u0438\\u0447\\u043D\\u043E\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E, \\u043A\\u043E\\u0442\\u043E\\u0440\\u043E\\u0435 \\u043C\\u043E\\u0436\\u043D\\u043E \\u043F\\u043E\\u043B\\u0443\\u0447\\u0438\\u0442\\u044C, \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u0443\\u044F \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u044D\\u0442\\u0438 \\u0446\\u0438\\u0444\\u0440\\u044B, \\u0440\\u0430\\u0432\\u043D\\u043E **11** (**3** \\u0432 \\u0434\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E\\u0439 \\u0441\\u0438\\u0441\\u0442\\u0435\\u043C\\u0435 \\u0441\\u0447\\u0438\\u0441\\u043B\\u0435\\u043D\\u0438\\u044F).\\n\\n\\u041F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u0434\\u0435\\u0441\\u044F\\u0442\\u0438\\u0447\\u043D\\u043E-\\u0434\\u0432\\u043E\\u0438\\u0447\\u043D\\u044B\\u0445 \\u0447\\u0438\\u0441\\u0435\\u043B, \\u043D\\u0435\\u043E\\u0431\\u0445\\u043E\\u0434\\u0438\\u043C\\u044B\\u0445 \\u0434\\u043B\\u044F \\u043F\\u043E\\u043B\\u0443\\u0447\\u0435\\u043D\\u0438\\u044F \\u0447\\u0438\\u0441\\u043B\\u0430 **32**, \\u0440\\u0430\\u0432\\u043D\\u043E **3**.\\n\\n*P.S.\\n\\u042F \\u043D\\u0430\\u0434\\u0435\\u044E\\u0441\\u044C, \\u0447\\u0442\\u043E \\u043E\\u0431\\u044A\\u044F\\u0441\\u043D\\u0435\\u043D\\u0438\\u0435 \\u0430\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C\\u0430 \\u0431\\u044B\\u043B\\u043E \\u043F\\u043E\\u043D\\u044F\\u0442\\u043D\\u044B\\u043C \\u0438 \\u043F\\u043E\\u043B\\u0435\\u0437\\u043D\\u044B\\u043C! \\u0415\\u0441\\u043B\\u0438 \\u0443 \\u0412\\u0430\\u0441 \\u0435\\u0441\\u0442\\u044C \\u043A\\u0430\\u043A\\u0438\\u0435-\\u0442\\u043E \\u0434\\u043E\\u043F\\u043E\\u043B\\u043D\\u0438\\u0442\\u0435\\u043B\\u044C\\u043D\\u044B\\u0435 \\u0432\\u043E\\u043F\\u0440\\u043E\\u0441\\u044B, \\u043D\\u0435 \\u0441\\u0442\\u0435\\u0441\\u043D\\u044F\\u0439\\u0442\\u0435\\u0441\\u044C \\u0441\\u043F\\u0440\\u0430\\u0448\\u0438\\u0432\\u0430\\u0442\\u044C.*\\n\\n# Complexity\\n- Time complexity:\\n**O(n)**, \\u0433\\u0434\\u0435 **n** - \\u0434\\u043B\\u0438\\u043D\\u0430 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438 **n**. \\u042D\\u0442\\u043E \\u043F\\u043E\\u0442\\u043E\\u043C\\u0443, \\u0447\\u0442\\u043E \\u043C\\u044B \\u043F\\u0440\\u043E\\u0445\\u043E\\u0434\\u0438\\u043C \\u043F\\u043E \\u043A\\u0430\\u0436\\u0434\\u043E\\u043C\\u0443 \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u0443 \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438 n \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043E\\u0434\\u0438\\u043D \\u0440\\u0430\\u0437.\\n\\n- Space complexity:\\n**O(1)**, \\u0442\\u0430\\u043A \\u043A\\u0430\\u043A \\u043C\\u044B \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u0443\\u0435\\u043C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u043F\\u0435\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u044B\\u0445 \\u0444\\u0438\\u043A\\u0441\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u043E\\u0433\\u043E \\u0440\\u0430\\u0437\\u043C\\u0435\\u0440\\u0430 **(maxDigit, digit)**, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0435 \\u043D\\u0435 \\u0437\\u0430\\u0432\\u0438\\u0441\\u044F\\u0442 \\u043E\\u0442 \\u0434\\u043B\\u0438\\u043D\\u044B \\u0441\\u0442\\u0440\\u043E\\u043A\\u0438 **n**. \\u0422\\u0430\\u043A\\u0438\\u043C \\u043E\\u0431\\u0440\\u0430\\u0437\\u043E\\u043C, \\u043D\\u0435\\u0437\\u0430\\u0432\\u0438\\u0441\\u0438\\u043C\\u043E \\u043E\\u0442 \\u0440\\u0430\\u0437\\u043C\\u0435\\u0440\\u0430 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0434\\u0430\\u043D\\u043D\\u044B\\u0445, \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u0443\\u0435\\u043C\\u0430\\u044F \\u043F\\u0430\\u043C\\u044F\\u0442\\u044C \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043E\\u0434\\u0438\\u043D\\u0430\\u043A\\u043E\\u0432\\u043E\\u0439.\\n\\n# Code\\n```\\nfunc minPartitions(n string) int {\\n    maxDigit := 0\\n    for i := 0; i < len(n); i++ {\\n        digit := int(n[i] - \\'0\\')\\n        if digit > maxDigit {\\n            maxDigit = digit\\n        }\\n    }\\n    return maxDigit\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nfunc minPartitions(n string) int {\\n    maxDigit := 0\\n    for i := 0; i < len(n); i++ {\\n        digit := int(n[i] - \\'0\\')\\n        if digit > maxDigit {\\n            maxDigit = digit\\n        }\\n    }\\n    return maxDigit\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3398651,
                "title": "very-simple-solution-on-python3",
                "content": "# Intuition\\n# ***The largest digit in the number will determine the number of binary terms.***\\n\\n---\\n\\n\\nFor example:\\n574**9**3\\n$=$\\n11111 <- 1\\n$+$\\n11111 <- 2\\n$+$\\n11111 <- 3\\n$+$\\n11110 <- 4\\n$+$\\n11010 <- 5\\n$+$\\n01010 <- 6\\n$+$\\n01010 <- 7\\n$+$\\n00010 <- 8\\n$+$\\n00010 <- **9**\\n\\n# Approach\\n*Strings in Python will be compared character by character, i.e. **\"2\" > \"10\"**, since 2 > 1.\\n**But** since we only need to compare 1 digit, **we can use the max() function without changing the string type to int**.*\\n\\n# Complexity\\nThe complexity of the algorithm will be determined by the complexity of the built-in max() function.\\n- Time complexity:\\n$$O(1)$$ *<->* $$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ *<->* $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n))\\n```\\n# ***Please vote for this solution!***",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268699,
                "title": "max-digit",
                "content": "\\n# Code\\n```\\nfunction minPartitions(n: string): number {\\n    let result = 0;\\n    for(let i = 0; i<n.length;i++){\\n        if(+n[i]>result) result =+n[i]\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minPartitions(n: string): number {\\n    let result = 0;\\n    for(let i = 0; i<n.length;i++){\\n        if(+n[i]>result) result =+n[i]\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3255808,
                "title": "easy-2-line-code-in-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        sort(n.begin(),n.end());\\n        int ans=n[n.size()-1]-\\'0\\';\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        sort(n.begin(),n.end());\\n        int ans=n[n.size()-1]-\\'0\\';\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222204,
                "title": "easy-c-greedy",
                "content": "# Intuition\\nMaximum digit will be the answer\\n\\n# Approach\\nwe can either sum with 100000 and 1111. we can make 9 in \\'9\\' step by using 1.\\n\\neg:-\\n2345 = 1111 + 1111 + 0111 + 0011 + 0001\\n\\nwe can observe that answer is the maximum char of the string\\n\\n \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=0;\\n        for(auto i:n){\\n            ans=max(i-\\'0\\',ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int ans=0;\\n        for(auto i:n){\\n            ans=max(i-\\'0\\',ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219267,
                "title": "simple-and-short-o-n-time-complexity-and-o-1-space-complexity",
                "content": "# Intuition\\nsubtract \\'0\\' from every character to convert char to int and just take max of all the numbers \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int maxi=0;\\n        for(int i=0;i<n.size();i++){\\n            char c=n[i];\\n            maxi=max(maxi,int(c-\\'0\\'));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int maxi=0;\\n        for(int i=0;i<n.size();i++){\\n            char c=n[i];\\n            maxi=max(maxi,int(c-\\'0\\'));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048667,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045995,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        x=0\\n        for i in n:\\n            x=max(x,int(i))\\n        return x\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        x=0\\n        for i in n:\\n            x=max(x,int(i))\\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939429,
                "title": "c-2-line-logic-simple-code-99-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//just return maximum in given string.\\nclass Solution {\\npublic: int mx=0;\\nint minPartitions(string n) \\n  {\\n    for(int i=0;i<n.length();i++)\\n    {\\n      mx=max(mx,n[i]-\\'0\\');\\n    }\\n  return mx;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//just return maximum in given string.\\nclass Solution {\\npublic: int mx=0;\\nint minPartitions(string n) \\n  {\\n    for(int i=0;i<n.length();i++)\\n    {\\n      mx=max(mx,n[i]-\\'0\\');\\n    }\\n  return mx;\\n  }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1757188,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1786996,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1575309,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1575313,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1566725,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1570556,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1986495,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1707556,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1838865,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1576916,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1757188,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1786996,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1575309,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1575313,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1566725,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1570556,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1986495,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1707556,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1838865,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1576916,
                "content": [
                    {
                        "username": "Pengu_98",
                        "content": "can\\'t believe it has been marked as Medium. It\\'s easier than the Easy questions."
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "I was about to write the same comment. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "How can so many say this question is easy??? "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "The implementation is easy, but how can prove that the highest number in the string is the answer?"
                    },
                    {
                        "username": "citaces",
                        "content": "[@Mister_CK](/Mister_CK) man, I was already very disappointed with this task because I could not pass the 66th test. My solution with jetbrains IDE test had 2.1 seconds, which was considered a lot. I did not immediately notice the logic you are talking about and iterated over in a loop in the buffer, and subtracted it recursively. Horror)) did not know how to optimize. It turned out to be much easier..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Because if you look at the three test cases you can see that every time the highest number in the string is the answer they return, which makes sense intuitively. So I took 1 minute to write a function that returns the highest number in a string and spend another minute trying to come up with a couple of test cases. everything passed. So in my opinion it is a very easy question. Why do you think it isn't?"
                    },
                    {
                        "username": "pp423",
                        "content": "I noticed that in the solution provided by Leetcode for this problem, they use the `string.toCharArray()` method to convert the input string to a char array:\\n![image](https://assets.leetcode.com/users/images/693638d6-58a0-4983-b558-e2a4ca9e089f_1622036152.0824442.png)\\n\\nThey describe the space complexity as `O(1)`:\\n![image](https://assets.leetcode.com/users/images/f5d01e45-7f2c-47bb-97ff-bc0a550f7f7c_1622036168.7543108.png)\\n\\nThis seems incorrect since this method returns a newly allocated character array  of size equal to that of input string. So, the space complexity should rightly be `O(n)`."
                    },
                    {
                        "username": "aaabramov",
                        "content": "You are totally correct!"
                    },
                    {
                        "username": "SunnyGupta",
                        "content": "Just return the maximum digit present. \\nThanks!\\n\\nTBH, I started to thing up complex things about this question until I read some hints and bingo I was there with the solution.\\nSo, lets take an example of n=\"1342\"\\nSo what do we want, we want minimum deci-binary numbers to sum upto this.\\n\\nLets there be 4 numbers:\\n1111\\n0111\\n0110\\n0010\\n\\nSum of these numbers gives us 1342. So basically we require maximum digit number of numbers of deci-binary numbers to achieve this feat."
                    },
                    {
                        "username": "rsmit11",
                        "content": "two of those have leading zeroes though, so how is that valid?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Math\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arjun9000",
                        "content": "Can anybody explain why the largest number is the answer here?"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@SanskarBabel](/SanskarBabel) how to found it"
                    },
                    {
                        "username": "Wetooa",
                        "content": "basic idea is we can only have either a 1 or a 0 as the digit, so the digits in \"n\" can only decrement at most by 1"
                    },
                    {
                        "username": "SanskarBabel",
                        "content": "given example 82734 we have to add \\n11111\\n11111\\n10111\\n10101\\n10100\\n10100\\n10100\\n10000\\n_______\\n82734\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "100% of those who write `easy` noticed that the output is the biggest number of a string, but how it works only 1 % of them know, the rest 99% just had a random match, without understanding the concept. \nYes, you are very smart, take that candy. Wish, good luck doing this on an interview. Hope they will provide examples for you to notice the highest number in the string, without knowing why and how it behaves like this. Otherwise GGWP. "
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "cope lmao"
                    },
                    {
                        "username": "shahan989",
                        "content": "I looked at it from another perspective (reverse) like how can I make the given value zero. Now to do so I must decrement it by maximum possible number but we have condition that we can only use 1/0 digits and using that I was able to find my proof. \n\nEach time I decrement my given value, I can only use 1 and 0 in the place and this will then keep on going. The last round before the value become 0 will be when the position where the max digits were placed at will be with 1s. \n\nHence, we end up with rounds which is equal to max, as that is the last value to die last and we can only reduce it each round by decrementing it by 1 until we finally remove it and turn into 0. That's it will take us max times as it each round we can only decrement it by 1 and so the number of rounds we need to make it 0 will be max times."
                    },
                    {
                        "username": "kmp1084",
                        "content": "For this question the hint is not at all a hint, it should just be called the answer!"
                    },
                    {
                        "username": "iamdejan",
                        "content": "Looks like the hint is removed in February 2023"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "the problem description was not clear, so I looked at the discussion to understand what deci-binary is, but unfortunately, I saw the answer while reading.\\n\\nyou have a decimal number as an input, and you want to find the minimum partitions of deci-binary.\\n\\ndeci-binary is a number that consists of only 0 and 1.\\nfor example 32 is sum of 10 + 11 + 11\\n\\nyou can\\'t have 12+20 because a deci-binary consists of only zeros and ones.\\n\\n\\nfor n = 10\\ndeci binary partitions of 1+1+1+1+1+1+1+1+1+1 is valid, but it\\'s not the answer you\\'re looking for, because you\\'re looking for the minimum partition.\\n\\nthe minimum partition should be 10 (only one partition, so the answer is one)."
                    },
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "Sure doesn\\'t seem like it?"
                    }
                ]
            },
            {
                "id": 1767349,
                "content": [
                    {
                        "username": "adis176",
                        "content": "Guys, the best hint here would be to take a few random cases, try to solve them.\\nAlso, the given test case - 27346209830709182346 is enough of a hint."
                    },
                    {
                        "username": "accessarijit",
                        "content": "The only thing that you need to note in this problem is that the min. number of deci-binary numbers needed is equal to the maximum digit there in the string ;)"
                    },
                    {
                        "username": "stick109",
                        "content": "Not sure how this is \"medium\". This should be marked \"easy\". Took 1 minute and 3 lines of code."
                    },
                    {
                        "username": "saikat2300",
                        "content": "run a loop through the string. must remember here \\'n\\' is a string :)"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest Question on this platform lol"
                    },
                    {
                        "username": "kumkum13",
                        "content": "class Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int m=0;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]>m){\\n                m = n[i];\\n            }\\n            if(m==\\'9\\'){\\n                return 9;\\n            }\\n        }\\n        return (m-\\'0\\' );\\n    }\\n};"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just return the highest digit in the string, because that many ones you would need, like if its 7, you would need seven 1s in the adding number at that position"
                    },
                    {
                        "username": "kaprister07",
                        "content": "I don\\'t know why this question is medium level this is very easy question,\\nwe have to return the maximum number in the string...."
                    },
                    {
                        "username": "abhishek_raut2355",
                        "content": "This was a very simple and interesting question. We have to just return Max(digit) in a given string."
                    },
                    {
                        "username": "adis176",
                        "content": "This should have been marked as an easy question in my opinion."
                    }
                ]
            },
            {
                "id": 1575757,
                "content": [
                    {
                        "username": "adis176",
                        "content": "Guys, the best hint here would be to take a few random cases, try to solve them.\\nAlso, the given test case - 27346209830709182346 is enough of a hint."
                    },
                    {
                        "username": "accessarijit",
                        "content": "The only thing that you need to note in this problem is that the min. number of deci-binary numbers needed is equal to the maximum digit there in the string ;)"
                    },
                    {
                        "username": "stick109",
                        "content": "Not sure how this is \"medium\". This should be marked \"easy\". Took 1 minute and 3 lines of code."
                    },
                    {
                        "username": "saikat2300",
                        "content": "run a loop through the string. must remember here \\'n\\' is a string :)"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest Question on this platform lol"
                    },
                    {
                        "username": "kumkum13",
                        "content": "class Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int m=0;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]>m){\\n                m = n[i];\\n            }\\n            if(m==\\'9\\'){\\n                return 9;\\n            }\\n        }\\n        return (m-\\'0\\' );\\n    }\\n};"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just return the highest digit in the string, because that many ones you would need, like if its 7, you would need seven 1s in the adding number at that position"
                    },
                    {
                        "username": "kaprister07",
                        "content": "I don\\'t know why this question is medium level this is very easy question,\\nwe have to return the maximum number in the string...."
                    },
                    {
                        "username": "abhishek_raut2355",
                        "content": "This was a very simple and interesting question. We have to just return Max(digit) in a given string."
                    },
                    {
                        "username": "adis176",
                        "content": "This should have been marked as an easy question in my opinion."
                    }
                ]
            },
            {
                "id": 1575477,
                "content": [
                    {
                        "username": "adis176",
                        "content": "Guys, the best hint here would be to take a few random cases, try to solve them.\\nAlso, the given test case - 27346209830709182346 is enough of a hint."
                    },
                    {
                        "username": "accessarijit",
                        "content": "The only thing that you need to note in this problem is that the min. number of deci-binary numbers needed is equal to the maximum digit there in the string ;)"
                    },
                    {
                        "username": "stick109",
                        "content": "Not sure how this is \"medium\". This should be marked \"easy\". Took 1 minute and 3 lines of code."
                    },
                    {
                        "username": "saikat2300",
                        "content": "run a loop through the string. must remember here \\'n\\' is a string :)"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest Question on this platform lol"
                    },
                    {
                        "username": "kumkum13",
                        "content": "class Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int m=0;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]>m){\\n                m = n[i];\\n            }\\n            if(m==\\'9\\'){\\n                return 9;\\n            }\\n        }\\n        return (m-\\'0\\' );\\n    }\\n};"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just return the highest digit in the string, because that many ones you would need, like if its 7, you would need seven 1s in the adding number at that position"
                    },
                    {
                        "username": "kaprister07",
                        "content": "I don\\'t know why this question is medium level this is very easy question,\\nwe have to return the maximum number in the string...."
                    },
                    {
                        "username": "abhishek_raut2355",
                        "content": "This was a very simple and interesting question. We have to just return Max(digit) in a given string."
                    },
                    {
                        "username": "adis176",
                        "content": "This should have been marked as an easy question in my opinion."
                    }
                ]
            },
            {
                "id": 2063808,
                "content": [
                    {
                        "username": "adis176",
                        "content": "Guys, the best hint here would be to take a few random cases, try to solve them.\\nAlso, the given test case - 27346209830709182346 is enough of a hint."
                    },
                    {
                        "username": "accessarijit",
                        "content": "The only thing that you need to note in this problem is that the min. number of deci-binary numbers needed is equal to the maximum digit there in the string ;)"
                    },
                    {
                        "username": "stick109",
                        "content": "Not sure how this is \"medium\". This should be marked \"easy\". Took 1 minute and 3 lines of code."
                    },
                    {
                        "username": "saikat2300",
                        "content": "run a loop through the string. must remember here \\'n\\' is a string :)"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest Question on this platform lol"
                    },
                    {
                        "username": "kumkum13",
                        "content": "class Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int m=0;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]>m){\\n                m = n[i];\\n            }\\n            if(m==\\'9\\'){\\n                return 9;\\n            }\\n        }\\n        return (m-\\'0\\' );\\n    }\\n};"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just return the highest digit in the string, because that many ones you would need, like if its 7, you would need seven 1s in the adding number at that position"
                    },
                    {
                        "username": "kaprister07",
                        "content": "I don\\'t know why this question is medium level this is very easy question,\\nwe have to return the maximum number in the string...."
                    },
                    {
                        "username": "abhishek_raut2355",
                        "content": "This was a very simple and interesting question. We have to just return Max(digit) in a given string."
                    },
                    {
                        "username": "adis176",
                        "content": "This should have been marked as an easy question in my opinion."
                    }
                ]
            },
            {
                "id": 1970183,
                "content": [
                    {
                        "username": "adis176",
                        "content": "Guys, the best hint here would be to take a few random cases, try to solve them.\\nAlso, the given test case - 27346209830709182346 is enough of a hint."
                    },
                    {
                        "username": "accessarijit",
                        "content": "The only thing that you need to note in this problem is that the min. number of deci-binary numbers needed is equal to the maximum digit there in the string ;)"
                    },
                    {
                        "username": "stick109",
                        "content": "Not sure how this is \"medium\". This should be marked \"easy\". Took 1 minute and 3 lines of code."
                    },
                    {
                        "username": "saikat2300",
                        "content": "run a loop through the string. must remember here \\'n\\' is a string :)"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest Question on this platform lol"
                    },
                    {
                        "username": "kumkum13",
                        "content": "class Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int m=0;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]>m){\\n                m = n[i];\\n            }\\n            if(m==\\'9\\'){\\n                return 9;\\n            }\\n        }\\n        return (m-\\'0\\' );\\n    }\\n};"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just return the highest digit in the string, because that many ones you would need, like if its 7, you would need seven 1s in the adding number at that position"
                    },
                    {
                        "username": "kaprister07",
                        "content": "I don\\'t know why this question is medium level this is very easy question,\\nwe have to return the maximum number in the string...."
                    },
                    {
                        "username": "abhishek_raut2355",
                        "content": "This was a very simple and interesting question. We have to just return Max(digit) in a given string."
                    },
                    {
                        "username": "adis176",
                        "content": "This should have been marked as an easy question in my opinion."
                    }
                ]
            },
            {
                "id": 1968204,
                "content": [
                    {
                        "username": "adis176",
                        "content": "Guys, the best hint here would be to take a few random cases, try to solve them.\\nAlso, the given test case - 27346209830709182346 is enough of a hint."
                    },
                    {
                        "username": "accessarijit",
                        "content": "The only thing that you need to note in this problem is that the min. number of deci-binary numbers needed is equal to the maximum digit there in the string ;)"
                    },
                    {
                        "username": "stick109",
                        "content": "Not sure how this is \"medium\". This should be marked \"easy\". Took 1 minute and 3 lines of code."
                    },
                    {
                        "username": "saikat2300",
                        "content": "run a loop through the string. must remember here \\'n\\' is a string :)"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest Question on this platform lol"
                    },
                    {
                        "username": "kumkum13",
                        "content": "class Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int m=0;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]>m){\\n                m = n[i];\\n            }\\n            if(m==\\'9\\'){\\n                return 9;\\n            }\\n        }\\n        return (m-\\'0\\' );\\n    }\\n};"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just return the highest digit in the string, because that many ones you would need, like if its 7, you would need seven 1s in the adding number at that position"
                    },
                    {
                        "username": "kaprister07",
                        "content": "I don\\'t know why this question is medium level this is very easy question,\\nwe have to return the maximum number in the string...."
                    },
                    {
                        "username": "abhishek_raut2355",
                        "content": "This was a very simple and interesting question. We have to just return Max(digit) in a given string."
                    },
                    {
                        "username": "adis176",
                        "content": "This should have been marked as an easy question in my opinion."
                    }
                ]
            },
            {
                "id": 1895991,
                "content": [
                    {
                        "username": "adis176",
                        "content": "Guys, the best hint here would be to take a few random cases, try to solve them.\\nAlso, the given test case - 27346209830709182346 is enough of a hint."
                    },
                    {
                        "username": "accessarijit",
                        "content": "The only thing that you need to note in this problem is that the min. number of deci-binary numbers needed is equal to the maximum digit there in the string ;)"
                    },
                    {
                        "username": "stick109",
                        "content": "Not sure how this is \"medium\". This should be marked \"easy\". Took 1 minute and 3 lines of code."
                    },
                    {
                        "username": "saikat2300",
                        "content": "run a loop through the string. must remember here \\'n\\' is a string :)"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest Question on this platform lol"
                    },
                    {
                        "username": "kumkum13",
                        "content": "class Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int m=0;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]>m){\\n                m = n[i];\\n            }\\n            if(m==\\'9\\'){\\n                return 9;\\n            }\\n        }\\n        return (m-\\'0\\' );\\n    }\\n};"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just return the highest digit in the string, because that many ones you would need, like if its 7, you would need seven 1s in the adding number at that position"
                    },
                    {
                        "username": "kaprister07",
                        "content": "I don\\'t know why this question is medium level this is very easy question,\\nwe have to return the maximum number in the string...."
                    },
                    {
                        "username": "abhishek_raut2355",
                        "content": "This was a very simple and interesting question. We have to just return Max(digit) in a given string."
                    },
                    {
                        "username": "adis176",
                        "content": "This should have been marked as an easy question in my opinion."
                    }
                ]
            },
            {
                "id": 1846155,
                "content": [
                    {
                        "username": "adis176",
                        "content": "Guys, the best hint here would be to take a few random cases, try to solve them.\\nAlso, the given test case - 27346209830709182346 is enough of a hint."
                    },
                    {
                        "username": "accessarijit",
                        "content": "The only thing that you need to note in this problem is that the min. number of deci-binary numbers needed is equal to the maximum digit there in the string ;)"
                    },
                    {
                        "username": "stick109",
                        "content": "Not sure how this is \"medium\". This should be marked \"easy\". Took 1 minute and 3 lines of code."
                    },
                    {
                        "username": "saikat2300",
                        "content": "run a loop through the string. must remember here \\'n\\' is a string :)"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest Question on this platform lol"
                    },
                    {
                        "username": "kumkum13",
                        "content": "class Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int m=0;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]>m){\\n                m = n[i];\\n            }\\n            if(m==\\'9\\'){\\n                return 9;\\n            }\\n        }\\n        return (m-\\'0\\' );\\n    }\\n};"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just return the highest digit in the string, because that many ones you would need, like if its 7, you would need seven 1s in the adding number at that position"
                    },
                    {
                        "username": "kaprister07",
                        "content": "I don\\'t know why this question is medium level this is very easy question,\\nwe have to return the maximum number in the string...."
                    },
                    {
                        "username": "abhishek_raut2355",
                        "content": "This was a very simple and interesting question. We have to just return Max(digit) in a given string."
                    },
                    {
                        "username": "adis176",
                        "content": "This should have been marked as an easy question in my opinion."
                    }
                ]
            },
            {
                "id": 1807923,
                "content": [
                    {
                        "username": "adis176",
                        "content": "Guys, the best hint here would be to take a few random cases, try to solve them.\\nAlso, the given test case - 27346209830709182346 is enough of a hint."
                    },
                    {
                        "username": "accessarijit",
                        "content": "The only thing that you need to note in this problem is that the min. number of deci-binary numbers needed is equal to the maximum digit there in the string ;)"
                    },
                    {
                        "username": "stick109",
                        "content": "Not sure how this is \"medium\". This should be marked \"easy\". Took 1 minute and 3 lines of code."
                    },
                    {
                        "username": "saikat2300",
                        "content": "run a loop through the string. must remember here \\'n\\' is a string :)"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest Question on this platform lol"
                    },
                    {
                        "username": "kumkum13",
                        "content": "class Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int m=0;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]>m){\\n                m = n[i];\\n            }\\n            if(m==\\'9\\'){\\n                return 9;\\n            }\\n        }\\n        return (m-\\'0\\' );\\n    }\\n};"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just return the highest digit in the string, because that many ones you would need, like if its 7, you would need seven 1s in the adding number at that position"
                    },
                    {
                        "username": "kaprister07",
                        "content": "I don\\'t know why this question is medium level this is very easy question,\\nwe have to return the maximum number in the string...."
                    },
                    {
                        "username": "abhishek_raut2355",
                        "content": "This was a very simple and interesting question. We have to just return Max(digit) in a given string."
                    },
                    {
                        "username": "adis176",
                        "content": "This should have been marked as an easy question in my opinion."
                    }
                ]
            },
            {
                "id": 1767350,
                "content": [
                    {
                        "username": "adis176",
                        "content": "Guys, the best hint here would be to take a few random cases, try to solve them.\\nAlso, the given test case - 27346209830709182346 is enough of a hint."
                    },
                    {
                        "username": "accessarijit",
                        "content": "The only thing that you need to note in this problem is that the min. number of deci-binary numbers needed is equal to the maximum digit there in the string ;)"
                    },
                    {
                        "username": "stick109",
                        "content": "Not sure how this is \"medium\". This should be marked \"easy\". Took 1 minute and 3 lines of code."
                    },
                    {
                        "username": "saikat2300",
                        "content": "run a loop through the string. must remember here \\'n\\' is a string :)"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Easiest Question on this platform lol"
                    },
                    {
                        "username": "kumkum13",
                        "content": "class Solution {\\npublic:\\n    int minPartitions(string n) {\\n        int m=0;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]>m){\\n                m = n[i];\\n            }\\n            if(m==\\'9\\'){\\n                return 9;\\n            }\\n        }\\n        return (m-\\'0\\' );\\n    }\\n};"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just return the highest digit in the string, because that many ones you would need, like if its 7, you would need seven 1s in the adding number at that position"
                    },
                    {
                        "username": "kaprister07",
                        "content": "I don\\'t know why this question is medium level this is very easy question,\\nwe have to return the maximum number in the string...."
                    },
                    {
                        "username": "abhishek_raut2355",
                        "content": "This was a very simple and interesting question. We have to just return Max(digit) in a given string."
                    },
                    {
                        "username": "adis176",
                        "content": "This should have been marked as an easy question in my opinion."
                    }
                ]
            }
        ]
    }
]