[
    {
        "title": "Find Subarrays With Equal Sum",
        "question_content": "Given a 0-indexed integer array nums, determine whether there exist two subarrays of length 2 with equal sum. Note that the two subarrays must begin at different indices.\nReturn true if these subarrays exist, and false otherwise.\nA subarray is a contiguous non-empty sequence of elements within an array.\n&nbsp;\nExample 1:\n\nInput: nums = [4,2,4]\nOutput: true\nExplanation: The subarrays with elements [4,2] and [2,4] have the same sum of 6.\n\nExample 2:\n\nInput: nums = [1,2,3,4,5]\nOutput: false\nExplanation: No two subarrays of size 2 have the same sum.\n\nExample 3:\n\nInput: nums = [0,0,0]\nOutput: true\nExplanation: The subarrays [nums[0],nums[1]] and [nums[1],nums[2]] have the same sum of 0. \nNote that even though the subarrays have the same content, the two subarrays are considered different because they are in different positions in the original array.\n\n&nbsp;\nConstraints:\n\n\t2 <= nums.length <= 1000\n\t-109 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 2524729,
                "title": "hash-set",
                "content": "**C++**\\n```cpp\\nbool findSubarrays(vector<int>& nums) {\\n    unordered_set<int> s;\\n    for (int i = 1; i < nums.size(); ++i)\\n        if(!s.insert(nums[i - 1] + nums[i]).second)\\n            return true;\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool findSubarrays(vector<int>& nums) {\\n    unordered_set<int> s;\\n    for (int i = 1; i < nums.size(); ++i)\\n        if(!s.insert(nums[i - 1] + nums[i]).second)\\n            return true;\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2525203,
                "title": "c-brute-optimal-approaches",
                "content": "**C++:** (**Brute Approach**)\\n```\\nclass Solution {\\npublic:\\n\\tbool findSubarrays(vector<int>& nums) {\\n\\t\\tint n=nums.size();\\n\\t\\tint count=0;\\n\\t\\tfor(int i=0;i<n-1;i++){\\n\\t\\t\\tfor(int j=i+1;j<n-1;j++){\\n\\t\\t\\t\\tif(nums[j]+nums[j+1]==nums[i]+nums[i+1]) count++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count>=1;\\n\\t}\\n};\\n```\\n****\\n**Time Complexity:** **O(N^2)**\\n**Space Complexity:** **O(N)**\\n****\\n**C++:** (**Hashmap Approach**)\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        for(int i=1;i<n;i++){\\n            int sum = nums[i]+nums[i-1];\\n            mp[sum]++;\\n            if(mp[sum]>1) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(N)**\\n**Space Complexity:** **O(N)**\\n****",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool findSubarrays(vector<int>& nums) {\\n\\t\\tint n=nums.size();\\n\\t\\tint count=0;\\n\\t\\tfor(int i=0;i<n-1;i++){\\n\\t\\t\\tfor(int j=i+1;j<n-1;j++){\\n\\t\\t\\t\\tif(nums[j]+nums[j+1]==nums[i]+nums[i+1]) count++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count>=1;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        for(int i=1;i<n;i++){\\n            int sum = nums[i]+nums[i-1];\\n            mp[sum]++;\\n            if(mp[sum]>1) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525005,
                "title": "python-99-97-with-comments",
                "content": "**Approach:**\\n --> As there is sub-array of len 2, we use set and store sum by going through first pass only.\\n--- > If we encouter same sum then just simply return **True** otherwise by end of that pass return **False**.\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        sums = set()\\n        \\n        for i in range(len(nums)-1):\\n            t = nums[i]+nums[i+1]\\n            if t in sums:\\n                return True\\n            else:\\n                sums.add(t)\\n            \\n        return False",
                "solutionTags": [],
                "code": "**Approach:**\\n --> As there is sub-array of len 2, we use set and store sum by going through first pass only.\\n--- > If we encouter same sum then just simply return **True** otherwise by end of that pass return **False**.\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        sums = set()\\n        \\n        for i in range(len(nums)-1):\\n            t = nums[i]+nums[i+1]\\n            if t in sums:\\n                return True\\n            else:\\n                sums.add(t)\\n            \\n        return False",
                "codeTag": "C++"
            },
            {
                "id": 2544777,
                "title": "python-99-faster-easy-solution",
                "content": "```\\ndef findSubarrays(self, nums: List[int]) -> bool:\\n        seen = set()\\n        for i in range(len(nums)-1):\\n            s = nums[i] + nums[i+1]\\n            if s in seen:\\n                return True\\n            seen.add(s)\\n        return False\\n```\\n![image](https://assets.leetcode.com/users/images/78187650-64db-4b93-932e-154312c9e1f0_1662554404.896161.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findSubarrays(self, nums: List[int]) -> bool:\\n        seen = set()\\n        for i in range(len(nums)-1):\\n            s = nums[i] + nums[i+1]\\n            if s in seen:\\n                return True\\n            seen.add(s)\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2752712,
                "title": "simple-hashset-java",
                "content": "If you like the solution pls upvote\\n\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int i = 1; i < nums.length; i++){\\n            if(!set.add(nums[i] + nums[i-1]))\\n                return true;\\n        }\\n\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int i = 1; i < nums.length; i++){\\n            if(!set.add(nums[i] + nums[i-1]))\\n                return true;\\n        }\\n\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525034,
                "title": "beginner-friendly-explained-1ms",
                "content": "```\\n/*\\n\\nApproach:\\n\\nNeed to find contiguous subarrays of length 2 only with different indices \\nso simply traverse array from i=0 to n-2\\n\\nand on every iteration check whether the sum of\\npairs nums[i]+nums[i+1] exists in the set or not\\n\\nIf exists then return true as two subarrays are found here\\nbut if the iteration completes then return false\\n\\n*/\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        int len = nums.length;\\n        if(len<=2) return false;\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0; i<len-1; i++){\\n            int sum = nums[i]+nums[i+1];\\n            if(set.contains(sum)) return true;\\n            set.add(sum);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n\\nApproach:\\n\\nNeed to find contiguous subarrays of length 2 only with different indices \\nso simply traverse array from i=0 to n-2\\n\\nand on every iteration check whether the sum of\\npairs nums[i]+nums[i+1] exists in the set or not\\n\\nIf exists then return true as two subarrays are found here\\nbut if the iteration completes then return false\\n\\n*/\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        int len = nums.length;\\n        if(len<=2) return false;\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0; i<len-1; i++){\\n            int sum = nums[i]+nums[i+1];\\n            if(set.contains(sum)) return true;\\n            set.add(sum);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533839,
                "title": "clean-and-fast-javascript-solution-set",
                "content": "```\\nvar findSubarrays = function(nums) {\\n    const sums = new Set()\\n    for( let i = 0 ; i < nums.length ; i++ ){\\n        let tot = nums[i] + nums[i+1]\\n        if( sums.has(tot) )\\n            return true\\n        sums.add(tot)\\n        // console.log(sums)\\n    }\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findSubarrays = function(nums) {\\n    const sums = new Set()\\n    for( let i = 0 ; i < nums.length ; i++ ){\\n        let tot = nums[i] + nums[i+1]\\n        if( sums.has(tot) )\\n            return true\\n        sums.add(tot)\\n        // console.log(sums)\\n    }\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2530016,
                "title": "c-easy-without-map-set-sc-o-1-tc-o-nlogn",
                "content": "```\\nbool findSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (nums.size() <= 2)\\n            return false;\\n        \\n        for (int i = 1; i < n; i++)\\n        {\\n            int sum = nums[i-1] + nums[i];\\n            nums[i-1] = sum;\\n        }\\n        nums.pop_back();\\n        sort (nums.begin(), nums.end());\\n        \\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            if (nums[i-1] == nums[i])\\n                return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool findSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (nums.size() <= 2)\\n            return false;\\n        \\n        for (int i = 1; i < n; i++)\\n        {\\n            int sum = nums[i-1] + nums[i];\\n            nums[i-1] = sum;\\n        }\\n        nums.pop_back();\\n        sort (nums.begin(), nums.end());\\n        \\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            if (nums[i-1] == nums[i])\\n                return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524894,
                "title": "java-hashset-method",
                "content": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        HashSet<Long> set = new HashSet<>();\\n        for(int i=0; i<nums.length-1; i++) {\\n            long sum = (long) (nums[i]+nums[i+1]);\\n            if(set.contains(sum)) return true;\\n            set.add(sum);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        HashSet<Long> set = new HashSet<>();\\n        for(int i=0; i<nums.length-1; i++) {\\n            long sum = (long) (nums[i]+nums[i+1]);\\n            if(set.contains(sum)) return true;\\n            set.add(sum);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524724,
                "title": "c-2-methods-map-loop-easily-understandable-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) \\n    {\\n        // First method\\n        map<int,int> mp;                                                       // create a map for storing all pair sum ans their occurance \\n        int n = nums.size();\\n        for(int i=0;i<n-1;i++)\\n        {\\n            mp[nums[i]+nums[i+1]]++;                                           // each time incease the occurance of pair sum\\n        }\\n        \\n        for(auto it : mp)                                                      // iterate over the map\\n        {\\n            if(it.second>1) return true;                                       // any point we get any pair sum occurance more than 1 just return true\\n        }\\n        return false;\\n    }  \\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) \\n    {\\n        \\n        // second method\\n        for(int i=1;i<nums.size();i++)                                         // from 0 to n-1\\n        {\\n            int sum = nums[i-1]+nums[i];                                       // storing the current pair sum\\n            for(int j=i;j<nums.size()-1;j++)                                   // from i to n-1\\n            {\\n                if(nums[j]+nums[j+1]==sum) return true;                        // any point of time we get same pair of sum return true \\n            }\\n        }\\n        return false;\\n    }  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) \\n    {\\n        // First method\\n        map<int,int> mp;                                                       // create a map for storing all pair sum ans their occurance \\n        int n = nums.size();\\n        for(int i=0;i<n-1;i++)\\n        {\\n            mp[nums[i]+nums[i+1]]++;                                           // each time incease the occurance of pair sum\\n        }\\n        \\n        for(auto it : mp)                                                      // iterate over the map\\n        {\\n            if(it.second>1) return true;                                       // any point we get any pair sum occurance more than 1 just return true\\n        }\\n        return false;\\n    }  \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) \\n    {\\n        \\n        // second method\\n        for(int i=1;i<nums.size();i++)                                         // from 0 to n-1\\n        {\\n            int sum = nums[i-1]+nums[i];                                       // storing the current pair sum\\n            for(int j=i;j<nums.size()-1;j++)                                   // from i to n-1\\n            {\\n                if(nums[j]+nums[j+1]==sum) return true;                        // any point of time we get same pair of sum return true \\n            }\\n        }\\n        return false;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524703,
                "title": "java-hashset",
                "content": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        \\n        if(nums.length<2)\\n        return false;\\n        \\n        HashSet<Integer> set=new HashSet<>(); //  To Track previous sum calculated \\n        \\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(!set.add(nums[i]+nums[i+1]))  //   Check if sum already exist \\n            return true;\\n            \\n        }\\n        \\n        return false;    \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        \\n        if(nums.length<2)\\n        return false;\\n        \\n        HashSet<Integer> set=new HashSet<>(); //  To Track previous sum calculated \\n        \\n        for(int i=0;i<nums.length-1;i++){\\n            \\n            if(!set.add(nums[i]+nums[i+1]))  //   Check if sum already exist \\n            return true;\\n            \\n        }\\n        \\n        return false;    \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617494,
                "title": "c-hashmap-easy",
                "content": "**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0; i<nums.size()-1; i++ ){\\n            mp[nums[i] + nums[i+1]]++ ;\\n            if( mp[nums[i] + nums[i+1]] >= 2 ){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\t};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0; i<nums.size()-1; i++ ){\\n            mp[nums[i] + nums[i+1]]++ ;\\n            if( mp[nums[i] + nums[i+1]] >= 2 ){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2530968,
                "title": "python3-3-or-1-lines-t-m-36ms-13-9mb",
                "content": "```\\nclass Solution:    # Let nums = [ 1,3,2,4,1,4],\\n    \\n                   # Here\\'s the plan: \\n                   #        1) Compute all the sums:   ((1,3),(3,2),(4,1),(1,4))\\n                   #                                    -->(1,5,5,5)\\n                   #        2) Determine whether any sum occurs twice: \\n                   #                                    --> Counter({5: 3, 4: 1})\\n                   #        3) Return the result.\\n\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n\\n        sums = (x+y for x,y in zip(nums[1:], nums))  # <-- 1)\\n\\n        counts = Counter(sums).values()              # <-- 2)\\n\\n        return max(counts) > 1                       # <-- 3)\\n\\n    # or (if you must):\\n\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        return max(Counter([x+y for x,y in zip(nums[1:], nums)]).values()) > 1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:    # Let nums = [ 1,3,2,4,1,4],\\n    \\n                   # Here\\'s the plan: \\n                   #        1) Compute all the sums:   ((1,3),(3,2),(4,1),(1,4))\\n                   #                                    -->(1,5,5,5)\\n                   #        2) Determine whether any sum occurs twice: \\n                   #                                    --> Counter({5: 3, 4: 1}",
                "codeTag": "Java"
            },
            {
                "id": 2526020,
                "title": "c-unordered-set-clean-code-fast-3ms",
                "content": "### Solution 1: hash set (3ms)\\n\\nWe insert the sum of two adjacent values of ```nums``` into a hash set, and if ```inserted``` is false the value is already in the hash set, i.e. we have seen it before. Doing this instead of ```unordered_set::count()``` and ```unordered_set::insert()``` avoids one hash set lookup and is faster.\\n\\n```\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_set<int> seen;\\n        for (int i = 1; i < size(nums); ++i) {\\n            const int sum = nums[i - 1] + nums[i];\\n            auto [it, inserted] = seen.insert(sum);\\n            if (!inserted) return true;\\n        }\\n        return false;\\n    }\\n```\\n\\n**Complexity Analysis**\\n\\n  * Time Complexity: O(n), we scan the input once.\\n  * Space Complexity: O(n), we insert at most n - 1 different sums into the hashmap.\\n\\n\\n### Appendix: speed up IO\\n\\nTo speed up IO I always have a header like this in my solutions:\\n\\n\\n```\\n// https://leetcode.com/problems/find-subarrays-with-equal-sum/\\n// problem: 2395\\nstatic int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\\n```\\n\\n_As always: Feedback is welcome and upvote if you like this post._",
                "solutionTags": [
                    "C"
                ],
                "code": "```nums```\n```inserted```\n```unordered_set::count()```\n```unordered_set::insert()```\n```\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_set<int> seen;\\n        for (int i = 1; i < size(nums); ++i) {\\n            const int sum = nums[i - 1] + nums[i];\\n            auto [it, inserted] = seen.insert(sum);\\n            if (!inserted) return true;\\n        }\\n        return false;\\n    }\\n```\n```\\n// https://leetcode.com/problems/find-subarrays-with-equal-sum/\\n// problem: 2395\\nstatic int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2525818,
                "title": "python-sliding-window-bruteforce",
                "content": "# Bruteforce \\n# Sliding window\\n## Time -> O(n)\\n## Space -> O(n)\\n\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n    \"\"\" \\n\\tBruteforce approch\\n\\t\"\"\"\\n#         for i in range(len(nums)-2):\\n#             summ1 = nums[i] + nums[i+1]\\n#             # for j in range(i+1,len(nums)):\\n#             for j in range(i+1,len(nums)-1):\\n#                 summ = nums[j] + nums[j+1]\\n#                 if summ == summ1:\\n#                     return True\\n#         return False\\n\\t \"\"\"\\n\\t Sliding Window\\n\\t \"\"\"\\n        one ,two = len(nums)-2,len(nums)-1      // at end of list\\n        dic = {}\\n        while one >= 0:\\n            # print(one,two)\\n            summ = nums[one] + nums[two]\\n            if summ in dic:\\n                return True               // if already there then there is 2 pairs\\n            else:\\n                dic[summ] = 1        // add summ in of window in dictonary\\n            one -=1\\n            two -=1\\n        return False\\n```\\n### \\uD83D\\uDE02 Random Dev Meme\\n<img src=\"https://random-memer.herokuapp.com/\" width=\"512px\"/>",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n    \"\"\" \\n\\tBruteforce approch\\n\\t\"\"\"\\n#         for i in range(len(nums)-2):\\n#             summ1 = nums[i] + nums[i+1]\\n#             # for j in range(i+1,len(nums)):\\n#             for j in range(i+1,len(nums)-1):\\n#                 summ = nums[j] + nums[j+1]\\n#                 if summ == summ1:\\n#                     return True\\n#         return False\\n\\t \"\"\"\\n\\t Sliding Window\\n\\t \"\"\"\\n        one ,two = len(nums)-2,len(nums)-1      // at end of list\\n        dic = {}\\n        while one >= 0:\\n            # print(one,two)\\n            summ = nums[one] + nums[two]\\n            if summ in dic:\\n                return True               // if already there then there is 2 pairs\\n            else:\\n                dic[summ] = 1        // add summ in of window in dictonary\\n            one -=1\\n            two -=1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524876,
                "title": "simple-solution-using-map-with-intuition-and-code-with-comments",
                "content": "We have to find whether there exist two subarray of length 2 with equal sum. \\nNote: number should be at different indices\\n\\nObservation:\\nTo find the given subarray sum present or not, we have to store it to check and return true or false. \\nSo we use unordered_map(hashmap) to store it and check in map that the current sum is already present or not. If it is present return true, else return false.\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int,int> mp;        //creating hashmap\\n        for(int i=0;i<nums.size()-1;i++){  //iterating till n-1\\n            int sum=nums[i]+nums[i+1];\\n            mp[sum]++;\\n            if(mp[sum]>1)                  //check if sum is present or not\\n                return true;               //if present return true\\n        }\\n        return false;                      //else return false\\n    }\\n};\\n```\\n\\nTC: O(N) for iterating whole array\\nSC: O(N) for unordered_map\\nwhere N is size of num array",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int,int> mp;        //creating hashmap\\n        for(int i=0;i<nums.size()-1;i++){  //iterating till n-1\\n            int sum=nums[i]+nums[i+1];\\n            mp[sum]++;\\n            if(mp[sum]>1)                  //check if sum is present or not\\n                return true;               //if present return true\\n        }\\n        return false;                      //else return false\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524812,
                "title": "c",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 2)\\n            return false;\\n        for(int i = 1; i < n; i++)\\n        {\\n            long long int sum = nums[i] + nums[i-1];\\n            \\n            for(int j = i; j < n-1; j++)\\n            {\\n                long long int tsum = nums[j] + nums[j+1];\\n                if(sum == tsum)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 2)\\n            return false;\\n        for(int i = 1; i < n; i++)\\n        {\\n            long long int sum = nums[i] + nums[i-1];\\n            \\n            for(int j = i; j < n-1; j++)\\n            {\\n                long long int tsum = nums[j] + nums[j+1];\\n                if(sum == tsum)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524709,
                "title": "c-use-hashmap-easy-and-efficient",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    bool findSubarrays(vector<int>& nums) \\n    {\\n        unordered_map<int, int> mp;\\n        int sum=0;\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            sum = nums[i]+nums[i+1];\\n            mp[sum]++;\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            if(it.second>1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool findSubarrays(vector<int>& nums) \\n    {\\n        unordered_map<int, int> mp;\\n        int sum=0;\\n        \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            sum = nums[i]+nums[i+1];\\n            mp[sum]++;\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            if(it.second>1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240569,
                "title": "optimum-solution-using-python-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        dict1={}\\n        for i in range(len(nums)-1):\\n            x=sum(nums[i:i+2])\\n            if x in dict1:\\n                return True\\n            else:\\n                dict1[x]=x \\n        return False\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        dict1={}\\n        for i in range(len(nums)-1):\\n            x=sum(nums[i:i+2])\\n            if x in dict1:\\n                return True\\n            else:\\n                dict1[x]=x \\n        return False\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790091,
                "title": "java-easy-peasy-solution-for-beginners-best-for-logic-building",
                "content": "Follow Brute Force Methods for Initial Logic Building...will take you places\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n       for(int i=0;i<nums.length-1;i++)\\n           for(int j=i+1;j<nums.length-1;j++)\\n               if((nums[i]+nums[i+1])==(nums[j]+nums[j+1]))\\n                   return true;\\n        return false;\\n    }\\n}\\n```\\nPlease Upvote if you find this Helpful...**Happy Coding...**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n       for(int i=0;i<nums.length-1;i++)\\n           for(int j=i+1;j<nums.length-1;j++)\\n               if((nums[i]+nums[i+1])==(nums[j]+nums[j+1]))\\n                   return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776774,
                "title": "js-very-easy-and-fast-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar findSubarrays = function(nums) {\\n    const temp = [];\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        temp.push(nums[i] + nums[i+1]);\\n    }\\n    const hashmap = new Map();\\n    for (let i = 0 ; i < temp.length; i++) {\\n        if (hashmap.has(temp[i])) return true;\\n        hashmap.set(temp[i], 1);\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar findSubarrays = function(nums) {\\n    const temp = [];\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        temp.push(nums[i] + nums[i+1]);\\n    }\\n    const hashmap = new Map();\\n    for (let i = 0 ; i < temp.length; i++) {\\n        if (hashmap.has(temp[i])) return true;\\n        hashmap.set(temp[i], 1);\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2600901,
                "title": "python-simple-python-solution-using-dictionary-95-faster",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 43 ms, faster than 95.05% of Python3 online submissions for Find Subarrays With Equal Sum.\\n# Memory Usage: 14.2 MB, less than 9.83% of Python3 online submissions for Find Subarrays With Equal Sum.\\n\\n\\t\\tclass Solution:\\n\\t\\tdef findSubarrays(self, nums: List[int]) -> bool:\\n\\n\\t\\t\\tdictionary = {}\\n\\n\\t\\t\\tfor i in range(len(nums) - 1):\\n\\n\\t\\t\\t\\tsubarray_sum = sum(nums[i:i+2])\\n\\n\\t\\t\\t\\tif subarray_sum not in dictionary:\\n\\n\\t\\t\\t\\t\\tdictionary[subarray_sum] = nums[i:i+2]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef findSubarrays(self, nums: List[int]) -> bool:\\n\\n\\t\\t\\tdictionary = {}",
                "codeTag": "Java"
            },
            {
                "id": 2528111,
                "title": "easy-java-super-fast-set-concise",
                "content": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        int n = nums.length,i;\\n        for(i=1;i<n;i++){\\n            if(set.contains(nums[i-1]+nums[i])) return true;\\n            set.add(nums[i-1]+nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        int n = nums.length,i;\\n        for(i=1;i<n;i++){\\n            if(set.contains(nums[i-1]+nums[i])) return true;\\n            set.add(nums[i-1]+nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525149,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] n) {\\n        int k=n.length;\\n        int a[]=new int[k-1];\\n        for(int i=1;i<k;i++)\\n        {\\n            a[i-1]=n[i-1]+n[i];\\n        }\\n        Arrays.sort(a);\\n        for(int i=0;i<k-2;i++)\\n        {\\n            if(a[i]==a[i+1])\\n                return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean findSubarrays(int[] n) {\\n        int k=n.length;\\n        int a[]=new int[k-1];\\n        for(int i=1;i<k;i++)\\n        {\\n            a[i-1]=n[i-1]+n[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2524714,
                "title": "c-sliding-window-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> pref(n-1);\\n        for(int i=1;i<n;i++){\\n            pref[i-1] = nums[i] + nums[i-1];\\n        }\\n        for(int i=0;i<n-1;i++){\\n            for(int j = i+1;j<n-1;j++){\\n                if(pref[i] == pref[j]) return true;\\n                \\n            } \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> pref(n-1);\\n        for(int i=1;i<n;i++){\\n            pref[i-1] = nums[i] + nums[i-1];\\n        }\\n        for(int i=0;i<n-1;i++){\\n            for(int j = i+1;j<n-1;j++){\\n                if(pref[i] == pref[j]) return true;\\n                \\n            } \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361098,
                "title": "find-subarrays-with-equal-sum-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int i, j;\\n        for(i=0 ; i<nums.size()-2 ; i++)\\n        { \\n            for(j=i+1 ; j<nums.size()-1 ; j++)\\n            {\\n                if((nums[i]+nums[i+1])==(nums[j]+nums[j+1]))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int i, j;\\n        for(i=0 ; i<nums.size()-2 ; i++)\\n        { \\n            for(j=i+1 ; j<nums.size()-1 ; j++)\\n            {\\n                if((nums[i]+nums[i+1])==(nums[j]+nums[j+1]))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840766,
                "title": "java-from-5ms-to-2ms-2-solutions",
                "content": "\\n# Solution 1 | 5ms | 15% Faster\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            for (int j = i + 1; j < nums.length - 1; j++) {\\n                if (nums[i] + nums[i + 1] == nums[j] + nums[j + 1]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n# Solution 2 | 2ms | 80% Faster\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        int temp = nums[0];\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 1; i < nums.length; i++) {\\n            int t = nums[i];\\n            nums[i] += temp;\\n            if (set.contains(nums[i])) {\\n                return true;\\n            } else {\\n                set.add(nums[i]);\\n            }\\n            temp = t;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            for (int j = i + 1; j < nums.length - 1; j++) {\\n                if (nums[i] + nums[i + 1] == nums[j] + nums[j + 1]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        int temp = nums[0];\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 1; i < nums.length; i++) {\\n            int t = nums[i];\\n            nums[i] += temp;\\n            if (set.contains(nums[i])) {\\n                return true;\\n            } else {\\n                set.add(nums[i]);\\n            }\\n            temp = t;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762749,
                "title": "find-subarrays-with-equal-sum",
                "content": "Just Go to description and read the question . It states that it shoud be in contiguous. \\n ```\\nExample =[2 ,1,3,5,0,6]\\nit is  also giving the two array with equal sum but [3,0] is not contiguous.\\nso it gives false;\\n```\\n\\n Just simple solution we add current element and previous element and search in set if found return true else insert in set and if not found in set means not found so return false;\\n \\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n    unordered_set<int>s;\\n        for(int i=1;i<nums.size();i++){\\n            if(s.find(nums[i]+nums[i-1])!=s.end()){\\n                return true;\\n            }\\n            s.insert(nums[i]+nums[i-1]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nExample =[2 ,1,3,5,0,6]\\nit is  also giving the two array with equal sum but [3,0] is not contiguous.\\nso it gives false;\\n```\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n    unordered_set<int>s;\\n        for(int i=1;i<nums.size();i++){\\n            if(s.find(nums[i]+nums[i-1])!=s.end()){\\n                return true;\\n            }\\n            s.insert(nums[i]+nums[i-1]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753796,
                "title": "0ms-sliding-window-and-map-approach",
                "content": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        int count=0;\\n        int wsum=0;\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        int ws=0;\\n        for(int we=0;we<nums.length;we++){\\n            wsum+=nums[we];\\n            while(we-ws+1 >= 2){\\n                if((we-ws+1==2) && (hm.containsKey(wsum))) return true;\\n                hm.put(wsum,1);\\n                wsum-=nums[ws];\\n                ws++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        int count=0;\\n        int wsum=0;\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        int ws=0;\\n        for(int we=0;we<nums.length;we++){\\n            wsum+=nums[we];\\n            while(we-ws+1 >= 2){\\n                if((we-ws+1==2) && (hm.containsKey(wsum))) return true;\\n                hm.put(wsum,1);\\n                wsum-=nums[ws];\\n                ws++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738672,
                "title": "c-using-set-only",
                "content": "class Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        set<int >s;\\n        for(int i=0;i<=nums.size()-2;i++)\\n        {\\n            s.insert(nums[i]+nums[i+1]);\\n        }\\n        if(s.size()==(nums.size()-1)) return false;\\n        return true;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        set<int >s;\\n        for(int i=0;i<=nums.size()-2;i++)\\n        {\\n            s.insert(nums[i]+nums[i+1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2633753,
                "title": "check-consecutive-sum-43ms",
                "content": "Since the condition is to check for subarray of length two, we only hav to check for the sum of two elements which are `nums[i]` and `nums[i+1]`.\\n\\n_For this solution we use the `set()` data structure for memorizing the previous sums.If the subarray exists, then we stop the loop and return `True`._\\n\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        out = set()\\n        for i in range(1, len(nums)):\\n            if nums[i-1]+nums[i] in out:\\n                return True\\n            out.add(nums[i-1]+nums[i])\\n        return False\\n```\\n\\n![image](https://assets.leetcode.com/users/images/92c8292f-2afe-415a-a168-7cf0c7328d10_1664350114.1230812.png)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        out = set()\\n        for i in range(1, len(nums)):\\n            if nums[i-1]+nums[i] in out:\\n                return True\\n            out.add(nums[i-1]+nums[i])\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535757,
                "title": "java-faster-than-100-6-lines",
                "content": "`set.add(x)` returns true when `set` does not contain `x` and hence adds `x` successfully.\\nSimilarly `set.add(x)` returns false when `set` contains `x`.\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 1; i < nums.length - 1; i += 2) {\\n            int first = nums[i - 1] + nums[i], second = nums[i] + nums[i + 1];\\n            if (!set.add(first) || !set.add(second)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 1; i < nums.length - 1; i += 2) {\\n            int first = nums[i - 1] + nums[i], second = nums[i] + nums[i + 1];\\n            if (!set.add(first) || !set.add(second)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534184,
                "title": "prefix-sum-approach-beats-both-runtime-and-memory-by-100",
                "content": "Using prefix sum and simply checking if two subarrays are equal by substracting values.\\nUpvote if this helps you :)\\n\\n![image](https://assets.leetcode.com/users/images/dfaceb68-ce35-42d3-bc9c-bdfac2a71c98_1662374864.870948.png)\\n\\n\\n\\nC++ code:\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long int> prefix(n+1,0);\\n        prefix[0]=0;\\n        for(int i=0;i<n;i++){\\n            prefix[i+1]=prefix[i]+nums[i];\\n        }\\n        \\n        for(int i=1;i<n-1;i++){\\n            long long int curr=prefix[i+1]-prefix[i-1];\\n            for(int j=i+1;j<n;j++){\\n                long long int next=prefix[j+1]-prefix[j-1];\\n                if(next==curr)\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\nWorst case cpmplexity analysis:\\n1. Space O(n)\\n2. Time O(n^2)\\n\\nPlease feel free to comment if you have any doubts.",
                "solutionTags": [
                    "C",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long int> prefix(n+1,0);\\n        prefix[0]=0;\\n        for(int i=0;i<n;i++){\\n            prefix[i+1]=prefix[i]+nums[i];\\n        }\\n        \\n        for(int i=1;i<n-1;i++){\\n            long long int curr=prefix[i+1]-prefix[i-1];\\n            for(int j=i+1;j<n;j++){\\n                long long int next=prefix[j+1]-prefix[j-1];\\n                if(next==curr)\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525971,
                "title": "bruteforce-and-optimal-c",
                "content": "**1. Bruteforce Approach | O(n^2) time, O(n) space, n = nums.length**\\n\\n```cpp\\nclass Solution_1 {\\npublic:\\n    bool findSubarrays(vector<int> &nums) {\\n        int n = nums.size();\\n        int arr[n - 1];\\n        for (int i = 1; i < n; i++) {\\n            arr[i - 1] = nums[i] + nums[i - 1];\\n        }\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                if (arr[i] == arr[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n<br>\\n\\n**2. Optimal Approach | O(n) time, O(n) space, n = nums.length**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int> &nums) {\\n        int n = nums.size();\\n        unordered_set<int> ans;\\n        for(int i = 1; i < n; i++){\\n            ans.insert(nums[i] + nums[i - 1]);\\n        }\\n        if (ans.size() == (nums.size() - 1)){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution_1 {\\npublic:\\n    bool findSubarrays(vector<int> &nums) {\\n        int n = nums.size();\\n        int arr[n - 1];\\n        for (int i = 1; i < n; i++) {\\n            arr[i - 1] = nums[i] + nums[i - 1];\\n        }\\n        for (int i = 0; i < n - 1; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                if (arr[i] == arr[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int> &nums) {\\n        int n = nums.size();\\n        unordered_set<int> ans;\\n        for(int i = 1; i < n; i++){\\n            ans.insert(nums[i] + nums[i - 1]);\\n        }\\n        if (ans.size() == (nums.size() - 1)){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525650,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashset***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // declare a set\\n        \\n        unordered_set<long long> s;\\n        \\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            long long sum = nums[i] + nums[i + 1];\\n            \\n            // if sum is already present in set then return true\\n            \\n            if(s.count(sum))\\n                return true;\\n            \\n            s.insert(sum);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // declare a set\\n        \\n        unordered_set<long long> s;\\n        \\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            long long sum = nums[i] + nums[i + 1];\\n            \\n            // if sum is already present in set then return true\\n            \\n            if(s.count(sum))\\n                return true;\\n            \\n            s.insert(sum);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525530,
                "title": "python-easy-understanding",
                "content": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        all_sums = []\\n        for i in range(0, len(nums) - 1):\\n            if nums[i] + nums[i + 1] in all_sums:\\n                return True\\n            else:\\n                all_sums.append(nums[i] + nums[i + 1])\\n    \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        all_sums = []\\n        for i in range(0, len(nums) - 1):\\n            if nums[i] + nums[i + 1] in all_sums:\\n                return True\\n            else:\\n                all_sums.append(nums[i] + nums[i + 1])\\n    \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524980,
                "title": "2-easy-c-soln",
                "content": "```\\n// method  -1 (sliding window )\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        int j = 0;\\n        int i = 0;\\n        int sum = 0;\\n        while(j<nums.size()){\\n            sum+=nums[j];\\n            \\n            if(j - i + 1 ==2){\\n                if(mp[sum])\\n                    return true;\\n                \\n                mp[sum]++;\\n                sum -= nums[i];\\n                i++;  \\n            }\\n            \\n            j++;\\n                \\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n```\\n// method -2\\nbool findSubarrays(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(int i=1;i<nums.size();i++){\\n            int s=nums[i]+nums[i-1];\\n            if(mp.find(s)!=mp.end())\\n                return true;\\n            mp[s]++;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n// method  -1 (sliding window )\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        int j = 0;\\n        int i = 0;\\n        int sum = 0;\\n        while(j<nums.size()){\\n            sum+=nums[j];\\n            \\n            if(j - i + 1 ==2){\\n                if(mp[sum])\\n                    return true;\\n                \\n                mp[sum]++;\\n                sum -= nums[i];\\n                i++;  \\n            }\\n            \\n            j++;\\n                \\n        }\\n        \\n        return false;\\n    }\\n};\\n```\n```\\n// method -2\\nbool findSubarrays(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(int i=1;i<nums.size();i++){\\n            int s=nums[i]+nums[i-1];\\n            if(mp.find(s)!=mp.end())\\n                return true;\\n            mp[s]++;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524866,
                "title": "brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int n=nums.size();\\n        map <int,int> m;\\n        for(int i=0;i<n-1;i++){\\n            int k=nums[i]+nums[i+1];\\n            m[k]++;\\n        }\\n        \\n        for(auto it:m){\\n            if(it.second>=2){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int n=nums.size();\\n        map <int,int> m;\\n        for(int i=0;i<n-1;i++){\\n            int k=nums[i]+nums[i+1];\\n            m[k]++;\\n        }\\n        \\n        for(auto it:m){\\n            if(it.second>=2){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524686,
                "title": "c-hash-set",
                "content": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for (int i = 1; i < size(nums); i++) {\\n            int tmp = nums[i] + nums[i-1];\\n            if (st.count(tmp)) return true;\\n            st.insert(tmp);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_set<int> st;\\n        for (int i = 1; i < size(nums); i++) {\\n            int tmp = nums[i] + nums[i-1];\\n            if (st.count(tmp)) return true;\\n            st.insert(tmp);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081387,
                "title": "easiest-solution-of-c-using-loops",
                "content": "# Intuition\\n\\nCertainly! The intuition for the provided code is as follows:\\n\\nIntuition:\\n\\nThe problem requires us to determine if there exist two subarrays of consecutive elements in the given nums array such that the sum of the elements in the first subarray is equal to the sum of the elements in the second subarray.\\n\\nHere\\'s the intuition behind the code:\\n\\nFirst, we calculate the sum of adjacent elements in the nums array and store these sums in the weights vector. This is done by iterating through nums from index 0 to n-2 and calculating sum = nums[i] + nums[i+1] for each pair of adjacent elements. These sums represent the possible sums of two consecutive elements.\\n\\nNext, we sort the weights vector in ascending order. Sorting is necessary because it helps us identify if there are consecutive equal sums, which would satisfy the problem\\'s condition.\\n\\nAfter sorting, we iterate through the sorted weights vector and check if there are any two consecutive elements that are equal. If we find such elements, it means we\\'ve found two subarrays with equal sums, and we return true. Otherwise, we return false at the end of the function.\\n\\nThe core idea is to transform the problem of finding two subarrays with equal sums into finding consecutive equal elements in the sorted list of possible sums. If we find such elements, we can conclude that there are indeed two subarrays with equal sums in the original array.\\n\\n# Approach\\nThe problem asks us to determine whether there exist two subarrays of consecutive elements in the given nums array such that the sum of elements in the first subarray is equal to the sum of elements in the second subarray. We can solve this problem using the following approach:\\n\\nCreate a vector called weights to store the sums of adjacent elements in the nums array.\\n\\nIterate through the nums array from the first element to the second-to-last element. For each pair of adjacent elements at indices i and i+1, calculate their sum (sum = nums[i] + nums[i+1]) and add it to the weights vector. This step creates a list of possible sums of two consecutive elements in the original array.\\n\\nSort the weights vector in ascending order. Sorting is essential to identify consecutive equal sums efficiently.\\n\\nIterate through the sorted weights vector. For each element at index i, compare it with the next element at index i+1. If these two elements are equal, it implies that there are two subarrays in the original nums array with equal sums. In this case, return true.\\n\\nIf no consecutive equal sums are found while iterating through the sorted weights vector, return false at the end of the function.\\n\\nThe key insight here is that sorting the sums simplifies the problem because it allows us to identify consecutive equal sums efficiently. If we find consecutive equal sums in the sorted list, it implies that there are two subarrays in the original array with the same sum, satisfying the problem\\'s condition.\\n\\nThis approach has a time complexity of O(n log n) due to the sorting step, where n is the length of the nums array, and a space complexity of O(n) to store the weights vector.\\n# Complexity\\n- Time complexity:\\n O(n log n)\\n- Space complexity:\\n O(n) \\n\\n# Code\\n```\\n#include <vector>\\n#include <algorithm> // for sort\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        vector<int> weights;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            int sum = nums[i] + nums[i + 1];\\n            weights.push_back(sum);\\n        }\\n\\n        sort(weights.begin(), weights.end());\\n\\n        for (int i = 0; i < weights.size() - 1; i++) {\\n            int sum1 = weights[i];\\n            int sum2 = weights[i + 1];\\n            if (sum1 == sum2) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n#include <algorithm> // for sort\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        vector<int> weights;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n - 1; i++) {\\n            int sum = nums[i] + nums[i + 1];\\n            weights.push_back(sum);\\n        }\\n\\n        sort(weights.begin(), weights.end());\\n\\n        for (int i = 0; i < weights.size() - 1; i++) {\\n            int sum1 = weights[i];\\n            int sum2 = weights[i + 1];\\n            if (sum1 == sum2) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3515221,
                "title": "c-set",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_set<int> S;\\n\\n        for (int i = 0; i < nums.size()-1; i++) {\\n            int sum = nums[i] + nums[i+1];\\n            if (S.find(sum) != S.end()) return true;\\n            S.insert(sum);\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_set<int> S;\\n\\n        for (int i = 0; i < nums.size()-1; i++) {\\n            int sum = nums[i] + nums[i+1];\\n            if (S.find(sum) != S.end()) return true;\\n            S.insert(sum);\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405620,
                "title": "simple-sliding-window-approach",
                "content": "\\n\\n# Approach\\n- Keep track of sum of array of size 2.\\n- Keep on sliding the window ,and at any point if curr window sum was present before , return true.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& a) {\\n        int n=a.size(), l=0, r=2;\\n        if(n<=1)\\n          return false;\\n        int currWindowSum = a[0]+a[1];\\n        unordered_set<int>s;\\n        s.insert(currWindowSum);\\n        while(r<n)\\n        {\\n           currWindowSum=currWindowSum-a[l];\\n           currWindowSum=currWindowSum+a[r];\\n           l++;\\n           r++;\\n           if(s.find(currWindowSum)!=s.end())\\n             return true;\\n           s.insert(currWindowSum);\\n        }\\n        return false;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& a) {\\n        int n=a.size(), l=0, r=2;\\n        if(n<=1)\\n          return false;\\n        int currWindowSum = a[0]+a[1];\\n        unordered_set<int>s;\\n        s.insert(currWindowSum);\\n        while(r<n)\\n        {\\n           currWindowSum=currWindowSum-a[l];\\n           currWindowSum=currWindowSum+a[r];\\n           l++;\\n           r++;\\n           if(s.find(currWindowSum)!=s.end())\\n             return true;\\n           s.insert(currWindowSum);\\n        }\\n        return false;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241336,
                "title": "3-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        list1=[]\\n        for i in range(len(nums)-1):\\n            list1.append(sum(nums[i:i+2%(len(nums))]))\\n        return sorted(set(list1))!=sorted(list1)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        list1=[]\\n        for i in range(len(nums)-1):\\n            list1.append(sum(nums[i:i+2%(len(nums))]))\\n        return sorted(set(list1))!=sorted(list1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240544,
                "title": "beginner-friendly-code-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        dict1={}\\n        for i in range(len(nums)-1):\\n            x=sum(nums[i:i+2])\\n            dict1[i]=x\\n        list1=list(dict1.values())\\n        for i in range(len(list1)):\\n            j=i+1\\n            while j<len(list1):\\n                if list1[i]==list1[j]:\\n                    return True\\n                j+=1\\n        return False\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        dict1={}\\n        for i in range(len(nums)-1):\\n            x=sum(nums[i:i+2])\\n            dict1[i]=x\\n        list1=list(dict1.values())\\n        for i in range(len(list1)):\\n            j=i+1\\n            while j<len(list1):\\n                if list1[i]==list1[j]:\\n                    return True\\n                j+=1\\n        return False\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092922,
                "title": "efficient-easy-solution-with-set",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar findSubarrays = function(nums) {\\n    const sumSet = new Set();\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        const sum = nums[i] + nums[i + 1];\\n\\n        if (sumSet.has(sum)) {\\n            return true;\\n        }\\n\\n        sumSet.add(sum);\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar findSubarrays = function(nums) {\\n    const sumSet = new Set();\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        const sum = nums[i] + nums[i + 1];\\n\\n        if (sumSet.has(sum)) {\\n            return true;\\n        }\\n\\n        sumSet.add(sum);\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2799097,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int i;\\n        for(i=0;i<nums.size();i++){\\n             int n = nums.size();\\n        unordered_map<int,int> y;\\n        for(int i=1;i<n;i++){\\n            int sum = nums[i]+nums[i-1];\\n            y[sum]++;\\n            if(y[sum]>1) return true;\\n        }}\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int i;\\n        for(i=0;i<nums.size();i++){\\n             int n = nums.size();\\n        unordered_map<int,int> y;\\n        for(int i=1;i<n;i++){\\n            int sum = nums[i]+nums[i-1];\\n            y[sum]++;\\n            if(y[sum]>1) return true;\\n        }}\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746998,
                "title": "c",
                "content": "*if there exist any two sum with same sum set will overide the last one resulting into shorter set length*\\n.\\n.\\n.\\nbool findSubarrays(vector<int>& nums) {\\n        set<int> res;\\n        for(int i=1;i<nums.size();i++){\\n            res.insert(nums[i]+nums[i-1]);\\n        }\\n        return !(res.size()==nums.size()-1);\\n    }",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "*if there exist any two sum with same sum set will overide the last one resulting into shorter set length*\\n.\\n.\\n.\\nbool findSubarrays(vector<int>& nums) {\\n        set<int> res;\\n        for(int i=1;i<nums.size();i++){\\n            res.insert(nums[i]+nums[i-1]);\\n        }\\n        return !(res.size()==nums.size()-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2694241,
                "title": "easy-solution-c",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int, bool> sumExists;\\n        int i = 1, n = nums.size();\\n        while (i < n) {\\n            int sum = nums[i - 1] + nums[i++];\\n            if (sumExists[sum]) return true;\\n            else sumExists[sum] = true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nIn the code above we are finding the sum of every two consecutive element in the array, and if the sum exists we return true else false;",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int, bool> sumExists;\\n        int i = 1, n = nums.size();\\n        while (i < n) {\\n            int sum = nums[i - 1] + nums[i++];\\n            if (sumExists[sum]) return true;\\n            else sumExists[sum] = true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630558,
                "title": "c-easy-to-undersatand-step-by-step",
                "content": "```\\nbool findSubarrays(vector<int>& nums) {\\n        int sum = nums[0], counter = 0;\\n        unordered_map<int, int>m;\\n        for(int i = 1; i<nums.size(); i++)\\n        {\\n            sum +=nums[i];\\n            counter ++;\\n            if(counter == 1)\\n            {\\n                if(m.find(sum) != m.end())\\n                  return true;\\n                 m[sum]=nums[i];\\n                sum=nums[i];\\n                counter = 0;\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "```\\nbool findSubarrays(vector<int>& nums) {\\n        int sum = nums[0], counter = 0;\\n        unordered_map<int, int>m;\\n        for(int i = 1; i<nums.size(); i++)\\n        {\\n            sum +=nums[i];\\n            counter ++;\\n            if(counter == 1)\\n            {\\n                if(m.find(sum) != m.end())\\n                  return true;\\n                 m[sum]=nums[i];\\n                sum=nums[i];\\n                counter = 0;\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2628405,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar findSubarrays = function (nums) {\\n  const set = new Set();\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (set.has(nums[i] + nums[i + 1])) {\\n      return true;\\n    }\\n    set.add(nums[i] + nums[i + 1]);\\n  }\\n\\n  return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar findSubarrays = function (nums) {\\n  const set = new Set();\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (set.has(nums[i] + nums[i + 1])) {\\n      return true;\\n    }\\n    set.add(nums[i] + nums[i + 1]);\\n  }\\n\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2623936,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size()-1;i++){\\n            int x=nums[i]+nums[i+1];\\n            ans.push_back(x);\\n        }\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size()-1;i++){\\n            if(ans[i]==ans[i+1]) \\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size()-1;i++){\\n            int x=nums[i]+nums[i+1];\\n            ans.push_back(x);\\n        }\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size()-1;i++){\\n            if(ans[i]==ans[i+1]) \\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619011,
                "title": "java-hash-set-easy-understanding",
                "content": "# class Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        if(nums.length<=2){\\n            return false;\\n        }\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0; i<nums.length-1; i++){\\n            int sum = nums[i]+nums[i+1];\\n            if(set.contains(sum)) return true;\\n            set.add(sum);\\n        }\\n    \\n        return false;\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        if(nums.length<=2){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2586892,
                "title": "java-simple-hashset-solution",
                "content": "```\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            int cur = nums[i - 1] + nums[i];\\n            \\n            if (!set.add(cur)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            int cur = nums[i - 1] + nums[i];\\n            \\n            if (!set.add(cur)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556225,
                "title": "my-accepted-java-solution-in-0-ms",
                "content": "```\\n\\tSet<Integer> s = new HashSet<>();\\n    public boolean findSubarrays(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){\\n            int x = nums[i]+nums[i+1];\\n            if(s.contains(x)){return true;}\\n            else{s.add(x);}\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tSet<Integer> s = new HashSet<>();\\n    public boolean findSubarrays(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){\\n            int x = nums[i]+nums[i+1];\\n            if(s.contains(x)){return true;}\\n            else{s.add(x);}\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2540492,
                "title": "rust-0-ms-zip-any-solution-using-hashset-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/793059284/) employs a zip-any functional-style approach with *HashSet* used to store sums of neighbours. It demonstrated **0 ms runtime (100%)** and used **2.1 MB memory (96.67%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn find_subarrays(nums: Vec<i32>) -> bool \\n    {\\n        // [1] we store sums in a HashSet with preallocated capacity\\n        let mut sums: HashSet<i32> = HashSet::<i32>::with_capacity(nums.len());\\n        \\n        // [2] to compute sums of neighbours, we zip them into a tuple (left,right)\\n        nums[1..]\\n            .iter()\\n            .zip(nums.iter())\\n            .any(|(&left,&right)| !sums.insert(left+right))\\n        // [3] HashSet::insert returns whether or not the element was newly inserted;\\n        //     .any() - checks for at least one duplicate sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn find_subarrays(nums: Vec<i32>) -> bool \\n    {\\n        // [1] we store sums in a HashSet with preallocated capacity\\n        let mut sums: HashSet<i32> = HashSet::<i32>::with_capacity(nums.len());\\n        \\n        // [2] to compute sums of neighbours, we zip them into a tuple (left,right)\\n        nums[1..]\\n            .iter()\\n            .zip(nums.iter())\\n            .any(|(&left,&right)| !sums.insert(left+right))\\n        // [3] HashSet::insert returns whether or not the element was newly inserted;\\n        //     .any() - checks for at least one duplicate sum\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2540392,
                "title": "python-map-zip-pythonic-solution-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/793039170/) uses map-zip functional-style approach with comparison of list-vs-set lengths to detect duplicates. It demonstrated **37 ms runtime (97.14%)** and used **14.0 MB memory (43.21%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        # [1] compute sums of neighbours\\n        sums = [*map(lambda x: x[0]+x[1], zip(nums[0:-1], nums[1:]))]\\n        # [2] check if there are any duplicates\\n        return len(sums) != len(set(sums))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        # [1] compute sums of neighbours\\n        sums = [*map(lambda x: x[0]+x[1], zip(nums[0:-1], nums[1:]))]\\n        # [2] check if there are any duplicates\\n        return len(sums) != len(set(sums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533850,
                "title": "1-line-python-with-explanation",
                "content": "```\\nreturn Counter(map(sum, pairwise(nums))).most_common(1)[0][1] >= 2\\n```\\n\\n- `itertools.pairwise(nums)` returns all subarrays with length 2. `pairwise(\\'ABCDEFG\\') --> AB BC CD DE EF FG`\\n- Use `map(sum, pairwise(nums))` to sum all the subarrays.\\n- Use `Counter.most_common()` to find if there are subarrays with same `sum()`.\\n\\nI\\'m growing the list of [1liner Python](https://github.com/dangsonbk/1linePython) code, hope you like it.",
                "solutionTags": [],
                "code": "```\\nreturn Counter(map(sum, pairwise(nums))).most_common(1)[0][1] >= 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2531291,
                "title": "with-explanation-comments-time-20-ms-100-00-space-7-3-mb-100-00",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        \\n        //loop over the whole array elements as a first pointer\\n        for(int i=0;i<nums.size()-1;i++){\\n            \\n        //loop over the remainder array elements as a second pointer\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                //check if the current + the next digit values of the first pointer equals to the current + the next digit values of the second pointer\\n                if(nums[i]+nums[i+1]==nums[j]+nums[j+1])\\n                //if yes-> true\\n                    return true;\\n            }\\n        }\\n        \\n        //if no-> false\\n        return false;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        \\n        //loop over the whole array elements as a first pointer\\n        for(int i=0;i<nums.size()-1;i++){\\n            \\n        //loop over the remainder array elements as a second pointer\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                //check if the current + the next digit values of the first pointer equals to the current + the next digit values of the second pointer\\n                if(nums[i]+nums[i+1]==nums[j]+nums[j+1])\\n                //if yes-> true\\n                    return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2529076,
                "title": "sliding-window-hashmap",
                "content": "```\\n bool findSubarrays(vector<int>& nums) {\\n        int ind=0,sum=0;\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            if(i-ind+1==2)\\n            {\\n                if(mp[sum]!=0)return 1;\\n                mp[sum]++;\\n                sum-=nums[ind++];\\n            }\\n        }\\n        return 0;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n bool findSubarrays(vector<int>& nums) {\\n        int ind=0,sum=0;\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            if(i-ind+1==2)\\n            {\\n                if(mp[sum]!=0)return 1;\\n                mp[sum]++;\\n                sum-=nums[ind++];\\n            }\\n        }\\n        return 0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2528145,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        c=[]\\n        for i in range(len(nums)-1):\\n            c.append(sum([nums[i],nums[i+1]]))\\n        if len(c)==len(set(c)):\\n            return False\\n        else:\\n            return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        c=[]\\n        for i in range(len(nums)-1):\\n            c.append(sum([nums[i],nums[i+1]]))\\n        if len(c)==len(set(c)):\\n            return False\\n        else:\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527571,
                "title": "easy-cpp-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_set<int> sumOfElements;\\n        for(int i=0;i<nums.size()-1;i++){\\n            int sum=nums[i]+nums[i+1];\\n            sumOfElements.insert(sum);\\n        }\\n        if(sumOfElements.size()==nums.size()-1){\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_set<int> sumOfElements;\\n        for(int i=0;i<nums.size()-1;i++){\\n            int sum=nums[i]+nums[i+1];\\n            sumOfElements.insert(sum);\\n        }\\n        if(sumOfElements.size()==nums.size()-1){\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527212,
                "title": "c-python-sliding-window-easy-to-understand",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int l = nums.size();\\n        if(l<=2) return false;\\n        unordered_set<int> m;\\n        int s = nums[0]+nums[1];\\n        m.insert(s);\\n        for(int i=0; i<l-2; ++i){\\n            s += nums[i+2]-nums[i];\\n            if(m.find(s) != m.end()) return true;\\n            else m.insert(s);\\n        }\\n        return false;\\n    }\\n};\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        l = len(nums)\\n        if(l<=2): return False\\n        m = []\\n        s = nums[0]+nums[1]\\n        m.append(s)\\n        for i in range(l-2):\\n            s += nums[i+2]-nums[i]\\n            if(s in m): return True\\n            else: m.append(s)\\n        return False\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int l = nums.size();\\n        if(l<=2) return false;\\n        unordered_set<int> m;\\n        int s = nums[0]+nums[1];\\n        m.insert(s);\\n        for(int i=0; i<l-2; ++i){\\n            s += nums[i+2]-nums[i];\\n            if(m.find(s) != m.end()) return true;\\n            else m.insert(s);\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        l = len(nums)\\n        if(l<=2): return False\\n        m = []\\n        s = nums[0]+nums[1]\\n        m.append(s)\\n        for i in range(l-2):\\n            s += nums[i+2]-nums[i]\\n            if(s in m): return True\\n            else: m.append(s)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526487,
                "title": "rust-solution",
                "content": "I use `zip` instead `windows` to prevent bound checking in each pair.\\nMaybe I\\'m wrong and this is over-optimization)\\n```\\nimpl Solution {\\n    pub fn find_subarrays(nums: Vec<i32>) -> bool {\\n        let mut set = std::collections::HashSet::with_capacity(nums.len());\\n        nums.iter()\\n            .zip(nums[1..].iter())\\n            .any(|(x, y)| !set.insert(*x + *y))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_subarrays(nums: Vec<i32>) -> bool {\\n        let mut set = std::collections::HashSet::with_capacity(nums.len());\\n        nums.iter()\\n            .zip(nums[1..].iter())\\n            .any(|(x, y)| !set.insert(*x + *y))\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2526470,
                "title": "java-solution-o-n-2-and-o-n",
                "content": "### ***Please Upvote !!!***\\n#### 1. Nested loop:\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int sum1 = nums[i] + nums[i + 1];\\n            for (int j = i + 1; j < nums.length - 1; j++) {\\n                int sum2 = nums[j] + nums[j + 1];\\n                if (sum1 == sum2) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\\n#### 2. Single loop (using hashset):\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            int sum = nums[i] + nums[i + 1];\\n            if (set.contains(sum)) return true;\\n            set.add(sum);\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int sum1 = nums[i] + nums[i + 1];\\n            for (int j = i + 1; j < nums.length - 1; j++) {\\n                int sum2 = nums[j] + nums[j + 1];\\n                if (sum1 == sum2) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            int sum = nums[i] + nums[i + 1];\\n            if (set.contains(sum)) return true;\\n            set.add(sum);\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525977,
                "title": "java-very-easy-with-3-sections-to-understand-easily",
                "content": "```\\nclass Solution {\\n    public  boolean findSubarrays(int[] nums) {\\n        HashMap<Integer,Integer>hmap = new HashMap<>();\\n       ArrayList<Integer>sum= new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(i+1<nums.length){\\n            sum.add(nums[i]+nums[i+1]);\\n            }\\n        }\\n      \\n        for(int i=0;i<sum.size();i++){\\n            if(hmap.containsKey(sum.get(i))){\\n                int ov =hmap.get(sum.get(i));\\n                int nv = ov+1;\\n                hmap.put(sum.get(i),nv);\\n            }else{\\n                hmap.put(sum.get(i),1);\\n            }\\n        }\\n        for(int key:hmap.keySet()){\\n            if(hmap.get(key)>1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public  boolean findSubarrays(int[] nums) {\\n        HashMap<Integer,Integer>hmap = new HashMap<>();\\n       ArrayList<Integer>sum= new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(i+1<nums.length){\\n            sum.add(nums[i]+nums[i+1]);\\n            }\\n        }\\n      \\n        for(int i=0;i<sum.size();i++){\\n            if(hmap.containsKey(sum.get(i))){\\n                int ov =hmap.get(sum.get(i));\\n                int nv = ov+1;\\n                hmap.put(sum.get(i),nv);\\n            }else{\\n                hmap.put(sum.get(i),1);\\n            }\\n        }\\n        for(int key:hmap.keySet()){\\n            if(hmap.get(key)>1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525435,
                "title": "python-solution-90-faster",
                "content": "![image](https://assets.leetcode.com/users/images/fa5e7d31-5e52-4bdf-a99e-77cd127844da_1662224924.937164.png)\\n\\nclass Solution:\\n\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n      z=[]\\n      y = deque(nums[:2])\\n      z.append(sum(y))\\n      j = 2\\n      while j < len(nums):\\n        y.popleft()\\n        y.append(nums[j])\\n        z.append(sum(y))\\n        j+=1\\n      if len(z)==len(set(z)):\\n        return False\\n      return True\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/fa5e7d31-5e52-4bdf-a99e-77cd127844da_1662224924.937164.png)\\n\\nclass Solution:\\n\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n      z=[]\\n      y = deque(nums[:2])\\n      z.append(sum(y))\\n      j = 2\\n      while j < len(nums):\\n        y.popleft()\\n        y.append(nums[j])\\n        z.append(sum(y))\\n        j+=1\\n      if len(z)==len(set(z)):\\n        return False\\n      return True\\n",
                "codeTag": "Java"
            },
            {
                "id": 2525365,
                "title": "c-easy-brute",
                "content": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        for ( int i=0; i<n-1; i++) {\\n            for ( int j = i+1; j<n-1; j++) {\\n                if( nums[i]+nums[i+1] == nums[j]+nums[j+1]) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        for ( int i=0; i<n-1; i++) {\\n            for ( int j = i+1; j<n-1; j++) {\\n                if( nums[i]+nums[i+1] == nums[j]+nums[j+1]) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525342,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        int sum = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int n = nums.length;\\n        int j = 1;\\n        for(int i = 0; i < n-1; i++) {\\n            sum = nums[i] + nums[j];\\n            map.put(sum,map.getOrDefault(sum,0)+1);\\n            j++;\\n        }\\n        int count = 0;\\n        for(int num: map.values()) {\\n            if(num > 1) {\\n                count++;\\n            }\\n        }\\n        if(count >= 1) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        int sum = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int n = nums.length;\\n        int j = 1;\\n        for(int i = 0; i < n-1; i++) {\\n            sum = nums[i] + nums[j];\\n            map.put(sum,map.getOrDefault(sum,0)+1);\\n            j++;\\n        }\\n        int count = 0;\\n        for(int num: map.values()) {\\n            if(num > 1) {\\n                count++;\\n            }\\n        }\\n        if(count >= 1) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525205,
                "title": "java-sliding-window-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        \\n        Map<Long, Integer> map = new HashMap<>();\\n        \\n        int i=0, j=0; long sum = 0;\\n        while(j < nums.length) {\\n            \\n            sum += nums[j];\\n            \\n            if(j-i+1 < 2) j++;\\n            \\n            else if(j-i+1 == 2) {  \\n                if(map.containsKey(sum)) return true;\\n                else map.put(sum, map.getOrDefault(sum, 0) + 1);\\n                sum -= nums[i];\\n                j++; i++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        \\n        Map<Long, Integer> map = new HashMap<>();\\n        \\n        int i=0, j=0; long sum = 0;\\n        while(j < nums.length) {\\n            \\n            sum += nums[j];\\n            \\n            if(j-i+1 < 2) j++;\\n            \\n            else if(j-i+1 == 2) {  \\n                if(map.containsKey(sum)) return true;\\n                else map.put(sum, map.getOrDefault(sum, 0) + 1);\\n                sum -= nums[i];\\n                j++; i++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525177,
                "title": "java-solution-hashset",
                "content": "```java \\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            int sum = nums[i]+nums[i+1];\\n            int prev=set.size();\\n            set.add(sum);\\n            if(set.size()==prev)\\n                return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            int sum = nums[i]+nums[i+1];\\n            int prev=set.size();\\n            set.add(sum);\\n            if(set.size()==prev)\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2525125,
                "title": "100-fast",
                "content": "\\t\\tclass Solution {\\n\\tpublic:\\n    bool findSubarrays(vector<int>& nums) {\\n    \\n        unordered_set<int>set;\\n        int n =nums.size(); \\n        \\n        for(int i=0;i<n-1;i++){\\n            if(set.find(nums[i]+nums[i+1])!=set.end())\\n                return true;\\n            else \\n                set.insert(nums[i]+nums[i+1]);\\n        }\\n    return false;\\n    \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool findSubarrays(vector<int>& nums) {\\n    \\n        unordered_set<int>set;\\n        int n =nums.size(); \\n        \\n        for(int i=0;i<n-1;i++){\\n            if(set.find(nums[i]+nums[i+1])!=set.end())\\n                return true;\\n            else \\n                set.insert(nums[i]+nums[i+1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2525054,
                "title": "easy-hashmap-solution",
                "content": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        if len(nums) <= 2:\\n            return False\\n        seen = set()\\n        for i in range(len(nums)-2):\\n            first = sum(nums[i:i+2])\\n            second = sum(nums[i+1:i+3])\\n            seen.add(first)\\n            if second in seen:\\n                return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        if len(nums) <= 2:\\n            return False\\n        seen = set()\\n        for i in range(len(nums)-2):\\n            first = sum(nums[i:i+2])\\n            second = sum(nums[i+1:i+3])\\n            seen.add(first)\\n            if second in seen:\\n                return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525028,
                "title": "python-99-easy-simple-solution-set",
                "content": "#### Easy Solution:\\n* Sum the two indexes `getSum`\\n* If the `getSum` is in `sums` array then return true\\n* Else add the summation into the array\\n* After iterate through the array return false as there is no similar sum\\n```\\nclass Solution:\\n\\tdef findSubarrays(self, nums: list[int]) -> bool:\\n\\t\\tsums = set()\\n\\n\\t\\tfor i in range(len(nums) - 1):\\n\\t\\t\\tgetSum = nums[i] + nums[i + 1]\\n\\t\\t\\tif getSum in sums:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tsums.add(getSum)\\n\\t\\treturn False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef findSubarrays(self, nums: list[int]) -> bool:\\n\\t\\tsums = set()\\n\\n\\t\\tfor i in range(len(nums) - 1):\\n\\t\\t\\tgetSum = nums[i] + nums[i + 1]\\n\\t\\t\\tif getSum in sums:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tsums.add(getSum)\\n\\t\\treturn False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524999,
                "title": "c-hashmap-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            int c=nums[i]+nums[i+1];\\n            if(m.find(c)!=m.end())\\n                return 1;\\n            m[c]=1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            int c=nums[i]+nums[i+1];\\n            if(m.find(c)!=m.end())\\n                return 1;\\n            m[c]=1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524994,
                "title": "c-short-clean-easy-bruteforce",
                "content": "![image](https://assets.leetcode.com/users/images/f079ef63-3f7f-4a89-b5ff-e07add6282df_1662221429.1087756.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool findSubarrays(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<n-1;i++){\\n\\t\\t\\t\\tfor(int j=i+1;j<n-1;j++){\\n\\t\\t\\t\\t\\tif(nums[j]+nums[j+1]==nums[i]+nums[i+1]) count++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count>=1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool findSubarrays(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<n-1;i++){\\n\\t\\t\\t\\tfor(int j=i+1;j<n-1;j++){\\n\\t\\t\\t\\t\\tif(nums[j]+nums[j+1]==nums[i]+nums[i+1]) count++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2524975,
                "title": "c-hashset-easy-and-fast",
                "content": "```\\npublic bool FindSubarrays(int[] nums) {\\n        if (nums.Length < 3) return false;\\n        \\n        var set = new HashSet<int>();\\n        for (var i = 0; i < nums.Length - 1; i++)\\n        {\\n            var sum = 0;\\n            sum = nums[i] + nums[i+1];\\n            if (set.Contains(sum)) return true;\\n            set.Add(sum);\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic bool FindSubarrays(int[] nums) {\\n        if (nums.Length < 3) return false;\\n        \\n        var set = new HashSet<int>();\\n        for (var i = 0; i < nums.Length - 1; i++)\\n        {\\n            var sum = 0;\\n            sum = nums[i] + nums[i+1];\\n            if (set.Contains(sum)) return true;\\n            set.Add(sum);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524826,
                "title": "unordered-map-easy-to-understand",
                "content": "```\\nbool findSubarrays(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n-1;i++){\\n            int sum=nums[i]+nums[i+1];\\n            if(mp.find(sum)!=mp.end()) \\n                return true;\\n            mp[sum]++;\\n        }\\n        return false;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool findSubarrays(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n-1;i++){\\n            int sum=nums[i]+nums[i+1];\\n            if(mp.find(sum)!=mp.end()) \\n                return true;\\n            mp[sum]++;\\n        }\\n        return false;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524768,
                "title": "c-sliding-window",
                "content": "Time Complexity : O(n)\\nSpace Complexity : O(n)\\n\\n```\\n  bool findSubarrays(vector<int>& nums) {\\n        \\n        unordered_map<long long int,int> mp; // To store occurrences of sum\\n        \\n        int i=0,j=0; \\n        long long sum = 0; // Stores sum of elements in window\\n        \\n        while(j<nums.size()){\\n            \\n            sum+=nums[j];  // Adding current element to sum;\\n            \\n            // (j - i + 1) is the window size\\n            if(j-i+1<2) j++; // if window size is smaller than 2, increment j ( increase window size )  \\n            \\n            // If window size is equal to 2, maintain it\\n            if(j-i+1 == 2){ \\n                // Find if sum exists in the map, if exists subarray of length 2 exists\\n                if(mp.find(sum)!=mp.end()) return true;\\n                \\n                mp[sum]++; // if sum is not present in the map then store the sum into the map\\n                \\n                sum-=nums[i];  // subtract element present at starting of the window from sum as we will slide the window\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n  bool findSubarrays(vector<int>& nums) {\\n        \\n        unordered_map<long long int,int> mp; // To store occurrences of sum\\n        \\n        int i=0,j=0; \\n        long long sum = 0; // Stores sum of elements in window\\n        \\n        while(j<nums.size()){\\n            \\n            sum+=nums[j];  // Adding current element to sum;\\n            \\n            // (j - i + 1) is the window size\\n            if(j-i+1<2) j++; // if window size is smaller than 2, increment j ( increase window size )  \\n            \\n            // If window size is equal to 2, maintain it\\n            if(j-i+1 == 2){ \\n                // Find if sum exists in the map, if exists subarray of length 2 exists\\n                if(mp.find(sum)!=mp.end()) return true;\\n                \\n                mp[sum]++; // if sum is not present in the map then store the sum into the map\\n                \\n                sum-=nums[i];  // subtract element present at starting of the window from sum as we will slide the window\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524749,
                "title": "javascript-easy-to-understand",
                "content": "```\\nconst findSubarrays = function(nums) {\\n  const count = {};  // to keep track of subArray sums\\n  \\n  for (let i = 0; i < nums.length; i++) {\\n      let sum = 0;\\n\\t  \\n\\t  //  calculate the sum for a subArray\\n      for (let j = i; j < i + 2; j++) {\\n          sum += nums[j];\\n      }\\n\\t  \\n\\t  // if this sum exists in hashmap return true, otherwise store it in the hashmap\\n      if (count[sum]) return true;\\n      count[sum] = 1;\\n  }\\n  \\n  return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findSubarrays = function(nums) {\\n  const count = {};  // to keep track of subArray sums\\n  \\n  for (let i = 0; i < nums.length; i++) {\\n      let sum = 0;\\n\\t  \\n\\t  //  calculate the sum for a subArray\\n      for (let j = i; j < i + 2; j++) {\\n          sum += nums[j];\\n      }\\n\\t  \\n\\t  // if this sum exists in hashmap return true, otherwise store it in the hashmap\\n      if (count[sum]) return true;\\n      count[sum] = 1;\\n  }\\n  \\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2524738,
                "title": "greedy-approach-hashmap-tc-o-n",
                "content": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        \\n        hashset=set()\\n        for i in range(len(nums)-1):\\n            if nums[i]+nums[i+1] in hashset:\\n                return True\\n            else:\\n                hashset.add(nums[i]+nums[i+1])\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        \\n        hashset=set()\\n        for i in range(len(nums)-1):\\n            if nums[i]+nums[i+1] in hashset:\\n                return True\\n            else:\\n                hashset.add(nums[i]+nums[i+1])\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524692,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& v) {\\n        int sz = v.size();\\n        unordered_map<int, int>ump;\\n        for (int i = 0;i < sz - 1;++i) {\\n            ump[v[i] + v[i + 1]]++;\\n        }\\n        for (auto it : ump) {\\n            if (it.second > 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& v) {\\n        int sz = v.size();\\n        unordered_map<int, int>ump;\\n        for (int i = 0;i < sz - 1;++i) {\\n            ump[v[i] + v[i + 1]]++;\\n        }\\n        for (auto it : ump) {\\n            if (it.second > 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092305,
                "title": "discuss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n\\n        for (int i = 1; i < nums.length; ++i) {\\n        final int sum = nums[i - 1] + nums[i];\\n        if (seen.contains(sum))\\n            return true;\\n        seen.add(sum);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> seen = new HashSet<>();\\n\\n        for (int i = 1; i < nums.length; ++i) {\\n        final int sum = nums[i - 1] + nums[i];\\n        if (seen.contains(sum))\\n            return true;\\n        seen.add(sum);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090582,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        return len(set(map(sum, pairwise(nums)))) < len(nums)-1\\n\\n```\\n\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        return len(set(a+b for a, b in pairwise(nums))) < len(nums)-1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        return len(set(map(sum, pairwise(nums)))) < len(nums)-1\\n\\n```\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        return len(set(a+b for a, b in pairwise(nums))) < len(nums)-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089126,
                "title": "o-n-solution-using-a-map",
                "content": "# Intuition\\nWe store the sums of all the subarrays of `nums`. After that we check if any of the sums appear more the once, returning 1 in case there is.\\n\\n\\n# Complexity\\n- Time complexity:\\n$O(n)$\\n\\n- Space complexity:\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int, int> sums;\\n        int n = nums.size();\\n        for(int i = 0; i < n - 1; i++){\\n            int sum = nums[i] + nums[i + 1];\\n            sums[sum]++;\\n        }\\n        for(auto i : sums){\\n            if(i.second > 1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int, int> sums;\\n        int n = nums.size();\\n        for(int i = 0; i < n - 1; i++){\\n            int sum = nums[i] + nums[i + 1];\\n            sums[sum]++;\\n        }\\n        for(auto i : sums){\\n            if(i.second > 1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078442,
                "title": "c-solution-using-hashset",
                "content": "# Approach\\n- Use `HashSet` to track sums\\n- If sum of currect pair contains in the hashset return `true`\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public bool FindSubarrays(int[] nums)\\n    {\\n        var hashSet = new HashSet<int>();\\n        \\n        for (var i = 1; i < nums.Length; i++)\\n        {\\n            var sum = nums[i- 1] + nums[i];\\n\\n            if (hashSet.Contains(sum))\\n            {\\n                return true;\\n            }\\n            \\n            hashSet.Add(sum);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool FindSubarrays(int[] nums)\\n    {\\n        var hashSet = new HashSet<int>();\\n        \\n        for (var i = 1; i < nums.Length; i++)\\n        {\\n            var sum = nums[i- 1] + nums[i];\\n\\n            if (hashSet.Contains(sum))\\n            {\\n                return true;\\n            }\\n            \\n            hashSet.Add(sum);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072253,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        \\n        set<int> s;\\n        for(int i=1;i<nums.size();i++)\\n        {int pref=0;\\n            pref=nums[i]+nums[i-1];\\n            if(s.find(pref)!=s.end())\\n            {\\n                return true;\\n            }\\n            s.insert(pref);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        \\n        set<int> s;\\n        for(int i=1;i<nums.size();i++)\\n        {int pref=0;\\n            pref=nums[i]+nums[i-1];\\n            if(s.find(pref)!=s.end())\\n            {\\n                return true;\\n            }\\n            s.insert(pref);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056771,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            int sum=nums[i]+nums[i+1];\\n            mp[sum]++;\\n            if(mp[sum]==2)\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n\\n        for(int i=0;i<nums.size()-1;i++){\\n            int sum=nums[i]+nums[i+1];\\n            mp[sum]++;\\n            if(mp[sum]==2)\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048157,
                "title": "100-beats-swift-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func findSubarrays(_ nums: [Int]) -> Bool {\\n        var set: Set<Int> = []\\n        for i in 0..<nums.count - 1 {\\n            let cur = nums[i] + nums[i + 1]\\n            if set.contains(cur) {\\n                return true\\n            }\\n            set.insert(cur)\\n        }\\n\\n        return false \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findSubarrays(_ nums: [Int]) -> Bool {\\n        var set: Set<Int> = []\\n        for i in 0..<nums.count - 1 {\\n            let cur = nums[i] + nums[i + 1]\\n            if set.contains(cur) {\\n                return true\\n            }\\n            set.insert(cur)\\n        }\\n\\n        return false \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046182,
                "title": "java-2approch-bruteforce-and-optiminal-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=1; i<nums.length; i++){\\n            if(!set.add(nums[i-1]+nums[i])) return true;\\n        }\\n        return false;\\n    }\\n\\n//TC:- O(n2)\\n//SC:- O(1)\\n/*\\n        for(int i=0; i<nums.length-1; i++){\\n            int temp = nums[i]+nums[i+1];\\n            for(int j=i+1; j<nums.length-1; j++){\\n                if(temp == (nums[j]+nums[j+1])) return true;\\n            }\\n        }\\n        return false;\\n*/\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "class Solution {\\n    public boolean findSubarrays(int[] nums) {\\n\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=1; i<nums.length; i++){\\n            if(!set.add(nums[i-1]+nums[i])) return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4035954,
                "title": "very-easy-simple-for-beginners-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        a=[]\\n        flag=0\\n        for i in range(len(nums)-1):\\n            if (nums[i]+nums[i+1]) in a:\\n                flag=1\\n                break\\n            else:\\n                a.append(nums[i]+nums[i+1])\\n        if flag==1:\\n            return True\\n        else:\\n            return False\\n\\n                \\n              \\n\\n\\n\\n\\n        \\n        \\n\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        a=[]\\n        flag=0\\n        for i in range(len(nums)-1):\\n            if (nums[i]+nums[i+1]) in a:\\n                flag=1\\n                break\\n            else:\\n                a.append(nums[i]+nums[i+1])\\n        if flag==1:\\n            return True\\n        else:\\n            return False\\n\\n                \\n              \\n\\n\\n\\n\\n        \\n        \\n\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034432,
                "title": "python-easy-solution-python-step-wise-solution",
                "content": "# PYTHON EASY SOLUTION || PYTHON || STEP WISE SOLUTION || \\u270C\\u270C\\n# Runtime\\n- 45ms\\n- Beats 59.81%of users with Python3\\n# Memory\\n- 16.52MB\\n- Beats 12.71%of users with Python3\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        res = []\\n\\n        for i in range(0,len(nums)-1):\\n            if nums[i] + nums[i+1] in res:\\n                return True\\n            else:\\n                res.append(nums[i]+nums[i+1])\\n        \\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        res = []\\n\\n        for i in range(0,len(nums)-1):\\n            if nums[i] + nums[i+1] in res:\\n                return True\\n            else:\\n                res.append(nums[i]+nums[i+1])\\n        \\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008928,
                "title": "java-fast-100-easy-to-understand-2-pointer-approach",
                "content": "Iterate over the array and find the sum of all the sub-arrays by maintaing 2 pointers. Insert the sum to a set, and once we get a false while performing the add() operation into the set we return true as we have found that their exists a pair with same sum.\\n\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n\\t\\tSet<Integer> set = new HashSet<>();\\n\\t\\tint i = 0; int k = i + 1;\\n\\t\\twhile(k < nums.length) {\\n\\t\\t\\tif(!set.add(nums[i] + nums[k])) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tk++; i++;\\n\\t\\t}\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n\\t\\tSet<Integer> set = new HashSet<>();\\n\\t\\tint i = 0; int k = i + 1;\\n\\t\\twhile(k < nums.length) {\\n\\t\\t\\tif(!set.add(nums[i] + nums[k])) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tk++; i++;\\n\\t\\t}\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004340,
                "title": "c-unordered-map-0ms-100-faster-easy-understanding",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<long long, int>myMap;\\n        long long sum = nums[0] + nums[1];\\n        myMap[sum]++;\\n        for(int i=2; i<n; i++){\\n            sum+=nums[i];\\n            sum-=nums[i-2];\\n        if(myMap.find(sum) != myMap.end() && myMap[sum]>0) return true;\\n            myMap[sum]++;\\n     }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<long long, int>myMap;\\n        long long sum = nums[0] + nums[1];\\n        myMap[sum]++;\\n        for(int i=2; i<n; i++){\\n            sum+=nums[i];\\n            sum-=nums[i-2];\\n        if(myMap.find(sum) != myMap.end() && myMap[sum]>0) return true;\\n            myMap[sum]++;\\n     }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997597,
                "title": "c-o-n-solution",
                "content": "# Algorithm \\n- create the count of sum of adjacent elements \\n- if you get the count greater than 1 then true\\n- else false \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int, int> ump;\\n        int n = nums.size(); \\n        for(int i = 0; i+1 < n; ++i) {\\n            int sm = nums[i] + nums[i+1];\\n            ump[sm]++;\\n            if(ump[sm] >= 2) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int, int> ump;\\n        int n = nums.size(); \\n        for(int i = 0; i+1 < n; ++i) {\\n            int sm = nums[i] + nums[i+1];\\n            ump[sm]++;\\n            if(ump[sm] >= 2) return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988044,
                "title": "java-simple-hashset-solution-o-n-beginner-level",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>(); \\n        for(int i=0;i<nums.length -1;i++){\\n            int val = nums[i] + nums[i+1];\\n\\n            if(set.contains(val)){\\n                return true;\\n            }\\n\\n            set.add(val);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        HashSet<Integer> set = new HashSet<>(); \\n        for(int i=0;i<nums.length -1;i++){\\n            int val = nums[i] + nums[i+1];\\n\\n            if(set.contains(val)){\\n                return true;\\n            }\\n\\n            set.add(val);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986850,
                "title": "simple-implementation-using-hashset-with-0ms-runtime-java",
                "content": "# Intuition\\nWe must check each pair of integers in the array until we either reach the last pair (returning **false**), or find a pair with a sum equal to a previous pair (returning **true**).\\n\\n# Approach\\nInstead of comparing each pair of integers to every other pair in the array (requiring a time complexity of $$O(n^2)$$), we can track the sum of each pair in some type of collection. If we encounter a pair with a sum that already exists in the collection, we can stop iterating through the array and return **true**. Otherwise, after iterating through the entire array, we return **false**. Since we only need to track whether a sum has been found instead of the total number of times a sum has been found, we can use a **HashSet** to store each sum instead of something like a **HashMap** which requires more memory. We attempt to add each sum to the set, returning true if the sum is already found to exist in the set.\\n\\n# Complexity\\n- Time complexity:\\nBest Case: $$O(1)$$\\nWorst Case: $$O(n)$$\\n\\n- Space complexity:\\nBest Case: $$O(1)$$\\nWorst Case: $$O(n)$$\\n\\n# Code\\n```\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        HashSet<Integer> sums = new HashSet<>();\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (!sums.add(nums[i] + nums[i + 1])) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        HashSet<Integer> sums = new HashSet<>();\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (!sums.add(nums[i] + nums[i + 1])) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985912,
                "title": "use-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        if(nums.length==2)return false;\\n       HashSet<Integer>set=new HashSet<>();\\n       for(int i=1;i<nums.length;i++){\\n           if(set.contains(nums[i]+nums[i-1]))return true;\\n           set.add(nums[i]+nums[i-1]);\\n       }\\n       return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        if(nums.length==2)return false;\\n       HashSet<Integer>set=new HashSet<>();\\n       for(int i=1;i<nums.length;i++){\\n           if(set.contains(nums[i]+nums[i-1]))return true;\\n           set.add(nums[i]+nums[i-1]);\\n       }\\n       return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983428,
                "title": "simple-c-solution-using-hashmap",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size()-1;i++){\\n            int sum=nums[i]+nums[i+1];\\n            if(m[sum])\\n            return true;\\n            m[sum]++;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size()-1;i++){\\n            int sum=nums[i]+nums[i+1];\\n            if(m[sum])\\n            return true;\\n            m[sum]++;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980183,
                "title": "simple-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\nif(hs.contains(nums[i]+nums[i+1]))\\n    return true;\\nelse\\n    hs.add(nums[i]+nums[i+1]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\nif(hs.contains(nums[i]+nums[i+1]))\\n    return true;\\nelse\\n    hs.add(nums[i]+nums[i+1]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979998,
                "title": "simple-o-n-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(nsli)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& arr) {\\n        int i = 0 , j = 0 , n = arr.size(),sum = 0;\\n        unordered_map<int,int>m;\\n\\n        while(j<n){\\n            sum+=arr[j];\\n            if( (j-i+1)  < 2){\\n                j++;\\n            }\\n            else if((j-i+1) == 2){\\n                if(m.find(sum) != m.end()){\\n                    return true;\\n                }\\n                else{\\n                    m[sum]++;\\n                }\\n                j++;\\n                sum-=arr[i];\\n                i++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& arr) {\\n        int i = 0 , j = 0 , n = arr.size(),sum = 0;\\n        unordered_map<int,int>m;\\n\\n        while(j<n){\\n            sum+=arr[j];\\n            if( (j-i+1)  < 2){\\n                j++;\\n            }\\n            else if((j-i+1) == 2){\\n                if(m.find(sum) != m.end()){\\n                    return true;\\n                }\\n                else{\\n                    m[sum]++;\\n                }\\n                j++;\\n                sum-=arr[i];\\n                i++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962686,
                "title": "python-beats-100-explanation-easy-for-beginners-single-line",
                "content": "# Approach\\n1. First, we examine if the length of the array is greater than 2. In this code, I use the \"walrus operator\" (**:=**) to directly assign the value of **len(nums) - 1** to a variable called \\'**n**\\'. If the length is not greater than 2, we return False because with only one subarray, we can\\'t meet the condition described in the question.\\n\\n2. The next step is to create a set containing the sums of all subarrays with 2 elements.\\n\\n3. If all the sums in the set are unique, the set\\'s length should be the same as \\'**n**\\' (which we calculated earlier as **len(nums) - 1**). If the length of the set is smaller than \\'**n**\\', it means there are at least two equal sums.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        return n != len({nums[i]+nums[i+1] for i in range(n)}) if (n:=len(nums)-1) != 1 else False\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        return n != len({nums[i]+nums[i+1] for i in range(n)}) if (n:=len(nums)-1) != 1 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957750,
                "title": "find-subarrays-with-equal-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(arr.contains(nums[i]+nums[i+1]))\\n            return true;\\n            else\\n            arr.add(nums[i]+nums[i+1]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(arr.contains(nums[i]+nums[i+1]))\\n            return true;\\n            else\\n            arr.add(nums[i]+nums[i+1]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957746,
                "title": "sliding-window-approach-of-the-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore the sum of two size subarray in some memory location.\\nAnd finding the sum we visited or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) -> n is the size of the nums vector.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) n is the size of the vector nums.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        \\n\\n        int size = nums.size();\\n\\n        unordered_map<int,int>mp;\\n        // int length = 0;\\n        long long int sum = nums[0] + nums[1];\\n        mp[sum] = 0;\\n        for(int i = 1; i<nums.size()-1; i++)\\n        {\\n            sum = sum + nums[i+1] - nums[i-1];\\n            if(mp.count(sum))\\n                return 1;\\n\\n            mp[sum] = i;\\n\\n        /*\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            \\n            sum += nums[i];\\n            length++;\\n            if(mp.count(sum))\\n                return 1;\\n\\n            if( length == 2 )\\n            {\\n                mp[sum] = i;\\n                sum = nums[i];\\n                length = 1;\\n            }    \\n            */\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        \\n\\n        int size = nums.size();\\n\\n        unordered_map<int,int>mp;\\n        // int length = 0;\\n        long long int sum = nums[0] + nums[1];\\n        mp[sum] = 0;\\n        for(int i = 1; i<nums.size()-1; i++)\\n        {\\n            sum = sum + nums[i+1] - nums[i-1];\\n            if(mp.count(sum))\\n                return 1;\\n\\n            mp[sum] = i;\\n\\n        /*\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            \\n            sum += nums[i];\\n            length++;\\n            if(mp.count(sum))\\n                return 1;\\n\\n            if( length == 2 )\\n            {\\n                mp[sum] = i;\\n                sum = nums[i];\\n                length = 1;\\n            }    \\n            */\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955761,
                "title": "easy-to-understand-python3-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        for i in range(len(nums) - 1):\\n            sumval = nums[i] + nums[i+1]\\n\\n            for j in range(i+1, len(nums) - 1):\\n                if nums[j] + nums[j+1] == sumval:\\n                    return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        for i in range(len(nums) - 1):\\n            sumval = nums[i] + nums[i+1]\\n\\n            for j in range(i+1, len(nums) - 1):\\n                if nums[j] + nums[j+1] == sumval:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953669,
                "title": "clean-sliding-window-solution-explaned-with-meme",
                "content": "# Approach\\nThe very fact of having the same amount is important, so you don\\'t need to memorize indexes or other unnecessary information. We will go through the array and see if this sum has been found before.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        l=0\\n        buff=set()\\n        r=2\\n        while r<=len(nums):\\n            s = sum(nums[l:r])\\n            if s in buff:\\n                return True\\n            buff.add(s)\\n            r+=1\\n            l+=1\\n        return False\\n              \\n```\\nMeme:\\n![image.png](https://assets.leetcode.com/users/images/0ecd3560-9200-4fb7-87fa-ae2e72e9058f_1692869821.5354002.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        l=0\\n        buff=set()\\n        r=2\\n        while r<=len(nums):\\n            s = sum(nums[l:r])\\n            if s in buff:\\n                return True\\n            buff.add(s)\\n            r+=1\\n            l+=1\\n        return False\\n              \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951201,
                "title": "very-basic-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> set=new HashSet<>();\\n        for(int i=0;i<nums.length-1;i++){\\n            if(set.contains(nums[i]+nums[i+1]))\\n                return true;\\n            set.add(nums[i]+nums[i+1]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> set=new HashSet<>();\\n        for(int i=0;i<nums.length-1;i++){\\n            if(set.contains(nums[i]+nums[i+1]))\\n                return true;\\n            set.add(nums[i]+nums[i+1]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937595,
                "title": "easy-cpp-solution-using-unordered-map-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n\\n        for(int i=0; i<nums.size(); i++)\\n            if(i+1 < nums.size())\\n                mp[nums[i] + nums[i+1]]++;\\n\\n        for(auto i : mp) if(i.second >= 2) return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n\\n        for(int i=0; i<nums.size(); i++)\\n            if(i+1 < nums.size())\\n                mp[nums[i] + nums[i+1]]++;\\n\\n        for(auto i : mp) if(i.second >= 2) return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924943,
                "title": "c-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool FindSubarrays(int[] nums) {\\n\\n        int n = nums.Length;\\n        if(n<2)\\n        {\\n            return false;\\n        }\\n       HashSet<int> hs = new HashSet<int>();\\n       for(int i =1;i<nums.Length;i++)\\n       {\\n            if(hs.Contains(nums[i-1]+nums[i]))\\n            {\\n                return true;\\n            }else{\\n                hs.Add(nums[i-1]+nums[i]);\\n            }\\n       }\\n       return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool FindSubarrays(int[] nums) {\\n\\n        int n = nums.Length;\\n        if(n<2)\\n        {\\n            return false;\\n        }\\n       HashSet<int> hs = new HashSet<int>();\\n       for(int i =1;i<nums.Length;i++)\\n       {\\n            if(hs.Contains(nums[i-1]+nums[i]))\\n            {\\n                return true;\\n            }else{\\n                hs.Add(nums[i-1]+nums[i]);\\n            }\\n       }\\n       return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912228,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Map<Long,Integer>h= new HashMap();\\n        int n=nums.length;\\n        Long sum=(long)nums[0]+nums[1];\\n        h.put(sum,0);\\n        for(int i=2;i<n;i++){\\n            sum-=nums[i-2];\\n            sum+=nums[i];\\n            if(h.containsKey(sum)){\\n                if(h.get(sum)!=i)\\n                    return true;\\n            }\\n            else{\\n                h.put(sum,i);\\n            }\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Map<Long,Integer>h= new HashMap();\\n        int n=nums.length;\\n        Long sum=(long)nums[0]+nums[1];\\n        h.put(sum,0);\\n        for(int i=2;i<n;i++){\\n            sum-=nums[i-2];\\n            sum+=nums[i];\\n            if(h.containsKey(sum)){\\n                if(h.get(sum)!=i)\\n                    return true;\\n            }\\n            else{\\n                h.put(sum,i);\\n            }\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910906,
                "title": "easy-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        HashSet<Integer> hsum = new HashSet<Integer>();\\n        int sum = 0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(hsum.contains(nums[i]+nums[i+1])){\\n                return true;\\n            }\\n            hsum.add(nums[i]+nums[i+1]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        HashSet<Integer> hsum = new HashSet<Integer>();\\n        int sum = 0;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(hsum.contains(nums[i]+nums[i+1])){\\n                return true;\\n            }\\n            hsum.add(nums[i]+nums[i+1]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903923,
                "title": "simple-java-solution-time-complexity-o-n-space-complexity-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public boolean findSubarrays(int[] nums) \\n    {\\n        if (nums == null || nums.length == 0)\\n            return false;\\n\\n        int n = nums.length - 1;\\n        HashSet<Integer> subArrSum = new HashSet<>();\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (subArrSum.contains(nums[i] + nums[i + 1]))\\n                return true;\\n            else\\n                subArrSum.add(nums[i] + nums[i + 1]);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean findSubarrays(int[] nums) \\n    {\\n        if (nums == null || nums.length == 0)\\n            return false;\\n\\n        int n = nums.length - 1;\\n        HashSet<Integer> subArrSum = new HashSet<>();\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (subArrSum.contains(nums[i] + nums[i + 1]))\\n                return true;\\n            else\\n                subArrSum.add(nums[i] + nums[i + 1]);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898546,
                "title": "easiest-c-solution-beats-100",
                "content": "\\n# Complexity\\n- Time complexity:0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n\\n      unordered_set<int> s ;\\n\\n      for(int i = 0 ; i < nums.size()-1;i++)  \\n      {\\n          if(s.find(nums[i] + nums[i+1]) == s.end())\\n          s.insert(nums[i]+nums[i+1]);\\n          else\\n          return true ;\\n      }\\n       return false ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n\\n      unordered_set<int> s ;\\n\\n      for(int i = 0 ; i < nums.size()-1;i++)  \\n      {\\n          if(s.find(nums[i] + nums[i+1]) == s.end())\\n          s.insert(nums[i]+nums[i+1]);\\n          else\\n          return true ;\\n      }\\n       return false ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895119,
                "title": "java-with-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBy employing a set, I devised an approach that involves storing the sums of consecutive elements within the given array. This technique enables the identification of repeating sums, which serves as an indicator that two subarrays of equal length possess matching sums. If such a repeating sum is encountered during traversal, the function promptly returns true, as the condition has been met. Conversely, if the traversal concludes without any recurring sums being detected, the function gracefully returns false, denoting the absence of subarrays with identical sums. This strategy effectively leverages the set\\'s unique property to facilitate an efficient determination of the existence of these subarrays.\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        HashSet <Integer> set = new HashSet<Integer>();\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(i < nums.length - 1){\\n                if(!set.contains(nums[i] + nums[i + 1])) set.add(nums[i] + nums[i + 1]);\\n                else return true;\\n            }  \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        HashSet <Integer> set = new HashSet<Integer>();\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(i < nums.length - 1){\\n                if(!set.contains(nums[i] + nums[i + 1])) set.add(nums[i] + nums[i + 1]);\\n                else return true;\\n            }  \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885661,
                "title": "brute-force-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = 0;\\n\\n        for(int i=0; i<n-1; i++)\\n        {\\n            for(int j=i+1; j<n-1; j++)\\n            {\\n                if(nums[i] + nums[i+1] == nums[j] + nums[j+1])\\n                    count++;\\n            }\\n        }\\n        return count>=1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = 0;\\n\\n        for(int i=0; i<n-1; i++)\\n        {\\n            for(int j=i+1; j<n-1; j++)\\n            {\\n                if(nums[i] + nums[i+1] == nums[j] + nums[j+1])\\n                    count++;\\n            }\\n        }\\n        return count>=1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881315,
                "title": "elixir-simple-solution",
                "content": "```\\ndefmodule Solution do\\n  @spec find_subarrays(nums :: [integer]) :: boolean\\n  def find_subarrays(nums) do\\n    chunked_nums = Enum.chunk_every(nums, 2, 1)\\n\\n    chunked_nums\\n    |> List.delete_at(length(chunked_nums) - 1)\\n    |> Enum.map(&Enum.sum/1)\\n    |> Enum.frequencies()\\n    |> Enum.find_value(false, &(elem(&1, 1) >= 2 and true))\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec find_subarrays(nums :: [integer]) :: boolean\\n  def find_subarrays(nums) do\\n    chunked_nums = Enum.chunk_every(nums, 2, 1)\\n\\n    chunked_nums\\n    |> List.delete_at(length(chunked_nums) - 1)\\n    |> Enum.map(&Enum.sum/1)\\n    |> Enum.frequencies()\\n    |> Enum.find_value(false, &(elem(&1, 1) >= 2 and true))\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3873976,
                "title": "two-lines-of-code",
                "content": "# Intuition\\nYou gotta find out if there\\'s any two+ sets of adajacent pairs in the array with the same sum\\n\\n# Approach\\nCreate a new array that\\'s the sum of adajacent pairs of numbers in the original array. Test to see if there are any repeats by comparing the length of the array to the length of the array as cast to a set. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        sumar=[nums[i-1]+nums[i] for i in range(1,len(nums)) ]\\n        return len(set(sumar))!=len(sumar)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        sumar=[nums[i-1]+nums[i] for i in range(1,len(nums)) ]\\n        return len(set(sumar))!=len(sumar)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868342,
                "title": "beats-100-cpp-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTaking pairs of i and i+1 index and getting the sume of these two and storing them in map . If any sum has value which is divisible by 2 which means it should form pairs of 2. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n/2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        if(nums.size()<=2){\\n            return false;\\n        }\\n        map<int,int> mp;\\n        int i=0;\\n        int j=i+1;\\n       \\n       while(j<nums.size()){\\n         int  x=nums[i]+nums[j];\\n        mp[x]++;\\n         i++;\\n         j++;\\n\\n       }\\n       for(auto i:mp){\\n           if(i.second%2==0){\\n               return true;\\n           }\\n       }\\n       return false;\\n       \\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        if(nums.size()<=2){\\n            return false;\\n        }\\n        map<int,int> mp;\\n        int i=0;\\n        int j=i+1;\\n       \\n       while(j<nums.size()){\\n         int  x=nums[i]+nums[j];\\n        mp[x]++;\\n         i++;\\n         j++;\\n\\n       }\\n       for(auto i:mp){\\n           if(i.second%2==0){\\n               return true;\\n           }\\n       }\\n       return false;\\n       \\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866899,
                "title": "0-ms-c-using-sliding-window-and-set",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool findSubarrays(vector<int>& vec) {\\n\\n\\t\\tunordered_set<int>st;\\n\\n\\t\\tint i=0,j=0;\\n\\n\\t\\tint sum = 0;\\n\\n\\t\\tbool ans = false;\\n\\n\\t\\twhile(j<vec.size()){\\n\\t\\t\\tsum += vec[j];\\n\\t\\t\\tif((j-i+1)<2){\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}else if((j-i+1) == 2){\\n\\t\\t\\t\\tif(st.find(sum) != st.end()){\\n\\t\\t\\t\\t\\tans = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.insert(sum);\\n\\t\\t\\t\\tsum-=vec[i];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool findSubarrays(vector<int>& vec) {\\n\\n\\t\\tunordered_set<int>st;\\n\\n\\t\\tint i=0,j=0;\\n\\n\\t\\tint sum = 0;\\n\\n\\t\\tbool ans = false;\\n\\n\\t\\twhile(j<vec.size()){\\n\\t\\t\\tsum += vec[j];\\n\\t\\t\\tif((j-i+1)<2){\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3852635,
                "title": "c-solution-with-t-c-o-n-and-s-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int n = nums.size(),i = 0,j = 0,sum = 0;\\n        unordered_map<int,int> mp;\\n        while(j < n){\\n            sum += nums[j];\\n            if(j-i+1 < 2) j++;\\n            else if(j-i+1 == 2){\\n                mp[sum]++;\\n                if(mp[sum] > 1) return true;\\n                sum -= nums[i];\\n                i++;\\n                j++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        int n = nums.size(),i = 0,j = 0,sum = 0;\\n        unordered_map<int,int> mp;\\n        while(j < n){\\n            sum += nums[j];\\n            if(j-i+1 < 2) j++;\\n            else if(j-i+1 == 2){\\n                mp[sum]++;\\n                if(mp[sum] > 1) return true;\\n                sum -= nums[i];\\n                i++;\\n                j++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836193,
                "title": "set-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n    unordered_set<int>s;\\n        for(int i=1;i<nums.size();i++){\\n            if(s.find(nums[i]+nums[i-1])!=s.end()){\\n                return true;\\n            }\\n            s.insert(nums[i]+nums[i-1]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n    unordered_set<int>s;\\n        for(int i=1;i<nums.size();i++){\\n            if(s.find(nums[i]+nums[i-1])!=s.end()){\\n                return true;\\n            }\\n            s.insert(nums[i]+nums[i-1]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829966,
                "title": "sub-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool FindSubarrays(int[] nums) {\\n            List<int> list = new List<int>();\\n            int sum = 0;\\n            for (int i = 0; i < nums.Length - 1; i++)\\n            {\\n                sum = nums[i] + nums[i + 1];\\n                list.Add(sum);\\n            }\\n\\n            var k = list.GroupBy(x => x).Where(y => y.Count()>1).Select(y => new {kp =y.Key , np = y.Count() });\\n           \\n            foreach (var item in k)\\n            {\\n                if (item.np> 1)\\n                {\\n                    return true;\\n                }\\n            }\\n               \\n                return false;\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool FindSubarrays(int[] nums) {\\n            List<int> list = new List<int>();\\n            int sum = 0;\\n            for (int i = 0; i < nums.Length - 1; i++)\\n            {\\n                sum = nums[i] + nums[i + 1];\\n                list.Add(sum);\\n            }\\n\\n            var k = list.GroupBy(x => x).Where(y => y.Count()>1).Select(y => new {kp =y.Key , np = y.Count() });\\n           \\n            foreach (var item in k)\\n            {\\n                if (item.np> 1)\\n                {\\n                    return true;\\n                }\\n            }\\n               \\n                return false;\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828538,
                "title": "easy-go-golang-solution",
                "content": "```\\nfunc findSubarrays(nums []int) bool {\\n        mapper := make(map[int]int)\\n\\n        for i := 0; i < len(nums)-1; i++ {\\n                num := nums[i]\\n                next := nums[i+1]\\n                sum := num + next\\n\\n                mapper[sum]++\\n\\n                if mapper[sum] == 2 {\\n                        return true\\n                }\\n        }\\n\\n        return false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findSubarrays(nums []int) bool {\\n        mapper := make(map[int]int)\\n\\n        for i := 0; i < len(nums)-1; i++ {\\n                num := nums[i]\\n                next := nums[i+1]\\n                sum := num + next\\n\\n                mapper[sum]++\\n\\n                if mapper[sum] == 2 {\\n                        return true\\n                }\\n        }\\n\\n        return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3822070,
                "title": "swift-two-liner-o-n-space-o-n-time",
                "content": "# Code\\n```\\nclass Solution {\\n     func findSubarrays(_ nums: [Int]) -> Bool {\\n        var seen = Set<Int>()\\n        return (1..<nums.count).contains { !seen.insert(nums[$0] + nums[$0-1]).inserted }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n     func findSubarrays(_ nums: [Int]) -> Bool {\\n        var seen = Set<Int>()\\n        return (1..<nums.count).contains { !seen.insert(nums[$0] + nums[$0-1]).inserted }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822058,
                "title": "python-set-and-for-loop",
                "content": "# Code\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        sums = set()\\n        for i in range(len(nums) - 1):\\n            s = nums[i] + nums[i + 1]\\n            if s in sums:\\n                return True\\n            sums.add(s)\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        sums = set()\\n        for i in range(len(nums) - 1):\\n            s = nums[i] + nums[i + 1]\\n            if s in sums:\\n                return True\\n            sums.add(s)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820028,
                "title": "simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  bool findSubarrays(List<int> nums) {\\n  bool sum = false;\\n  for(int i = 0; i < nums.length - 1; i++) {\\n    for(int j = i + 1; j < nums.length - 1; j++) {\\n      if(nums[i] + nums[i + 1] == nums[j] + nums[j + 1]) {\\n        sum = true;\\n      }\\n    }\\n  }\\n  return sum;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  bool findSubarrays(List<int> nums) {\\n  bool sum = false;\\n  for(int i = 0; i < nums.length - 1; i++) {\\n    for(int j = i + 1; j < nums.length - 1; j++) {\\n      if(nums[i] + nums[i + 1] == nums[j] + nums[j + 1]) {\\n        sum = true;\\n      }\\n    }\\n  }\\n  return sum;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800645,
                "title": "7-ms-easy-java-solution-using-list",
                "content": "# Intuition\\nThe purpose of the given code is to find if there exists a contiguous subarray in the given integer array nums, such that the sum of any two consecutive elements in the subarray is also present in the subarray. \\n\\n# Approach\\n- The code iterates through the array and maintains a list l to keep track of the sums of consecutive elements encountered so far. \\n\\n- If, at any point, the sum of two consecutive elements is found to be already present in the list, it means that a subarray with the required property exists, and the function returns true. \\n\\n- Otherwise, it continues adding the sums to the list. If no such subarray is found, the function returns false.\\n\\n# Complexity\\n- Time complexity:\\n    The time complexity of the solution is O(n), where n is the number of elements in the given array nums. The code iterates through the array once.\\n\\n- Space complexity:\\n   The space complexity of the solution is O(n), where n is the number of elements in the given array nums. The space is used to store the sums of consecutive elements in the list l. In the worst case, the list l may contain all possible sums of consecutive elements, leading to O(n) space complexity.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        List<Integer> l = new ArrayList<Integer> ();\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            int sum = nums[i-1]+nums[i];\\n            if(l.contains(sum))\\n            return true;\\n            else \\n            l.add(sum);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        List<Integer> l = new ArrayList<Integer> ();\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            int sum = nums[i-1]+nums[i];\\n            if(l.contains(sum))\\n            return true;\\n            else \\n            l.add(sum);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790404,
                "title": "rust",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn find_subarrays(nums: Vec<i32>) -> bool {\\n        let mut hm:HashMap<i32,i32> = HashMap::new();\\n        let w = nums.windows(2);\\n        for n in w.into_iter(){\\n            let sum = n[0] + n[1];\\n            *hm.entry(sum).or_insert(0) += 1;\\n        }\\n        let res = hm.into_iter().filter(|p| p.1 > 1).map(|f| f.1).collect::<Vec<_>>();\\n        if res.len() > 0{\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn find_subarrays(nums: Vec<i32>) -> bool {\\n        let mut hm:HashMap<i32,i32> = HashMap::new();\\n        let w = nums.windows(2);\\n        for n in w.into_iter(){\\n            let sum = n[0] + n[1];\\n            *hm.entry(sum).or_insert(0) += 1;\\n        }\\n        let res = hm.into_iter().filter(|p| p.1 > 1).map(|f| f.1).collect::<Vec<_>>();\\n        if res.len() > 0{\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3788282,
                "title": "initial-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n// We have an array of elemeents that we are iterating essentially two elements at a time.  Using a hash table we can hash the sum as a key.  Per each iteration we are checking if the sum between two variables exist in the hash table, if it does exist, it instantly signifies a duplicate by which we return true;\\n\\nIf we go through all elements in the array it will instantly signify false\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a hash table by which we are hashing the sum of two elements in the array\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar findSubarrays = function(nums) {\\n\\n    let hash = {};\\n\\n    for(let i= 1; i < nums.length ; i++){\\n        let sum = nums[i] + nums[i-1];\\n\\n        if(hash[sum]){\\n            return true;\\n        }\\n\\n        hash[sum] = 1;\\n    }\\n\\n    return false;\\n\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar findSubarrays = function(nums) {\\n\\n    let hash = {};\\n\\n    for(let i= 1; i < nums.length ; i++){\\n        let sum = nums[i] + nums[i-1];\\n\\n        if(hash[sum]){\\n            return true;\\n        }\\n\\n        hash[sum] = 1;\\n    }\\n\\n    return false;\\n\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3787200,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int, int> sumFrequency;\\n        int n = nums.size();\\n        \\n        for (int i = 1; i < n; i++) {\\n            int sum = nums[i] + nums[i - 1];\\n            if (sumFrequency.count(sum) > 0) {\\n                return true;\\n            }\\n            sumFrequency[sum]++;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_map<int, int> sumFrequency;\\n        int n = nums.size();\\n        \\n        for (int i = 1; i < n; i++) {\\n            int sum = nums[i] + nums[i - 1];\\n            if (sumFrequency.count(sum) > 0) {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3782949,
                "title": "python3-solution-with-comments",
                "content": "# Code\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        ## Create a hashmap to store sums of subarrays\\n        hashmap = {}\\n        ## Loop through each value starting from 1 as we will be checking against i and i-1 to avoid index out of bounds\\n        for i in range(1, len(nums)): \\n            value = nums[i] + nums[i-1]\\n            #If the value is in thehashmap\\n            if value in hashmap: \\n                ##Return true\\n                return True\\n                ## Else add it to the map\\n            else: \\n                hashmap[value] = True\\n            ## If everything is checked and no matches are found we can default to false\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        ## Create a hashmap to store sums of subarrays\\n        hashmap = {}\\n        ## Loop through each value starting from 1 as we will be checking against i and i-1 to avoid index out of bounds\\n        for i in range(1, len(nums)): \\n            value = nums[i] + nums[i-1]\\n            #If the value is in thehashmap\\n            if value in hashmap: \\n                ##Return true\\n                return True\\n                ## Else add it to the map\\n            else: \\n                hashmap[value] = True\\n            ## If everything is checked and no matches are found we can default to false\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770315,
                "title": "easy-sliding-window-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n       int n=nums.size();\\n       map<int,int> m;\\n       int sum=0;\\n       int i=0;\\n       int j=0;\\n       while(j<n){\\n           sum=sum+nums[j];\\n           if(j-i+1<2){\\n               j++;\\n           }\\n           else if(j-i+1==2){\\n               if(m.find(sum)==m.end()){\\n                   m[sum]++;\\n               }\\n               else{\\n                   return true;\\n               }\\n               sum=sum-nums[i];\\n               i++;\\n               j++;\\n           }\\n       }\\n       return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n       int n=nums.size();\\n       map<int,int> m;\\n       int sum=0;\\n       int i=0;\\n       int j=0;\\n       while(j<n){\\n           sum=sum+nums[j];\\n           if(j-i+1<2){\\n               j++;\\n           }\\n           else if(j-i+1==2){\\n               if(m.find(sum)==m.end()){\\n                   m[sum]++;\\n               }\\n               else{\\n                   return true;\\n               }\\n               sum=sum-nums[i];\\n               i++;\\n               j++;\\n           }\\n       }\\n       return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765412,
                "title": "java-hashmap-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    HashMap<Integer, Integer> sub = new HashMap<>(); \\n    public boolean findSubarrays(int[] nums) \\n    {\\n        for(int i=0; i<nums.length-1;i++)\\n        {\\n            if(sub.containsKey(nums[i]+nums[i+1]))\\n            {\\n                return(true);    \\n            }\\n            sub.put(nums[i]+nums[i+1],1);\\n        }\\n        return(false); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer, Integer> sub = new HashMap<>(); \\n    public boolean findSubarrays(int[] nums) \\n    {\\n        for(int i=0; i<nums.length-1;i++)\\n        {\\n            if(sub.containsKey(nums[i]+nums[i+1]))\\n            {\\n                return(true);    \\n            }\\n            sub.put(nums[i]+nums[i+1],1);\\n        }\\n        return(false); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760608,
                "title": "beginner-friendly-with-comments-89-beats",
                "content": "# Intuition\\nBrute Force\\n\\n# Approach\\nCalculate the sums of subarrays, use a dictionary, where the key is the sum, the value is the number of meetings. If at least one value is greater than 2x, then we return True.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        dict1 = {} # Creating an empty dictionary\\n        i = 0 # Creating 2 counters\\n        j = 1\\n        while j < len(nums): # Until j got to the last element\\n            x = nums[i] + nums[j] # Counting the sum of the subarray\\n            i += 1 # Increasing counters by 1\\n            j += 1\\n            if x not in dict1: # If the sum of the subarray has not been encountered before\\n                dict1[x] = 1 # Assign the value 1 to the key\\n            else:\\n                dict1[x] += 1 # Increasing the value by 1\\n        for i in dict1.values(): # Let\\'s go through each dictionary value\\n            if i >= 2: # If the value occurs more than once, we return True\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        dict1 = {} # Creating an empty dictionary\\n        i = 0 # Creating 2 counters\\n        j = 1\\n        while j < len(nums): # Until j got to the last element\\n            x = nums[i] + nums[j] # Counting the sum of the subarray\\n            i += 1 # Increasing counters by 1\\n            j += 1\\n            if x not in dict1: # If the sum of the subarray has not been encountered before\\n                dict1[x] = 1 # Assign the value 1 to the key\\n            else:\\n                dict1[x] += 1 # Increasing the value by 1\\n        for i in dict1.values(): # Let\\'s go through each dictionary value\\n            if i >= 2: # If the value occurs more than once, we return True\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760560,
                "title": "java-easy-solution-hash-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n       HashSet<Integer> set=new HashSet<Integer>();\\n       for(int i=0;i<nums.length-1;i++)\\n       {\\n           if(set.contains(nums[i]+nums[i+1]))\\n           {\\n               return true;\\n           }\\n           set.add(nums[i]+nums[i+1]);\\n       }\\n       return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n       HashSet<Integer> set=new HashSet<Integer>();\\n       for(int i=0;i<nums.length-1;i++)\\n       {\\n           if(set.contains(nums[i]+nums[i+1]))\\n           {\\n               return true;\\n           }\\n           set.add(nums[i]+nums[i+1]);\\n       }\\n       return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753713,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            for (int j = i + 1; j < nums.length - 1; j++) {\\n                if (nums[i] + nums[i + 1] == nums[j] + nums[j + 1]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            for (int j = i + 1; j < nums.length - 1; j++) {\\n                if (nums[i] + nums[i + 1] == nums[j] + nums[j + 1]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751018,
                "title": "easy-java-solution-set",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n       Set<Integer> set = new HashSet<>();\\n       int i=1;\\n       while(i<nums.length){\\n           int sum = nums[i-1] + nums[i];\\n           if(set.contains(sum))\\n           return true;\\n           set.add(sum);\\n           i++;\\n       } \\n       return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n       Set<Integer> set = new HashSet<>();\\n       int i=1;\\n       while(i<nums.length){\\n           int sum = nums[i-1] + nums[i];\\n           if(set.contains(sum))\\n           return true;\\n           set.add(sum);\\n           i++;\\n       } \\n       return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750958,
                "title": "java-code",
                "content": "# Intuition\\ncreate an array list so that it adds sum of consecutive pairs.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse for loop and traverse thru all the elements and add pairs of elements and check whether that sum is present in array list or not \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public boolean findSubarrays(int[] nums) {\\n         ArrayList<Integer> r=new ArrayList<Integer>();\\n         for(int i=0;i<nums.length-1;i++)\\n         {\\n             if(r.contains(nums[i]+nums[i+1]))\\n             {\\n                 return true;\\n             }\\n             else\\n             {\\n                 r.add(nums[i]+nums[i+1]);\\n             }\\n         }\\n        return false;\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public boolean findSubarrays(int[] nums) {\\n         ArrayList<Integer> r=new ArrayList<Integer>();\\n         for(int i=0;i<nums.length-1;i++)\\n         {\\n             if(r.contains(nums[i]+nums[i+1]))\\n             {\\n                 return true;\\n             }\\n             else\\n             {\\n                 r.add(nums[i]+nums[i+1]);\\n             }\\n         }\\n        return false;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739420,
                "title": "java-simple-solution",
                "content": "\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0; i<nums.length-1; i++){\\n            if(set.contains(nums[i]+nums[i+1])) return true;\\n            set.add(nums[i]+nums[i+1]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0; i<nums.length-1; i++){\\n            if(set.contains(nums[i]+nums[i+1])) return true;\\n            set.add(nums[i]+nums[i+1]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730235,
                "title": "easy-c-solution-runtime-0ms",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool findSubarrays(int* nums, int numsSize){\\nint n=numsSize-1;\\nint arr[n],sum=0,index=0;\\nfor(int i=0;i<numsSize-1;i++)\\n{\\n   sum=nums[i]+nums[i+1];\\n   arr[index++]=sum;\\n   sum=0;\\n}\\nint flag=0;\\nfor(int i=0;i<n-1;i++)\\n{\\n    for(int j=i+1;j<n;j++)\\n    {\\n        if(arr[i]==arr[j])\\n        {\\n            return true;\\n            \\n        }\\n    }\\n}\\nreturn false;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nbool findSubarrays(int* nums, int numsSize){\\nint n=numsSize-1;\\nint arr[n],sum=0,index=0;\\nfor(int i=0;i<numsSize-1;i++)\\n{\\n   sum=nums[i]+nums[i+1];\\n   arr[index++]=sum;\\n   sum=0;\\n}\\nint flag=0;\\nfor(int i=0;i<n-1;i++)\\n{\\n    for(int j=i+1;j<n;j++)\\n    {\\n        if(arr[i]==arr[j])\\n        {\\n            return true;\\n            \\n        }\\n    }\\n}\\nreturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3720335,
                "title": "find-subarrays-with-equal-sum-easy-approach-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        if(nums.size()==2){\\n            return false;\\n        }\\n        vector<int> arr;\\n        for(int i=0;i<nums.size()-1;i++){\\n            arr.push_back(nums[i]+nums[i+1]);\\n        }\\n        set<int> s;\\n        for(int i=0;i<arr.size();i++){\\n            s.insert(arr[i]);\\n        }\\n        return s.size()==arr.size() ? 0:1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        if(nums.size()==2){\\n            return false;\\n        }\\n        vector<int> arr;\\n        for(int i=0;i<nums.size()-1;i++){\\n            arr.push_back(nums[i]+nums[i+1]);\\n        }\\n        set<int> s;\\n        for(int i=0;i<arr.size();i++){\\n            s.insert(arr[i]);\\n        }\\n        return s.size()==arr.size() ? 0:1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712776,
                "title": "1-pass-100-0ms-veryeasy-hashset",
                "content": "# Points to be Noted :\\n> Return Value for hashset add method: The function returns True if the element is not present in the HashSet otherwise False if the element is already present in the HashSet.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        if(nums.length==2) return false;\\n        HashSet<Integer> dup = new HashSet<>();\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(!dup.add(nums[i]+nums[i+1])) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        if(nums.length==2) return false;\\n        HashSet<Integer> dup = new HashSet<>();\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(!dup.add(nums[i]+nums[i+1])) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708678,
                "title": "o-n-solution-using-hash-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeeping a Set of seen values which are subarray sums of length 2. Checking if a sum is previously seen.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        HashSet<Integer> seen = new HashSet<>();\\n        int l = 0, r = 0;\\n        int ws = 0; \\n        while (r < nums.length) {\\n            while (r - l + 1 != 2) {\\n                ws += nums[r];\\n                r++;\\n            }\\n\\n            if (seen.contains(ws)) {\\n                return true;\\n            } else {\\n                seen.add(ws);\\n            }\\n            r++;\\n            if (r < nums.length) {\\n                ws += nums[r];\\n                ws -= nums[l];\\n                l++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        HashSet<Integer> seen = new HashSet<>();\\n        int l = 0, r = 0;\\n        int ws = 0; \\n        while (r < nums.length) {\\n            while (r - l + 1 != 2) {\\n                ws += nums[r];\\n                r++;\\n            }\\n\\n            if (seen.contains(ws)) {\\n                return true;\\n            } else {\\n                seen.add(ws);\\n            }\\n            r++;\\n            if (r < nums.length) {\\n                ws += nums[r];\\n                ws -= nums[l];\\n                l++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704067,
                "title": "beats-100-java-beginner-friendly",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i = 0; i < nums.length - 1; i++){\\n            int sum = 0;\\n            for(int j = i; j < i + 2; j++){\\n                sum += nums[j];\\n            }\\n            if(set.contains(sum)){\\n                return true;\\n            }else{\\n                set.add(sum);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean findSubarrays(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i = 0; i < nums.length - 1; i++){\\n            int sum = 0;\\n            for(int j = i; j < i + 2; j++){\\n                sum += nums[j];\\n            }\\n            if(set.contains(sum)){\\n                return true;\\n            }else{\\n                set.add(sum);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697378,
                "title": "c-linq-oneliner",
                "content": "```\\npublic class Solution {\\n    public bool FindSubarrays(int[] nums)\\n      => Enumerable\\n        .Range(0, nums.Length - 1)\\n        .GroupBy(i => nums[i..(i+2)].Sum())\\n        .Any(g => g.Count() >= 2);\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool FindSubarrays(int[] nums)\\n      => Enumerable\\n        .Range(0, nums.Length - 1)\\n        .GroupBy(i => nums[i..(i+2)].Sum())\\n        .Any(g => g.Count() >= 2);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688208,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findSubarrays(self, nums):\\n        if len(nums) < 3:\\n            return False\\n            return False\\n        lista2=[]\\n        for i in range(len(nums)):\\n            if i == len(nums) -1:\\n                if not [nums[i-1],nums[i]] in lista2:\\n                    lista2.append([nums[i-1],nums[i]])\\n        \\n                break\\n            if not [nums[i],nums[i+1]] in lista2:\\n                lista2.append([nums[i],nums[i+1]])\\n        lista3=[sum(elem) for elem in lista2]\\n        if lista3 == [0]:\\n            return True\\n        for i in lista3:\\n            if lista3.count(i) > 1:\\n                return True\\n        return False\\n        \\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findSubarrays(self, nums):\\n        if len(nums) < 3:\\n            return False\\n            return False\\n        lista2=[]\\n        for i in range(len(nums)):\\n            if i == len(nums) -1:\\n                if not [nums[i-1],nums[i]] in lista2:\\n                    lista2.append([nums[i-1],nums[i]])\\n        \\n                break\\n            if not [nums[i],nums[i+1]] in lista2:\\n                lista2.append([nums[i],nums[i+1]])\\n        lista3=[sum(elem) for elem in lista2]\\n        if lista3 == [0]:\\n            return True\\n        for i in lista3:\\n            if lista3.count(i) > 1:\\n                return True\\n        return False\\n        \\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666070,
                "title": "easy-js-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar findSubarrays = function(nums) {\\n    \\n    var arrayOfSums = [];\\n    for (let i = 0; i<nums.length; i++) {\\n        let currentNum1 = nums[i];\\n        let currentNum2 = nums[i+1]\\n        let currentSum = currentNum1 + currentNum2;\\n        if (arrayOfSums.includes(currentSum)) {\\n            return true;\\n        } else {\\n            arrayOfSums.push(currentSum);\\n        }\\n        \\n    }   \\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar findSubarrays = function(nums) {\\n    \\n    var arrayOfSums = [];\\n    for (let i = 0; i<nums.length; i++) {\\n        let currentNum1 = nums[i];\\n        let currentNum2 = nums[i+1]\\n        let currentSum = currentNum1 + currentNum2;\\n        if (arrayOfSums.includes(currentSum)) {\\n            return true;\\n        } else {\\n            arrayOfSums.push(currentSum);\\n        }\\n        \\n    }   \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3655601,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        set<int> s;\\n        for(int i=0;i<nums.size()-1;i++){\\n            int temp = nums[i]+nums[i+1];\\n            int x = s.size();\\n            s.insert(temp);\\n            if(s.size()==x)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        set<int> s;\\n        for(int i=0;i<nums.size()-1;i++){\\n            int temp = nums[i]+nums[i+1];\\n            int x = s.size();\\n            s.insert(temp);\\n            if(s.size()==x)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648730,
                "title": "easy-c-solution-100-faster-beginner-friendly",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_set<long> s;\\n        int n=nums.size();\\n        for(int i=0;i<n-1;i++){\\n            long prefixSum=nums[i]+nums[i+1];\\n            if(s.find(prefixSum)!=s.end())\\n                return true;\\n            else\\n                s.insert(prefixSum);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_set<long> s;\\n        int n=nums.size();\\n        for(int i=0;i<n-1;i++){\\n            long prefixSum=nums[i]+nums[i+1];\\n            if(s.find(prefixSum)!=s.end())\\n                return true;\\n            else\\n                s.insert(prefixSum);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641258,
                "title": "c-straighforward-solution-using-hashset-int-runtime-beats-100",
                "content": "# Intuition\\n![Leetcode.png](https://assets.leetcode.com/users/images/32c5e346-3027-43a2-a155-ccb72bcf1f17_1686827986.7741754.png)\\n\\n\\n# Approach\\nFirstly, if length of array is smaller than **3** return false.\\nBefore adding subarray sum to the HashSet, check the HashSet if it contains that sum. \\n\\n# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n- Space complexity:\\n**O(1)**\\n# Code\\n```\\npublic class Solution {\\n    public bool FindSubarrays(int[] nums) {\\n        int len = nums.Length;\\n        if (len <= 2) return false;\\n        int sum = 0;\\n        var sums = new HashSet<int>();\\n        for (int i = 0; i < len - 1; i++)\\n        {\\n            sum = nums[i] + nums[i + 1];\\n            if(sums.Contains(sum)) return true;\\n            sums.Add(sum);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public bool FindSubarrays(int[] nums) {\\n        int len = nums.Length;\\n        if (len <= 2) return false;\\n        int sum = 0;\\n        var sums = new HashSet<int>();\\n        for (int i = 0; i < len - 1; i++)\\n        {\\n            sum = nums[i] + nums[i + 1];\\n            if(sums.Contains(sum)) return true;\\n            sums.Add(sum);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634877,
                "title": "find-subarrays-with-equal-sum-brute-force-optimal-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n- Time complexity: (For Brute Force Approach (Method 1))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> The time complexity of this brute force solution can be approximated as O(n^2)\\n\\n- <!-- Add your time complexity here, e.g. $$O(n)$$ --> The time complexity is O(n) for Optimal Approach.\\n\\n\\n\\n\\n\\n\\n  - Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> We are not creating any additional data structures or using any extra space that scales with the input size, the space complexity can be considered as O(1), which is constant space.\\n\\n# Code\\n\\n\\n```\\n\\nMethod 1: \\n\\n/*\\nBrute Force:\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        for ( int i=0; i<n-1; i++) {\\n            for ( int j = i+1; j<n-1; j++) {\\n                if( nums[i]+nums[i+1] == nums[j]+nums[j+1])\\n                 return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n*/\\n\\n\\nMethod 2: \\n/*\\nOptimal Solution:\\n\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_set<int>s;\\n        for(int i=1; i<nums.size(); i++)\\n        {\\n            if(s.find(nums[i]+nums[i-1]) != s.end())\\n            return true;\\n             s.insert(nums[i]+nums[i-1]);\\n        }\\n       \\n        return false;\\n    }\\n};\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nMethod 1: \\n\\n/*\\nBrute Force:\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        for ( int i=0; i<n-1; i++) {\\n            for ( int j = i+1; j<n-1; j++) {\\n                if( nums[i]+nums[i+1] == nums[j]+nums[j+1])\\n                 return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n*/\\n\\n\\nMethod 2: \\n/*\\nOptimal Solution:\\n\\nclass Solution {\\npublic:\\n    bool findSubarrays(vector<int>& nums) {\\n        unordered_set<int>s;\\n        for(int i=1; i<nums.size(); i++)\\n        {\\n            if(s.find(nums[i]+nums[i-1]) != s.end())\\n            return true;\\n             s.insert(nums[i]+nums[i-1]);\\n        }\\n       \\n        return false;\\n    }\\n};\\n*/\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1636618,
                "content": [
                    {
                        "username": "manindra007",
                        "content": "check for length of array if equals 2 return false as you can\\'t get pair.\\n\\nnext store sum of each pair in map of integer to integer array, \\nif already exists return true, else push your current value.\\nif no match found in the end return false "
                    },
                    {
                        "username": "anjith",
                        "content": "Thanks for sharing your solution in the discussions section and ruining it for everyone."
                    },
                    {
                        "username": "arare653",
                        "content": "In example 2 (nums = [1,2,3,4,5]) sums 2 of subsets (1,5 and 2,4) are 6. So why not True?"
                    },
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "this is subset not subarray . In qstn they mentioned it as subarray"
                    },
                    {
                        "username": "shreyabirthare16",
                        "content": "that\\'s not contiguous coz"
                    },
                    {
                        "username": "apawar584",
                        "content": "[77,95,90,98,8,100,88,96,6,40,86,56,98,96,40,52,30,33,97,72,54,15,33,77,78,8,21,47,99,48]\\nthis test case Expected Answer is True ,\\nmy answer is false\\nplease explain if anyone can.\\ni think my answer id right. "
                    },
                    {
                        "username": "almostmonday",
                        "content": "90 + 98 = 188 (indexes 2 and 3)\\n100 + 88 = 188 (indexes 5 and 6)\\n188 == 188"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you find it useful please LEAVE A STAR \\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/2395.%20Find%20Subarrays%20With%20Equal%20Sum.cpp"
                    },
                    {
                        "username": "arshadali7860",
                        "content": "hello"
                    },
                    {
                        "username": "kapilk",
                        "content": "```\\nclass Solution(object):\\n    def findSubarrays(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # nums = [1,2,3,4,5]\\n        # [3, 5, 7, 9]\\n        # nums = [4, 2, 4]\\n        # [6, 6]\\n        # nums = [1, 1, 1]\\n        # [2, 2]\\n\\n        seen = set()\\n        for i in range(len(nums) - 1):\\n            first = nums[i]\\n            second = nums[i + 1]\\n            if first + second in seen:\\n                return True\\n            seen.add(first + second)\\n        \\n        return False\\n```"
                    }
                ]
            },
            {
                "id": 1959851,
                "content": [
                    {
                        "username": "manindra007",
                        "content": "check for length of array if equals 2 return false as you can\\'t get pair.\\n\\nnext store sum of each pair in map of integer to integer array, \\nif already exists return true, else push your current value.\\nif no match found in the end return false "
                    },
                    {
                        "username": "anjith",
                        "content": "Thanks for sharing your solution in the discussions section and ruining it for everyone."
                    },
                    {
                        "username": "arare653",
                        "content": "In example 2 (nums = [1,2,3,4,5]) sums 2 of subsets (1,5 and 2,4) are 6. So why not True?"
                    },
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "this is subset not subarray . In qstn they mentioned it as subarray"
                    },
                    {
                        "username": "shreyabirthare16",
                        "content": "that\\'s not contiguous coz"
                    },
                    {
                        "username": "apawar584",
                        "content": "[77,95,90,98,8,100,88,96,6,40,86,56,98,96,40,52,30,33,97,72,54,15,33,77,78,8,21,47,99,48]\\nthis test case Expected Answer is True ,\\nmy answer is false\\nplease explain if anyone can.\\ni think my answer id right. "
                    },
                    {
                        "username": "almostmonday",
                        "content": "90 + 98 = 188 (indexes 2 and 3)\\n100 + 88 = 188 (indexes 5 and 6)\\n188 == 188"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you find it useful please LEAVE A STAR \\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/2395.%20Find%20Subarrays%20With%20Equal%20Sum.cpp"
                    },
                    {
                        "username": "arshadali7860",
                        "content": "hello"
                    },
                    {
                        "username": "kapilk",
                        "content": "```\\nclass Solution(object):\\n    def findSubarrays(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # nums = [1,2,3,4,5]\\n        # [3, 5, 7, 9]\\n        # nums = [4, 2, 4]\\n        # [6, 6]\\n        # nums = [1, 1, 1]\\n        # [2, 2]\\n\\n        seen = set()\\n        for i in range(len(nums) - 1):\\n            first = nums[i]\\n            second = nums[i + 1]\\n            if first + second in seen:\\n                return True\\n            seen.add(first + second)\\n        \\n        return False\\n```"
                    }
                ]
            },
            {
                "id": 1832914,
                "content": [
                    {
                        "username": "manindra007",
                        "content": "check for length of array if equals 2 return false as you can\\'t get pair.\\n\\nnext store sum of each pair in map of integer to integer array, \\nif already exists return true, else push your current value.\\nif no match found in the end return false "
                    },
                    {
                        "username": "anjith",
                        "content": "Thanks for sharing your solution in the discussions section and ruining it for everyone."
                    },
                    {
                        "username": "arare653",
                        "content": "In example 2 (nums = [1,2,3,4,5]) sums 2 of subsets (1,5 and 2,4) are 6. So why not True?"
                    },
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "this is subset not subarray . In qstn they mentioned it as subarray"
                    },
                    {
                        "username": "shreyabirthare16",
                        "content": "that\\'s not contiguous coz"
                    },
                    {
                        "username": "apawar584",
                        "content": "[77,95,90,98,8,100,88,96,6,40,86,56,98,96,40,52,30,33,97,72,54,15,33,77,78,8,21,47,99,48]\\nthis test case Expected Answer is True ,\\nmy answer is false\\nplease explain if anyone can.\\ni think my answer id right. "
                    },
                    {
                        "username": "almostmonday",
                        "content": "90 + 98 = 188 (indexes 2 and 3)\\n100 + 88 = 188 (indexes 5 and 6)\\n188 == 188"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you find it useful please LEAVE A STAR \\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/2395.%20Find%20Subarrays%20With%20Equal%20Sum.cpp"
                    },
                    {
                        "username": "arshadali7860",
                        "content": "hello"
                    },
                    {
                        "username": "kapilk",
                        "content": "```\\nclass Solution(object):\\n    def findSubarrays(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # nums = [1,2,3,4,5]\\n        # [3, 5, 7, 9]\\n        # nums = [4, 2, 4]\\n        # [6, 6]\\n        # nums = [1, 1, 1]\\n        # [2, 2]\\n\\n        seen = set()\\n        for i in range(len(nums) - 1):\\n            first = nums[i]\\n            second = nums[i + 1]\\n            if first + second in seen:\\n                return True\\n            seen.add(first + second)\\n        \\n        return False\\n```"
                    }
                ]
            },
            {
                "id": 1804029,
                "content": [
                    {
                        "username": "manindra007",
                        "content": "check for length of array if equals 2 return false as you can\\'t get pair.\\n\\nnext store sum of each pair in map of integer to integer array, \\nif already exists return true, else push your current value.\\nif no match found in the end return false "
                    },
                    {
                        "username": "anjith",
                        "content": "Thanks for sharing your solution in the discussions section and ruining it for everyone."
                    },
                    {
                        "username": "arare653",
                        "content": "In example 2 (nums = [1,2,3,4,5]) sums 2 of subsets (1,5 and 2,4) are 6. So why not True?"
                    },
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "this is subset not subarray . In qstn they mentioned it as subarray"
                    },
                    {
                        "username": "shreyabirthare16",
                        "content": "that\\'s not contiguous coz"
                    },
                    {
                        "username": "apawar584",
                        "content": "[77,95,90,98,8,100,88,96,6,40,86,56,98,96,40,52,30,33,97,72,54,15,33,77,78,8,21,47,99,48]\\nthis test case Expected Answer is True ,\\nmy answer is false\\nplease explain if anyone can.\\ni think my answer id right. "
                    },
                    {
                        "username": "almostmonday",
                        "content": "90 + 98 = 188 (indexes 2 and 3)\\n100 + 88 = 188 (indexes 5 and 6)\\n188 == 188"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you find it useful please LEAVE A STAR \\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/2395.%20Find%20Subarrays%20With%20Equal%20Sum.cpp"
                    },
                    {
                        "username": "arshadali7860",
                        "content": "hello"
                    },
                    {
                        "username": "kapilk",
                        "content": "```\\nclass Solution(object):\\n    def findSubarrays(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # nums = [1,2,3,4,5]\\n        # [3, 5, 7, 9]\\n        # nums = [4, 2, 4]\\n        # [6, 6]\\n        # nums = [1, 1, 1]\\n        # [2, 2]\\n\\n        seen = set()\\n        for i in range(len(nums) - 1):\\n            first = nums[i]\\n            second = nums[i + 1]\\n            if first + second in seen:\\n                return True\\n            seen.add(first + second)\\n        \\n        return False\\n```"
                    }
                ]
            },
            {
                "id": 1662048,
                "content": [
                    {
                        "username": "manindra007",
                        "content": "check for length of array if equals 2 return false as you can\\'t get pair.\\n\\nnext store sum of each pair in map of integer to integer array, \\nif already exists return true, else push your current value.\\nif no match found in the end return false "
                    },
                    {
                        "username": "anjith",
                        "content": "Thanks for sharing your solution in the discussions section and ruining it for everyone."
                    },
                    {
                        "username": "arare653",
                        "content": "In example 2 (nums = [1,2,3,4,5]) sums 2 of subsets (1,5 and 2,4) are 6. So why not True?"
                    },
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "this is subset not subarray . In qstn they mentioned it as subarray"
                    },
                    {
                        "username": "shreyabirthare16",
                        "content": "that\\'s not contiguous coz"
                    },
                    {
                        "username": "apawar584",
                        "content": "[77,95,90,98,8,100,88,96,6,40,86,56,98,96,40,52,30,33,97,72,54,15,33,77,78,8,21,47,99,48]\\nthis test case Expected Answer is True ,\\nmy answer is false\\nplease explain if anyone can.\\ni think my answer id right. "
                    },
                    {
                        "username": "almostmonday",
                        "content": "90 + 98 = 188 (indexes 2 and 3)\\n100 + 88 = 188 (indexes 5 and 6)\\n188 == 188"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you find it useful please LEAVE A STAR \\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/2395.%20Find%20Subarrays%20With%20Equal%20Sum.cpp"
                    },
                    {
                        "username": "arshadali7860",
                        "content": "hello"
                    },
                    {
                        "username": "kapilk",
                        "content": "```\\nclass Solution(object):\\n    def findSubarrays(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # nums = [1,2,3,4,5]\\n        # [3, 5, 7, 9]\\n        # nums = [4, 2, 4]\\n        # [6, 6]\\n        # nums = [1, 1, 1]\\n        # [2, 2]\\n\\n        seen = set()\\n        for i in range(len(nums) - 1):\\n            first = nums[i]\\n            second = nums[i + 1]\\n            if first + second in seen:\\n                return True\\n            seen.add(first + second)\\n        \\n        return False\\n```"
                    }
                ]
            },
            {
                "id": 1628804,
                "content": [
                    {
                        "username": "manindra007",
                        "content": "check for length of array if equals 2 return false as you can\\'t get pair.\\n\\nnext store sum of each pair in map of integer to integer array, \\nif already exists return true, else push your current value.\\nif no match found in the end return false "
                    },
                    {
                        "username": "anjith",
                        "content": "Thanks for sharing your solution in the discussions section and ruining it for everyone."
                    },
                    {
                        "username": "arare653",
                        "content": "In example 2 (nums = [1,2,3,4,5]) sums 2 of subsets (1,5 and 2,4) are 6. So why not True?"
                    },
                    {
                        "username": "Arunkumar_veerappan",
                        "content": "this is subset not subarray . In qstn they mentioned it as subarray"
                    },
                    {
                        "username": "shreyabirthare16",
                        "content": "that\\'s not contiguous coz"
                    },
                    {
                        "username": "apawar584",
                        "content": "[77,95,90,98,8,100,88,96,6,40,86,56,98,96,40,52,30,33,97,72,54,15,33,77,78,8,21,47,99,48]\\nthis test case Expected Answer is True ,\\nmy answer is false\\nplease explain if anyone can.\\ni think my answer id right. "
                    },
                    {
                        "username": "almostmonday",
                        "content": "90 + 98 = 188 (indexes 2 and 3)\\n100 + 88 = 188 (indexes 5 and 6)\\n188 == 188"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you find it useful please LEAVE A STAR \\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/2395.%20Find%20Subarrays%20With%20Equal%20Sum.cpp"
                    },
                    {
                        "username": "arshadali7860",
                        "content": "hello"
                    },
                    {
                        "username": "kapilk",
                        "content": "```\\nclass Solution(object):\\n    def findSubarrays(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # nums = [1,2,3,4,5]\\n        # [3, 5, 7, 9]\\n        # nums = [4, 2, 4]\\n        # [6, 6]\\n        # nums = [1, 1, 1]\\n        # [2, 2]\\n\\n        seen = set()\\n        for i in range(len(nums) - 1):\\n            first = nums[i]\\n            second = nums[i + 1]\\n            if first + second in seen:\\n                return True\\n            seen.add(first + second)\\n        \\n        return False\\n```"
                    }
                ]
            }
        ]
    }
]