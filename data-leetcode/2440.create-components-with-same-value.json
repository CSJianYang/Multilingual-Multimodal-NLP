[
    {
        "title": "Create Components With Same Value",
        "question_content": "There is an undirected tree with n nodes labeled from 0 to n - 1.\nYou are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\nReturn the maximum number of edges you can delete, such that every connected component in the tree has the same value.\n&nbsp;\nExample 1:\n\nInput: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] \nOutput: 2 \nExplanation: The above figure shows how we can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3] and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.\n\nExample 2:\n\nInput: nums = [2], edges = []\nOutput: 0\nExplanation: There are no edges to be deleted.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 2 * 104\n\tnums.length == n\n\t1 <= nums[i] <= 50\n\tedges.length == n - 1\n\tedges[i].length == 2\n\t0 <= edges[i][0], edges[i][1] <= n - 1\n\tedges represents a valid tree.",
        "solutions": [
            {
                "id": 2706736,
                "title": "python-explanation-with-pictures-bfs",
                "content": "Instead of\\n- Splitting trees aimlessly until we cut it into equal parts.\\n\\nWe do:\\n- Set a value `target`, check if there is a way to split the tree into parts with value `target`.\\n\\nStart with brute force, can we split trees into all segments of `target = 1`, or `target = 2`, or `target = 3`... ? Well we don\\'t need to try every possible target value. If we can split tree into `k` parts, it means the sum of values `sum(N)` must be divisible by `k`. We only need to test the number of times equal to the number of `sum(N)`\\'s factors. (Given `sum(N) = 15`, we only need to try `target = 1, 3, 5, 15`)\\n\\n\\nNow for a `target`, how to check if the tree can be splited into `k` parts of value `target`?\\n\\n![image](https://assets.leetcode.com/users/images/f55605c5-52e5-4b69-8e88-9787bb4570f0_1665852053.7543595.png)\\n\\nWe can use a toplogical-sort-like strategy, start with leaf nodes (nodes with degree of 1). If a leaf value is less than `target`, then it must be connected to its parent in order to make `target`. Thus we push leaf value to its \\'parent\\' (or \\'root\\'? \\'neighbor\\'? correct my terminology if I am wrong), and decrement the degree of parent node by 1. \\n\\n![image](https://assets.leetcode.com/users/images/017b88e4-a1d8-43c1-9f80-17c6428b66c6_1665852056.9383192.png)\\n\\nNote some edge cases:\\n\\n- If a leaf value equals `target`, then we don\\'t push its value, just reduce its the degree of its \\'parent\\' by 1.\\n- If a leaf value is larger than `target`, then there is no way to split tree into parts of value `target`. \\n- If we run into the last node, just check if its value equals `target`.\\n\\nAs shown below:\\n- Don\\'t increment the middle node\\'s value by `6`.\\n- The node value is larger than `6`, we will keep pushing its value (end up with fail anyway)\\n- The last node\\'s value is not `6`, the split fails.\\n\\n![image](https://assets.leetcode.com/users/images/7344df0f-4909-4a0f-8529-666fe27af093_1665853429.1268094.png)\\n\\n\\n**python**\\n```\\nclass Solution:\\n    def componentValue(self, N:List[int], E: List[List[int]]) -> int:\\n        ma, ss, n = max(N), sum(N), len(N)\\n        G = collections.defaultdict(set)\\n        degree = [0] * n\\n        for a, b in E:\\n            degree[a] += 1\\n            degree[b] += 1\\n            G[a].add(b)\\n            G[b].add(a)\\n            \\n        def bfs(target):\\n            V, deg = N[:], degree[:]\\n            dq = collections.deque([i for i, d in enumerate(degree) if d == 1])\\n            \\n            while dq:\\n                ci = dq.popleft()\\n                deg[ci] = 0\\n                for nxt in G[ci]:\\n                    if V[ci] != target: V[nxt] += V[ci] # Edge case 1.\\n                    deg[nxt] -= 1\\n                    if deg[nxt] == 0:\\n                        return V[nxt] == target # Edge case 3.\\n                    elif deg[nxt] == 1:\\n                        dq.append(nxt)     \\n           \\n        for cand in range(min(N), ss):\\n            if ss % cand == 0 and bfs(cand):\\n                return ss // cand - 1\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def componentValue(self, N:List[int], E: List[List[int]]) -> int:\\n        ma, ss, n = max(N), sum(N), len(N)\\n        G = collections.defaultdict(set)\\n        degree = [0] * n\\n        for a, b in E:\\n            degree[a] += 1\\n            degree[b] += 1\\n            G[a].add(b)\\n            G[b].add(a)\\n            \\n        def bfs(target):\\n            V, deg = N[:], degree[:]\\n            dq = collections.deque([i for i, d in enumerate(degree) if d == 1])\\n            \\n            while dq:\\n                ci = dq.popleft()\\n                deg[ci] = 0\\n                for nxt in G[ci]:\\n                    if V[ci] != target: V[nxt] += V[ci] # Edge case 1.\\n                    deg[nxt] -= 1\\n                    if deg[nxt] == 0:\\n                        return V[nxt] == target # Edge case 3.\\n                    elif deg[nxt] == 1:\\n                        dq.append(nxt)     \\n           \\n        for cand in range(min(N), ss):\\n            if ss % cand == 0 and bfs(cand):\\n                return ss // cand - 1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706326,
                "title": "factorization-brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> graf;\\n    vector<int> nums;\\n    \\n    int comp, val;\\n    int dfs(int v, int par) {\\n        int tot = nums[v];\\n        for(auto x: graf[v]) {\\n            if(x == par) continue;\\n            tot += dfs(x, v);\\n        }\\n        \\n        if(tot == val) {\\n            //if a component of sum = val is found decrease number of component\\'s by 1\\n            //and return 0 because the component is detatched from this node\\n            comp--;\\n            return 0;\\n        }\\n        //this node cannot form a component with sum = val so maybe the parent would be able to make it\\n        return tot;\\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        \\n        graf.resize(n);\\n        this->nums = nums;\\n        \\n        for(auto x: edges) {\\n            graf[x[0]].push_back(x[1]);\\n            graf[x[1]].push_back(x[0]);\\n        }\\n        \\n        //if all values are equal then n - 1 edges can be deleted\\n        if(count(nums.begin(), nums.end(), nums[0]) == n) return n - 1;\\n        \\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        int res = 0;\\n        \\n        //now the sum of every component has to be same so we can factorize the total sum\\n        //and check for every possible values\\n        //For ex: sum = 18\\n        //18 = 3 * 6\\n        //check if the graph can be broken on some edges such that there are 3 components with sum 6\\n        //do the same operation in the flip order i.e check if the graph can be broken into 6 components with sum 3\\n        //now number of edges deleted = number of components - 1\\n\\t\\t//Time Complexity: O(n * sqrt(sum))\\n        for(int i = 2; i * i <= sum; ++i) {\\n            if(sum % i == 0) {\\n                comp = i, val = sum / i;\\n                dfs(0, -1);\\n                if(comp == 0) res = max(res, i - 1);\\n                \\n                comp = sum / i, val = i;\\n                dfs(0, -1);\\n                if(comp == 0) res = max(res, (sum / i) - 1);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> graf;\\n    vector<int> nums;\\n    \\n    int comp, val;\\n    int dfs(int v, int par) {\\n        int tot = nums[v];\\n        for(auto x: graf[v]) {\\n            if(x == par) continue;\\n            tot += dfs(x, v);\\n        }\\n        \\n        if(tot == val) {\\n            //if a component of sum = val is found decrease number of component\\'s by 1\\n            //and return 0 because the component is detatched from this node\\n            comp--;\\n            return 0;\\n        }\\n        //this node cannot form a component with sum = val so maybe the parent would be able to make it\\n        return tot;\\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        \\n        graf.resize(n);\\n        this->nums = nums;\\n        \\n        for(auto x: edges) {\\n            graf[x[0]].push_back(x[1]);\\n            graf[x[1]].push_back(x[0]);\\n        }\\n        \\n        //if all values are equal then n - 1 edges can be deleted\\n        if(count(nums.begin(), nums.end(), nums[0]) == n) return n - 1;\\n        \\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        int res = 0;\\n        \\n        //now the sum of every component has to be same so we can factorize the total sum\\n        //and check for every possible values\\n        //For ex: sum = 18\\n        //18 = 3 * 6\\n        //check if the graph can be broken on some edges such that there are 3 components with sum 6\\n        //do the same operation in the flip order i.e check if the graph can be broken into 6 components with sum 3\\n        //now number of edges deleted = number of components - 1\\n\\t\\t//Time Complexity: O(n * sqrt(sum))\\n        for(int i = 2; i * i <= sum; ++i) {\\n            if(sum % i == 0) {\\n                comp = i, val = sum / i;\\n                dfs(0, -1);\\n                if(comp == 0) res = max(res, i - 1);\\n                \\n                comp = sum / i, val = i;\\n                dfs(0, -1);\\n                if(comp == 0) res = max(res, (sum / i) - 1);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706628,
                "title": "c-easy-dfs",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. traverse the tree from root by DFS.\\n2. if a subtree we visited can form a conponent with total sum target, than we can delete it from the tree.\\n3. the function \"tarverse\" return the sum of value of subtree minus the sum of value of the subtees we deleted.\\n4. if the tree can be splited into i part, than the function traverse will return 0. Because the tree is splited completely.\\n\\n# time complexity: O(log(sum(nums)*n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int sum=0, n=nums.size();\\n        \\n        // sum of value\\n        for (int i=0; i<n; ++i)\\n            sum+=nums[i];\\n        \\n        vector<vector<int>> next(n);\\n        \\n        // create edges map\\n        for (auto e : edges) {\\n            next[e[0]].push_back(e[1]);\\n            next[e[1]].push_back(e[0]);\\n        }\\n        \\n        for (int i=n; i>1; --i) {\\n            if (sum%i) continue;  // there is no probability that split the tree into i part.\\n            vector<int> temp(n);\\n            if (traverse(nums, next, 0, temp, sum/i)==0) return i-1;\\n        }\\n        return 0;\\n    }\\n    \\n    int traverse(vector<int>& nums, vector<vector<int>>& next, int cur, vector<int>& temp, int target) {\\n        temp[cur]=nums[cur];\\n        for (auto n : next[cur]) {\\n            if (temp[n]) continue; // this condition represents that the node n has been visited.\\n            temp[cur]+=traverse(nums, next, n, temp, target);\\n            // If temp[cur]>target means that we fail the separation.\\n            // In this condition, we just return a very large integer.\\n            if (temp[cur]>target) return 1e7;\\n        }\\n        // this condition represents that the substree rooted at cur can be deleted from the tree. So, the sum of value can not add up to the parent of curent node.\\n        if (temp[cur]==target) return 0;\\n        return temp[cur];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int sum=0, n=nums.size();\\n        \\n        // sum of value\\n        for (int i=0; i<n; ++i)\\n            sum+=nums[i];\\n        \\n        vector<vector<int>> next(n);\\n        \\n        // create edges map\\n        for (auto e : edges) {\\n            next[e[0]].push_back(e[1]);\\n            next[e[1]].push_back(e[0]);\\n        }\\n        \\n        for (int i=n; i>1; --i) {\\n            if (sum%i) continue;  // there is no probability that split the tree into i part.\\n            vector<int> temp(n);\\n            if (traverse(nums, next, 0, temp, sum/i)==0) return i-1;\\n        }\\n        return 0;\\n    }\\n    \\n    int traverse(vector<int>& nums, vector<vector<int>>& next, int cur, vector<int>& temp, int target) {\\n        temp[cur]=nums[cur];\\n        for (auto n : next[cur]) {\\n            if (temp[n]) continue; // this condition represents that the node n has been visited.\\n            temp[cur]+=traverse(nums, next, n, temp, target);\\n            // If temp[cur]>target means that we fail the separation.\\n            // In this condition, we just return a very large integer.\\n            if (temp[cur]>target) return 1e7;\\n        }\\n        // this condition represents that the substree rooted at cur can be deleted from the tree. So, the sum of value can not add up to the parent of curent node.\\n        if (temp[cur]==target) return 0;\\n        return temp[cur];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707217,
                "title": "bfs",
                "content": "If we split the tree into `i` components, the target value of each component is `sum / i`. \\n\\nNote that we cannot split into `i` components if `sum % i != 0`. \\n\\nFor each target value, we can unambiguously discover all components starting from leaves. This works because we have a tree, not a graph. \\n\\nWhen processing from leaves, we track the value of the current component:\\n- If the value is greater than the target, we cannot split the tree.\\n- If the value is less, we add it to the parent.\\n\\t- There is no more than one parent as we go from a leaf.\\n- If the value is equal, we do not add it to the parent.\\n\\t- It will start a new component from that parent.\\n\\nThus, the solution is to try to `sum / n, sum / (n - 1), ..., sum / 2` values, and use BFS to check if we can do the split.\\n\\n**Complexity Analysis**\\n- Time: O(n * N nm), where m is max(nums), and N is a function returning the number of divisors.\\n\\t- BFS is O(n), and we do it for each divisor of sum. \\n\\t- The maximum sum is `nm`, and N(nm) is the number of divisors. \\n\\t- In the average case, the number of divisorts/target values that won\\'t be fast-pruned in BFS can be esitmated as `log2 nm`.\\n- Memory: O(n)\\n\\n**C++**\\n`cnt[i]` is the number of edges for node `i`. We start from leaves - nodes with one edge.\\n\\nAs we process a neighboring node, we decrease its number of edges. When that number becomes `1` - this node becomes a \\u201Cleaf\\u201D and we add it to the BFS queue.\\n\\nNote that it also prevents a node from being processed twice - since next time `cnt[i]` would become zero.\\n```cpp\\nbool bfs(int val, vector<vector<int>> &al, vector<int> q, vector<int> n, vector<int> cnt) {\\n    while(!q.empty()) {\\n        vector<int> q1;\\n        for (auto i : q) {\\n            if (n[i] > val)\\n                return false;\\n            for (auto j : al[i]) {\\n                n[j] += n[i] < val ? n[i] : 0;\\n                if (--cnt[j] == 1)\\n                    q1.push_back(j);\\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    return true;\\n}\\nint componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n    int n = nums.size(), sum = accumulate(begin(nums), end(nums), 0);\\n    if (sum % n == 0 && all_of(begin(nums), end(nums), [&](int v){ return v == sum / n; }))\\n        return n - 1;\\n    vector<vector<int>> al(n);\\n    for (auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    vector<int> q, cnt(n);\\n    for (int i = 0; i < n; ++i) {\\n        cnt[i] = al[i].size();\\n        if (al[i].size() == 1)\\n            q.push_back(i);\\n    }\\n    for (int i = n - 1; i > 1; --i)\\n        if (sum % i == 0 && bfs(sum / i, al, q, nums, cnt))\\n            return i - 1;\\n    return 0;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool bfs(int val, vector<vector<int>> &al, vector<int> q, vector<int> n, vector<int> cnt) {\\n    while(!q.empty()) {\\n        vector<int> q1;\\n        for (auto i : q) {\\n            if (n[i] > val)\\n                return false;\\n            for (auto j : al[i]) {\\n                n[j] += n[i] < val ? n[i] : 0;\\n                if (--cnt[j] == 1)\\n                    q1.push_back(j);\\n            }\\n        }\\n        swap(q, q1);\\n    }\\n    return true;\\n}\\nint componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n    int n = nums.size(), sum = accumulate(begin(nums), end(nums), 0);\\n    if (sum % n == 0 && all_of(begin(nums), end(nums), [&](int v){ return v == sum / n; }))\\n        return n - 1;\\n    vector<vector<int>> al(n);\\n    for (auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    vector<int> q, cnt(n);\\n    for (int i = 0; i < n; ++i) {\\n        cnt[i] = al[i].size();\\n        if (al[i].size() == 1)\\n            q.push_back(i);\\n    }\\n    for (int i = n - 1; i > 1; --i)\\n        if (sum % i == 0 && bfs(sum / i, al, q, nums, cnt))\\n            return i - 1;\\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2707304,
                "title": "python3-post-order-dfs",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b09317beeb5fa2ae0b6d2537172ab52647a75cea) for solutions of biweekly 89. \\n\\n```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        tree = [[] for _ in nums]\\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        \\n        def fn(u, p):\\n            \"\"\"Post-order dfs.\"\"\"\\n            ans = nums[u]\\n            for v in tree[u]: \\n                if v != p: ans += fn(v, u)\\n            return 0 if ans == cand else ans\\n        \\n        total = sum(nums)\\n        for cand in range(1, total//2+1): \\n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\\n        return 0 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        tree = [[] for _ in nums]\\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        \\n        def fn(u, p):\\n            \"\"\"Post-order dfs.\"\"\"\\n            ans = nums[u]\\n            for v in tree[u]: \\n                if v != p: ans += fn(v, u)\\n            return 0 if ans == cand else ans\\n        \\n        total = sum(nums)\\n        for cand in range(1, total//2+1): \\n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\\n        return 0 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706333,
                "title": "python-solution",
                "content": "Solution: find  the total sum of node vals. if our tree can be split, the sum of each subtree must equal one divisor of the total sum. check if we can split the tree for every divisor of the total sum. To save time:\\n\\n1.  skip divisors smaller than the largest node val\\n2. check divisors from low to high. We terminate after finding the first divisor that can split the tree, which leads to the max edge removals\\n\\n\\nHow many divisors we may check in the worst case? For a num N, the common approximate upper bound of # of divisors is N^1/3. \\nthe exact bounds for the number of divisors of any n-digit number are (http://oeis.org/A066150):   4, 12, 32, 64, 128, 240, 448, 768, 1344\\n\\n    nums = [1,5,5,4,11]\\n    edges = [[0,1],[1,2],[1,3],[3,4]]\\n\\n    tree=collections.defaultdict(set)\\n    for i,j in edges:\\n         tree[i].add(j)\\n         tree[j].add(i)\\n  \\n    def check(cur,prev,target):\\n        val=nums[cur]\\n        for kid in tree[cur]-{prev}:\\n           i=check(kid,cur,target)\\n           if i==-1: return -1\\n           val+=i          \\n        return val%target if val<=target else -1\\n    \\n    tot=sum(nums)\\n    for n in range(min(tot//max(nums),len(nums)),0,-1):  # for simplicity, i do not use O(n^1/2) approach to find all factors here\\n        if not tot%n and check(0,-1,tot//n)==0:\\n           return n-1",
                "solutionTags": [
                    "Python"
                ],
                "code": "Solution: find  the total sum of node vals. if our tree can be split, the sum of each subtree must equal one divisor of the total sum. check if we can split the tree for every divisor of the total sum. To save time:\\n\\n1.  skip divisors smaller than the largest node val\\n2. check divisors from low to high. We terminate after finding the first divisor that can split the tree, which leads to the max edge removals\\n\\n\\nHow many divisors we may check in the worst case? For a num N, the common approximate upper bound of # of divisors is N^1/3. \\nthe exact bounds for the number of divisors of any n-digit number are (http://oeis.org/A066150):   4, 12, 32, 64, 128, 240, 448, 768, 1344\\n\\n    nums = [1,5,5,4,11]\\n    edges = [[0,1],[1,2],[1,3],[3,4]]\\n\\n    tree=collections.defaultdict(set)\\n    for i,j in edges:\\n         tree[i].add(j)\\n         tree[j].add(i)\\n  \\n    def check(cur,prev,target):\\n        val=nums[cur]\\n        for kid in tree[cur]-{prev}:\\n           i=check(kid,cur,target)\\n           if i==-1: return -1\\n           val+=i          \\n        return val%target if val<=target else -1\\n    \\n    tot=sum(nums)\\n    for n in range(min(tot//max(nums),len(nums)),0,-1):  # for simplicity, i do not use O(n^1/2) approach to find all factors here\\n        if not tot%n and check(0,-1,tot//n)==0:\\n           return n-1",
                "codeTag": "Python3"
            },
            {
                "id": 2707267,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    int[] nums;\\n    public int componentValue(int[] nums, int[][] edges) {\\n        int n = nums.length;\\n        this.nums = nums;\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i=0; i<n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        \\n        int sum = 0;\\n        for(int i : nums) {\\n            sum += i;\\n        }\\n        \\n        for(int k=n; k>0; k--) {\\n            if(sum % k != 0) continue;\\n            int ans = helper(graph, 0, -1, sum / k);\\n            if(ans == 0) return k-1;\\n        }\\n        return 0;\\n    }\\n    \\n    private int helper(List<Integer>[] graph, int i, int prev, int target) {\\n        if(graph[i].size() == 1 && graph[i].get(0) == prev) {\\n            if(nums[i] > target) return -1;\\n            if(nums[i] == target) return 0;\\n            return nums[i];\\n        }\\n        \\n        int sum = nums[i];\\n        for(int k : graph[i]) {\\n            if(k == prev) continue;\\n            int ans = helper(graph, k, i, target);\\n            if(ans == -1) return -1;\\n            sum += ans;\\n        }\\n        \\n        if(sum > target) return -1;\\n        if(sum == target) return 0;\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int[] nums;\\n    public int componentValue(int[] nums, int[][] edges) {\\n        int n = nums.length;\\n        this.nums = nums;\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i=0; i<n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2707237,
                "title": "c-easy-understanding-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //to count\\n    int countIt(vector<int> arr, int x,int &sum){\\n        int count=0;\\n        for(auto &itr:arr){\\n            if(itr==x) count++;\\n            sum+=itr;\\n        }\\n        return count;\\n    }\\n    \\n\\n    //dfs traversal\\n    int dfs(vector<int> &nums, int cur, vector<int> adj[], int prev, int target){\\n        \\n        int curSum=nums[cur];\\n        \\n        for(auto &itr : adj[cur]){\\n            if(itr==prev) continue;     // avoid going backside in graph else infi loop\\n            curSum+=dfs(nums,itr,adj,cur,target);\\n        }\\n        \\n        //on returning back in recursion if you get target break \\n        //it there and start sum from 0 for next\\n        \\n        if(curSum==target) return 0;\\n        else return curSum;\\n    }\\n    \\n    //main() start\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<int> adj[nums.size()];\\n        \\n        //make graph\\n        for(auto &itr:edges){\\n            adj[itr[0]].push_back(itr[1]);\\n            adj[itr[1]].push_back(itr[0]);\\n        }\\n        \\n        //if all are of same nums[i] divide each node as individual also get total sum\\n        int sum=0;\\n        if(countIt(nums,nums[0],sum)==nums.size()) return nums.size()-1;\\n        \\n        //check for what it is dividable\\n        for(int i=nums.size()-1;i>=2;i--){\\n            if(sum%i != 0) continue;            // not dividable in i parts\\n            int res=dfs(nums,0,adj,-1, sum/i);    //array , start , graph , parent, target\\n            if(res==0) return i-1;  // edges removed = total components divided into -1 \\n        }\\n        \\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //to count\\n    int countIt(vector<int> arr, int x,int &sum){\\n        int count=0;\\n        for(auto &itr:arr){\\n            if(itr==x) count++;\\n            sum+=itr;\\n        }\\n        return count;\\n    }\\n    \\n\\n    //dfs traversal\\n    int dfs(vector<int> &nums, int cur, vector<int> adj[], int prev, int target){\\n        \\n        int curSum=nums[cur];\\n        \\n        for(auto &itr : adj[cur]){\\n            if(itr==prev) continue;     // avoid going backside in graph else infi loop\\n            curSum+=dfs(nums,itr,adj,cur,target);\\n        }\\n        \\n        //on returning back in recursion if you get target break \\n        //it there and start sum from 0 for next\\n        \\n        if(curSum==target) return 0;\\n        else return curSum;\\n    }\\n    \\n    //main() start\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<int> adj[nums.size()];\\n        \\n        //make graph\\n        for(auto &itr:edges){\\n            adj[itr[0]].push_back(itr[1]);\\n            adj[itr[1]].push_back(itr[0]);\\n        }\\n        \\n        //if all are of same nums[i] divide each node as individual also get total sum\\n        int sum=0;\\n        if(countIt(nums,nums[0],sum)==nums.size()) return nums.size()-1;\\n        \\n        //check for what it is dividable\\n        for(int i=nums.size()-1;i>=2;i--){\\n            if(sum%i != 0) continue;            // not dividable in i parts\\n            int res=dfs(nums,0,adj,-1, sum/i);    //array , start , graph , parent, target\\n            if(res==0) return i-1;  // edges removed = total components divided into -1 \\n        }\\n        \\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709091,
                "title": "c-dfs-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    vector<vector<int>> g;\\n    \\n    int dfs(int ind,int parent,const int target)\\n    {\\n        int val = arr[ind];\\n        \\n        for(auto it : g[ind]){\\n            if(it == parent) continue;\\n            val += dfs(it,ind,target);\\n        }\\n        \\n        if(val == target) return 0;\\n        return val;\\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        g.clear(),arr.clear();\\n        int n = nums.size();\\n        g.resize(n),arr.resize(n);\\n        int sum = 0;\\n        \\n        for(auto i: edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        \\n        for(int j=0;j<n;j++){\\n            sum += nums[j];\\n            arr[j] = nums[j];\\n        }\\n        \\n        int result = 0;\\n        for(int parts = 1;parts <= n;parts++){\\n            if(sum%parts != 0) continue;\\n            if(dfs(0,-1,sum/parts) !=0) continue;\\n            \\n            result = max(result,parts-1);\\n        }\\n        return result;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    vector<vector<int>> g;\\n    \\n    int dfs(int ind,int parent,const int target)\\n    {\\n        int val = arr[ind];\\n        \\n        for(auto it : g[ind]){\\n            if(it == parent) continue;\\n            val += dfs(it,ind,target);\\n        }\\n        \\n        if(val == target) return 0;\\n        return val;\\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        g.clear(),arr.clear();\\n        int n = nums.size();\\n        g.resize(n),arr.resize(n);\\n        int sum = 0;\\n        \\n        for(auto i: edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        \\n        for(int j=0;j<n;j++){\\n            sum += nums[j];\\n            arr[j] = nums[j];\\n        }\\n        \\n        int result = 0;\\n        for(int parts = 1;parts <= n;parts++){\\n            if(sum%parts != 0) continue;\\n            if(dfs(0,-1,sum/parts) !=0) continue;\\n            \\n            result = max(result,parts-1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706833,
                "title": "solution-based-in-intuiton-full-explained",
                "content": "# Intuition\\nWe define **W** as the total weight of the tree and **x** as the total weight of each component after erase some edges and finally **k** as the number of components left\\n\\nFirst of all we know that if a tree can be divided into many components with the same weight **x** the total weight of the tree must be a multiple of x that is **W = kx** for some **k** then we can iterate over all divisors of the total weight of the tree and try to find if it can be partitioned into k components such that they all have weight = **x**\\n\\nAnd here\\'s the main intuition, if we need to make each component weigh = **x**, we know we\\'ll get $$\\\\frac{W}{x} = k$$ components, so there must be exactly k subtrees with weight equal to a multiple of **x**\\n\\n# Example \\nWe use the same tree of first example \\n![image.png](https://assets.leetcode.com/users/images/205100cf-f59e-47d1-9aac-4db1c2b66400_1665851155.6040244.png)\\n\\nFirst we get the weight of each subtree (the root doesn\\'t matter)\\n\\nFor our example, the weights of each subtree with root 0 from node 0 to n-1 are:\\n**[18,12,2,8,6]**\\n\\nAnd then we try to find the solution for some x. \\n\\nFor x = 9: (remember that **x** is some divisor of **W**)\\nwe find that only one of the subtrees has weight = **kx** but intuition says we need to find exactly $$\\\\frac{W}{x} = \\\\frac{18}{9} =2 $$ so this divisor is invalid\\n\\nFor x = 6:\\nIn this case we find that the subtree of nodes **[0, 1, 4]** with weights **[18, 12, 6]** are multiples of **x = 6** and we have exactly 3 which is equal to **$$k = \\\\frac{W}{x} = \\\\frac{18}{6} = 3 $$** so we can say that it is a valid division of the tree, that is, there must be some way to delete some edges (exactly k-1) so that each component has weight = **x**\\n\\n\\n# Approach sumary\\nIterate over all divisors **x** of **W** and find if there are exactly **$$\\\\frac{W}{x}$$** subtrees whose weight $$w_{i} \\\\% x = 0 $$ and if this condition is valid we update the answer with **$$\\\\max( ans, \\\\frac{W}{x} -1)$$** (ans at the beginning is 0) \\n# Complexity\\n$$O(sqrt(W) \\\\times n)$$ (\\\\sqrt doesn\\'t render)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> vis;\\n    vector<int> Nums;\\n    vector<int> graph[20007];\\n    vector<int> sz;\\n    void solve(int u){\\n        sz[u] = Nums[u];\\n        vis[u] = true;\\n        for(auto v:graph[u]){\\n            if(vis[v])continue;\\n            solve(v);\\n            sz[u]+=sz[v];\\n        }\\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        Nums = nums;\\n        vis.resize(n);\\n        sz.resize(n);\\n        // Create the graph with adjacent list\\n        for(int i = 0;i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        int ans = 0;\\n        \\n        // Dfs to get the weight of each subtree (well known algorithm)\\n        // The root does not matter\\n        solve(0);\\n\\n        // Define W as the total weight of the tree\\n        int W = accumulate(nums.begin(),nums.end(),0);\\n        \\n        for(int x = 1;x*x<=W;x++){\\n            if(W%x ==0){\\n                // Check for every divisor\\n                int cont = 0;\\n                for(int j = 0;j<n;j++){\\n                    // Count every subtree with weight multiple of x\\n                    if(sz[j]%x ==0){\\n                        cont++;\\n                    }\\n                }\\n                int k = W/x;\\n                // Check the condition that must be exactly W/x components and update the answer\\n                // To make k components in a tree we need to erase k-1 edges \\n                if(cont == k )\\n                    ans = max(ans,k-1);\\n                \\n                if((W/x)==x)continue;\\n\\n                // The same for the other divisor W/x\\n                int otherDiv = W/x;\\n                cont = 0;\\n                for(int j = 0;j<n;j++){\\n                    if(sz[j]%otherDiv==0){\\n                        cont++;\\n                    }\\n                }\\n                k = W/otherDiv;\\n                if(cont==k)\\n                    ans = max(ans,k-1);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> vis;\\n    vector<int> Nums;\\n    vector<int> graph[20007];\\n    vector<int> sz;\\n    void solve(int u){\\n        sz[u] = Nums[u];\\n        vis[u] = true;\\n        for(auto v:graph[u]){\\n            if(vis[v])continue;\\n            solve(v);\\n            sz[u]+=sz[v];\\n        }\\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        Nums = nums;\\n        vis.resize(n);\\n        sz.resize(n);\\n        // Create the graph with adjacent list\\n        for(int i = 0;i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        int ans = 0;\\n        \\n        // Dfs to get the weight of each subtree (well known algorithm)\\n        // The root does not matter\\n        solve(0);\\n\\n        // Define W as the total weight of the tree\\n        int W = accumulate(nums.begin(),nums.end(),0);\\n        \\n        for(int x = 1;x*x<=W;x++){\\n            if(W%x ==0){\\n                // Check for every divisor\\n                int cont = 0;\\n                for(int j = 0;j<n;j++){\\n                    // Count every subtree with weight multiple of x\\n                    if(sz[j]%x ==0){\\n                        cont++;\\n                    }\\n                }\\n                int k = W/x;\\n                // Check the condition that must be exactly W/x components and update the answer\\n                // To make k components in a tree we need to erase k-1 edges \\n                if(cont == k )\\n                    ans = max(ans,k-1);\\n                \\n                if((W/x)==x)continue;\\n\\n                // The same for the other divisor W/x\\n                int otherDiv = W/x;\\n                cont = 0;\\n                for(int j = 0;j<n;j++){\\n                    if(sz[j]%otherDiv==0){\\n                        cont++;\\n                    }\\n                }\\n                k = W/otherDiv;\\n                if(cont==k)\\n                    ans = max(ans,k-1);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706535,
                "title": "python-get-factors-of-sum-all-nodes-then-check",
                "content": "# Intuition\\n- Sum of each connected component must be values in factors of `sum(nums)`, and at least `max(nums)`.\\n- So get factors of sum all nodes then check if we can split into connected component, where sum of each connected component is equal to factor.\\n\\n# Complexity\\n- Time complexity: `O(sqrt(SUM_ALL_NODE) + N*log(SUM_ALL_NODE))`, where `SUM_ALL_NODE <= 10^6` is number of all nodes, `N <= 2*10^4` is number of nodes.\\n    - `factors` is up to `log(SUM_ALL_NODE)` elements.\\n    - `dfs()` function cost `O(N)`\\n\\n- Space complexity: `O(log(SUM_ALL_NODE) + N)`\\n\\n# Code\\n```python\\nclass Solution:\\n    def getFactors(self, x):\\n        factors = []\\n        for i in range(1, int(sqrt(x)) + 1):\\n            if x % i != 0: continue\\n            factors.append(i)\\n            if x // i != i: factors.append(x // i)\\n        return factors\\n\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        self.cntRemainZero = 0\\n        def dfs(u, p, sumPerComponent): # return remain of the subtree with root `u`\\n            remain = nums[u]\\n            for v in graph[u]:\\n                if v == p: continue\\n                remain += dfs(v, u, sumPerComponent)\\n                \\n            remain %= sumPerComponent\\n            if remain == 0:\\n                self.cntRemainZero += 1\\n                \\n            return remain\\n        \\n        def isGood(sumPerComponent, expectedNumOfComponents):\\n            self.cntRemainZero = 0\\n            dfs(0, -1, sumPerComponent)\\n            return self.cntRemainZero == expectedNumOfComponents\\n        \\n        sumAllNodes, maxNum = sum(nums), max(nums)\\n        for sumPerComponent in sorted(self.getFactors(sumAllNodes)):\\n            if sumPerComponent < maxNum: continue  # at least maxNum\\n            expectedNumOfComponents = sumAllNodes // sumPerComponent\\n            if isGood(sumPerComponent, expectedNumOfComponents):\\n                return expectedNumOfComponents - 1 # Need to cut `numOfComponent - 1` edges to make `numOfComponent` connected component\\n            \\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def getFactors(self, x):\\n        factors = []\\n        for i in range(1, int(sqrt(x)) + 1):\\n            if x % i != 0: continue\\n            factors.append(i)\\n            if x // i != i: factors.append(x // i)\\n        return factors\\n\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        self.cntRemainZero = 0\\n        def dfs(u, p, sumPerComponent): # return remain of the subtree with root `u`\\n            remain = nums[u]\\n            for v in graph[u]:\\n                if v == p: continue\\n                remain += dfs(v, u, sumPerComponent)\\n                \\n            remain %= sumPerComponent\\n            if remain == 0:\\n                self.cntRemainZero += 1\\n                \\n            return remain\\n        \\n        def isGood(sumPerComponent, expectedNumOfComponents):\\n            self.cntRemainZero = 0\\n            dfs(0, -1, sumPerComponent)\\n            return self.cntRemainZero == expectedNumOfComponents\\n        \\n        sumAllNodes, maxNum = sum(nums), max(nums)\\n        for sumPerComponent in sorted(self.getFactors(sumAllNodes)):\\n            if sumPerComponent < maxNum: continue  # at least maxNum\\n            expectedNumOfComponents = sumAllNodes // sumPerComponent\\n            if isGood(sumPerComponent, expectedNumOfComponents):\\n                return expectedNumOfComponents - 1 # Need to cut `numOfComponent - 1` edges to make `numOfComponent` connected component\\n            \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726428,
                "title": "python-3-dfs-some-explanation-t-m-96-39",
                "content": "```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n\\n        def dfs(a, b):                      # if this subtree has sum value of div, make it zero\\n        \\n            tally = nums[a]\\n            for c in graph[a]: \\n                if c != b:\\n                    tally += dfs(c, a)\\n            \\n            return tally if tally != div else 0\\n        \\n        graph = defaultdict(list)\\n        n, sm, mx, mn = len(nums), sum(nums), max(nums), min(nums)\\n\\n        for a, b in edges:                  # build the graph\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        \\n        for div in range(mx, sm//mn):       # consider each potential divisor of sm\\n            if not(sm%div or dfs(0, n-1)):  # if divisor and whole tree has sum-value of zero, success\\n                return sm//div-1            # number of deletions is one less than number of components\\n\\n        return 0                             # no successes\\n```\\n[https://leetcode.com/submissions/detail/826733562/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n\\n        def dfs(a, b):                      # if this subtree has sum value of div, make it zero\\n        \\n            tally = nums[a]\\n            for c in graph[a]: \\n                if c != b:\\n                    tally += dfs(c, a)\\n            \\n            return tally if tally != div else 0\\n        \\n        graph = defaultdict(list)\\n        n, sm, mx, mn = len(nums), sum(nums), max(nums), min(nums)\\n\\n        for a, b in edges:                  # build the graph\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        \\n        for div in range(mx, sm//mn):       # consider each potential divisor of sm\\n            if not(sm%div or dfs(0, n-1)):  # if divisor and whole tree has sum-value of zero, success\\n                return sm//div-1            # number of deletions is one less than number of components\\n\\n        return 0                             # no successes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709177,
                "title": "explanation-of-everyone-s-short-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>> adj;\\n    vector<int> arr;\\n    \\n    int dfs(int src,int parent,int target)\\n    {\\n        int sum=arr[src]; //mai apne subtree ka sum nikal rha hu -> to pehle apni val\\n          \\n        for(auto i:adj[src])\\n            if(i!=parent)\\n              sum+=dfs(i,src,target);       \\n        \\n        if(sum==target)  //bhai mera subtree pura hai mai ab alag component bngya\\n            return 0;   //thats why mera sb kuch bhuja (as if i dont exist. return 0)\\n        \\n        return sum;  //agar mai target ke equal nahi to kya pta parent ko help kru \\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        \\n        //Step 1 Make graph\\n        arr=nums;\\n        for(auto e:edges)\\n        {\\n            adj[e[1]].push_back(e[0]);\\n            adj[e[0]].push_back(e[1]);\\n        }\\n            \\n        //Step 2 Calculate sum\\n        int sum=0;\\n        for(auto i:nums)\\n            sum+=i;\\n    \\n        /* Step 3 -> 18 sum hai agar to kitne possible ways hai bnane ke compo :\\n        -> 1 compoent bnaega 18 sum ka \\n        -> 2 compoent bnaega 9 sum ka \\n        -> 3 compoent bnaega 6 sum ka \\n        -> 6 compoent bnaega 3 sum ka \\n        -> 9 compoent bnaega 2 sum ka\\n        -> 18 component bnaega 1 sum ka */\\n        \\n        for(int i=sum;i>=1;i--)  \\n        {\\n            if(sum%i==0)  // i components bn skte kya with every component val = n/i\\n            {\\n//IMPORTANT ->  i components bn pa rhe hai to edges i-1 remove hogi (Simple logic -> 2 compoent bnane hote to ek edge remove krte)\\n                if(dfs(0,-1,sum/i)==0) \\n                    return i-1; \\n            }\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    unordered_map<int,vector<int>> adj;\\n    vector<int> arr;\\n    \\n    int dfs(int src,int parent,int target)\\n    {\\n        int sum=arr[src]; //mai apne subtree ka sum nikal rha hu -> to pehle apni val\\n          \\n        for(auto i:adj[src])\\n            if(i!=parent)\\n              sum+=dfs(i,src,target);       \\n        \\n        if(sum==target)  //bhai mera subtree pura hai mai ab alag component bngya\\n            return 0;   //thats why mera sb kuch bhuja (as if i dont exist. return 0)\\n        \\n        return sum;  //agar mai target ke equal nahi to kya pta parent ko help kru \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3157650,
                "title": "clear-short-explanation-dfs-o-sqrt-sum-n-comments-added",
                "content": "\\n# Approach\\nFactorize sum and try all poosible factors..\\nfor each factor i the target is sum/i;\\n\\nnow to check if each factor can be our answer we are running a dfs, \\nin which if any component reaches the sum of exactly targeted value (val is used in code), then we return 0 for that component or we can say we deleted that.. \\nat at the end if we are able to delete the root also then we are good and this factor is one of our answer..\\n\\n# Complexity\\n- Time complexity: O( sqrt(sum) * N )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>g;\\n    vector<int>A;\\n\\n    // dfs function will check whether split is possible or not\\n    // if it is possible then it will return 0;\\n    int dfs(int r,int prnt,int val){\\n        int c=A[r];\\n        for(auto i:g[r]){\\n            if(i!=prnt){\\n                c+=dfs(i,r,val);\\n            }\\n        }\\n        if(c==val)return 0;\\n        else return c;\\n    }\\n    int componentValue(vector<int>& a, vector<vector<int>>& ed) {\\n        int s=0;\\n        A=a;\\n        for(auto i:a)s+=i;\\n\\n        // factorizing sum\\n        vector<int>f;\\n        for(int i=1;i*i<=s;i++){\\n            if(s%i==0){\\n                f.push_back(i);\\n                if(s/i!=i)f.push_back(s/i);\\n            }\\n        }\\n\\n        // making tree\\n        int n=a.size(),ans=1;\\n        g.assign(n+1,vector<int>());\\n        for(auto i:ed){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n\\n        // checking for each factor, can it be our ans?\\n        for(auto i:f){\\n            if(i<=n&&!dfs(0,-1,s/i)){\\n                ans=max(ans,i);\\n            }\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Tree",
                    "Depth-First Search",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>g;\\n    vector<int>A;\\n\\n    // dfs function will check whether split is possible or not\\n    // if it is possible then it will return 0;\\n    int dfs(int r,int prnt,int val){\\n        int c=A[r];\\n        for(auto i:g[r]){\\n            if(i!=prnt){\\n                c+=dfs(i,r,val);\\n            }\\n        }\\n        if(c==val)return 0;\\n        else return c;\\n    }\\n    int componentValue(vector<int>& a, vector<vector<int>>& ed) {\\n        int s=0;\\n        A=a;\\n        for(auto i:a)s+=i;\\n\\n        // factorizing sum\\n        vector<int>f;\\n        for(int i=1;i*i<=s;i++){\\n            if(s%i==0){\\n                f.push_back(i);\\n                if(s/i!=i)f.push_back(s/i);\\n            }\\n        }\\n\\n        // making tree\\n        int n=a.size(),ans=1;\\n        g.assign(n+1,vector<int>());\\n        for(auto i:ed){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n\\n        // checking for each factor, can it be our ans?\\n        for(auto i:f){\\n            if(i<=n&&!dfs(0,-1,s/i)){\\n                ans=max(ans,i);\\n            }\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836602,
                "title": "c-simple-clean-simple-modified-dfs-heavily-commented-100-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // dfs traversal of graph\\n    int dfs(vector<int>&nums, vector<vector<int>>&g, int cur, int parent, int target)\\n    {\\n        int curSum = nums[cur];\\n        for(auto &nbr : g[cur])\\n        {\\n            if(nbr == parent) continue;     // avoid going backside in graph else infinite loop\\n            curSum += dfs(nums, g, nbr, cur,target);\\n        }\\n        \\n        // on returning back in recursion if you get target break \\n        // it there and start sum from 0 for next\\n        \\n        if(curSum == target) \\n            return 0;\\n        else \\n            return curSum;\\n    }\\n    \\n\\t\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) \\n    {\\n        int n = nums.size();\\n        vector<vector<int>>g(n);\\n        \\n        // make graph\\n        for(auto e : edges){\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        \\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        \\n        // Handle early this Edge case will save time \\n        // if all values of nums are same divide each node as individual also \\n        // get total sum, i.e all nodes have same value.\\n        \\n        unordered_set<int>st(nums.begin(), nums.end());\\n        if(st.size() == 1) return n-1;\\n        \\n        // start from maximum (i.e n-1) number of components to minimum no. of components that is \"2\"\\n        for(int i=n-1;i>=2;i--)\\n        {\\n            if(sum%i != 0) continue;               // not dividable into \"i\" components\\n            \\n            int ans = dfs(nums, g, 0, -1, sum/i);  // value array , graph , start , parent , EachComponentSum\\n            \\n            // if ans finally returned to \"0\" means all components are successfully divided into sum of \"sum/i\"\\n            if(ans == 0) return i-1;               // edges removed = total components divided into - 1 \\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n----\\n***Thanks for Upvoting !***\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // dfs traversal of graph\\n    int dfs(vector<int>&nums, vector<vector<int>>&g, int cur, int parent, int target)\\n    {\\n        int curSum = nums[cur];\\n        for(auto &nbr : g[cur])\\n        {\\n            if(nbr == parent) continue;     // avoid going backside in graph else infinite loop\\n            curSum += dfs(nums, g, nbr, cur,target);\\n        }\\n        \\n        // on returning back in recursion if you get target break \\n        // it there and start sum from 0 for next\\n        \\n        if(curSum == target) \\n            return 0;\\n        else \\n            return curSum;\\n    }\\n    \\n\\t\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) \\n    {\\n        int n = nums.size();\\n        vector<vector<int>>g(n);\\n        \\n        // make graph\\n        for(auto e : edges){\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        \\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        \\n        // Handle early this Edge case will save time \\n        // if all values of nums are same divide each node as individual also \\n        // get total sum, i.e all nodes have same value.\\n        \\n        unordered_set<int>st(nums.begin(), nums.end());\\n        if(st.size() == 1) return n-1;\\n        \\n        // start from maximum (i.e n-1) number of components to minimum no. of components that is \"2\"\\n        for(int i=n-1;i>=2;i--)\\n        {\\n            if(sum%i != 0) continue;               // not dividable into \"i\" components\\n            \\n            int ans = dfs(nums, g, 0, -1, sum/i);  // value array , graph , start , parent , EachComponentSum\\n            \\n            // if ans finally returned to \"0\" means all components are successfully divided into sum of \"sum/i\"\\n            if(ans == 0) return i-1;               // edges removed = total components divided into - 1 \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706536,
                "title": "explained-c",
                "content": "Each component\\'s sum can be only divisor of the total sum. Thus we only need to check those (~100 divisors max of a number).\\n\\nFor each candidate sum, we will spend linear time to check whether it is possible to divide tree into such components with given sum, using dfs.\\n\\nRun dfs, and keep track of the subtree visited, when the sum of nodes in the subtree becomes equal to the potential sum, we will update our sum of subnodes to zero, and will count again until we go through entire tree. If at some point the sum is greater than potential sum, that means we cant build such a division into subtrees.\\n\\nAt the end, we know into how many components we were able to divide. From which we infer number of edges deleted and pick max.\\n\\nComplexity: n * D(sum of nodes). \\nD(s) number of divisors of s.\\n\\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n#define forn(i, n) for(int i = 0; i < n; ++i)\\n#define forbn(i, b, n) for(int i = b; i < n; ++i)\\n#define sz(v) (int)v.size()\\n#define pb push_back\\n\\ntypedef vector<int> vi;\\n\\n\\nclass Solution {\\npublic:\\n\\tstatic const int N = 20 * 1001;\\n\\tvi gr[N];\\n\\tvi gl_nums;\\n\\t\\n    \\n\\tint dfs(int target_sm, int node, int pr = -1) {\\n\\t\\tint loc_sm = gl_nums[node];\\n\\t\\t\\n\\t\\tfor(int to: gr[node]) {\\n\\t\\t\\tif(to != pr) {\\n\\t\\t\\t\\tint rem = dfs(target_sm, to, node);\\n\\t\\t\\t\\tloc_sm += rem;\\n\\t\\t\\t\\tif(rem < 0)\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(loc_sm == target_sm) {\\n\\t\\t\\treturn 0;\\n\\t\\t} \\n\\t\\tif(loc_sm > target_sm) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\treturn loc_sm;\\n\\t}\\n\\t\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n    \\tint total = 0;\\n    \\tfor(int to: nums) {\\n    \\t\\tgl_nums.pb(to);\\n    \\t\\ttotal += to;\\n    \\t}\\n    \\t\\n    \\tforn(i, sz(edges)) {\\n    \\t\\tint a = edges[i][0];\\n    \\t\\tint b = edges[i][1];\\n    \\t\\t\\n    \\t\\tgr[a].pb(b);\\n    \\t\\tgr[b].pb(a);\\n    \\t}\\n    \\t\\n    \\tforbn(d, 1, total + 1) {\\n    \\t\\tif(total % d == 0) {\\n    \\t\\t\\tint ans = dfs(d, 0);\\n    \\t\\t\\tif(ans == 0) {\\n    \\t\\t\\t\\tint k = total / d;\\n    \\t\\t\\t\\treturn k - 1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n#define forn(i, n) for(int i = 0; i < n; ++i)\\n#define forbn(i, b, n) for(int i = b; i < n; ++i)\\n#define sz(v) (int)v.size()\\n#define pb push_back\\n\\ntypedef vector<int> vi;\\n\\n\\nclass Solution {\\npublic:\\n\\tstatic const int N = 20 * 1001;\\n\\tvi gr[N];\\n\\tvi gl_nums;\\n\\t\\n    \\n\\tint dfs(int target_sm, int node, int pr = -1) {\\n\\t\\tint loc_sm = gl_nums[node];\\n\\t\\t\\n\\t\\tfor(int to: gr[node]) {\\n\\t\\t\\tif(to != pr) {\\n\\t\\t\\t\\tint rem = dfs(target_sm, to, node);\\n\\t\\t\\t\\tloc_sm += rem;\\n\\t\\t\\t\\tif(rem < 0)\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(loc_sm == target_sm) {\\n\\t\\t\\treturn 0;\\n\\t\\t} \\n\\t\\tif(loc_sm > target_sm) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\treturn loc_sm;\\n\\t}\\n\\t\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n    \\tint total = 0;\\n    \\tfor(int to: nums) {\\n    \\t\\tgl_nums.pb(to);\\n    \\t\\ttotal += to;\\n    \\t}\\n    \\t\\n    \\tforn(i, sz(edges)) {\\n    \\t\\tint a = edges[i][0];\\n    \\t\\tint b = edges[i][1];\\n    \\t\\t\\n    \\t\\tgr[a].pb(b);\\n    \\t\\tgr[b].pb(a);\\n    \\t}\\n    \\t\\n    \\tforbn(d, 1, total + 1) {\\n    \\t\\tif(total % d == 0) {\\n    \\t\\t\\tint ans = dfs(d, 0);\\n    \\t\\t\\tif(ans == 0) {\\n    \\t\\t\\t\\tint k = total / d;\\n    \\t\\t\\t\\treturn k - 1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3705666,
                "title": "c-bfs-with-explanation-beginner-friendly",
                "content": "# Intuition\\nThe problem requires two things to be thought of:\\n\\n*Q1) What could be the sum of each component?\\nQ2) How can we check whether the tree could be split into components of given sum?*\\n\\n1) Add the value of all the nodes and try all the possible sums into which this value can be broken down.\\n2) Start travelling from the leaf nodes and move towards the root. A leaf node can be considered only if its value equals the sum. If it\\'s value is less than the sum then it must give its to its parent. On the other hand if its value is greater than sum we can conclude that the tree cant be broken into clusters of that sum.\\n\\n*Please upvote if found helpful :)*\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool bfs(int rt, vector<vector<int>> &adj,vector<int>&nums, int sum){\\n        stack<vector<int>> st;\\n        vector<int> vis(adj.size());\\n        queue<int> q;\\n        q.push(rt);\\n        vector<int> first={rt};\\n        st.push(first);\\n\\n\\n        while(!q.empty()){\\n            int siz=q.size();\\n            vector<int> tem;\\n            for(int i=0;i<siz;i++){\\n                int nod=q.front();\\n                vis[nod]=1;\\n                q.pop();\\n                for(auto it:adj[nod]){\\n                    if(!vis[it]){\\n                        q.push(it);\\n                        tem.push_back(it);\\n                    }\\n                }\\n            }\\n            st.push(tem);\\n        }\\n        vector<int> pval(adj.size());\\n        for(int i =0;i<vis.size();i++){\\n            vis[i]=0;\\n        }\\n        while(!st.empty()){\\n            \\n            vector<int> tem=st.top();\\n            for(int i=0;i<tem.size();i++){\\n                vis[tem[i]]=1;\\n                if(pval[tem[i]]+nums[tem[i]]>sum){\\n                    return 0;\\n                }else if(pval[tem[i]]+nums[tem[i]]<sum){\\n                    for(auto it: adj[tem[i]]){\\n                        if(!vis[it]){\\n                            \\n                            pval[it]+=pval[tem[i]]+nums[tem[i]];\\n                        }\\n                    }\\n                } \\n            }\\n            st.pop();\\n        }\\n        if(pval[0]+nums[0]!=sum) return 0;\\n        return 1;\\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int sum=accumulate(nums.begin(),nums.end(),0);\\n        vector<vector<int>> adj(nums.size());\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int maxi=INT_MIN;\\n        for(int i=1;i<=sqrt(sum);i++){\\n            if(sum%i==0){\\n                if(bfs(0,adj,nums,sum/i)){\\n                    maxi=max(maxi,i-1);\\n                }\\n                int quo=sum/i;\\n                if(bfs(0,adj,nums,sum/quo)){\\n                    maxi=max(maxi,quo-1);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool bfs(int rt, vector<vector<int>> &adj,vector<int>&nums, int sum){\\n        stack<vector<int>> st;\\n        vector<int> vis(adj.size());\\n        queue<int> q;\\n        q.push(rt);\\n        vector<int> first={rt};\\n        st.push(first);\\n\\n\\n        while(!q.empty()){\\n            int siz=q.size();\\n            vector<int> tem;\\n            for(int i=0;i<siz;i++){\\n                int nod=q.front();\\n                vis[nod]=1;\\n                q.pop();\\n                for(auto it:adj[nod]){\\n                    if(!vis[it]){\\n                        q.push(it);\\n                        tem.push_back(it);\\n                    }\\n                }\\n            }\\n            st.push(tem);\\n        }\\n        vector<int> pval(adj.size());\\n        for(int i =0;i<vis.size();i++){\\n            vis[i]=0;\\n        }\\n        while(!st.empty()){\\n            \\n            vector<int> tem=st.top();\\n            for(int i=0;i<tem.size();i++){\\n                vis[tem[i]]=1;\\n                if(pval[tem[i]]+nums[tem[i]]>sum){\\n                    return 0;\\n                }else if(pval[tem[i]]+nums[tem[i]]<sum){\\n                    for(auto it: adj[tem[i]]){\\n                        if(!vis[it]){\\n                            \\n                            pval[it]+=pval[tem[i]]+nums[tem[i]];\\n                        }\\n                    }\\n                } \\n            }\\n            st.pop();\\n        }\\n        if(pval[0]+nums[0]!=sum) return 0;\\n        return 1;\\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int sum=accumulate(nums.begin(),nums.end(),0);\\n        vector<vector<int>> adj(nums.size());\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int maxi=INT_MIN;\\n        for(int i=1;i<=sqrt(sum);i++){\\n            if(sum%i==0){\\n                if(bfs(0,adj,nums,sum/i)){\\n                    maxi=max(maxi,i-1);\\n                }\\n                int quo=sum/i;\\n                if(bfs(0,adj,nums,sum/quo)){\\n                    maxi=max(maxi,quo-1);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253972,
                "title": "java-100-faster-easy-solution-no-recursion-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/abdff6d0-a6a1-4ede-ba79-46e8e428fb49_1677891910.0585468.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[] nums;\\n    public int componentValue(int[] nums, int[][] edges) {\\n        int n = nums.length;\\n        this.nums = nums;\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i=0; i<n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        \\n        int sum = 0;\\n        for(int i : nums) {\\n            sum += i;\\n        }\\n        \\n        for(int k=n; k>0; k--) {\\n            if(sum % k != 0) continue;\\n            int ans = helper(graph, 0, -1, sum / k);\\n            if(ans == 0) return k-1;\\n        }\\n        return 0;\\n    }\\n    \\n    private int helper(List<Integer>[] graph, int i, int prev, int target) {\\n        if(graph[i].size() == 1 && graph[i].get(0) == prev) {\\n            if(nums[i] > target) return -1;\\n            if(nums[i] == target) return 0;\\n            return nums[i];\\n        }\\n        \\n        int sum = nums[i];\\n        for(int k : graph[i]) {\\n            if(k == prev) continue;\\n            int ans = helper(graph, k, i, target);\\n            if(ans == -1) return -1;\\n            sum += ans;\\n        }\\n        \\n        if(sum > target) return -1;\\n        if(sum == target) return 0;\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] nums;\\n    public int componentValue(int[] nums, int[][] edges) {\\n        int n = nums.length;\\n        this.nums = nums;\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i=0; i<n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        \\n        int sum = 0;\\n        for(int i : nums) {\\n            sum += i;\\n        }\\n        \\n        for(int k=n; k>0; k--) {\\n            if(sum % k != 0) continue;\\n            int ans = helper(graph, 0, -1, sum / k);\\n            if(ans == 0) return k-1;\\n        }\\n        return 0;\\n    }\\n    \\n    private int helper(List<Integer>[] graph, int i, int prev, int target) {\\n        if(graph[i].size() == 1 && graph[i].get(0) == prev) {\\n            if(nums[i] > target) return -1;\\n            if(nums[i] == target) return 0;\\n            return nums[i];\\n        }\\n        \\n        int sum = nums[i];\\n        for(int k : graph[i]) {\\n            if(k == prev) continue;\\n            int ans = helper(graph, k, i, target);\\n            if(ans == -1) return -1;\\n            sum += ans;\\n        }\\n        \\n        if(sum > target) return -1;\\n        if(sum == target) return 0;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745581,
                "title": "python-one-pass-dfs-to-count-optimized-with-module-o-n-factor-of-sum-nums-max-nums",
                "content": "First, get all subtree sum dfs start from any node(here is 0).As every compent we get is divisor of sum(nums), we iterate all k in range(max(nums), s). *sum(c for v, c in dt.items() if v % k == 0)* is used to get all subtree sum is k * t(1 <= t <= s // k).\\n```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        graph = [[] for _ in range(len(nums))]\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        dt, visited = dict(), set()\\n        def dfs(v):\\n            visited.add(v)\\n            ret = nums[v]\\n            for u in graph[v]:\\n                if u not in visited: ret += dfs(u)\\n            dt[ret] = dt.get(ret, 0) + 1\\n            return ret\\n        s = sum(nums)\\n        dfs(0)\\n        for k in range(max(nums), s):\\n            if s % k: continue\\n            if sum(c for v, c in dt.items() if v % k == 0) == s // k: return s // k - 1\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        graph = [[] for _ in range(len(nums))]\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        dt, visited = dict(), set()\\n        def dfs(v):\\n            visited.add(v)\\n            ret = nums[v]\\n            for u in graph[v]:\\n                if u not in visited: ret += dfs(u)\\n            dt[ret] = dt.get(ret, 0) + 1\\n            return ret\\n        s = sum(nums)\\n        dfs(0)\\n        for k in range(max(nums), s):\\n            if s % k: continue\\n            if sum(c for v, c in dt.items() if v % k == 0) == s // k: return s // k - 1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725968,
                "title": "java-dfs",
                "content": "```\\n\\t//1.DFS\\n    //Runtime: 64 ms, faster than 97.17% of Java online submissions for Create Components With Same Value.\\n    //Memory Usage: 103.1 MB, less than 83.02% of Java online submissions for Create Components With Same Value.\\n    //Time: O(V + V + E + logV * V); Space: O(V + E + V)\\n    //Time: O(logV * V); Space: O(V)\\n    public int componentValue(int[] nums, int[][] edges) {\\n        if (edges.length == 0) return 0;\\n\\n        //Time: O(V)\\n        int sum = 0, maxValue = 0;\\n        for (int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            maxValue = Math.max(maxValue, nums[i]);\\n        }\\n        int maxCount = sum / maxValue;\\n        if (sum % maxCount == 0 && maxCount == nums.length) return nums.length - 1;\\n\\n        //build graph\\n        //Time: O(V + E); Space: O(V + E)\\n        List<Integer>[] graph = new List[nums.length];\\n        for (int i = 0; i < nums.length; i++) graph[i] = new ArrayList<>();\\n        for (int[] edge: edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n\\n        //Time: O(logV * V); Space:O(V)\\n        for (int k = maxCount; k > 1; k--)\\n            if (sum % k == 0 && helper_dfs_sumTarget(nums, graph,0, -1, sum / k) == 0)\\n                return k - 1;\\n        return 0;\\n    }\\n\\n    private int helper_dfs_sumTarget(int[] nums, List<Integer>[] graph,\\n                       int index, int parent, int target) {\\n        //the sum of value of current subtree\\n        int sum = nums[index];\\n        for (int neighbour : graph[index]){\\n            if (neighbour != parent) {\\n                sum += helper_dfs_sumTarget(nums, graph, neighbour, index, target);\\n                if (sum > target) return sum;\\n            }\\n        }\\n        //sum == target means current subtree can be deleted from tree.\\n        return sum == target ? 0 : sum;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n\\t//1.DFS\\n    //Runtime: 64 ms, faster than 97.17% of Java online submissions for Create Components With Same Value.\\n    //Memory Usage: 103.1 MB, less than 83.02% of Java online submissions for Create Components With Same Value.\\n    //Time: O(V + V + E + logV * V); Space: O(V + E + V)\\n    //Time: O(logV * V); Space: O(V)\\n    public int componentValue(int[] nums, int[][] edges) {\\n        if (edges.length == 0) return 0;\\n\\n        //Time: O(V)\\n        int sum = 0, maxValue = 0;\\n        for (int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            maxValue = Math.max(maxValue, nums[i]);\\n        }\\n        int maxCount = sum / maxValue;\\n        if (sum % maxCount == 0 && maxCount == nums.length) return nums.length - 1;\\n\\n        //build graph\\n        //Time: O(V + E); Space: O(V + E)\\n        List<Integer>[] graph = new List[nums.length];\\n        for (int i = 0; i < nums.length; i++) graph[i] = new ArrayList<>();\\n        for (int[] edge: edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n\\n        //Time: O(logV * V); Space:O(V)\\n        for (int k = maxCount; k > 1; k--)\\n            if (sum % k == 0 && helper_dfs_sumTarget(nums, graph,0, -1, sum / k) == 0)\\n                return k - 1;\\n        return 0;\\n    }\\n\\n    private int helper_dfs_sumTarget(int[] nums, List<Integer>[] graph,\\n                       int index, int parent, int target) {\\n        //the sum of value of current subtree\\n        int sum = nums[index];\\n        for (int neighbour : graph[index]){\\n            if (neighbour != parent) {\\n                sum += helper_dfs_sumTarget(nums, graph, neighbour, index, target);\\n                if (sum > target) return sum;\\n            }\\n        }\\n        //sum == target means current subtree can be deleted from tree.\\n        return sum == target ? 0 : sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2712296,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    ll n, rem, sum;\\n    vi(vi(ll))g;\\n    ll func(const vi(vi(ll))&g, const vi(int)&val, const ll&nd, const ll&par){\\n        ll tot=val[nd];\\n        for(ll child:g[nd]){\\n            if(child!=par){\\n                tot+=func(g, val, child, nd);\\n            }\\n        }\\n        if(tot==sum){\\n            --rem, tot=0;\\n        }\\n        return tot;\\n    }\\n    int componentValue(vector<int>&v, vector<vector<int>>&e) {\\n        n=v.size();\\n        ll tot=accumulate(begin(v), end(v), 0LL), ans=0;\\n        g.resize(n);\\n        for(auto edge:e){\\n            g[edge[0]].pb(edge[1]);\\n            g[edge[1]].pb(edge[0]);\\n        }\\n        for(ll i=1;i<=n;++i){\\n            if(tot%i){\\n                continue;\\n            }\\n                rem=i, sum=tot/rem;\\n                func(g, v, 0, -1);\\n                if(rem==0){\\n                    ans=i;\\n                }\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    ll n, rem, sum;\\n    vi(vi(ll))g;\\n    ll func(const vi(vi(ll))&g, const vi(int)&val, const ll&nd, const ll&par){\\n        ll tot=val[nd];\\n        for(ll child:g[nd]){\\n            if(child!=par){\\n                tot+=func(g, val, child, nd);\\n            }\\n        }\\n        if(tot==sum){\\n            --rem, tot=0;\\n        }\\n        return tot;\\n    }\\n    int componentValue(vector<int>&v, vector<vector<int>>&e) {\\n        n=v.size();\\n        ll tot=accumulate(begin(v), end(v), 0LL), ans=0;\\n        g.resize(n);\\n        for(auto edge:e){\\n            g[edge[0]].pb(edge[1]);\\n            g[edge[1]].pb(edge[0]);\\n        }\\n        for(ll i=1;i<=n;++i){\\n            if(tot%i){\\n                continue;\\n            }\\n                rem=i, sum=tot/rem;\\n                func(g, v, 0, -1);\\n                if(rem==0){\\n                    ans=i;\\n                }\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710662,
                "title": "python-bfs-topological-sort-w-explanation-beats-100",
                "content": "Python solution:\\n```\\nclass Solution:\\n    def componentValue(self, N:List[int], E: List[List[int]]) -> int:\\n        total_sum, n = sum(nums), len(nums)\\n        adj_list, dep_counts = collections.defaultdict(set), [0] * n\\n        for v1, v2 in edges:\\n            adj_list[v1].add(v2)\\n            adj_list[v2].add(v1)\\n            dep_counts[v1] += 1\\n            dep_counts[v2] += 1\\n\\n        def can_partition_into_subtrees_with_sum_(target_tree_sum: int) -> bool:\\n            v_subtree_sums, dep_counts_copy = nums[:], dep_counts[:]\\n            v_dq = deque([i for i, dep_count in enumerate(dep_counts) if dep_count == 1])\\n            while v_dq:\\n                for _ in range(len(v_dq)):\\n                    curr_v = v_dq.pop()\\n                    if v_subtree_sums[curr_v] > target_tree_sum:\\n                        return False\\n                    elif dep_counts_copy[curr_v] == 0:  # can\\'t come up with a short example to trigger this condition\\n                        continue\\n                    dep_counts_copy[curr_v] = 0\\n                    for next_v in adj_list[curr_v]:\\n                        if v_subtree_sums[curr_v] == target_tree_sum or dep_counts_copy[next_v] > 0:\\n                            dep_counts_copy[next_v] -= 1\\n                            if v_subtree_sums[curr_v] < target_tree_sum:\\n                                v_subtree_sums[next_v] += v_subtree_sums[curr_v]\\n                            if dep_counts_copy[next_v] == 0:\\n                                return v_subtree_sums[next_v] == target_tree_sum\\n                            elif dep_counts_copy[next_v] == 1:\\n                                v_dq.appendleft(next_v)\\n            return True\\n\\n        for possible_subtree_sum in range(total_sum // n, total_sum):\\n            if total_sum % possible_subtree_sum == 0 and can_partition_into_subtrees_with_sum_(possible_subtree_sum):\\n                return total_sum // possible_subtree_sum - 1\\n        return 0\\n```\\nI put this together with help from https://leetcode.com/problems/create-components-with-same-value/discuss/2706736/Python-Explanation-with-pictures-BFS and cleaned it up to be easier for me to understand. (Would highly recommend checking out the pictures in the linked post).\\n\\nHere\\'s the explanation I could come up with:\\n1. **Only attempt to partition the tree into subtrees with a sum that is a perfect divisor of the total tree sum.**\\nThe first thing to realize here (as the problem hint says), is that you can only split the tree into x subtrees if x cleanly divides the sum of nums.\\n\\t* Ex1: `nums = [1,2,1], sum(nums) = 4`. Here, it\\'s obvious that we can\\'t split the tree into 3 subtrees (which would be the optimal answer since we would be deleting all edges), because 4/3 is not an integer (ie 4 % 3 != 0)\\n\\t* Ex2: `nums = [6,8,10], sum(nums) = 24`. Here, it could be possible to split the tree into 3 subtrees with sum 8 since 24 % 3 == 0. In this case, now we need to actually run through the tree and see if we can successfully partition it into 3 subtrees of sum 8 (obviously not possible for the given example).\\n\\t* This principle provides the setup for the `for`-loop iterating from `[total_sum // n, total_sum)`. The minimum possible valid subtree sum would be `total_sum` split over n subtrees (ie 1-node trees), and the max would be a single tree with all nodes summing to `total_sum` (we don\\'t need to manually check the max since it is the default answer if we can\\'t do any splits).\\n2. **Additional space required for performing the partitioning**\\nTo perform the actual partition-checking, we define a function that takes in the required sum that each subtree must have, and attempts to split all the nodes into subtrees with that sum. In order for this function to do its job, it will need:\\n\\t*  An easy way to determine the neighbors of a given node.\\n\\t\\t*   We build a standard adjacency list `adj_list` to do this.\\n\\t*  An easy way to track whether a given node has been used up or not.\\n\\t\\t*  We build a dependency-count array `dep_counts` (aka the current \"degree\" of a vertex) to do this.\\n\\t*  An easy way to track the sum of the subtree at the current vertex being considered.\\n\\t\\t*  We\\'ll use the `nums` array for this.\\n\\t*  Since the partition function could be run multiple times for multiple possible subtree sums, and since we\\'ll need to modify the subtree sums and `dep_counts` as we go, we\\'ll need to make copies of these arrays each time the function executes. We\\'ll use those copies during the function-execution.\\n3. **Process the nodes in the tree starting from leaves first**\\n\\t* \\tTo partition the tree into subtrees of sum x, we\\'ll start from all the leaf nodes in the tree. The reason we want to start from leaf nodes rather than a middle node is that if a node has multiple neighbors to pick from, we don\\'t know ahead-of-time which neighbor should be the correct one to pick such that other nodes in the tree will also be able to correctly form subtrees of sum x.\\n\\t* \\tEx: Given this tree which you want to partition into subtrees of sum 3:\\n\\t\\t```\\n        1      2\\n         \\\\    /\\n          2--1\\n         /    \\\\\\n        3      3\\n\\t\\t```\\n\\t\\tIf you start at the first 2 with 3 neighbors, and you incorrectly pick the \"1\" to the right to make a subtree of sum 3, then the other nodes will not be able to form subtrees of sum 3. This would require some complex backtracking to undo, so it\\'s better to start at the leaf nodes.\\n\\t* \\t(In case you haven\\'t already seen it...we\\'re going to be running a topological sort lol) We\\'ll build a deque of nodes `v_dq`, which will be instantiated with all nodes with `dep_count == 1` (ie leaves).\\n4. **Perform the subtree-building in a topological-sort fashion**\\nNow we\\'ll just do a standard bfs-style iteration of the vertices in the deque which is common to topological sort problems. For all the elements in the deque, we pop off each one and do the following:\\n\\t* Let `curr_v` be the current vertex we are considering which we just popped off the deque\\n\\t* If the sum of the subtree at `curr_v` is > than the target sum, we know we\\'ve failed the partitioning so we\\'ll just return False immediately.\\n\\t\\t* Ex: `nums=[10,2], sum(nums) = 12`, we\\'d first try to partition the tree into 2 subtrees of sum 6. We check 10 and its sum is > 6, so we stop immediately.\\n\\t* Otherwise, if the dep_count of `curr_v` is 0, then we\\'ll skip it and move on to the next vertex. I think this case only occurs if we added a vertex to a previous subtree while that vertex was sitting in the deque.\\n\\t\\t* Ex: Unfortunately I can\\'t come up with a simple example to demonstrate this. If you have one please let me know. (This condition is necessary to achieve fast runtime)\\n\\t* Otherwise we\\'ll set the dep_count of `curr_v` to 0 to indicate that this node has been used up in a subtree that we\\'re building. Now, for each of the neighbors of `curr_v` (denoted `next_v`), we do the following:\\n\\t\\t* if the sum at `curr_v` is already equal to the target sum, then we know this tree is finished. Thus all neighboring nodes should no longer have a dependency on `curr_v` and we\\'ll decrement their dep_count by 1. (Note this may cause the `dep_count` of some nodes to fall below 0 - this is not an issue because those nodes would have already been processed in our `v_dq` ahead-of-time due to having a lower dependency-count than us [this is the nature of a topological sort]).\\n\\t\\t\\t* if we find after decrementing the neighbor\\'s `dep_count` that it\\'s `dep_count == 0`, this indicates that we\\'ve just processed all nodes in the tree (by the nature of a connected tree where the node with the most edges is processed last). So we\\'ll just check whether our `tree_sum == target` and, if so, `return True` (else `return False`).\\n\\t\\t\\t* otherwise if the neighbor\\'s `dep_count` is now 1, that means it\\'s eligible to be processed in the next round of BFS, so we\\'ll append it onto `v_dq`.\\n\\t\\t* the only other possibility is that our `tree_sum` is < than the target sum (we already checked the > condition above so we would\\'ve returned False by now). For this case, we can only consider neighbors whose `dep_count` is > 0 (otherwise we would end up looking at nodes that were already added to our subtree in the previous iteration).\\n\\t\\t\\t* Since we absolutely need another node in our subtree to potentially hit the target, we must add this neighbor into our subtree. (Remember that nodes in `v_dq` have only 1 dependency, which means there\\'s only 1 option to pick for increasing our subtree sum.) Thus we will increment the `next_v` tree_sum value by `curr_v` tree_sum value.\\n\\t\\t\\t* Afterwards, the same logic as in the previous block applies:\\n\\t\\t\\t\\t* if the neighbor we just added has `dep_count == 0`, it\\'s the last node to be processed in the tree.\\n\\t\\t\\t\\t* elif the neighbor\\'s `dep_count == 1`, it\\'s ready to be processed in the next round of BFS.\\n\\t\\t\\t\\t* otherwise, the neighbor must have other dependencies that should be processed first before deciding if any more nodes should be added to our subtree that the neighbor is now in.\\n\\t* Note: There is a `return True` condition at the end of the function - this should not execute because our topological sort will handle it in the `if dep_counts_copy[next_v] == 0` condition.\\n5. A nice thing to note about the final answer we return: If we are able to successfully partition the given tree into multiple subtrees, then the number of edges that were deleted is going to be exactly the `number of subtrees` - 1.\\n\\t* Ex: `nums=[8,8,8], sum(nums) = 24`. We can partition into 3 subtrees, which means we\\'d remove 2 edges.\\n\\t\\tSince all the nodes are connected in the beginning, to form 2 trees out of 1 tree, you delete one edge. Then to form 3 trees from 2 trees, you delete one more edge. etc.\\n\\t\\t\\nSorry if this was a little verbose. Hopefully it\\'ll help me understand this if I look at it again a few years from now lol.",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def componentValue(self, N:List[int], E: List[List[int]]) -> int:\\n        total_sum, n = sum(nums), len(nums)\\n        adj_list, dep_counts = collections.defaultdict(set), [0] * n\\n        for v1, v2 in edges:\\n            adj_list[v1].add(v2)\\n            adj_list[v2].add(v1)\\n            dep_counts[v1] += 1\\n            dep_counts[v2] += 1\\n\\n        def can_partition_into_subtrees_with_sum_(target_tree_sum: int) -> bool:\\n            v_subtree_sums, dep_counts_copy = nums[:], dep_counts[:]\\n            v_dq = deque([i for i, dep_count in enumerate(dep_counts) if dep_count == 1])\\n            while v_dq:\\n                for _ in range(len(v_dq)):\\n                    curr_v = v_dq.pop()\\n                    if v_subtree_sums[curr_v] > target_tree_sum:\\n                        return False\\n                    elif dep_counts_copy[curr_v] == 0:  # can\\'t come up with a short example to trigger this condition\\n                        continue\\n                    dep_counts_copy[curr_v] = 0\\n                    for next_v in adj_list[curr_v]:\\n                        if v_subtree_sums[curr_v] == target_tree_sum or dep_counts_copy[next_v] > 0:\\n                            dep_counts_copy[next_v] -= 1\\n                            if v_subtree_sums[curr_v] < target_tree_sum:\\n                                v_subtree_sums[next_v] += v_subtree_sums[curr_v]\\n                            if dep_counts_copy[next_v] == 0:\\n                                return v_subtree_sums[next_v] == target_tree_sum\\n                            elif dep_counts_copy[next_v] == 1:\\n                                v_dq.appendleft(next_v)\\n            return True\\n\\n        for possible_subtree_sum in range(total_sum // n, total_sum):\\n            if total_sum % possible_subtree_sum == 0 and can_partition_into_subtrees_with_sum_(possible_subtree_sum):\\n                return total_sum // possible_subtree_sum - 1\\n        return 0\\n```\n```\\n        1      2\\n         \\\\    /\\n          2--1\\n         /    \\\\\\n        3      3\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2709839,
                "title": "c-easy-to-understand-100-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDiving the total sum into equal parts and then simply DFS call\\n\\n# Complexity\\n- Time complexity:O(N*root(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n         int n=nums.size();\\n        vector<vector<int>> adj(n);\\n        int sum=0;\\n         for (int i=0; i<n; ++i)\\n            sum+=nums[i];\\n        for(auto &x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            \\n            adj[x[1]].push_back(x[0]);\\n        }\\n       \\n       for(int i=n;i>1;i--)\\n       {\\n           if(sum%i) continue;\\n         \\n           if(dfs(nums,adj,0,-1,sum/i)==0)\\n           return i-1;\\n       }\\n       return 0;\\n    }\\n    private:\\n    int dfs(vector<int> &nums,vector<vector<int>> &adj,int node,int par,int target)\\n    {\\n        int s=nums[node];\\n        for(auto &it:adj[node])\\n        {\\n            if(it==par) continue;\\n            s+=dfs(nums,adj,it,node,target);\\n        }\\n        if(s==target)\\n        return 0;\\n        else\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n         int n=nums.size();\\n        vector<vector<int>> adj(n);\\n        int sum=0;\\n         for (int i=0; i<n; ++i)\\n            sum+=nums[i];\\n        for(auto &x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            \\n            adj[x[1]].push_back(x[0]);\\n        }\\n       \\n       for(int i=n;i>1;i--)\\n       {\\n           if(sum%i) continue;\\n         \\n           if(dfs(nums,adj,0,-1,sum/i)==0)\\n           return i-1;\\n       }\\n       return 0;\\n    }\\n    private:\\n    int dfs(vector<int> &nums,vector<vector<int>> &adj,int node,int par,int target)\\n    {\\n        int s=nums[node];\\n        for(auto &it:adj[node])\\n        {\\n            if(it==par) continue;\\n            s+=dfs(nums,adj,it,node,target);\\n        }\\n        if(s==target)\\n        return 0;\\n        else\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707109,
                "title": "simple-logic-dfs-factors-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n    int comp;\\n    int dfs(vector<int>& nums,int v, int parent,int val) {\\n        int total = nums[v];\\n        for(auto x: adj[v]) {\\n            if(x == parent) continue;\\n            total += dfs(nums,x, v,val);\\n        } \\n        if(total == val) {\\n            comp--;\\n            return 0;\\n        }\\n        return total;\\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        adj.resize(n);\\n        for(auto e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        if(count(nums.begin(), nums.end(), nums[0]) == n) return n - 1;\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        int res = 0;\\n    \\n        for(int i = 2; i * i <= sum; ++i) {\\n            if(sum % i == 0) {\\n                comp = i;\\n                dfs(nums,0, -1,sum / i);\\n                if(comp == 0) res = max(res, i - 1);\\n                \\n                comp = sum / i;\\n                dfs(nums,0, -1,i);\\n                if(comp == 0) res = max(res, (sum / i) - 1);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n    int comp;\\n    int dfs(vector<int>& nums,int v, int parent,int val) {\\n        int total = nums[v];\\n        for(auto x: adj[v]) {\\n            if(x == parent) continue;\\n            total += dfs(nums,x, v,val);\\n        } \\n        if(total == val) {\\n            comp--;\\n            return 0;\\n        }\\n        return total;\\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        adj.resize(n);\\n        for(auto e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        if(count(nums.begin(), nums.end(), nums[0]) == n) return n - 1;\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        int res = 0;\\n    \\n        for(int i = 2; i * i <= sum; ++i) {\\n            if(sum % i == 0) {\\n                comp = i;\\n                dfs(nums,0, -1,sum / i);\\n                if(comp == 0) res = max(res, i - 1);\\n                \\n                comp = sum / i;\\n                dfs(nums,0, -1,i);\\n                if(comp == 0) res = max(res, (sum / i) - 1);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706982,
                "title": "faster-solution-o-mloglogm-where-m-is-the-sum-of-nodes",
                "content": "## Prerequisite\\nChoose an arbitrary root to make the tree rooted. 0 is the root thereafter.\\nThe sum of nodes in the subtree (subtree-sum thereafter) rooted at each node can be found by a simple DFS in O(N).\\nLet M be the sum of all nodes, or in other words, the subtree-sum of the root.\\n\\n## Lemma\\nThis solution is based on the following not so intuitive lemma:\\n> For any divisor D of M, the tree can be divided into connected components (CCs) with the same sum D, if and only if D divides exactly M/D nodes\\' subtree-sum.\\n## Proof\\n### \"=>\" direction\\nFor any CC, consider its unique node closest to the root. The subtree rooted at this node is disconnected from the rest of the tree, so this subtree must consist of one or more CCs in their entirety. Therefore this node\\'s subtree-sum is the sum of one more CCs and is divisible by D.\\nConversely, if a node is not a CC\\'s closest node to the root, let sub-CC be the intersection of this CC and the subtree rooted at this node. Note that sub-CC is a proper subset of CC, since this node\\'s parent must also belong to this CC. Also, since nodes are all positive, sub-CC\\'s sum is positive and strictly smaller than that of CC. The subtree-sum of this node is the sum of sub-CC and zero or more other CCs in their entirety, so if the subtree-sum divisible by D, the sub-CC\\'s sum must be at least D, and the CC\\'s sum is strictly larger than D, a contradiction.\\nWe have shown that a node\\'s subtree-sum is divisible by D if and only if it\\'s a CC\\'s unique closest node to the root. Since there are exactly M/D CCs, there are exactly M/D nodes whose subtree-sum is divisible by D.\\n### \"<=\" direction:\\nRemove all edges between non-root nodes whose subtree-sum is divisible by D and their parents. This splits the tree into M/D CCs. Each CC\\'s sum must be positive and divisible by D, and thus at least D. Also, none of the CC\\'s sum could larger than D since otherwise their sum will be larger than M, a contradition. Therefore all CC\\'s sums are exactly D, and we found a valid solution.\\n## Algorithm\\nUse an array or a hashmap to count the number of subtree-sums equal to x for every integer x from 1 to M (inclusive). Let\\'s call it `count`.\\nEnumerate all divisors of D of M, starting from the smallest. The number of subtree-sums divisible by D is given by `count[D]+count[D*2]+...+count[M]`. If it is exactly M/D, return M/D-1.\\nFor each D, it takes M/D steps to compute the summation. Therefore the complexity is the sum of M/D over all D\\'s, which is the same as the sum of all D\\'s. This is at most O(MloglogM). See https://en.wikipedia.org/wiki/Divisor_function#Growth_rate\\n## Code\\n### C++\\n```\\nclass Solution {\\n    void dfs(int u,vector<int> &subsum,const vector<vector<int>> &adj,vector<bool> &vis){\\n        vis[u]=true;\\n        for(int v:adj[u])\\n            if(!vis[v]){\\n                dfs(v,subsum,adj,vis);\\n                subsum[u]+=subsum[v];\\n            }\\n    }\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=nums.size();\\n        vector<vector<int>> adj(n);\\n        for(auto &e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<bool> vis(n);\\n        dfs(0,nums,adj,vis);\\n        int tot=nums[0];\\n        vector<int> cnt(tot+1);\\n        for(int x:nums)\\n            cnt[x]++;\\n        for(int d=1;d<tot;d++)\\n            if(tot%d==0){\\n                int c=0;\\n                for(int i=d;i<tot;i+=d)\\n                    c+=cnt[i];\\n                if((c+1)*d==tot)\\n                    return c;\\n            }\\n        return 0;\\n    }\\n};\\n```\\n### Python\\n```\\nclass Solution:\\n    def dfs(self, u):\\n        self.vis[u]=True\\n        for v in self.adj[u]:\\n            if not self.vis[v]:\\n                self.dfs(v)\\n                self.subsum[u]+=self.subsum[v]\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n=len(nums)\\n        self.adj=[list() for _ in range(n)]\\n        for u,v in edges:\\n            self.adj[u].append(v)\\n            self.adj[v].append(u)\\n        self.vis=[False]*n\\n        self.subsum=nums\\n        self.dfs(0)\\n        cnt=[0]*(max(self.subsum)+1)\\n        for s in self.subsum:\\n            cnt[s]+=1\\n        tot=self.subsum[0]\\n        for d in range(1,tot):\\n            if tot%d==0:\\n                c=0\\n                for i in range(d,tot,d):\\n                    c+=cnt[i]\\n                if (c+1)*d==tot:\\n                    return c\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int u,vector<int> &subsum,const vector<vector<int>> &adj,vector<bool> &vis){\\n        vis[u]=true;\\n        for(int v:adj[u])\\n            if(!vis[v]){\\n                dfs(v,subsum,adj,vis);\\n                subsum[u]+=subsum[v];\\n            }\\n    }\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n=nums.size();\\n        vector<vector<int>> adj(n);\\n        for(auto &e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<bool> vis(n);\\n        dfs(0,nums,adj,vis);\\n        int tot=nums[0];\\n        vector<int> cnt(tot+1);\\n        for(int x:nums)\\n            cnt[x]++;\\n        for(int d=1;d<tot;d++)\\n            if(tot%d==0){\\n                int c=0;\\n                for(int i=d;i<tot;i+=d)\\n                    c+=cnt[i];\\n                if((c+1)*d==tot)\\n                    return c;\\n            }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def dfs(self, u):\\n        self.vis[u]=True\\n        for v in self.adj[u]:\\n            if not self.vis[v]:\\n                self.dfs(v)\\n                self.subsum[u]+=self.subsum[v]\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n=len(nums)\\n        self.adj=[list() for _ in range(n)]\\n        for u,v in edges:\\n            self.adj[u].append(v)\\n            self.adj[v].append(u)\\n        self.vis=[False]*n\\n        self.subsum=nums\\n        self.dfs(0)\\n        cnt=[0]*(max(self.subsum)+1)\\n        for s in self.subsum:\\n            cnt[s]+=1\\n        tot=self.subsum[0]\\n        for d in range(1,tot):\\n            if tot%d==0:\\n                c=0\\n                for i in range(d,tot,d):\\n                    c+=cnt[i]\\n                if (c+1)*d==tot:\\n                    return c\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706644,
                "title": "c-dsu-factorization-o-n-root-sum",
                "content": "`Hint: sum of all node values = (no. of component) * (value of component)`\\nThe problem is divided into two steps:\\n1. find the value of component (say **target**). we will check for possible values.\\n1. check if there are possible partitions with the target value, if yes find no. of Max component. Max edges removed = (max no. of component -1)\\n\\n* To find the value of component, we will use the Factorization method and check for all of those values.\\n* To check the no. of max partition, I have used DSU. Now a question arrises, what is the criteria for the union of nodes and check the **Value of a component**? To do this, first find all node with degree 1 and push into the queue. Now union all these node with its direct parent. But before this, first check that if the value of component is equal to the **target** value. if it is, then insert its parent to a *set* ( which will mark this compenent as lock ). Also, avoid the union operation with any of the nodes whose component is locked.\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int find(vector<int>& nums,int i){\\n        if(nums[i]==-1) return i;\\n        else return nums[i] = find(nums,nums[i]);\\n    }\\n    void union_(vector<int>& nums,vector<int>& sum,int x,int y){\\n        int i = find(nums,x), j = find(nums,y);\\n        if(i==j) return;\\n        if(i<j) {nums[j] = i; sum[i]+=sum[j];}\\n        else {nums[i] = j; sum[j]+=sum[i];}\\n    }\\n    int dfs(vector<int>& val,vector<int> deg,vector<vector<int>>& nums,int target){\\n        queue<int> q;\\n        vector<int> dp(n+1,-1), sum(n+1,-1);\\n        for(int i = 0; i<n;++i) {\\n            sum[i] = val[i];\\n            if(deg[i]==1){\\n                q.push(i); deg[i] = 0;\\n            }\\n        }\\n        unordered_set<int> st;\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                int in = q.front(); q.pop();\\n                int pt = find(dp,in); bool is = 1;\\n                if(sum[pt]==target){ \\n                    st.insert(find(dp,in)); is = 0;\\n                }\\n                if(sum[pt]>target) return 1;\\n                for(int i = 0; i<nums[in].size();++i){\\n                    int j = nums[in][i];\\n                    int p = find(dp,j);\\n                    if(deg[j] && st.find(p)==st.end()){\\n                        deg[j]--;\\n                        if(is) union_(dp,sum,in,j);\\n                        if(deg[j]==1) q.push(j);\\n                    }\\n                }\\n            }\\n        }\\n        int re = 0;\\n        for(int i = 0; i<n;++i){\\n            if(dp[i]==-1){\\n                if(sum[i]==target) re++;\\n                else return 1;\\n            }\\n        }\\n        return re;\\n    }\\n    int componentValue(vector<int>& val, vector<vector<int>>& edges) {\\n        n = val.size();\\n        vector<int> deg(n+1,0);\\n        vector<vector<int>> nums(n+1);\\n        for(int i = 0; i<edges.size();++i){\\n            deg[edges[i][0]]++; deg[edges[i][1]]++;\\n            nums[edges[i][0]].push_back(edges[i][1]);\\n            nums[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int sum = 0,re = 0;\\n        for(int i = 0; i<n;++i) sum+=val[i];\\n        for(int i = 1;i*i<=sum;++i){\\n            if(sum%i==0){\\n                re = max(re,dfs(val,deg,nums,i)-1);\\n                re = max(re,dfs(val,deg,nums,sum/i)-1);\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```\\n***Comment for any queries. Upvote if it helps***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int find(vector<int>& nums,int i){\\n        if(nums[i]==-1) return i;\\n        else return nums[i] = find(nums,nums[i]);\\n    }\\n    void union_(vector<int>& nums,vector<int>& sum,int x,int y){\\n        int i = find(nums,x), j = find(nums,y);\\n        if(i==j) return;\\n        if(i<j) {nums[j] = i; sum[i]+=sum[j];}\\n        else {nums[i] = j; sum[j]+=sum[i];}\\n    }\\n    int dfs(vector<int>& val,vector<int> deg,vector<vector<int>>& nums,int target){\\n        queue<int> q;\\n        vector<int> dp(n+1,-1), sum(n+1,-1);\\n        for(int i = 0; i<n;++i) {\\n            sum[i] = val[i];\\n            if(deg[i]==1){\\n                q.push(i); deg[i] = 0;\\n            }\\n        }\\n        unordered_set<int> st;\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                int in = q.front(); q.pop();\\n                int pt = find(dp,in); bool is = 1;\\n                if(sum[pt]==target){ \\n                    st.insert(find(dp,in)); is = 0;\\n                }\\n                if(sum[pt]>target) return 1;\\n                for(int i = 0; i<nums[in].size();++i){\\n                    int j = nums[in][i];\\n                    int p = find(dp,j);\\n                    if(deg[j] && st.find(p)==st.end()){\\n                        deg[j]--;\\n                        if(is) union_(dp,sum,in,j);\\n                        if(deg[j]==1) q.push(j);\\n                    }\\n                }\\n            }\\n        }\\n        int re = 0;\\n        for(int i = 0; i<n;++i){\\n            if(dp[i]==-1){\\n                if(sum[i]==target) re++;\\n                else return 1;\\n            }\\n        }\\n        return re;\\n    }\\n    int componentValue(vector<int>& val, vector<vector<int>>& edges) {\\n        n = val.size();\\n        vector<int> deg(n+1,0);\\n        vector<vector<int>> nums(n+1);\\n        for(int i = 0; i<edges.size();++i){\\n            deg[edges[i][0]]++; deg[edges[i][1]]++;\\n            nums[edges[i][0]].push_back(edges[i][1]);\\n            nums[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        int sum = 0,re = 0;\\n        for(int i = 0; i<n;++i) sum+=val[i];\\n        for(int i = 1;i*i<=sum;++i){\\n            if(sum%i==0){\\n                re = max(re,dfs(val,deg,nums,i)-1);\\n                re = max(re,dfs(val,deg,nums,sum/i)-1);\\n            }\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706399,
                "title": "python-factorization-dfs",
                "content": "Let `s = sum(nums)`.  Let `t` is the sum of a component, which is unknown right now.  But, because each component has the same sum, `s % t == 0` must hold.\\n\\nSo first, we find all the possible `t`s.  We can try from `1` to `ceil(sqrt(s))`, and we sort the `t`s from small to large.  Remember `t` can be larger than `sqrt(s)`.  For `s = i * j`, both `i` and `j` are candidates of `t`.\\n\\nAnd then, we try using each `t` as the component sum and see if that is feasible.  We use a DFS on the tree.  For each sub-tree, there are 3 situations:\\n1. `sum < t`, then we should not cut off this sub-tree.\\n2. `sum == t`, then we should cut off this sub-tree, and `+1` to the cut counter.\\n3. `sum > t`, then this `t` is infeasible.  Terminate and try next `t`.\\n\\nIf `t` is feasible, then we can return the cut counter.  No need to try the larger `t`s.\\n\\nThe amount of `t`s is in `O(sqrt(N))`, and DFS costs `O(N)`.  Overall is `O(N*sqrt(N))`.\\n\\n```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        if n <= 1: return 0\\n        s = sum(nums)\\n        m = max(nums)\\n        \\n        f = set()\\n        for i in range(1, ceil(sqrt(s))):\\n            if s % i == 0:\\n                if i >= m:\\n                    f.add(i)\\n                j = s // i\\n                if j >= m:\\n                    f.add(j)\\n        f = sorted(f)\\n        \\n        g = [[] for _ in range(n)]\\n        for a, b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n            \\n        c = 0\\n        t = 0\\n        def rec(p, pp):\\n            nonlocal c\\n            r = nums[p]\\n            for q in g[p]:\\n                if q == pp: continue\\n                r += rec(q, p)\\n            if r == t:\\n                c += 1\\n                return 0\\n            elif r > t:\\n                raise Exception(\"\")\\n            else:\\n                return r\\n        for t in f:\\n            try:\\n                c = 0\\n                rec(0, -1)\\n                return c-1\\n            except:\\n                pass\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        n = len(nums)\\n        if n <= 1: return 0\\n        s = sum(nums)\\n        m = max(nums)\\n        \\n        f = set()\\n        for i in range(1, ceil(sqrt(s))):\\n            if s % i == 0:\\n                if i >= m:\\n                    f.add(i)\\n                j = s // i\\n                if j >= m:\\n                    f.add(j)\\n        f = sorted(f)\\n        \\n        g = [[] for _ in range(n)]\\n        for a, b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n            \\n        c = 0\\n        t = 0\\n        def rec(p, pp):\\n            nonlocal c\\n            r = nums[p]\\n            for q in g[p]:\\n                if q == pp: continue\\n                r += rec(q, p)\\n            if r == t:\\n                c += 1\\n                return 0\\n            elif r > t:\\n                raise Exception(\"\")\\n            else:\\n                return r\\n        for t in f:\\n            try:\\n                c = 0\\n                rec(0, -1)\\n                return c-1\\n            except:\\n                pass\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015071,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool check(vector<int>&nums,vector<vector<int>>&adj,int target)\\n   {\\n       int n=nums.size();\\n       vector<int>temp(n,0);\\n       if (traverse(0,nums,adj,target,temp)==0) return true;\\n       return false;\\n   }\\n   \\n   int traverse(int node,vector<int>&nums,vector<vector<int>>&adj,int target,vector<int>&temp)\\n   {\\n       temp[node]=nums[node];\\n       for (auto it:adj[node])\\n       {\\n           if (temp[it]) continue;\\n           temp[node]+=traverse(it,nums,adj,target,temp);\\n           if (temp[node]>target) return 1e5;\\n       }\\n       if (temp[node]==target) return 0;\\n       return temp[node];\\n   }\\n\\n\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) \\n    {\\n        int n=nums.size();\\n        vector<vector<int>>adj(n);\\n        for (auto it:edges)\\n        {\\n           adj[it[0]].push_back(it[1]);\\n           adj[it[1]].push_back(it[0]);\\n        }\\n        int sum=0;\\n        for (auto it:nums) sum+=it;\\n        for (int i=n;i>1;i--)\\n        {\\n           if (sum%i) continue;\\n           if (check(nums,adj,sum/i)) return i-1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool check(vector<int>&nums,vector<vector<int>>&adj,int target)\\n   {\\n       int n=nums.size();\\n       vector<int>temp(n,0);\\n       if (traverse(0,nums,adj,target,temp)==0) return true;\\n       return false;\\n   }\\n   \\n   int traverse(int node,vector<int>&nums,vector<vector<int>>&adj,int target,vector<int>&temp)\\n   {\\n       temp[node]=nums[node];\\n       for (auto it:adj[node])\\n       {\\n           if (temp[it]) continue;\\n           temp[node]+=traverse(it,nums,adj,target,temp);\\n           if (temp[node]>target) return 1e5;\\n       }\\n       if (temp[node]==target) return 0;\\n       return temp[node];\\n   }\\n\\n\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) \\n    {\\n        int n=nums.size();\\n        vector<vector<int>>adj(n);\\n        for (auto it:edges)\\n        {\\n           adj[it[0]].push_back(it[1]);\\n           adj[it[1]].push_back(it[0]);\\n        }\\n        int sum=0;\\n        for (auto it:nums) sum+=it;\\n        for (int i=n;i>1;i--)\\n        {\\n           if (sum%i) continue;\\n           if (check(nums,adj,sum/i)) return i-1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841794,
                "title": "detailed-easy-2-dfs-solution-complete-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSuppose we are able to divide the tree into $$k$$ components each having value $$x$$ then, $$k*x = total\\\\; sum\\\\; of\\\\; value\\\\; of\\\\; each\\\\; node$$. Since $$k$$ is an integer, $$x$$ must be a factor of $$total\\\\; sum$$. We calculate the $$total\\\\; sum$$ and try to find if each of it\\'s factor can be the value of each component. If the value of each component is $$x$$ then number of components is $$ k = (total\\\\; sum)/ x$$. To form  $$k$$ components we need to remove $$k-1$$ edges.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`subtree[x] stores the sum of the tree rooted at x. sub() function calculates subtree[] array first`.\\nIn the `dfs()` function :\\n- *adj* is the adjacency list.\\n- *req* is required value of each component.\\n- *k* is number of components to be formed.\\n- *par* is parent node to avoid infinite recursion.\\n- *nums* is the value array.\\n\\nIf I am at an edge `x -- y` and `subtree[y]% req == 0 and subtree[y]/req == k-1` then I can remove this edge `(k-1 is remaining number of components)`. It means after removing the edge `x -- y` , we can still form `k-1` components with the tree rooted at `y`.If only 1 component is remaining we return true. We do this over all factors of `total sum` and take the max.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\;\\\\;\\\\;\\\\;\\\\;\\\\;\\\\;O(n * sqrt(sum) )$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\;\\\\;\\\\;\\\\;\\\\;\\\\;\\\\;O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> adj[20005];\\n    int subtree[20005];\\n    int sub(int x, int par, vector<int> &nums){\\n        int sum = nums[x];\\n        for(auto y: adj[x]){\\n            if(y!=par){\\n                sum+=sub(y,x,nums);\\n            }\\n        }\\n        return subtree[x] = sum;\\n    }\\n    bool dfs(int x , int par , int &k, int req, vector<int> & nums){\\n       \\n        if(k==1){\\n            return true;\\n        }\\n        for(auto y: adj[x]){\\n            if(y==par) continue;\\n             if(subtree[y]%req==0&&subtree[y]/req==k-1){\\n                k--;\\n            }\\n            if(dfs(y,x,k,req,nums)) {\\n                return true;\\n            }\\n        }\\n  \\n        return false;\\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        for(auto v:edges){\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        cout<<nums.size()<<endl;\\n        sub(0,-1,nums);\\n        int tot = 0;\\n        unordered_set<int> s;\\n        for(auto x:nums){\\n            tot+=x;\\n            s.insert(x);\\n        }\\n/* if each node has the same value we can delete all n-1 edges dfs*/\\n        if(s.size()==1) return nums.size()-1;\\n\\n        int ans=1;\\n        for(int i =1 ;i*i<=tot;i++){\\n            if(tot%i==0){\\n                int k= tot/i;\\n                if(dfs(0,-1,k,i,nums)){\\n                    ans = max(ans,tot/i);\\n                }\\n                k = i;\\n                if(dfs(0,-1,k,tot/i,nums)){\\n                    ans = max(ans,i);\\n                }\\n            }\\n        }\\n        return ans-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[20005];\\n    int subtree[20005];\\n    int sub(int x, int par, vector<int> &nums){\\n        int sum = nums[x];\\n        for(auto y: adj[x]){\\n            if(y!=par){\\n                sum+=sub(y,x,nums);\\n            }\\n        }\\n        return subtree[x] = sum;\\n    }\\n    bool dfs(int x , int par , int &k, int req, vector<int> & nums){\\n       \\n        if(k==1){\\n            return true;\\n        }\\n        for(auto y: adj[x]){\\n            if(y==par) continue;\\n             if(subtree[y]%req==0&&subtree[y]/req==k-1){\\n                k--;\\n            }\\n            if(dfs(y,x,k,req,nums)) {\\n                return true;\\n            }\\n        }\\n  \\n        return false;\\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        for(auto v:edges){\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        cout<<nums.size()<<endl;\\n        sub(0,-1,nums);\\n        int tot = 0;\\n        unordered_set<int> s;\\n        for(auto x:nums){\\n            tot+=x;\\n            s.insert(x);\\n        }\\n/* if each node has the same value we can delete all n-1 edges dfs*/\\n        if(s.size()==1) return nums.size()-1;\\n\\n        int ans=1;\\n        for(int i =1 ;i*i<=tot;i++){\\n            if(tot%i==0){\\n                int k= tot/i;\\n                if(dfs(0,-1,k,i,nums)){\\n                    ans = max(ans,tot/i);\\n                }\\n                k = i;\\n                if(dfs(0,-1,k,tot/i,nums)){\\n                    ans = max(ans,i);\\n                }\\n            }\\n        }\\n        return ans-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3795405,
                "title": "very-simple-and-straightforward-dfs-solution",
                "content": "# Intuition\\nFirst think if the nums is not there then how you approach\\n\\n# Approach\\nstep1 -> Find the all the divisors of sum(nums[i])\\nstep -> check for each divisor wheather can we split into sum/divisor or not If yes the update ans as max(ans,divisor-1);\\n\\n# Complexity\\n- Time complexity:\\nO(Number of node*no of divisor of sum(nums[i])+ sum(nums[i]))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nbool flag;        // yes can split\\nint dfs(int curr,vector <vector<int>> &adj,int par,int k,vector <int> &cost)\\n{\\n    int ans = cost[curr];\\n    for(auto &x:adj[curr])\\n    {\\n        if(par!=x)\\n        ans+=dfs(x,adj,curr,k,cost);\\n    }\\n    if(ans>k)\\n    {\\n        flag = false;\\n        return 0;\\n    }\\n    else if(ans==k)\\n        ans=0;\\n    return ans;\\n}\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        vector <vector<int>> adj(n);\\n        for(auto &x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int sum = 0;\\n        int maxEdgeCanRemove = 0;\\n        for(auto &x:nums) sum+=x;\\n        for(int i=1;i<=sum;i++)\\n        {\\n            if(sum%i==0)\\n            {\\n                flag = true;\\n                dfs(0,adj,-1,sum/i,nums);\\n                if(flag)\\n                maxEdgeCanRemove = max(maxEdgeCanRemove,i-1);\\n            }\\n        }\\n        return maxEdgeCanRemove;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nbool flag;        // yes can split\\nint dfs(int curr,vector <vector<int>> &adj,int par,int k,vector <int> &cost)\\n{\\n    int ans = cost[curr];\\n    for(auto &x:adj[curr])\\n    {\\n        if(par!=x)\\n        ans+=dfs(x,adj,curr,k,cost);\\n    }\\n    if(ans>k)\\n    {\\n        flag = false;\\n        return 0;\\n    }\\n    else if(ans==k)\\n        ans=0;\\n    return ans;\\n}\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        vector <vector<int>> adj(n);\\n        for(auto &x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int sum = 0;\\n        int maxEdgeCanRemove = 0;\\n        for(auto &x:nums) sum+=x;\\n        for(int i=1;i<=sum;i++)\\n        {\\n            if(sum%i==0)\\n            {\\n                flag = true;\\n                dfs(0,adj,-1,sum/i,nums);\\n                if(flag)\\n                maxEdgeCanRemove = max(maxEdgeCanRemove,i-1);\\n            }\\n        }\\n        return maxEdgeCanRemove;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657223,
                "title": "c-dfs-easiest-and-simplest-solution",
                "content": "\\n# Approach\\nIdea is to keep the sum of subtree of each node, and store them in an array, say `s`. Now for all the factors `fac` of `A` (`A` is the sum of values of all the nodes.), check if there are exactly ` A / fac ` elemens in s that are divisible by `fac`.\\n\\n# Complexity\\n- Time complexity: O(n log(A))\\nA is the sum of values of all the nodes.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(int node, vector<int> &s, vector<int> &nums, vector<vector<int>> &mp, vector<int> &vis)\\n    {\\n        vis[node] = 1;\\n        for(auto x: mp[node])\\n            if(vis[x]==0)\\n                s[node]+=dfs(x, s, nums, mp, vis);\\n        s[node]+=nums[node];\\n        return s[node];\\n    }\\n\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<vector<int>> mp(nums.size());\\n        for(auto x: edges){\\n            mp[x[0]].push_back(x[1]);\\n            mp[x[1]].push_back(x[0]);\\n        }\\n        int sum = 0;\\n        vector<int> s(nums.size(), 0), vis(nums.size(), 0);\\n        sum = dfs(0, s, nums, mp, vis);\\n        for(int i=1; i<sum; i++)\\n        {\\n            if(sum%i!=0)\\n            {\\n                int div=0;\\n                for(auto x: s)\\n                    if(x%i==0)\\n                        x++;\\n                if(x==sum/i)\\n                    return sum/i-1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(int node, vector<int> &s, vector<int> &nums, vector<vector<int>> &mp, vector<int> &vis)\\n    {\\n        vis[node] = 1;\\n        for(auto x: mp[node])\\n            if(vis[x]==0)\\n                s[node]+=dfs(x, s, nums, mp, vis);\\n        s[node]+=nums[node];\\n        return s[node];\\n    }\\n\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<vector<int>> mp(nums.size());\\n        for(auto x: edges){\\n            mp[x[0]].push_back(x[1]);\\n            mp[x[1]].push_back(x[0]);\\n        }\\n        int sum = 0;\\n        vector<int> s(nums.size(), 0), vis(nums.size(), 0);\\n        sum = dfs(0, s, nums, mp, vis);\\n        for(int i=1; i<sum; i++)\\n        {\\n            if(sum%i!=0)\\n            {\\n                int div=0;\\n                for(auto x: s)\\n                    if(x%i==0)\\n                        x++;\\n                if(x==sum/i)\\n                    return sum/i-1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441779,
                "title": "python-factorization-dfs",
                "content": "Time Complexity - O(sqrt(sum)*n)\\n```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        ssum=sum(nums)\\n        n=len(nums)\\n        facs=set()\\n        for i in range(1,int(sqrt(ssum))+1):\\n            if ssum%i==0: \\n                facs.add(ssum//i)\\n                facs.add(i)\\n        graph=defaultdict(list)\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        def dfs(node,par,gg):\\n            nonlocal cnt\\n            val=nums[node]\\n            for nei in graph[node]:\\n                if nei==par: continue\\n                val+=dfs(nei,node,gg)\\n            if val==gg:\\n                cnt+=1\\n                val=0\\n            return val\\n        for f in sorted(list(facs),reverse=True):\\n            cnt=0\\n            dfs(0,-1,ssum//f)\\n            if cnt==f:\\n                return f-1\\n        return 0\\n                    \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        ssum=sum(nums)\\n        n=len(nums)\\n        facs=set()\\n        for i in range(1,int(sqrt(ssum))+1):\\n            if ssum%i==0: \\n                facs.add(ssum//i)\\n                facs.add(i)\\n        graph=defaultdict(list)\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        def dfs(node,par,gg):\\n            nonlocal cnt\\n            val=nums[node]\\n            for nei in graph[node]:\\n                if nei==par: continue\\n                val+=dfs(nei,node,gg)\\n            if val==gg:\\n                cnt+=1\\n                val=0\\n            return val\\n        for f in sorted(list(facs),reverse=True):\\n            cnt=0\\n            dfs(0,-1,ssum//f)\\n            if cnt==f:\\n                return f-1\\n        return 0\\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384411,
                "title": "javascript-beats-100",
                "content": "# Code\\n```\\nvar componentValue = function(nums, edges) {\\n    var dfs = function(nums, g, cur, parent, target) {\\n        var curSum = nums[cur];\\n        for (var i = 0; i < g[cur].length; i++) {\\n            var nbr = g[cur][i];\\n            if (nbr === parent) continue;\\n            curSum += dfs(nums, g, nbr, cur, target);\\n        }\\n        \\n        if (curSum === target) {\\n            return 0;\\n        } else {\\n            return curSum;\\n        }\\n    };\\n    \\n    var n = nums.length;\\n    var g = new Array(n);\\n    for (var i = 0; i < n; i++) {\\n        g[i] = [];\\n    }\\n    \\n    for (var i = 0; i < edges.length; i++) {\\n        var e = edges[i];\\n        g[e[0]].push(e[1]);\\n        g[e[1]].push(e[0]);\\n    }\\n    \\n    var sum = 0;\\n    for (var i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n    }\\n    \\n    var st = {};\\n    for (var i = 0; i < nums.length; i++) {\\n        st[nums[i]] = true;\\n    }\\n    var numDistinctValues = Object.keys(st).length;\\n    \\n    if (numDistinctValues === 1) {\\n        return n - 1;\\n    }\\n    \\n    for (var i = n - 1; i >= 2; i--) {\\n        if (sum % i !== 0) continue;\\n        \\n        var ans = dfs(nums, g, 0, -1, sum / i);\\n        \\n        if (ans === 0) return i - 1;\\n    }\\n    \\n    return 0;\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar componentValue = function(nums, edges) {\\n    var dfs = function(nums, g, cur, parent, target) {\\n        var curSum = nums[cur];\\n        for (var i = 0; i < g[cur].length; i++) {\\n            var nbr = g[cur][i];\\n            if (nbr === parent) continue;\\n            curSum += dfs(nums, g, nbr, cur, target);\\n        }\\n        \\n        if (curSum === target) {\\n            return 0;\\n        } else {\\n            return curSum;\\n        }\\n    };\\n    \\n    var n = nums.length;\\n    var g = new Array(n);\\n    for (var i = 0; i < n; i++) {\\n        g[i] = [];\\n    }\\n    \\n    for (var i = 0; i < edges.length; i++) {\\n        var e = edges[i];\\n        g[e[0]].push(e[1]);\\n        g[e[1]].push(e[0]);\\n    }\\n    \\n    var sum = 0;\\n    for (var i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n    }\\n    \\n    var st = {};\\n    for (var i = 0; i < nums.length; i++) {\\n        st[nums[i]] = true;\\n    }\\n    var numDistinctValues = Object.keys(st).length;\\n    \\n    if (numDistinctValues === 1) {\\n        return n - 1;\\n    }\\n    \\n    for (var i = n - 1; i >= 2; i--) {\\n        if (sum % i !== 0) continue;\\n        \\n        var ans = dfs(nums, g, 0, -1, sum / i);\\n        \\n        if (ans === 0) return i - 1;\\n    }\\n    \\n    return 0;\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3342875,
                "title": "c-dfs-faster-than-70",
                "content": "```\\nclass Solution {\\npublic:\\n    int b,sum;\\n    vector<int> F;\\n    void dfs(int x,int limit,vector<int>& nums,vector<vector<int>>& A,vector<int>& kt,vector<int>& value)\\n    {\\n        kt[x]=1;\\n        value[x]=nums[x];\\n        for(int i=0;i<=A[x].size()-1;i++)\\n        {\\n            if(kt[A[x][i]]==0)\\n            {\\n                dfs(A[x][i],limit,nums,A,kt,value);\\n                if(b==1) return;\\n                value[x]=value[x]+value[A[x][i]];\\n            }\\n        }\\n        if(value[x]>limit) b=1;\\n        else if(value[x]==limit) value[x]=0;\\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        if(edges.empty()!=0) return 0;\\n        vector<int> kt,temp(nums.size(),0),value;\\n        vector<vector<int>> A(nums.size());\\n        for(int i=0;i<=edges.size()-1;i++)\\n        {\\n            A[edges[i][0]].push_back(edges[i][1]);\\n            A[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<=nums.size()-1;i++)\\n            sum=sum+nums[i];\\n        for(int i=1;i<=sum;i++)\\n            if(sum%i==0) F.push_back(i);\\n        for(int i=0;i<=F.size()-1;i++)\\n        {\\n            b=0;\\n            kt=temp;\\n            value=temp;\\n            dfs(0,F[i],nums,A,kt,value);\\n            if(b==0) return sum/F[i]-1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int b,sum;\\n    vector<int> F;\\n    void dfs(int x,int limit,vector<int>& nums,vector<vector<int>>& A,vector<int>& kt,vector<int>& value)\\n    {\\n        kt[x]=1;\\n        value[x]=nums[x];\\n        for(int i=0;i<=A[x].size()-1;i++)\\n        {\\n            if(kt[A[x][i]]==0)\\n            {\\n                dfs(A[x][i],limit,nums,A,kt,value);\\n                if(b==1) return;\\n                value[x]=value[x]+value[A[x][i]];\\n            }\\n        }\\n        if(value[x]>limit) b=1;\\n        else if(value[x]==limit) value[x]=0;\\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        if(edges.empty()!=0) return 0;\\n        vector<int> kt,temp(nums.size(),0),value;\\n        vector<vector<int>> A(nums.size());\\n        for(int i=0;i<=edges.size()-1;i++)\\n        {\\n            A[edges[i][0]].push_back(edges[i][1]);\\n            A[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<=nums.size()-1;i++)\\n            sum=sum+nums[i];\\n        for(int i=1;i<=sum;i++)\\n            if(sum%i==0) F.push_back(i);\\n        for(int i=0;i<=F.size()-1;i++)\\n        {\\n            b=0;\\n            kt=temp;\\n            value=temp;\\n            dfs(0,F[i],nums,A,kt,value);\\n            if(b==0) return sum/F[i]-1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282646,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    vector<vector<int>> g;\\n    \\n    int dfs(int ind,int parent,const int target)\\n    {\\n        int val = arr[ind];\\n        \\n        for(auto it : g[ind]){\\n            if(it == parent) continue;\\n            val += dfs(it,ind,target);\\n        }\\n        \\n        if(val == target) return 0;\\n        return val;\\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        g.clear(),arr.clear();\\n        int n = nums.size();\\n        g.resize(n),arr.resize(n);\\n        int sum = 0;\\n        \\n        for(auto i: edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        \\n        for(int j=0;j<n;j++){\\n            sum += nums[j];\\n            arr[j] = nums[j];\\n        }\\n        \\n        int result = 0;\\n        for(int parts = 1;parts <= n;parts++){\\n            if(sum%parts != 0) continue;\\n            if(dfs(0,-1,sum/parts) !=0) continue;\\n            \\n            result = max(result,parts-1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    vector<vector<int>> g;\\n    \\n    int dfs(int ind,int parent,const int target)\\n    {\\n        int val = arr[ind];\\n        \\n        for(auto it : g[ind]){\\n            if(it == parent) continue;\\n            val += dfs(it,ind,target);\\n        }\\n        \\n        if(val == target) return 0;\\n        return val;\\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        g.clear(),arr.clear();\\n        int n = nums.size();\\n        g.resize(n),arr.resize(n);\\n        int sum = 0;\\n        \\n        for(auto i: edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        \\n        for(int j=0;j<n;j++){\\n            sum += nums[j];\\n            arr[j] = nums[j];\\n        }\\n        \\n        int result = 0;\\n        for(int parts = 1;parts <= n;parts++){\\n            if(sum%parts != 0) continue;\\n            if(dfs(0,-1,sum/parts) !=0) continue;\\n            \\n            result = max(result,parts-1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159642,
                "title": "c-solution-dfs",
                "content": "# Optimized Approach\\n```\\nclass Solution {\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int sum=0;\\n        // sum of all values which are associated with every node\\n        for(auto num: nums) // TC: O(n)\\n         sum+=num;\\n         \\n       int n=nums.size();  // TC: O(n)\\n       vector<int>inEdge(n,0);  // SC, TC: O(n)\\n        vector<vector<int>>adjList(n,vector<int>()); // TC,SC: O(n)\\n        for(auto it: edges)\\n        {\\n            adjList[it[0]].push_back(it[1]);\\n            adjList[it[1]].push_back(it[0]);\\n            inEdge[it[0]]++;\\n            inEdge[it[1]]++;\\n        }\\n       \\n       // deciding the root of tree\\n        int root=0;\\n        // TC: O(n)\\n        for(int i=0;i<n;i++)\\n         if(inEdge[i]==1)\\n          {root=i;\\n           break;}\\n      \\n\\n      // making list of divisor of sum, so that we can find out that in what numbers of component can we divide the whole tree\\n       vector<int>divisor; // SC: O(sum)\\n       int i=1;\\n       while(i<=sum) // TC: O(sum)\\n       {\\n           if(sum%i==0)\\n            divisor.push_back(i);\\n            i++;\\n       }\\n\\n       \\n       // use dfs \\n     // TC: O(sum*(V+E))\\n     // SC: O(sum(V+E+n))\\n       for(auto it=divisor.rbegin();it!=divisor.rend();it++)\\n         {   int cnt=0;\\n         vector<int>visited(n,0);\\n    dfs(adjList,nums,root,sum/(*it),cnt,visited);\\n            // if number of component is equal to divisor\\n              if(cnt==*it)\\n              return *it-1; // no. of component = no. of deleted edge+1\\n           \\n         }\\n  \\n         return 0;\\n        \\n    }\\n  int dfs(vector<vector<int>>&adjList,vector<int>&nums,int node,int target,int &cnt,vector<int>&visited)\\n  {\\n      // mark as visited\\n      visited[node]=1;\\n       \\n      int load=0;\\n     // traverse over neighbors\\n     for(auto adjNode: adjList[node])\\n     {\\n      if(!visited[adjNode])\\n       load+=dfs(adjList,nums,adjNode,target,cnt,visited);   \\n     }\\n    load+=nums[node];\\n    if(load==target)\\n     {cnt++;\\n      load=0;}\\n     return load;\\n  }\\n};\\n```\\n\\n# Brute Force Approach\\n```\\nclass Solution {\\n    private:\\n    int ans=0;\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<int>consider(edges.size(),1);\\n         fun(nums,edges,0,consider);\\n         return ans;\\n    }\\n    void fun(vector<int>&nums, vector<vector<int>>&edges,int index,vector<int>&consider)\\n    {\\n        // cout<<\"index:\"<<index<<\"    ans:\"<<ans<<endl;\\n        ans=max(makeComp(nums,edges,consider),ans);\\n        //  cout<<endl;\\n        if(index==edges.size())\\n           return;\\n\\n        // let delete this\\n         // pre-calculation\\n         consider[index]=0;\\n         fun(nums,edges,index+1,consider);\\n         // post-calculation\\n         consider[index]=1;\\n        \\n        // not delete this\\n        fun(nums,edges,index+1,consider);\\n         \\n    }\\n    int find(vector<int>&dsuf,int v)\\n    {\\n        if(dsuf[v]<0)\\n         return v;\\n        return dsuf[v]=find(dsuf,dsuf[v]);\\n    }\\n    void Union(vector<int>&dsuf,int from ,int to)\\n    {\\n        from=find(dsuf,from);\\n        to=find(dsuf,to);\\n        if(from!=to)\\n        {\\n            if(dsuf[from]<dsuf[to])\\n            {\\n                dsuf[from]+=dsuf[to];\\n                dsuf[to]=from;\\n            }\\n            else\\n            {\\n                dsuf[to]+=dsuf[from];\\n                dsuf[from]=to;\\n            }\\n        }\\n    }\\n  int makeComp(vector<int>&nums, vector<vector<int>>&edges,vector<int>&consider)\\n    {  vector<int>dsuf(nums.size(),-1);\\n    int cnt=0;\\n        for(int i=0;i<consider.size();i++)\\n         {\\n             if(consider[i])\\n            {\\n                Union(dsuf,edges[i][0],edges[i][1]);\\n            }\\n            else\\n              cnt++;\\n         }\\n        //  for(int i=0;i<dsuf.size();i++)\\n        //   cout<<\"node:\"<<i<<\"   parent:\"<<dsuf[i]<<endl;\\n\\n         unordered_map<int,int>mp;\\n         for(int i=0;i<dsuf.size();i++)\\n         {\\n             if(dsuf[i]<0)\\n             {\\n                mp[i]+=nums[i];\\n             }\\n             else\\n             mp[dsuf[i]]+=nums[i];\\n         }\\n        unordered_set<int>st;\\n        for(auto p:mp)\\n        \\n             st.insert(p.second);\\n         \\n        if(st.size()==1)\\n        return cnt;\\n        return 0 ;\\n    }\\n};\\n\\n\\n\\nclass Solution {\\n    private:\\n    int ans=0;\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<int>consider(edges.size(),1);\\n         fun(nums,edges,0,consider);\\n         return ans;\\n    }\\n    void fun(vector<int>&nums, vector<vector<int>>&edges,int index,vector<int>&consider)\\n    {\\n        // cout<<\"index:\"<<index<<\"    ans:\"<<ans<<endl;\\n        ans=max(makeComp(nums,edges,consider),ans);\\n        //  cout<<endl;\\n        if(index==edges.size())\\n           return;\\n\\n        // let delete this\\n         // pre-calculation\\n         consider[index]=0;\\n         fun(nums,edges,index+1,consider);\\n         // post-calculation\\n         consider[index]=1;\\n        \\n        // not delete this\\n        fun(nums,edges,index+1,consider);\\n         \\n    }\\n    int find(vector<int>&dsuf,int v)\\n    {\\n        if(dsuf[v]<0)\\n         return v;\\n        return dsuf[v]=find(dsuf,dsuf[v]);\\n    }\\n    void Union(vector<int>&dsuf,int from ,int to)\\n    {\\n        from=find(dsuf,from);\\n        to=find(dsuf,to);\\n        if(from!=to)\\n        {\\n            if(dsuf[from]<dsuf[to])\\n            {\\n                dsuf[from]+=dsuf[to];\\n                dsuf[to]=from;\\n            }\\n            else\\n            {\\n                dsuf[to]+=dsuf[from];\\n                dsuf[from]=to;\\n            }\\n        }\\n    }\\n  int makeComp(vector<int>&nums, vector<vector<int>>&edges,vector<int>&consider)\\n    {  vector<int>dsuf(nums.size(),-1);\\n    int cnt=0;\\n        for(int i=0;i<consider.size();i++)\\n         {\\n             if(consider[i])\\n            {\\n                Union(dsuf,edges[i][0],edges[i][1]);\\n            }\\n            else\\n              cnt++;\\n         }\\n        //  for(int i=0;i<dsuf.size();i++)\\n        //   cout<<\"node:\"<<i<<\"   parent:\"<<dsuf[i]<<endl;\\n\\n         unordered_map<int,int>mp;\\n         for(int i=0;i<dsuf.size();i++)\\n         {\\n             if(dsuf[i]<0)\\n             {\\n                mp[i]+=nums[i];\\n             }\\n             else\\n             mp[dsuf[i]]+=nums[i];\\n         }\\n        unordered_set<int>st;\\n        for(auto p:mp)\\n        \\n             st.insert(p.second);\\n         \\n        if(st.size()==1)\\n        return cnt;\\n        return 0 ;\\n    }\\n};\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/b74f5a20-f513-4a1b-9a40-61df7bb1f245_1675849980.0767183.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int sum=0;\\n        // sum of all values which are associated with every node\\n        for(auto num: nums) // TC: O(n)\\n         sum+=num;\\n         \\n       int n=nums.size();  // TC: O(n)\\n       vector<int>inEdge(n,0);  // SC, TC: O(n)\\n        vector<vector<int>>adjList(n,vector<int>()); // TC,SC: O(n)\\n        for(auto it: edges)\\n        {\\n            adjList[it[0]].push_back(it[1]);\\n            adjList[it[1]].push_back(it[0]);\\n            inEdge[it[0]]++;\\n            inEdge[it[1]]++;\\n        }\\n       \\n       // deciding the root of tree\\n        int root=0;\\n        // TC: O(n)\\n        for(int i=0;i<n;i++)\\n         if(inEdge[i]==1)\\n          {root=i;\\n           break;}\\n      \\n\\n      // making list of divisor of sum, so that we can find out that in what numbers of component can we divide the whole tree\\n       vector<int>divisor; // SC: O(sum)\\n       int i=1;\\n       while(i<=sum) // TC: O(sum)\\n       {\\n           if(sum%i==0)\\n            divisor.push_back(i);\\n            i++;\\n       }\\n\\n       \\n       // use dfs \\n     // TC: O(sum*(V+E))\\n     // SC: O(sum(V+E+n))\\n       for(auto it=divisor.rbegin();it!=divisor.rend();it++)\\n         {   int cnt=0;\\n         vector<int>visited(n,0);\\n    dfs(adjList,nums,root,sum/(*it),cnt,visited);\\n            // if number of component is equal to divisor\\n              if(cnt==*it)\\n              return *it-1; // no. of component = no. of deleted edge+1\\n           \\n         }\\n  \\n         return 0;\\n        \\n    }\\n  int dfs(vector<vector<int>>&adjList,vector<int>&nums,int node,int target,int &cnt,vector<int>&visited)\\n  {\\n      // mark as visited\\n      visited[node]=1;\\n       \\n      int load=0;\\n     // traverse over neighbors\\n     for(auto adjNode: adjList[node])\\n     {\\n      if(!visited[adjNode])\\n       load+=dfs(adjList,nums,adjNode,target,cnt,visited);   \\n     }\\n    load+=nums[node];\\n    if(load==target)\\n     {cnt++;\\n      load=0;}\\n     return load;\\n  }\\n};\\n```\n```\\nclass Solution {\\n    private:\\n    int ans=0;\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<int>consider(edges.size(),1);\\n         fun(nums,edges,0,consider);\\n         return ans;\\n    }\\n    void fun(vector<int>&nums, vector<vector<int>>&edges,int index,vector<int>&consider)\\n    {\\n        // cout<<\"index:\"<<index<<\"    ans:\"<<ans<<endl;\\n        ans=max(makeComp(nums,edges,consider),ans);\\n        //  cout<<endl;\\n        if(index==edges.size())\\n           return;\\n\\n        // let delete this\\n         // pre-calculation\\n         consider[index]=0;\\n         fun(nums,edges,index+1,consider);\\n         // post-calculation\\n         consider[index]=1;\\n        \\n        // not delete this\\n        fun(nums,edges,index+1,consider);\\n         \\n    }\\n    int find(vector<int>&dsuf,int v)\\n    {\\n        if(dsuf[v]<0)\\n         return v;\\n        return dsuf[v]=find(dsuf,dsuf[v]);\\n    }\\n    void Union(vector<int>&dsuf,int from ,int to)\\n    {\\n        from=find(dsuf,from);\\n        to=find(dsuf,to);\\n        if(from!=to)\\n        {\\n            if(dsuf[from]<dsuf[to])\\n            {\\n                dsuf[from]+=dsuf[to];\\n                dsuf[to]=from;\\n            }\\n            else\\n            {\\n                dsuf[to]+=dsuf[from];\\n                dsuf[from]=to;\\n            }\\n        }\\n    }\\n  int makeComp(vector<int>&nums, vector<vector<int>>&edges,vector<int>&consider)\\n    {  vector<int>dsuf(nums.size(),-1);\\n    int cnt=0;\\n        for(int i=0;i<consider.size();i++)\\n         {\\n             if(consider[i])\\n            {\\n                Union(dsuf,edges[i][0],edges[i][1]);\\n            }\\n            else\\n              cnt++;\\n         }\\n        //  for(int i=0;i<dsuf.size();i++)\\n        //   cout<<\"node:\"<<i<<\"   parent:\"<<dsuf[i]<<endl;\\n\\n         unordered_map<int,int>mp;\\n         for(int i=0;i<dsuf.size();i++)\\n         {\\n             if(dsuf[i]<0)\\n             {\\n                mp[i]+=nums[i];\\n             }\\n             else\\n             mp[dsuf[i]]+=nums[i];\\n         }\\n        unordered_set<int>st;\\n        for(auto p:mp)\\n        \\n             st.insert(p.second);\\n         \\n        if(st.size()==1)\\n        return cnt;\\n        return 0 ;\\n    }\\n};\\n\\n\\n\\nclass Solution {\\n    private:\\n    int ans=0;\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<int>consider(edges.size(),1);\\n         fun(nums,edges,0,consider);\\n         return ans;\\n    }\\n    void fun(vector<int>&nums, vector<vector<int>>&edges,int index,vector<int>&consider)\\n    {\\n        // cout<<\"index:\"<<index<<\"    ans:\"<<ans<<endl;\\n        ans=max(makeComp(nums,edges,consider),ans);\\n        //  cout<<endl;\\n        if(index==edges.size())\\n           return;\\n\\n        // let delete this\\n         // pre-calculation\\n         consider[index]=0;\\n         fun(nums,edges,index+1,consider);\\n         // post-calculation\\n         consider[index]=1;\\n        \\n        // not delete this\\n        fun(nums,edges,index+1,consider);\\n         \\n    }\\n    int find(vector<int>&dsuf,int v)\\n    {\\n        if(dsuf[v]<0)\\n         return v;\\n        return dsuf[v]=find(dsuf,dsuf[v]);\\n    }\\n    void Union(vector<int>&dsuf,int from ,int to)\\n    {\\n        from=find(dsuf,from);\\n        to=find(dsuf,to);\\n        if(from!=to)\\n        {\\n            if(dsuf[from]<dsuf[to])\\n            {\\n                dsuf[from]+=dsuf[to];\\n                dsuf[to]=from;\\n            }\\n            else\\n            {\\n                dsuf[to]+=dsuf[from];\\n                dsuf[from]=to;\\n            }\\n        }\\n    }\\n  int makeComp(vector<int>&nums, vector<vector<int>>&edges,vector<int>&consider)\\n    {  vector<int>dsuf(nums.size(),-1);\\n    int cnt=0;\\n        for(int i=0;i<consider.size();i++)\\n         {\\n             if(consider[i])\\n            {\\n                Union(dsuf,edges[i][0],edges[i][1]);\\n            }\\n            else\\n              cnt++;\\n         }\\n        //  for(int i=0;i<dsuf.size();i++)\\n        //   cout<<\"node:\"<<i<<\"   parent:\"<<dsuf[i]<<endl;\\n\\n         unordered_map<int,int>mp;\\n         for(int i=0;i<dsuf.size();i++)\\n         {\\n             if(dsuf[i]<0)\\n             {\\n                mp[i]+=nums[i];\\n             }\\n             else\\n             mp[dsuf[i]]+=nums[i];\\n         }\\n        unordered_set<int>st;\\n        for(auto p:mp)\\n        \\n             st.insert(p.second);\\n         \\n        if(st.size()==1)\\n        return cnt;\\n        return 0 ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3159641,
                "title": "c-solution-dfs",
                "content": "# Optimized Approach\\n```\\nclass Solution {\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int sum=0;\\n        // sum of all values which are associated with every node\\n        for(auto num: nums) // TC: O(n)\\n         sum+=num;\\n         \\n       int n=nums.size();  // TC: O(n)\\n       vector<int>inEdge(n,0);  // SC, TC: O(n)\\n        vector<vector<int>>adjList(n,vector<int>()); // TC,SC: O(n)\\n        for(auto it: edges)\\n        {\\n            adjList[it[0]].push_back(it[1]);\\n            adjList[it[1]].push_back(it[0]);\\n            inEdge[it[0]]++;\\n            inEdge[it[1]]++;\\n        }\\n       \\n       // deciding the root of tree\\n        int root=0;\\n        // TC: O(n)\\n        for(int i=0;i<n;i++)\\n         if(inEdge[i]==1)\\n          {root=i;\\n           break;}\\n      \\n\\n      // making list of divisor of sum, so that we can find out that in what numbers of component can we divide the whole tree\\n       vector<int>divisor; // SC: O(sum)\\n       int i=1;\\n       while(i<=sum) // TC: O(sum)\\n       {\\n           if(sum%i==0)\\n            divisor.push_back(i);\\n            i++;\\n       }\\n\\n       \\n       // use dfs \\n     // TC: O(sum*(V+E))\\n     // SC: O(sum(V+E+n))\\n       for(auto it=divisor.rbegin();it!=divisor.rend();it++)\\n         {   int cnt=0;\\n         vector<int>visited(n,0);\\n    dfs(adjList,nums,root,sum/(*it),cnt,visited);\\n            // if number of component is equal to divisor\\n              if(cnt==*it)\\n              return *it-1; // no. of component = no. of deleted edge+1\\n           \\n         }\\n  \\n         return 0;\\n        \\n    }\\n  int dfs(vector<vector<int>>&adjList,vector<int>&nums,int node,int target,int &cnt,vector<int>&visited)\\n  {\\n      // mark as visited\\n      visited[node]=1;\\n       \\n      int load=0;\\n     // traverse over neighbors\\n     for(auto adjNode: adjList[node])\\n     {\\n      if(!visited[adjNode])\\n       load+=dfs(adjList,nums,adjNode,target,cnt,visited);   \\n     }\\n    load+=nums[node];\\n    if(load==target)\\n     {cnt++;\\n      load=0;}\\n     return load;\\n  }\\n};\\n```\\n\\n# Brute Force Approach\\n```\\nclass Solution {\\n    private:\\n    int ans=0;\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<int>consider(edges.size(),1);\\n         fun(nums,edges,0,consider);\\n         return ans;\\n    }\\n    void fun(vector<int>&nums, vector<vector<int>>&edges,int index,vector<int>&consider)\\n    {\\n        // cout<<\"index:\"<<index<<\"    ans:\"<<ans<<endl;\\n        ans=max(makeComp(nums,edges,consider),ans);\\n        //  cout<<endl;\\n        if(index==edges.size())\\n           return;\\n\\n        // let delete this\\n         // pre-calculation\\n         consider[index]=0;\\n         fun(nums,edges,index+1,consider);\\n         // post-calculation\\n         consider[index]=1;\\n        \\n        // not delete this\\n        fun(nums,edges,index+1,consider);\\n         \\n    }\\n    int find(vector<int>&dsuf,int v)\\n    {\\n        if(dsuf[v]<0)\\n         return v;\\n        return dsuf[v]=find(dsuf,dsuf[v]);\\n    }\\n    void Union(vector<int>&dsuf,int from ,int to)\\n    {\\n        from=find(dsuf,from);\\n        to=find(dsuf,to);\\n        if(from!=to)\\n        {\\n            if(dsuf[from]<dsuf[to])\\n            {\\n                dsuf[from]+=dsuf[to];\\n                dsuf[to]=from;\\n            }\\n            else\\n            {\\n                dsuf[to]+=dsuf[from];\\n                dsuf[from]=to;\\n            }\\n        }\\n    }\\n  int makeComp(vector<int>&nums, vector<vector<int>>&edges,vector<int>&consider)\\n    {  vector<int>dsuf(nums.size(),-1);\\n    int cnt=0;\\n        for(int i=0;i<consider.size();i++)\\n         {\\n             if(consider[i])\\n            {\\n                Union(dsuf,edges[i][0],edges[i][1]);\\n            }\\n            else\\n              cnt++;\\n         }\\n        //  for(int i=0;i<dsuf.size();i++)\\n        //   cout<<\"node:\"<<i<<\"   parent:\"<<dsuf[i]<<endl;\\n\\n         unordered_map<int,int>mp;\\n         for(int i=0;i<dsuf.size();i++)\\n         {\\n             if(dsuf[i]<0)\\n             {\\n                mp[i]+=nums[i];\\n             }\\n             else\\n             mp[dsuf[i]]+=nums[i];\\n         }\\n        unordered_set<int>st;\\n        for(auto p:mp)\\n        \\n             st.insert(p.second);\\n         \\n        if(st.size()==1)\\n        return cnt;\\n        return 0 ;\\n    }\\n};\\n\\n\\n\\nclass Solution {\\n    private:\\n    int ans=0;\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<int>consider(edges.size(),1);\\n         fun(nums,edges,0,consider);\\n         return ans;\\n    }\\n    void fun(vector<int>&nums, vector<vector<int>>&edges,int index,vector<int>&consider)\\n    {\\n        // cout<<\"index:\"<<index<<\"    ans:\"<<ans<<endl;\\n        ans=max(makeComp(nums,edges,consider),ans);\\n        //  cout<<endl;\\n        if(index==edges.size())\\n           return;\\n\\n        // let delete this\\n         // pre-calculation\\n         consider[index]=0;\\n         fun(nums,edges,index+1,consider);\\n         // post-calculation\\n         consider[index]=1;\\n        \\n        // not delete this\\n        fun(nums,edges,index+1,consider);\\n         \\n    }\\n    int find(vector<int>&dsuf,int v)\\n    {\\n        if(dsuf[v]<0)\\n         return v;\\n        return dsuf[v]=find(dsuf,dsuf[v]);\\n    }\\n    void Union(vector<int>&dsuf,int from ,int to)\\n    {\\n        from=find(dsuf,from);\\n        to=find(dsuf,to);\\n        if(from!=to)\\n        {\\n            if(dsuf[from]<dsuf[to])\\n            {\\n                dsuf[from]+=dsuf[to];\\n                dsuf[to]=from;\\n            }\\n            else\\n            {\\n                dsuf[to]+=dsuf[from];\\n                dsuf[from]=to;\\n            }\\n        }\\n    }\\n  int makeComp(vector<int>&nums, vector<vector<int>>&edges,vector<int>&consider)\\n    {  vector<int>dsuf(nums.size(),-1);\\n    int cnt=0;\\n        for(int i=0;i<consider.size();i++)\\n         {\\n             if(consider[i])\\n            {\\n                Union(dsuf,edges[i][0],edges[i][1]);\\n            }\\n            else\\n              cnt++;\\n         }\\n        //  for(int i=0;i<dsuf.size();i++)\\n        //   cout<<\"node:\"<<i<<\"   parent:\"<<dsuf[i]<<endl;\\n\\n         unordered_map<int,int>mp;\\n         for(int i=0;i<dsuf.size();i++)\\n         {\\n             if(dsuf[i]<0)\\n             {\\n                mp[i]+=nums[i];\\n             }\\n             else\\n             mp[dsuf[i]]+=nums[i];\\n         }\\n        unordered_set<int>st;\\n        for(auto p:mp)\\n        \\n             st.insert(p.second);\\n         \\n        if(st.size()==1)\\n        return cnt;\\n        return 0 ;\\n    }\\n};\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/b74f5a20-f513-4a1b-9a40-61df7bb1f245_1675849980.0767183.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int sum=0;\\n        // sum of all values which are associated with every node\\n        for(auto num: nums) // TC: O(n)\\n         sum+=num;\\n         \\n       int n=nums.size();  // TC: O(n)\\n       vector<int>inEdge(n,0);  // SC, TC: O(n)\\n        vector<vector<int>>adjList(n,vector<int>()); // TC,SC: O(n)\\n        for(auto it: edges)\\n        {\\n            adjList[it[0]].push_back(it[1]);\\n            adjList[it[1]].push_back(it[0]);\\n            inEdge[it[0]]++;\\n            inEdge[it[1]]++;\\n        }\\n       \\n       // deciding the root of tree\\n        int root=0;\\n        // TC: O(n)\\n        for(int i=0;i<n;i++)\\n         if(inEdge[i]==1)\\n          {root=i;\\n           break;}\\n      \\n\\n      // making list of divisor of sum, so that we can find out that in what numbers of component can we divide the whole tree\\n       vector<int>divisor; // SC: O(sum)\\n       int i=1;\\n       while(i<=sum) // TC: O(sum)\\n       {\\n           if(sum%i==0)\\n            divisor.push_back(i);\\n            i++;\\n       }\\n\\n       \\n       // use dfs \\n     // TC: O(sum*(V+E))\\n     // SC: O(sum(V+E+n))\\n       for(auto it=divisor.rbegin();it!=divisor.rend();it++)\\n         {   int cnt=0;\\n         vector<int>visited(n,0);\\n    dfs(adjList,nums,root,sum/(*it),cnt,visited);\\n            // if number of component is equal to divisor\\n              if(cnt==*it)\\n              return *it-1; // no. of component = no. of deleted edge+1\\n           \\n         }\\n  \\n         return 0;\\n        \\n    }\\n  int dfs(vector<vector<int>>&adjList,vector<int>&nums,int node,int target,int &cnt,vector<int>&visited)\\n  {\\n      // mark as visited\\n      visited[node]=1;\\n       \\n      int load=0;\\n     // traverse over neighbors\\n     for(auto adjNode: adjList[node])\\n     {\\n      if(!visited[adjNode])\\n       load+=dfs(adjList,nums,adjNode,target,cnt,visited);   \\n     }\\n    load+=nums[node];\\n    if(load==target)\\n     {cnt++;\\n      load=0;}\\n     return load;\\n  }\\n};\\n```\n```\\nclass Solution {\\n    private:\\n    int ans=0;\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<int>consider(edges.size(),1);\\n         fun(nums,edges,0,consider);\\n         return ans;\\n    }\\n    void fun(vector<int>&nums, vector<vector<int>>&edges,int index,vector<int>&consider)\\n    {\\n        // cout<<\"index:\"<<index<<\"    ans:\"<<ans<<endl;\\n        ans=max(makeComp(nums,edges,consider),ans);\\n        //  cout<<endl;\\n        if(index==edges.size())\\n           return;\\n\\n        // let delete this\\n         // pre-calculation\\n         consider[index]=0;\\n         fun(nums,edges,index+1,consider);\\n         // post-calculation\\n         consider[index]=1;\\n        \\n        // not delete this\\n        fun(nums,edges,index+1,consider);\\n         \\n    }\\n    int find(vector<int>&dsuf,int v)\\n    {\\n        if(dsuf[v]<0)\\n         return v;\\n        return dsuf[v]=find(dsuf,dsuf[v]);\\n    }\\n    void Union(vector<int>&dsuf,int from ,int to)\\n    {\\n        from=find(dsuf,from);\\n        to=find(dsuf,to);\\n        if(from!=to)\\n        {\\n            if(dsuf[from]<dsuf[to])\\n            {\\n                dsuf[from]+=dsuf[to];\\n                dsuf[to]=from;\\n            }\\n            else\\n            {\\n                dsuf[to]+=dsuf[from];\\n                dsuf[from]=to;\\n            }\\n        }\\n    }\\n  int makeComp(vector<int>&nums, vector<vector<int>>&edges,vector<int>&consider)\\n    {  vector<int>dsuf(nums.size(),-1);\\n    int cnt=0;\\n        for(int i=0;i<consider.size();i++)\\n         {\\n             if(consider[i])\\n            {\\n                Union(dsuf,edges[i][0],edges[i][1]);\\n            }\\n            else\\n              cnt++;\\n         }\\n        //  for(int i=0;i<dsuf.size();i++)\\n        //   cout<<\"node:\"<<i<<\"   parent:\"<<dsuf[i]<<endl;\\n\\n         unordered_map<int,int>mp;\\n         for(int i=0;i<dsuf.size();i++)\\n         {\\n             if(dsuf[i]<0)\\n             {\\n                mp[i]+=nums[i];\\n             }\\n             else\\n             mp[dsuf[i]]+=nums[i];\\n         }\\n        unordered_set<int>st;\\n        for(auto p:mp)\\n        \\n             st.insert(p.second);\\n         \\n        if(st.size()==1)\\n        return cnt;\\n        return 0 ;\\n    }\\n};\\n\\n\\n\\nclass Solution {\\n    private:\\n    int ans=0;\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<int>consider(edges.size(),1);\\n         fun(nums,edges,0,consider);\\n         return ans;\\n    }\\n    void fun(vector<int>&nums, vector<vector<int>>&edges,int index,vector<int>&consider)\\n    {\\n        // cout<<\"index:\"<<index<<\"    ans:\"<<ans<<endl;\\n        ans=max(makeComp(nums,edges,consider),ans);\\n        //  cout<<endl;\\n        if(index==edges.size())\\n           return;\\n\\n        // let delete this\\n         // pre-calculation\\n         consider[index]=0;\\n         fun(nums,edges,index+1,consider);\\n         // post-calculation\\n         consider[index]=1;\\n        \\n        // not delete this\\n        fun(nums,edges,index+1,consider);\\n         \\n    }\\n    int find(vector<int>&dsuf,int v)\\n    {\\n        if(dsuf[v]<0)\\n         return v;\\n        return dsuf[v]=find(dsuf,dsuf[v]);\\n    }\\n    void Union(vector<int>&dsuf,int from ,int to)\\n    {\\n        from=find(dsuf,from);\\n        to=find(dsuf,to);\\n        if(from!=to)\\n        {\\n            if(dsuf[from]<dsuf[to])\\n            {\\n                dsuf[from]+=dsuf[to];\\n                dsuf[to]=from;\\n            }\\n            else\\n            {\\n                dsuf[to]+=dsuf[from];\\n                dsuf[from]=to;\\n            }\\n        }\\n    }\\n  int makeComp(vector<int>&nums, vector<vector<int>>&edges,vector<int>&consider)\\n    {  vector<int>dsuf(nums.size(),-1);\\n    int cnt=0;\\n        for(int i=0;i<consider.size();i++)\\n         {\\n             if(consider[i])\\n            {\\n                Union(dsuf,edges[i][0],edges[i][1]);\\n            }\\n            else\\n              cnt++;\\n         }\\n        //  for(int i=0;i<dsuf.size();i++)\\n        //   cout<<\"node:\"<<i<<\"   parent:\"<<dsuf[i]<<endl;\\n\\n         unordered_map<int,int>mp;\\n         for(int i=0;i<dsuf.size();i++)\\n         {\\n             if(dsuf[i]<0)\\n             {\\n                mp[i]+=nums[i];\\n             }\\n             else\\n             mp[dsuf[i]]+=nums[i];\\n         }\\n        unordered_set<int>st;\\n        for(auto p:mp)\\n        \\n             st.insert(p.second);\\n         \\n        if(st.size()==1)\\n        return cnt;\\n        return 0 ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3061097,
                "title": "python-simple-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def componentValue(self, nums, edges):\\n        if not edges:\\n            return 0\\n\\n        dict1, result = collections.defaultdict(list), sum(nums)\\n\\n        for i,j in edges:\\n            dict1[i].append(j)\\n            dict1[j].append(i)\\n\\n        def dfs(a,b):\\n            total = nums[a]\\n\\n            for neighbor in dict1[a]:\\n                if neighbor != b:\\n                    total += dfs(neighbor,a)\\n\\n            return total if total != i else 0\\n\\n        for i in range(max(nums),result//min(nums)):\\n            if result%i == 0 and dfs(0,len(nums)-1) == 0:\\n                return result//i - 1\\n\\n        return 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def componentValue(self, nums, edges):\\n        if not edges:\\n            return 0\\n\\n        dict1, result = collections.defaultdict(list), sum(nums)\\n\\n        for i,j in edges:\\n            dict1[i].append(j)\\n            dict1[j].append(i)\\n\\n        def dfs(a,b):\\n            total = nums[a]\\n\\n            for neighbor in dict1[a]:\\n                if neighbor != b:\\n                    total += dfs(neighbor,a)\\n\\n            return total if total != i else 0\\n\\n        for i in range(max(nums),result//min(nums)):\\n            if result%i == 0 and dfs(0,len(nums)-1) == 0:\\n                return result//i - 1\\n\\n        return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937512,
                "title": "java-optimal-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int dfs(int src,ArrayList<ArrayList<Integer>> al,int[] nums,int sum,boolean[] vis){\\n        vis[src]=true;\\n        int curr = nums[src];\\n        for(Integer z : al.get(src)){\\n            if(!vis[z]){\\n                int s = dfs(z,al,nums,sum,vis);\\n                // if sum is not possible in some subtree\\n                // it\\'s a fail case we return from here\\n                if(s==-1)\\n                    return s;\\n                curr+=s;\\n            }\\n        }\\n        // if curr value is greater than sum\\n        // then we cannot create sum anymore, so return -1\\n        if(curr>sum)\\n            return -1;\\n        // is possible, we will do a split of component and\\n        // return 0 as sum of the subtree\\n        if(curr==sum)\\n            return 0;\\n        return curr;\\n    }\\n \\n    public int componentValue(int[] nums, int[][] edges) {\\n        int sum=0;\\n        ArrayList<ArrayList<Integer>> al=new ArrayList<>();\\n        for(int x : nums){\\n            sum+=x;\\n            al.add(new ArrayList<>());\\n        }\\n        for(int[] x : edges){\\n            al.get(x[0]).add(x[1]);\\n            al.get(x[1]).add(x[0]);\\n        }\\n        int ans=0;\\n        int sq=(int)Math.sqrt(sum);\\n        // Iterating over each divisor of the total sum\\n        // as we want a equal split of sum among all components\\n        for(int i=1;i<=sq;i++){\\n            if(sum%i==0){\\n                int z=sum/i;\\n                boolean vis[]=new boolean[nums.length];\\n                // Try to make sum as z, if possible\\n                // then we need to remove i-1 edges only\\n                // E.g : i=3, sum=18 : then you need sum as 18/3=6\\n                // for 3 components and 3 components could be made\\n                // by removing 2(i-1) edges.\\n                int op=dfs(0,al,nums,z,vis);\\n                if(op==0){\\n                    // Taking max of all the edge values\\n                    ans=Integer.max(ans,i-1);\\n                }\\n                if(sum%z==0){\\n                    Arrays.fill(vis,false);\\n                    // Similarly trying for other values\\n                    op=dfs(0,al,nums,i,vis);\\n                    if(op==0){\\n                        // Taking max of all the edge values\\n                        ans=Integer.max(ans,z-1);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int dfs(int src,ArrayList<ArrayList<Integer>> al,int[] nums,int sum,boolean[] vis){\\n        vis[src]=true;\\n        int curr = nums[src];\\n        for(Integer z : al.get(src)){\\n            if(!vis[z]){\\n                int s = dfs(z,al,nums,sum,vis);\\n                // if sum is not possible in some subtree\\n                // it\\'s a fail case we return from here\\n                if(s==-1)\\n                    return s;\\n                curr+=s;\\n            }\\n        }\\n        // if curr value is greater than sum\\n        // then we cannot create sum anymore, so return -1\\n        if(curr>sum)\\n            return -1;\\n        // is possible, we will do a split of component and\\n        // return 0 as sum of the subtree\\n        if(curr==sum)\\n            return 0;\\n        return curr;\\n    }\\n \\n    public int componentValue(int[] nums, int[][] edges) {\\n        int sum=0;\\n        ArrayList<ArrayList<Integer>> al=new ArrayList<>();\\n        for(int x : nums){\\n            sum+=x;\\n            al.add(new ArrayList<>());\\n        }\\n        for(int[] x : edges){\\n            al.get(x[0]).add(x[1]);\\n            al.get(x[1]).add(x[0]);\\n        }\\n        int ans=0;\\n        int sq=(int)Math.sqrt(sum);\\n        // Iterating over each divisor of the total sum\\n        // as we want a equal split of sum among all components\\n        for(int i=1;i<=sq;i++){\\n            if(sum%i==0){\\n                int z=sum/i;\\n                boolean vis[]=new boolean[nums.length];\\n                // Try to make sum as z, if possible\\n                // then we need to remove i-1 edges only\\n                // E.g : i=3, sum=18 : then you need sum as 18/3=6\\n                // for 3 components and 3 components could be made\\n                // by removing 2(i-1) edges.\\n                int op=dfs(0,al,nums,z,vis);\\n                if(op==0){\\n                    // Taking max of all the edge values\\n                    ans=Integer.max(ans,i-1);\\n                }\\n                if(sum%z==0){\\n                    Arrays.fill(vis,false);\\n                    // Similarly trying for other values\\n                    op=dfs(0,al,nums,i,vis);\\n                    if(op==0){\\n                        // Taking max of all the edge values\\n                        ans=Integer.max(ans,z-1);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897780,
                "title": "c-91-96-faster-90-17-less-space-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    ll dfs(ll curr,ll par,ll target,vector<int>&nums,vector<ll>adj[],ll &count){\\n        ll sum=nums[curr];\\n        for(auto &x:adj[curr]){\\n            if(x!=par){\\n                sum+=dfs(x,curr,target,nums,adj,count);\\n            }\\n        }\\n        if(sum==target){\\n            count--;\\n            return 0;\\n        }\\n        return sum;\\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        ll n=nums.size(),total=0;\\n        for(auto &x:nums){\\n            total+=x;\\n        }\\n        vector<ll>adj[n];\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        set<ll>ss;\\n        for(ll i=1;i*i<=total;i++){\\n            if(total%i==0){\\n                ss.insert(i);ss.insert(total/i);\\n            }\\n        }\\n        for(auto &x:ss){\\n            if(x==total){\\n                continue;\\n            }\\n            ll count=total/x;\\n            if(dfs(0,-1,x,nums,adj,count)==0 && count==0){\\n                return (total/x)-1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    ll dfs(ll curr,ll par,ll target,vector<int>&nums,vector<ll>adj[],ll &count){\\n        ll sum=nums[curr];\\n        for(auto &x:adj[curr]){\\n            if(x!=par){\\n                sum+=dfs(x,curr,target,nums,adj,count);\\n            }\\n        }\\n        if(sum==target){\\n            count--;\\n            return 0;\\n        }\\n        return sum;\\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        ll n=nums.size(),total=0;\\n        for(auto &x:nums){\\n            total+=x;\\n        }\\n        vector<ll>adj[n];\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        set<ll>ss;\\n        for(ll i=1;i*i<=total;i++){\\n            if(total%i==0){\\n                ss.insert(i);ss.insert(total/i);\\n            }\\n        }\\n        for(auto &x:ss){\\n            if(x==total){\\n                continue;\\n            }\\n            ll count=total/x;\\n            if(dfs(0,-1,x,nums,adj,count)==0 && count==0){\\n                return (total/x)-1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846328,
                "title": "python-dfs-factors-easy",
                "content": "Reply if you need any more clarification\\n```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        # Get All Factors\\n        factors = set()\\n        totalTreeSum = sum(nums)\\n        for factor in range(1,ceil(sqrt(totalTreeSum))):\\n            if totalTreeSum%factor == 0:\\n                factors.add(factor)\\n                factors.add(totalTreeSum//factor)\\n        maxNum = max(nums)\\n        \\n        graph = defaultdict(list)\\n        \\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        def dfs(u,Sum, vis):\\n            vis.add(u)\\n            NowSum = nums[u]\\n            for v in graph[u]:\\n                if v not in vis:\\n                    NowSum += dfs(v, Sum, vis)\\n            if NowSum == Sum:\\n                self.components-=1\\n                return 0\\n            elif NowSum < Sum:\\n                return NowSum\\n            return 0\\n            \\n            \\n        def isPossible(targetSum, components):\\n            self.components = components\\n            dfs(0,targetSum,set())\\n            return self.components == 0\\n            \\n        for factor in sorted(list(factors)):\\n            # Each component should be atleast maxNum to be made\\n            if factor < maxNum: continue\\n            numberOfComponentsPossible = totalTreeSum//factor\\n            if isPossible(factor,numberOfComponentsPossible):\\n                return numberOfComponentsPossible-1\\n        return 0\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        # Get All Factors\\n        factors = set()\\n        totalTreeSum = sum(nums)\\n        for factor in range(1,ceil(sqrt(totalTreeSum))):\\n            if totalTreeSum%factor == 0:\\n                factors.add(factor)\\n                factors.add(totalTreeSum//factor)\\n        maxNum = max(nums)\\n        \\n        graph = defaultdict(list)\\n        \\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        def dfs(u,Sum, vis):\\n            vis.add(u)\\n            NowSum = nums[u]\\n            for v in graph[u]:\\n                if v not in vis:\\n                    NowSum += dfs(v, Sum, vis)\\n            if NowSum == Sum:\\n                self.components-=1\\n                return 0\\n            elif NowSum < Sum:\\n                return NowSum\\n            return 0\\n            \\n            \\n        def isPossible(targetSum, components):\\n            self.components = components\\n            dfs(0,targetSum,set())\\n            return self.components == 0\\n            \\n        for factor in sorted(list(factors)):\\n            # Each component should be atleast maxNum to be made\\n            if factor < maxNum: continue\\n            numberOfComponentsPossible = totalTreeSum//factor\\n            if isPossible(factor,numberOfComponentsPossible):\\n                return numberOfComponentsPossible-1\\n        return 0\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829621,
                "title": "golang-bfs",
                "content": "- Golang implementation of https://leetcode.com/problems/create-components-with-same-value/discuss/2706736/Python-Explanation-with-pictures-BFS\\n```\\nfunc componentValue(nums []int, edges [][]int) int {\\n    maxNum, minNum, sumNums, n := 0, math.MaxInt32, 0, len(nums)\\n    for _, num := range nums {\\n        maxNum = max(maxNum, num)\\n        minNum = min(minNum, num)\\n        sumNums += num\\n    }\\n    G := make(map[int]map[int]struct{})\\n    degree := make([]int, n)\\n    for _, edge := range edges {\\n        a, b := edge[0], edge[1]\\n        degree[a]++\\n        degree[b]++\\n        if _, ok := G[a]; !ok {\\n            G[a] = make(map[int]struct{})\\n        }\\n        G[a][b] = struct{}{}\\n        if _, ok := G[b]; !ok {\\n            G[b] = make(map[int]struct{})\\n        }\\n        G[b][a] = struct{}{}\\n    }\\n    \\n    for i := minNum; i < sumNums; i++ {\\n        if sumNums % i == 0 && bfs(i, nums, degree, G) {\\n            return (sumNums / i) - 1\\n        }\\n    }\\n    return 0\\n}\\n\\nfunc bfs(target int, nums []int, degree []int, G map[int]map[int]struct{}) bool {\\n    V := make([]int, len(nums))\\n    copy(V, nums)\\n    deg := make([]int, len(degree))\\n    copy(deg, degree)\\n    \\n    q := make([]int, 0)\\n    for i, d := range degree {\\n        if d == 1 {\\n            q = append(q, i)\\n        }\\n    }\\n    \\n    for len(q) > 0 {\\n        i := q[0]\\n        q = q[1:]\\n        deg[i] = 0\\n        \\n        for nxt, _ := range G[i] {\\n            if V[i] != target {\\n                V[nxt] += V[i]\\n            }\\n            deg[nxt]--\\n            if deg[nxt] == 0 {\\n                return V[nxt] == target\\n            } else if deg[nxt] == 1 {\\n                q = append(q, nxt)\\n            }\\n        }\\n    }\\n    return false\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc componentValue(nums []int, edges [][]int) int {\\n    maxNum, minNum, sumNums, n := 0, math.MaxInt32, 0, len(nums)\\n    for _, num := range nums {\\n        maxNum = max(maxNum, num)\\n        minNum = min(minNum, num)\\n        sumNums += num\\n    }\\n    G := make(map[int]map[int]struct{})\\n    degree := make([]int, n)\\n    for _, edge := range edges {\\n        a, b := edge[0], edge[1]\\n        degree[a]++\\n        degree[b]++\\n        if _, ok := G[a]; !ok {\\n            G[a] = make(map[int]struct{})\\n        }\\n        G[a][b] = struct{}{}\\n        if _, ok := G[b]; !ok {\\n            G[b] = make(map[int]struct{})\\n        }\\n        G[b][a] = struct{}{}\\n    }\\n    \\n    for i := minNum; i < sumNums; i++ {\\n        if sumNums % i == 0 && bfs(i, nums, degree, G) {\\n            return (sumNums / i) - 1\\n        }\\n    }\\n    return 0\\n}\\n\\nfunc bfs(target int, nums []int, degree []int, G map[int]map[int]struct{}) bool {\\n    V := make([]int, len(nums))\\n    copy(V, nums)\\n    deg := make([]int, len(degree))\\n    copy(deg, degree)\\n    \\n    q := make([]int, 0)\\n    for i, d := range degree {\\n        if d == 1 {\\n            q = append(q, i)\\n        }\\n    }\\n    \\n    for len(q) > 0 {\\n        i := q[0]\\n        q = q[1:]\\n        deg[i] = 0\\n        \\n        for nxt, _ := range G[i] {\\n            if V[i] != target {\\n                V[nxt] += V[i]\\n            }\\n            deg[nxt]--\\n            if deg[nxt] == 0 {\\n                return V[nxt] == target\\n            } else if deg[nxt] == 1 {\\n                q = append(q, nxt)\\n            }\\n        }\\n    }\\n    return false\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2802576,
                "title": "c-solution-faster-than-40-submissions",
                "content": "Question : Find the max number of edges that you can delete, such that all sub-components have the same sum.\\n\\nIdea : \\nFirst, calculate the sum of all nodes as S. To split them into n components, S % n must be 0 (primary school maths).\\n\\nThen, you can inspect the tree. Each node must belongs to any sub-component.\\n\\nThe value of all sub-component is (S / n).\\n\\nSo, if the current node\\'s value is already (S / n), it is a sub-component itself. So, remove all the edges between this and the child / children, and if any child\\'s sum != (S / n), it is invalid. Why? Because the current node can\\'t take in more values.\\n\\nIf the current node\\'s value is < (S / n), then check the children. For all the children with sub-sum < (S / n), group them together. Since it is a tree, those children can only connect to this parent node.\\n\\nRecall that all nodes must belongs to any sub-component. Therefore, those children with sub-sum < (S / n) can only be grouped with the current parent.\\n\\n*Imagine that if you left out any child (-_-) with sub-sum < S / n, that child cannot be connected to any other nodes (T_T) (poor child). Since that child cannot be a sub-component, it is invalid.*\\n\\nSo, that\\'s the entire idea (-_-;)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxn;\\n    int sumn;\\n    int pat_val, pat_size;\\n    const static int MAX = 20010;\\n    bool mk[MAX];\\n    int edges_del;\\n    int max_edges_del;\\n    bool flag;\\n    std::map<int, vector<int>> T;\\n    void T_init_insert(int a, int b) {\\n        if (T.find(a) == T.end()) {\\n            T[a] = { b };\\n        }\\n        else {\\n            T[a].push_back(b);\\n        }\\n    }\\n    int T_ck(vector<int>& nums, int cur_n) {\\n        if (!flag)\\n            return -1;\\n        if (nums[cur_n] > pat_val) {\\n            flag = false;\\n            return -1;\\n        }\\n        mk[cur_n] = true;\\n        int cvaltmp, rescval;\\n        if (nums[cur_n] == pat_val) {\\n            for (int des : T[cur_n]) {\\n                if (!mk[des]) {\\n                    edges_del++;\\n                    int cval = T_ck(nums, des);\\n                    if (!flag)\\n                        return -1;\\n                    if (cval != pat_val) {\\n                        flag = false;\\n                        return -1;\\n                    }\\n                }\\n            }\\n            return pat_val;\\n        }\\n        else {\\n            cvaltmp = 0;\\n            for (int des : T[cur_n]) {\\n                if (!mk[des]) {\\n                    int cval = T_ck(nums, des);\\n                    if (cval > pat_val) {\\n                        flag = false;\\n                        return -1;\\n                    }\\n                    else if (cval == pat_val) {\\n                        edges_del++;\\n                    }\\n                    else {\\n                        cvaltmp += cval;\\n                    }\\n                }\\n            }\\n            rescval = nums[cur_n] + cvaltmp;\\n            if (rescval > pat_val) {\\n                flag = false;\\n                return -1;\\n            }\\n            return rescval;\\n        }\\n        return -1;\\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        max_edges_del = 0;\\n        maxn = -1;\\n        sumn = 0;\\n        for (int v : nums) {\\n            sumn += v;\\n            maxn = std::max(maxn, v);\\n        }\\n        for (vector<int> e : edges) {\\n            T_init_insert(e[0], e[1]);\\n            T_init_insert(e[1], e[0]);\\n        }\\n        int bound = (int)std::ceil(std::sqrt((sumn * 1.0)));\\n        for (int d = 1; d < bound; d++) {\\n            if ((sumn % d) == 0) {\\n                flag = true;\\n                edges_del = 0;\\n                memset(mk, false, sizeof(mk));\\n                pat_val = d;\\n                pat_size = sumn / d;\\n                T_ck(nums, 0);\\n                \\n                if (flag) {\\n                    max_edges_del = std::max(max_edges_del, edges_del);\\n                }\\n                flag = true;\\n                edges_del = 0;\\n                memset(mk, false, sizeof(mk));\\n                pat_val = sumn / d;\\n                pat_size = d;  \\n                T_ck(nums, 0);\\n                if (flag) {\\n                    max_edges_del = std::max(max_edges_del, edges_del);\\n                }\\n            }\\n        }\\n        return max_edges_del;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxn;\\n    int sumn;\\n    int pat_val, pat_size;\\n    const static int MAX = 20010;\\n    bool mk[MAX];\\n    int edges_del;\\n    int max_edges_del;\\n    bool flag;\\n    std::map<int, vector<int>> T;\\n    void T_init_insert(int a, int b) {\\n        if (T.find(a) == T.end()) {\\n            T[a] = { b };\\n        }\\n        else {\\n            T[a].push_back(b);\\n        }\\n    }\\n    int T_ck(vector<int>& nums, int cur_n) {\\n        if (!flag)\\n            return -1;\\n        if (nums[cur_n] > pat_val) {\\n            flag = false;\\n            return -1;\\n        }\\n        mk[cur_n] = true;\\n        int cvaltmp, rescval;\\n        if (nums[cur_n] == pat_val) {\\n            for (int des : T[cur_n]) {\\n                if (!mk[des]) {\\n                    edges_del++;\\n                    int cval = T_ck(nums, des);\\n                    if (!flag)\\n                        return -1;\\n                    if (cval != pat_val) {\\n                        flag = false;\\n                        return -1;\\n                    }\\n                }\\n            }\\n            return pat_val;\\n        }\\n        else {\\n            cvaltmp = 0;\\n            for (int des : T[cur_n]) {\\n                if (!mk[des]) {\\n                    int cval = T_ck(nums, des);\\n                    if (cval > pat_val) {\\n                        flag = false;\\n                        return -1;\\n                    }\\n                    else if (cval == pat_val) {\\n                        edges_del++;\\n                    }\\n                    else {\\n                        cvaltmp += cval;\\n                    }\\n                }\\n            }\\n            rescval = nums[cur_n] + cvaltmp;\\n            if (rescval > pat_val) {\\n                flag = false;\\n                return -1;\\n            }\\n            return rescval;\\n        }\\n        return -1;\\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        max_edges_del = 0;\\n        maxn = -1;\\n        sumn = 0;\\n        for (int v : nums) {\\n            sumn += v;\\n            maxn = std::max(maxn, v);\\n        }\\n        for (vector<int> e : edges) {\\n            T_init_insert(e[0], e[1]);\\n            T_init_insert(e[1], e[0]);\\n        }\\n        int bound = (int)std::ceil(std::sqrt((sumn * 1.0)));\\n        for (int d = 1; d < bound; d++) {\\n            if ((sumn % d) == 0) {\\n                flag = true;\\n                edges_del = 0;\\n                memset(mk, false, sizeof(mk));\\n                pat_val = d;\\n                pat_size = sumn / d;\\n                T_ck(nums, 0);\\n                \\n                if (flag) {\\n                    max_edges_del = std::max(max_edges_del, edges_del);\\n                }\\n                flag = true;\\n                edges_del = 0;\\n                memset(mk, false, sizeof(mk));\\n                pat_val = sumn / d;\\n                pat_size = d;  \\n                T_ck(nums, 0);\\n                if (flag) {\\n                    max_edges_del = std::max(max_edges_del, edges_del);\\n                }\\n            }\\n        }\\n        return max_edges_del;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794219,
                "title": "simple-cpp-solution-dfs-only",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>g;\\n    vector<int>arr;\\n    \\n    int dfs(int ind,int par,int target){\\n        int val=arr[ind];\\n        \\n        for(auto it:g[ind]){\\n            if(it == par) continue;\\n            \\n            val += dfs(it,ind,target);\\n        }\\n        if( val == target) return 0;\\n        return val;\\n        \\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& ed) {\\n        int n=nums.size();\\n        if(n == 1) return 0;\\n        \\n        g.resize(n);\\n        arr.resize(n);\\n        \\n        for(auto i:ed){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n            \\n        }\\n        \\n        \\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            arr[i]= nums[i];\\n        }\\n        \\n        \\n       int res=0;\\n        for(int part=1;part<=n;part++){\\n            if(sum%part !=0 ) continue;\\n            if(dfs(0,-1,sum/part) == 0){\\n                res=max(res,part-1);\\n            }\\n        }\\n        \\n        return res;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>g;\\n    vector<int>arr;\\n    \\n    int dfs(int ind,int par,int target){\\n        int val=arr[ind];\\n        \\n        for(auto it:g[ind]){\\n            if(it == par) continue;\\n            \\n            val += dfs(it,ind,target);\\n        }\\n        if( val == target) return 0;\\n        return val;\\n        \\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& ed) {\\n        int n=nums.size();\\n        if(n == 1) return 0;\\n        \\n        g.resize(n);\\n        arr.resize(n);\\n        \\n        for(auto i:ed){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n            \\n        }\\n        \\n        \\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            arr[i]= nums[i];\\n        }\\n        \\n        \\n       int res=0;\\n        for(int part=1;part<=n;part++){\\n            if(sum%part !=0 ) continue;\\n            if(dfs(0,-1,sum/part) == 0){\\n                res=max(res,part-1);\\n            }\\n        }\\n        \\n        return res;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762423,
                "title": "c-code-for-beginners-easy-understanding-dfs",
                "content": "```\\nclass Solution {\\nprivate:\\n    list<int>* adj;\\npublic:\\n    vector<int> Divisors(int n){\\n        vector<int> G,L;\\n        for(int i=1;i<=sqrt(n);i++){\\n            if(n%i==0){\\n                if(n/i==i){\\n                    L.push_back(i);\\n                }\\n                else{\\n                    G.push_back(n/i);\\n                    L.push_back(i);\\n                }\\n            }\\n        }\\n        vector<int> res=L;\\n        for(int i=G.size()-1;i>=0;i--){\\n            res.push_back(G[i]);\\n        }\\n        return res; // returns sorted output\\n    }  \\n    \\n    int validate(int node, int sum, vector<int>& nums, int par){\\n        int currsum=nums[node];\\n        for(auto nei: adj[node]){\\n            if(par==nei){\\n                continue;\\n            }\\n            currsum+=validate(nei,sum,nums,node);\\n            if(currsum>sum){\\n                return INT_MAX/2;\\n            }\\n        }\\n        if(currsum==sum){ // erasing edge and hence return 0\\n            return 0;\\n        }\\n        return currsum;\\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int sum=accumulate(nums.begin(),nums.end(),0);\\n        vector<int> div=Divisors(sum);\\n        int n=nums.size();\\n        adj=new list<int>[n];\\n        for(auto edge: edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        for(auto d: div){\\n            if(validate(0,d,nums,-1)==0){\\n                return sum/d-1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    list<int>* adj;\\npublic:\\n    vector<int> Divisors(int n){\\n        vector<int> G,L;\\n        for(int i=1;i<=sqrt(n);i++){\\n            if(n%i==0){\\n                if(n/i==i){\\n                    L.push_back(i);\\n                }\\n                else{\\n                    G.push_back(n/i);\\n                    L.push_back(i);\\n                }\\n            }\\n        }\\n        vector<int> res=L;\\n        for(int i=G.size()-1;i>=0;i--){\\n            res.push_back(G[i]);\\n        }\\n        return res; // returns sorted output\\n    }  \\n    \\n    int validate(int node, int sum, vector<int>& nums, int par){\\n        int currsum=nums[node];\\n        for(auto nei: adj[node]){\\n            if(par==nei){\\n                continue;\\n            }\\n            currsum+=validate(nei,sum,nums,node);\\n            if(currsum>sum){\\n                return INT_MAX/2;\\n            }\\n        }\\n        if(currsum==sum){ // erasing edge and hence return 0\\n            return 0;\\n        }\\n        return currsum;\\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int sum=accumulate(nums.begin(),nums.end(),0);\\n        vector<int> div=Divisors(sum);\\n        int n=nums.size();\\n        adj=new list<int>[n];\\n        for(auto edge: edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        for(auto d: div){\\n            if(validate(0,d,nums,-1)==0){\\n                return sum/d-1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745619,
                "title": "c-simple-queue-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool solve_bfs(int sum,vector<int>nums,vector<vector<int>>&adj,vector<int>cnt,queue<int>q)\\n    {\\n        while(!q.empty())\\n        {\\n            queue<int>q1;\\n            while(!q.empty())\\n            {\\n                int per=q.front();\\n                q.pop();\\n                if(nums[per]>sum)\\n                    return 0;\\n                \\n                for(auto it:adj[per])\\n                {\\n                    if(nums[per]!=sum)   //if sum is not equal to nums[per]\\n                    nums[it]+=nums[per]; \\n                    \\n                    cnt[it]--;\\n                    if(cnt[it]==1)\\n                    {\\n                        q1.push(it);\\n                    }\\n                }\\n                \\n            }\\n           q=q1;\\n        }\\n        return 1;\\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int sum=0;\\n        int n=nums.size();\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        \\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int>cnt(n,0);\\n        queue<int>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            cnt[i]=adj[i].size();\\n            if(cnt[i]==1) //leaf node or root node\\n            {\\n               q.push(i);\\n            }\\n        }\\n        \\n         \\n        for(int i=n;i>=2;i--)\\n        {\\n            if(sum%i==0)\\n            { \\n                if(solve_bfs(sum/i,nums,adj,cnt,q))\\n                    return i-1;\\n            }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool solve_bfs(int sum,vector<int>nums,vector<vector<int>>&adj,vector<int>cnt,queue<int>q)\\n    {\\n        while(!q.empty())\\n        {\\n            queue<int>q1;\\n            while(!q.empty())\\n            {\\n                int per=q.front();\\n                q.pop();\\n                if(nums[per]>sum)\\n                    return 0;\\n                \\n                for(auto it:adj[per])\\n                {\\n                    if(nums[per]!=sum)   //if sum is not equal to nums[per]\\n                    nums[it]+=nums[per]; \\n                    \\n                    cnt[it]--;\\n                    if(cnt[it]==1)\\n                    {\\n                        q1.push(it);\\n                    }\\n                }\\n                \\n            }\\n           q=q1;\\n        }\\n        return 1;\\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int sum=0;\\n        int n=nums.size();\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        \\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        vector<int>cnt(n,0);\\n        queue<int>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            cnt[i]=adj[i].size();\\n            if(cnt[i]==1) //leaf node or root node\\n            {\\n               q.push(i);\\n            }\\n        }\\n        \\n         \\n        for(int i=n;i>=2;i--)\\n        {\\n            if(sum%i==0)\\n            { \\n                if(solve_bfs(sum/i,nums,adj,cnt,q))\\n                    return i-1;\\n            }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745103,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    class Pair{\\n        int node;\\n        int val;\\n        Pair(int node,int val){\\n            this.node=node;\\n            this.val=val;\\n        }\\n    }\\n    public int componentValue(int[] nums, int[][] edges) {\\n        int n=nums.length;\\n        int sum=0;\\n        List<List<Integer>> adjList=new ArrayList<>();\\n        int[] degree=new int[n];\\n        for(int i=0;i<n;i++){\\n            sum=sum+nums[i];\\n            adjList.add(new ArrayList<>());\\n        }\\n        for(int[] edge:edges){\\n            adjList.get(edge[0]).add(edge[1]);\\n            adjList.get(edge[1]).add(edge[0]);\\n            degree[edge[0]]++;\\n            degree[edge[1]]++;\\n        }\\n        List<Integer> factors=new ArrayList<>();\\n        for(int i=1;i<=(int)Math.sqrt(sum);i++){\\n            if(sum%i==0){\\n                factors.add(i);\\n                factors.add(sum/i);\\n            }\\n        }\\n        Collections.sort(factors);\\n        for(int factor:factors){\\n            if(sum%factor!=0) continue;\\n            Queue<Pair> q=new LinkedList<>();\\n            int[] visited=new int[n];\\n            int[] numsCopy=new int[n];\\n            int[] degreeCopy=new int[n];\\n            for(int j=0;j<n;j++){\\n                numsCopy[j]=nums[j];\\n                degreeCopy[j]=degree[j];\\n                if(degreeCopy[j]==1){\\n                    q.add(new Pair(j,numsCopy[j]));\\n                    visited[j]=1;\\n                    \\n                }      \\n            }\\n            int component=0;\\n            int count=0;\\n            while(!q.isEmpty()){\\n                Pair pair=q.remove();\\n                count++;\\n                if(numsCopy[pair.node]==factor){\\n                    component++;\\n                }\\n                if(numsCopy[pair.node]>factor) break;\\n                for(int parent:adjList.get(pair.node)){\\n                    if(numsCopy[pair.node]<factor){\\n                        numsCopy[parent]=numsCopy[parent]+numsCopy[pair.node];\\n                    }                    \\n                    if(visited[parent]==0){\\n                        degreeCopy[parent]--;\\n                        if(degreeCopy[parent]==1){\\n                            q.add(new Pair(parent,numsCopy[parent]));\\n                            visited[parent]=1;\\n                        }\\n                    }\\n                }\\n                if(count==n) return component-1;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int node;\\n        int val;\\n        Pair(int node,int val){\\n            this.node=node;\\n            this.val=val;\\n        }\\n    }\\n    public int componentValue(int[] nums, int[][] edges) {\\n        int n=nums.length;\\n        int sum=0;\\n        List<List<Integer>> adjList=new ArrayList<>();\\n        int[] degree=new int[n];\\n        for(int i=0;i<n;i++){\\n            sum=sum+nums[i];\\n            adjList.add(new ArrayList<>());\\n        }\\n        for(int[] edge:edges){\\n            adjList.get(edge[0]).add(edge[1]);\\n            adjList.get(edge[1]).add(edge[0]);\\n            degree[edge[0]]++;\\n            degree[edge[1]]++;\\n        }\\n        List<Integer> factors=new ArrayList<>();\\n        for(int i=1;i<=(int)Math.sqrt(sum);i++){\\n            if(sum%i==0){\\n                factors.add(i);\\n                factors.add(sum/i);\\n            }\\n        }\\n        Collections.sort(factors);\\n        for(int factor:factors){\\n            if(sum%factor!=0) continue;\\n            Queue<Pair> q=new LinkedList<>();\\n            int[] visited=new int[n];\\n            int[] numsCopy=new int[n];\\n            int[] degreeCopy=new int[n];\\n            for(int j=0;j<n;j++){\\n                numsCopy[j]=nums[j];\\n                degreeCopy[j]=degree[j];\\n                if(degreeCopy[j]==1){\\n                    q.add(new Pair(j,numsCopy[j]));\\n                    visited[j]=1;\\n                    \\n                }      \\n            }\\n            int component=0;\\n            int count=0;\\n            while(!q.isEmpty()){\\n                Pair pair=q.remove();\\n                count++;\\n                if(numsCopy[pair.node]==factor){\\n                    component++;\\n                }\\n                if(numsCopy[pair.node]>factor) break;\\n                for(int parent:adjList.get(pair.node)){\\n                    if(numsCopy[pair.node]<factor){\\n                        numsCopy[parent]=numsCopy[parent]+numsCopy[pair.node];\\n                    }                    \\n                    if(visited[parent]==0){\\n                        degreeCopy[parent]--;\\n                        if(degreeCopy[parent]==1){\\n                            q.add(new Pair(parent,numsCopy[parent]));\\n                            visited[parent]=1;\\n                        }\\n                    }\\n                }\\n                if(count==n) return component-1;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743851,
                "title": "java-clear-code-faster-than-90",
                "content": "class Solution {\\n    int[] nums;\\n    public int componentValue(int[] nums, int[][] edges) {\\n        int n = nums.length;\\n        this.nums = nums;\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i=0; i<n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        \\n        int sum = 0;\\n        for(int i : nums) {\\n            sum += i;\\n        }\\n        \\n        for(int k=n; k>0; k--) {\\n            if(sum % k != 0) continue;\\n            int ans = helper(graph, 0, -1, sum / k);\\n            if(ans == 0) return k-1;\\n        }\\n        return 0;\\n    }\\n    \\n    private int helper(List<Integer>[] graph, int i, int prev, int target) {\\n        if(graph[i].size() == 1 && graph[i].get(0) == prev) {\\n            if(nums[i] > target) return -1;\\n            if(nums[i] == target) return 0;\\n            return nums[i];\\n        }\\n        \\n        int sum = nums[i];\\n        for(int k : graph[i]) {\\n            if(k == prev) continue;\\n            int ans = helper(graph, k, i, target);\\n            if(ans == -1) return -1;\\n            sum += ans;\\n        }\\n        \\n        if(sum > target) return -1;\\n        if(sum == target) return 0;\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int[] nums;\\n    public int componentValue(int[] nums, int[][] edges) {\\n        int n = nums.length;\\n        this.nums = nums;\\n        List<Integer>[] graph = new ArrayList[n];\\n        for(int i=0; i<n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2738446,
                "title": "c-dfs-concise",
                "content": "```\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        const auto sum = accumulate(nums.begin(), nums.end(), 0); \\n        vector<vector<int>> g(nums.size());\\n        for (auto& e:edges) g[e[0]].push_back(e[1]), g[e[1]].push_back(e[0]);        \\n        for (int d=1;d<= sum/2; d++)\\n            if (sum % d == 0 && dfs(g, nums, 0, -1, d) == 0) return sum/d - 1;\\n        return 0;\\n    }\\n    \\n    int dfs(const vector<vector<int>>& g, const vector<int>& nums, int i, int par, int d){\\n        int sum = nums[i];\\n        for (auto j : g[i]) {\\n            if (j == par) continue;\\n            if (int x = dfs(g, nums, j, i, d); x==-1) return -1; //impossible\\n            else sum += x;\\n        }\\n        if (sum > d) return -1;\\n        return sum == d ? 0 : sum;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        const auto sum = accumulate(nums.begin(), nums.end(), 0); \\n        vector<vector<int>> g(nums.size());\\n        for (auto& e:edges) g[e[0]].push_back(e[1]), g[e[1]].push_back(e[0]);        \\n        for (int d=1;d<= sum/2; d++)\\n            if (sum % d == 0 && dfs(g, nums, 0, -1, d) == 0) return sum/d - 1;\\n        return 0;\\n    }\\n    \\n    int dfs(const vector<vector<int>>& g, const vector<int>& nums, int i, int par, int d){\\n        int sum = nums[i];\\n        for (auto j : g[i]) {\\n            if (j == par) continue;\\n            if (int x = dfs(g, nums, j, i, d); x==-1) return -1; //impossible\\n            else sum += x;\\n        }\\n        if (sum > d) return -1;\\n        return sum == d ? 0 : sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2735544,
                "title": "c-dfs-for-each-divisor-of-the-sum-of-all-nodes-in-the-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem requires the following observations to be solved:\\n\\n1.) Suppose we are looking to divide the tree into components of sum s, then if a subtree has a sum of s, then it needs to be included in the final answer.\\n2.) Following point 1, if there is a tree of sum m*s rooted at some node i and if we have found (m-1) components of sum s in all the subtrees of node i, then it is possible to divide the tree at node i into into m components of sum s.\\n3.) We need to consider all the sums that are divisors of the total sum of the tree and choose the lowest sum for which the overall tree can be divided into equal sum components.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo check whether the given tree can be divided into equal components of sum \"s\", we need to check whether the number of components of sum s found in the tree is equal to \"totalSum/s\", where totalSum is the sum of all the nodes in the overall tree.\\n\\nThe 2nd observation points to a recursive approach, so we are going to use DFS to count the number of components for each divisor of totalSum.\\n\\n# Complexity\\n- Time complexity: O(N*k) where k is the number of factors of totalSum\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) - for storing the tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct CompositeSum {\\n        int componentsFound;\\n        int sum;\\n    };\\n\\n    CompositeSum dfs(int s, int parent, int targetSum, vector<vector<int>>& tree, \\n                    vector<int>& nums) {\\n        int currSum = nums[s], currComponents = 0;\\n        for (int nbr: tree[s]) {\\n            if (nbr == parent) {\\n                continue;\\n            }\\n            CompositeSum subResult = dfs(nbr, s, targetSum, tree, nums);\\n            currSum += subResult.sum;\\n            currComponents += subResult.componentsFound;\\n        }\\n\\n        if (currSum % targetSum == 0 && (currComponents == currSum/targetSum-1)) {\\n            currComponents++;\\n        }\\n\\n        CompositeSum fin = {currComponents, currSum};\\n        return fin;\\n    }\\n\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        //create the tree\\n        int N = nums.size();\\n        vector<vector<int>> tree(N);\\n        for (vector<int>& edge: edges) {\\n            tree[edge[0]].push_back(edge[1]);\\n            tree[edge[1]].push_back(edge[0]);\\n        }\\n\\n        //calculate the sum and its factors;\\n        int sum = 0;\\n        for (int num: nums) {\\n            sum += num;\\n        }\\n        vector<int> factors;\\n        for (int i = 1; i*i <= sum; i++) {\\n            if (sum%i == 0) {\\n                factors.push_back(i);\\n                factors.push_back(sum/i);\\n            }\\n        }\\n        sort(factors.begin(), factors.end(), greater<int>());\\n\\n        int ans = 0;\\n        for (int factor: factors) {\\n            CompositeSum curr = dfs(0, -1, factor, tree, nums);\\n            if (curr.componentsFound == sum/factor) {\\n                ans = sum/factor-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct CompositeSum {\\n        int componentsFound;\\n        int sum;\\n    };\\n\\n    CompositeSum dfs(int s, int parent, int targetSum, vector<vector<int>>& tree, \\n                    vector<int>& nums) {\\n        int currSum = nums[s], currComponents = 0;\\n        for (int nbr: tree[s]) {\\n            if (nbr == parent) {\\n                continue;\\n            }\\n            CompositeSum subResult = dfs(nbr, s, targetSum, tree, nums);\\n            currSum += subResult.sum;\\n            currComponents += subResult.componentsFound;\\n        }\\n\\n        if (currSum % targetSum == 0 && (currComponents == currSum/targetSum-1)) {\\n            currComponents++;\\n        }\\n\\n        CompositeSum fin = {currComponents, currSum};\\n        return fin;\\n    }\\n\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        //create the tree\\n        int N = nums.size();\\n        vector<vector<int>> tree(N);\\n        for (vector<int>& edge: edges) {\\n            tree[edge[0]].push_back(edge[1]);\\n            tree[edge[1]].push_back(edge[0]);\\n        }\\n\\n        //calculate the sum and its factors;\\n        int sum = 0;\\n        for (int num: nums) {\\n            sum += num;\\n        }\\n        vector<int> factors;\\n        for (int i = 1; i*i <= sum; i++) {\\n            if (sum%i == 0) {\\n                factors.push_back(i);\\n                factors.push_back(sum/i);\\n            }\\n        }\\n        sort(factors.begin(), factors.end(), greater<int>());\\n\\n        int ans = 0;\\n        for (int factor: factors) {\\n            CompositeSum curr = dfs(0, -1, factor, tree, nums);\\n            if (curr.componentsFound == sum/factor) {\\n                ans = sum/factor-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732444,
                "title": "c-dfs-commented-code",
                "content": "**C++ code**\\n```\\n int isPossible(int target, int src, vector<int> adj[], int par, vector<int> &nums){\\n        int currSum=nums[src];\\n        \\n        for(auto &x:adj[src]){\\n            if(x!=par){\\n                currSum+=isPossible(target,x,adj,src,nums);\\n            }\\n        }\\n        \\n        //if current node create pair with its child and found target so it will not going to give its value to its parent\\n        if(currSum==target){\\n            return 0;\\n        }\\n        return currSum;\\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<int> adj[nums.size()];\\n        \\n        //create graph\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        \\n        int sum=0;\\n        for(auto &x:nums){\\n            sum+=x;\\n        }\\n        // check for each possiblity\\n        for(int i=nums.size()-1;i>=1;i--){\\n            if(sum%(i+1)==0){\\n                if(isPossible(sum/(i+1),0,adj,-1,nums)==0){\\n                    return i;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\t//code by sachin\\n```\\n**Upvote if solution was helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n int isPossible(int target, int src, vector<int> adj[], int par, vector<int> &nums){\\n        int currSum=nums[src];\\n        \\n        for(auto &x:adj[src]){\\n            if(x!=par){\\n                currSum+=isPossible(target,x,adj,src,nums);\\n            }\\n        }\\n        \\n        //if current node create pair with its child and found target so it will not going to give its value to its parent\\n        if(currSum==target){\\n            return 0;\\n        }\\n        return currSum;\\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<int> adj[nums.size()];\\n        \\n        //create graph\\n        for(auto &x:edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        \\n        int sum=0;\\n        for(auto &x:nums){\\n            sum+=x;\\n        }\\n        // check for each possiblity\\n        for(int i=nums.size()-1;i>=1;i--){\\n            if(sum%(i+1)==0){\\n                if(isPossible(sum/(i+1),0,adj,-1,nums)==0){\\n                    return i;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\t//code by sachin\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2732430,
                "title": "golang",
                "content": "```\\nfunc componentValue(nums []int, edges [][]int) int {\\n    sum := 0\\n    for _, v := range nums {\\n        sum += v\\n    }\\n    \\n    g := make([][]int, len(nums))\\n    for _, e := range edges {\\n        g[e[0]] = append(g[e[0]], e[1])\\n        g[e[1]] = append(g[e[1]], e[0])\\n    }\\n    \\n    res := 0\\n    for i := 1; i < sum; i++ {\\n        if sum % i == 0 {\\n            res = max(res, search(g, nums, i))\\n        }\\n    }\\n    return res\\n}\\n\\nfunc max(a int,b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc search(g [][]int, nums []int, tar int) int {\\n    fmt.Println(tar)\\n    nums2 := make([]int, len(nums))\\n    copy(nums2, nums)\\n    \\n    degree := make([]int, len(nums))\\n    for i := 0; i < len(nums); i++ {\\n        degree[i] = len(g[i])\\n    }\\n    \\n    var queue []int\\n    for i, d := range degree {\\n        if d == 1 {\\n            queue = append(queue, i)\\n        }\\n    }\\n    \\n    res := 0\\n    for len(queue) > 0 {\\n        l := len(queue)\\n        for i := 0; i < l; i++ {\\n            a := queue[i]\\n            if nums2[a] > tar {\\n                return 0\\n            }\\n            if degree[a] != 1 {\\n                continue\\n            }\\n            for _, v := range g[a] {\\n                if degree[v] != 0 {\\n                    degree[v]--\\n                    degree[a]--\\n                    \\n                    if nums2[a] < tar {\\n                        nums2[v] += nums2[a]\\n                    } else {\\n                        res++\\n                    }\\n                    if degree[v] == 1 {\\n                        queue = append(queue, v)\\n                    }\\n                }\\n            }\\n            \\n        }\\n        queue = queue[l:]\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc componentValue(nums []int, edges [][]int) int {\\n    sum := 0\\n    for _, v := range nums {\\n        sum += v\\n    }\\n    \\n    g := make([][]int, len(nums))\\n    for _, e := range edges {\\n        g[e[0]] = append(g[e[0]], e[1])\\n        g[e[1]] = append(g[e[1]], e[0])\\n    }\\n    \\n    res := 0\\n    for i := 1; i < sum; i++ {\\n        if sum % i == 0 {\\n            res = max(res, search(g, nums, i))\\n        }\\n    }\\n    return res\\n}\\n\\nfunc max(a int,b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc search(g [][]int, nums []int, tar int) int {\\n    fmt.Println(tar)\\n    nums2 := make([]int, len(nums))\\n    copy(nums2, nums)\\n    \\n    degree := make([]int, len(nums))\\n    for i := 0; i < len(nums); i++ {\\n        degree[i] = len(g[i])\\n    }\\n    \\n    var queue []int\\n    for i, d := range degree {\\n        if d == 1 {\\n            queue = append(queue, i)\\n        }\\n    }\\n    \\n    res := 0\\n    for len(queue) > 0 {\\n        l := len(queue)\\n        for i := 0; i < l; i++ {\\n            a := queue[i]\\n            if nums2[a] > tar {\\n                return 0\\n            }\\n            if degree[a] != 1 {\\n                continue\\n            }\\n            for _, v := range g[a] {\\n                if degree[v] != 0 {\\n                    degree[v]--\\n                    degree[a]--\\n                    \\n                    if nums2[a] < tar {\\n                        nums2[v] += nums2[a]\\n                    } else {\\n                        res++\\n                    }\\n                    if degree[v] == 1 {\\n                        queue = append(queue, v)\\n                    }\\n                }\\n            }\\n            \\n        }\\n        queue = queue[l:]\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2731323,
                "title": "python-dfs-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def getFactors(self, num: int) -> List[int]:\\n        factors = []\\n        for possibleFactor in range(1, int(sqrt(num)) + 1):\\n            if num % possibleFactor != 0: \\n                continue\\n            factors.append(possibleFactor)\\n            if num // possibleFactor != possibleFactor: \\n                factors.append(num // possibleFactor)\\n        return factors\\n    \\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        numNodes, self.cntRemainderZero, graph = len(nums), 0, defaultdict(list)\\n        for node1, node2 in edges:\\n            graph[node1].append(node2)\\n            graph[node2].append(node1)\\n        \\n        def dfs(node: int, prevNode: int, sumPerComponent: int) -> int:\\n            remainder = nums[node]\\n            for neighbor in graph[node]:\\n                if neighbor == prevNode:\\n                    continue\\n                remainder += dfs(neighbor, node, sumPerComponent)\\n            remainder %= sumPerComponent\\n            if remainder == 0:\\n                self.cntRemainderZero += 1\\n            return remainder\\n        \\n        def isGood(sumPerComponent: int, expectedNumOfComponents: int) -> bool:\\n            self.cntRemainderZero = 0\\n            dfs(0, -1, sumPerComponent)\\n            return self.cntRemainderZero == expectedNumOfComponents\\n        \\n        sumOfAllNodes, maxNode = sum(nums), max(nums)\\n        for sumPerComponent in sorted(self.getFactors(sumOfAllNodes)):\\n            if sumPerComponent < maxNode: \\n                continue\\n            expectedNumOfComponents = sumOfAllNodes // sumPerComponent\\n            if isGood(sumPerComponent, expectedNumOfComponents):\\n                return expectedNumOfComponents - 1\\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def getFactors(self, num: int) -> List[int]:\\n        factors = []\\n        for possibleFactor in range(1, int(sqrt(num)) + 1):\\n            if num % possibleFactor != 0: \\n                continue\\n            factors.append(possibleFactor)\\n            if num // possibleFactor != possibleFactor: \\n                factors.append(num // possibleFactor)\\n        return factors\\n    \\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        numNodes, self.cntRemainderZero, graph = len(nums), 0, defaultdict(list)\\n        for node1, node2 in edges:\\n            graph[node1].append(node2)\\n            graph[node2].append(node1)\\n        \\n        def dfs(node: int, prevNode: int, sumPerComponent: int) -> int:\\n            remainder = nums[node]\\n            for neighbor in graph[node]:\\n                if neighbor == prevNode:\\n                    continue\\n                remainder += dfs(neighbor, node, sumPerComponent)\\n            remainder %= sumPerComponent\\n            if remainder == 0:\\n                self.cntRemainderZero += 1\\n            return remainder\\n        \\n        def isGood(sumPerComponent: int, expectedNumOfComponents: int) -> bool:\\n            self.cntRemainderZero = 0\\n            dfs(0, -1, sumPerComponent)\\n            return self.cntRemainderZero == expectedNumOfComponents\\n        \\n        sumOfAllNodes, maxNode = sum(nums), max(nums)\\n        for sumPerComponent in sorted(self.getFactors(sumOfAllNodes)):\\n            if sumPerComponent < maxNode: \\n                continue\\n            expectedNumOfComponents = sumOfAllNodes // sumPerComponent\\n            if isGood(sumPerComponent, expectedNumOfComponents):\\n                return expectedNumOfComponents - 1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729344,
                "title": "java-complex-bfs-solution-commented",
                "content": "Runtime: 105 ms, faster than 80.75% of Java online submissions for Create Components With Same Value.\\nMemory Usage: 59 MB, less than 88.22% of Java online submissions for Create Components With Same Value.\\n![image](https://assets.leetcode.com/users/images/2e98a54b-967d-4e66-8a30-d7a926336a94_1666362387.249585.png)\\n\\n```\\nclass Solution {\\n  public int componentValue(int[] nums, int[][] edges) {\\n    if(edges.length == 0) return 0;\\n   \\n    fillDivisors(nums);\\n    constructGraph(edges, nums.length);\\n    collectAllLeavesAndBFSFromLeaves(nums);\\n    \\n    return decoupleGraph(edges.length);\\n  }\\n  \\n  \\n//for divisors\\n  LinkedList<Integer> divisors;\\n  int sum;\\n  \\n  private void fillDivisors(int[] nums) {\\n    divisors = new LinkedList<>();\\n    sum = 0;\\n    for(int x : nums) sum += x;\\n    \\n    int n = sum;\\n    int div = (int)Math.sqrt(n);\\n    if(n == div * div) divisors.add(div);\\n    else div++;\\n    \\n    while(--div != 0)\\n      if(n % div == 0){\\n        divisors.addFirst(div);\\n        divisors.addLast(n/div);\\n      }\\n    \\n    divisors.pollLast();  \\n  }\\n  \\n//for graph\\n  HashSet<Integer>[] graph;\\n  \\n  private void constructGraph(int[][] edges, int size){\\n    graph = new HashSet[size];\\n    \\n    for(int[] e: edges){\\n      if(graph[e[0]] == null) graph[e[0]] = new HashSet<>();\\n      if(graph[e[1]] == null) graph[e[1]] = new HashSet<>();\\n      \\n      graph[e[0]].add(e[1]);\\n      graph[e[1]].add(e[0]);\\n    }\\n  }\\n  \\n//for path from all leaves  \\n  LinkedList<Integer> nodes;\\n  HashMap<Integer, Integer> table = new HashMap<>();\\n  \\n  private void collectAllLeavesAndBFSFromLeaves(int[] nums){\\n    nodes = new LinkedList<>();\\n    for(int i = 0; i != graph.length; i++) \\n      if(graph[i].size() == 1) nodes.add(i);\\n    \\n    while(!nodes.isEmpty()){\\n      int n = nodes.pollLast();\\n      if(graph[n].size() != 1) continue;\\n      \\n      Integer value = table.get(nums[n]);\\n      value = value == null ? 1 : value + 1;\\n      table.put(nums[n], value);\\n      \\n      for(int next: graph[n]){\\n        nums[next] += nums[n];\\n        graph[next].remove(n);\\n        if(graph[next].size() == 1) nodes.addFirst(next);\\n      }\\n    }\\n  }\\n  \\n//for searching answer\\n  private int decoupleGraph(int countOfEdges){\\n    int ans;\\n    \\n    for(int d : divisors)\\n      if( (ans = sum/d - 1) <= countOfEdges){\\n        int k = 0;\\n        for(Map.Entry<Integer,Integer> it: table.entrySet())\\n          if(it.getKey() % d == 0) k += it.getValue();\\n        \\n        if(ans <= k) return ans;\\n      }  \\n    \\n    return 0;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int componentValue(int[] nums, int[][] edges) {\\n    if(edges.length == 0) return 0;\\n   \\n    fillDivisors(nums);\\n    constructGraph(edges, nums.length);\\n    collectAllLeavesAndBFSFromLeaves(nums);\\n    \\n    return decoupleGraph(edges.length);\\n  }\\n  \\n  \\n//for divisors\\n  LinkedList<Integer> divisors;\\n  int sum;\\n  \\n  private void fillDivisors(int[] nums) {\\n    divisors = new LinkedList<>();\\n    sum = 0;\\n    for(int x : nums) sum += x;\\n    \\n    int n = sum;\\n    int div = (int)Math.sqrt(n);\\n    if(n == div * div) divisors.add(div);\\n    else div++;\\n    \\n    while(--div != 0)\\n      if(n % div == 0){\\n        divisors.addFirst(div);\\n        divisors.addLast(n/div);\\n      }\\n    \\n    divisors.pollLast();  \\n  }\\n  \\n//for graph\\n  HashSet<Integer>[] graph;\\n  \\n  private void constructGraph(int[][] edges, int size){\\n    graph = new HashSet[size];\\n    \\n    for(int[] e: edges){\\n      if(graph[e[0]] == null) graph[e[0]] = new HashSet<>();\\n      if(graph[e[1]] == null) graph[e[1]] = new HashSet<>();\\n      \\n      graph[e[0]].add(e[1]);\\n      graph[e[1]].add(e[0]);\\n    }\\n  }\\n  \\n//for path from all leaves  \\n  LinkedList<Integer> nodes;\\n  HashMap<Integer, Integer> table = new HashMap<>();\\n  \\n  private void collectAllLeavesAndBFSFromLeaves(int[] nums){\\n    nodes = new LinkedList<>();\\n    for(int i = 0; i != graph.length; i++) \\n      if(graph[i].size() == 1) nodes.add(i);\\n    \\n    while(!nodes.isEmpty()){\\n      int n = nodes.pollLast();\\n      if(graph[n].size() != 1) continue;\\n      \\n      Integer value = table.get(nums[n]);\\n      value = value == null ? 1 : value + 1;\\n      table.put(nums[n], value);\\n      \\n      for(int next: graph[n]){\\n        nums[next] += nums[n];\\n        graph[next].remove(n);\\n        if(graph[next].size() == 1) nodes.addFirst(next);\\n      }\\n    }\\n  }\\n  \\n//for searching answer\\n  private int decoupleGraph(int countOfEdges){\\n    int ans;\\n    \\n    for(int d : divisors)\\n      if( (ans = sum/d - 1) <= countOfEdges){\\n        int k = 0;\\n        for(Map.Entry<Integer,Integer> it: table.entrySet())\\n          if(it.getKey() % d == 0) k += it.getValue();\\n        \\n        if(ans <= k) return ans;\\n      }  \\n    \\n    return 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729095,
                "title": "factorization-recursive-c",
                "content": "class Solution {\\nprivate:\\n    vector<int> a[20000+5];\\n    pair<int,bool> dfs(int curr,int par,int k,vector<int> &nums)\\n    {\\n        bool ans=true;\\n        int sum=nums[curr];\\n        for(auto &it:a[curr])\\n        {\\n            if(it!=par)\\n            {\\n                pair<int,bool> pp=dfs(it,curr,k,nums);\\n                ans=ans && pp.second;\\n                sum+=pp.first;\\n            }\\n        }\\n        \\n        if(sum==k) \\n        {\\n            sum=0;\\n            ans=ans and true;\\n        }\\n        else\\n        {\\n            if(sum>k) ans=false;\\n        }\\n        \\n        return {sum,ans};\\n    }\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        \\n        for(auto &it:edges)\\n        {\\n            int x=it[0];\\n            int y=it[1];\\n            a[x].push_back(y);\\n            a[y].push_back(x);\\n        }\\n        \\n        int sum=0;\\n        for(auto &it:nums) sum+=it;\\n        \\n        \\n        for(int x=1;x<=sum;x++)\\n        {\\n            if(sum%x==0 and dfs(0,-1,x,nums).second==true)\\n            {\\n                int cc=sum/x;\\n                return (sum/x)-1;\\n            }\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\nprivate:\\n    vector<int> a[20000+5];\\n    pair<int,bool> dfs(int curr,int par,int k,vector<int> &nums)\\n    {\\n        bool ans=true;\\n        int sum=nums[curr];\\n        for(auto &it:a[curr])\\n        {\\n            if(it!=par)\\n            {\\n                pair<int,bool> pp=dfs(it,curr,k,nums);\\n                ans=ans && pp.second;\\n                sum+=pp.first;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2728494,
                "title": "c-dfs-explained-stepwise-commented",
                "content": "**Explanation of DFS:**  \\nImagine standing at the root and going down to child nodes (traversing subtrees)\\n1. Assign the current nodes the value of nums[current index] to temp[current index] (current index = node 0, 1, 2, 3... here)\\n2. Traverse the adjacent nodes of current node. If the child node is not visited call the recursive DFS traversal for these nodes and add the values that they return to the current node value.\\nIt means we are at root and we are traversing the children of tree (subtree) and add the values that they return while backtraversing to the root.\\n\\n3. If after adding DFS traversal values of any child we have `sum at root > target` (target = value of one component),\\n we return 1e6 as it is the max sum of whole tree we can have (constraints : max node val = 50, max no. of nodes = 1e4)\\n4. If after traversing all the child nodes we see that `sum at current root = target` \\nwe can clip off this subtree as one component and return 0 to be added back to root of current root.\\n5. Else if `sum at current root < target` \\nwe return the value of current root to be added to sum of its root (current root contributing in making a component with its own root)\\n\\n**If it helps, please UPVOTE : )**\\n```\\nclass Solution {\\npublic:\\n    int dfs(int v, int target, vector<int> &temp, vector<int>& nums, vector<vector<int>>& adj)\\n    {\\n        temp[v] = nums[v];                             //step 1\\n        \\n        for(auto u: adj[v])                            //step 2\\n        {\\n            if(temp[u])                                //already visited \\n                continue;\\n            \\n            temp[v] += dfs(u, target, temp, nums, adj);\\n            \\n            if(temp[v] > target)                       //step 3\\n                return 1e6;                            \\n        }\\n        if(temp[v] == target)                          //step 4\\n            return 0;\\n        return temp[v];                                //step 5\\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) \\n    {\\n        int n = nums.size();\\n        vector<vector<int>> adj(n);                    //adjacency list, making graph\\n        for(auto e: edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        int sum = 0;                                   //sum of all nodes\\n        for(auto i: nums)\\n            sum += i;\\n        \\n        for(int i=n; i>1; i--)                         //components = i, edges to be removed = i-1, we see if we can divide the graph into more than 1 component\\n        {\\n            if(sum % i != 0)                           //not possible to divide graph into equal components\\n                continue;\\n            \\n            vector<int> temp(n, 0);\\n            if(dfs(0, sum/i, temp, nums, adj) == 0)    //0 = curr node, sum/i = target sum for each component\\n                return i-1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int v, int target, vector<int> &temp, vector<int>& nums, vector<vector<int>>& adj)\\n    {\\n        temp[v] = nums[v];                             //step 1\\n        \\n        for(auto u: adj[v])                            //step 2\\n        {\\n            if(temp[u])                                //already visited \\n                continue;\\n            \\n            temp[v] += dfs(u, target, temp, nums, adj);\\n            \\n            if(temp[v] > target)                       //step 3\\n                return 1e6;                            \\n        }\\n        if(temp[v] == target)                          //step 4\\n            return 0;\\n        return temp[v];                                //step 5\\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) \\n    {\\n        int n = nums.size();\\n        vector<vector<int>> adj(n);                    //adjacency list, making graph\\n        for(auto e: edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        int sum = 0;                                   //sum of all nodes\\n        for(auto i: nums)\\n            sum += i;\\n        \\n        for(int i=n; i>1; i--)                         //components = i, edges to be removed = i-1, we see if we can divide the graph into more than 1 component\\n        {\\n            if(sum % i != 0)                           //not possible to divide graph into equal components\\n                continue;\\n            \\n            vector<int> temp(n, 0);\\n            if(dfs(0, sum/i, temp, nums, adj) == 0)    //0 = curr node, sum/i = target sum for each component\\n                return i-1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728401,
                "title": "java-proper-commented-code-greedy-dfs-solution",
                "content": "```\\nclass Solution {\\n     public int componentValue(int[] nums, int[][] edges) {\\n        int totalSum = 0;\\n\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        int[] indegree = new int[nums.length];\\n\\n        for (int num : nums) totalSum += num;\\n\\n        for (int[] edge : edges) {\\n            if (!graph.containsKey(edge[0])) graph.put(edge[0], new ArrayList<>());\\n            if (!graph.containsKey(edge[1])) graph.put(edge[1], new ArrayList<>());\\n\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n            indegree[edge[0]]++;\\n            indegree[edge[1]]++;\\n        }\\n\\n\\n        // We will greadily start with max number of components ie, traverse from right to left\\n        // and check if such configuration is achievable\\n        for (int i = nums.length; i > 1; i--) {\\n\\n            // If we split the tree into i components, the target value of each component is sum / i.\\n            // Note that we cannot split into i components if sum % i != 0.\\n            if (totalSum % i == 0) {\\n\\n                if (bfs(nums.clone(), totalSum / i, graph, indegree.clone())) {\\n                    // return i-1 as edges to be deleted == number of partition - 1\\n                    return i - 1;\\n                }\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n    private boolean bfs(int[] nums, int target, Map<Integer, List<Integer>> graph, int[] indegree) {\\n\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        for (int i = 0; i < indegree.length; i++) {\\n            // start from leaves\\n            if (indegree[i] == 1) queue.addLast(i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            // leaf nodes\\n            int curr = queue.removeFirst();\\n\\n            for (int adj : graph.get(curr)) {\\n\\n                // if curr node itself exceeds target then this configuration is indeed impossible to obtain\\n                if (nums[curr] > target) return false;\\n\\n                // nums[curr] < target is true it means adj can be taken in same component else make a cut\\n                nums[adj] += nums[curr] < target ? nums[curr] : 0;\\n\\n                // In either cases indegree will be reduced by 1\\n                indegree[adj]--;\\n\\n                // Repeat the same process\\n                if (indegree[adj] == 1) {\\n                    queue.addLast(adj);\\n                }\\n\\n            }\\n        }\\n\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n     public int componentValue(int[] nums, int[][] edges) {\\n        int totalSum = 0;\\n\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        int[] indegree = new int[nums.length];\\n\\n        for (int num : nums) totalSum += num;\\n\\n        for (int[] edge : edges) {\\n            if (!graph.containsKey(edge[0])) graph.put(edge[0], new ArrayList<>());\\n            if (!graph.containsKey(edge[1])) graph.put(edge[1], new ArrayList<>());\\n\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n            indegree[edge[0]]++;\\n            indegree[edge[1]]++;\\n        }\\n\\n\\n        // We will greadily start with max number of components ie, traverse from right to left\\n        // and check if such configuration is achievable\\n        for (int i = nums.length; i > 1; i--) {\\n\\n            // If we split the tree into i components, the target value of each component is sum / i.\\n            // Note that we cannot split into i components if sum % i != 0.\\n            if (totalSum % i == 0) {\\n\\n                if (bfs(nums.clone(), totalSum / i, graph, indegree.clone())) {\\n                    // return i-1 as edges to be deleted == number of partition - 1\\n                    return i - 1;\\n                }\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n    private boolean bfs(int[] nums, int target, Map<Integer, List<Integer>> graph, int[] indegree) {\\n\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        for (int i = 0; i < indegree.length; i++) {\\n            // start from leaves\\n            if (indegree[i] == 1) queue.addLast(i);\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            // leaf nodes\\n            int curr = queue.removeFirst();\\n\\n            for (int adj : graph.get(curr)) {\\n\\n                // if curr node itself exceeds target then this configuration is indeed impossible to obtain\\n                if (nums[curr] > target) return false;\\n\\n                // nums[curr] < target is true it means adj can be taken in same component else make a cut\\n                nums[adj] += nums[curr] < target ? nums[curr] : 0;\\n\\n                // In either cases indegree will be reduced by 1\\n                indegree[adj]--;\\n\\n                // Repeat the same process\\n                if (indegree[adj] == 1) {\\n                    queue.addLast(adj);\\n                }\\n\\n            }\\n        }\\n\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727115,
                "title": "dfs-o-n-no-of-factors-sum-of-vals-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int cnt;\\n    bool flag;\\n    \\n    vector<int> Cal(int num){\\n        int sq = sqrt(num)+1;\\n        vector<int> fact;\\n        for(int i=2;i<=sq;i++){\\n            if(num%i==0){\\n                int j = num/i;\\n                fact.push_back(i);\\n                if(i!=j) fact.push_back(j);\\n            }\\n        }\\n        fact.push_back(1);\\n        sort(fact.begin(),fact.end());\\n        return fact;\\n    }\\n    \\n    int Check(vector<vector<int>>& Graph, int node, int f, int par, vector<int>& val){\\n        if(flag) return -1;\\n        int sum = val[node];\\n        for(int next : Graph[node]){\\n            if(next == par) continue;\\n            int x =  Check(Graph, next, f, node, val);\\n            if(x==-1) return -1;\\n            sum += x;\\n        }\\n     \\n        if(sum==f){\\n            cnt++;\\n            return 0;\\n        }else if(sum < f){\\n            return sum;\\n        }\\n        flag = true;\\n        return -1;\\n        \\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int N = nums.size();\\n        if(N==1) return 0;\\n        int sum = 0;\\n        for(int i=0;i<N;i++) sum += nums[i];\\n        \\n        vector<vector<int>> Graph(N);\\n        for(auto edge : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            Graph[u].push_back(v);\\n            Graph[v].push_back(u);\\n        }\\n        \\n        vector<int> fact = Cal(sum);\\n        int Ans = 0;\\n        for(int f : fact){\\n            cnt = 0;\\n            flag = false;\\n            Check(Graph, 0, f, -1, nums);\\n            if(!flag){\\n                Ans = max(Ans,cnt-1);\\n            } \\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int cnt;\\n    bool flag;\\n    \\n    vector<int> Cal(int num){\\n        int sq = sqrt(num)+1;\\n        vector<int> fact;\\n        for(int i=2;i<=sq;i++){\\n            if(num%i==0){\\n                int j = num/i;\\n                fact.push_back(i);\\n                if(i!=j) fact.push_back(j);\\n            }\\n        }\\n        fact.push_back(1);\\n        sort(fact.begin(),fact.end());\\n        return fact;\\n    }\\n    \\n    int Check(vector<vector<int>>& Graph, int node, int f, int par, vector<int>& val){\\n        if(flag) return -1;\\n        int sum = val[node];\\n        for(int next : Graph[node]){\\n            if(next == par) continue;\\n            int x =  Check(Graph, next, f, node, val);\\n            if(x==-1) return -1;\\n            sum += x;\\n        }\\n     \\n        if(sum==f){\\n            cnt++;\\n            return 0;\\n        }else if(sum < f){\\n            return sum;\\n        }\\n        flag = true;\\n        return -1;\\n        \\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int N = nums.size();\\n        if(N==1) return 0;\\n        int sum = 0;\\n        for(int i=0;i<N;i++) sum += nums[i];\\n        \\n        vector<vector<int>> Graph(N);\\n        for(auto edge : edges){\\n            int u = edge[0];\\n            int v = edge[1];\\n            Graph[u].push_back(v);\\n            Graph[v].push_back(u);\\n        }\\n        \\n        vector<int> fact = Cal(sum);\\n        int Ans = 0;\\n        for(int f : fact){\\n            cnt = 0;\\n            flag = false;\\n            Check(Graph, 0, f, -1, nums);\\n            if(!flag){\\n                Ans = max(Ans,cnt-1);\\n            } \\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725838,
                "title": "c-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n            int sum = accumulate(nums.begin(),nums.end(),0);\\n            int n = nums.size();\\n            vector<int> div;\\n            vector<vector<int>> adj(n);\\n            for(auto v:edges)\\n            {\\n                adj[v[0]].push_back(v[1]);\\n                adj[v[1]].push_back(v[0]);\\n            }\\n\\n            for(int i=1;i*i <= sum;i++)\\n            {\\n                if(i*i == sum)\\n                {\\n                    div.push_back(i);\\n                }\\n                else if(sum%i == 0)\\n                {\\n                    div.push_back(i);\\n                    div.push_back(sum/i);\\n                }\\n            }\\n\\n            int ans = 0;\\n            for(int i:div)\\n            {\\n                pair<int,int> temp = divide(adj,0,-1,i,nums);\\n\\n                if(temp.first == 0)\\n                {\\n                ans = max(ans,temp.second - 1);\\n                \\n                }\\n            }\\n\\n            return ans;\\n\\n    }\\n\\n    pair<int,int> divide(vector<vector<int>>& adj,int src,int parent,int val,vector<int>& nums)\\n    {\\n        \\n        int sum = nums[src];\\n        int breaks = 0;\\n        for(int i:adj[src])\\n        {\\n            if(i != parent)\\n            {\\n                pair<int,int> temp = divide(adj,i,src,val,nums);\\n                sum += temp.first;\\n                breaks += temp.second;\\n            }\\n        }\\n\\n        if(sum == val)\\n        {\\n            return {0,breaks + 1};\\n        }\\n        else\\n        {\\n            return {sum,breaks};\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n            int sum = accumulate(nums.begin(),nums.end(),0);\\n            int n = nums.size();\\n            vector<int> div;\\n            vector<vector<int>> adj(n);\\n            for(auto v:edges)\\n            {\\n                adj[v[0]].push_back(v[1]);\\n                adj[v[1]].push_back(v[0]);\\n            }\\n\\n            for(int i=1;i*i <= sum;i++)\\n            {\\n                if(i*i == sum)\\n                {\\n                    div.push_back(i);\\n                }\\n                else if(sum%i == 0)\\n                {\\n                    div.push_back(i);\\n                    div.push_back(sum/i);\\n                }\\n            }\\n\\n            int ans = 0;\\n            for(int i:div)\\n            {\\n                pair<int,int> temp = divide(adj,0,-1,i,nums);\\n\\n                if(temp.first == 0)\\n                {\\n                ans = max(ans,temp.second - 1);\\n                \\n                }\\n            }\\n\\n            return ans;\\n\\n    }\\n\\n    pair<int,int> divide(vector<vector<int>>& adj,int src,int parent,int val,vector<int>& nums)\\n    {\\n        \\n        int sum = nums[src];\\n        int breaks = 0;\\n        for(int i:adj[src])\\n        {\\n            if(i != parent)\\n            {\\n                pair<int,int> temp = divide(adj,i,src,val,nums);\\n                sum += temp.first;\\n                breaks += temp.second;\\n            }\\n        }\\n\\n        if(sum == val)\\n        {\\n            return {0,breaks + 1};\\n        }\\n        else\\n        {\\n            return {sum,breaks};\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723418,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int size = nums.size();\\n        int sum = 0;\\n        for(int num: nums) sum += num;\\n            \\n        vector<vector<int>> e(size);\\n        for(vector<int>& edge: edges) {\\n            e[edge[0]].push_back(edge[1]);\\n            e[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<int> visited(size, 0);\\n        bool res;\\n        int target;\\n        function<int(int)> dfs = [&](int startNode) {\\n            if(!res) return 0;\\n            \\n            visited[startNode] = target;\\n            int sum = 0;\\n            for(int nextNode: e[startNode]) {\\n                if(visited[nextNode] != target) sum += dfs(nextNode);\\n            }\\n            \\n            sum += nums[startNode];\\n            if(sum > target) res = false;\\n            return sum >= target ? 0 : sum;\\n        };\\n        \\n        for(int div = size; div >= 2; div--) {\\n            if(sum % div) continue;\\n            \\n            res = true;\\n            target = sum / div;\\n            dfs(0);\\n            if(res) return div - 1;\\n        }\\n        \\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int size = nums.size();\\n        int sum = 0;\\n        for(int num: nums) sum += num;\\n            \\n        vector<vector<int>> e(size);\\n        for(vector<int>& edge: edges) {\\n            e[edge[0]].push_back(edge[1]);\\n            e[edge[1]].push_back(edge[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2720807,
                "title": "c-bfs-95-faster-commented-code-with-explanation",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool can_divide_evenly(int comp_val, queue<int> leaf_q, vector<int> cnt_nghbr, vector<int> nums, vector<vector<int>> &G) {\\n        // we will apply topological sort in some form,\\n        // roughly similar to BFS, by taking leaf nodes\\n        // and merging them to their parents.\\n        while(!leaf_q.empty()) {\\n            // only leaf nodes, i.e nodes with cnt_nghbr == 1\\n            // or degree == 1 will enter the queue\\n            int idx = leaf_q.front();\\n            leaf_q.pop();\\n            \\n            // since we are processing the leaf node, by merging\\n            // it into its nghbr decrease its cnt_nghbr to 0\\n            cnt_nghbr[idx]--;\\n            \\n            // 3 CASES\\n                \\n            // CASE 1: if value at idx is greater than the allowed\\n            // comp_val because of some reason, we can\\'t divide\\n            // evenly into components\\n            if(nums[idx] > comp_val)\\n                return false;\\n            \\n            for(int &nghbr: G[idx]) {\\n                \\n                // optimisation: if we\\'ve already processed a leaf node\\n                // i.e. if a node\\'s degree is zero we will not update its \\n                // value, becuase it doesn\\'t make sense as it will never\\n                // enter the queue again\\n                if(cnt_nghbr[nghbr] == 0)\\n                    continue;\\n                \\n                // CASE 2: if value at idx is equal to comp_val\\n                // just decrease the neighbout count, becuase\\n                // we just completed a component with desired value\\n                // and can act like we remove that edge\\n                else if(nums[idx] == comp_val)\\n                    cnt_nghbr[nghbr]--;\\n                \\n                // CASE 3: if value is less than the comp_val\\n                // we add the value to the parent/nghbr node\\n                // and decrease its neighbour\\'s degree by 1\\n                else {\\n                    nums[nghbr] += nums[idx];\\n                    cnt_nghbr[nghbr]--;\\n                }\\n                \\n                // if nghbr under consideration becomes leaf node\\n                // push it to the leaf queue\\n                if(cnt_nghbr[nghbr] == 1)\\n                    leaf_q.push(nghbr);\\n            }\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        \\n        // checking if graph contains all the same value\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        int max_ele = *max_element(nums.begin(), nums.end());\\n        if(sum % n == 0 && count(nums.begin(), nums.end(), sum/n) == n)\\n            return n-1;\\n        \\n        // make adjacency list for the tree(graph)\\n        vector<vector<int>> G(n);\\n        for(vector<int> &e: edges) {\\n            G[e[0]].push_back(e[1]);\\n            G[e[1]].push_back(e[0]);\\n        }\\n        \\n        // will store the indices of leaf nodes\\n        queue<int> leaf_q;\\n        // will sotre the count of neighbors of each node\\n        vector<int> cnt_nghbr(n, 0);\\n        for(int i = 0; i < n; ++i) {\\n            if(G[i].size() == 1) leaf_q.push(i);\\n            cnt_nghbr[i] += G[i].size();\\n        }\\n        \\n        // optimisations: \\n        // 1: start with minimum comp_val possible so that we \\n        //    can get the maximum possible number of components\\n        //    and hence can early stop our solution.\\n        // 2: comp_val can\\'t be less than the max element\\n        // 3: comp_val cna\\'t be more than sum\\n        //    i.e. only one component, no edges removed\\n        for(int comp_val = max_ele; comp_val <= sum; ++comp_val) {\\n            // if sum cannot be divided evenly into num_comp\\n            // with comp_val calues, then continue\\n            if(sum % comp_val) continue;\\n            int num_comp = sum / comp_val;\\n            // because to make \"num_comp\" componenets\\n            // we need to remove \"num_comp-1\" edges \\n            if(can_divide_evenly(comp_val, leaf_q, cnt_nghbr, nums, G)) return num_comp - 1;\\n        }\\n        \\n        // will never be called b/c in loop condition \\n        // is comp_val == sum, so it will return 0 anyways\\n        // there itself if needed\\n        return 0;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool can_divide_evenly(int comp_val, queue<int> leaf_q, vector<int> cnt_nghbr, vector<int> nums, vector<vector<int>> &G) {\\n        // we will apply topological sort in some form,\\n        // roughly similar to BFS, by taking leaf nodes\\n        // and merging them to their parents.\\n        while(!leaf_q.empty()) {\\n            // only leaf nodes, i.e nodes with cnt_nghbr == 1\\n            // or degree == 1 will enter the queue\\n            int idx = leaf_q.front();\\n            leaf_q.pop();\\n            \\n            // since we are processing the leaf node, by merging\\n            // it into its nghbr decrease its cnt_nghbr to 0\\n            cnt_nghbr[idx]--;\\n            \\n            // 3 CASES\\n                \\n            // CASE 1: if value at idx is greater than the allowed\\n            // comp_val because of some reason, we can\\'t divide\\n            // evenly into components\\n            if(nums[idx] > comp_val)\\n                return false;\\n            \\n            for(int &nghbr: G[idx]) {\\n                \\n                // optimisation: if we\\'ve already processed a leaf node\\n                // i.e. if a node\\'s degree is zero we will not update its \\n                // value, becuase it doesn\\'t make sense as it will never\\n                // enter the queue again\\n                if(cnt_nghbr[nghbr] == 0)\\n                    continue;\\n                \\n                // CASE 2: if value at idx is equal to comp_val\\n                // just decrease the neighbout count, becuase\\n                // we just completed a component with desired value\\n                // and can act like we remove that edge\\n                else if(nums[idx] == comp_val)\\n                    cnt_nghbr[nghbr]--;\\n                \\n                // CASE 3: if value is less than the comp_val\\n                // we add the value to the parent/nghbr node\\n                // and decrease its neighbour\\'s degree by 1\\n                else {\\n                    nums[nghbr] += nums[idx];\\n                    cnt_nghbr[nghbr]--;\\n                }\\n                \\n                // if nghbr under consideration becomes leaf node\\n                // push it to the leaf queue\\n                if(cnt_nghbr[nghbr] == 1)\\n                    leaf_q.push(nghbr);\\n            }\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size();\\n        \\n        // checking if graph contains all the same value\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        int max_ele = *max_element(nums.begin(), nums.end());\\n        if(sum % n == 0 && count(nums.begin(), nums.end(), sum/n) == n)\\n            return n-1;\\n        \\n        // make adjacency list for the tree(graph)\\n        vector<vector<int>> G(n);\\n        for(vector<int> &e: edges) {\\n            G[e[0]].push_back(e[1]);\\n            G[e[1]].push_back(e[0]);\\n        }\\n        \\n        // will store the indices of leaf nodes\\n        queue<int> leaf_q;\\n        // will sotre the count of neighbors of each node\\n        vector<int> cnt_nghbr(n, 0);\\n        for(int i = 0; i < n; ++i) {\\n            if(G[i].size() == 1) leaf_q.push(i);\\n            cnt_nghbr[i] += G[i].size();\\n        }\\n        \\n        // optimisations: \\n        // 1: start with minimum comp_val possible so that we \\n        //    can get the maximum possible number of components\\n        //    and hence can early stop our solution.\\n        // 2: comp_val can\\'t be less than the max element\\n        // 3: comp_val cna\\'t be more than sum\\n        //    i.e. only one component, no edges removed\\n        for(int comp_val = max_ele; comp_val <= sum; ++comp_val) {\\n            // if sum cannot be divided evenly into num_comp\\n            // with comp_val calues, then continue\\n            if(sum % comp_val) continue;\\n            int num_comp = sum / comp_val;\\n            // because to make \"num_comp\" componenets\\n            // we need to remove \"num_comp-1\" edges \\n            if(can_divide_evenly(comp_val, leaf_q, cnt_nghbr, nums, G)) return num_comp - 1;\\n        }\\n        \\n        // will never be called b/c in loop condition \\n        // is comp_val == sum, so it will return 0 anyways\\n        // there itself if needed\\n        return 0;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2717812,
                "title": "cpp-time-100-concise-solution-with-topological-sort-and-bottom-up-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe already have many posts using DFS or BFS. Here is an approach using toplogical sort. According to the result, this approach beats 99.9+% w.r.t. time and 95+% w.r.t. space. As a result, we decide to share this post.\\n\\nGiven a target sum, we need to check whether it is possible to partition the tree so that each connected component meets such target. Our idea is quite simple: we always choose the node with least options (i.e. leaf). Either keep going or give up.\\n\\n1. If the value of current node \"*Less Than*\" the target, donate its value to its parent, remove the node from tree.\\n2. If the value of current node \"*Equals*\" the target, remove the subtree of current node, add 1 to the counter.\\n3. If the value of current node \"*Greater Than*\" the target, FAIL.\\n4. Repeat Step 1~3 on next leaf.\\n\\nAs you all known, topological sort can give us such an order and meanwhile we can determine the parent of each node (except for the root) accordingly.\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis is the worst case estimation. The first N is calculated based on the possible numbers of components (we have at most n components). The second N is the number of nodes. Generally, the real performance is much better than this estimation.\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nint n;\\nint top [20000];\\nint cnt [20000];\\nint par [20000];\\nclass Solution {\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        n=nums.size();\\n        if(n==1)\\n            return 0;\\n        int m=0, ans=0, tar=0, sum=0;\\n        vector<vector<int>> edge (n); \\n        for(int i=0; i<n; ++i) {\\n            cnt[i]=0;\\n            par[i]=-1;\\n            sum+=nums[i];\\n            tar=max(tar, nums[i]);\\n        }\\n        //topo sort + parent of tree\\n        for(int i=0; i<n-1; ++i) {\\n            ++cnt[edges[i][0]];\\n            ++cnt[edges[i][1]];\\n            edge[edges[i][0]].push_back(edges[i][1]);\\n            edge[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0; i<n; ++i) {\\n            if(cnt[i]==1) {\\n                top[m++]=i;\\n            }\\n        }\\n        for(int i=0; i<n; ++i) {\\n            for(int p : edge[top[i]]) {\\n                if(par[p]<0) {\\n                    par[top[i]]=p;\\n                }\\n                if(--cnt[p]==1) {\\n                    top[m++]=p;\\n                }\\n            }\\n        }\\n        //check\\n        for(int i, j, k, m=sum/tar; m && !ans; --m) {\\n            if(sum%m==0) {\\n                tar=sum/m;\\n                for(i=0; i<n; ++i) {\\n                    cnt[i]=nums[i];\\n                }\\n                for(i=0, k=-1; i<n; ++i) {\\n                    j=top[i];\\n                    if(cnt[j]>tar) {\\n                        // cout<<j<<\":FAIL\";\\n                        k=-1;\\n                        break;\\n                    } else if(cnt[j]==tar) {\\n                        // cout<<j<<\":REM |\";\\n                        ++k;\\n                    } else {\\n                        cnt[par[j]]+=cnt[j];\\n                        // cout<<j<<\",\";\\n                    }\\n                }\\n                // cout<<\"~\"<<k<<\"\\\\n\";\\n                ans=max(ans, k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Topological Sort"
                ],
                "code": "```\\nint n;\\nint top [20000];\\nint cnt [20000];\\nint par [20000];\\nclass Solution {\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        n=nums.size();\\n        if(n==1)\\n            return 0;\\n        int m=0, ans=0, tar=0, sum=0;\\n        vector<vector<int>> edge (n); \\n        for(int i=0; i<n; ++i) {\\n            cnt[i]=0;\\n            par[i]=-1;\\n            sum+=nums[i];\\n            tar=max(tar, nums[i]);\\n        }\\n        //topo sort + parent of tree\\n        for(int i=0; i<n-1; ++i) {\\n            ++cnt[edges[i][0]];\\n            ++cnt[edges[i][1]];\\n            edge[edges[i][0]].push_back(edges[i][1]);\\n            edge[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0; i<n; ++i) {\\n            if(cnt[i]==1) {\\n                top[m++]=i;\\n            }\\n        }\\n        for(int i=0; i<n; ++i) {\\n            for(int p : edge[top[i]]) {\\n                if(par[p]<0) {\\n                    par[top[i]]=p;\\n                }\\n                if(--cnt[p]==1) {\\n                    top[m++]=p;\\n                }\\n            }\\n        }\\n        //check\\n        for(int i, j, k, m=sum/tar; m && !ans; --m) {\\n            if(sum%m==0) {\\n                tar=sum/m;\\n                for(i=0; i<n; ++i) {\\n                    cnt[i]=nums[i];\\n                }\\n                for(i=0, k=-1; i<n; ++i) {\\n                    j=top[i];\\n                    if(cnt[j]>tar) {\\n                        // cout<<j<<\":FAIL\";\\n                        k=-1;\\n                        break;\\n                    } else if(cnt[j]==tar) {\\n                        // cout<<j<<\":REM |\";\\n                        ++k;\\n                    } else {\\n                        cnt[par[j]]+=cnt[j];\\n                        // cout<<j<<\",\";\\n                    }\\n                }\\n                // cout<<\"~\"<<k<<\"\\\\n\";\\n                ans=max(ans, k);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2716676,
                "title": "only-do-n-times-dfs-cpp-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    vector<vector<int>> g;\\n    \\n    int dfs(int idx, int parent, const int target){\\n        int val = arr[idx];\\n        for(auto nbr : g[idx]){\\n            if(nbr == parent) continue;\\n            val += dfs(nbr,idx,target);\\n        }\\n        \\n        if(val == target) return 0;   // we find any one componets give me target value then return 0 bcz we consider that one components\\n        return val;\\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size(), ttl_sum = 0, res = 0;\\n        arr.resize(n); g.resize(n);\\n        \\n        // Create graph using given edges\\n        for(auto i : edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        \\n        // Finding total sum of all nodes value \\n        for(int i = 0; i<n; i++){\\n            ttl_sum += nums[i];\\n            arr[i] = nums[i];\\n        }\\n        // We find one by one components with target sum % p ---> 1 <= p <= no of nodes\\n        // bcz we find min one components and max no of nodes components of same value\\n        // that\\'s why we do n time dfs to find we get sum % p vlaue components or not\\n        for(int p = 1; p <= n; p++){\\n            if(ttl_sum % p != 0) continue;\\n            // we get return 0 then we said we create p components of same values and deleted p-1 edges in a tree or graph\\n            if(dfs(0,-1,ttl_sum/p) != 0) continue;\\n            res = max(res,p-1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    vector<vector<int>> g;\\n    \\n    int dfs(int idx, int parent, const int target){\\n        int val = arr[idx];\\n        for(auto nbr : g[idx]){\\n            if(nbr == parent) continue;\\n            val += dfs(nbr,idx,target);\\n        }\\n        \\n        if(val == target) return 0;   // we find any one componets give me target value then return 0 bcz we consider that one components\\n        return val;\\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int n = nums.size(), ttl_sum = 0, res = 0;\\n        arr.resize(n); g.resize(n);\\n        \\n        // Create graph using given edges\\n        for(auto i : edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        \\n        // Finding total sum of all nodes value \\n        for(int i = 0; i<n; i++){\\n            ttl_sum += nums[i];\\n            arr[i] = nums[i];\\n        }\\n        // We find one by one components with target sum % p ---> 1 <= p <= no of nodes\\n        // bcz we find min one components and max no of nodes components of same value\\n        // that\\'s why we do n time dfs to find we get sum % p vlaue components or not\\n        for(int p = 1; p <= n; p++){\\n            if(ttl_sum % p != 0) continue;\\n            // we get return 0 then we said we create p components of same values and deleted p-1 edges in a tree or graph\\n            if(dfs(0,-1,ttl_sum/p) != 0) continue;\\n            res = max(res,p-1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715696,
                "title": "c-dfs-with-explanation-and-comments",
                "content": "```\\nclass Solution {\\n    /*\\n    First, for a number n, the number of divisors of n is O(n^(1/3)). For this problem, the maximum sum of the values in the\\n    tree is 2*10^4 * 50 = 10^6, and the maximum number of divisors here is O(100), with this number, we could consider \\n    iterating through all the divisors of the sum to find the result.\\n    \\n    Then we come to the main part of this problem, how to check if the tree can be divided into components of same value, where the\\n    number fo the components equal to a specific divisor?\\n    \\n    With tree problem, it is intuitive to use bfs/dfs here. I am using dfs here, since it is easier to work with recursion. The dfs algorithm\\n    is shown below, notice that this is a similar dfs algorithm for calculating the size of a tree, we just change size to value here.\\n    \\n    The time complexity is O(n logmn), where n is the number of nodes and m is the maximum value in nums.\\n        O(n) is the time complexity for one dfs traversal and O(logmn) is the maximum number of divisors.\\n    \\n    The auxiliary space complexity is O(n) with:\\n        dfs recursion activation record: O(n)\\n        neighbors lists: O(n)\\n    */\\n    \\n    int dfs(vector<int>& nums, vector<vector<int>>& neighbors, int i, int parent, int target) {\\n        // if the subtree with root i can be divided into components with same value target, then we return 0\\n        int value = nums[i];\\n        for (int neighbor : neighbors[i]) {\\n            if (neighbor != parent) {\\n                int temp = dfs(nums, neighbors, neighbor, i, target);\\n                if (temp == -1) return temp; // if the subtree is invalid, then the whole tree must be also invalid\\n                value += temp;\\n            }\\n        }\\n        if (value > target) return -1;  // invalid subtree\\n        if (value == target) return 0;  // find a matched component, cut off the subtree\\n        return value;\\n    }\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        // step 1: find the total sum of the tree\\n        int sumVal = accumulate(nums.begin(), nums.end(), 0);\\n        \\n        // step 2: construct the neighbors lists for each of the node in the tree\\n        int n = nums.size();\\n        vector<vector<int>> neighbors(n);\\n        for (vector<int>& edge : edges) {\\n            neighbors[edge[0]].push_back(edge[1]);\\n            neighbors[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        // step 3: traverse all the divisors and perform a dfs to check if we can\\n        //  devide the tree into i components, where i is the divisor\\n        for (int i = n; i > 1; i--) {\\n            if (sumVal % i == 0) {\\n                if (dfs(nums, neighbors, 0, -1, sumVal / i) == 0) return i - 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    First, for a number n, the number of divisors of n is O(n^(1/3)). For this problem, the maximum sum of the values in the\\n    tree is 2*10^4 * 50 = 10^6, and the maximum number of divisors here is O(100), with this number, we could consider \\n    iterating through all the divisors of the sum to find the result.\\n    \\n    Then we come to the main part of this problem, how to check if the tree can be divided into components of same value, where the\\n    number fo the components equal to a specific divisor?\\n    \\n    With tree problem, it is intuitive to use bfs/dfs here. I am using dfs here, since it is easier to work with recursion. The dfs algorithm\\n    is shown below, notice that this is a similar dfs algorithm for calculating the size of a tree, we just change size to value here.\\n    \\n    The time complexity is O(n logmn), where n is the number of nodes and m is the maximum value in nums.\\n        O(n) is the time complexity for one dfs traversal and O(logmn) is the maximum number of divisors.\\n    \\n    The auxiliary space complexity is O(n) with:\\n        dfs recursion activation record: O(n)\\n        neighbors lists: O(n)\\n    */\\n    \\n    int dfs(vector<int>& nums, vector<vector<int>>& neighbors, int i, int parent, int target) {\\n        // if the subtree with root i can be divided into components with same value target, then we return 0\\n        int value = nums[i];\\n        for (int neighbor : neighbors[i]) {\\n            if (neighbor != parent) {\\n                int temp = dfs(nums, neighbors, neighbor, i, target);\\n                if (temp == -1) return temp; // if the subtree is invalid, then the whole tree must be also invalid\\n                value += temp;\\n            }\\n        }\\n        if (value > target) return -1;  // invalid subtree\\n        if (value == target) return 0;  // find a matched component, cut off the subtree\\n        return value;\\n    }\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        // step 1: find the total sum of the tree\\n        int sumVal = accumulate(nums.begin(), nums.end(), 0);\\n        \\n        // step 2: construct the neighbors lists for each of the node in the tree\\n        int n = nums.size();\\n        vector<vector<int>> neighbors(n);\\n        for (vector<int>& edge : edges) {\\n            neighbors[edge[0]].push_back(edge[1]);\\n            neighbors[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        // step 3: traverse all the divisors and perform a dfs to check if we can\\n        //  devide the tree into i components, where i is the divisor\\n        for (int i = n; i > 1; i--) {\\n            if (sumVal % i == 0) {\\n                if (dfs(nums, neighbors, 0, -1, sumVal / i) == 0) return i - 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713187,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    \\n    vector<vector<int>> graph;\\n    \\n    int dfs(int src, int parent, int target, vector<int>& nums)\\n    {\\n        int sum = nums[src];\\n        \\n        for(auto &x: graph[src])\\n        {\\n            if(x != parent)\\n            {\\n                sum += dfs(x,src,target, nums);\\n            }\\n        }\\n        \\n        if(sum == target)\\n        {\\n            return 0;\\n        }\\n        \\n        return sum;\\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) \\n    {\\n        \\n        int n =  nums.size();\\n        \\n        graph.resize(n);\\n        \\n        for(auto &x: edges)\\n        {\\n            graph[x[0]].push_back(x[1]);\\n            graph[x[1]].push_back(x[0]);\\n        }\\n        \\n        int sum = accumulate(nums.begin(),nums.end(), 0);\\n        \\n        for(int i=sum; i>=1; i--)\\n        {\\n            if(sum % i == 0)\\n            {\\n                if(dfs(0,-1, sum/ i, nums) == 0)\\n                {\\n                    return i-1;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    vector<vector<int>> graph;\\n    \\n    int dfs(int src, int parent, int target, vector<int>& nums)\\n    {\\n        int sum = nums[src];\\n        \\n        for(auto &x: graph[src])\\n        {\\n            if(x != parent)\\n            {\\n                sum += dfs(x,src,target, nums);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2713018,
                "title": "python-no-fancy-stuff-just-plain-dfs-on-tree-root",
                "content": "```\\ndef componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        N, s = len(nums), sum(nums)\\n        G = defaultdict(list)\\n        \\n        for u, v in edges:\\n            G[u].append(v)\\n            G[v].append(u)\\n            \\n        def dfs(i, tar, par):\\n            total = nums[i]\\n            for c in G[i]:\\n                if c == par: continue \\n                res = dfs(c, tar, i)\\n                total += res \\n            if total == tar:\\n                return 0   \\n            return total \\n\\n        for i in range(s, 0, -1):\\n            if s % i != 0: continue \\n            res = dfs(0, s // i, -1)\\n            if res != 0: continue\\n            return i - 1   \\n        return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\ndef componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        N, s = len(nums), sum(nums)\\n        G = defaultdict(list)\\n        \\n        for u, v in edges:\\n            G[u].append(v)\\n            G[v].append(u)\\n            \\n        def dfs(i, tar, par):\\n            total = nums[i]\\n            for c in G[i]:\\n                if c == par: continue \\n                res = dfs(c, tar, i)\\n                total += res \\n            if total == tar:\\n                return 0   \\n            return total \\n\\n        for i in range(s, 0, -1):\\n            if s % i != 0: continue \\n            res = dfs(0, s // i, -1)\\n            if res != 0: continue\\n            return i - 1   \\n        return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2712321,
                "title": "python-beats-100-time",
                "content": "```\\n\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def componentValue(self, nums, edges):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type edges: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        graph = defaultdict(list)\\n        for edge in edges:\\n            graph[edge[1]].append(edge[0])\\n            graph[edge[0]].append(edge[1])\\n        \\n        total_sum = sum(nums)\\n        visited = set()\\n        cut_value = 0\\n        ans = 0\\n\\n        def isPossible(index):\\n            nonlocal cut_value, ans\\n            visited.add(index)\\n            elem = nums[index]\\n            sum_children = elem\\n            for child in graph[index]:\\n                if child not in visited:\\n                    sum_children += isPossible(child)\\n\\n            if sum_children == cut_value:\\n                ans += 1\\n                return 0\\n            if sum_children > cut_value:\\n                return float(\\'inf\\')\\n            return sum_children\\n        \\n        min_start = min(nums)\\n        for i in range(min_start, total_sum//2+1):\\n            if total_sum%i == 0:\\n                ans = 0\\n                cut_value = i\\n                visited = set()\\n                if isPossible(0) == 0:\\n                    return ans-1\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\n\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def componentValue(self, nums, edges):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type edges: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        graph = defaultdict(list)\\n        for edge in edges:\\n            graph[edge[1]].append(edge[0])\\n            graph[edge[0]].append(edge[1])\\n        \\n        total_sum = sum(nums)\\n        visited = set()\\n        cut_value = 0\\n        ans = 0\\n\\n        def isPossible(index):\\n            nonlocal cut_value, ans\\n            visited.add(index)\\n            elem = nums[index]\\n            sum_children = elem\\n            for child in graph[index]:\\n                if child not in visited:\\n                    sum_children += isPossible(child)\\n\\n            if sum_children == cut_value:\\n                ans += 1\\n                return 0\\n            if sum_children > cut_value:\\n                return float(\\'inf\\')\\n            return sum_children\\n        \\n        min_start = min(nums)\\n        for i in range(min_start, total_sum//2+1):\\n            if total_sum%i == 0:\\n                ans = 0\\n                cut_value = i\\n                visited = set()\\n                if isPossible(0) == 0:\\n                    return ans-1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711401,
                "title": "easy-to-understand-o-n-sqrt-sum-solution-c",
                "content": "Inspired from https://leetcode.com/problems/create-components-with-same-value/discuss/2706628/C%2B%2B-easy-DFS\\n\\n```\\nTime complexity = O(N*sqrt(sum))\\n\\nclass Solution {\\n    int dfs(int cur, int target, vector<int>& nums, vector<bool>& vis, vector<int> graph[]) {\\n        int val = nums[cur];\\n        vis[cur] = true;\\n        \\n        for(auto it: graph[cur]) {\\n            \\n            if(vis[it]) continue;\\n            \\n            val += dfs(it, target, nums, vis, graph);\\n        }\\n        \\n        if(val == target) return 0;\\n        \\n        return val;\\n    }\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        \\n        int n = nums.size();\\n        vector<int> graph[n + 1];\\n        \\n        for(auto it: edges) {\\n            graph[it[0]].push_back(it[1]);\\n            graph[it[1]].push_back(it[0]);\\n        }\\n        \\n        int sum = 0;\\n        \\n        for(int it: nums) sum += it;\\n        \\n        for(int i = n; i > 1; i--) { \\n            // greater than 1 in loop beacuse there has to be more than one component, then only we can delete edges\\n            \\n            if(sum % i) continue;\\n            \\n            vector<bool> vis(n, false);\\n            \\n            if(dfs(i, sum/i, nums, vis, graph) == 0) return (i - 1); // equal components minus 1\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nTime complexity = O(N*sqrt(sum))\\n\\nclass Solution {\\n    int dfs(int cur, int target, vector<int>& nums, vector<bool>& vis, vector<int> graph[]) {\\n        int val = nums[cur];\\n        vis[cur] = true;\\n        \\n        for(auto it: graph[cur]) {\\n            \\n            if(vis[it]) continue;\\n            \\n            val += dfs(it, target, nums, vis, graph);\\n        }\\n        \\n        if(val == target) return 0;\\n        \\n        return val;\\n    }\\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        \\n        int n = nums.size();\\n        vector<int> graph[n + 1];\\n        \\n        for(auto it: edges) {\\n            graph[it[0]].push_back(it[1]);\\n            graph[it[1]].push_back(it[0]);\\n        }\\n        \\n        int sum = 0;\\n        \\n        for(int it: nums) sum += it;\\n        \\n        for(int i = n; i > 1; i--) { \\n            // greater than 1 in loop beacuse there has to be more than one component, then only we can delete edges\\n            \\n            if(sum % i) continue;\\n            \\n            vector<bool> vis(n, false);\\n            \\n            if(dfs(i, sum/i, nums, vis, graph) == 0) return (i - 1); // equal components minus 1\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710555,
                "title": "javascript-dfs-faster-than-100",
                "content": "```\\nvar componentValue = function (nums, edges) {\\n  const size = nums.length;\\n  const graph = Array(size)\\n    .fill()\\n    .map(() => []);\\n  \\n  const sum = nums.reduce((sum, num) => num + sum, 0);\\n\\n  for (let [A, B] of edges) {\\n    graph[A].push(B);\\n    graph[B].push(A);\\n  }\\n\\n  for (let i = size; i >= 2; i--) {\\n    if (sum % i == 0) {\\n      if (can(nums, graph, sum / i)) return i - 1;\\n    }\\n  }\\n\\n  return 0;\\n};\\n\\nconst can = (nums, graph, target) => {\\n  const n = nums.length;\\n  const visited = new Set();\\n  const dfs = (v) => {\\n    visited[v] = true;\\n    let sum = 0;\\n    for (let u of graph[v])\\n      if (!visited[u]) {\\n        let k = dfs(u);\\n        if (k != target) sum += k;\\n      }\\n    return sum + nums[v];\\n  };\\n  return dfs(0) == target;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nvar componentValue = function (nums, edges) {\\n  const size = nums.length;\\n  const graph = Array(size)\\n    .fill()\\n    .map(() => []);\\n  \\n  const sum = nums.reduce((sum, num) => num + sum, 0);\\n\\n  for (let [A, B] of edges) {\\n    graph[A].push(B);\\n    graph[B].push(A);\\n  }\\n\\n  for (let i = size; i >= 2; i--) {\\n    if (sum % i == 0) {\\n      if (can(nums, graph, sum / i)) return i - 1;\\n    }\\n  }\\n\\n  return 0;\\n};\\n\\nconst can = (nums, graph, target) => {\\n  const n = nums.length;\\n  const visited = new Set();\\n  const dfs = (v) => {\\n    visited[v] = true;\\n    let sum = 0;\\n    for (let u of graph[v])\\n      if (!visited[u]) {\\n        let k = dfs(u);\\n        if (k != target) sum += k;\\n      }\\n    return sum + nums[v];\\n  };\\n  return dfs(0) == target;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2710090,
                "title": "cpp-simple-dfs",
                "content": "1. First Compute the sum of all the nodes and do factorisation because the resulted component sum will always be one of the factors of the total sum of all nodes.\\n\\n2. As the number of factors cannot exceed 250, so we can brute force for each factor and check if it is possible to Create Components With Same Value.\\n\\n3. Now the remaining task is how to check if tree can be break into components with equal sum,\\n    Do dfs if we found subtree sum as target_sum then increment the totalComponents and also make this subtree sum as 0 because to ensure that its ancestor doesn\\'t include this subtree again.\\n\\nif target_sum * totalComponents == total_sum of all nodes then\\nans = max(ans, totalComponents - 1)\\n\\n\\n```cpp\\nconst int Max = 2e4 + 10;\\nvector<int> adj[Max];\\nvector<int> subSum;\\n\\nclass Solution {\\npublic:\\n    int totalComp;\\n    void dfs(int cur, int par, int target, vector<int>& nums) {\\n        for (auto it : adj[cur]) {\\n            if (it != par) dfs(it, cur, target, nums);\\n        }\\n        \\n        subSum[cur] = nums[cur];\\n        for (auto it : adj[cur]) {\\n            if (it != par) subSum[cur] += subSum[it];\\n        }\\n        \\n        if (subSum[cur] == target) totalComp++, subSum[cur] = 0;\\n    }\\n    \\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int sum = 0;\\n        for (auto it : nums) sum += it;\\n        vector<int> div;\\n        for (int i = 1; i * i <= sum; ++i) {\\n            if (sum % i == 0) {\\n                div.push_back(i);\\n                if (sum / i != i) div.push_back(sum / i);\\n            }\\n        }\\n        \\n        sort(begin(div), end(div));\\n        \\n        int n = nums.size();\\n        subSum.resize(n);\\n        for (int i = 0; i < n; ++i) adj[i].clear();\\n        for (auto it : edges) {\\n            int u = it[0], v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        \\n        int ans = 0;\\n        for (auto it : div) {\\n            int target = it;\\n            \\n            totalComp = 0;\\n            for (int i = 0; i < n; ++i) subSum[i] = 0;\\n            dfs(0, -1, target, nums);\\n            \\n            if (totalComp * target == sum) {\\n                ans = max(ans, totalComp - 1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```cpp\\nconst int Max = 2e4 + 10;\\nvector<int> adj[Max];\\nvector<int> subSum;\\n\\nclass Solution {\\npublic:\\n    int totalComp;\\n    void dfs(int cur, int par, int target, vector<int>& nums) {\\n        for (auto it : adj[cur]) {\\n            if (it != par) dfs(it, cur, target, nums);\\n        }\\n        \\n        subSum[cur] = nums[cur];\\n        for (auto it : adj[cur]) {\\n            if (it != par) subSum[cur] += subSum[it];\\n        }\\n        \\n        if (subSum[cur] == target) totalComp++, subSum[cur] = 0;\\n    }\\n    \\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        int sum = 0;\\n        for (auto it : nums) sum += it;\\n        vector<int> div;\\n        for (int i = 1; i * i <= sum; ++i) {\\n            if (sum % i == 0) {\\n                div.push_back(i);\\n                if (sum / i != i) div.push_back(sum / i);\\n            }\\n        }\\n        \\n        sort(begin(div), end(div));\\n        \\n        int n = nums.size();\\n        subSum.resize(n);\\n        for (int i = 0; i < n; ++i) adj[i].clear();\\n        for (auto it : edges) {\\n            int u = it[0], v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        \\n        int ans = 0;\\n        for (auto it : div) {\\n            int target = it;\\n            \\n            totalComp = 0;\\n            for (int i = 0; i < n; ++i) subSum[i] = 0;\\n            dfs(0, -1, target, nums);\\n            \\n            if (totalComp * target == sum) {\\n                ans = max(ans, totalComp - 1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708847,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n//     start from leaf nodes and add its value to its neighbour checking if this can be added to it or not\\n//     check only for those values whose total sum% (size we want to divide is zero)\\n    \\n    bool bfs(int sum, vector<vector<int>> &adj, vector<int> nums, queue<int> q, vector<int> cnt){\\n        while(!q.empty()){\\n            int val = q.front();\\n            q.pop();\\n            if(nums[val] > sum) return false;  // self value jayada hojaye\\n            for(auto it: adj[val]){\\n                if(nums[val] < sum)\\n                 nums[it] += nums[val];\\n                 cnt[it] -= 1;\\n                 if(cnt[it] == 1) q.push(it);\\n                \\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(nums.size());\\n        queue<int> q;\\n        vector<int> cnt(nums.size());\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        for(int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i = 0; i < adj.size(); i++){\\n            cnt[i] = adj[i].size();\\n            if(adj[i].size() == 1) q.push(i);\\n        }\\n        for(int i = nums.size(); i >= 1; i--){\\n            if(sum%i == 0 && bfs(sum/i, adj, nums, q, cnt))\\n                 return i - 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//     start from leaf nodes and add its value to its neighbour checking if this can be added to it or not\\n//     check only for those values whose total sum% (size we want to divide is zero)\\n    \\n    bool bfs(int sum, vector<vector<int>> &adj, vector<int> nums, queue<int> q, vector<int> cnt){\\n        while(!q.empty()){\\n            int val = q.front();\\n            q.pop();\\n            if(nums[val] > sum) return false;  // self value jayada hojaye\\n            for(auto it: adj[val]){\\n                if(nums[val] < sum)\\n                 nums[it] += nums[val];\\n                 cnt[it] -= 1;\\n                 if(cnt[it] == 1) q.push(it);\\n                \\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        vector<vector<int>> adj(nums.size());\\n        queue<int> q;\\n        vector<int> cnt(nums.size());\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        for(int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i = 0; i < adj.size(); i++){\\n            cnt[i] = adj[i].size();\\n            if(adj[i].size() == 1) q.push(i);\\n        }\\n        for(int i = nums.size(); i >= 1; i--){\\n            if(sum%i == 0 && bfs(sum/i, adj, nums, q, cnt))\\n                 return i - 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707607,
                "title": "making-each-component-s-sum-factor-of-sum-of-entire-tree",
                "content": "class Solution {\\npublic:\\n    bool ok=1;\\n    int del=0;\\n    int dfs(int x,int par,vector<vector<int>> &G,int val,vector<int> &nums)\\n    {\\n  if(ok==0)\\n      return 0;\\n        vector<int> v1;\\n        int ss=0;\\n    for(auto xx:G[x])\\n    {\\n     if(xx!=par)\\n     {\\n         \\n         ss+=dfs(xx,x,G,val,nums);\\n     }\\n    }\\n        \\n       \\n       \\n        if(ss+nums[x]==val)\\n        {\\n            cout<<ss+nums[x]<<endl;\\n            del++;\\n            return 0;\\n        }\\n        else\\n        {\\n           if(ss+nums[x]>val)\\n           {\\n               ok=0;\\n           }\\n            return nums[x]+ss;\\n            \\n        }\\n        \\n        \\n        \\n    }\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        \\n        int sum=0;\\n        int n=nums.size();\\n        for(auto x:nums)\\n        {\\n            sum+=x;\\n        }\\n        vector<vector<int>> G(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            G[edges[i][0]].push_back(edges[i][1]);\\n            G[edges[i][1]].push_back(edges[i][0]);\\n            \\n        }\\n        int low=0,high=sum,mid;\\n        int mx=0;\\n        \\n            mx=0;\\n     \\n       \\n        \\n       for(int i=1;i*i<=sum;i++)\\n       {\\n           \\n           del=0;\\n           if(sum%i==0)\\n           {\\n              \\n               del=0;\\n               ok=1;\\n               int pp=dfs(0,-1,G,i,nums);\\n               \\n            if(pp!=0)\\n                ok=0;\\n               if(ok)\\n                   mx=max(mx,del-1);\\n              \\n               del=0;\\n               ok=1;\\n             \\n             pp=dfs(0,-1,G,sum/i,nums);\\n               \\n            if(pp!=0)\\n                ok=0;\\n              \\n               if(ok)\\n                   mx=max(mx,del-1);\\n               \\n               \\n           }\\n            \\n           \\n       }\\n        \\n            return mx;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    bool ok=1;\\n    int del=0;\\n    int dfs(int x,int par,vector<vector<int>> &G,int val,vector<int> &nums)\\n    {\\n  if(ok==0)\\n      return 0;\\n        vector<int> v1;\\n        int ss=0;\\n    for(auto xx:G[x])\\n    {\\n     if(xx!=par)\\n     {\\n         \\n         ss+=dfs(xx,x,G,val,nums);\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 2707489,
                "title": "bfs",
                "content": "If u are unable to understanf see the pictures on https://leetcode.com/problems/create-components-with-same-value/discuss/2706736/Python-Explanation-with-pictures-BFS\\n\\n```\\nclass Solution {\\n    vector<int>adj[20000];\\n    int n;\\n    int deg[20000]={0};\\n    bool bfs(int reqSum,vector<int>num){\\n        queue<int>pq;\\n        int Deg[20000];\\n        copy_n(deg,n,Deg);\\n        for(int i = 0;i<n;i++)\\n            if(Deg[i]==1) //taking all nodes having degree 1, i.e, leaf nodes\\n                pq.push(i);\\n        while(pq.size()){\\n            int node = pq.front();pq.pop();\\n            if(num[node]>reqSum) return 0;//the graph cant be broken to components having sum = reqSum\\n            Deg[node]--;\\n            for(auto &par:adj[node]){\\n                if(Deg[par]>0){\\n                    Deg[par]--;\\n                    if(num[node]!=reqSum)//If value of node is not equal to reqSum, we pass its value to is child or parent\\n                        num[par]+=num[node];\\n                    if(Deg[par]==0) //last node\\n                        return num[par]==reqSum;\\n                    if(Deg[par]==1) //append it to queue\\n                        pq.push(par);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        n = nums.size();\\n        if(n==1) return 0;\\n        \\n        for(auto &e:edges){\\n            deg[e[0]]++;\\n            deg[e[1]]++;\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        int sum = accumulate(nums.begin(),nums.end(),0);\\n        int maxx = *max_element(nums.begin(),nums.end());\\n        for(int i = maxx;i<sum;i++)\\n            if(sum%i==0 && bfs(i,nums))\\n                return sum/i-1;\\n        \\n        return 0;//We cant delete any edge\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<int>adj[20000];\\n    int n;\\n    int deg[20000]={0};\\n    bool bfs(int reqSum,vector<int>num){\\n        queue<int>pq;\\n        int Deg[20000];\\n        copy_n(deg,n,Deg);\\n        for(int i = 0;i<n;i++)\\n            if(Deg[i]==1) //taking all nodes having degree 1, i.e, leaf nodes\\n                pq.push(i);\\n        while(pq.size()){\\n            int node = pq.front();pq.pop();\\n            if(num[node]>reqSum) return 0;//the graph cant be broken to components having sum = reqSum\\n            Deg[node]--;\\n            for(auto &par:adj[node]){\\n                if(Deg[par]>0){\\n                    Deg[par]--;\\n                    if(num[node]!=reqSum)//If value of node is not equal to reqSum, we pass its value to is child or parent\\n                        num[par]+=num[node];\\n                    if(Deg[par]==0) //last node\\n                        return num[par]==reqSum;\\n                    if(Deg[par]==1) //append it to queue\\n                        pq.push(par);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\npublic:\\n    int componentValue(vector<int>& nums, vector<vector<int>>& edges) {\\n        n = nums.size();\\n        if(n==1) return 0;\\n        \\n        for(auto &e:edges){\\n            deg[e[0]]++;\\n            deg[e[1]]++;\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        int sum = accumulate(nums.begin(),nums.end(),0);\\n        int maxx = *max_element(nums.begin(),nums.end());\\n        for(int i = maxx;i<sum;i++)\\n            if(sum%i==0 && bfs(i,nums))\\n                return sum/i-1;\\n        \\n        return 0;//We cant delete any edge\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707161,
                "title": "pass-all-test-case-but-misjudgment-is-possible",
                "content": "\\n\\n\\n```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        maxnum, total = max(nums), sum(nums)\\n        #print(maxnum, total , 19999, total / (19999+1))\\n        g = defaultdict(set)\\n        for l, r in edges:\\n            g[l].add(r)\\n            g[r].add(l)\\n        v = defaultdict(lambda: -1)\\n        def ev(l, r):\\n            nonlocal total, g\\n            if v[(l, r)] == -1:\\n                if v[(r, l)] != -1:\\n                    v[(l, r)] = total - v[(r, l)]\\n                elif len(g[l]) == 1:\\n                    v[(l, r)] = nums[l]\\n                    v[(r, l)] = total - nums[l]\\n                elif len(g[r]) == 1:\\n                    v[(r, l)] = nums[r]\\n                    v[(l, r)] = total - nums[r]\\n                else:\\n                    v[(l, r)] = sum(ev(j, l) for j in g[l] if j != r) + nums[l]\\n                    v[(r, l)] = total - v[(l, r)]\\n            return v[(l, r)]\\n        #\\n        for l,r in edges:\\n            if v[(l, r)] == -1 or v[(r, l)] == -1:\\n                #print(ev(l,r), ev(r, l), (l,r ))\\n                ev(l,r) \\n                pass\\n        #print(v)\\n        v0 =  (Counter(v.values()))\\n        #print(maxnum, total, v0)\\n        for v in range(maxnum, total//2+1):\\n            if total % v:\\n                continue\\n            if any (_ not in v0.keys() or v0[_] < 2 for _ in range(v, min(total, v * 30),v) ):\\n                #if v == 36:\\n                    #print(list((_, _ not in v0.keys(), v0[_] , total // v) for _ in range(v, total,v) if (_ not in v0.keys() or v0[_] < 2)))\\n                continue\\n            \\n            #print(v, total, total // v )\\n            pass\\n            return total // v - 1\\n        else:\\n            return 0\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        maxnum, total = max(nums), sum(nums)\\n        #print(maxnum, total , 19999, total / (19999+1))\\n        g = defaultdict(set)\\n        for l, r in edges:\\n            g[l].add(r)\\n            g[r].add(l)\\n        v = defaultdict(lambda: -1)\\n        def ev(l, r):\\n            nonlocal total, g\\n            if v[(l, r)] == -1:\\n                if v[(r, l)] != -1:\\n                    v[(l, r)] = total - v[(r, l)]\\n                elif len(g[l]) == 1:\\n                    v[(l, r)] = nums[l]\\n                    v[(r, l)] = total - nums[l]\\n                elif len(g[r]) == 1:\\n                    v[(r, l)] = nums[r]\\n                    v[(l, r)] = total - nums[r]\\n                else:\\n                    v[(l, r)] = sum(ev(j, l) for j in g[l] if j != r) + nums[l]\\n                    v[(r, l)] = total - v[(l, r)]\\n            return v[(l, r)]\\n        #\\n        for l,r in edges:\\n            if v[(l, r)] == -1 or v[(r, l)] == -1:\\n                #print(ev(l,r), ev(r, l), (l,r ))\\n                ev(l,r) \\n                pass\\n        #print(v)\\n        v0 =  (Counter(v.values()))\\n        #print(maxnum, total, v0)\\n        for v in range(maxnum, total//2+1):\\n            if total % v:\\n                continue\\n            if any (_ not in v0.keys() or v0[_] < 2 for _ in range(v, min(total, v * 30),v) ):\\n                #if v == 36:\\n                    #print(list((_, _ not in v0.keys(), v0[_] , total // v) for _ in range(v, total,v) if (_ not in v0.keys() or v0[_] < 2)))\\n                continue\\n            \\n            #print(v, total, total // v )\\n            pass\\n            return total // v - 1\\n        else:\\n            return 0\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707138,
                "title": "factor-modified-dfs-easy-solution",
                "content": "# Approach\\n- If every node have same value then no edge need to be deleted.\\n- Now get the sum of all node value. When every component have same sum value. So we can try with every posible sum as target.\\n- If all the node value is positive integer then sum will be divided by target.\\n- We factorize sum and try with all factor as posible starting with the smallest one.\\n- If we found any target is fulfilled, we just break the loop for checking as we started with the smallest candidate for target.\\n\\n# Complexity\\n- Time complexity:\\n- o(nlogn)\\n\\n# Code\\n```\\nclass Solution {\\n    int dfs(int node, int[] par, ArrayList<ArrayList<Integer>> adj, int[] vis, int[] v, int tar)\\n    {\\n        par[node]=v[node];\\n        vis[node]=1;\\n        for(int itr: adj.get(node))\\n        {\\n            if(vis[itr]==0)\\n            {\\n                vis[itr]=1;\\n                par[node] += dfs(itr,par,adj,vis,v, tar);\\n                if(par[node] > tar) return 1000000;\\n            }\\n        }\\n        if(par[node] == tar) return 0;  // current subtree sum is target. So we can create another component from here\\n        return par[node];\\n    }\\n    ArrayList<Integer> Divisors(int n)\\n    {\\n        ArrayList<Integer> ret = new ArrayList<Integer>();\\n        for (int i=1; i<=Math.sqrt(n); i++)\\n        {\\n            if (n%i==0)\\n            {\\n                if (n/i == i)\\n                    ret.add(i);\\n      \\n                else{\\n                    ret.add(i);\\n                    ret.add(n/i);\\n                } // Otherwise print both\\n            }\\n        }\\n        return ret;\\n    }\\n    public int componentValue(int[] v, int[][] ed) {\\n        int n = v.length;        \\n        int sum=0, temp = 0;        \\n        boolean all = true;\\n        \\n        for(int i=0 ; i<n; i++){\\n            sum += v[i];\\n            if(i > 0){\\n                if(v[i] != v[i-1])\\n                    all = false;\\n            }\\n        }\\n        if(all){\\n            return n-1;\\n        }\\n        ArrayList<Integer> fac = Divisors(sum);\\n        if(fac.size() <= 2)  //sum of the nodes is prime.\\n            return 0;        \\n        \\n        int ans=0;\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i = 0; i < n;i++)\\n        {\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        for(int i = 0 ; i < n-1; i++){\\n            adj.get(ed[i][0]).add(ed[i][1]);\\n            adj.get(ed[i][1]).add(ed[i][0]);\\n        }\\n        Collections.sort(fac);\\n        //Try all posible factor of the sum as a target for every every component\\n        for(int i : fac){\\n            if(i > 1){\\n                int[] par = new int[n+1];\\n                Arrays.fill(par, -1);\\n                int[] vis = new int[n+1];\\n                if(dfs(0, par, adj, vis, v, i)==0){\\n                    int cc = sum/i;\\n                    return cc-1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int node, int[] par, ArrayList<ArrayList<Integer>> adj, int[] vis, int[] v, int tar)\\n    {\\n        par[node]=v[node];\\n        vis[node]=1;\\n        for(int itr: adj.get(node))\\n        {\\n            if(vis[itr]==0)\\n            {\\n                vis[itr]=1;\\n                par[node] += dfs(itr,par,adj,vis,v, tar);\\n                if(par[node] > tar) return 1000000;\\n            }\\n        }\\n        if(par[node] == tar) return 0;  // current subtree sum is target. So we can create another component from here\\n        return par[node];\\n    }\\n    ArrayList<Integer> Divisors(int n)\\n    {\\n        ArrayList<Integer> ret = new ArrayList<Integer>();\\n        for (int i=1; i<=Math.sqrt(n); i++)\\n        {\\n            if (n%i==0)\\n            {\\n                if (n/i == i)\\n                    ret.add(i);\\n      \\n                else{\\n                    ret.add(i);\\n                    ret.add(n/i);\\n                } // Otherwise print both\\n            }\\n        }\\n        return ret;\\n    }\\n    public int componentValue(int[] v, int[][] ed) {\\n        int n = v.length;        \\n        int sum=0, temp = 0;        \\n        boolean all = true;\\n        \\n        for(int i=0 ; i<n; i++){\\n            sum += v[i];\\n            if(i > 0){\\n                if(v[i] != v[i-1])\\n                    all = false;\\n            }\\n        }\\n        if(all){\\n            return n-1;\\n        }\\n        ArrayList<Integer> fac = Divisors(sum);\\n        if(fac.size() <= 2)  //sum of the nodes is prime.\\n            return 0;        \\n        \\n        int ans=0;\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for(int i = 0; i < n;i++)\\n        {\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        for(int i = 0 ; i < n-1; i++){\\n            adj.get(ed[i][0]).add(ed[i][1]);\\n            adj.get(ed[i][1]).add(ed[i][0]);\\n        }\\n        Collections.sort(fac);\\n        //Try all posible factor of the sum as a target for every every component\\n        for(int i : fac){\\n            if(i > 1){\\n                int[] par = new int[n+1];\\n                Arrays.fill(par, -1);\\n                int[] vis = new int[n+1];\\n                if(dfs(0, par, adj, vis, v, i)==0){\\n                    int cc = sum/i;\\n                    return cc-1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1657525,
                "content": [
                    {
                        "username": "yingfei_hong01",
                        "content": "Use BFS to cluster the trees with the same sum of values"
                    }
                ]
            }
        ]
    }
]