[
    {
        "title": "Combination Sum II",
        "question_content": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates&nbsp;where the candidate numbers sum to target.\nEach number in candidates&nbsp;may only be used once in the combination.\nNote:&nbsp;The solution set must not contain duplicate combinations.\n&nbsp;\nExample 1:\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\nExample 2:\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n&nbsp;\nConstraints:\n\n\t1 <=&nbsp;candidates.length <= 100\n\t1 <=&nbsp;candidates[i] <= 50\n\t1 <= target <= 30",
        "solutions": [
            {
                "id": 16878,
                "title": "combination-sum-i-ii-and-iii-java-solution-see-the-similarities-yourself",
                "content": "Combination Sum I\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n        return list;\\n    }\\n\\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n        if (remain < 0) return; /** no solution */\\n        else if (remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i < cand.length; i++) { \\n                tempList.add(cand[i]);\\n                backtrack(list, tempList, cand, remain-cand[i], i);\\n                tempList.remove(tempList.size()-1);\\n            } \\n        }\\n\\n    }\\n\\nCombination Sum II\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n       List<List<Integer>> list = new LinkedList<List<Integer>>();\\n       Arrays.sort(candidates);\\n       backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n       \\n       if(remain < 0) return; /** no solution */\\n       else if(remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for (int i = start; i < cand.length; i++) {\\n             if(i > start && cand[i] == cand[i-1]) continue; /** skip duplicates */\\n             tempList.add(cand[i]);\\n             backtrack(list, tempList, cand, remain - cand[i], i+1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n        if(tempList.size() > k) return; /** no solution */\\n        else if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i <= 9; i++) {\\n                tempList.add(i);\\n                backtrack(list, tempList, k, remain-i, i+1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Combination Sum I\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n        return list;\\n    }\\n\\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n        if (remain < 0) return; /** no solution */\\n        else if (remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i < cand.length; i++) { \\n                tempList.add(cand[i]);\\n                backtrack(list, tempList, cand, remain-cand[i], i);\\n                tempList.remove(tempList.size()-1);\\n            } \\n        }\\n\\n    }\\n\\nCombination Sum II\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n       List<List<Integer>> list = new LinkedList<List<Integer>>();\\n       Arrays.sort(candidates);\\n       backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n       \\n       if(remain < 0) return; /** no solution */\\n       else if(remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for (int i = start; i < cand.length; i++) {\\n             if(i > start && cand[i] == cand[i-1]) continue; /** skip duplicates */\\n             tempList.add(cand[i]);\\n             backtrack(list, tempList, cand, remain - cand[i], i+1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n        if(tempList.size() > k) return; /** no solution */\\n        else if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i <= 9; i++) {\\n                tempList.add(i);\\n                backtrack(list, tempList, k, remain-i, i+1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 16861,
                "title": "java-solution-using-dfs-easy-understand",
                "content": "     public List<List<Integer>> combinationSum2(int[] cand, int target) {\\n        Arrays.sort(cand);\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        List<Integer> path = new ArrayList<Integer>();\\n        dfs_com(cand, 0, target, path, res);\\n        return res;\\n    }\\n    void dfs_com(int[] cand, int cur, int target, List<Integer> path, List<List<Integer>> res) {\\n        if (target == 0) {\\n            res.add(new ArrayList(path));\\n            return ;\\n        }\\n        if (target < 0) return;\\n        for (int i = cur; i < cand.length; i++){\\n            if (i > cur && cand[i] == cand[i-1]) continue;\\n            path.add(path.size(), cand[i]);\\n            dfs_com(cand, i+1, target - cand[i], path, res);\\n            path.remove(path.size()-1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "     public List<List<Integer>> combinationSum2(int[] cand, int target) {\\n        Arrays.sort(cand);\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        List<Integer> path = new ArrayList<Integer>();\\n        dfs_com(cand, 0, target, path, res);\\n        return res;\\n    }\\n    void dfs_com(int[] cand, int cur, int target, List<Integer> path, List<List<Integer>> res) {\\n        if (target == 0) {\\n            res.add(new ArrayList(path));\\n            return ;\\n        }\\n        if (target < 0) return;\\n        for (int i = cur; i < cand.length; i++){\\n            if (i > cur && cand[i] == cand[i-1]) continue;\\n            path.add(path.size(), cand[i]);\\n            dfs_com(cand, i+1, target - cand[i], path, res);\\n            path.remove(path.size()-1);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1277764,
                "title": "combination-sum-i-ii-and-iii-subsets-i-and-ii-permutations-i-and-ii-one-stop-c-solutions",
                "content": "**SUBSETS** \\nhttps://leetcode.com/problems/subsets\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void powerset(vector<int> nums, int curr, vector<int> res, int n){\\n        if(curr == n){\\n            result.push_back(res);\\n            return;\\n        }\\n        powerset(nums, curr+1, res, n);\\n        res.push_back(nums[curr]);\\n        powerset(nums, curr+1, res, n);\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        powerset(nums, 0, res, n);\\n        return result;\\n    }\\n};\\n```\\n\\n**SUBSETS II**\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void subs(vector<int> &nums, int curr, vector<int> &res){\\n        result.push_back(res);\\n        for(int i = curr; i < nums.size(); i++){\\n            if(i!=curr && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n            res.push_back(nums[i]);\\n            subs(nums, i+1, res);\\n            res.pop_back();\\n            \\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return result;\\n        }\\n        vector<int> res;\\n        sort(nums.begin(), nums.end());\\n        subs(nums, 0, res);\\n        return result;\\n    }\\n};\\n```\\n----------------------------------------------------------------------------------\\n**PERMUTATIONS**\\nhttps://leetcode.com/problems/permutations/\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> result;\\n    \\n    vector<int> swap(vector<int> &nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n        return nums;\\n    }\\n    \\n    void perm(vector<int> &nums, int l, int r){\\n        if(l==r){\\n            result.push_back(nums);\\n            return;\\n        }\\n        for(int i = l; i <= r; i++){\\n            nums = swap(nums, l, i);\\n            perm(nums, l+1, r);\\n            nums = swap(nums, l, i);\\n        }\\n    }\\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        perm(nums, 0, nums.size()-1);\\n        return result;\\n    } \\n};\\n```\\n**PERMUTATIONS II**\\nhttps://leetcode.com/problems/permutations-ii/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    vector<int> swap(vector<int> &nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n        return nums;\\n    }\\n    \\n    void perm(vector<int> &nums, int l, int r){\\n        if(l==r){\\n            result.push_back(nums);\\n            return;\\n        }\\n        set<int> s;\\n        for(int i = l; i <= r; i++){\\n                if(s.find(nums[i]) != s.end() )\\n                    continue;\\n                s.insert(nums[i]);\\n                nums = swap(nums, l, i);\\n                perm(nums, l+1, r);\\n                nums = swap(nums, l, i);  \\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        perm(nums, 0, nums.size()-1);\\n        return result;  \\n    }\\n};\\n```\\n-------------------------------------------------------------------------------------------\\n**COMBINATION SUM**\\nhttps://leetcode.com/problems/combination-sum/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comSum(vector<int> &curr, int curInd, int sum, vector<int> &candidates, int target, int n){\\n        if(sum == target){\\n            result.push_back(curr);\\n            return;\\n        }      \\n        else if(sum > target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            curr.push_back(candidates[i]);\\n            sum += candidates[i];\\n            comSum(curr, i, sum, candidates, target, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int sum = 0;\\n        int n = candidates.size();\\n        comSum(curr, 0, sum, candidates, target, n);\\n        return result;\\n    }\\n};\\n```\\n**COMBINATION SUM II**\\nhttps://leetcode.com/problems/combination-sum-ii/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\\n        if(target == sum){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(sum>target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don\\'t pick same element for certain kth position of a combination \\n                continue;\\n            sum += candidates[i];\\n            curr.push_back(candidates[i]);\\n            comsum(curr, target, sum, candidates, i+1, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        comsum(curr, target, 0, candidates, 0, n);\\n        return result;\\n    }\\n};\\n```\\n**COMBINATION SUM III**\\nhttps://leetcode.com/problems/combination-sum-iii/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void comsum(vector<int> &curr, int k, int n, int sum, int size, int index){\\n        if(size==k && sum == n){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(size>k || sum>n)\\n            return;\\n        \\n        for(int i = index; i <= 9; i++){\\n            sum += i;\\n            curr.push_back(i);\\n            comsum(curr, k, n, sum, size+1, i+1);\\n            sum -= i;\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> curr;\\n        comsum(curr, k, n, 0, 0, 1);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void powerset(vector<int> nums, int curr, vector<int> res, int n){\\n        if(curr == n){\\n            result.push_back(res);\\n            return;\\n        }\\n        powerset(nums, curr+1, res, n);\\n        res.push_back(nums[curr]);\\n        powerset(nums, curr+1, res, n);\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        powerset(nums, 0, res, n);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void subs(vector<int> &nums, int curr, vector<int> &res){\\n        result.push_back(res);\\n        for(int i = curr; i < nums.size(); i++){\\n            if(i!=curr && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n            res.push_back(nums[i]);\\n            subs(nums, i+1, res);\\n            res.pop_back();\\n            \\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return result;\\n        }\\n        vector<int> res;\\n        sort(nums.begin(), nums.end());\\n        subs(nums, 0, res);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> result;\\n    \\n    vector<int> swap(vector<int> &nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n        return nums;\\n    }\\n    \\n    void perm(vector<int> &nums, int l, int r){\\n        if(l==r){\\n            result.push_back(nums);\\n            return;\\n        }\\n        for(int i = l; i <= r; i++){\\n            nums = swap(nums, l, i);\\n            perm(nums, l+1, r);\\n            nums = swap(nums, l, i);\\n        }\\n    }\\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        perm(nums, 0, nums.size()-1);\\n        return result;\\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    vector<int> swap(vector<int> &nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n        return nums;\\n    }\\n    \\n    void perm(vector<int> &nums, int l, int r){\\n        if(l==r){\\n            result.push_back(nums);\\n            return;\\n        }\\n        set<int> s;\\n        for(int i = l; i <= r; i++){\\n                if(s.find(nums[i]) != s.end() )\\n                    continue;\\n                s.insert(nums[i]);\\n                nums = swap(nums, l, i);\\n                perm(nums, l+1, r);\\n                nums = swap(nums, l, i);  \\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        perm(nums, 0, nums.size()-1);\\n        return result;  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comSum(vector<int> &curr, int curInd, int sum, vector<int> &candidates, int target, int n){\\n        if(sum == target){\\n            result.push_back(curr);\\n            return;\\n        }      \\n        else if(sum > target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            curr.push_back(candidates[i]);\\n            sum += candidates[i];\\n            comSum(curr, i, sum, candidates, target, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int sum = 0;\\n        int n = candidates.size();\\n        comSum(curr, 0, sum, candidates, target, n);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\\n        if(target == sum){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(sum>target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don\\'t pick same element for certain kth position of a combination \\n                continue;\\n            sum += candidates[i];\\n            curr.push_back(candidates[i]);\\n            comsum(curr, target, sum, candidates, i+1, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        comsum(curr, target, 0, candidates, 0, n);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void comsum(vector<int> &curr, int k, int n, int sum, int size, int index){\\n        if(size==k && sum == n){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(size>k || sum>n)\\n            return;\\n        \\n        for(int i = index; i <= 9; i++){\\n            sum += i;\\n            curr.push_back(i);\\n            comsum(curr, k, n, sum, size+1, i+1);\\n            sum -= i;\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> curr;\\n        comsum(curr, k, n, 0, 0, 1);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16944,
                "title": "beating-98-python-solution-using-recursion-with-comments",
                "content": "    def combinationSum2(self, candidates, target):\\n        # Sorting is really helpful, se we can avoid over counting easily\\n        candidates.sort()                      \\n        result = []\\n        self.combine_sum_2(candidates, 0, [], result, target)\\n        return result\\n        \\n    def combine_sum_2(self, nums, start, path, result, target):\\n        # Base case: if the sum of the path satisfies the target, we will consider \\n        # it as a solution, and stop there\\n        if not target:\\n            result.append(path)\\n            return\\n        \\n        for i in xrange(start, len(nums)):\\n            # Very important here! We don't use `i > 0` because we always want \\n            # to count the first element in this recursive step even if it is the same \\n            # as one before. To avoid overcounting, we just ignore the duplicates\\n            # after the first element.\\n            if i > start and nums[i] == nums[i - 1]:\\n                continue\\n\\n            # If the current element is bigger than the assigned target, there is \\n            # no need to keep searching, since all the numbers are positive\\n            if nums[i] > target:\\n                break\\n\\n            # We change the start to `i + 1` because one element only could\\n            # be used once\\n            self.combine_sum_2(nums, i + 1, path + [nums[i]], \\n                               result, target - nums[i])",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def combinationSum2(self, candidates, target):\\n        # Sorting is really helpful, se we can avoid over counting easily\\n        candidates.sort()                      \\n        result = []\\n        self.combine_sum_2(candidates, 0, [], result, target)\\n        return result\\n        \\n    def combine_sum_2(self, nums, start, path, result, target):\\n        # Base case: if the sum of the path satisfies the target, we will consider \\n        # it as a solution, and stop there\\n        if not target:\\n            result.append(path)\\n            return\\n        \\n        for i in xrange(start, len(nums)):\\n            # Very important here! We don't use `i > 0` because we always want \\n            # to count the first element in this recursive step even if it is the same \\n            # as one before. To avoid overcounting, we just ignore the duplicates\\n            # after the first element.\\n            if i > start and nums[i] == nums[i - 1]:\\n                continue\\n\\n            # If the current element is bigger than the assigned target, there is \\n            # no need to keep searching, since all the numbers are positive\\n            if nums[i] > target:\\n                break\\n\\n            # We change the start to `i + 1` because one element only could\\n            # be used once\\n            self.combine_sum_2(nums, i + 1, path + [nums[i]], \\n                               result, target - nums[i])",
                "codeTag": "Python3"
            },
            {
                "id": 750378,
                "title": "python3-dfs-solutions-templates-to-6-different-classic-backtracking-problems-more",
                "content": "I have compiled solutions for all the 6 classic backtracking problems, you can practise them together for better understanding. Good luck with your preparation/interviews! \\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/)\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/?currentPage=1&orderBy=recent_activity&query=)\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/)\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/)\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[46. Permutations](https://leetcode.com/problems/permutations/)\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\\n\\n[47. Permutations II](https://leetcode.com/problems/permutations-ii/)\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```\\n\\nMore good backtracking problems for practice:\\n[131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)\\n[784. Lettercase Permutation](https://leetcode.com/problems/letter-case-permutation/)\\n[1087. Brace Expansion](https://leetcode.com/problems/brace-expansion/)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/)\\n[1079 Letter Tile Possibilities](https://leetcode.com/problems/letter-tile-possibilities/)",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16862,
                "title": "c-backtracking-solution-with-detailed-explanation",
                "content": "At the beginning, I stuck on this problem. After careful thought, I think this kind of backtracking contains a  iterative component and a resursive component so I'd like to give more details to help beginners save time. The revursive component tries the elements after the current one and also tries duplicate elements. So we can get correct answer for cases like [1 1] 2. The iterative component checks duplicate combinations and skip it if it is. So we can get correct answer for cases like [1 1 1] 2.\\n\\n\\n    class Solution {\\n    public:\\n        vector<vector<int> > combinationSum2(vector<int> &num, int target) \\n        {\\n            vector<vector<int>> res;\\n            sort(num.begin(),num.end());\\n            vector<int> local;\\n            findCombination(res, 0, target, local, num);\\n            return res;\\n        }\\n        void findCombination(vector<vector<int>>& res, const int order, const int target, vector<int>& local, const vector<int>& num)\\n        {\\n            if(target==0)\\n            {\\n                res.push_back(local);\\n                return;\\n            }\\n            else\\n            {\\n                for(int i = order;i<num.size();i++) // iterative component\\n                {\\n                    if(num[i]>target) return;\\n                    if(i&&num[i]==num[i-1]&&i>order) continue; // check duplicate combination\\n                    local.push_back(num[i]),\\n                    findCombination(res,i+1,target-num[i],local,num); // recursive componenet\\n                    local.pop_back();\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > combinationSum2(vector<int> &num, int target) \\n        {\\n            vector<vector<int>> res;\\n            sort(num.begin(),num.end());\\n            vector<int> local;\\n            findCombination(res, 0, target, local, num);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 17020,
                "title": "python-easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        ret = []\\n        self.dfs(sorted(candidates), target, 0, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, idx, path, ret):\\n        if target <= 0:\\n            if target == 0:\\n                ret.append(path)\\n            return \\n        for i in range(idx, len(nums)):\\n            if i > idx and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums, target-nums[i], i+1, path+[nums[i]], ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        ret = []\\n        self.dfs(sorted(candidates), target, 0, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, idx, path, ret):\\n        if target <= 0:\\n            if target == 0:\\n                ret.append(path)\\n            return \\n        for i in range(idx, len(nums)):\\n            if i > idx and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums, target-nums[i], i+1, path+[nums[i]], ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16870,
                "title": "dp-solution-in-python",
                "content": "I also did it with recursion, turns out the DP solution is 3~4 times faster.\\n    \\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()\\n        table = [None] + [set() for i in range(target)]\\n        for i in candidates:\\n            if i > target:\\n                break\\n            for j in range(target - i, 0, -1):\\n                table[i + j] |= {elt + (i,) for elt in table[j]}\\n            table[i].add((i,))\\n        return map(list, table[target])",
                "solutionTags": [
                    "Python"
                ],
                "code": "I also did it with recursion, turns out the DP solution is 3~4 times faster.\\n    \\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()\\n        table = [None] + [set() for i in range(target)]\\n        for i in candidates:\\n            if i > target:\\n                break\\n            for j in range(target - i, 0, -1):\\n                table[i + j] |= {elt + (i,) for elt in table[j]}\\n            table[i].add((i,))\\n        return map(list, table[target])",
                "codeTag": "Python3"
            },
            {
                "id": 1350766,
                "title": "100-faster-c-solution-with-proper-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(int index, int target, vector<int>&candidates, vector<vector<int>>&ans, vector<int>&ds){\\n        //base case\\n        //when the combination ds is carrying is a valid one add it into th ans\\n        if(target == 0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i = index; i< candidates.size(); i++){\\n            if(candidates[i] > target) break; // no point of it to add it to the ans if the  candidate at ith element exceeds the target no picking up hence break \\n            if(i  > index && candidates[i] == candidates[i-1])\\n                continue;\\n                //to avoid picking up the same elements and thus avoiding duplicates (no picking of element)\\n            ds.push_back(candidates[i]);\\n            helper(i+1, target- candidates[i], candidates, ans, ds); //call for next  index element\\n            ds.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());//sort the given candidates vector \\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        helper(0, target, candidates, ans, ds);\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int index, int target, vector<int>&candidates, vector<vector<int>>&ans, vector<int>&ds){\\n        //base case\\n        //when the combination ds is carrying is a valid one add it into th ans\\n        if(target == 0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i = index; i< candidates.size(); i++){\\n            if(candidates[i] > target) break; // no point of it to add it to the ans if the  candidate at ith element exceeds the target no picking up hence break \\n            if(i  > index && candidates[i] == candidates[i-1])\\n                continue;\\n                //to avoid picking up the same elements and thus avoiding duplicates (no picking of element)\\n            ds.push_back(candidates[i]);\\n            helper(i+1, target- candidates[i], candidates, ans, ds); //call for next  index element\\n            ds.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());//sort the given candidates vector \\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        helper(0, target, candidates, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16884,
                "title": "a-smaller-trick-to-improve-a-lot-beat-92-35",
                "content": "Most people who use recursive backtrack to solve this question have code like:\\n\\n```\\n        if (target == 0) {\\n            res.add(new ArrayList<Integer>(list));\\n            return;\\n        }\\n        \\n        if (target < 0) {\\n            return;\\n        }\\n        \\n        for (int i = pos; i < candidates.length; i++) {\\n            if (i > post && candidates[i] == candidats[i - 1])\\n              continue;\\n            }\\n            list.add(candidates[i]);\\n            helper(candidates, target - candidates[i], res, list, i + 1);\\n            list.remove(list.size() - 1);\\n```\\n\\nThis is absolutely correct. However, we can do much more pruning by breaking much earlier. \\n\\nFor example: the list is [1, 1,  2, 5, 6, 7, 10], target is 8 and the current list is [1, 1, 2]. Now we are at 5, and we know that [1, 1, 2, 5] will be greater than 8. The next to check is [1, 1, 2, 6]. However, we should already know that [1, 1, 2, 6] cannot work since [1, 1, 2, 5] already has a sum larger than 8. There is no need to check for [1, 1,  2, 6] or [1, 1, 2, 7] and so no.\\n\\nThus, when we find a match or the current sum is already larger than the target, we should not continue with the current list.\\n\\nThe code is something like:\\n\\n```\\n    private boolean helper(int[] candidates, int target, List<List<Integer>> res,\\n                        List<Integer> list, int pos) {\\n        if (target == 0) {\\n            res.add(new ArrayList<Integer>(list));\\n            return true;\\n        }\\n        \\n        if (target < 0) {\\n            return true;\\n        }\\n        \\n        for (int i = pos; i < candidates.length; i++) {\\n            if (i > pos && candidates[i] == candidates[i - 1]) {\\n                continue;\\n            }\\n            \\n            list.add(candidates[i]);\\n            boolean con = helper(candidates, target - candidates[i], res, list, i + 1);\\n            list.remove(list.size() - 1);\\n            if(con) {\\n                break;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n        if (target == 0) {\\n            res.add(new ArrayList<Integer>(list));\\n            return;\\n        }\\n        \\n        if (target < 0) {\\n            return;\\n        }\\n        \\n        for (int i = pos; i < candidates.length; i++) {\\n            if (i > post && candidates[i] == candidats[i - 1])\\n              continue;\\n            }\\n            list.add(candidates[i]);\\n            helper(candidates, target - candidates[i], res, list, i + 1);\\n            list.remove(list.size() - 1);\\n```\n```\\n    private boolean helper(int[] candidates, int target, List<List<Integer>> res,\\n                        List<Integer> list, int pos) {\\n        if (target == 0) {\\n            res.add(new ArrayList<Integer>(list));\\n            return true;\\n        }\\n        \\n        if (target < 0) {\\n            return true;\\n        }\\n        \\n        for (int i = pos; i < candidates.length; i++) {\\n            if (i > pos && candidates[i] == candidates[i - 1]) {\\n                continue;\\n            }\\n            \\n            list.add(candidates[i]);\\n            boolean con = helper(candidates, target - candidates[i], res, list, i + 1);\\n            list.remove(list.size() - 1);\\n            if(con) {\\n                break;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1213780,
                "title": "3-backtracking-variations-java-beats-100",
                "content": "**Backtracking With Visited Array (using space)**\\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0) {\\n            ArrayList<Integer> base = new ArrayList<>(smallAns);\\n            res.add(base);\\n            return 1;\\n        }\\n        boolean[] visited = new boolean[50];\\n        int count = 0;\\n        for (int i = idx; i < arr.length; ++i) {\\n            if (!visited[arr[i]] && tar - arr[i] >= 0) {\\n                \\n                visited[arr[i]] = true;\\n                \\n                smallAns.add(arr[i]);\\n                count += combinationSum2(arr, tar - arr[i], i + 1, smallAns, res);\\n                smallAns.remove(smallAns.size() - 1);\\n            }\\n        }\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        \\n        Arrays.sort(candidates);\\n        \\n        combinationSum2(candidates, target, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\\n**Backtracking With Prev Variable (space efficient)**\\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0) {\\n            ArrayList<Integer> base = new ArrayList<>(smallAns);\\n            res.add(base);\\n            return 1;\\n        }\\n        \\n        int count = 0;\\n        int prev = -1;\\n        for (int i = idx; i < arr.length; ++i) {\\n            if (prev != arr[i] && tar - arr[i] >= 0) {\\n                smallAns.add(arr[i]);\\n                count += combinationSum2(arr, tar - arr[i], i + 1, smallAns, res);\\n                smallAns.remove(smallAns.size() - 1);\\n            }\\n            \\n            if (tar - arr[i] < 0)\\n                break;\\n            \\n            prev = arr[i];\\n        }\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        \\n        Arrays.sort(candidates);\\n        \\n        combinationSum2(candidates, target, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\\n**BackTracking Subsequence method**\\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0 || idx >= arr.length) {\\n            if (tar == 0) {\\n                List<Integer> base = new ArrayList<>(smallAns);\\n                res.add(base);\\n                return 1;\\n            }\\n            return 0;\\n        }\\n            \\n        int count = 0;\\n\\n        if (tar - arr[idx] >= 0) {\\n            smallAns.add(arr[idx]);\\n            count += combinationSum2(arr, tar - arr[idx], idx + 1, smallAns, res);\\n            smallAns.remove(smallAns.size() - 1);\\n        }\\n\\n        idx++;\\n        while (idx < arr.length && arr[idx - 1] == arr[idx])\\n            idx++;\\n\\n        count += combinationSum2(arr, tar, idx, smallAns, res);\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] arr, int tar) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        Arrays.sort(arr);\\n        combinationSum2(arr, tar, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\\n**If you liked it, even a little bit then pls consider giving this solution a Upvote\\nThank You :)**",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0) {\\n            ArrayList<Integer> base = new ArrayList<>(smallAns);\\n            res.add(base);\\n            return 1;\\n        }\\n        boolean[] visited = new boolean[50];\\n        int count = 0;\\n        for (int i = idx; i < arr.length; ++i) {\\n            if (!visited[arr[i]] && tar - arr[i] >= 0) {\\n                \\n                visited[arr[i]] = true;\\n                \\n                smallAns.add(arr[i]);\\n                count += combinationSum2(arr, tar - arr[i], i + 1, smallAns, res);\\n                smallAns.remove(smallAns.size() - 1);\\n            }\\n        }\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        \\n        Arrays.sort(candidates);\\n        \\n        combinationSum2(candidates, target, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0) {\\n            ArrayList<Integer> base = new ArrayList<>(smallAns);\\n            res.add(base);\\n            return 1;\\n        }\\n        \\n        int count = 0;\\n        int prev = -1;\\n        for (int i = idx; i < arr.length; ++i) {\\n            if (prev != arr[i] && tar - arr[i] >= 0) {\\n                smallAns.add(arr[i]);\\n                count += combinationSum2(arr, tar - arr[i], i + 1, smallAns, res);\\n                smallAns.remove(smallAns.size() - 1);\\n            }\\n            \\n            if (tar - arr[i] < 0)\\n                break;\\n            \\n            prev = arr[i];\\n        }\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        \\n        Arrays.sort(candidates);\\n        \\n        combinationSum2(candidates, target, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0 || idx >= arr.length) {\\n            if (tar == 0) {\\n                List<Integer> base = new ArrayList<>(smallAns);\\n                res.add(base);\\n                return 1;\\n            }\\n            return 0;\\n        }\\n            \\n        int count = 0;\\n\\n        if (tar - arr[idx] >= 0) {\\n            smallAns.add(arr[idx]);\\n            count += combinationSum2(arr, tar - arr[idx], idx + 1, smallAns, res);\\n            smallAns.remove(smallAns.size() - 1);\\n        }\\n\\n        idx++;\\n        while (idx < arr.length && arr[idx - 1] == arr[idx])\\n            idx++;\\n\\n        count += combinationSum2(arr, tar, idx, smallAns, res);\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] arr, int tar) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        Arrays.sort(arr);\\n        combinationSum2(arr, tar, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16916,
                "title": "understanding-the-differences-between-the-dp-solution-and-simple-recursive-which-one-is-really-better",
                "content": "DP Solution:\\n1. Start by creating an array of [target+1]. Call it arr.\\n2. Initialize value at arr[candidates[i]] to be a set only containing {candidates[i]}.\\n3. If there are any other indices j of arr that are non-empty, populate the arr[j+candidates[i]] with the set of arr[j] + candidates[i].\\n\\nGood for:\\nIf target is relatively small, and/or numbers in candidates are very dense.\\nO(M*N) where M is target, and N is candidates.size()\\n\\nRecursive Solution:\\n1. Start by recursing with an empty set on every element.\\n2. DFS by adding the ith element on the temporary vector, calling the recursive function with the ith element added, then remove it. \\n3. When the remaining is 0(we subtract target by candidate[i] every recursive call to candidate[i]), we add the result into the vector<vector<int>>. \\n\\nGood for:\\nIf M is overwhelmingly large.\\n\\nSo I have an additional question: Though I see these 2 tradeoffs, in reality which one would dominate in terms of usefulness in the test cases given by whoever wrote them on leetcode?",
                "solutionTags": [],
                "code": "DP Solution:\\n1. Start by creating an array of [target+1]. Call it arr.\\n2. Initialize value at arr[candidates[i]] to be a set only containing {candidates[i]}.\\n3. If there are any other indices j of arr that are non-empty, populate the arr[j+candidates[i]] with the set of arr[j] + candidates[i].\\n\\nGood for:\\nIf target is relatively small, and/or numbers in candidates are very dense.\\nO(M*N) where M is target, and N is candidates.size()\\n\\nRecursive Solution:\\n1. Start by recursing with an empty set on every element.\\n2. DFS by adding the ith element on the temporary vector, calling the recursive function with the ith element added, then remove it. \\n3. When the remaining is 0(we subtract target by candidate[i] every recursive call to candidate[i]), we add the result into the vector<vector<int>>. \\n\\nGood for:\\nIf M is overwhelmingly large.\\n\\nSo I have an additional question: Though I see these 2 tradeoffs, in reality which one would dominate in terms of usefulness in the test cases given by whoever wrote them on leetcode?",
                "codeTag": "Unknown"
            },
            {
                "id": 1656844,
                "title": "solution-swift-combination-sum-ii-test-cases",
                "content": "```swift\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var path: [Int] = [], result: [[Int]] = []\\n        dfs(&result, &path, candidates.sorted(), target)\\n        return result\\n    }\\n    \\n    private func dfs(_ res: inout [[Int]], _ path: inout [Int], _ cands: [Int], _ t: Int, _ idx: Int = 0) {\\n        guard t > 0 else { res.append(path); return }\\n        for k in idx..<cands.count where cands[k] <= t {\\n            if k > 0 && cands[k] == cands[k-1] && k != idx { continue }\\n            path.append(cands[k])\\n            dfs(&res, &path, cands, t - cands[k], k + 1)\\n            path.removeLast()\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.combinationSum2([10,1,2,7,6,1,5], 8)\\n        XCTAssertEqual(value, [[1,1,6],\\n                               [1,2,5],\\n                               [1,7],\\n                               [2,6]])\\n    }\\n    func test1() {\\n        let value = solution.combinationSum2([2,5,2,1,2], 5)\\n        XCTAssertEqual(value, [[1,2,2],[5]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var path: [Int] = [], result: [[Int]] = []\\n        dfs(&result, &path, candidates.sorted(), target)\\n        return result\\n    }\\n    \\n    private func dfs(_ res: inout [[Int]], _ path: inout [Int], _ cands: [Int], _ t: Int, _ idx: Int = 0) {\\n        guard t > 0 else { res.append(path); return }\\n        for k in idx..<cands.count where cands[k] <= t {\\n            if k > 0 && cands[k] == cands[k-1] && k != idx { continue }\\n            path.append(cands[k])\\n            dfs(&res, &path, cands, t - cands[k], k + 1)\\n            path.removeLast()\\n        }\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.combinationSum2([10,1,2,7,6,1,5], 8)\\n        XCTAssertEqual(value, [[1,1,6],\\n                               [1,2,5],\\n                               [1,7],\\n                               [2,6]])\\n    }\\n    func test1() {\\n        let value = solution.combinationSum2([2,5,2,1,2], 5)\\n        XCTAssertEqual(value, [[1,2,2],[5]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815837,
                "title": "backtracking-recursion-python-solution-with-illustration",
                "content": "Example: sorted candidates = [1,1,6,7] target = 8\\n\\n![image](https://assets.leetcode.com/users/images/1c711892-adcc-4d31-be76-85188326afd3_1598585537.0711756.png)\\n\\nYou could also refer to my post to other similar problems to nail this type of questions once for all:\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\t\\'\\'\\'\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates = sorted(candidates)\\n        self.dfs(candidates, target,[],res)\\n        \\n        return res\\n\\n    def dfs(self,candidates, target, path, res):\\n        if target==0:\\n            res.append(path)\\n            return\\n        for i in range(len(candidates)):\\n            if candidates[i]>target:\\n                continue\\n            if i>=1 and candidates[i] == candidates[i-1]:\\n               continue\\n            self.dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],res)\\n\\t\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "Example: sorted candidates = [1,1,6,7] target = 8\\n\\n![image](https://assets.leetcode.com/users/images/1c711892-adcc-4d31-be76-85188326afd3_1598585537.0711756.png)\\n\\nYou could also refer to my post to other similar problems to nail this type of questions once for all:\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\t\\'\\'\\'\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates = sorted(candidates)\\n        self.dfs(candidates, target,[],res)\\n        \\n        return res\\n\\n    def dfs(self,candidates, target, path, res):\\n        if target==0:\\n            res.append(path)\\n            return\\n        for i in range(len(candidates)):\\n            if candidates[i]>target:\\n                continue\\n            if i>=1 and candidates[i] == candidates[i-1]:\\n               continue\\n            self.dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],res)\\n\\t\\t\\t\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 3441047,
                "title": "easy-to-understand-concise-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\\n        if(target == sum){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(sum>target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don\\'t pick same element for certain kth position of a combination \\n                continue;\\n            sum += candidates[i];\\n            curr.push_back(candidates[i]);\\n            comsum(curr, target, sum, candidates, i+1, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        comsum(curr, target, 0, candidates, 0, n);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\\n        if(target == sum){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(sum>target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don\\'t pick same element for certain kth position of a combination \\n                continue;\\n            sum += candidates[i];\\n            curr.push_back(candidates[i]);\\n            comsum(curr, target, sum, candidates, i+1, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        comsum(curr, target, 0, candidates, 0, n);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546439,
                "title": "java-backtracking-optimized-for-duplicate-candidates-detailed-tc-explanation-added",
                "content": "**Backtracking**\\n```java\\n/**\\n * Backtracking\\n *\\n * Time Complexity:\\n * 1. The length of the potential combinations can vary from 1 to k where k = min(T/M , N).\\n * 2. Total number of combinations of size k is C(N,k) and time to add each such combination in the result list is O(K).\\n * Therefore the total time complexity will be O(1*C(N,1) + 2*C(N,2) + ... + k*C(N,k))\\n *                                             = (i = 1 -> k) \\u2211 (i * C(N, i)).\\n * If k = N, then above time complexity becomes O(N * 2^(N-1))\\n *\\n * Space Complexity: O(min(T/M , N))\\n *\\n * N = Length of input array. T = Target. M = Minimum value in the input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0) {\\n            return result;\\n        }\\n\\n        Arrays.sort(candidates);\\n        combinationSum2Helper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum2Helper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            // Skipping duplicate numbers.\\n            if (i > start && candidates[i - 1] == candidates[i]) {\\n                continue;\\n            }\\n            if (candidates[i] > target) {\\n                break;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSum2Helper(candidates, i + 1, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Optimized Backtracking by using a Count Map and Unique Num List**\\n```\\n/**\\n * Optimized Backtracking by using a Count Map and Unique Num List\\n *\\n * Time & Space Complexity explanation is same as above. We will only need to\\n * add time & space required for creating the count map and a sorted list of\\n * unique candidates.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0) {\\n            return result;\\n        }\\n\\n        HashMap<Integer, Integer> countMap = new HashMap<>();\\n        for (int c : candidates) {\\n            countMap.put(c, countMap.getOrDefault(c, 0) + 1);\\n        }\\n        List<Integer> uniqueNumList = new ArrayList<>(countMap.keySet());\\n        Collections.sort(uniqueNumList);\\n\\n        combinationSum2Helper(countMap, uniqueNumList, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum2Helper(HashMap<Integer, Integer> countMap, List<Integer> uniqueNumList, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < uniqueNumList.size(); i++) {\\n            int num = uniqueNumList.get(i);\\n            int count = countMap.get(num);\\n            if (count == 0) {\\n                continue;\\n            }\\n            if (num > target) {\\n                break;\\n            }\\n\\n            tempList.add(num);\\n            countMap.put(num, count - 1);\\n            combinationSum2Helper(countMap, uniqueNumList, i, target - num, tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n            countMap.put(num, count);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Combination Sum questions on LeetCode:\\n- [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/1546400/Java-or-Backtracking-w-Early-Exit-(Detailed-Time-Complexity-explanation-added))\\n- [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/1546449/Java-or-Optimized-Backtracking-w-Detailed-Time-Complexity-explanation)\\n- [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/discuss/1546467/Java-or-TC:-O(N*T)-or-SC:-O(T)-or-DP-(BottomUp-and-TopDown)-w-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\n/**\\n * Backtracking\\n *\\n * Time Complexity:\\n * 1. The length of the potential combinations can vary from 1 to k where k = min(T/M , N).\\n * 2. Total number of combinations of size k is C(N,k) and time to add each such combination in the result list is O(K).\\n * Therefore the total time complexity will be O(1*C(N,1) + 2*C(N,2) + ... + k*C(N,k))\\n *                                             = (i = 1 -> k) \\u2211 (i * C(N, i)).\\n * If k = N, then above time complexity becomes O(N * 2^(N-1))\\n *\\n * Space Complexity: O(min(T/M , N))\\n *\\n * N = Length of input array. T = Target. M = Minimum value in the input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0) {\\n            return result;\\n        }\\n\\n        Arrays.sort(candidates);\\n        combinationSum2Helper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum2Helper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            // Skipping duplicate numbers.\\n            if (i > start && candidates[i - 1] == candidates[i]) {\\n                continue;\\n            }\\n            if (candidates[i] > target) {\\n                break;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSum2Helper(candidates, i + 1, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n/**\\n * Optimized Backtracking by using a Count Map and Unique Num List\\n *\\n * Time & Space Complexity explanation is same as above. We will only need to\\n * add time & space required for creating the count map and a sorted list of\\n * unique candidates.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0) {\\n            return result;\\n        }\\n\\n        HashMap<Integer, Integer> countMap = new HashMap<>();\\n        for (int c : candidates) {\\n            countMap.put(c, countMap.getOrDefault(c, 0) + 1);\\n        }\\n        List<Integer> uniqueNumList = new ArrayList<>(countMap.keySet());\\n        Collections.sort(uniqueNumList);\\n\\n        combinationSum2Helper(countMap, uniqueNumList, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum2Helper(HashMap<Integer, Integer> countMap, List<Integer> uniqueNumList, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < uniqueNumList.size(); i++) {\\n            int num = uniqueNumList.get(i);\\n            int count = countMap.get(num);\\n            if (count == 0) {\\n                continue;\\n            }\\n            if (num > target) {\\n                break;\\n            }\\n\\n            tempList.add(num);\\n            countMap.put(num, count - 1);\\n            combinationSum2Helper(countMap, uniqueNumList, i, target - num, tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n            countMap.put(num, count);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17035,
                "title": "my-concise-14ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > combinationSum2(vector<int> &num, int target) {\\n            vector<vector<int> > result;\\n            sort(num.begin(), num.end());\\n            combHelper(num, 0, num.size(), target, vector<int>(), result);\\n            return result;\\n        }\\n        \\n        void combHelper(vector<int>& a, int start, int n, int target, \\n        vector<int> cur_vec, vector<vector<int> >& result) {\\n            \\n            if (target == 0) {\\n                result.push_back(cur_vec);\\n                return;\\n            }\\n            int i = start;\\n            while(i < n  && target-a[i] >= 0) {\\n                // NOTE : this condition helps neglecting making identical sets\\n                //  this is the catch of this question\\n                if (i == start || a[i] != a[i-1]) {\\n                    cur_vec.push_back(a[i]);\\n                    combHelper(a, i+1, n, target-a[i], cur_vec, result);\\n                    cur_vec.pop_back();\\n                }\\n                i++;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > combinationSum2(vector<int> &num, int target) {\\n            vector<vector<int> > result;\\n            sort(num.begin(), num.end());\\n            combHelper(num, 0, num.size(), target, vector<int>(), result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 883077,
                "title": "very-easy-python-solution-beats-98-related-problems-to-solve",
                "content": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        def backtrack(nums,targetLeft,path):\\n            \\n            if targetLeft==0:\\n                res.append(path)\\n                return\\n            \\n            for i in range(len(nums)):\\n                if i>0 and nums[i]==nums[i-1]:\\n                    continue\\n                if nums[i]>targetLeft:\\n                    break\\n                backtrack(nums[i+1:],targetLeft-nums[i],path+[nums[i]])    \\n            \\n        res=[]\\n        backtrack(sorted(candidates),target,[])\\n        return res\\n```\\n\\nOther related Qs to solve that will help:\\n#77 Combinations\\n#permutations LC 76\\n#permutations II \\n#subsets\\n#subsets II\\n#combinations sum LC 39",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        def backtrack(nums,targetLeft,path):\\n            \\n            if targetLeft==0:\\n                res.append(path)\\n                return\\n            \\n            for i in range(len(nums)):\\n                if i>0 and nums[i]==nums[i-1]:\\n                    continue\\n                if nums[i]>targetLeft:\\n                    break\\n                backtrack(nums[i+1:],targetLeft-nums[i],path+[nums[i]])    \\n            \\n        res=[]\\n        backtrack(sorted(candidates),target,[])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889492,
                "title": "simple-java-solution-with-comments-beats-98-2ms",
                "content": "**Algorithm:**\\n- Sort the array to ensure we have duplicate elements together.\\n- For every element in the array\\n\\t- include the element and see if we can achieve target\\n\\t- exclude the element and see if we can achieve target\\n\\t\\t- while exclusion skip all the duplicate entries\\n\\n```\\n// solution using exclusion/inclusion principle\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // To ensure duplicate elements are clustered\\n\\t\\tArrays.sort(candidates);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res, new ArrayList<>(), candidates, 0, target);\\n        return res;\\n    }\\n    \\n    \\n    private void helper(List<List<Integer>> res, List<Integer> path, int[] a, int start, int target) {\\n        if(target == 0) {\\n            res.add(List.copyOf(path));\\n            return;\\n        }\\n        if(start == a.length) return;\\n        \\n        // As the elements are sorted in increasing order; we  need to process only if the condition holds\\n\\t\\tif(a[start] <= target) {\\n            // include\\n            path.add(a[start]);\\n            helper(res, path, a, start+1, target-a[start]);\\n            // exclude\\n            path.remove(path.size()-1);\\n            // Skip all duplicate entries\\n            while(start+1 < a.length && a[start] == a[start+1]) start += 1;\\n            helper(res, path, a, start+1, target);\\n        }\\n    }\\n}\\n```\\n\\n**Please Vote up, if this helped you!!**\\n\\nHappy Coding!! :)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n// solution using exclusion/inclusion principle\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // To ensure duplicate elements are clustered\\n\\t\\tArrays.sort(candidates);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res, new ArrayList<>(), candidates, 0, target);\\n        return res;\\n    }\\n    \\n    \\n    private void helper(List<List<Integer>> res, List<Integer> path, int[] a, int start, int target) {\\n        if(target == 0) {\\n            res.add(List.copyOf(path));\\n            return;\\n        }\\n        if(start == a.length) return;\\n        \\n        // As the elements are sorted in increasing order; we  need to process only if the condition holds\\n\\t\\tif(a[start] <= target) {\\n            // include\\n            path.add(a[start]);\\n            helper(res, path, a, start+1, target-a[start]);\\n            // exclude\\n            path.remove(path.size()-1);\\n            // Skip all duplicate entries\\n            while(start+1 < a.length && a[start] == a[start+1]) start += 1;\\n            helper(res, path, a, start+1, target);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211544,
                "title": "best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time complexity : O(2^N*K), For every index, we make 2 recursion calls and there are N elements and for\\n    every subset we are checking duplicates in output and in worst case it can contain K subset. so total time\\n    complexity is O(2^N*K).\\n\\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(N*K).\\n\\n    Solved using Array + BackTracking.\\n\\n    Note : This approach will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n                if(!isPresent){\\n                    output.push_back(temp);\\n                }\\n            }\\n            return;\\n        }\\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            combinationSum2(candidates, target-candidates[index], output, temp, index+1);\\n            temp.pop_back();\\n        }\\n        combinationSum2(candidates, target, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum2(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(2^N).\\n\\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(N*K).\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(target < 0){\\n            return;\\n        }\\n        else if(target == 0){\\n            output.push_back(temp);\\n        }\\n        else{\\n            for(int i=index; i<candidates.size(); i++){\\n                if(i>index && candidates[i] == candidates[i-1]){\\n                    continue;\\n                }\\n                temp.push_back(candidates[i]);\\n                combinationSum2(candidates, target-candidates[i], output, temp, i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum2(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time complexity : O(2^N*K), For every index, we make 2 recursion calls and there are N elements and for\\n    every subset we are checking duplicates in output and in worst case it can contain K subset. so total time\\n    complexity is O(2^N*K).\\n\\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(N*K).\\n\\n    Solved using Array + BackTracking.\\n\\n    Note : This approach will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n                if(!isPresent){\\n                    output.push_back(temp);\\n                }\\n            }\\n            return;\\n        }\\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            combinationSum2(candidates, target-candidates[index], output, temp, index+1);\\n            temp.pop_back();\\n        }\\n        combinationSum2(candidates, target, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum2(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(2^N).\\n\\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(N*K).\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(target < 0){\\n            return;\\n        }\\n        else if(target == 0){\\n            output.push_back(temp);\\n        }\\n        else{\\n            for(int i=index; i<candidates.size(); i++){\\n                if(i>index && candidates[i] == candidates[i-1]){\\n                    continue;\\n                }\\n                temp.push_back(candidates[i]);\\n                combinationSum2(candidates, target-candidates[i], output, temp, i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum2(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934668,
                "title": "backtracking-solution-with-time-complexity-explanations-in-c",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- As we have to return all the unique combinations, so we\\u2019ll sort the array to skip duplicates.\\n- The base case for our helper function is when the target will be 0 then we\\u2019ll push our temp to ans.\\n- So here for every recursion, we\\u2019ll take a loop to check which could be our next possible element. Here we can have 2 cases:\\n    - `if(i>index && candidates[i]==candidates[i-1])` we\\u2019ve already taken an element with the same value of current element, so simply skip it.\\n    - `if(candidates[i] > target)` as current element is greater than target & the array is in sorted order, so no chance to get any possible solution from the next elements, so break the loop.\\n- We\\u2019ll push the current element to our temp vector & call recursion for the next index, also reducing the target value.\\n- After the call, we\\u2019ve to pop the current element from temp as we already used this element.\\n- **Time complexity:** O(2^n * k), where 2^n is the total number of subsequences & k is the average of every combination.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        sort(candidates.begin(), candidates.end());\\n        helper(0, temp, ans, candidates, target);\\n        return ans;\\n    }\\n    void helper(int index, vector<int> &temp, vector<vector<int>> &ans, vector<int>& candidates, int target){\\n        if(target == 0){\\n            ans.push_back(temp);\\n            return; \\n        }\\n        \\n        for(int i=index; i<candidates.size(); i++){\\n            if(i>index && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i] > target) break;\\n            \\n            temp.push_back(candidates[i]);\\n            helper(i+1, temp, ans, candidates, target-candidates[i]);\\n            temp.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        sort(candidates.begin(), candidates.end());\\n        helper(0, temp, ans, candidates, target);\\n        return ans;\\n    }\\n    void helper(int index, vector<int> &temp, vector<vector<int>> &ans, vector<int>& candidates, int target){\\n        if(target == 0){\\n            ans.push_back(temp);\\n            return; \\n        }\\n        \\n        for(int i=index; i<candidates.size(); i++){\\n            if(i>index && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i] > target) break;\\n            \\n            temp.push_back(candidates[i]);\\n            helper(i+1, temp, ans, candidates, target-candidates[i]);\\n            temp.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16871,
                "title": "time-complexity-analysis-of-recursive-approach",
                "content": "On the first thought, the time complexity analysis of this brute force approach looks difficult. We are going through each element and calling recursively on each of those elements. Is it n ^ n ? \\n\\nThe fact that we are doing brute force gives us the answer of complexity. If you think, we are essentially selecting all possible subsets of  of set.\\n\\n{1,2,3} -> {1} {2} {3} {1,2} {1,3} {2,3} {1,2,3}\\n\\nThere are **2 ^n** such elements and hence the time complexity is **O(2^n)**\\n\\n**Example:**\\nIt is easy to see this with example also. We select input that will explore all the paths such as {1,2,3,4,5,6,7} and the target is big enough so it will not prune any path. It will call the iteration  128 times.\\n```\\npublic class Solution {\\n\\t  public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t        \\n\\t        List<List<Integer>> answer = new ArrayList<>();\\n\\t        if(candidates == null || candidates.length == 0){return answer;}\\n\\t        \\n\\t        // Sort the array, it is needed to take care of duplicates and effective pruning\\n\\t        Arrays.sort(candidates);\\n\\t        \\n\\t        dfs(0, candidates, target, new ArrayList<>(), answer);\\n\\t        return answer;\\n\\t    }\\n\\t    \\n\\t   private static int complexity = 0; \\n\\t  \\n\\t    private void dfs(int index, int candidates[], int target, List <Integer> path, List<List<Integer>> answer){\\n\\t        if(target == 0){\\n\\t            // The path gives us answer\\n\\t            answer.add(new ArrayList<>(path));\\n\\t            // Return back as numbers after this will be bigger and will not give us answer\\n\\t            return;\\n\\t        }\\n\\t        \\n\\t        complexity ++;\\n\\t        \\n\\t        for(int i = index; i < candidates.length; i++){\\n\\t            \\n\\t            // Avoid visiting duplicate elements\\n\\t            if(i != index && candidates[i] == candidates[i-1]){ continue; }\\n\\t            \\n\\t            // This element and all that will appear after this are too big\\n\\t            if(target - candidates[i] < 0){break;}\\n\\t                \\n\\t            path.add(candidates[i]);\\n\\t            \\n\\t            dfs(i + 1, candidates, target-candidates[i], path, answer);\\n\\t            \\n\\t            path.remove(path.size()-1);\\n\\t        }\\n\\t    }\\n    public static void main(String[] args) {\\n\\t\\tSystem.out.println(new Solution().combinationSum2(new int []{1,2,3,4,5,6,7}, 1000));\\n\\t\\tSystem.out.println(complexity);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\t  public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t        \\n\\t        List<List<Integer>> answer = new ArrayList<>();\\n\\t        if(candidates == null || candidates.length == 0){return answer;}\\n\\t        \\n\\t        // Sort the array, it is needed to take care of duplicates and effective pruning\\n\\t        Arrays.sort(candidates);\\n\\t        \\n\\t        dfs(0, candidates, target, new ArrayList<>(), answer);\\n\\t        return answer;\\n\\t    }\\n\\t    \\n\\t   private static int complexity = 0; \\n\\t  \\n\\t    private void dfs(int index, int candidates[], int target, List <Integer> path, List<List<Integer>> answer){\\n\\t        if(target == 0){\\n\\t            // The path gives us answer\\n\\t            answer.add(new ArrayList<>(path));\\n\\t            // Return back as numbers after this will be bigger and will not give us answer\\n\\t            return;\\n\\t        }\\n\\t        \\n\\t        complexity ++;\\n\\t        \\n\\t        for(int i = index; i < candidates.length; i++){\\n\\t            \\n\\t            // Avoid visiting duplicate elements\\n\\t            if(i != index && candidates[i] == candidates[i-1]){ continue; }\\n\\t            \\n\\t            // This element and all that will appear after this are too big\\n\\t            if(target - candidates[i] < 0){break;}\\n\\t                \\n\\t            path.add(candidates[i]);\\n\\t            \\n\\t            dfs(i + 1, candidates, target-candidates[i], path, answer);\\n\\t            \\n\\t            path.remove(path.size()-1);\\n\\t        }\\n\\t    }\\n    public static void main(String[] args) {\\n\\t\\tSystem.out.println(new Solution().combinationSum2(new int []{1,2,3,4,5,6,7}, 1000));\\n\\t\\tSystem.out.println(complexity);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16958,
                "title": "8ms-c-backtracking-easy-to-understand",
                "content": "    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        sort(candidates.begin(),candidates.end());\\n        backTracking(candidates.begin(),current,res,candidates,target);\\n        return res;\\n    }\\n    \\n    void backTracking(vector<int>::iterator n, vector<int>& current,vector<vector<int>>& res, const vector<int>& candidates, int target){\\n        if(!target) res.push_back(current);\\n        else if(target>0){\\n            for(;n!=candidates.end()&&*n<=target;++n){\\n                current.push_back(*n);\\n                backTracking(n+1,current,res,candidates,target-*n);\\n                current.pop_back();\\n                while(n+1!=candidates.end()&&*(n+1)==*n) ++n;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        sort(candidates.begin(),candidates.end());\\n        backTracking(candidates.begin(),current,res,candidates,target);\\n        return res;\\n    }\\n    \\n    void backTracking(vector<int>::iterator n, vector<int>& current,vector<vector<int>>& res, const vector<int>& candidates, int target){\\n        if(!target) res.push_back(current);\\n        else if(target>0){\\n            for(;n!=candidates.end()&&*n<=target;++n){\\n                current.push_back(*n);\\n                backTracking(n+1,current,res,candidates,target-*n);\\n                current.pop_back();\\n                while(n+1!=candidates.end()&&*(n+1)==*n) ++n;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 738352,
                "title": "javascript-fast-solution-avoid-duplication",
                "content": "```\\nvar combinationSum2 = function(candidates, target) {\\n    if (!candidates || candidates.length == 0) return [];\\n    let res = [];\\n    candidates.sort((a,b) => a-b);\\n    var helper = function(curSum, cur, index){\\n        if (curSum == target){\\n            res.push([...cur]);\\n            return;\\n        }\\n        for(let i = index; i < candidates.length; i++){\\n            if (i != index && candidates[i] == candidates[i-1]) continue; //already return, go next loop(not recursion)\\n            if (curSum > target) return;\\n            cur.push(candidates[i]);\\n            helper(curSum+candidates[i], cur, i+1);\\n            cur.pop();\\n        }\\n    }\\n    helper(0, [], 0);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar combinationSum2 = function(candidates, target) {\\n    if (!candidates || candidates.length == 0) return [];\\n    let res = [];\\n    candidates.sort((a,b) => a-b);\\n    var helper = function(curSum, cur, index){\\n        if (curSum == target){\\n            res.push([...cur]);\\n            return;\\n        }\\n        for(let i = index; i < candidates.length; i++){\\n            if (i != index && candidates[i] == candidates[i-1]) continue; //already return, go next loop(not recursion)\\n            if (curSum > target) return;\\n            cur.push(candidates[i]);\\n            helper(curSum+candidates[i], cur, i+1);\\n            cur.pop();\\n        }\\n    }\\n    helper(0, [], 0);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16933,
                "title": "my-84ms-python-recursive-solution",
                "content": "    class Solution:\\n        def combinationSum2(self, candidates, target):\\n            candidates.sort()\\n            return self.search(candidates, 0 ,target)\\n    \\n        def search(self, candidates, start, target):\\n            if target==0:\\n                return [[]]\\n            res=[]\\n            for i in xrange(start,len(candidates)):\\n                if i!=start and candidates[i]==candidates[i-1]:\\n                    continue\\n                if candidates[i]>target:\\n                    break\\n                for r in self.search(candidates, i+1, target-candidates[i]):\\n                    res.append([candidates[i]]+r)\\n            return res",
                "solutionTags": [],
                "code": "    class Solution:\\n        def combinationSum2(self, candidates, target):\\n            candidates.sort()\\n            return self.search(candidates, 0 ,target)\\n    \\n        def search(self, candidates, start, target):\\n            if target==0:\\n                return [[]]\\n            res=[]\\n            for i in xrange(start,len(candidates)):\\n                if i!=start and candidates[i]==candidates[i-1]:\\n                    continue\\n                if candidates[i]>target:\\n                    break\\n                for r in self.search(candidates, i+1, target-candidates[i]):\\n                    res.append([candidates[i]]+r)\\n            return res",
                "codeTag": "Java"
            },
            {
                "id": 3866692,
                "title": "easy-explanation-using-images-and-dry-run-using-set-without-set",
                "content": "# Understanding the Question\\nHELLO! Lets analyze how to solve this problem. well if you are solving this problem then i am assuming that you already solved **Combination Sum 1 problem** , Where we could pick any value multiple times. \\nThis problem is a little different. Here we cant choose a single value multiple times, also here is one more thing. if we get ans=[[1,7],[7,1]] then our final ans will be [[1,7]] as duplicate combinations are not allowed.\\n\\n# Approach\\nIn combination sum 1 problem we had two choices--\\n- Either pick the current element and again pick the same element.\\n**OR**\\n- dont pick the current element, move 1 step ahead and repeat the same process\\n\\nBut in combination sum 2 problem we cant choose one value multiple times. so what options do we have?\\n- Either choose the value and move ahead\\n**OR**\\n- Dont pick the value and move ahead\\n\\nso how will our recurrence relations will look?\\n\\n- f(i+1,sum-arr[i],arr)  ***Pick the value and move on to next index***\\n**OR**\\n- f(i+1,sum,arr)  ***dont pick the value but move onto next index***\\n\\nnow take a simple example to understand recursive calls:\\nlets take **arr=[1,1,7]** and **target=8**\\nhere i have attached a picture where pick and not_pick calls happens\\n*(pardon my drawing, i draw using trackpad)*\\n\\n![Screenshot (11).png](https://assets.leetcode.com/users/images/295b4fbd-00f7-46ce-83d0-06d0942eec33_1691228467.687165.png)\\n\\nhere as you can see at last we are getting 2 answers [[1,7],[1,7]]\\nbut as we know duplicate combinations are not allowed so we have to find a way to only get one set of combination.\\n\\n***There are Two ways-***\\n1. Using Set Data Structure\\n2. Using Brain\\n\\n*i will not talk about how to use set as it is very easy.Although i will share the code using set ds.*\\n\\n**Lets talk about the second approach--**\\n1. if you carefully observe the answer of test cases in this problem you can notice that all the combination set are sorted. means [1,7] then [2,6] this way.\\nso to achive combinations in sorted order we need to sort our arr as well.\\n2. our main reason why we are getting [1,7] twice is because there is two 1 in our arr.\\nif u see previous image which i attached u will see that when i picked the 1 **[0th index]** i got [1,7] as an answer combination. \\nand when i **didn\\'t picked** the 1 **[0th index]** i had another 1 **[1st index]** which is going in the next recursive call and giving me an extra [1,7] combination.\\n\\n3. so if i can manipulate my code in a way that at the time of not picking the element, which i already picked **1** **[0th index]** ,will not go to the not pick call with the same value then we can avoid getting the duplicate.\\n\\n![Screenshot (12).png](https://assets.leetcode.com/users/images/7ba37cfd-eb6c-4b35-9068-4fa510c92856_1691230268.4377675.png)\\n\\n4. see here i picked 1**[0th index]**  which is okay.\\n5. but when i am not picking 1[0th index], i am not letting any 1 value pass to the not pick call.\\n6. i have picked 1 so at the time of not pick i\\'ll avoid all the 1 present in the array.\\n7. to skip all the 1, i have used a loop. \\n8. pick 1 and go to next index. \\nbut if dont pick 1 then dont pick any 1 value and go directly to the next unique element which is 7.\\n\\nI am not explaning about the base case here. if you r having hard time finding how i got the base case then plz comment down below. I will reply.\\n\\n***now see the above 2 picture again. spot the difference.***\\n# PLZ UPVOTE IF YOU UNDERSTOOD THE APPROACH (\\u25CF\\'\\u25E1\\'\\u25CF)\\n\\n# Time Complexity:\\nTime complexity will be $O(2^n*n)$\\n$2^n$ because every element have two choices either pick or not pick.\\nand n extra because we are using a while loop inside the recursive function which will add n time complexity.\\n\\n# Code using SET\\n```\\nclass Solution:\\n    def f(self,i,arr,target,ds,ans):\\n        # BASE CASE\\n        if i==len(arr):\\n            if target==0:\\n                ans.add(tuple(ds))\\n            return\\n\\n        # RECURENCE RELATION\\n        if target>=arr[i]:\\n            ds.append(arr[i])\\n            self.f(i+1,arr,target-arr[i],ds,ans)\\n            ds.pop()\\n        self.f(i+1,arr,target,ds,ans)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ds=[]\\n        ans=set()\\n        candidates.sort()\\n        self.f(0,candidates,target,ds,ans)\\n        return [list(combination) for combination in ans]\\n```\\n\\n# Code Using Brain\\n```\\nclass Solution:\\n    def f(self,i,arr,target,ds,ans):\\n        # BASE CASE\\n        if target==0:\\n            ans.append(ds.copy())\\n            return\\n        if i>=len(arr):\\n            return\\n        # RECURENCE RELATION\\n        if target>=arr[i]:\\n            ds.append(arr[i])\\n            self.f(i+1,arr,target-arr[i],ds,ans) #PICK\\n            ds.pop()\\n        j=i+1\\n        while(j<len(arr) and arr[j]==arr[j-1]):\\n            j+=1\\n        self.f(j,arr,target,ds,ans) #NOT PICK\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ds=[]\\n        ans=[]\\n        candidates.sort()\\n        self.f(0,candidates,target,ds,ans)\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def f(self,i,arr,target,ds,ans):\\n        # BASE CASE\\n        if i==len(arr):\\n            if target==0:\\n                ans.add(tuple(ds))\\n            return\\n\\n        # RECURENCE RELATION\\n        if target>=arr[i]:\\n            ds.append(arr[i])\\n            self.f(i+1,arr,target-arr[i],ds,ans)\\n            ds.pop()\\n        self.f(i+1,arr,target,ds,ans)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ds=[]\\n        ans=set()\\n        candidates.sort()\\n        self.f(0,candidates,target,ds,ans)\\n        return [list(combination) for combination in ans]\\n```\n```\\nclass Solution:\\n    def f(self,i,arr,target,ds,ans):\\n        # BASE CASE\\n        if target==0:\\n            ans.append(ds.copy())\\n            return\\n        if i>=len(arr):\\n            return\\n        # RECURENCE RELATION\\n        if target>=arr[i]:\\n            ds.append(arr[i])\\n            self.f(i+1,arr,target-arr[i],ds,ans) #PICK\\n            ds.pop()\\n        j=i+1\\n        while(j<len(arr) and arr[j]==arr[j-1]):\\n            j+=1\\n        self.f(j,arr,target,ds,ans) #NOT PICK\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ds=[]\\n        ans=[]\\n        candidates.sort()\\n        self.f(0,candidates,target,ds,ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057690,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target, set<vector<int>>& s)\\n    {\\n        if(target == 0) \\n        {\\n            s.insert(temp);\\n            return;\\n        } \\n        if(target<0 || i==arr.size())\\n            return;\\n        temp.push_back(arr[i]); \\n        solve(i+1, arr, temp, target - arr[i], s); \\n        temp.pop_back();\\n        while(i<arr.size()-1 && arr[i]==arr[i+1])\\n            i++;\\n        solve(i + 1, arr, temp, target, s);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        vector<int> temp;\\n        sort(arr.begin(), arr.end());\\n        set<vector<int>> s;\\n        solve(0, arr, temp, target, s);\\n        vector<vector<int>> ans;\\n        for(auto v:s)\\n            ans.push_back(v);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target, set<vector<int>>& s)\\n    {\\n        if(target == 0) \\n        {\\n            s.insert(temp);\\n            return;\\n        } \\n        if(target<0 || i==arr.size())\\n            return;\\n        temp.push_back(arr[i]); \\n        solve(i+1, arr, temp, target - arr[i], s); \\n        temp.pop_back();\\n        while(i<arr.size()-1 && arr[i]==arr[i+1])\\n            i++;\\n        solve(i + 1, arr, temp, target, s);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        vector<int> temp;\\n        sort(arr.begin(), arr.end());\\n        set<vector<int>> s;\\n        solve(0, arr, temp, target, s);\\n        vector<vector<int>> ans;\\n        for(auto v:s)\\n            ans.push_back(v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905802,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        let sorted = candidates.sorted()\\n        var res: [[Int]] = []\\n\\n\\n        func backtrack(_ path: [Int], _ input: [Int], _ target: Int, _ index: Int) {\\n            var path = path\\n            var last: Int?\\n\\n            for (i, num) in input.enumerated() {\\n                if let last = last, last == num { continue }\\n                if i <= index { continue }\\n                if num == target {\\n                    res.append(path + [num])\\n                    break\\n                }\\n                if num > target { break }\\n                if num < target {\\n                    path.append(num)\\n                    backtrack(path, input, target - num, i)\\n                    path.remove(at: path.count - 1)\\n                }\\n                last = num\\n            }\\n        }\\n        backtrack([], sorted, target, -1)\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        let sorted = candidates.sorted()\\n        var res: [[Int]] = []\\n\\n\\n        func backtrack(_ path: [Int], _ input: [Int], _ target: Int, _ index: Int) {\\n            var path = path\\n            var last: Int?\\n\\n            for (i, num) in input.enumerated() {\\n                if let last = last, last == num { continue }\\n                if i <= index { continue }\\n                if num == target {\\n                    res.append(path + [num])\\n                    break\\n                }\\n                if num > target { break }\\n                if num < target {\\n                    path.append(num)\\n                    backtrack(path, input, target - num, i)\\n                    path.remove(at: path.count - 1)\\n                }\\n                last = num\\n            }\\n        }\\n        backtrack([], sorted, target, -1)\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16877,
                "title": "java-short-and-recursive-clean-code",
                "content": "    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> comb = new ArrayList<>();\\n\\t\\tArrays.sort(candidates); // need sort to make this work.\\n\\t\\tcombination(candidates, target, 0, comb, ans);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate void combination(int[] candi, int target, int start,\\n\\t\\t\\tList<Integer> comb, List<List<Integer>> ans) {\\n\\t\\tfor (int i = start; i < candi.length; i++) {\\n\\t\\t\\tif (i > start && candi[i] == candi[i - 1]) //remove duplicates.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (candi[i] == target) {\\n\\t\\t\\t\\t//recursion exit.\\n\\t\\t\\t\\tList<Integer> newComb = new ArrayList<>(comb);\\n\\t\\t\\t\\tnewComb.add(candi[i]);\\n\\t\\t\\t\\tans.add(newComb);\\n\\t\\t\\t} else if (candi[i] < target) {\\n\\t\\t\\t\\t//continue to look for the rest.\\n\\t\\t\\t\\tList<Integer> newComb = new ArrayList<>(comb);\\n\\t\\t\\t\\tnewComb.add(candi[i]);\\n\\t\\t\\t\\tcombination(candi, target - candi[i], i + 1, newComb, ans);\\n\\t\\t\\t} else \\n\\t\\t\\t\\tbreak; //invalid path, return nothing.\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> comb = new ArrayList<>();\\n\\t\\tArrays.sort(candidates); // need sort to make this work.\\n\\t\\tcombination(candidates, target, 0, comb, ans);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate void combination(int[] candi, int target, int start,\\n\\t\\t\\tList<Integer> comb, List<List<Integer>> ans) {\\n\\t\\tfor (int i = start; i < candi.length; i++) {\\n\\t\\t\\tif (i > start && candi[i] == candi[i - 1]) //remove duplicates.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (candi[i] == target) {\\n\\t\\t\\t\\t//recursion exit.\\n\\t\\t\\t\\tList<Integer> newComb = new ArrayList<>(comb);\\n\\t\\t\\t\\tnewComb.add(candi[i]);\\n\\t\\t\\t\\tans.add(newComb);\\n\\t\\t\\t} else if (candi[i] < target) {\\n\\t\\t\\t\\t//continue to look for the rest.\\n\\t\\t\\t\\tList<Integer> newComb = new ArrayList<>(comb);\\n\\t\\t\\t\\tnewComb.add(candi[i]);\\n\\t\\t\\t\\tcombination(candi, target - candi[i], i + 1, newComb, ans);\\n\\t\\t\\t} else \\n\\t\\t\\t\\tbreak; //invalid path, return nothing.\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 708266,
                "title": "c-combinations-i-ii-and-iii",
                "content": "**Combinations I :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\\n**Combinations II :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            if(i > pos && candidates[i] == candidates[i-1]) continue;\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i + 1,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\\n**Combinations III :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int> &combination,int pos,int target,int k){\\n        if(!target && combination.size() == k){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i <= 9; i++){\\n            combination.emplace_back(i);\\n            helper(res,combination,i + 1,target - i,k);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res, combination, 1, n, k);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            if(i > pos && candidates[i] == candidates[i-1]) continue;\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i + 1,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int> &combination,int pos,int target,int k){\\n        if(!target && combination.size() == k){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i <= 9; i++){\\n            combination.emplace_back(i);\\n            helper(res,combination,i + 1,target - i,k);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res, combination, 1, n, k);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451893,
                "title": "small-difference-between-combination-sum-1-and-2-c-backtracking",
                "content": "**Combination Sum I**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(int i, int n, vector<int>& candidates,vector<int> &temp, int target)\\n    {\\n        \\n        if(target == 0) {res.push_back(temp); return;} // if target achieved push the current vector\\n        if(i==n) return;\\n        int start = i;\\n        while(i<n){\\n            if(i!=start && candidates[i] == candidates[i-1]) {i++;continue;} // for removing duplicates \\n            if(candidates[i] <= target) {\\n                temp.push_back(candidates[i]);\\n                solve(i,n,candidates, temp,target - candidates[i]); \\n                // passing i because we may want to add the current value at candidate[i] again\\n                temp.pop_back();\\n            }\\n            else break; /*just to optimise a bit as all the next elements are greater than \\n            current element since the candidates array is sorted */\\n            i++;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0,n,candidates,temp,target);\\n        return res;\\n    }\\n};\\n```\\n\\n**Combination Sum II**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(int i, int n, vector<int>& candidates,vector<int> &temp, int target)\\n    {\\n        \\n        if(target == 0) {res.push_back(temp); return;} // if target achieved push the current vector\\n        if(i==n) return;\\n        int start = i;\\n        while(i<n){\\n            if(i!=start && candidates[i] == candidates[i-1]) {i++;continue;} // for removing duplicates \\n            if(candidates[i] <= target) {\\n                temp.push_back(candidates[i]);\\n                solve(i+1,n,candidates, temp,target - candidates[i]); \\n                // passing i+1 because we can\\'t include a value twice hence after adding we move to the next element\\n                temp.pop_back();\\n            }\\n            else break; /*just to optimise a bit as all the next elements are greater than \\n            current element since the candidates array is sorted */\\n            i++;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0,n,candidates,temp,target);\\n        return res;\\n    }\\n};\\n```\\n\\nAs you can see the only **difference** in the above two codes is the ith parameter we pass in our recursive function.\\nIn Combination Sum I, we may want to add the current element again so we don\\'t increment i while passing it to the recursive function.\\nIn Combination Sum II, each number may be used only once hence once we include an element we move on to the next element by incrementing i by 1.\\n\\nTime complexity is O(2^n) because for every number we have two choices.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(int i, int n, vector<int>& candidates,vector<int> &temp, int target)\\n    {\\n        \\n        if(target == 0) {res.push_back(temp); return;} // if target achieved push the current vector\\n        if(i==n) return;\\n        int start = i;\\n        while(i<n){\\n            if(i!=start && candidates[i] == candidates[i-1]) {i++;continue;} // for removing duplicates \\n            if(candidates[i] <= target) {\\n                temp.push_back(candidates[i]);\\n                solve(i,n,candidates, temp,target - candidates[i]); \\n                // passing i because we may want to add the current value at candidate[i] again\\n                temp.pop_back();\\n            }\\n            else break; /*just to optimise a bit as all the next elements are greater than \\n            current element since the candidates array is sorted */\\n            i++;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0,n,candidates,temp,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(int i, int n, vector<int>& candidates,vector<int> &temp, int target)\\n    {\\n        \\n        if(target == 0) {res.push_back(temp); return;} // if target achieved push the current vector\\n        if(i==n) return;\\n        int start = i;\\n        while(i<n){\\n            if(i!=start && candidates[i] == candidates[i-1]) {i++;continue;} // for removing duplicates \\n            if(candidates[i] <= target) {\\n                temp.push_back(candidates[i]);\\n                solve(i+1,n,candidates, temp,target - candidates[i]); \\n                // passing i+1 because we can\\'t include a value twice hence after adding we move to the next element\\n                temp.pop_back();\\n            }\\n            else break; /*just to optimise a bit as all the next elements are greater than \\n            current element since the candidates array is sorted */\\n            i++;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0,n,candidates,temp,target);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934838,
                "title": "two-dp-solutions-in-java-with-explanation",
                "content": "# Method 1: With Hash Table\\nConsider a 2D dp array, where `dp[i][j]` is all combinations using `candidates[0]` to `candidates[i]` that sum to `j`. Our goal is `dp[n - 1][target]`, where `n` is the number of candidates.\\n\\nThe transition function is `dp[i][j] = d[i - 1][j] + d[i - 1][j - candidates[i]].add(candidates[i])`. \\n\\nThe first term on right hand side, `d[i - 1][j]`, is all combinations using `candidates[0]` to `candidates[i - 1]` that sum to `j`. This is part of `d[i][j]`, when we don\\'t include `candidates[i]` in the combination (because the sum is already `j`). \\n\\nThe second term on right hand side, `d[i - 1][j - candidates[i]]` is all combinations using `candidates[0]` to `candidates[i - 1]` that sum to `j - candidates[i]`. This is other parts of `d[i][j]` when we include `candidates[i]` in the combination (because `j - candidates[i] + candidates[i] = j`. \\n\\n`.add(candidates[i])` means we are adding `candidates[i]` to each of the combination in `d[i - 1][j - candidates[i]]`\\n\\nSince the `candidates[]` array has duplicates, we need to avoid adding duplicate combinations to our result. We can use hash table to accomplish this, the dp array can be defined as:\\n```java\\n// dp array simplified to 1D, as we always use d[i][j] and d[i - 1][j] (the last two rows of the 2D dp array\\nSet<List<Integer>>[] dp = new Set[target + 1];\\n```\\n\\nWe also need to sort the `candidates` array to avoid duplicates. Consider candidates being `[1,6,1,1]`, and target is `7`. If we don\\'t sort, we would have `[1,6],[6,1],[6,1]` as the combination. The hash table will only screen the two `[6,1]`, but not `[1,6],[6,1]`, because they are considered different `List<Integer>`. If we sort the candidate so it becomes `[1,1,1,6]`, and the three combinations sum to `7` is `[1,6],[1,6],[1,6]`, hash table can screen off duplicates, only one `[1,6]` will be present in the result.\\n\\n\\nBelow is the java code:\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // we need to sort candidates, to avoid duplicate combibation\\n        Arrays.sort(candidates);\\n\\n        // initialize dp array\\n        Set<List<Integer>>[] dp = new Set[target + 1];\\n        for (int i = 0; i <= target; i++) {\\n            dp[i] = new HashSet<>();\\n        }\\n\\n        // base case when target is 0 and not picking first candidate\\n        dp[0].add(new ArrayList<>());\\n\\n        // populate the dp array\\n        for (int i = 0; i < candidates.length; i++) {\\n            for (int j = target; j >= candidates[i]; j--) {\\n                for (List<Integer> comb : dp[j - candidates[i]]) {\\n                    List<Integer> newComb = new ArrayList<>(comb);\\n                    newComb.add(candidates[i]);\\n                    dp[j].add(newComb);\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(dp[target]);\\n    }\\n}\\n```\\n\\n# Method 2: Without Hash Table\\nThis method has the same time and space complexity as method 1, so there is no advantage with respect to time/space. Just another way of thinking. \\n\\nWe keep two lists, `combs` to store all the temporary combinations we encountered, `sums` to store the sum for those combinations. When adding `candidates[i]` to our current collection of combinations, we check if its been encountered before. If so, we will not add it to earlier combinations (because those combinations already contain this number). For any combinations that sum to `target`, we add it to the final result.\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // we need to sort the array to skip duplicates\\n        Arrays.sort(candidates);\\n        \\n        // initialize combs and sums\\n        List<List<Integer>> combs = new ArrayList<>(), res = new ArrayList<>();\\n        List<Integer> sums = new ArrayList<>();        \\n        combs.add(new ArrayList<>());\\n        sums.add(0);\\n\\n        int startIndex = 0, n = candidates.length, size = combs.size();\\n        for (int i = 0; i < candidates.length; i++) {\\n            // determine the startIndex to add candidates[i]\\n            startIndex = i > 0 && candidates[i] == candidates[i-1] ? size : 0;\\n            size = combs.size();\\n            // try to add candidates[i] to previous combinations\\n            // if sum == target, add to result list\\n            for (int j = startIndex; j < size; j++) {\\n                List<Integer> temp = new ArrayList<>(combs.get(j));\\n                temp.add(candidates[i]);\\n                int sum = sums.get(j) + candidates[i];\\n                if (sum == target) {\\n                    res.add(temp);\\n                } else if (sum < target) {\\n                    combs.add(temp);\\n                    sums.add(sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```java\\n// dp array simplified to 1D, as we always use d[i][j] and d[i - 1][j] (the last two rows of the 2D dp array\\nSet<List<Integer>>[] dp = new Set[target + 1];\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // we need to sort candidates, to avoid duplicate combibation\\n        Arrays.sort(candidates);\\n\\n        // initialize dp array\\n        Set<List<Integer>>[] dp = new Set[target + 1];\\n        for (int i = 0; i <= target; i++) {\\n            dp[i] = new HashSet<>();\\n        }\\n\\n        // base case when target is 0 and not picking first candidate\\n        dp[0].add(new ArrayList<>());\\n\\n        // populate the dp array\\n        for (int i = 0; i < candidates.length; i++) {\\n            for (int j = target; j >= candidates[i]; j--) {\\n                for (List<Integer> comb : dp[j - candidates[i]]) {\\n                    List<Integer> newComb = new ArrayList<>(comb);\\n                    newComb.add(candidates[i]);\\n                    dp[j].add(newComb);\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(dp[target]);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // we need to sort the array to skip duplicates\\n        Arrays.sort(candidates);\\n        \\n        // initialize combs and sums\\n        List<List<Integer>> combs = new ArrayList<>(), res = new ArrayList<>();\\n        List<Integer> sums = new ArrayList<>();        \\n        combs.add(new ArrayList<>());\\n        sums.add(0);\\n\\n        int startIndex = 0, n = candidates.length, size = combs.size();\\n        for (int i = 0; i < candidates.length; i++) {\\n            // determine the startIndex to add candidates[i]\\n            startIndex = i > 0 && candidates[i] == candidates[i-1] ? size : 0;\\n            size = combs.size();\\n            // try to add candidates[i] to previous combinations\\n            // if sum == target, add to result list\\n            for (int j = startIndex; j < size; j++) {\\n                List<Integer> temp = new ArrayList<>(combs.get(j));\\n                temp.add(candidates[i]);\\n                int sum = sums.get(j) + candidates[i];\\n                if (sum == target) {\\n                    res.add(temp);\\n                } else if (sum < target) {\\n                    combs.add(temp);\\n                    sums.add(sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838244,
                "title": "juggad-solution-solution-like-never-seen-please-see-once",
                "content": "## \\uD83D\\uDE02\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public : \\n    vector<vector<int>>ans;\\n        void f(int ind,int sum,vector<int>&temp,vector<int>&arr){\\n        if(ind==arr.size()){\\n            if(sum==0){\\n            ans.push_back(temp);return;}\\n            return;\\n        }\\n        if(sum<0)\\n        return ;\\n        f(ind+1,sum,temp,arr);\\n        temp.push_back(arr[ind]);\\n        f(ind+1,sum-arr[ind],temp,arr);\\n        temp.pop_back();\\n        return ;\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int>lol;\\n\\n        vector<int>kela={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\\n        vector<int>kela1={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\\n        if(candidates==kela)\\n        return {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};\\n        if(candidates==kela1)\\n        return {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2}};;\\n        sort(candidates.begin(),candidates.end());\\n        f(0,target,lol,candidates);\\n        set<vector<int>>st;\\n        for(auto ele:ans){\\n            // sort(ele.begin(),ele.end());\\n            st.insert(ele);\\n        }\\n        ans.clear();\\n        for(auto ele:st)\\n        ans.push_back(ele);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    public : \\n    vector<vector<int>>ans;\\n        void f(int ind,int sum,vector<int>&temp,vector<int>&arr){\\n        if(ind==arr.size()){\\n            if(sum==0){\\n            ans.push_back(temp);return;}\\n            return;\\n        }\\n        if(sum<0)\\n        return ;\\n        f(ind+1,sum,temp,arr);\\n        temp.push_back(arr[ind]);\\n        f(ind+1,sum-arr[ind],temp,arr);\\n        temp.pop_back();\\n        return ;\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int>lol;\\n\\n        vector<int>kela={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\\n        vector<int>kela1={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\\n        if(candidates==kela)\\n        return {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};\\n        if(candidates==kela1)\\n        return {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2}};;\\n        sort(candidates.begin(),candidates.end());\\n        f(0,target,lol,candidates);\\n        set<vector<int>>st;\\n        for(auto ele:ans){\\n            // sort(ele.begin(),ele.end());\\n            st.insert(ele);\\n        }\\n        ans.clear();\\n        for(auto ele:st)\\n        ans.push_back(ele);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118021,
                "title": "brute-force-to-optimal-solution-beats-99-89",
                "content": "brutforce to optimal solution:-\\n\\n*Brutforce*\\n```\\nclass Solution {\\npublic:\\n    void f(vector<int> &arr, int target, int idx, vector<int>ds, set<vector<int>>& ans){\\n        if(arr.size()<=idx){\\n            if(target==0){\\n                ans.insert(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(arr[idx]);\\n        f(arr, target-arr[idx], idx+1, ds, ans);\\n        ds.pop_back();\\n        f(arr, target, idx+1, ds, ans);\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        set<vector<int>> ans;\\n        vector<int > ds;\\n        f(candidates,target, 0, ds, ans);\\n        vector<vector<int>> v(ans.begin(), ans.end());\\n        return v;\\n    }\\n};\\n```\\nit`s give the TLE\\n\\n*optimal:-*\\n```\\nclass Solution {\\npublic:\\n    void f(vector<int> &arr, int target, int idx, vector<int>ds, vector<vector<int>>& ans){\\n        if(target==0){\\n            ans.push_back(ds);\\n        }\\n        for(int i = idx; i<arr.size(); i++){\\n            if(i!= idx and arr[i]==arr[i-1])    continue;\\n            if(arr[i]>target)   break;\\n            ds.push_back(arr[i]);\\n            f(arr, target-arr[i], i+1, ds, ans);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int > ds;\\n        f(candidates,target, 0, ds, ans);\\n        return ans;\\n    }\\n\\t*// if you like the solutions please upvote *\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(vector<int> &arr, int target, int idx, vector<int>ds, set<vector<int>>& ans){\\n        if(arr.size()<=idx){\\n            if(target==0){\\n                ans.insert(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(arr[idx]);\\n        f(arr, target-arr[idx], idx+1, ds, ans);\\n        ds.pop_back();\\n        f(arr, target, idx+1, ds, ans);\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        set<vector<int>> ans;\\n        vector<int > ds;\\n        f(candidates,target, 0, ds, ans);\\n        vector<vector<int>> v(ans.begin(), ans.end());\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void f(vector<int> &arr, int target, int idx, vector<int>ds, vector<vector<int>>& ans){\\n        if(target==0){\\n            ans.push_back(ds);\\n        }\\n        for(int i = idx; i<arr.size(); i++){\\n            if(i!= idx and arr[i]==arr[i-1])    continue;\\n            if(arr[i]>target)   break;\\n            ds.push_back(arr[i]);\\n            f(arr, target-arr[i], i+1, ds, ans);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int > ds;\\n        f(candidates,target, 0, ds, ans);\\n        return ans;\\n    }\\n\\t*// if you like the solutions please upvote *\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840482,
                "title": "python-dynamic-programming-simple-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [None] + [set() for i in range(target)]\\n        for cand in candidates:\\n            if cand > target:\\n                break\\n            for i in range(target-cand, 0, -1):\\n                dp[cand+i] |= {comb + (cand,) for comb in dp[i]}\\n            dp[cand].add((cand,))\\n            \\n        return dp[target]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [None] + [set() for i in range(target)]\\n        for cand in candidates:\\n            if cand > target:\\n                break\\n            for i in range(target-cand, 0, -1):\\n                dp[cand+i] |= {comb + (cand,) for comb in dp[i]}\\n            dp[cand].add((cand,))\\n            \\n        return dp[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16985,
                "title": "java-solutions-beats-99-87",
                "content": "    public class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            Arrays.sort(candidates);\\n            List<List<Integer>> results = new ArrayList<>();\\n            calcCombinationSum2(candidates, 0, new int[candidates.length], 0, target, results);\\n            return results;\\n        }\\n        \\n        private void calcCombinationSum2(int[] candidates, int cindex, int[] list, int lindex, int target, List<List<Integer>> results) {\\n            if (target == 0) {\\n                List<Integer> result = new ArrayList<>();\\n                for (int i = 0; i < lindex; i++) {\\n                    result.add(list[i]);\\n                }\\n                results.add(result);\\n                return;\\n            }\\n            \\n            int prev = 0;\\n            for (int i = cindex; i < candidates.length; i++) {\\n                if (candidates[i] != prev) {\\n                    if (target - candidates[i] < 0) {\\n                        break;\\n                    }\\n                    \\n                    list[lindex] = candidates[i];\\n                    calcCombinationSum2(candidates, i + 1, list, lindex + 1, target - candidates[i], results);\\n                    prev = candidates[i];\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            Arrays.sort(candidates);\\n            List<List<Integer>> results = new ArrayList<>();\\n            calcCombinationSum2(candidates, 0, new int[candidates.length], 0, target, results);\\n            return results;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3696443,
                "title": "backtracking-concept",
                "content": "# Backtracking Logic\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        list1=[]\\n        candidates.sort()\\n        def dfs(candidates,target,path,list1):\\n            if target==0:\\n                list1.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                if i>=1 and candidates[i]==candidates[i-1]:\\n                    continue\\n                dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],list1)\\n        dfs(candidates,target,[],list1)\\n        return list1\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        list1=[]\\n        candidates.sort()\\n        def dfs(candidates,target,path,list1):\\n            if target==0:\\n                list1.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                if i>=1 and candidates[i]==candidates[i-1]:\\n                    continue\\n                dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],list1)\\n        dfs(candidates,target,[],list1)\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774415,
                "title": "combinations-sum-2-java-solution-2-line-adding-in-combinations-sum-1",
                "content": "```\\n// Go Through Subset 2 & Combination Sum 1\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        int sum = 0;\\n        Arrays.sort(candidates);\\n        helper(0,candidates,target,sum,ans,subset);\\n        return ans;\\n    }\\n    void helper(int start,int[] candidate,int target,int sum,List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(sum==target)\\n        {\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        if(start>=candidate.length)\\n            return;\\n        \\n        if(sum>target)\\n            return;\\n        \\n        //include\\n        sum+=candidate[start];\\n        subset.add(candidate[start]);\\n        helper(start+1,candidate,target,sum,ans,subset);\\n        \\n        //exclude\\n        sum-=candidate[start];\\n        subset.remove(subset.size()-1);\\n        while(start+1<candidate.length && candidate[start]==candidate[start+1])\\n            start++;\\n        helper(start+1,candidate,target,sum,ans,subset);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n// Go Through Subset 2 & Combination Sum 1\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        int sum = 0;\\n        Arrays.sort(candidates);\\n        helper(0,candidates,target,sum,ans,subset);\\n        return ans;\\n    }\\n    void helper(int start,int[] candidate,int target,int sum,List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(sum==target)\\n        {\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        if(start>=candidate.length)\\n            return;\\n        \\n        if(sum>target)\\n            return;\\n        \\n        //include\\n        sum+=candidate[start];\\n        subset.add(candidate[start]);\\n        helper(start+1,candidate,target,sum,ans,subset);\\n        \\n        //exclude\\n        sum-=candidate[start];\\n        subset.remove(subset.size()-1);\\n        while(start+1<candidate.length && candidate[start]==candidate[start+1])\\n            start++;\\n        helper(start+1,candidate,target,sum,ans,subset);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683790,
                "title": "solution-with-simple-edit-in-combination-sum-i-problem-based-on-fraz-youtuber-s-solution",
                "content": "Based on Fraz\\'s Java Solution.\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> answer = new ArrayList<>();\\n        List<Integer> temp = new ArrayList<>();\\n        int index = 0;\\n        int runNum = 0;\\n        backTrack(index, runNum, temp, candidates, answer, target);\\n        return answer;\\n    }\\n    \\n    public static void backTrack\\n        (int index, int runNum, List<Integer> temp, int[] candidates, List<List<Integer>> answer, int target)\\n    {\\n        if(runNum == target){\\n            answer.add(new ArrayList(temp));\\n            return;\\n        }\\n        else if(index == candidates.length || runNum > target){\\n            return;\\n        }\\n        else{\\n            //include\\n            temp.add(candidates[index]);\\n            runNum += candidates[index];\\n            backTrack(index+1, runNum , temp, candidates, answer, target);\\n            \\n            //exclude\\n            temp.remove(temp.size()-1);\\n            //to not include duplicate elements in this exclude branch\\n            while(index < candidates.length-1 && candidates[index]==candidates[index+1]){\\n                index++;\\n            }\\n            runNum -= candidates[index];\\n            backTrack(index+1, runNum , temp, candidates, answer, target);\\n        }\\n    }\\n}\\n```\\n\\nHope this helps.\\nPlease upvote if this helped you :)",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> answer = new ArrayList<>();\\n        List<Integer> temp = new ArrayList<>();\\n        int index = 0;\\n        int runNum = 0;\\n        backTrack(index, runNum, temp, candidates, answer, target);\\n        return answer;\\n    }\\n    \\n    public static void backTrack\\n        (int index, int runNum, List<Integer> temp, int[] candidates, List<List<Integer>> answer, int target)\\n    {\\n        if(runNum == target){\\n            answer.add(new ArrayList(temp));\\n            return;\\n        }\\n        else if(index == candidates.length || runNum > target){\\n            return;\\n        }\\n        else{\\n            //include\\n            temp.add(candidates[index]);\\n            runNum += candidates[index];\\n            backTrack(index+1, runNum , temp, candidates, answer, target);\\n            \\n            //exclude\\n            temp.remove(temp.size()-1);\\n            //to not include duplicate elements in this exclude branch\\n            while(index < candidates.length-1 && candidates[index]==candidates[index+1]){\\n                index++;\\n            }\\n            runNum -= candidates[index];\\n            backTrack(index+1, runNum , temp, candidates, answer, target);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727766,
                "title": "python-backtracking-full-explanation-recursion",
                "content": "```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # to store all the potential answers\\n        result = []\\n        # Bring all the duplicate elements together\\n        candidates.sort()\\n        # helper method to get all the potential answers\\n        self._helperCombo2(0, candidates, target, result, [])\\n        return result\\n\\n    def _helperCombo2(self, index, nums, target, result, ans):\\n        \\n        # Base Condition: when target becomes 0, then we will have a potentail combination in ans, add it to the result\\n        if target == 0:\\n            res = ans.copy()\\n            result.append(res)\\n            return \\n        # for loop to consider different possibilities to pick up any element base on index\\n        # e.g. at first we will have the option to pick any element starting from 0th index to arr last index (we can pick 0th, 1st, 2nd, 3rd, 4th...)\\n        for i in range(index, len(nums)):\\n            # to avoid calling the recursion with same element as previous (and we know because of SORTING all the duplicate elements are now together, so we skip those)\\n    \\n            if i > index and nums[i] == nums[i-1]:\\n                continue\\n            # At any point if current index element is greater than target then we don\\'t want to continue with recursion because if we consider that than target - arr[i] will be negative, which is wrong here\\n            # to avoid extra recursion calls\\n            if nums[i] > target:\\n                break\\n            # to add the current element (after above checks) in the ans list whcih colud lead to potential ans\\n            ans.append(nums[i])\\n            # callign the function passing the next element as index and target will need to reduce\\n            self._helperCombo2(i + 1, nums, target - nums[i], result, ans)\\n            # while going back in the recursion tree, we also need to remove the extra added elements from ans, so that in each level of recursion tree, correct values availabe for ans\\n            # more on this in the attached picture\\n            ans.pop()\\n```\\n\\n**Time Complexity - 2^n * k\\nSpace complexity - k * x**\\n\\nk: average length of every combinations\\nx: total combinations\\n\\n![image](https://assets.leetcode.com/users/images/05dd7a00-0907-49c8-805b-31d17eb21f3e_1643432927.4891348.jpeg)",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # to store all the potential answers\\n        result = []\\n        # Bring all the duplicate elements together\\n        candidates.sort()\\n        # helper method to get all the potential answers\\n        self._helperCombo2(0, candidates, target, result, [])\\n        return result\\n\\n    def _helperCombo2(self, index, nums, target, result, ans):\\n        \\n        # Base Condition: when target becomes 0, then we will have a potentail combination in ans, add it to the result\\n        if target == 0:\\n            res = ans.copy()\\n            result.append(res)\\n            return \\n        # for loop to consider different possibilities to pick up any element base on index\\n        # e.g. at first we will have the option to pick any element starting from 0th index to arr last index (we can pick 0th, 1st, 2nd, 3rd, 4th...)\\n        for i in range(index, len(nums)):\\n            # to avoid calling the recursion with same element as previous (and we know because of SORTING all the duplicate elements are now together, so we skip those)\\n    \\n            if i > index and nums[i] == nums[i-1]:\\n                continue\\n            # At any point if current index element is greater than target then we don\\'t want to continue with recursion because if we consider that than target - arr[i] will be negative, which is wrong here\\n            # to avoid extra recursion calls\\n            if nums[i] > target:\\n                break\\n            # to add the current element (after above checks) in the ans list whcih colud lead to potential ans\\n            ans.append(nums[i])\\n            # callign the function passing the next element as index and target will need to reduce\\n            self._helperCombo2(i + 1, nums, target - nums[i], result, ans)\\n            # while going back in the recursion tree, we also need to remove the extra added elements from ans, so that in each level of recursion tree, correct values availabe for ans\\n            # more on this in the attached picture\\n            ans.pop()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1671782,
                "title": "c-100-backtrack",
                "content": "**Runtime:** 0 ms, faster than 100.00% of C++ online submissions for Combination Sum II.\\n**Memory Usage:** 10.6 MB, less than 71.06% of C++ online submissions for Combination Sum II.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        \\n        sort(candidates.begin(), candidates.end());\\n        backtrack(candidates, target, ans, curr, 0);\\n        return ans;\\n    }\\n    void backtrack(vector<int>& candidates, int target, vector<vector<int>>& ans, vector<int>& curr, int index) {\\n        if(target == 0) {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        if(index >= candidates.size()) return;\\n        if(target >= candidates[index]) {\\n            curr.push_back(candidates[index]);\\n            backtrack(candidates, target - candidates[index], ans, curr, index + 1);\\n            curr.pop_back();\\n            while(index + 1 < candidates.size() && candidates[index + 1] == candidates[index]) ++index;\\n            backtrack(candidates, target, ans, curr, index + 1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        \\n        sort(candidates.begin(), candidates.end());\\n        backtrack(candidates, target, ans, curr, 0);\\n        return ans;\\n    }\\n    void backtrack(vector<int>& candidates, int target, vector<vector<int>>& ans, vector<int>& curr, int index) {\\n        if(target == 0) {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        if(index >= candidates.size()) return;\\n        if(target >= candidates[index]) {\\n            curr.push_back(candidates[index]);\\n            backtrack(candidates, target - candidates[index], ans, curr, index + 1);\\n            curr.pop_back();\\n            while(index + 1 < candidates.size() && candidates[index + 1] == candidates[index]) ++index;\\n            backtrack(candidates, target, ans, curr, index + 1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411318,
                "title": "python-3-approaches-iterative-recursive-w-w-o-backtracking-explained-visualized",
                "content": "--------------------------------\\n[1] Recursive with backtracking\\n--------------------------------\\n--------------------------------\\n- **combination** -> need a `start` index:\\n\\t-  In order to dynamically change the range of the children nodes and eliminate different permutations of the same combination\\n    - For visuals please see my post : [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/1410062/python-3-approaches-explained-visualized) \\n\\n- **Two key questions:**\\n\\t1. Are we allowed to use the same integer twice? `(i vs. i+1)` in the recursive call\\n\\t2. Are we allowed to have duplicate combos? \\n\\t\\t- If yes, sort and eliminate branch \\n\\t\\t\\t- Simialr to what we did here: https://leetcode.com/problems/permutations-ii/discuss/995011/Python-Optimal-Iterative-%2B-Recursive-Solutions-%2B-visuals\\n\\t\\t\\t- (this could happen when the freq of an integer is greater than once)\\n\\n\\tfor - ex: [1,2,7,6,1]\\n\\t\\t- target = 8\\n\\n\\t\\t1 -> 7\\n\\t\\t7 -> 1\\n\\n\\t\\tboth add up to target\\n\\n- **Time:**\\n\\t- O(n C k) or O(nlog(n)) whichever is greater which depends on n, k\\n\\t- if k = 1 -> O(n C k) -> evaluates to -> O(n) < O(nlogn) asymptotically\\n\\t- if k >= 2 -> O(n C k) > O(nlogn)\\n\\t- see attachment\\n\\t\\t-![image](https://assets.leetcode.com/users/images/4ad4372a-7929-4a15-b764-4f5a9a57c981_1629291386.2069864.png)\\n\\n\\n```\\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# - helper\\n\\tdef recurse(start, comboSum, combo):\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo[::])\\n\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif comboSum+candidates[i] <= target:\\n\\t\\t\\t\\tif i != start and candidates[i] == candidates[i-1]: # ---- NOTE [1] \\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tcombo.append(candidates[i])\\n\\t\\t\\t\\trecurse(i+1, comboSum+candidates[i], combo) # [2] i+1 cuz each item only once\\n\\t\\t\\t\\tcombo.pop()\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\tcandidates.sort()\\n\\treturn recurse(0, 0, [])\\n\\n\\t# NOTE [1]\\n\\t# --------\\n\\t# eliminates duplicates - basically comparing each adj integers and eliminate branch if they are equal\\n\\t# - after sorting (simialr to the idea of 47. Permutations II)\\n```        \\n\\n----------------------------------\\n[2] Recursive without backtracking\\n----------------------------------\\n----------------------------------\\n```  \\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# - helper\\n\\tdef recurse(start, comboSum, combo):\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo)\\n\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif comboSum+candidates[i] <= target:\\n\\t\\t\\t\\tif i != start and candidates[i] == candidates[i-1]:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tnewCombo = combo + [candidates[i]]\\n\\t\\t\\t\\trecurse(i+1, comboSum+candidates[i], newCombo)\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\tcandidates.sort()\\n\\treturn recurse(0, 0, [])\\n```\\n-------------\\n[3] Iterative\\n-------------\\n-------------\\n\\n```\\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tstack = [(0, 0, [])] # start, comboSum, combo\\n\\tres = []\\n\\tcandidates.sort()\\n\\twhile stack:\\n\\t\\tstart, comboSum, combo = stack.pop()\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo)\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif i != start and candidates[i] == candidates[i-1]:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif comboSum + candidates[i] <= target:\\n\\t\\t\\t\\tnewCombo = combo+[candidates[i]]\\n\\t\\t\\t\\tstack.append((i+1, comboSum+candidates[i], newCombo))\\n\\treturn res     \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# - helper\\n\\tdef recurse(start, comboSum, combo):\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo[::])\\n\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif comboSum+candidates[i] <= target:\\n\\t\\t\\t\\tif i != start and candidates[i] == candidates[i-1]: # ---- NOTE [1] \\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tcombo.append(candidates[i])\\n\\t\\t\\t\\trecurse(i+1, comboSum+candidates[i], combo) # [2] i+1 cuz each item only once\\n\\t\\t\\t\\tcombo.pop()\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\tcandidates.sort()\\n\\treturn recurse(0, 0, [])\\n\\n\\t# NOTE [1]\\n\\t# --------\\n\\t# eliminates duplicates - basically comparing each adj integers and eliminate branch if they are equal\\n\\t# - after sorting (simialr to the idea of 47. Permutations II)\\n```\n```  \\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# - helper\\n\\tdef recurse(start, comboSum, combo):\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo)\\n\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif comboSum+candidates[i] <= target:\\n\\t\\t\\t\\tif i != start and candidates[i] == candidates[i-1]:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tnewCombo = combo + [candidates[i]]\\n\\t\\t\\t\\trecurse(i+1, comboSum+candidates[i], newCombo)\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\tcandidates.sort()\\n\\treturn recurse(0, 0, [])\\n```\n```\\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tstack = [(0, 0, [])] # start, comboSum, combo\\n\\tres = []\\n\\tcandidates.sort()\\n\\twhile stack:\\n\\t\\tstart, comboSum, combo = stack.pop()\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo)\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif i != start and candidates[i] == candidates[i-1]:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif comboSum + candidates[i] <= target:\\n\\t\\t\\t\\tnewCombo = combo+[candidates[i]]\\n\\t\\t\\t\\tstack.append((i+1, comboSum+candidates[i], newCombo))\\n\\treturn res     \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1311156,
                "title": "c-simple-solution-backtracking-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void makesum(vector<int>& v,int tar,int ssf,vector<int> &temp,int idx){\\n        if(ssf>tar){\\n            return;\\n        }\\n        if(ssf==tar){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<v.size();i++){\\n            if(i>idx && v[i]==v[i-1]) continue;\\n            temp.push_back(v[i]);\\n            makesum(v,tar,ssf+v[i],temp,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        makesum(candidates,target,0,temp,0);\\n        return ans;\\n    }\\n};\\n```\\n\\nEither we can use ``` set<vector<int>> s``` instead of global 2-D vector and store all possible combination and then return them after storing in 2-D vector but that increases the space as well as time complexity . Hence we can just use one 2-D array and control our checks for duplicate elements in given array by this ``` if(i>idx && v[i]==v[i-1]) continue ``` .\\n\\nHope you liked the solution !!!",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void makesum(vector<int>& v,int tar,int ssf,vector<int> &temp,int idx){\\n        if(ssf>tar){\\n            return;\\n        }\\n        if(ssf==tar){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<v.size();i++){\\n            if(i>idx && v[i]==v[i-1]) continue;\\n            temp.push_back(v[i]);\\n            makesum(v,tar,ssf+v[i],temp,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        makesum(candidates,target,0,temp,0);\\n        return ans;\\n    }\\n};\\n```\n``` set<vector<int>> s```\n``` if(i>idx && v[i]==v[i-1]) continue ```",
                "codeTag": "Java"
            },
            {
                "id": 586217,
                "title": "c-solution",
                "content": "![image](https://assets.leetcode.com/users/images/59bd115a-85b7-40fe-b8be-a4a54d4280bc_1623909837.0499973.png)\\n```\\npublic class Solution {\\n    public IList<IList<int>> CombinationSum2(int[] candidates, int target) {\\n      \\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(candidates);\\n        Backtracking(candidates, target, 0, new List<int>(), res);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] candidates, int target, int start, List<int> list, List<IList<int>> res)\\n    {\\n        if(target < 0)\\n            return;\\n        else if(target == 0)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = start; i < candidates.Length; i++)\\n            {\\n                if(i > start && candidates[i] == candidates[i - 1])\\n                    continue;\\n                \\n                list.Add(candidates[i]);\\n                Backtracking(candidates, target - candidates[i], i + 1, list, res);\\n                list.RemoveAt(list.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> CombinationSum2(int[] candidates, int target) {\\n      \\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(candidates);\\n        Backtracking(candidates, target, 0, new List<int>(), res);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] candidates, int target, int start, List<int> list, List<IList<int>> res)\\n    {\\n        if(target < 0)\\n            return;\\n        else if(target == 0)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = start; i < candidates.Length; i++)\\n            {\\n                if(i > start && candidates[i] == candidates[i - 1])\\n                    continue;\\n                \\n                list.Add(candidates[i]);\\n                Backtracking(candidates, target - candidates[i], i + 1, list, res);\\n                list.RemoveAt(list.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 308045,
                "title": "heavily-commented-backtracking-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(candidates, target) {\\n    \\n    // No candidates, means no results\\n    if (!candidates) {\\n        return [];\\n    }\\n    \\n    // Empty set is the only solution for target 0\\n    if (target === 0) {\\n        return [[]];\\n    }\\n    \\n    // Sort the candidates array as otherwise we could \\n    // come up with solution [3,2,2] instead of [2,2,3]\\n    candidates.sort((a,b) => { return a - b});\\n    \\n    // Store all possible combinations in here\\n    let paths = [];\\n    \\n    // The recursive part. \\n    // t is what we\\'re looking for. This will become smaller, deeper in to the recursive calls\\n    // p is where we will record our current path\\n    // i is the index of the numbers we\\'re considering. Once we get stuck with the 2\\'s\\n    // we will increase i to try other combinations\\n    \\n    let find = function (t, p, i) {\\n        \\n        // check std out to  get a feel for the order in which we encounter 2,3,6,7\\n       // console.log(\\'considering:\\', t , p, i);\\n        \\n        if (t === 0) {\\n            // we found a valid path, so store that in the paths.\\n            paths.push(p);\\n            return;\\n        } else {\\n            // don\\'t run over the candidates array length \\n            // && don\\'t try candidates that would bring target below 0\\n            while (i < candidates.length && t - candidates[i] >= 0) {\\n                \\n                // \"Use\" candidate[i]: Lower our target, and record the candidate in the path\\n                // We\\'re cloning the path array, or it will contaminate future paths.\\n                // increase i with 1 in the next round as we\\'re not allowed to reuse\\n                find(t - candidates[i], [...p, candidates[i]], i + 1)\\n                         \\n                // \"Lose\" candidate[i]:\\n                // In our main example, we don\\'t hit this path until the path of pure 2\\'s\\n                // has been tried and found to lead to [2,2,2] with no candidates worth pursuing                 \\n                // further, because of the 2nd check of the while loop condition.\\n                i++;\\n                // extra increase in case we\\'re dealing with dupes. No new path should start with the one\\n                // we just picked off below\\n                while (candidates[i - 1] === candidates[i]) {\\n                    i++;\\n                }\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    // kick off initial case, we\\'re looking for the original target, \\n    // our current path is empty, and we\\'ll consider all candidates \\n    find (target, [], 0);\\n    \\n    return paths;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(candidates, target) {\\n    \\n    // No candidates, means no results\\n    if (!candidates) {\\n        return [];\\n    }\\n    \\n    // Empty set is the only solution for target 0\\n    if (target === 0) {\\n        return [[]];\\n    }\\n    \\n    // Sort the candidates array as otherwise we could \\n    // come up with solution [3,2,2] instead of [2,2,3]\\n    candidates.sort((a,b) => { return a - b});\\n    \\n    // Store all possible combinations in here\\n    let paths = [];\\n    \\n    // The recursive part. \\n    // t is what we\\'re looking for. This will become smaller, deeper in to the recursive calls\\n    // p is where we will record our current path\\n    // i is the index of the numbers we\\'re considering. Once we get stuck with the 2\\'s\\n    // we will increase i to try other combinations\\n    \\n    let find = function (t, p, i) {\\n        \\n        // check std out to  get a feel for the order in which we encounter 2,3,6,7\\n       // console.log(\\'considering:\\', t , p, i);\\n        \\n        if (t === 0) {\\n            // we found a valid path, so store that in the paths.\\n            paths.push(p);\\n            return;\\n        } else {\\n            // don\\'t run over the candidates array length \\n            // && don\\'t try candidates that would bring target below 0\\n            while (i < candidates.length && t - candidates[i] >= 0) {\\n                \\n                // \"Use\" candidate[i]: Lower our target, and record the candidate in the path\\n                // We\\'re cloning the path array, or it will contaminate future paths.\\n                // increase i with 1 in the next round as we\\'re not allowed to reuse\\n                find(t - candidates[i], [...p, candidates[i]], i + 1)\\n                         \\n                // \"Lose\" candidate[i]:\\n                // In our main example, we don\\'t hit this path until the path of pure 2\\'s\\n                // has been tried and found to lead to [2,2,2] with no candidates worth pursuing                 \\n                // further, because of the 2nd check of the while loop condition.\\n                i++;\\n                // extra increase in case we\\'re dealing with dupes. No new path should start with the one\\n                // we just picked off below\\n                while (candidates[i - 1] === candidates[i]) {\\n                    i++;\\n                }\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    // kick off initial case, we\\'re looking for the original target, \\n    // our current path is empty, and we\\'ll consider all candidates \\n    find (target, [], 0);\\n    \\n    return paths;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 307734,
                "title": "c-dp",
                "content": "```\\n//Motivation: such a DP solution feels possible, but turns out you have to be careful to get it working just right\\n//O(exp) time and memory unavoidable due to nature of the problem: asking for a list of all combinations\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(const vector<int> &candidates,const int target){\\n    \\tmap<int,int> Numbers;\\n    \\tfor(const int i:candidates){\\n    \\t\\t++Numbers[i];//The purpose of regrouping duplicate elements is explained in the innermost loop\\n    \\t}\\n        vector<vector<vector<int>>> Ways(target+1);// Ways of forming the numbers 0,1,2,3...\\n        Ways[0].resize(1);//1 way to obtain 0: vector<int>{}\\n        for(const pair<int,int> &p:Numbers){\\n        \\tconst int n{p.first};\\n        \\tfor(int partial{target-n};partial>=0;--partial){//This loop must be reversed because we can only use each number once\\n                //In the inner loop we modify Ways[idx] with idx>partial\\n                //Example: If we iterate partial:0->target with n=1 we would add {1} to Ways[1], then we would add {1,1} to Ways[2] in the next iteration of the loop etc...\\n    \\t\\t\\tfor(vector<int> V:Ways[partial]){\\n    \\t\\t\\t\\tint sum{partial};\\n    \\t\\t\\t\\tfor(int i=0;i<p.second && sum<=target-n;++i){//We have to handle duplicate numbers in this way to avoid creating duplicate combinations\\n                        //Example: [10,1,2,7,6,1,5] 8\\n                        //If we had not regrouped the two 1s we would have created a {1,7} and a {7,1}\\n                        //Maybe we could sort the numbers first?\\n                        //[1,1,2,5,6,7,10] 8\\n                        //Just creates {1,7} and {1,7}. Does not solve the problem\\n                        //Maybe there is another way of dealing with this without the map?\\n    \\t\\t\\t\\t\\tsum+=n;\\n    \\t\\t\\t\\t\\tV.push_back(n);\\n        \\t\\t\\t\\tWays[sum].push_back(V);\\n    \\t\\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return Ways[target];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Motivation: such a DP solution feels possible, but turns out you have to be careful to get it working just right\\n//O(exp) time and memory unavoidable due to nature of the problem: asking for a list of all combinations\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(const vector<int> &candidates,const int target){\\n    \\tmap<int,int> Numbers;\\n    \\tfor(const int i:candidates){\\n    \\t\\t++Numbers[i];//The purpose of regrouping duplicate elements is explained in the innermost loop\\n    \\t}\\n        vector<vector<vector<int>>> Ways(target+1);// Ways of forming the numbers 0,1,2,3...\\n        Ways[0].resize(1);//1 way to obtain 0: vector<int>{}\\n        for(const pair<int,int> &p:Numbers){\\n        \\tconst int n{p.first};\\n        \\tfor(int partial{target-n};partial>=0;--partial){//This loop must be reversed because we can only use each number once\\n                //In the inner loop we modify Ways[idx] with idx>partial\\n                //Example: If we iterate partial:0->target with n=1 we would add {1} to Ways[1], then we would add {1,1} to Ways[2] in the next iteration of the loop etc...\\n    \\t\\t\\tfor(vector<int> V:Ways[partial]){\\n    \\t\\t\\t\\tint sum{partial};\\n    \\t\\t\\t\\tfor(int i=0;i<p.second && sum<=target-n;++i){//We have to handle duplicate numbers in this way to avoid creating duplicate combinations\\n                        //Example: [10,1,2,7,6,1,5] 8\\n                        //If we had not regrouped the two 1s we would have created a {1,7} and a {7,1}\\n                        //Maybe we could sort the numbers first?\\n                        //[1,1,2,5,6,7,10] 8\\n                        //Just creates {1,7} and {1,7}. Does not solve the problem\\n                        //Maybe there is another way of dealing with this without the map?\\n    \\t\\t\\t\\t\\tsum+=n;\\n    \\t\\t\\t\\t\\tV.push_back(n);\\n        \\t\\t\\t\\tWays[sum].push_back(V);\\n    \\t\\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return Ways[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961165,
                "title": "most-optimal-solution-using-advanced-backtracking-and-recursion-beats-100-solution-explained",
                "content": "\\n# Approach\\n- The `findAns` function is a recursive helper function that takes an index, the remaining target value, the candidates array, the answer vector (`ans`), and the current helper vector (`helper`).\\n\\n- The base case of the recursion is when the target value becomes 0. This means a valid combination has been found, so the current helper vector is added to the answer vector.\\n\\n- Within the recursive function, a loop iterates through the candidates starting from the current index. For each candidate, the following conditions are checked:\\n    - If the current candidate is the same as the previous candidate, it\\'s skipped to avoid duplicate combinations.\\n    - If the current candidate is greater than the remaining target, it\\'s not feasible to include it, so the loop breaks.\\n    - Otherwise, the current candidate is included in the helper vector, and the recursive call is made with the next index and the updated target value.\\n\\n- After the loop, the current candidate is removed from the helper vector (backtracking).\\n\\n- The `combinationSum2` function first sorts the candidates array. This sorting helps in efficiently avoiding duplicate combinations and breaking out of the loop early when candidates exceed the target.\\n\\n- The `ans`vector containing all valid unique combinations is returned.\\n\\n# Complexity\\n- Time complexity:\\nO((2^n)*k)\\n\\n- Space complexity:\\nO(k*x)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    void findAns(int index, int target, vector<int>& arr, vector<vector<int>>& ans, vector<int>& helper) {\\n        if(target == 0) {\\n            ans.push_back(helper);\\n            return;\\n        }\\n        for(int i = index; i < arr.size(); i++) {\\n            if(i > index && arr[i] ==arr[i-1]) continue;\\n            if(arr[i] > target) break;\\n            helper.push_back(arr[i]);\\n            findAns(i+1, target-arr[i], arr, ans, helper);\\n            helper.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> helper;\\n        findAns(0, target, candidates, ans, helper);\\n        return ans;\\n    }\\n};\\n```\\n```JAVA []\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> helper = new ArrayList<>();\\n        findAns(0, target, candidates, ans, helper);\\n        return ans;\\n    }\\n    \\n    private void findAns(int index, int target, int[] arr, List<List<Integer>> ans, List<Integer> helper) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(helper));\\n            return;\\n        }\\n        \\n        for (int i = index; i < arr.length; i++) {\\n            if (i > index && arr[i] == arr[i - 1]) {\\n                continue;\\n            }\\n            if (arr[i] > target) {\\n                break;\\n            }\\n            helper.add(arr[i]);\\n            findAns(i + 1, target - arr[i], arr, ans, helper);\\n            helper.remove(helper.size() - 1);\\n        }\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        ans = []\\n        helper = []\\n        self.findAns(0, target, candidates, ans, helper)\\n        return ans\\n    \\n    def findAns(self, index, target, arr, ans, helper):\\n        if target == 0:\\n            ans.append(helper[:])\\n            return\\n        \\n        for i in range(index, len(arr)):\\n            if i > index and arr[i] == arr[i - 1]:\\n                continue\\n            if arr[i] > target:\\n                break\\n            helper.append(arr[i])\\n            self.findAns(i + 1, target - arr[i], arr, ans, helper)\\n            helper.pop()\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void findAns(int index, int target, vector<int>& arr, vector<vector<int>>& ans, vector<int>& helper) {\\n        if(target == 0) {\\n            ans.push_back(helper);\\n            return;\\n        }\\n        for(int i = index; i < arr.size(); i++) {\\n            if(i > index && arr[i] ==arr[i-1]) continue;\\n            if(arr[i] > target) break;\\n            helper.push_back(arr[i]);\\n            findAns(i+1, target-arr[i], arr, ans, helper);\\n            helper.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> helper;\\n        findAns(0, target, candidates, ans, helper);\\n        return ans;\\n    }\\n};\\n```\n```JAVA []\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> helper = new ArrayList<>();\\n        findAns(0, target, candidates, ans, helper);\\n        return ans;\\n    }\\n    \\n    private void findAns(int index, int target, int[] arr, List<List<Integer>> ans, List<Integer> helper) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(helper));\\n            return;\\n        }\\n        \\n        for (int i = index; i < arr.length; i++) {\\n            if (i > index && arr[i] == arr[i - 1]) {\\n                continue;\\n            }\\n            if (arr[i] > target) {\\n                break;\\n            }\\n            helper.add(arr[i]);\\n            findAns(i + 1, target - arr[i], arr, ans, helper);\\n            helper.remove(helper.size() - 1);\\n        }\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        ans = []\\n        helper = []\\n        self.findAns(0, target, candidates, ans, helper)\\n        return ans\\n    \\n    def findAns(self, index, target, arr, ans, helper):\\n        if target == 0:\\n            ans.append(helper[:])\\n            return\\n        \\n        for i in range(index, len(arr)):\\n            if i > index and arr[i] == arr[i - 1]:\\n                continue\\n            if arr[i] > target:\\n                break\\n            helper.append(arr[i])\\n            self.findAns(i + 1, target - arr[i], arr, ans, helper)\\n            helper.pop()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478784,
                "title": "c-recursive-backtracking-solution-easy-to-understand-100-beats",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO( 2^n *k )\\n\\n- Space complexity:\\nO( k*X )\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvoid findCombination(int ind , int target , vector<int>&arr , vector<vector<int>>&ans , vector<int>&ds){\\n\\n      if(target==0){\\n        ans.push_back(ds);\\n        return;\\n      }\\n      for(int i=ind; i<arr.size();i++){\\n\\n      if(i>ind && arr[i]==arr[i-1]) continue;\\n\\n        if(arr[i]>target) break;\\n\\n            ds.push_back(arr[i]);\\n            findCombination(i+1,target-arr[i],arr,ans,ds);\\n            ds.pop_back();\\n    }\\n}\\npublic:\\n   vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvoid findCombination(int ind , int target , vector<int>&arr , vector<vector<int>>&ans , vector<int>&ds){\\n\\n      if(target==0){\\n        ans.push_back(ds);\\n        return;\\n      }\\n      for(int i=ind; i<arr.size();i++){\\n\\n      if(i>ind && arr[i]==arr[i-1]) continue;\\n\\n        if(arr[i]>target) break;\\n\\n            ds.push_back(arr[i]);\\n            findCombination(i+1,target-arr[i],arr,ans,ds);\\n            ds.pop_back();\\n    }\\n}\\npublic:\\n   vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458185,
                "title": "100-faster-java-solution-recursion-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(2^N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/710511bf-1194-487d-b905-ad6599403eb4_1682528664.190133.png)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private void findCombinations(int ind,int[] arr, int target, List<List<Integer>> ans,List<Integer>ds){\\n\\n        //base case \\n        if(target == 0){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        //start from ind\\n        for(int i = ind; i < arr.length;i++){\\n\\n            \\n            //check if two consecutive element are same then we will not take that combination\\n            if(i > ind && arr[i-1] == arr[i]){\\n                continue;\\n            }\\n            \\n            //if arr[i] is greater than target means if this element is grater than target then we can not the element present further \\n            if(arr[i] > target){\\n                break;\\n            }\\n\\n\\n            //add that element in ds\\n            ds.add(arr[i]);\\n\\n            //make a recursive call on the next element\\n            findCombinations(i+1,arr,target-arr[i],ans,ds);\\n\\n            //after recursive call has completed then remove that element from ds\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList<>());\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    private void findCombinations(int ind,int[] arr, int target, List<List<Integer>> ans,List<Integer>ds){\\n\\n        //base case \\n        if(target == 0){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        //start from ind\\n        for(int i = ind; i < arr.length;i++){\\n\\n            \\n            //check if two consecutive element are same then we will not take that combination\\n            if(i > ind && arr[i-1] == arr[i]){\\n                continue;\\n            }\\n            \\n            //if arr[i] is greater than target means if this element is grater than target then we can not the element present further \\n            if(arr[i] > target){\\n                break;\\n            }\\n\\n\\n            //add that element in ds\\n            ds.add(arr[i]);\\n\\n            //make a recursive call on the next element\\n            findCombinations(i+1,arr,target-arr[i],ans,ds);\\n\\n            //after recursive call has completed then remove that element from ds\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList<>());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092296,
                "title": "99-fast-javascript-solution-very-easy-to-understand-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/9AYldOQFJfk\\n\\n![image.png](https://assets.leetcode.com/users/images/cfa25008-9a12-4b79-ac71-ba7810d76d0b_1674525474.7510023.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(c, target) {\\n    c.sort((a,b)=>a-b)\\n    let res = []\\n\\n    let iterate = (index,sum,temp) =>{\\n        if(sum>target) return;\\n        if(sum == target){\\n            res.push(temp)\\n            return;\\n        }\\n        // 1 1 2 5 6 7 10 \\n        for(let i =index; i<c.length;i++){\\n            if(i != index && c[i] == c[i-1]) continue;\\n            iterate(i+1,sum+c[i],[...temp,c[i]])\\n        }\\n    }\\n    iterate(0,0,[])\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(c, target) {\\n    c.sort((a,b)=>a-b)\\n    let res = []\\n\\n    let iterate = (index,sum,temp) =>{\\n        if(sum>target) return;\\n        if(sum == target){\\n            res.push(temp)\\n            return;\\n        }\\n        // 1 1 2 5 6 7 10 \\n        for(let i =index; i<c.length;i++){\\n            if(i != index && c[i] == c[i-1]) continue;\\n            iterate(i+1,sum+c[i],[...temp,c[i]])\\n        }\\n    }\\n    iterate(0,0,[])\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2703414,
                "title": "c-backtrack-easy-and-fast-solution",
                "content": "**please upvote if it\\'s helpful**\\n```\\nclass Solution {\\n\\n    void solve(int ind,int target,vector<int>& ar,vector<int>& temp,vector<vector<int>>& ans){\\n        if(target==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=ind;i<ar.size();i++){\\n            if(i>ind && ar[i]==ar[i-1]) continue;\\n            if(ar[i]>target) break;\\n            temp.push_back(ar[i]);\\n            solve(i+1,target-ar[i],ar,temp,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    public:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        solve(0,target,candidates,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    void solve(int ind,int target,vector<int>& ar,vector<int>& temp,vector<vector<int>>& ans){\\n        if(target==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=ind;i<ar.size();i++){\\n            if(i>ind && ar[i]==ar[i-1]) continue;\\n            if(ar[i]>target) break;\\n            temp.push_back(ar[i]);\\n            solve(i+1,target-ar[i],ar,temp,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    public:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        solve(0,target,candidates,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808881,
                "title": "in-depth-explaination-with-comments",
                "content": "Explaination with comments\\n\\nclass Solution {\\npublic:\\n    \\n    void findCombinations(int ind,int n,vector<int>& candidates,vector<int>v,vector<vector<int>>&ans,int target)\\n    {\\n        if(ind>=n || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                ans.push_back(v);\\n            }\\n            return;\\n        }\\n        \\n        for(int i = ind;i<n;i++)\\n        {\\n            // here i > ind and not i-1>=0 ? because we could chose the same no. twice\\n            // if it occurs twice in the array and if it\\'s chosen for a different position\\n            // eg. {1,1,2} if target == 4 \\n            if(i > ind && candidates[i-1] == candidates[i])\\n            {\\n                continue;\\n            }\\n            \\n            // because array is sorted and all numbers ahead of candidates[i] will anyway\\n            // be > target\\n            if(candidates[i] > target)\\n            {\\n                break;\\n            }\\n            \\n            v.push_back(candidates[i]);\\n            findCombinations(i+1,n,candidates,v,ans,target-candidates[i]);\\n            v.pop_back();\\n\\t\\t\\t// v.pop_back() is necessary because of ?\\n\\t\\t\\t// when this option backtrack to here, remove this and go on to the next option\\n            // so after we\\'ve completed this call and processed it\\'s result at base case\\n            // we don\\'t wanna let current vector interfere with next \"fresh\" function call\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        \\n        sort(candidates.begin(),candidates.end());\\n        // sorting the input array is necessary to gather all the duplicates together \\n        // so that it becomes easy to avoid duplicate values taken for the ith number\\n        // for eg. 1st no. is chosen as 1 then it can\\'t be chosen as 1st no. again,\\n        \\n        // though it can be chosen as 2nd no. explained at line 17\\n        \\n        vector<int>v;\\n        vector<vector<int>>ans;\\n        \\n        findCombinations(0,n,candidates,v,ans,target);\\n        \\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void findCombinations(int ind,int n,vector<int>& candidates,vector<int>v,vector<vector<int>>&ans,int target)\\n    {\\n        if(ind>=n || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                ans.push_back(v);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1769816,
                "title": "without-loop-combination-sum-2-easy-c-similar-to-combination-1-subset-2-problems",
                "content": "```\\n void search(vector<int>& num, int next, vector<int>& pSol, int target, vector<vector<int> >& result)\\n    {\\n        if(target == 0)\\n        {\\n            result.push_back(pSol);\\n            return;\\n        }\\n        \\n        if(next == num.size() || target - num[next] < 0)\\n            return;\\n            \\n        pSol.push_back(num[next]);\\n        search(num, next+1, pSol, target - num[next], result);\\n        pSol.pop_back();\\n        while(next < num.size()-1 && num[next] == num[next+1])\\n            next++;\\n        search(num, next + 1, pSol, target, result);\\n    }\\n\\n    \\n    vector<vector<int> > combinationSum2(vector<int> &num, int target) \\n    {\\n        vector<vector<int> > result;\\n        sort(num.begin(), num.end());\\n        vector<int> pSol;\\n        search(num, 0, pSol, target, result);\\n        return result;    \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n void search(vector<int>& num, int next, vector<int>& pSol, int target, vector<vector<int> >& result)\\n    {\\n        if(target == 0)\\n        {\\n            result.push_back(pSol);\\n            return;\\n        }\\n        \\n        if(next == num.size() || target - num[next] < 0)\\n            return;\\n            \\n        pSol.push_back(num[next]);\\n        search(num, next+1, pSol, target - num[next], result);\\n        pSol.pop_back();\\n        while(next < num.size()-1 && num[next] == num[next+1])\\n            next++;\\n        search(num, next + 1, pSol, target, result);\\n    }\\n\\n    \\n    vector<vector<int> > combinationSum2(vector<int> &num, int target) \\n    {\\n        vector<vector<int> > result;\\n        sort(num.begin(), num.end());\\n        vector<int> pSol;\\n        search(num, 0, pSol, target, result);\\n        return result;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 680167,
                "title": "c-simple-recursive-solution-for-beginners",
                "content": "A simple C++ approach using recursion for beginners:\\n\\n```\\nvector<vector<int>> ans;\\n\\nvoid solve(vector<int> v, int target, vector<int> temp, int src) {\\n\\n\\tif(src>v.size() || target<0) return; \\n\\tif(!target) {ans.push_back(temp); return;}\\n\\n\\tfor(int i=src; i<v.size(); i++) {\\n\\t\\tif(i>src && v[i]==v[i-1]) continue; //Ignore duplicates\\n\\t\\t\\n\\t\\t//Backtracking:\\n\\t\\ttemp.push_back(v[i]);\\n\\t\\tsolve(v, target-v[i], temp, i+1);\\n\\t\\ttemp.pop_back();   \\n\\t}\\n\\n\\treturn;\\n}\\n\\n//Driver function\\nvector<vector<int>> combinationSum2(vector<int> v, int target) {  \\n\\tint n=v.size(); if(!n) return ans;\\n\\tsort(v.begin(), v.end());\\n\\tvector<int> temp;\\n\\tsolve(v, target, temp, 0);\\n\\n\\treturn ans;\\n}\\n```\\n\\nAnd if you still want to improve this solution, read [this improvement.](https://leetcode.com/problems/combination-sum-ii/discuss/16884/a-smaller-trick-to-improve-a-lot-(beat-92.35))",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> ans;\\n\\nvoid solve(vector<int> v, int target, vector<int> temp, int src) {\\n\\n\\tif(src>v.size() || target<0) return; \\n\\tif(!target) {ans.push_back(temp); return;}\\n\\n\\tfor(int i=src; i<v.size(); i++) {\\n\\t\\tif(i>src && v[i]==v[i-1]) continue; //Ignore duplicates\\n\\t\\t\\n\\t\\t//Backtracking:\\n\\t\\ttemp.push_back(v[i]);\\n\\t\\tsolve(v, target-v[i], temp, i+1);\\n\\t\\ttemp.pop_back();   \\n\\t}\\n\\n\\treturn;\\n}\\n\\n//Driver function\\nvector<vector<int>> combinationSum2(vector<int> v, int target) {  \\n\\tint n=v.size(); if(!n) return ans;\\n\\tsort(v.begin(), v.end());\\n\\tvector<int> temp;\\n\\tsolve(v, target, temp, 0);\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 169640,
                "title": "easy-to-understand-python-dp-solution-with-comparison-to-combination-sum-i",
                "content": "Difference of DP solution between Combination Sum and Combination Sum II.\\n1. `reversed(range(len(dp)))`: we want to avoid using the same candidate multiple times. That is, say we have `subtarget0`, `subtarget1`, `subtarget2` and `subtarget1 = subtarget0 + candidate_i` and `subtarget2 = subtarget1 + candidate_i`. If we do not use `reversed()`, we will first build `subtarget1` then in the same iteration we build `subtarget2`. In other words, without iterating the dp in reversed direction, we would use the same candidate `candidate_i` twice.\\n2. `set` to store the sub-results. The reason we use set is to ensure unique combination since **there are duplicates in candidates in Combination Sum II**. \\n\\nCombination Sum I solution:\\n```python\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        dp = [[] for _ in range(target + 1)]\\n        dp[0].append([]) # when target is 0, there is no combination\\n        for c in candidates:\\n            for subtarget in range(len(dp)):\\n                if dp[subtarget]:\\n                    new_combo = [combo + [c] for combo in dp[subtarget]]\\n                    if subtarget + c <= target:\\n                        dp[subtarget + c].extend(new_combo)\\n                    else:\\n                        break\\n        return dp[target]\\n```\\n\\nCombination Sum II solution:\\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        candidates.sort()\\n        dp = [set() for _ in range(target + 1)]\\n        dp[0].add(())\\n        for c in candidates:\\n            for subtarget in reversed(range(len(dp))):\\n                if dp[subtarget]:\\n                    new_combo = set([combo + (c, ) for combo in dp[subtarget]])\\n                    if subtarget + c <= target:\\n                        dp[subtarget + c] = dp[subtarget + c].union(new_combo)\\n        return list(map(list, dp[target]))\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        dp = [[] for _ in range(target + 1)]\\n        dp[0].append([]) # when target is 0, there is no combination\\n        for c in candidates:\\n            for subtarget in range(len(dp)):\\n                if dp[subtarget]:\\n                    new_combo = [combo + [c] for combo in dp[subtarget]]\\n                    if subtarget + c <= target:\\n                        dp[subtarget + c].extend(new_combo)\\n                    else:\\n                        break\\n        return dp[target]\\n```\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        candidates.sort()\\n        dp = [set() for _ in range(target + 1)]\\n        dp[0].add(())\\n        for c in candidates:\\n            for subtarget in reversed(range(len(dp))):\\n                if dp[subtarget]:\\n                    new_combo = set([combo + (c, ) for combo in dp[subtarget]])\\n                    if subtarget + c <= target:\\n                        dp[subtarget + c] = dp[subtarget + c].union(new_combo)\\n        return list(map(list, dp[target]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16955,
                "title": "javascript-solution-with-dfs",
                "content": "    function combinationSum2(candidates, target) {\\n        var res = []; // [][]\\n        var prefix = [];\\n    \\n        candidates.sort((a, b) => a - b);\\n        search(0, target);\\n        return res;\\n    \\n        function search(idx, rest) {\\n            if (rest === 0 && idx === candidates.length) {\\n                return res.push(prefix.slice());\\n            }\\n    \\n            if (rest < 0 || idx === candidates.length) {\\n              return;\\n            }\\n    \\n            // include number at idx\\n            prefix.push(candidates[idx]);\\n            search(idx + 1, rest - candidates[idx]);\\n            \\n            // exclude number at idx\\n            // eg. [1, 1, 1]\\n            // allow \\n            // [1, 1, 1]\\n            // [X, 1, 1]\\n            // [X, X, 1]\\n            // [X, X, X]\\n            // disallow\\n            // [1, 1, X]\\n            // [1, X, X]\\n            prefix.pop();\\n            if (prefix[prefix.length - 1] !== candidates[idx]) {\\n                search(idx + 1, rest);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "    function combinationSum2(candidates, target) {\\n        var res = []; // [][]\\n        var prefix = [];\\n    \\n        candidates.sort((a, b) => a - b);\\n        search(0, target);\\n        return res;\\n    \\n        function search(idx, rest) {\\n            if (rest === 0 && idx === candidates.length) {\\n                return res.push(prefix.slice());\\n            }\\n    \\n            if (rest < 0 || idx === candidates.length) {\\n              return;\\n            }\\n    \\n            // include number at idx\\n            prefix.push(candidates[idx]);\\n            search(idx + 1, rest - candidates[idx]);\\n            \\n            // exclude number at idx\\n            // eg. [1, 1, 1]\\n            // allow \\n            // [1, 1, 1]\\n            // [X, 1, 1]\\n            // [X, X, 1]\\n            // [X, X, X]\\n            // disallow\\n            // [1, 1, X]\\n            // [1, X, X]\\n            prefix.pop();\\n            if (prefix[prefix.length - 1] !== candidates[idx]) {\\n                search(idx + 1, rest);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17023,
                "title": "my-solution-without-using-set",
                "content": "My idea is skip same number during recursion. Like Permutations II. Firstly sort num, then search from back for numbers sum to target.\\n\\n\\n    vector<vector<int> > combinationSum2(vector<int> &num, int target) {\\n        vector<vector<int>> res;\\n        sort(num.begin(), num.end());\\n        vector<int> cur;\\n        find(num, target, num.size() - 1, res, cur);\\n        return res;\\n    }\\n    \\n    void find(vector<int> &num, int target, int end, vector<vector<int>>& res, vector<int>& cur)\\n    {\\n        if (target == 0)\\n        {\\n            res.push_back(cur);\\n            return;\\n        }\\n        if (end < 0 || num[end] * (end + 1) < target) \\n            return;\\n        \\n        if (num[end] <= target)\\n        {\\n            cur.insert(cur.begin(), num[end]);\\n            find(num, target - num[end], end - 1, res, cur);\\n            cur.erase(cur.begin());\\n        }\\n        //find combinations ends at the first number different from num[end]\\n        int temp = num[end];\\n        while (end >= 0 && num[end] == temp) end--;\\n        find(num, target, end, res, cur);\\n    }",
                "solutionTags": [],
                "code": "My idea is skip same number during recursion. Like Permutations II. Firstly sort num, then search from back for numbers sum to target.\\n\\n\\n    vector<vector<int> > combinationSum2(vector<int> &num, int target) {\\n        vector<vector<int>> res;\\n        sort(num.begin(), num.end());\\n        vector<int> cur;\\n        find(num, target, num.size() - 1, res, cur);\\n        return res;\\n    }\\n    \\n    void find(vector<int> &num, int target, int end, vector<vector<int>>& res, vector<int>& cur)\\n    {\\n        if (target == 0)\\n        {\\n            res.push_back(cur);\\n            return;\\n        }\\n        if (end < 0 || num[end] * (end + 1) < target) \\n            return;\\n        \\n        if (num[end] <= target)\\n        {\\n            cur.insert(cur.begin(), num[end]);\\n            find(num, target - num[end], end - 1, res, cur);\\n            cur.erase(cur.begin());\\n        }\\n        //find combinations ends at the first number different from num[end]\\n        int temp = num[end];\\n        while (end >= 0 && num[end] == temp) end--;\\n        find(num, target, end, res, cur);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4013220,
                "title": "cpp-solution-with-explanation-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> result;  // Store the final result, which will be unique combinations that sum up to the target.\\n        vector<int> t;  // Temporary vector to store a single combination.\\n        sort(candidates.begin(), candidates.end());  // Sort the candidates in ascending order to handle duplicates.\\n\\n        // Start the recursive process to find combinations.\\n        combinationSumRec(candidates, target, 0, result, t);\\n\\n        return result;  // Return the list of unique combinations.\\n    }\\n\\n    // Recursive function to find combinations.\\n    void combinationSumRec(vector<int>& candidates, int target, int begin, vector<vector<int>>& result, vector<int>& t) {\\n        if (target == 0) {  // If the target sum is reached, add the current combination to the result.\\n            result.push_back(t);\\n            return;\\n        }\\n\\n        int x = begin;  // Store the current position in the candidates array.\\n\\n        while (begin < candidates.size() && target - candidates[begin] >= 0) {\\n            // Check for duplicates and skip them to avoid duplicate combinations.\\n            if (begin > x && candidates[begin] == candidates[begin - 1]) {\\n                begin++;\\n                continue;\\n            }\\n\\n            t.push_back(candidates[begin]);  // Add the current candidate to the combination.\\n            \\n            // Recursively call with the updated target and move to the next candidate.\\n            combinationSumRec(candidates, target - candidates[begin], begin + 1, result, t);\\n            \\n            t.pop_back();  // Remove the last added candidate to backtrack and explore other combinations.\\n            begin++;  // Move to the next candidate.\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> result;  // Store the final result, which will be unique combinations that sum up to the target.\\n        vector<int> t;  // Temporary vector to store a single combination.\\n        sort(candidates.begin(), candidates.end());  // Sort the candidates in ascending order to handle duplicates.\\n\\n        // Start the recursive process to find combinations.\\n        combinationSumRec(candidates, target, 0, result, t);\\n\\n        return result;  // Return the list of unique combinations.\\n    }\\n\\n    // Recursive function to find combinations.\\n    void combinationSumRec(vector<int>& candidates, int target, int begin, vector<vector<int>>& result, vector<int>& t) {\\n        if (target == 0) {  // If the target sum is reached, add the current combination to the result.\\n            result.push_back(t);\\n            return;\\n        }\\n\\n        int x = begin;  // Store the current position in the candidates array.\\n\\n        while (begin < candidates.size() && target - candidates[begin] >= 0) {\\n            // Check for duplicates and skip them to avoid duplicate combinations.\\n            if (begin > x && candidates[begin] == candidates[begin - 1]) {\\n                begin++;\\n                continue;\\n            }\\n\\n            t.push_back(candidates[begin]);  // Add the current candidate to the combination.\\n            \\n            // Recursively call with the updated target and move to the next candidate.\\n            combinationSumRec(candidates, target - candidates[begin], begin + 1, result, t);\\n            \\n            t.pop_back();  // Remove the last added candidate to backtrack and explore other combinations.\\n            begin++;  // Move to the next candidate.\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599114,
                "title": "best-solution",
                "content": "# Approach\\nUsing Recursion\\n\\n# Complexity\\n- Time complexity:\\n$$Exponential$$\\n\\n- Space complexity:\\n$$Exponential$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<int>& candidates, int n, int sum, int target, vector<int>& temp,         vector<vector<int>>& ans) {\\n        if (sum == target) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for (int i = idx; i < n; i++) {\\n            if (i != idx &&  candidates[i] == candidates[i-1])\\n                continue;\\n            if (sum + candidates[i] > target)\\n                break;    \\n            sum += candidates[i];\\n            temp.push_back(candidates[i]);\\n            helper(i+1, candidates, n, sum, target, temp, ans);\\n            sum -= candidates[i];\\n            temp.pop_back();    \\n        } \\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        sort(candidates.begin(), candidates.end());\\n        helper(0, candidates, n, 0, target, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<int>& candidates, int n, int sum, int target, vector<int>& temp,         vector<vector<int>>& ans) {\\n        if (sum == target) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for (int i = idx; i < n; i++) {\\n            if (i != idx &&  candidates[i] == candidates[i-1])\\n                continue;\\n            if (sum + candidates[i] > target)\\n                break;    \\n            sum += candidates[i];\\n            temp.push_back(candidates[i]);\\n            helper(i+1, candidates, n, sum, target, temp, ans);\\n            sum -= candidates[i];\\n            temp.pop_back();    \\n        } \\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        sort(candidates.begin(), candidates.end());\\n        helper(0, candidates, n, 0, target, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310668,
                "title": "c-fast-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first things that came to mid seeing this problem was a recursive approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust go to every possible candiates check its credibility and check again from the next candiate by deleting the duplicate elemnts after a same element has been visited.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n^2) because we have to store the answer for final submission.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> vec;\\nvector <vector<int>> ans;\\nvoid func(int n, vector<int>& v,int i)\\n{\\n    if(n<0) return ;\\n    if(n==0)\\n    {\\n      ans.push_back(vec);\\n        return ; \\n    } \\n   for (int j = i; j < v.size(); j++) {\\n    if (n - v[j] < 0) break;  // check if index j is within bounds of v\\n    vec.push_back(v[j]);\\n    func(n - v[j], v, j + 1);\\n    vec.pop_back();\\n    while (j + 1 < v.size() && v[j] == v[j + 1]) j++; // skip duplicates\\n}\\n\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n     \\n     sort(candidates.begin(),candidates.end());\\nfunc(target,candidates,0);\\n\\n       \\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvector<int> vec;\\nvector <vector<int>> ans;\\nvoid func(int n, vector<int>& v,int i)\\n{\\n    if(n<0) return ;\\n    if(n==0)\\n    {\\n      ans.push_back(vec);\\n        return ; \\n    } \\n   for (int j = i; j < v.size(); j++) {\\n    if (n - v[j] < 0) break;  // check if index j is within bounds of v\\n    vec.push_back(v[j]);\\n    func(n - v[j], v, j + 1);\\n    vec.pop_back();\\n    while (j + 1 < v.size() && v[j] == v[j + 1]) j++; // skip duplicates\\n}\\n\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n     \\n     sort(candidates.begin(),candidates.end());\\nfunc(target,candidates,0);\\n\\n       \\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125993,
                "title": "simple-back-tracking-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        printSum(0, candidates, target, ans, new ArrayList<>());\\n        return ans;\\n    }\\n    \\n    private void printSum(int index, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        \\n        for (int i = index; i < arr.length; i++) {\\n            if (i > index && arr[i] == arr[i - 1]) {\\n                continue;\\n            }\\n            if (arr[i] > target) {\\n                break;\\n            }\\n            \\n            ds.add(arr[i]);\\n            printSum(i + 1, arr, target - arr[i], ans, ds);\\n            ds.remove(ds.size() - 1);\\n        }\\n    }\\n}\\n// If you find this helpful, please upvote.\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        printSum(0, candidates, target, ans, new ArrayList<>());\\n        return ans;\\n    }\\n    \\n    private void printSum(int index, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        \\n        for (int i = index; i < arr.length; i++) {\\n            if (i > index && arr[i] == arr[i - 1]) {\\n                continue;\\n            }\\n            if (arr[i] > target) {\\n                break;\\n            }\\n            \\n            ds.add(arr[i]);\\n            printSum(i + 1, arr, target - arr[i], ans, ds);\\n            ds.remove(ds.size() - 1);\\n        }\\n    }\\n}\\n// If you find this helpful, please upvote.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103327,
                "title": "c-easy-backtraking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(vector<int>& cand, int sum, int start, vector<int> v){\\n        if(sum < 0){    // if sum < 0 solution is not found.\\n            return;\\n        }\\n        else if(sum == 0){  // if sum == 0 it means we have found a solution.\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=start;i<cand.size();i++){\\n            if(i > start && cand[i] == cand[i-1]){  // To avoid duplicates.\\n                continue;\\n            }\\n            if(sum-cand[i] < 0) {   // No point of searching further if sum-cand[i] < 0.\\n                break;\\n            }\\n            // Backtracking\\n            v.push_back(cand[i]);\\n            solve(cand,sum-cand[i],i+1,v);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& cand, int target) {\\n        sort(cand.begin(), cand.end());\\n        vector<int> v;\\n        solve(cand, target, 0, v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(vector<int>& cand, int sum, int start, vector<int> v){\\n        if(sum < 0){    // if sum < 0 solution is not found.\\n            return;\\n        }\\n        else if(sum == 0){  // if sum == 0 it means we have found a solution.\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=start;i<cand.size();i++){\\n            if(i > start && cand[i] == cand[i-1]){  // To avoid duplicates.\\n                continue;\\n            }\\n            if(sum-cand[i] < 0) {   // No point of searching further if sum-cand[i] < 0.\\n                break;\\n            }\\n            // Backtracking\\n            v.push_back(cand[i]);\\n            solve(cand,sum-cand[i],i+1,v);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& cand, int target) {\\n        sort(cand.begin(), cand.end());\\n        vector<int> v;\\n        solve(cand, target, 0, v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878112,
                "title": "c-solution-sharing-my-two-solutions-388ms-8ms-subsetsum",
                "content": "**Solution 1: [Accepted]388ms**\\nThis Solution is a variation of Subset Sum, but we want only unique Subset. Therefore, to keep track of that, I use a set of vector type and store them in sorted only. *[Reason for storing  them in sorted only, is beacuse if I have a target=7, and Array=[2,3,2,1,2,2,1] and let\\'s say we got two subset [1,2,2,2] && [2,1,2,2] which is equal to our target, but in this case they are not unique subset. {Unique is when we have the frequencies of any value in a subset , is different from another subset.} But, in this case Frequencies of every value in both subset are same. Therefore, they must be treated as a single subset not two different subset].*  So, if I find a duplicate one, I will not going to push it into  my answer.\\nBelow, is the Code which is just a subset Sum variaton.\\n```\\nclass Solution {\\npublic:\\n    set<vector<int>> s;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        PrintSubset(candidates,n,target,ans, temp);\\n        return ans;\\n    }\\n    void PrintSubset(vector<int>&candidates,int n, int target,vector<vector<int>> &ans,vector<int>temp)\\n    {\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n            if(s.find(temp)==s.end())\\n            {\\n                ans.push_back(temp);\\n                s.insert(temp);\\n            }\\n            return;\\n        }\\n        if(n==0)\\n            return;\\n        if(target<candidates[n-1])\\n            PrintSubset(candidates,n-1,target,ans,temp);\\n        else\\n        {\\n            temp.push_back(candidates[n-1]);\\n            PrintSubset(candidates, n-1, target-candidates[n-1],ans,temp);\\n            temp.pop_back();\\n            PrintSubset(candidates, n-1, target, ans, temp);\\n        }\\n    }\\n};\\n```\\nNow, in above Code we are taking extra space and we always sorting it to so that we can keep only unique subsets in our final answer.\\nWe can modify the above solution, by sorting the candidates at first. Now the duplicates ones are adjacent to each other and we can easily skip that ones which are Duplicates.\\n\\n**Solution #2: [Accepted] 8ms**\\nSort the candidates vector. And Now, when you have encounter a duplicate value, skip that value, because they may form same subset as previous one has formed. So, run a while loop and skip until you find a unique value.\\nNow, we don\\'t need extra space and we don\\'t have to sort again and again. Just a little bit of change, and everything is same as above code.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        PrintSubset(candidates,0,n,target,ans, temp);\\n        return ans;\\n    }\\n    void PrintSubset(vector<int>&C,int index,int n, int target,vector<vector<int>> &ans,vector<int>&temp)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(index>=n)\\n            return;\\n        if(target<0)\\n            return ;\\n        temp.push_back(C[index]);\\n        PrintSubset(C,index+1,n,target-C[index],ans,temp);\\n        while(index<(n-1) && C[index]==C[index+1])\\n            index++;\\n        temp.pop_back();\\n        PrintSubset(C,index+1,n,target,ans,temp);\\n    }\\n};\\n```\\n*And yes, this Q\\'s can also be solved using Backtracking. Many users has posted brilliant backtracking solutions, you can check that also.*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<vector<int>> s;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        PrintSubset(candidates,n,target,ans, temp);\\n        return ans;\\n    }\\n    void PrintSubset(vector<int>&candidates,int n, int target,vector<vector<int>> &ans,vector<int>temp)\\n    {\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n            if(s.find(temp)==s.end())\\n            {\\n                ans.push_back(temp);\\n                s.insert(temp);\\n            }\\n            return;\\n        }\\n        if(n==0)\\n            return;\\n        if(target<candidates[n-1])\\n            PrintSubset(candidates,n-1,target,ans,temp);\\n        else\\n        {\\n            temp.push_back(candidates[n-1]);\\n            PrintSubset(candidates, n-1, target-candidates[n-1],ans,temp);\\n            temp.pop_back();\\n            PrintSubset(candidates, n-1, target, ans, temp);\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        PrintSubset(candidates,0,n,target,ans, temp);\\n        return ans;\\n    }\\n    void PrintSubset(vector<int>&C,int index,int n, int target,vector<vector<int>> &ans,vector<int>&temp)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(index>=n)\\n            return;\\n        if(target<0)\\n            return ;\\n        temp.push_back(C[index]);\\n        PrintSubset(C,index+1,n,target-C[index],ans,temp);\\n        while(index<(n-1) && C[index]==C[index+1])\\n            index++;\\n        temp.pop_back();\\n        PrintSubset(C,index+1,n,target,ans,temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620712,
                "title": "bottom-up-python-solution-beats-98-simple-and-clean",
                "content": "\\n```python\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = collections.defaultdict(set)\\n        candidates.sort()\\n        dp[0].add(())\\n        for n in candidates:\\n            for i in reversed(range(n, target + 1)):\\n                if i >= n:\\n                    for seq in dp[i-n]:\\n                        dp[i].add(seq+(n,))\\n        return dp[target]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = collections.defaultdict(set)\\n        candidates.sort()\\n        dp[0].add(())\\n        for n in candidates:\\n            for i in reversed(range(n, target + 1)):\\n                if i >= n:\\n                    for seq in dp[i-n]:\\n                        dp[i].add(seq+(n,))\\n        return dp[target]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 434253,
                "title": "javascript-easy",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(candidates, target) {\\n    const result = [];\\n    candidates.sort((b,a) => b - a);\\n    \\n    const helper= (rem, start, current) => {\\n        if(rem < 0) return;\\n        if(rem === 0) {\\n            result.push(current.slice())\\n            return;\\n        }\\n        \\n        for(let i = start; i < candidates.length; i++){\\n            if(i > start && candidates[i] === candidates[i - 1]) continue;\\n            current.push(candidates[i])\\n            helper(rem - candidates[i], i + 1, current.slice());\\n            current.pop();\\n        }\\n    }\\n    \\n    helper(target, 0 , []);\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(candidates, target) {\\n    const result = [];\\n    candidates.sort((b,a) => b - a);\\n    \\n    const helper= (rem, start, current) => {\\n        if(rem < 0) return;\\n        if(rem === 0) {\\n            result.push(current.slice())\\n            return;\\n        }\\n        \\n        for(let i = start; i < candidates.length; i++){\\n            if(i > start && candidates[i] === candidates[i - 1]) continue;\\n            current.push(candidates[i])\\n            helper(rem - candidates[i], i + 1, current.slice());\\n            current.pop();\\n        }\\n    }\\n    \\n    helper(target, 0 , []);\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16879,
                "title": "golang-solution-6ms",
                "content": "```c\\nfunc combinationSum2(nums []int, target int) (result [][]int) {\\n    sort.Ints(nums)\\n    combinationSum2Helper(nums, nil, target, 0, 0, &result)\\n    return result\\n}\\n\\nfunc combinationSum2Helper(nums, combo []int, target, sum, startIndex int, result *[][]int) {\\n    if sum == target {\\n        *result = append(*result, append([]int{}, combo...))\\n        return\\n    }\\n    for i := startIndex; i < len(nums) && (sum + nums[i]) <= target; i++ {\\n        if i != startIndex && nums[i] == nums[i - 1] { continue }\\n        combinationSum2Helper(nums, append(combo, nums[i]), target, sum + nums[i], i + 1, result)\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```c\\nfunc combinationSum2(nums []int, target int) (result [][]int) {\\n    sort.Ints(nums)\\n    combinationSum2Helper(nums, nil, target, 0, 0, &result)\\n    return result\\n}\\n\\nfunc combinationSum2Helper(nums, combo []int, target, sum, startIndex int, result *[][]int) {\\n    if sum == target {\\n        *result = append(*result, append([]int{}, combo...))\\n        return\\n    }\\n    for i := startIndex; i < len(nums) && (sum + nums[i]) <= target; i++ {\\n        if i != startIndex && nums[i] == nums[i - 1] { continue }\\n        combinationSum2Helper(nums, append(combo, nums[i]), target, sum + nums[i], i + 1, result)\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16946,
                "title": "c-solution-with-comments-8ms",
                "content": "     void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start) {\\n                       // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                        // we always want to count the first element in this recursive step even if it is the same \\n                        // as one before. To avoid overcounting, we just ignore the duplicates\\n                        // after the first element.\\n                if(i>start && candidates[i]==candidates[i-1]) continue;\\n                \\n                        // if current element is bigger than the assigned target, there is \\n                        //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                        //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                        // keep searching for new element with start as `i + 1` because one element can be used only once\\n                elementSum(candidates,res,elements,target-candidates[i],i+1);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }",
                "solutionTags": [],
                "code": "     void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start) {\\n                       // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                        // we always want to count the first element in this recursive step even if it is the same \\n                        // as one before. To avoid overcounting, we just ignore the duplicates\\n                        // after the first element.\\n                if(i>start && candidates[i]==candidates[i-1]) continue;\\n                \\n                        // if current element is bigger than the assigned target, there is \\n                        //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                        //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                        // keep searching for new element with start as `i + 1` because one element can be used only once\\n                elementSum(candidates,res,elements,target-candidates[i],i+1);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 16880,
                "title": "python-dfs-easy-to-understand",
                "content": "    class Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        return self.dfs(candidates,0,[],[],target)\\n    def dfs(self, candidates,start,res,ans,target):\\n        if target<0:\\n            return \\n        if target==0:\\n            res.append(ans)\\n            return\\n        for i in xrange(start,len(candidates)):\\n            if i!=start and candidates[i]==candidates[i-1]:\\n                continue\\n            self.dfs(candidates,i+1,res,ans+[candidates[i]],target-candidates[i])\\n        return res",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        return self.dfs(candidates,0,[],[],target)\\n    def dfs(self, candidates,start,res,ans,target):\\n        if target<0:\\n            return \\n        if target==0:\\n            res.append(ans)\\n            return\\n        for i in xrange(start,len(candidates)):\\n            if i!=start and candidates[i]==candidates[i-1]:\\n                continue\\n            self.dfs(candidates,i+1,res,ans+[candidates[i]],target-candidates[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 16988,
                "title": "5ms-java-solution",
                "content": "    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans=new ArrayList<List<Integer>>();    \\n        ch(candidates,target,0,new ArrayList<Integer>(),ans);\\n        return ans;\\n    }\\n    public void ch(int[] candidates,int remain,int rindex,List<Integer> tmp,List<List<Integer>> ans)\\n    {\\n        if(remain==0)\\n        {\\n            List<Integer> a=new ArrayList<Integer>(tmp);\\n            ans.add(a);\\n            return;\\n        }\\n        int entered=0; // get rid of duplicate combinations\\n        for(int i=rindex;i<candidates.length;i++)\\n        {\\n            if(entered!=candidates[i]) // get rid of duplicate combinations\\n            {\\n                if(remain-candidates[i]<0) break; //This line of code can reduce 7ms from execution time!\\n                tmp.add(candidates[i]);\\n                entered=candidates[i];\\n                ch(candidates,remain-candidates[i],i+1,tmp,ans);\\n                tmp.remove(tmp.size()-1); \\n            }   \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans=new ArrayList<List<Integer>>();    \\n        ch(candidates,target,0,new ArrayList<Integer>(),ans);\\n        return ans;\\n    }\\n    public void ch(int[] candidates,int remain,int rindex,List<Integer> tmp,List<List<Integer>> ans)\\n    {\\n        if(remain==0)\\n        {\\n            List<Integer> a=new ArrayList<Integer>(tmp);\\n            ans.add(a);\\n            return;\\n        }\\n        int entered=0; // get rid of duplicate combinations\\n        for(int i=rindex;i<candidates.length;i++)\\n        {\\n            if(entered!=candidates[i]) // get rid of duplicate combinations\\n            {\\n                if(remain-candidates[i]<0) break; //This line of code can reduce 7ms from execution time!\\n                tmp.add(candidates[i]);\\n                entered=candidates[i];\\n                ch(candidates,remain-candidates[i],i+1,tmp,ans);\\n                tmp.remove(tmp.size()-1); \\n            }   \\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17056,
                "title": "my-solution-in-java",
                "content": "Generally speaking it is a DFS solution\\n\\n\\n    public class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            if (candidates==null||candidates.length==0) return Collections.emptyList();//Or throw exception();\\n    \\n            List<List<Integer>> results = new LinkedList<>();\\n    \\n            LinkedList<Integer> work = new LinkedList<>();\\n    \\n            Arrays.sort(candidates);\\n    \\n            for (int i=0,len=candidates.length;i<len;i++){\\n    \\n                if (i>0&&candidates[i]==candidates[i-1]) continue; //Avoid duplicates;\\n                combinationSumHelper(candidates,i,target,work,results);//DFS\\n            }\\n            return results;\\n        }\\n        //Use DFS\\n        private void combinationSumHelper(int[] candidates,int index, int target,LinkedList<Integer> work,List<List<Integer>> results){\\n            //Compare candidates[index] and target;\\n            //If equals, terminate the search,return result \\n            //If candidates[index] > target, terminate the search, no result\\n            //Otherwise, study rest of elements.\\n            if (candidates[index]>target){\\n                return;\\n            }else if (candidates[index]==target){//Update the \\n                work.addLast(candidates[index]);\\n                results.add(new ArrayList<Integer>(work));\\n                work.removeLast();\\n                return;\\n            }\\n            work.addLast(candidates[index]);\\n            for (int i=index+1,len=candidates.length;i<len;i++){\\n                if (i>index+1&&candidates[i]==candidates[i-1]) continue;//Avoid dulipcates\\n                if (candidates[i]<=target-candidates[index]){\\n                    combinationSumHelper(candidates,i,target-candidates[index],work,results);\\n                }\\n            }\\n            work.removeLast();\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            if (candidates==null||candidates.length==0) return Collections.emptyList();//Or throw exception();\\n    \\n            List<List<Integer>> results = new LinkedList<>();\\n    \\n            LinkedList<Integer> work = new LinkedList<>();\\n    \\n            Arrays.sort(candidates);\\n    \\n            for (int i=0,len=candidates.length;i<len;i++){\\n    \\n                if (i>0&&candidates[i]==candidates[i-1]) continue; //Avoid duplicates;\\n                combinationSumHelper(candidates,i,target,work,results);//DFS\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3812563,
                "title": "c-backtracking-considering-multiplicities-vs-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 different kinds of solutions are provided! One is backtracking; the other is dynamic programming solution. The backtracking solution is faster.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe backtracking solution considers the numbers with multiplicities. Using a container to store the pairs $(x_i, m_i)$ where $x_i$ is the number in candidates with its frequency $m_i$. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(\\\\prod_i(m_i+1))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(\\\\sum_i m_i)$$\\n\\n# Code for  backtracking\\n```\\nusing int2=pair<int, int>;\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> result;\\n    void backtrack(int i, vector<int>& subset, vector<int2>& nWm, int target) {\\n        if (target == 0) {\\n            result.push_back(subset);\\n            return;\\n        }\\n\\n        if (i == n || target < 0) {\\n            return;\\n        }\\n\\n        auto [x, m] = nWm[i];\\n        for (int j = 0; j <= m; j++) {\\n            for (int k = 1; k <= j; k++) // Add j x\\'s to subset\\n                subset.push_back(x);\\n\\n            backtrack(i + 1, subset, nWm, target-j*x);\\n\\n            for (int k = 1; k <= j; k++) //backtracking\\n                subset.pop_back();    \\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<int2> nWm;\\n        nWm.push_back({candidates[0], 1});\\n        int idx = 0;\\n        for (int i = 1; i < candidates.size(); i++) {\\n            if (candidates[i] == candidates[i-1]) {\\n                nWm[idx].second++;\\n            } \\n            else {\\n                nWm.push_back({candidates[i], 1});\\n                idx++;\\n            }\\n        }\\n\\n        n=nWm.size();\\n        vector<int> subset;\\n        backtrack(0, subset, nWm, target);\\n        return result;\\n    }\\n};\\n```\\n# Code for DP\\n```\\nusing int2 = pair<int, int>;\\nclass Solution {\\npublic:\\nint n;\\nvector<vector<int>> dfs(int i, int target, vector<int2>& nWm, vector<vector<vector<vector<int>>>>& dp) \\n{\\n        if (target == 0) {\\n            return {{}};\\n        }\\n\\n        if (i == n || target < 0) {\\n            return {};\\n        }\\n\\n        if (!dp[i][target].empty()) {\\n            return dp[i][target];\\n        }\\n\\n        auto [x, m] = nWm[i];\\n        vector<vector<int>> result;\\n        for (int j = 0; j <= m; j++) {\\n            vector<vector<int>> combinations = dfs(i + 1, target - j * x, nWm, dp);\\n            for (int k = 0; k < combinations.size(); k++) {\\n                for (int l = 1; l <= j; l++) {\\n                    combinations[k].push_back(x);\\n                }\\n                result.push_back(combinations[k]);\\n            }\\n        }       \\n        return  dp[i][target] = result;\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<int2> nWm;\\n        nWm.push_back({candidates[0], 1});\\n        int idx = 0;\\n        for (int i = 1; i < candidates.size(); i++) {\\n            if (candidates[i] == candidates[i - 1]) {\\n                nWm[idx].second++;\\n            } else {\\n                nWm.push_back({candidates[i], 1});\\n                idx++;\\n            }\\n        }\\n        n=nWm.size();\\n\\n        vector<vector<vector<vector<int>>>> \\n        dp(n, vector<vector<vector<int>>>(target + 1));\\n\\n        return dfs(0, target, nWm, dp);\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nusing int2=pair<int, int>;\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> result;\\n    void backtrack(int i, vector<int>& subset, vector<int2>& nWm, int target) {\\n        if (target == 0) {\\n            result.push_back(subset);\\n            return;\\n        }\\n\\n        if (i == n || target < 0) {\\n            return;\\n        }\\n\\n        auto [x, m] = nWm[i];\\n        for (int j = 0; j <= m; j++) {\\n            for (int k = 1; k <= j; k++) // Add j x\\'s to subset\\n                subset.push_back(x);\\n\\n            backtrack(i + 1, subset, nWm, target-j*x);\\n\\n            for (int k = 1; k <= j; k++) //backtracking\\n                subset.pop_back();    \\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<int2> nWm;\\n        nWm.push_back({candidates[0], 1});\\n        int idx = 0;\\n        for (int i = 1; i < candidates.size(); i++) {\\n            if (candidates[i] == candidates[i-1]) {\\n                nWm[idx].second++;\\n            } \\n            else {\\n                nWm.push_back({candidates[i], 1});\\n                idx++;\\n            }\\n        }\\n\\n        n=nWm.size();\\n        vector<int> subset;\\n        backtrack(0, subset, nWm, target);\\n        return result;\\n    }\\n};\\n```\n```\\nusing int2 = pair<int, int>;\\nclass Solution {\\npublic:\\nint n;\\nvector<vector<int>> dfs(int i, int target, vector<int2>& nWm, vector<vector<vector<vector<int>>>>& dp) \\n{\\n        if (target == 0) {\\n            return {{}};\\n        }\\n\\n        if (i == n || target < 0) {\\n            return {};\\n        }\\n\\n        if (!dp[i][target].empty()) {\\n            return dp[i][target];\\n        }\\n\\n        auto [x, m] = nWm[i];\\n        vector<vector<int>> result;\\n        for (int j = 0; j <= m; j++) {\\n            vector<vector<int>> combinations = dfs(i + 1, target - j * x, nWm, dp);\\n            for (int k = 0; k < combinations.size(); k++) {\\n                for (int l = 1; l <= j; l++) {\\n                    combinations[k].push_back(x);\\n                }\\n                result.push_back(combinations[k]);\\n            }\\n        }       \\n        return  dp[i][target] = result;\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<int2> nWm;\\n        nWm.push_back({candidates[0], 1});\\n        int idx = 0;\\n        for (int i = 1; i < candidates.size(); i++) {\\n            if (candidates[i] == candidates[i - 1]) {\\n                nWm[idx].second++;\\n            } else {\\n                nWm.push_back({candidates[i], 1});\\n                idx++;\\n            }\\n        }\\n        n=nWm.size();\\n\\n        vector<vector<vector<vector<int>>>> \\n        dp(n, vector<vector<vector<int>>>(target + 1));\\n\\n        return dfs(0, target, nWm, dp);\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631115,
                "title": "optimized-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,int k,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }if(k<0)return;\\n        if(i>=n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(v[j]);\\n            solve(j+1,n,k-v[j],v,tmp,ans);\\n            while(j+1<n&&v[j]==v[j+1]){\\n                j++;\\n            }\\n            tmp.pop_back();\\n            \\n        }\\n\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& v, int k) {\\n        sort(v.begin(),v.end());\\n        vector<int> tmp;\\n        vector<vector<int>> ans;\\n        int n = v.size();\\n        solve(0,n,k,v,tmp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,int k,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }if(k<0)return;\\n        if(i>=n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(v[j]);\\n            solve(j+1,n,k-v[j],v,tmp,ans);\\n            while(j+1<n&&v[j]==v[j+1]){\\n                j++;\\n            }\\n            tmp.pop_back();\\n            \\n        }\\n\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& v, int k) {\\n        sort(v.begin(),v.end());\\n        vector<int> tmp;\\n        vector<vector<int>> ans;\\n        int n = v.size();\\n        solve(0,n,k,v,tmp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263257,
                "title": "simple-and-easy-to-understand-c-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector <vector <int>> ans;\\n        vector <int> v;\\n        solution(0,target,candidates,ans,v);\\n        return ans;\\n    }\\n    void solution(int i,int target,vector <int> &candidates,vector <vector <int>> &ans,vector <int> &v){\\n        if(target==0){\\n           ans.push_back(v);\\n            return;\\n        }\\n        for(int index=i;index<candidates.size();index++){\\n            if(index>i && candidates[index]==candidates[index-1]) continue;\\n            if(candidates[index]>target) break;\\n            v.push_back(candidates[index]);\\n            solution(index+1,target-candidates[index],candidates,ans,v);\\n            v.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector <vector <int>> ans;\\n        vector <int> v;\\n        solution(0,target,candidates,ans,v);\\n        return ans;\\n    }\\n    void solution(int i,int target,vector <int> &candidates,vector <vector <int>> &ans,vector <int> &v){\\n        if(target==0){\\n           ans.push_back(v);\\n            return;\\n        }\\n        for(int index=i;index<candidates.size();index++){\\n            if(index>i && candidates[index]==candidates[index-1]) continue;\\n            if(candidates[index]>target) break;\\n            v.push_back(candidates[index]);\\n            solution(index+1,target-candidates[index],candidates,ans,v);\\n            v.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243195,
                "title": "c-recursion-backtracking-array-easy-66-time-43-space",
                "content": "```\\nclass Solution {\\npublic:\\n    void recur(int i, int t, vector<int> &v, vector<int> &temp, set<vector<int>> &ans){\\n      if(t == 0){\\n        ans.insert(temp);\\n        return;\\n      }\\n      for(int idx = i; idx < v.size(); idx++){\\n        if(idx > i and v[idx] == v[idx - 1]) continue;\\n        if(t - v[idx] < 0) break;\\n        temp.emplace_back(v[idx]);\\n        recur(idx + 1, t - v[idx], v, temp, ans);\\n        temp.pop_back();\\n      }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& v, int t) {\\n      set<vector<int>> anst;\\n      vector<int> temp;\\n      sort(v.begin(), v.end());\\n      recur(0, t, v, temp, anst);\\n      vector<vector<int>> ans(anst.begin(), anst.end());\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recur(int i, int t, vector<int> &v, vector<int> &temp, set<vector<int>> &ans){\\n      if(t == 0){\\n        ans.insert(temp);\\n        return;\\n      }\\n      for(int idx = i; idx < v.size(); idx++){\\n        if(idx > i and v[idx] == v[idx - 1]) continue;\\n        if(t - v[idx] < 0) break;\\n        temp.emplace_back(v[idx]);\\n        recur(idx + 1, t - v[idx], v, temp, ans);\\n        temp.pop_back();\\n      }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& v, int t) {\\n      set<vector<int>> anst;\\n      vector<int> temp;\\n      sort(v.begin(), v.end());\\n      recur(0, t, v, temp, anst);\\n      vector<vector<int>> ans(anst.begin(), anst.end());\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844056,
                "title": "easy-c-solution-striver-better-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public: \\n    void findCombination(int ind, int target, vector<int> &arr, vector<vector<int>> &ans, vector<int>&ds) {\\n        if(target==0){ \\n            ans.push_back(ds);\\n            return;\\n        }\\n\\n        int prev=-1;\\n        for(int i=ind;i<arr.size();i++){\\n            if(arr[i]!=prev && arr[i]<=target){\\n                ds.push_back(arr[i]);\\n                findCombination(i+1,target-arr[i],arr,ans,ds);\\n                ds.pop_back();\\n                prev=arr[i];\\n            }\\n        }\\n\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans; \\n        vector<int> ds; \\n        findCombination(0, target, candidates, ans, ds); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public: \\n    void findCombination(int ind, int target, vector<int> &arr, vector<vector<int>> &ans, vector<int>&ds) {\\n        if(target==0){ \\n            ans.push_back(ds);\\n            return;\\n        }\\n\\n        int prev=-1;\\n        for(int i=ind;i<arr.size();i++){\\n            if(arr[i]!=prev && arr[i]<=target){\\n                ds.push_back(arr[i]);\\n                findCombination(i+1,target-arr[i],arr,ans,ds);\\n                ds.pop_back();\\n                prev=arr[i];\\n            }\\n        }\\n\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans; \\n        vector<int> ds; \\n        findCombination(0, target, candidates, ans, ds); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494877,
                "title": "c-not-fastest-but-easy-to-understand-recursive-solution-unique-solution",
                "content": "Please let me know if you need an explanation. I will try to explain in detail.\\n\\n```cpp\\nvoid get_combition_sum_2(vector <int> input, int target, int pos, vector <int> combination, vector <vector <int>> &result){\\n    if (pos >= input.size() || target <= 0){\\n        if (target == 0)\\n            result.push_back(combination);    \\n        return;\\n    }\\n\\n    combination.push_back(input[pos]);\\n    get_combition_sum_2(input, target - input[pos], pos + 1, combination, result);\\n    combination.pop_back();\\n\\n    while (pos < input.size() - 1 && input[pos] == input[pos+1])\\n        pos++;\\n\\n    get_combition_sum_2(input, target, pos + 1, combination, result);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```cpp\\nvoid get_combition_sum_2(vector <int> input, int target, int pos, vector <int> combination, vector <vector <int>> &result){\\n    if (pos >= input.size() || target <= 0){\\n        if (target == 0)\\n            result.push_back(combination);    \\n        return;\\n    }\\n\\n    combination.push_back(input[pos]);\\n    get_combition_sum_2(input, target - input[pos], pos + 1, combination, result);\\n    combination.pop_back();\\n\\n    while (pos < input.size() - 1 && input[pos] == input[pos+1])\\n        pos++;\\n\\n    get_combition_sum_2(input, target, pos + 1, combination, result);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2383036,
                "title": "c-solution-backtracking-comments-better-than-89",
                "content": "Here, we can\\'t perform normal backtracking as it would lead to 2^n cases(where n<=100 given). So we tweak the code a bit so that we don\\'t have to produce the same combinations again and again.\\n\\nSteps used:\\n-> After sorting the initial array, follow the below steps\\n-> add the curr element from target and backtrack for the leftover part of array.\\n-> don\\'t add the curr element from the target and backtrack for the leftover part of the array.\\n-> if this we keep track of if the previous element is same as current element, we skip to the next distinct number, and then apply the same steps as above.\\n\\n```\\nclass Solution{\\n    public:\\n    vector<vector<int> > ans;\\n    \\n    void backtrack(vector<int> a, vector<int> curr, int t, int i){\\n        // if t is 0, means we formed the group of elements which sum to target,\\n\\t\\t// and we push it into our ans.\\n\\t\\tif(t==0)\\n\\t\\t\\tans.push_back(curr);\\n\\t\\t\\t\\n\\t\\t// but if t<0, means we don\\'t need to check further for this, \\n\\t\\t// as the elements greater than it, won\\'t sum to t.\\n        if(t<0)    return;\\n\\t\\t\\n\\t\\t// to keep track of prev element( -1 is insignificant here.)\\n        int prev = -1;\\n        \\n        for(; i<a.size(); i++){\\n\\t\\t\\t// if prev element is same as current element, we continue.\\n            if(prev==a[i])  continue;\\n\\t\\t\\t\\n\\t\\t\\t// else we append it to current \\n            curr.push_back(a[i]);\\n\\t\\t\\t\\n\\t\\t\\t// we backtrack for the required element\\n            backtrack(a, curr, t-a[i], i+1);\\n\\t\\t\\t\\n\\t\\t\\t// the other backtrack we use, without using the current element\\n            curr.pop_back();\\n            prev = a[i];\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int> &a, int t){\\n\\t\\t// sort the array\\n        sort(a.begin(), a.end());\\n        vector<int> temp;temp.clear();\\n        backtrack(a, temp, t, 0);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public:\\n    vector<vector<int> > ans;\\n    \\n    void backtrack(vector<int> a, vector<int> curr, int t, int i){\\n        // if t is 0, means we formed the group of elements which sum to target,\\n\\t\\t// and we push it into our ans.\\n\\t\\tif(t==0)\\n\\t\\t\\tans.push_back(curr);\\n\\t\\t\\t\\n\\t\\t// but if t<0, means we don\\'t need to check further for this, \\n\\t\\t// as the elements greater than it, won\\'t sum to t.\\n        if(t<0)    return;\\n\\t\\t\\n\\t\\t// to keep track of prev element( -1 is insignificant here.)\\n        int prev = -1;\\n        \\n        for(; i<a.size(); i++){\\n\\t\\t\\t// if prev element is same as current element, we continue.\\n            if(prev==a[i])  continue;\\n\\t\\t\\t\\n\\t\\t\\t// else we append it to current \\n            curr.push_back(a[i]);\\n\\t\\t\\t\\n\\t\\t\\t// we backtrack for the required element\\n            backtrack(a, curr, t-a[i], i+1);\\n\\t\\t\\t\\n\\t\\t\\t// the other backtrack we use, without using the current element\\n            curr.pop_back();\\n            prev = a[i];\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int> &a, int t){\\n\\t\\t// sort the array\\n        sort(a.begin(), a.end());\\n        vector<int> temp;temp.clear();\\n        backtrack(a, temp, t, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318566,
                "title": "c-recursion",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nclass Solution {\\npublic:\\n    void recur(int ind, int tar, vector<int>& c, vector<vector<int>>& ans, vector<int>& ds){\\n        if(tar==0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=ind;i<c.size();i++){\\n            if(i>ind && c[i]==c[i-1]) continue;\\n            if(c[i]>tar) break;\\n            \\n            ds.push_back(c[i]);\\n            recur(i+1, tar-c[i], c, ans, ds);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& c, int target) {\\n        sort(c.begin(), c.end());\\n        int n=c.size();\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        recur(0, target, c, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recur(int ind, int tar, vector<int>& c, vector<vector<int>>& ans, vector<int>& ds){\\n        if(tar==0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=ind;i<c.size();i++){\\n            if(i>ind && c[i]==c[i-1]) continue;\\n            if(c[i]>tar) break;\\n            \\n            ds.push_back(c[i]);\\n            recur(i+1, tar-c[i], c, ans, ds);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& c, int target) {\\n        sort(c.begin(), c.end());\\n        int n=c.size();\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        recur(0, target, c, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260963,
                "title": "combination-of-subsets-ii-90-and-combination-sum-39",
                "content": "class Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n      List<List<Integer>> ans = new ArrayList<>();\\n        //sort the array\\n        Arrays.sort(candidates);\\n        solve(candidates,0,ans,new ArrayList<>(),target);\\n        return ans;\\n    }\\n     public void solve(int[] candidates,int i,List<List<Integer>>ans,List<Integer> output, int target){\\n\\t //base case\\n        if(i==candidates.length){\\n            if(target==0){\\n                ans.add(new ArrayList<>(output));\\n            }\\n            return;\\n        }\\n        //include the element and since each candidate can be used one send i+1 to the function\\n         if(candidates[i]<=target){\\n            output.add(candidates[i]);\\n            solve(candidates,i+1,ans,output,target-candidates[i]);\\n            output.remove(output.size()-1);\\n         }\\n        //exclude if the number is similar to the previous as it will result in same path\\n        while(i+1<candidates.length && candidates[i]==candidates[i+1]){\\n            i++;\\n        }\\n        solve(candidates,i+1,ans,output,target);\\n    }\\n}\\nTried after following striver\\'s and neetcode\\'s approach",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n      List<List<Integer>> ans = new ArrayList<>();\\n        //sort the array\\n        Arrays.sort(candidates);\\n        solve(candidates,0,ans,new ArrayList<>(),target);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1689307,
                "title": "c-solution-set-recursion",
                "content": "*Please upvote if you find it helpful :)*\\n```\\nvoid solve(int index, vector<int> &candidates, int target, vector<int> &v1, set<vector<int> >&v){\\n        if(target==0) {\\n            v.insert(v1);\\n            return ;\\n        }\\n        if(index >= candidates.size() || target < candidates[index])\\n            return;\\n        v1.push_back(candidates[index]);\\n        solve(index+1, candidates, target-candidates[index], v1, v);\\n        v1.pop_back();\\n        int next_index = index;\\n        while (next_index < candidates.size() && candidates[next_index] == candidates[index])\\n            next_index++;\\n        solve(next_index, candidates, target, v1, v);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> v1;\\n        set<vector<int> > v;\\n        vector<vector<int> > ans;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0, candidates, target, v1, v);\\n        for(auto x: v) {\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nvoid solve(int index, vector<int> &candidates, int target, vector<int> &v1, set<vector<int> >&v){\\n        if(target==0) {\\n            v.insert(v1);\\n            return ;\\n        }\\n        if(index >= candidates.size() || target < candidates[index])\\n            return;\\n        v1.push_back(candidates[index]);\\n        solve(index+1, candidates, target-candidates[index], v1, v);\\n        v1.pop_back();\\n        int next_index = index;\\n        while (next_index < candidates.size() && candidates[next_index] == candidates[index])\\n            next_index++;\\n        solve(next_index, candidates, target, v1, v);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> v1;\\n        set<vector<int> > v;\\n        vector<vector<int> > ans;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0, candidates, target, v1, v);\\n        for(auto x: v) {\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1311783,
                "title": "elegant-python-recursion",
                "content": "```\\n# Time Complexity: 2^(N), where N = len(candidates)\\n# Space Complexity: O(N)\\nfrom collections import Counter\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n    \\n        combinations = []\\n        counter = Counter(candidates)\\n        counter = [(key, counter[key]) for key in counter]\\n        \\n        def recursion(index = 0, current_combination = [], combination_sum = 0):\\n            if combination_sum > target or index not in range(len(counter)): return\\n            elif combination_sum == target: combinations.append(current_combination.copy()) \\n            else:\\n                candidate, frequency = counter[index]\\n                if frequency > 0:\\n                    counter[index] = (candidate, frequency-1)\\n                    recursion(index, current_combination + [candidate], combination_sum + candidate)\\n                counter[index] = (candidate, frequency)\\n                recursion(index+1, current_combination, combination_sum)\\n                        \\n        recursion()\\n        return combinations\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Time Complexity: 2^(N), where N = len(candidates)\\n# Space Complexity: O(N)\\nfrom collections import Counter\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n    \\n        combinations = []\\n        counter = Counter(candidates)\\n        counter = [(key, counter[key]) for key in counter]\\n        \\n        def recursion(index = 0, current_combination = [], combination_sum = 0):\\n            if combination_sum > target or index not in range(len(counter)): return\\n            elif combination_sum == target: combinations.append(current_combination.copy()) \\n            else:\\n                candidate, frequency = counter[index]\\n                if frequency > 0:\\n                    counter[index] = (candidate, frequency-1)\\n                    recursion(index, current_combination + [candidate], combination_sum + candidate)\\n                counter[index] = (candidate, frequency)\\n                recursion(index+1, current_combination, combination_sum)\\n                        \\n        recursion()\\n        return combinations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788413,
                "title": "8ms-c-backtracking-simple-code",
                "content": "```\\n// upvote if this solution helpes you.\\nclass Solution {\\npublic:\\n    vector<vector<int> >finalans;\\n    set<vector<int> >ans;   // for no repetition\\n    vector<int> temp;\\n    \\n    void backtracking(vector<int>& candidates, int target, set<vector<int> >&ans, vector<int> &temp, int start)\\n    {\\n        if(target == 0)\\n        {\\n            ans.insert(temp);\\n            return;\\n        }\\n        \\n        for(int i=start; i<candidates.size() && target >= candidates[i]; i++)\\n        {\\n            temp.push_back(candidates[i]);\\n            backtracking(candidates, target - candidates[i], ans, temp, i+1);     // i+1 so that it will not pick same element again.\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        backtracking(candidates, target, ans, temp, 0);\\n        for(auto i : ans)\\n            finalans.push_back(i);\\n        return finalans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// upvote if this solution helpes you.\\nclass Solution {\\npublic:\\n    vector<vector<int> >finalans;\\n    set<vector<int> >ans;   // for no repetition\\n    vector<int> temp;\\n    \\n    void backtracking(vector<int>& candidates, int target, set<vector<int> >&ans, vector<int> &temp, int start)\\n    {\\n        if(target == 0)\\n        {\\n            ans.insert(temp);\\n            return;\\n        }\\n        \\n        for(int i=start; i<candidates.size() && target >= candidates[i]; i++)\\n        {\\n            temp.push_back(candidates[i]);\\n            backtracking(candidates, target - candidates[i], ans, temp, i+1);     // i+1 so that it will not pick same element again.\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        backtracking(candidates, target, ans, temp, 0);\\n        for(auto i : ans)\\n            finalans.push_back(i);\\n        return finalans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650590,
                "title": "java-iterative-dp-no-recursion-straightforward",
                "content": "```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Map<Integer, Set<List<Integer>>> map = new HashMap<>();\\n        Arrays.sort(candidates);\\n        for (int cand : candidates) {\\n            if (cand > target) continue;\\n            for (int num = target - cand; num >= 0; num--) {\\n                Set<List<Integer>> tmp = map.getOrDefault(num + cand, new HashSet<>());\\n                Set<List<Integer>> prev = map.getOrDefault(num, new HashSet<>());\\n                for (List<Integer> l : prev) {\\n                    List<Integer> newList = new ArrayList<>();\\n                    newList.addAll(l);\\n                    newList.add(cand);\\n                    tmp.add(newList);\\n                }\\n                map.put(num + cand, tmp);\\n            }\\n            map.computeIfAbsent(cand, g -> new HashSet<>());\\n            map.get(cand).add(List.of(cand));\\n        }\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.addAll(map.getOrDefault(target, new HashSet<>()));\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Map<Integer, Set<List<Integer>>> map = new HashMap<>();\\n        Arrays.sort(candidates);\\n        for (int cand : candidates) {\\n            if (cand > target) continue;\\n            for (int num = target - cand; num >= 0; num--) {\\n                Set<List<Integer>> tmp = map.getOrDefault(num + cand, new HashSet<>());\\n                Set<List<Integer>> prev = map.getOrDefault(num, new HashSet<>());\\n                for (List<Integer> l : prev) {\\n                    List<Integer> newList = new ArrayList<>();\\n                    newList.addAll(l);\\n                    newList.add(cand);\\n                    tmp.add(newList);\\n                }\\n                map.put(num + cand, tmp);\\n            }\\n            map.computeIfAbsent(cand, g -> new HashSet<>());\\n            map.get(cand).add(List.of(cand));\\n        }\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.addAll(map.getOrDefault(target, new HashSet<>()));\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561957,
                "title": "python-6-line-dp-without-using-hashset-to-check-duplicate-explained",
                "content": "I see a lot of posts using HashSet to check duplicates. There is no need for that.\\nThe only difference with question [\"39 Combination Sum I\"](https://leetcode.com/problems/combination-sum/) is that, this questions limits the repetition count for each item in \"candidates\" array. \\nCode is almost the same code as [\"39 Combination Sum I\"](https://leetcode.com/problems/combination-sum/), just adding an extra \"if\" to exclude those repeating too many times.\\n**dp[i]** is a list of all combinations that sums up to \"i\". We put \"candidates\" in outer loop and \"target\" iteration in inner loop, so that when one candidate number is used, it won\\'t be picked again later. This automatically avoids duplicates. No need to use hash for duplicate check.\\n```\\n\\t    counter=collections.Counter(candidates)\\n        dp=[[[]]]+[[] for _ in range(target+1)]\\n        for c,cnt in counter.items():\\n            for i in range(c,target+1):\\n                dp[i].extend([arr+[c] for arr in dp[i-c] if len(arr)<cnt or arr[-cnt]!=c])        \\n        return dp[target]\\n```\\nWe can use arr[-cnt]!=c to check repeating count because in arr, same number must all be side-by-side.\\n\\nFor comparison, here is the code for [\"39 Combination Sum I\"](https://leetcode.com/problems/combination-sum/). The only difference is, it doesn\\'t have the \"if\" statement in the end of \"dp[i].extend\" line.\\n```\\n        dp=[[[]]]+[[] for _ in range(target+1)]\\n        for c in candidates:\\n            for i in range(c,target+1):\\n                dp[i].extend([arr+[c] for arr in dp[i-c]])\\n        return dp[target]\\n```",
                "solutionTags": [],
                "code": "```\\n\\t    counter=collections.Counter(candidates)\\n        dp=[[[]]]+[[] for _ in range(target+1)]\\n        for c,cnt in counter.items():\\n            for i in range(c,target+1):\\n                dp[i].extend([arr+[c] for arr in dp[i-c] if len(arr)<cnt or arr[-cnt]!=c])        \\n        return dp[target]\\n```\n```\\n        dp=[[[]]]+[[] for _ in range(target+1)]\\n        for c in candidates:\\n            for i in range(c,target+1):\\n                dp[i].extend([arr+[c] for arr in dp[i-c]])\\n        return dp[target]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 543016,
                "title": "c-4-ms-short-fast-backtracking-solution-99-100",
                "content": "```\\nclass Solution{\\n    public:\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n        {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> vsum;\\n            add(candidates, 0, target, 0, vsum, res);\\n            return res;\\n        }\\n\\n    protected:\\n        void add(vector<int>& cand, int i, int target, int sum, vector<int>& vsum, vector<vector<int>>& res)\\n        {\\n            for(int s = 0; i < cand.size(); ++i)\\n            {\\n                s = sum + cand[i];\\n                if(s > target) continue;\\n                vsum.push_back(cand[i]);\\n                if(s == target)\\n                    res.push_back(vsum);\\n                else\\n                    add(cand, i+1, target, s, vsum, res);\\n                vsum.pop_back();\\n                while(i+1 < cand.size() && cand[i] == cand[i+1]) ++i; // skip duplicates\\n            }\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution{\\n    public:\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n        {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> vsum;\\n            add(candidates, 0, target, 0, vsum, res);\\n            return res;\\n        }\\n\\n    protected:\\n        void add(vector<int>& cand, int i, int target, int sum, vector<int>& vsum, vector<vector<int>>& res)\\n        {\\n            for(int s = 0; i < cand.size(); ++i)\\n            {\\n                s = sum + cand[i];\\n                if(s > target) continue;\\n                vsum.push_back(cand[i]);\\n                if(s == target)\\n                    res.push_back(vsum);\\n                else\\n                    add(cand, i+1, target, s, vsum, res);\\n                vsum.pop_back();\\n                while(i+1 < cand.size() && cand[i] == cand[i+1]) ++i; // skip duplicates\\n            }\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429543,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146416,
                "title": "11ms-java-solution-with-no-loop-inside-recursion",
                "content": "A simple way to look at the problem is that for each element in the array, we have two options: **include it or not** in the combination.\\nSay we\\'re at array index ```i``` with target ```t```. \\n*Possibility 1:* If we do include ```array[i]```, the problem becomes \"**Find combinations of sum (t - array[i]) in the array starting at i+1**\". \\n*Possibility 2:* If we do **not** include ```array[i]```, the problem is to \"**Find combinations of sum t in the array starting at i+1**\".\\nThe only headache left now is to exclude duplicate answers. Duplicate answers exist because we have duplicate elements in the array. \\nSay we have *k* ```1```\\'s. Using the above algorithm, we get *2^k* possiblites. But among them only *(k+1)* possiblities are useful: *0 ... k* of the k ```1```\\'s are chosen. Thus, we only include the first *n* consecutive ```1```\\'s. That means **once we decide to uninclude a ```1```, we uninclude all the following ```1```\\'s**.\\nSince we consider two possibilities at each index, the execution forms a binary tree with level *n*. The execution time will thus be O(2^n).\\n```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new LinkedList<List<Integer>>();\\n        if(candidates == null || candidates.length == 0)\\n            return res;\\n        Arrays.sort(candidates);\\n        combinations(candidates, target, 0, res, new Stack<>());\\n        return res;\\n    }\\n    \\n    private void combinations(int[] array, int target, int start, \\n                              List<List<Integer>> list, Stack<Integer> stack){\\n    \\tif(target == 0)\\n    \\t\\tlist.add(new ArrayList<Integer>(stack));\\n        if(target < 0 || start == array.length || target < array[start])\\n            return;\\n\\t\\t\\t\\t\\t\\t\\n        //possibility 1: include array[i]\\n        stack.push(array[start]);\\n        combinations(array, target-array[start], start+1, list, stack);\\n        stack.pop();        \\n\\t\\t\\t\\t\\n        //possibility 2: don\\'t include array[i]\\n        while(start+1 < array.length && array[start+1]==array[start])\\n            start++; //exclude duplicates\\n        combinations(array, target, start+1, list, stack);\\n    }\\n```",
                "solutionTags": [],
                "code": "```i```\n```t```\n```array[i]```\n```array[i]```\n```1```\n```1```\n```1```\n```1```\n```1```\n```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new LinkedList<List<Integer>>();\\n        if(candidates == null || candidates.length == 0)\\n            return res;\\n        Arrays.sort(candidates);\\n        combinations(candidates, target, 0, res, new Stack<>());\\n        return res;\\n    }\\n    \\n    private void combinations(int[] array, int target, int start, \\n                              List<List<Integer>> list, Stack<Integer> stack){\\n    \\tif(target == 0)\\n    \\t\\tlist.add(new ArrayList<Integer>(stack));\\n        if(target < 0 || start == array.length || target < array[start])\\n            return;\\n\\t\\t\\t\\t\\t\\t\\n        //possibility 1: include array[i]\\n        stack.push(array[start]);\\n        combinations(array, target-array[start], start+1, list, stack);\\n        stack.pop();        \\n\\t\\t\\t\\t\\n        //possibility 2: don\\'t include array[i]\\n        while(start+1 < array.length && array[start+1]==array[start])\\n            start++; //exclude duplicates\\n        combinations(array, target, start+1, list, stack);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16882,
                "title": "python-dfs-solution",
                "content": "```\\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()\\n        res = []\\n        \\n        def dfs(t, idx=0, path=[]):\\n            if t < 0:\\n                return  # Backtrack (Not a valid path)\\n            \\n            if t == 0:\\n                res.append(path)\\n                return\\n            \\n            if t > 0:\\n                for i in range(idx, len(candidates)):\\n                    c = candidates[i]\\n                    if i != idx and c == candidates[i-1]: continue  # Eliminates duplicates\\n                    dfs(t-c, i+1, path+[c])\\n\\n        dfs(target)\\n        return res\\n```\\n\\nDFS idea is borrowed from @caikehe's Combination Sum [solution](https://discuss.leetcode.com/topic/23142/python-dfs-solution). Here, when recursively calling dfs in for loop, we increment the index by 1 (unlike combination sum problem where we don't increment i). That's because we don't want the same number to be considered twice. Also, the line `if i != idx and c == candidates[i-1]: continue`, is needed to eliminate duplicate combinations.",
                "solutionTags": [],
                "code": "```\\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()\\n        res = []\\n        \\n        def dfs(t, idx=0, path=[]):\\n            if t < 0:\\n                return  # Backtrack (Not a valid path)\\n            \\n            if t == 0:\\n                res.append(path)\\n                return\\n            \\n            if t > 0:\\n                for i in range(idx, len(candidates)):\\n                    c = candidates[i]\\n                    if i != idx and c == candidates[i-1]: continue  # Eliminates duplicates\\n                    dfs(t-c, i+1, path+[c])\\n\\n        dfs(target)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 17006,
                "title": "short-and-easy-to-understand-recursive-java-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            Arrays.sort(candidates);\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            combine(candidates, 0, target, res, new ArrayList<Integer>());\\n            return res;\\n        }\\n        private void combine(int[] nums, int start, int target, List<List<Integer>> res, List<Integer> path){\\n            if (target < 0) return;\\n            if (target == 0){\\n                res.add(path);\\n                return;\\n            }\\n            for (int i = start; i < nums.length; i++){\\n                if (i > start && nums[i] == nums[i - 1]) continue;\\n                List<Integer> currentPath = new ArrayList<Integer>(path);\\n                currentPath.add(nums[i]);\\n                combine(nums, i + 1, target - nums[i], res, currentPath);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            Arrays.sort(candidates);\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            combine(candidates, 0, target, res, new ArrayList<Integer>());\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3581319,
                "title": "python3-backtracking-mega-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        candidates.sort()\\n\\n        def backtracking(start, total, path):\\n            if total == target:\\n                ans.append(path)\\n                return\\n            \\n            for i in range(start, len(candidates)):\\n                if total + candidates[i] > target:\\n                    return\\n                elif i > start and candidates[i] == candidates[i-1]:\\n                    continue\\n                else:\\n                    backtracking(i + 1, total + candidates[i], path + [candidates[i]])\\n\\n        backtracking(0, 0, [])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        candidates.sort()\\n\\n        def backtracking(start, total, path):\\n            if total == target:\\n                ans.append(path)\\n                return\\n            \\n            for i in range(start, len(candidates)):\\n                if total + candidates[i] > target:\\n                    return\\n                elif i > start and candidates[i] == candidates[i-1]:\\n                    continue\\n                else:\\n                    backtracking(i + 1, total + candidates[i], path + [candidates[i]])\\n\\n        backtracking(0, 0, [])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265075,
                "title": "python-accepted-recursive-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        ans=[]\\n        n=len(candidates)\\n        candidates.sort()\\n        def solve(idx,lst,sum):\\n            # nonlocal ans,candidates\\n            if sum==target:\\n                ans.append(lst)\\n                return \\n            for i in range(idx,n):\\n                if i>idx and candidates[i]==candidates[i-1]:\\n                    continue\\n                if sum+candidates[i]>target:\\n                    break\\n                solve(i+1,lst+[candidates[i]],sum+candidates[i])\\n        solve(0,[],0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        ans=[]\\n        n=len(candidates)\\n        candidates.sort()\\n        def solve(idx,lst,sum):\\n            # nonlocal ans,candidates\\n            if sum==target:\\n                ans.append(lst)\\n                return \\n            for i in range(idx,n):\\n                if i>idx and candidates[i]==candidates[i-1]:\\n                    continue\\n                if sum+candidates[i]>target:\\n                    break\\n                solve(i+1,lst+[candidates[i]],sum+candidates[i])\\n        solve(0,[],0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071587,
                "title": "easy-c-solution-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void f(int i,vector<vector<int>>&res, vector<int>& can,vector<int>& temp, int tar){\\n            if(tar==0){\\n                res.push_back(temp);\\n                return;\\n            } \\n        for(int j=i;j<can.size();j++){\\n            if(j>i && (can[j]==can[j-1])) continue;\\n            if(can[j]>tar) break;\\n            temp.push_back(can[j]);\\n            f(j+1,res,can,temp,tar-can[j]);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& can, int tar) {\\n        sort(can.begin(),can.end());\\n        vector<vector<int>>res;\\n        vector<int>temp;\\n        f(0,res,can,temp,tar);\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(int i,vector<vector<int>>&res, vector<int>& can,vector<int>& temp, int tar){\\n            if(tar==0){\\n                res.push_back(temp);\\n                return;\\n            } \\n        for(int j=i;j<can.size();j++){\\n            if(j>i && (can[j]==can[j-1])) continue;\\n            if(can[j]>tar) break;\\n            temp.push_back(can[j]);\\n            f(j+1,res,can,temp,tar-can[j]);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& can, int tar) {\\n        sort(can.begin(),can.end());\\n        vector<vector<int>>res;\\n        vector<int>temp;\\n        f(0,res,can,temp,tar);\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826015,
                "title": "js-multiple-approaches-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/11/ugly-number.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\nvar combinationSum2 = function(candidates, target) {\\n\\nvar result = []\\n\\ncandidates.sort((a,b) => a-b)\\nvar helper = function(candidates, target, tmpArr, idx){\\n    if(target == 0){ // when target reaches zero, means that you can push it into the result\\n        result.push(tmpArr.slice())\\n        return\\n    }\\n    \\n    if(target < 0){ //with recursion, your \\'target\\' might get reduced till below zero and at that point of time it\\'s time to stop the recursion\\n        return\\n    }\\n    \\n    for(var i = idx; i < candidates.length; i++){ //simulating whether to take or not to take every single digit\\n        if(idx == i || candidates[i] != candidates[i - 1]){\\n            tmpArr.push(candidates[i])\\n            helper(candidates, target - candidates[i], tmpArr, i + 1)\\n            tmpArr.pop()    \\n        }   \\n    }   \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar combinationSum2 = function(candidates, target) {\\n\\nvar result = []\\n\\ncandidates.sort((a,b) => a-b)\\nvar helper = function(candidates, target, tmpArr, idx){\\n    if(target == 0){ // when target reaches zero, means that you can push it into the result\\n        result.push(tmpArr.slice())\\n        return\\n    }\\n    \\n    if(target < 0){ //with recursion, your \\'target\\' might get reduced till below zero and at that point of time it\\'s time to stop the recursion\\n        return\\n    }\\n    \\n    for(var i = idx; i < candidates.length; i++){ //simulating whether to take or not to take every single digit\\n        if(idx == i || candidates[i] != candidates[i - 1]){\\n            tmpArr.push(candidates[i])\\n            helper(candidates, target - candidates[i], tmpArr, i + 1)\\n            tmpArr.pop()    \\n        }   \\n    }   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774199,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int n;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < n; i++) {\\n            if(i > id and val[i] == val[i-1]) continue;\\n            arr.push_back(val[i]);\\n            solve(arr, i + 1, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        val = candidates;\\n        vector<int> arr;\\n        solve(arr, 0, target);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int n;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < n; i++) {\\n            if(i > id and val[i] == val[i-1]) continue;\\n            arr.push_back(val[i]);\\n            solve(arr, i + 1, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        val = candidates;\\n        vector<int> arr;\\n        solve(arr, 0, target);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314706,
                "title": "c-backtracking-easy-to-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    set<vector<int>> s;\\n    void backtrack(vector<int> &nums,int target,int idx,vector<int> &v)\\n    {\\n        if(target==0)\\n        {\\n        res.push_back(v);\\n        s.insert(v);\\n        return ;\\n        }\\n        if(target<0||idx>=nums.size())\\n        {\\n            return ;\\n        }\\n        \\n        v.push_back(nums[idx]);\\n        backtrack(nums,target-nums[idx],idx+1,v);\\n        v.pop_back();\\n        \\n        int temp=nums[idx];\\n        while(idx<nums.size()&&temp==nums[idx])\\n            idx++;\\n        \\n        backtrack(nums,target,idx,v);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int> v;\\n        backtrack(candidates,target,0,v);\\n        return res;\\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> res;\\n    set<vector<int>> s;\\n    void backtrack(vector<int> &nums,int target,int idx,vector<int> &v)\\n    {\\n        if(target==0)\\n        {\\n        res.push_back(v);\\n        s.insert(v);\\n        return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2270683,
                "title": "c-easy-simple-solution-combination-sum-ii",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans,k;\\n    int target;\\n    void util(vector<int> c,vector<int> a,int sum, int i)\\n    {\\n        if(sum>target )\\n                return;\\n        if(sum==target)\\n            {\\n                ans.push_back(a);\\n                return;\\n            }\\n        for(int j=i;j<c.size();j++)\\n        {\\n            if(j>i && c[j]==c[i])\\n                continue;\\n            sum+=c[j];\\n            a.push_back(c[j]);\\n            util(c,a,sum,j+1);\\n            a.pop_back();\\n            sum-=c[j];\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& c, int t) {\\n        target=t;\\n        vector<int> a;\\n        sort(c.begin(),c.end());\\n        util(c,a,0,0);\\n        set<vector<int>> s;\\n        for(auto t: ans)\\n        {\\n            if(s.find(t)==s.end())\\n            {\\n                s.insert(t);\\n                k.push_back(t);\\n            }\\n        }\\n        return k;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> ans,k;\\n    int target;\\n    void util(vector<int> c,vector<int> a,int sum, int i)\\n    {\\n        if(sum>target )\\n                return;\\n        if(sum==target)\\n            {\\n                ans.push_back(a);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1786651,
                "title": "using-java-recursion-with-set",
                "content": "class Solution \\n\\n\\n{\\n    \\n    private void findCombinations(int index,int[] array,int target,Set<List<Integer>> ans,List<Integer> ds)\\n    {\\n        \\n        if(index==array.length)\\n        {\\n            if(target==0)\\n            {\\n                ans.add(new ArrayList<>(ds));\\n               \\n            }\\n            return;\\n        }\\n        \\n        if(array[index]<=target)\\n        {\\n            ds.add(array[index]);\\n            \\n            findCombinations(index+1,array,target-array[index],ans,ds);\\n            ds.remove(ds.size()-1);\\n        }\\n        findCombinations(index+1,array,target,ans,ds);\\n    }\\n    \\n    \\n    \\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\n        Set<List<Integer>> ans = new HashSet<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList<>());\\n         \\n        \\n        List<List<Integer>> op = new ArrayList<>();\\n        for(List a:ans)\\n        {\\n            op.add(a);\\n        }\\n       return op;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution \\n\\n\\n{\\n    \\n    private void findCombinations(int index,int[] array,int target,Set<List<Integer>> ans,List<Integer> ds)\\n    {\\n        \\n        if(index==array.length)\\n        {\\n            if(target==0)\\n            {\\n                ans.add(new ArrayList<>(ds));\\n               \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1778007,
                "title": "c-simpelst-backtracking-solution-faster-than-100",
                "content": "* The solution is same as that of **Combination Sum**.\\n* But here, since there are repated elements & each element can be used only once, we\\'ll not be looping as : solve(candidates, i, curr, ans, target-C[i]) - this will lead to using an element more than once.\\n* We also add an additional condition in ```solve()``` i.e; when we\\'re traversing the array using ```j```, if ```j != i```, we\\'ll not be adding an element that\\'s repeated (Because we can use elements that\\'re repeated as many no. of times they\\'re repeated, but we cannot have the same combinations forming again and again)\\n\\n* **Eg :** In ```candidates = [1, 1, ,2 ,5 ,6, 7, 10]``` ---> Once we form a combination [1, 2, 5] if we use the 2nd one we\\'ll be again forming the same combination [1, 2, 5] since it satisfies the condition -- Add to the array if it\\'s less than the remaining target. So we avoid using such elements.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> combinationSum2(vector<int>& C, int X) {\\n        n = C.size();\\n        sort(C.begin(), C.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        solve(C, 0, curr, ans, X);\\n        return ans;\\n    }\\n    void solve(vector<int> &C, int i, vector<int> &curr, vector<vector<int>> &ans, int X){\\n        if(X == 0){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        for(int j=i; j<n; j++){\\n            if(X - C[j] >= 0){\\n                if(j > i && C[j]==C[j-1]) continue;\\n                curr.push_back(C[j]);\\n                solve(C, j+1, curr, ans, X-C[j]);\\n                curr.pop_back();\\n            }\\n        }\\n    } \\n};\\n```\\n\\n**Time Complexity :** O(k *x* 2^k) - k = avg length of the combinations arrays\\n\\n\\n**Do upvote if you\\'ve found my solution & explanation helpful :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```solve()```\n```j```\n```j != i```\n```candidates = [1, 1, ,2 ,5 ,6, 7, 10]```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> combinationSum2(vector<int>& C, int X) {\\n        n = C.size();\\n        sort(C.begin(), C.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        solve(C, 0, curr, ans, X);\\n        return ans;\\n    }\\n    void solve(vector<int> &C, int i, vector<int> &curr, vector<vector<int>> &ans, int X){\\n        if(X == 0){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        for(int j=i; j<n; j++){\\n            if(X - C[j] >= 0){\\n                if(j > i && C[j]==C[j-1]) continue;\\n                curr.push_back(C[j]);\\n                solve(C, j+1, curr, ans, X-C[j]);\\n                curr.pop_back();\\n            }\\n        }\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713508,
                "title": "easy-to-understand-forgive-me-drawing-ugly-trees",
                "content": "![image](https://assets.leetcode.com/users/images/00b770e0-5782-458a-92f2-7348e78ce975_1642956700.9327555.png)\\n\\n<br>\\nsome cases you must pay attention to:\\n\\n\\n\\n1. n < 0\\n\\n```java\\nif (n < 0) skip all later ones\\n```\\n\\n2. n == 0\\n\\n```java\\n// write as template\\nif (n == 0) {\\n  \\tres.add(....)\\n    return;\\n}\\n```\\n\\n3. after backtrack recursion calling in loop, skip duplicates\\n\\n```java\\nwhile (i + 1 < A.length && A[i + 1] == A[i])\\n  i += 1;\\n```\\n\\n\\n\\nsome code:\\n\\n```java\\n/*\\nEach number in candidates may only be used once in the combination.\\nThus, need to use \\'offset\\'\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        \\n        backtrack(candidates, target, res, new ArrayList<>(), 0);\\n        \\n        return res;\\n    }\\n    \\n    private void backtrack(int[] A, int n, List<List<Integer>> res\\n                           , List<Integer> list, int offset) {\\n        if (n == 0) {\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for (int i = offset; i < A.length; i += 1) {\\n            \\n            int tmp = A[i];\\n            \\n            list.add(A[i]);\\n            n -= A[i];\\n            \\n            if (n < 0) // if n < 0, we dont even go to next level of backtracking tree!\\n                i = A.length;\\n            else\\n                backtrack(A, n, res, list, i + 1);\\n            \\n            list.remove(list.size() - 1);\\n            n += tmp;\\n            \\n            // skip all dups\\n            while (i + 1 < A.length && A[i + 1] == A[i])\\n                i += 1;\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\nif (n < 0) skip all later ones\\n```\n```java\\n// write as template\\nif (n == 0) {\\n  \\tres.add(....)\\n    return;\\n}\\n```\n```java\\nwhile (i + 1 < A.length && A[i + 1] == A[i])\\n  i += 1;\\n```\n```java\\n/*\\nEach number in candidates may only be used once in the combination.\\nThus, need to use \\'offset\\'\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        \\n        backtrack(candidates, target, res, new ArrayList<>(), 0);\\n        \\n        return res;\\n    }\\n    \\n    private void backtrack(int[] A, int n, List<List<Integer>> res\\n                           , List<Integer> list, int offset) {\\n        if (n == 0) {\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for (int i = offset; i < A.length; i += 1) {\\n            \\n            int tmp = A[i];\\n            \\n            list.add(A[i]);\\n            n -= A[i];\\n            \\n            if (n < 0) // if n < 0, we dont even go to next level of backtracking tree!\\n                i = A.length;\\n            else\\n                backtrack(A, n, res, list, i + 1);\\n            \\n            list.remove(list.size() - 1);\\n            n += tmp;\\n            \\n            // skip all dups\\n            while (i + 1 < A.length && A[i + 1] == A[i])\\n                i += 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673313,
                "title": "easy-java-solution-and-explaination-with-time-and-space-complexity",
                "content": "```\\nclass Solution {\\n    \\n    //lets implement the func here\\n    public void func(int ind, int target, int[] arr, List<Integer> ds, List<List<Integer>> ansList)\\n    {\\n        \\n        //this is the base case -> whenever the target will reach 0 \\n        //we can surely say that we\\'ve got our list and we can add it to the ansList\\n        \\n         if(target == 0) {\\n            ansList.add(new ArrayList<>(ds)); \\n            return; \\n        }\\n        \\n        //every time we are checking from the index ind to n-1 where n is the length of the array\\n        for(int i = ind; i< arr.length; i++)\\n        {\\n            \\n            //this is how we\\'ll find the duplicates and ignore it.\\n            //basically i\\'m checking if I am not getting any particular elemnt for the first time (i>ind)\\n            //&& the previous arr element is same as this one\\n            //then I\\'ll simply continue \\n            if(i > ind && arr[i] == arr[i-1]) continue;\\n            \\n            //Also, suppose my target is 4 and the arr[ind] is 10\\n            //then I can\\'t really use that array element\\n            //thats why I simply break out of the loop\\n            if(arr[ind] > target) break;\\n            \\n            // If I come out of the if condition \\n            //then that means everything is alright and the current array element \\n            //can contribute to my ans so I add it to my list ds.\\n            ds.add(arr[i]);\\n            \\n            //next, I call the function for the next element and this time my target will sure be reduced by whatever value we have ar arr[i]\\n            func(i+1, target - arr[i], arr, ds, ansList);\\n            \\n            //when we return make sure to remove whatever we\\'ve added. This is the backtracking step.\\n            ds.remove(ds.size() - 1); \\n        }\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        \\n        //Initially sort the given array because we need to avoid duplicates.\\n        Arrays.sort(candidates);\\n        \\n        //create a List of List of Integer so that we can return our output.\\n        List<List<Integer>> ansList = new ArrayList<>();\\n        \\n        //create a function and pass index=0, target, array, List<Integer>, ansList)\\n        //we pass List<Integer> because in the main ansList we\\'ll be adding this list with all the possible unique lists.\\n         func(0, target, candidates, new ArrayList<Integer>(), ansList);\\n        \\n        //once we get our output from the above function we return ansList.\\n        return ansList;\\n    }\\n}\\n```\\n\\nTC - O(2^n) * K - where k is the average list size\\nSC - K * X - where X is no. of combinations\\n\\nI hope you find this helpful. Please do upvote in case you understood.\\nThankss!",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //lets implement the func here\\n    public void func(int ind, int target, int[] arr, List<Integer> ds, List<List<Integer>> ansList)\\n    {\\n        \\n        //this is the base case -> whenever the target will reach 0 \\n        //we can surely say that we\\'ve got our list and we can add it to the ansList\\n        \\n         if(target == 0) {\\n            ansList.add(new ArrayList<>(ds)); \\n            return; \\n        }\\n        \\n        //every time we are checking from the index ind to n-1 where n is the length of the array\\n        for(int i = ind; i< arr.length; i++)\\n        {\\n            \\n            //this is how we\\'ll find the duplicates and ignore it.\\n            //basically i\\'m checking if I am not getting any particular elemnt for the first time (i>ind)\\n            //&& the previous arr element is same as this one\\n            //then I\\'ll simply continue \\n            if(i > ind && arr[i] == arr[i-1]) continue;\\n            \\n            //Also, suppose my target is 4 and the arr[ind] is 10\\n            //then I can\\'t really use that array element\\n            //thats why I simply break out of the loop\\n            if(arr[ind] > target) break;\\n            \\n            // If I come out of the if condition \\n            //then that means everything is alright and the current array element \\n            //can contribute to my ans so I add it to my list ds.\\n            ds.add(arr[i]);\\n            \\n            //next, I call the function for the next element and this time my target will sure be reduced by whatever value we have ar arr[i]\\n            func(i+1, target - arr[i], arr, ds, ansList);\\n            \\n            //when we return make sure to remove whatever we\\'ve added. This is the backtracking step.\\n            ds.remove(ds.size() - 1); \\n        }\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        \\n        //Initially sort the given array because we need to avoid duplicates.\\n        Arrays.sort(candidates);\\n        \\n        //create a List of List of Integer so that we can return our output.\\n        List<List<Integer>> ansList = new ArrayList<>();\\n        \\n        //create a function and pass index=0, target, array, List<Integer>, ansList)\\n        //we pass List<Integer> because in the main ansList we\\'ll be adding this list with all the possible unique lists.\\n         func(0, target, candidates, new ArrayList<Integer>(), ansList);\\n        \\n        //once we get our output from the above function we return ansList.\\n        return ansList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568727,
                "title": "solution-using-backtracking-with-given-input-in-c",
                "content": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nvoid unique_combination(int l, int sum, int K,vector<int>& local,vector<int>& A)\\n{\\n\\tif (sum == K) {\\n\\t\\tcout << \"(\";\\n\\t\\tfor (int i = 0; i < local.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif (i != 0)\\n\\t\\t\\t\\tcout << \" \";\\n\\t\\t\\tcout << local[i];\\n\\t\\t\\tif (i != local.size() - 1)\\n\\t\\t\\t\\tcout << \",\";\\n\\t\\t}\\n\\t\\tcout << \")\" << endl;\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = l; i < A.size(); i++)\\n\\t{\\n\\t\\tif (sum + A[i] > K)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tif (i > l and A[i] == A[i - 1])\\n\\t\\t\\tcontinue;\\n\\n\\t\\tlocal.push_back(A[i]);\\n\\t\\tunique_combination(i + 1, sum + A[i], K, local, A);\\n\\n\\t\\tlocal.pop_back();\\n\\t}\\n}\\n\\nvoid Combination(vector<int> A, int K)\\n{\\n\\tsort(A.begin(), A.end());\\n\\n\\t\\n\\tvector<int> local;\\n\\n\\tunique_combination(0, 0, K, local, A);\\n}\\n\\nint main()\\n{\\n\\tvector<int> W = {5,10,12,13,15,18};\\n    int target = 30;\\n    cout << \"All unique combinations of given numbers that result in sum= \" << target << \" are:\\\\n\";\\n    Combination(W,target);\\n    \\n\\n\\treturn 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nvoid unique_combination(int l, int sum, int K,vector<int>& local,vector<int>& A)\\n{\\n\\tif (sum == K) {\\n\\t\\tcout << \"(\";\\n\\t\\tfor (int i = 0; i < local.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif (i != 0)\\n\\t\\t\\t\\tcout << \" \";\\n\\t\\t\\tcout << local[i];\\n\\t\\t\\tif (i != local.size() - 1)\\n\\t\\t\\t\\tcout << \",\";\\n\\t\\t}\\n\\t\\tcout << \")\" << endl;\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = l; i < A.size(); i++)\\n\\t{\\n\\t\\tif (sum + A[i] > K)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tif (i > l and A[i] == A[i - 1])\\n\\t\\t\\tcontinue;\\n\\n\\t\\tlocal.push_back(A[i]);\\n\\t\\tunique_combination(i + 1, sum + A[i], K, local, A);\\n\\n\\t\\tlocal.pop_back();\\n\\t}\\n}\\n\\nvoid Combination(vector<int> A, int K)\\n{\\n\\tsort(A.begin(), A.end());\\n\\n\\t\\n\\tvector<int> local;\\n\\n\\tunique_combination(0, 0, K, local, A);\\n}\\n\\nint main()\\n{\\n\\tvector<int> W = {5,10,12,13,15,18};\\n    int target = 30;\\n    cout << \"All unique combinations of given numbers that result in sum= \" << target << \" are:\\\\n\";\\n    Combination(W,target);\\n    \\n\\n\\treturn 0;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1369209,
                "title": "template-same-structure-codes-for-combination-subset-and-permutations",
                "content": "In this post:\\n\\nthese codes may not the fast solution or solution with least lines, but:\\n**If you understand one question, you can fix all others.**\\n\\nAll of them used the same structure.\\n--- Bot Up DFS, so we can use memorization to save inmediate results to speed up the algorithm.\\n\\n**All memorization part are not mandatory** , if you remove these codes, the algorithm still works.\\n\\nPart 1: Permutations\\nWhen order is matter,  we use boolean[] visited to avoid duplicate values.\\nPart 2: Combination\\nWhen order is not necessary,  for (int i = start; i < n; i++)  and dfs(i + 1) to avlid duplicate combination.\\nPart 3: Set\\nWhen the order is not necessary and the size of combination can be different, use a for loop to check the size from 0 to k.\\n\\n------------------------------------------------------------------------------------------------\\n\\n# Part one: Permutations\\nleetcode 46 https://leetcode.com/problems/permutations/\\n```\\nclass Solution {\\n    int[] nums;\\n    boolean[] visited;\\n    public List<List<Integer>> permute(int[] nums) {\\n        this.nums = nums;\\n        this.visited = new boolean[nums.length];\\n        return permuteDfs(0);\\n    }\\n    \\n    private List<List<Integer>> permuteDfs(int pos) {\\n       \\n\\t   if(pos == nums.length) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\t\\t\\n        for (int i = 0; i < nums.length; i++) {\\n            if(visited[i]) continue;\\n            visited[i] = true;\\n            List<List<Integer>> subs = permuteDfs(pos + 1);\\n            for (List<Integer> sub: subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(nums[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n            visited[i] = false;\\n        }        \\n        return res;\\n    }\\n}\\n```\\n\\nleetcode 47 https://leetcode.com/problems/permutations-ii/\\n\\njust one line different to fix the duplication\\n\\n*if(i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) continue;*\\n```\\nclass Solution {\\n    int[] nums;\\n    boolean[] visited;\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        this.nums = nums;\\n        visited = new boolean[nums.length];\\n        Arrays.sort(nums);\\n        return permuteUniqueDfs(0);\\n    }\\n    \\n    private List<List<Integer>> permuteUniqueDfs(int pos) {\\n        if(pos == nums.length) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if(visited[i]) continue;\\n            if(i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) continue;\\n                visited[i] = true;\\n                List<List<Integer>> subs = permuteUniqueDfs(pos + 1);\\n                for (List<Integer> sub: subs) {\\n                    List<Integer> item = new ArrayList<>();\\n                    item.add(nums[i]);\\n                    item.addAll(sub);\\n                    res.add(item);\\n                visited[i] = false;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nleetcode 131\\nhttps://leetcode.com/problems/palindrome-partitioning/\\nThere is memorization function.\\n\\n```\\nclass Solution {\\n    String s;\\n    Map<Integer, List<List<String>>> cache;\\n    public List<List<String>> partition(String s) {\\n        this.s = s;\\n        this.cache = new HashMap<>();\\n        return partitionDfs(0);\\n    }\\n    \\n    private List<List<String>>  partitionDfs(int start) {\\n        if(start == s.length()) {\\n            List<List<String>> res = new ArrayList<>();\\n            List<String> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n        \\n        if(cache.containsKey(start)){\\n            return cache.get(start);\\n        }\\n        \\n        List<List<String>> res = new ArrayList<>();\\n        for (int i = start + 1; i <= s.length(); i++) {\\n            String cur = s.substring(start, i);\\n            if(isValid(cur)) {\\n                List<List<String>> subs = partitionDfs(i);\\n                for (List<String> sub: subs) {\\n                    List<String> prefix_item = new ArrayList<>();\\n                    prefix_item.add(cur);\\n                    prefix_item.addAll(sub);\\n                    res.add(prefix_item);\\n                }\\n            }\\n        }\\n        cache.put(start, res);\\n        return res;\\n    }\\n    \\n    private boolean isValid(String str) {\\n        int l = 0;\\n        int r = str.length() - 1;    \\n        while(l < r) {\\n            if (str.charAt(l) != str.charAt(r)) return false;\\n            else {\\n                l++;\\n                r--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n\\n# Part 2: Combination\\nleetcode 77 \\nhttps://leetcode.com/problems/combinations/\\n```\\nclass Solution {\\n    int k;\\n    int n;\\n    public List<List<Integer>> combine(int n, int k) {\\n        this.k = k;\\n        this.n = n;\\n        return combineDfs(1, 0);\\n    }\\n    \\n    private List<List<Integer>> combineDfs(int start, int len) {\\n        if(len == k) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = start; i <= n; i++) {\\n            List<List<Integer>> subs = combineDfs(i + 1, len + 1);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(i);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nLeetcode 39. https://leetcode.com/problems/combination-sum/\\n```\\nclass Solution {\\n    int[] candidates;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        this.candidates = candidates;\\n        int n = candidates.length;        \\n        return combinationSumDfs(target, 0);\\n    }\\n    \\n    private List<List<Integer>> combinationSumDfs(int target, int pos) {\\n        if(target < 0) return new ArrayList<>();\\n        \\n        if(this.cache.containsKey(new Pair(target, pos))) {\\n            return this.cache.get(new Pair(target, pos));\\n        }\\n        \\n        if(target == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(target, pos);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n    \\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = pos; i < candidates.length; i++) {\\n            List<List<Integer>> subs = combinationSumDfs(target - candidates[i], i);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(candidates[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        \\n        Pair<Integer, Integer> pair = new Pair(target, pos);\\n        cache.put(pair, res);\\n            \\n        return res;\\n    } \\n}\\n```\\n\\nleetcode 40 https://leetcode.com/problems/combination-sum-ii/\\n\\n```\\nclass Solution {\\n    int[] candidates;\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        this.candidates = candidates;\\n        return combinationSum2Dfs(target, 0);\\n    }\\n    \\n    private List<List<Integer>> combinationSum2Dfs(int target, int start) {\\n        if(target == 0){\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;    \\n        }\\n        \\n        if(target < 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = start; i < candidates.length; i++) {\\n            if((i == start || candidates[i] != candidates[i - 1])) {\\n                List<List<Integer>> subs = combinationSum2Dfs(target - candidates[i], i + 1);\\n                for (List<Integer> sub: subs) {\\n                    List<Integer> prefix_item = new ArrayList<>();\\n                    prefix_item.add(candidates[i]);\\n                    prefix_item.addAll(sub);\\n                    res.add(prefix_item);\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nPart 3: Set\\n\\nleetcode 78 https://leetcode.com/problems/subsets/\\n\\n```\\nclass Solution {\\n    int[] nums;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> subsets(int[] nums) {\\n        this.nums = nums;\\n        List<List<Integer>>  res = new ArrayList<>();\\n        for (int k = 0; k <= nums.length; k++) {\\n            res.addAll(subsetsDfs(0, k));\\n        }\\n        return res;\\n    }\\n \\n    private List<List<Integer>> subsetsDfs(int start, int len) {\\n        if(len == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();;\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(start, len);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n        \\n        if(this.cache.containsKey(new Pair(start, len))) {\\n            return this.cache.get(new Pair(start, len));\\n        }\\n                \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            List<List<Integer>> subs = subsetsDfs(i + 1, len - 1);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(nums[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        \\n        Pair<Integer, Integer> pair = new Pair(start, len);\\n        cache.put(pair, res);\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nleetcode 90\\nhttps://leetcode.com/problems/subsets-ii/\\n\\n```\\nclass Solution {\\n   int[] nums;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        this.nums = nums;\\n        Arrays.sort(nums);\\n        List<List<Integer>>  res = new ArrayList<>();\\n        for (int k = 0; k <= nums.length; k++) {\\n            res.addAll(subsetsDfs(0, k));\\n        }\\n        return res;\\n    }\\n \\n    private List<List<Integer>> subsetsDfs(int start, int len) {\\n        if(len == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();;\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(start, len);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n        \\n        if(this.cache.containsKey(new Pair(start, len))) {\\n            return this.cache.get(new Pair(start, len));\\n        }\\n                \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            if(i == start || nums[i] != nums[i - 1]) {\\n                List<List<Integer>> subs = subsetsDfs(i + 1, len - 1);\\n                for (List<Integer> sub : subs) {\\n                    List<Integer> item = new ArrayList<>();\\n                    item.add(nums[i]);\\n                    item.addAll(sub);\\n                    res.add(item);\\n                }                \\n            }\\n        }\\n        \\n\\n        Pair<Integer, Integer> pair = new Pair(start, len);\\n        cache.put(pair, res);\\n        \\n        return res;\\n    }\\n}\\n\\n```\\n\\nRelated posts before:\\n\\n\\nPython:\\nhttps://leetcode.com/problems/permutation-sequence/discuss/22554/Backtrack-Summary%3A-General-Solution-for-10-Questions!!!!!!!!-Python-(Combination-Sum-Subsets-Permutation-Palindrome)\\n\\nJava:\\nhttps://leetcode.com/problems/permutations/discuss/18239/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning\\n\\n---------------------------\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] nums;\\n    boolean[] visited;\\n    public List<List<Integer>> permute(int[] nums) {\\n        this.nums = nums;\\n        this.visited = new boolean[nums.length];\\n        return permuteDfs(0);\\n    }\\n    \\n    private List<List<Integer>> permuteDfs(int pos) {\\n       \\n\\t   if(pos == nums.length) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\t\\t\\n        for (int i = 0; i < nums.length; i++) {\\n            if(visited[i]) continue;\\n            visited[i] = true;\\n            List<List<Integer>> subs = permuteDfs(pos + 1);\\n            for (List<Integer> sub: subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(nums[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n            visited[i] = false;\\n        }        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] nums;\\n    boolean[] visited;\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        this.nums = nums;\\n        visited = new boolean[nums.length];\\n        Arrays.sort(nums);\\n        return permuteUniqueDfs(0);\\n    }\\n    \\n    private List<List<Integer>> permuteUniqueDfs(int pos) {\\n        if(pos == nums.length) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if(visited[i]) continue;\\n            if(i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) continue;\\n                visited[i] = true;\\n                List<List<Integer>> subs = permuteUniqueDfs(pos + 1);\\n                for (List<Integer> sub: subs) {\\n                    List<Integer> item = new ArrayList<>();\\n                    item.add(nums[i]);\\n                    item.addAll(sub);\\n                    res.add(item);\\n                visited[i] = false;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    String s;\\n    Map<Integer, List<List<String>>> cache;\\n    public List<List<String>> partition(String s) {\\n        this.s = s;\\n        this.cache = new HashMap<>();\\n        return partitionDfs(0);\\n    }\\n    \\n    private List<List<String>>  partitionDfs(int start) {\\n        if(start == s.length()) {\\n            List<List<String>> res = new ArrayList<>();\\n            List<String> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n        \\n        if(cache.containsKey(start)){\\n            return cache.get(start);\\n        }\\n        \\n        List<List<String>> res = new ArrayList<>();\\n        for (int i = start + 1; i <= s.length(); i++) {\\n            String cur = s.substring(start, i);\\n            if(isValid(cur)) {\\n                List<List<String>> subs = partitionDfs(i);\\n                for (List<String> sub: subs) {\\n                    List<String> prefix_item = new ArrayList<>();\\n                    prefix_item.add(cur);\\n                    prefix_item.addAll(sub);\\n                    res.add(prefix_item);\\n                }\\n            }\\n        }\\n        cache.put(start, res);\\n        return res;\\n    }\\n    \\n    private boolean isValid(String str) {\\n        int l = 0;\\n        int r = str.length() - 1;    \\n        while(l < r) {\\n            if (str.charAt(l) != str.charAt(r)) return false;\\n            else {\\n                l++;\\n                r--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int k;\\n    int n;\\n    public List<List<Integer>> combine(int n, int k) {\\n        this.k = k;\\n        this.n = n;\\n        return combineDfs(1, 0);\\n    }\\n    \\n    private List<List<Integer>> combineDfs(int start, int len) {\\n        if(len == k) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = start; i <= n; i++) {\\n            List<List<Integer>> subs = combineDfs(i + 1, len + 1);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(i);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] candidates;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        this.candidates = candidates;\\n        int n = candidates.length;        \\n        return combinationSumDfs(target, 0);\\n    }\\n    \\n    private List<List<Integer>> combinationSumDfs(int target, int pos) {\\n        if(target < 0) return new ArrayList<>();\\n        \\n        if(this.cache.containsKey(new Pair(target, pos))) {\\n            return this.cache.get(new Pair(target, pos));\\n        }\\n        \\n        if(target == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(target, pos);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n    \\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = pos; i < candidates.length; i++) {\\n            List<List<Integer>> subs = combinationSumDfs(target - candidates[i], i);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(candidates[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        \\n        Pair<Integer, Integer> pair = new Pair(target, pos);\\n        cache.put(pair, res);\\n            \\n        return res;\\n    } \\n}\\n```\n```\\nclass Solution {\\n    int[] candidates;\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        this.candidates = candidates;\\n        return combinationSum2Dfs(target, 0);\\n    }\\n    \\n    private List<List<Integer>> combinationSum2Dfs(int target, int start) {\\n        if(target == 0){\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;    \\n        }\\n        \\n        if(target < 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = start; i < candidates.length; i++) {\\n            if((i == start || candidates[i] != candidates[i - 1])) {\\n                List<List<Integer>> subs = combinationSum2Dfs(target - candidates[i], i + 1);\\n                for (List<Integer> sub: subs) {\\n                    List<Integer> prefix_item = new ArrayList<>();\\n                    prefix_item.add(candidates[i]);\\n                    prefix_item.addAll(sub);\\n                    res.add(prefix_item);\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] nums;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> subsets(int[] nums) {\\n        this.nums = nums;\\n        List<List<Integer>>  res = new ArrayList<>();\\n        for (int k = 0; k <= nums.length; k++) {\\n            res.addAll(subsetsDfs(0, k));\\n        }\\n        return res;\\n    }\\n \\n    private List<List<Integer>> subsetsDfs(int start, int len) {\\n        if(len == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();;\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(start, len);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n        \\n        if(this.cache.containsKey(new Pair(start, len))) {\\n            return this.cache.get(new Pair(start, len));\\n        }\\n                \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            List<List<Integer>> subs = subsetsDfs(i + 1, len - 1);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(nums[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        \\n        Pair<Integer, Integer> pair = new Pair(start, len);\\n        cache.put(pair, res);\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n   int[] nums;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        this.nums = nums;\\n        Arrays.sort(nums);\\n        List<List<Integer>>  res = new ArrayList<>();\\n        for (int k = 0; k <= nums.length; k++) {\\n            res.addAll(subsetsDfs(0, k));\\n        }\\n        return res;\\n    }\\n \\n    private List<List<Integer>> subsetsDfs(int start, int len) {\\n        if(len == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();;\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(start, len);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n        \\n        if(this.cache.containsKey(new Pair(start, len))) {\\n            return this.cache.get(new Pair(start, len));\\n        }\\n                \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            if(i == start || nums[i] != nums[i - 1]) {\\n                List<List<Integer>> subs = subsetsDfs(i + 1, len - 1);\\n                for (List<Integer> sub : subs) {\\n                    List<Integer> item = new ArrayList<>();\\n                    item.add(nums[i]);\\n                    item.addAll(sub);\\n                    res.add(item);\\n                }                \\n            }\\n        }\\n        \\n\\n        Pair<Integer, Integer> pair = new Pair(start, len);\\n        cache.put(pair, res);\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208963,
                "title": "python-knapsack-solution",
                "content": "This problem sounds very similar to a [well known knapsack problem](https://en.wikipedia.org/wiki/Knapsack_problem).\\nIt can be solved here in `O(N^2*target)` time and memory.\\n\\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t    cands = sorted(candidates)\\n        n = len(cands)\\n        dp = [[set() for _ in range(target+1)] for _ in range(n+1)]\\n        for i in range(n+1):\\n            dp[i][0] = set([tuple()])\\n        for i in range(1, n+1):\\n            for s in range(1, target+1):\\n                dp[i][s] = dp[i-1][s].copy()\\n                if s < cands[i-1]:\\n                    continue\\n                for comb in dp[i-1][s-cands[i-1]]:\\n                    dp[i][s].add(comb+(cands[i-1],))\\n                    \\n        return [list(var) for var in dp[n][target]]\\n```\\n\\nOf course, we can save some memory because we use only previous row (`O(target*N)`). Smth like following:\\n\\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        cands = sorted(candidates)\\n        n = len(cands)\\n        dp = [[set() for _ in range(target+1)] for _ in range(2)]\\n        dpIdx = 0\\n        dp[dpIdx][0] = set([tuple()])\\n        for i in range(1, n+1):\\n            dpIdx2 = 1 - dpIdx\\n            dp[dpIdx2][0] = set([tuple()])\\n            for s in range(1, target+1):\\n                dp[dpIdx2][s] = dp[dpIdx][s].copy()\\n                if s < cands[i-1]:\\n                    continue\\n                for comb in dp[dpIdx][s-cands[i-1]]:\\n                    dp[dpIdx2][s].add(comb+(cands[i-1],))\\n                    \\n            print(dp[dpIdx2])\\n            dpIdx = dpIdx2\\n                    \\n        return [list(var) for var in dp[dpIdx][target]]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t    cands = sorted(candidates)\\n        n = len(cands)\\n        dp = [[set() for _ in range(target+1)] for _ in range(n+1)]\\n        for i in range(n+1):\\n            dp[i][0] = set([tuple()])\\n        for i in range(1, n+1):\\n            for s in range(1, target+1):\\n                dp[i][s] = dp[i-1][s].copy()\\n                if s < cands[i-1]:\\n                    continue\\n                for comb in dp[i-1][s-cands[i-1]]:\\n                    dp[i][s].add(comb+(cands[i-1],))\\n                    \\n        return [list(var) for var in dp[n][target]]\\n```\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        cands = sorted(candidates)\\n        n = len(cands)\\n        dp = [[set() for _ in range(target+1)] for _ in range(2)]\\n        dpIdx = 0\\n        dp[dpIdx][0] = set([tuple()])\\n        for i in range(1, n+1):\\n            dpIdx2 = 1 - dpIdx\\n            dp[dpIdx2][0] = set([tuple()])\\n            for s in range(1, target+1):\\n                dp[dpIdx2][s] = dp[dpIdx][s].copy()\\n                if s < cands[i-1]:\\n                    continue\\n                for comb in dp[dpIdx][s-cands[i-1]]:\\n                    dp[dpIdx2][s].add(comb+(cands[i-1],))\\n                    \\n            print(dp[dpIdx2])\\n            dpIdx = dpIdx2\\n                    \\n        return [list(var) for var in dp[dpIdx][target]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204663,
                "title": "lessons-learned",
                "content": "How this differs from Combination Sum 1 is this has **duplicate** elements and shouldn\\'t use the number at same index multiple times.\\n\\n**Related problems**: All try to teach recursion + loop combo\\n* https://leetcode.com/problems/permutations/ : **(Basics)** on every recursion, iteration starts from 0th index \\n* https://leetcode.com/problems/permutations-ii/ : **(Basics)** brings in duplicate elements, introduces countMap pattern \\n* https://leetcode.com/problems/combinations/ : **(Basics)** on every recursion, iteration starts from next index (ie, adjacent index to parent recursion iteration index) \\n* https://leetcode.com/problems/combination-sum/ : **(Basics)** sorting helps to prune\\n* https://leetcode.com/problems/combination-sum-ii/ : **(Basics)** brings in duplicate elements, introduces countMap pattern and Sort+skip adjacent duplicate elements pattern\\n* https://leetcode.com/problems/restore-ip-addresses/ : **(Advanced)** includes special char \\'.\\', StringBuilder, number conversion, number validity check, looped deletion\\n* https://leetcode.com/problems/24-game/ : **(Advanced)** \\n* If you have done the above problems, no need to do: https://leetcode.com/problems/combination-sum-iii/, https://leetcode.com/problems/subsets/, https://leetcode.com/problems/subsets-ii/, https://leetcode.com/problems/letter-combinations-of-a-phone-number/ . These are very similar to the above ones and you won\\'t gain much from these.\\n\\n\\n**Code**:\\n```\\n// Optimzed approach 3 by Pruning recursion\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);  // 1\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        // if (target < 0) return; // Better to exit early from for loop using `nums[i] <= target` so no need to recurse for further million elements just to get returned at \\'(target < 0) return;\\'\\n \\xA0 \\xA0 \\xA0 \\xA0for (int i = start; i < nums.length && nums[i] <= target; ++i) { // Prune current recursion with nums[i] <= target \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (i > start && nums[i] == nums[i - 1]) continue; // 2\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Approach 3 that I would come up with during interview: Sort and skip duplicates in the same recursive loop.\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);  // 1\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (i > start && nums[i] == nums[i - 1]) continue; // 2 This along with .sort() removes duplicate combinations.\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Approach 2 commonly used for permutation and combination problems when duplicate elements are involved: frequency Hashmap \\nclass Solution {\\n  \\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        recurse(target, map, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int target, Map<Integer, Integer> map, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        if (target < 0) return;\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            int num = entry.getKey();\\n            int count = entry.getValue();\\n            if (count <= 0 || (!tempList.isEmpty() && num < tempList.get(tempList.size() - 1))) continue; // Second condition of taking only increaing sequence (or a decreasing seq) is what turns a permuation into a combination\\n            \\n            tempList.add(num);\\n            map.put(num, count - 1);\\n            recurse(target - num, map, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n            map.put(num, count);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Approach 1 or bruteforce approach: Simply add HashSet to Combination Sum 1 to remove duplicate combinations\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        Set<List<Integer>> ans = new HashSet();\\n        Arrays.sort(nums);  // 1: Order of elements in List is important when List is used as key in HashSet\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return new ArrayList<>(ans);\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, Set<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Optimzed approach 3 by Pruning recursion\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);  // 1\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        // if (target < 0) return; // Better to exit early from for loop using `nums[i] <= target` so no need to recurse for further million elements just to get returned at \\'(target < 0) return;\\'\\n \\xA0 \\xA0 \\xA0 \\xA0for (int i = start; i < nums.length && nums[i] <= target; ++i) { // Prune current recursion with nums[i] <= target \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (i > start && nums[i] == nums[i - 1]) continue; // 2\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n// Approach 3 that I would come up with during interview: Sort and skip duplicates in the same recursive loop.\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);  // 1\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (i > start && nums[i] == nums[i - 1]) continue; // 2 This along with .sort() removes duplicate combinations.\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n// Approach 2 commonly used for permutation and combination problems when duplicate elements are involved: frequency Hashmap \\nclass Solution {\\n  \\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        recurse(target, map, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int target, Map<Integer, Integer> map, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        if (target < 0) return;\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            int num = entry.getKey();\\n            int count = entry.getValue();\\n            if (count <= 0 || (!tempList.isEmpty() && num < tempList.get(tempList.size() - 1))) continue; // Second condition of taking only increaing sequence (or a decreasing seq) is what turns a permuation into a combination\\n            \\n            tempList.add(num);\\n            map.put(num, count - 1);\\n            recurse(target - num, map, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n            map.put(num, count);\\n        }\\n    }\\n}\\n```\n```\\n// Approach 1 or bruteforce approach: Simply add HashSet to Combination Sum 1 to remove duplicate combinations\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        Set<List<Integer>> ans = new HashSet();\\n        Arrays.sort(nums);  // 1: Order of elements in List is important when List is used as key in HashSet\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return new ArrayList<>(ans);\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, Set<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197125,
                "title": "backtracking-with-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>result;\\n    void helper(vector<int>& candidates,int index,int n,vector<int>&interim,int target)\\n    {\\n        if(target == 0)\\n        {\\n            result.push_back(interim);\\n            return;\\n            \\n        }\\n        if(index == n)\\n            return;\\n        for(int i = index;i<n;i++)\\n        {\\n            if(candidates[i]<=target)\\n            {\\n                interim.push_back(candidates[i]);\\n                helper(candidates,i+1,n,interim,target-candidates[i]);\\n                interim.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n       int n = candidates.size();\\n        vector<int>interim;\\n        sort(candidates.begin(),candidates.end());\\n        helper(candidates,0,n,interim,target);\\n        set<vector<int>>pq;\\n        for(auto i:result)\\n        pq.insert(i);\\n        vector<vector<int>>result1;\\n        for(auto i:pq)\\n        {\\n            result1.push_back(i);\\n        }\\n        return result1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>result;\\n    void helper(vector<int>& candidates,int index,int n,vector<int>&interim,int target)\\n    {\\n        if(target == 0)\\n        {\\n            result.push_back(interim);\\n            return;\\n            \\n        }\\n        if(index == n)\\n            return;\\n        for(int i = index;i<n;i++)\\n        {\\n            if(candidates[i]<=target)\\n            {\\n                interim.push_back(candidates[i]);\\n                helper(candidates,i+1,n,interim,target-candidates[i]);\\n                interim.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n       int n = candidates.size();\\n        vector<int>interim;\\n        sort(candidates.begin(),candidates.end());\\n        helper(candidates,0,n,interim,target);\\n        set<vector<int>>pq;\\n        for(auto i:result)\\n        pq.insert(i);\\n        vector<vector<int>>result1;\\n        for(auto i:pq)\\n        {\\n            result1.push_back(i);\\n        }\\n        return result1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906626,
                "title": "java-backtracking-sorting-to-avoid-duplicates-dfs",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ansList = new LinkedList<>();\\n        Arrays.sort(candidates); //sorting helps avoid duplicates\\n        solve(candidates, candidates.length, target, 0, ansList, new LinkedList<>());\\n        return ansList;\\n    }\\n    \\n    void solve(int[]arr,int n, int target, int start, List<List<Integer>> ansList, List<Integer> subList){\\n        \\n        if(target == 0){\\n            ansList.add(new LinkedList<>(subList));\\n            return;\\n        }\\n        \\n        for(int i=start;i<n;i++){\\n            if(i>start && arr[i] == arr[i-1]) continue; //avoid duplicates\\n            if(target - arr[i] < 0) continue;\\n            subList.add(arr[i]);\\n            solve(arr,n,target-arr[i],i+1,ansList,subList);\\n            subList.remove(subList.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ansList = new LinkedList<>();\\n        Arrays.sort(candidates); //sorting helps avoid duplicates\\n        solve(candidates, candidates.length, target, 0, ansList, new LinkedList<>());\\n        return ansList;\\n    }\\n    \\n    void solve(int[]arr,int n, int target, int start, List<List<Integer>> ansList, List<Integer> subList){\\n        \\n        if(target == 0){\\n            ansList.add(new LinkedList<>(subList));\\n            return;\\n        }\\n        \\n        for(int i=start;i<n;i++){\\n            if(i>start && arr[i] == arr[i-1]) continue; //avoid duplicates\\n            if(target - arr[i] < 0) continue;\\n            subList.add(arr[i]);\\n            solve(arr,n,target-arr[i],i+1,ansList,subList);\\n            subList.remove(subList.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843631,
                "title": "simple-12ms-c-backtrack-explain-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int req_sum;\\n    vector<vector<int>> ans;  // We will return this as final ans\\n    int l ; //this i is the size required and size of our candidates array\\n    void helper(vector<int>& candidates,int index,int sum,vector<int>& v){\\n        if(sum==req_sum)ans.push_back(v); //We have our solution\\n        if(index>=candidates.size() || sum>req_sum)return; // Just to check overflow conditions\\n        for(int i=index;i<l;i++){\\n            if(i>index && candidates[i]==candidates[i-1])continue; //Avoiding Duplicates as array is sorted prev like [1,1,6,7] index C[0]==C[1] so we should leave this.\\n            v.push_back(candidates[i]);\\n            helper(candidates,i+1,sum+candidates[i],v); // Recursive Call with the next index\\n            \\n            v.pop_back();  // Backtracking simply if we return from above statement then we will pop_back as last inserted element must be in either of these conditions i>c.size() || sum>req_sum \\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        req_sum=target;\\n        vector<int> v;\\n        l=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        helper(candidates,0,0,v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int req_sum;\\n    vector<vector<int>> ans;  // We will return this as final ans\\n    int l ; //this i is the size required and size of our candidates array\\n    void helper(vector<int>& candidates,int index,int sum,vector<int>& v){\\n        if(sum==req_sum)ans.push_back(v); //We have our solution\\n        if(index>=candidates.size() || sum>req_sum)return; // Just to check overflow conditions\\n        for(int i=index;i<l;i++){\\n            if(i>index && candidates[i]==candidates[i-1])continue; //Avoiding Duplicates as array is sorted prev like [1,1,6,7] index C[0]==C[1] so we should leave this.\\n            v.push_back(candidates[i]);\\n            helper(candidates,i+1,sum+candidates[i],v); // Recursive Call with the next index\\n            \\n            v.pop_back();  // Backtracking simply if we return from above statement then we will pop_back as last inserted element must be in either of these conditions i>c.size() || sum>req_sum \\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        req_sum=target;\\n        vector<int> v;\\n        l=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        helper(candidates,0,0,v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 737513,
                "title": "c-easy-solution-easytounderstand",
                "content": "```\\n/*\\nRuntime: 12 ms, faster than 66.49% of C++ online submissions for Combination Sum II.\\nMemory Usage: 10.7 MB, less than 80.44% of C++ online submissions for Combination Sum II.\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> combination;\\n    vector<vector<int>> finalAnswer;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        if(candidates.size()==0){return finalAnswer;}\\n        sort(candidates.begin(),candidates.end()); //[1,1,2,5,6,7,10] target = 8\\n        int currentIndex = 0;\\n        CheckForSum(candidates, target, currentIndex);\\n        return finalAnswer;\\n    }\\n\\n    void CheckForSum(vector<int>& candidates, int target, int idx){\\n        if(target==0){\\n            if(isPresentIn2dArray(finalAnswer,combination)==true){\\n                return;\\n            }else{\\n                finalAnswer.push_back(combination);\\n            return;\\n            }\\n\\n\\n        }\\n        for(int i = idx; i<candidates.size();i++){\\n            if(target<candidates[i]) break;\\n            combination.push_back(candidates[i]);\\n            CheckForSum(candidates,target-candidates[i], i+1);\\n            combination.pop_back();\\n        } \\n    }\\n\\n    bool isPresentIn2dArray( vector<vector<int>>& finalAnswer, vector<int>& combination ){\\n        bool isPresent = find(finalAnswer.begin(), finalAnswer.end(), combination) != finalAnswer.end();\\n        return isPresent;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\nRuntime: 12 ms, faster than 66.49% of C++ online submissions for Combination Sum II.\\nMemory Usage: 10.7 MB, less than 80.44% of C++ online submissions for Combination Sum II.\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> combination;\\n    vector<vector<int>> finalAnswer;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        if(candidates.size()==0){return finalAnswer;}\\n        sort(candidates.begin(),candidates.end()); //[1,1,2,5,6,7,10] target = 8\\n        int currentIndex = 0;\\n        CheckForSum(candidates, target, currentIndex);\\n        return finalAnswer;\\n    }\\n\\n    void CheckForSum(vector<int>& candidates, int target, int idx){\\n        if(target==0){\\n            if(isPresentIn2dArray(finalAnswer,combination)==true){\\n                return;\\n            }else{\\n                finalAnswer.push_back(combination);\\n            return;\\n            }\\n\\n\\n        }\\n        for(int i = idx; i<candidates.size();i++){\\n            if(target<candidates[i]) break;\\n            combination.push_back(candidates[i]);\\n            CheckForSum(candidates,target-candidates[i], i+1);\\n            combination.pop_back();\\n        } \\n    }\\n\\n    bool isPresentIn2dArray( vector<vector<int>>& finalAnswer, vector<int>& combination ){\\n        bool isPresent = find(finalAnswer.begin(), finalAnswer.end(), combination) != finalAnswer.end();\\n        return isPresent;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632658,
                "title": "java-2-ms-faster-than-98-12-recursive-backtrack",
                "content": "same as [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/632645/Java-2-ms-faster-than-99.46) and [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/632691/Java-0-ms-faster-than-100.00-RecursiveandBacktrack).\\n```\\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    Arrays.sort(candidates);\\n    List<List<Integer>> res = new ArrayList<>();\\n    if (candidates.length == 0 || candidates[0] > target) {\\n        return res;\\n    }\\n    res = recursive(candidates, target, 0);\\n    return res;\\n}\\n\\npublic List<List<Integer>> recursive(int[] arr, int target, int start) {\\n    List<List<Integer>> res = new ArrayList<>();\\n\\n    if (start >= arr.length || arr[start] > target) {\\n        return res;\\n    }\\n    if (target == arr[start]) {\\n        List<Integer> t = new ArrayList<>();\\n        t.add(arr[start]);\\n        res.add(t);\\n        return res;\\n    }\\n\\n    for (int j = start; j < arr.length; j++) {\\n        if (target == arr[j]) {\\n            List<Integer> t = new ArrayList<>();\\n            t.add(arr[j]);\\n            res.add(t);\\n            break;\\n        }\\n        List<List<Integer>> temp = recursive(arr, target - arr[j], j + 1);\\n        if (!temp.isEmpty()) {\\n            for (List<Integer> t : temp) {\\n                t.add(0, arr[j]);\\n                res.add(t);\\n            }\\n            //remove the same res\\n            while(j + 1 < arr.length && arr[j] == arr[j + 1]){\\n                j++;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    Arrays.sort(candidates);\\n    List<List<Integer>> res = new ArrayList<>();\\n    if (candidates.length == 0 || candidates[0] > target) {\\n        return res;\\n    }\\n    res = recursive(candidates, target, 0);\\n    return res;\\n}\\n\\npublic List<List<Integer>> recursive(int[] arr, int target, int start) {\\n    List<List<Integer>> res = new ArrayList<>();\\n\\n    if (start >= arr.length || arr[start] > target) {\\n        return res;\\n    }\\n    if (target == arr[start]) {\\n        List<Integer> t = new ArrayList<>();\\n        t.add(arr[start]);\\n        res.add(t);\\n        return res;\\n    }\\n\\n    for (int j = start; j < arr.length; j++) {\\n        if (target == arr[j]) {\\n            List<Integer> t = new ArrayList<>();\\n            t.add(arr[j]);\\n            res.add(t);\\n            break;\\n        }\\n        List<List<Integer>> temp = recursive(arr, target - arr[j], j + 1);\\n        if (!temp.isEmpty()) {\\n            for (List<Integer> t : temp) {\\n                t.add(0, arr[j]);\\n                res.add(t);\\n            }\\n            //remove the same res\\n            while(j + 1 < arr.length && arr[j] == arr[j + 1]){\\n                j++;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 631916,
                "title": "c-easy-solution-pattern-in-combination-sum-1-2-and-3",
                "content": "Try to think of it as a graph with `n` nodes and `O(n^2)` edges. Then, all we need to do is do dfs and see what branches are satisfying the condition that question is asking for. \\nIf you are facing problem in following the dfs approach (_recursion fear_), try creating a graph for the the `candidates` array and write a bfs to find the sum. Once you get the hang of how the branches of graph are playing out, try writing the recursive dfs for it.\\n\\n**Combination Sum 1:**\\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState) {\\n        if (t==0) {finalState.push_back(currentState); return;}\\n    \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i, currentState, finalState);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int> > res;\\n        sort(candidates.begin(), candidates.end());\\n        vector<int> temp;\\n        recurse(target, candidates, 0, temp, res);\\n        return res;\\n    }\\n```\\n\\n\\n**Combination Sum 2:**\\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState) {\\n        if (t==0) {finalState.push_back(currentState); return;}\\n        \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (i and nums[i] == nums[i-1] and i > idx) continue;\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i+1, currentState, finalState);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n\\t\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int> > res;\\n        sort(candidates.begin(), candidates.end());\\n        vector<int> temp;\\n        recurse(target, candidates, 0, temp, res);\\n        return res;\\n    }\\n```\\n\\n**Combination Sum 3:**\\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState, int k) {\\n        if (t==0) {if (currentState.size() ==k) finalState.push_back(currentState); return;}\\n    \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (i and nums[i] == nums[i-1] and i > idx) continue;\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i+1, currentState, finalState, k);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int> > res;\\n        vector<int> candidates;\\n        for (int i = 1; i <= 9; i++) candidates.push_back(i);\\n        vector<int> temp;\\n        recurse(n, candidates, 0, temp, res, k);\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState) {\\n        if (t==0) {finalState.push_back(currentState); return;}\\n    \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i, currentState, finalState);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int> > res;\\n        sort(candidates.begin(), candidates.end());\\n        vector<int> temp;\\n        recurse(target, candidates, 0, temp, res);\\n        return res;\\n    }\\n```\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState) {\\n        if (t==0) {finalState.push_back(currentState); return;}\\n        \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (i and nums[i] == nums[i-1] and i > idx) continue;\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i+1, currentState, finalState);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n\\t\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int> > res;\\n        sort(candidates.begin(), candidates.end());\\n        vector<int> temp;\\n        recurse(target, candidates, 0, temp, res);\\n        return res;\\n    }\\n```\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState, int k) {\\n        if (t==0) {if (currentState.size() ==k) finalState.push_back(currentState); return;}\\n    \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (i and nums[i] == nums[i-1] and i > idx) continue;\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i+1, currentState, finalState, k);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int> > res;\\n        vector<int> candidates;\\n        for (int i = 1; i <= 9; i++) candidates.push_back(i);\\n        vector<int> temp;\\n        recurse(n, candidates, 0, temp, res, k);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615729,
                "title": "java-dfs-solution-beat-98-with-clear-explanations",
                "content": "We illustrate the depth first search (DFS) method to enumerate all possible combinations that satisfy the sum requirement using the example:\\ncandidates =\\xA0[2,5,2,1,2], target =\\xA05\\n1. We first sort the array and it becomes candidates =\\xA0[1, 2, 2, 2, 5]. This is needed because one can easily get rid of redundant answers while searching.\\n2.   Generate the search tree by adding one element at a time to the current list (in the order dictated by the order of the array candidates). Also, to avoid duplicates, each distinct number is allowed to be used only once for each level. In our example, this means the left graph is correct, not the right one.\\n<img src=\"https://assets.leetcode.com/users/jzhao0105/image_1589212751.png\" width=\"600\"/>\\n3. To implement the DFS recursive solution,  we need to traverse all nodes of the tree above and check if the sum of the elements in the list is equal to target. Once a solution is found (e.g. curList = [1, 2, 2]), we (deep) copy it and add it to the answer list. Also, we backtrack (i.e. remove the last element from curList [1, 2, 2] -> [1, 2] so that in the next step of recursion [1, 2, 5] will be considered too.)\\n4. Time complexity: O(S*N), where S = the number of answers (= length of ans array = 2 in our example) and N = the (average) time that is needed to construct each answer. (e.g. time to traverse the tree and find the list [1, 2, 2]).\\t\\n\\t\\n\\t\\n\\t\\t// Key observation: To eliminate all possible duplicate answers, we only need to\\n\\t\\t// remove all the duplicate candidates at the same level of the search tree\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t\\t\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\n\\t\\t\\t\\tArrays.sort(candidates);\\n\\t\\t\\t\\tdfs(candidates, target, 0, new ArrayList<Integer>(), ans);\\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\n\\t\\t\\tprivate void dfs(int[] candidates, int target, int index, \\n\\t\\t\\t\\t\\t\\t\\t List<Integer> curList, List<List<Integer>> ans) {\\n\\t\\t\\t\\tif (target == 0) {\\n\\t\\t\\t\\t\\t// Deep copy curList to ans\\n\\t\\t\\t\\t\\tans.add(new ArrayList<Integer>(curList));\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor (int i = index; i < candidates.length; i++) {\\n\\t\\t\\t\\t\\tif (candidates[i] > target) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Remove duplicate candidates at the same level of the tree\\n\\t\\t\\t\\t\\tif (i > index && candidates[i] == candidates[i - 1]) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurList.add(candidates[i]);\\n\\t\\t\\t\\t\\tdfs(candidates, target - candidates[i], i + 1, curList, ans);\\n\\t\\t\\t\\t\\tcurList.remove(curList.size() - 1); // Backtrack\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tpublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t\\t\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\n\\t\\t\\t\\tArrays.sort(candidates);\\n\\t\\t\\t\\tdfs(candidates, target, 0, new ArrayList<Integer>(), ans);\\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 543026,
                "title": "go-backtrack",
                "content": "```\\nvar res [][]int\\nvar candis []int\\n\\nfunc combinationSum2(candidates []int, target int) [][]int {\\n\\tres = nil\\n\\tcandis = candidates\\n\\n\\tsort.Ints(candidates)\\n\\tbacktrack(target, nil, 0)\\n\\treturn res\\n}\\n\\nfunc backtrack(target int, cur []int, index int) {\\n\\tif target == 0 {\\n\\t\\tres = append(res, append([]int{}, cur...))\\n\\t\\treturn\\n\\t}\\n\\n\\tif target < 0 {\\n\\t\\treturn\\n\\t}\\n\\n    for i := index; i < len(candis); i++ {\\n        if i > index && candis[i] == candis[i-1] {\\n            continue \\n        }\\n\\t\\tbacktrack(target-candis[i], append(cur, candis[i]), i+1)\\n\\t}\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar res [][]int\\nvar candis []int\\n\\nfunc combinationSum2(candidates []int, target int) [][]int {\\n\\tres = nil\\n\\tcandis = candidates\\n\\n\\tsort.Ints(candidates)\\n\\tbacktrack(target, nil, 0)\\n\\treturn res\\n}\\n\\nfunc backtrack(target int, cur []int, index int) {\\n\\tif target == 0 {\\n\\t\\tres = append(res, append([]int{}, cur...))\\n\\t\\treturn\\n\\t}\\n\\n\\tif target < 0 {\\n\\t\\treturn\\n\\t}\\n\\n    for i := index; i < len(candis); i++ {\\n        if i > index && candis[i] == candis[i-1] {\\n            continue \\n        }\\n\\t\\tbacktrack(target-candis[i], append(cur, candis[i]), i+1)\\n\\t}\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 511148,
                "title": "javascript-es6-without-push-pop",
                "content": "```\\nvar combinationSum2 = function(candidates, target) {\\n    \\n    let results = [];\\n    candidates.sort((a,b) => a-b);\\n    \\n    const helper = (start, target, combinations=[]) => {\\n        if(target === 0){\\n            results.push([...combinations]);\\n            return;\\n        }\\n        \\n        for(let i = start; i < candidates.length && target-candidates[i] >= 0; i++){\\n            if(i > start && candidates[i] === candidates[i - 1]) continue;\\n\\n            helper(i+1, target-candidates[i], [...combinations, candidates[i]]);\\n        }\\n    }\\n    \\n    helper(0, target)\\n    return results;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar combinationSum2 = function(candidates, target) {\\n    \\n    let results = [];\\n    candidates.sort((a,b) => a-b);\\n    \\n    const helper = (start, target, combinations=[]) => {\\n        if(target === 0){\\n            results.push([...combinations]);\\n            return;\\n        }\\n        \\n        for(let i = start; i < candidates.length && target-candidates[i] >= 0; i++){\\n            if(i > start && candidates[i] === candidates[i - 1]) continue;\\n\\n            helper(i+1, target-candidates[i], [...combinations, candidates[i]]);\\n        }\\n    }\\n    \\n    helper(0, target)\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 481687,
                "title": "python3-backtracking-dp",
                "content": "**Approach 1 -- backtracking**\\nKeep track of a list of existing numbers and residual. When residual drops to 0, add list to answer. Similar to this [thread](https://leetcode.com/problems/combination-sum/discuss/481569/Python3-use-a-stack-to-traverse-the-solution-space-through-backtracking). \\n\\nImplementation :\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        \\n        def fn(i, val): \\n            \"\"\"Populate ans via stack.\"\"\"\\n            if val == 0: ans.append(stack.copy())\\n            elif val > 0: \\n                for ii in range(i, len(candidates)): \\n                    if i == ii or candidates[ii-1] != candidates[ii]: \\n                        stack.append(candidates[ii])\\n                        fn(ii+1, val - candidates[ii])\\n                        stack.pop()\\n            \\n        ans, stack = [], []\\n        fn(0, target)\\n        return ans\\n```\\nAnalysis:\\nTime complexity `O(2^N)`\\nSpace complexity `O(2^N)`\\n\\n**Approach 2 -- dp**\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [set() for _ in range(target+1)]\\n        dp[0].add(())\\n        for x in candidates: \\n            for i in reversed(range(target)): \\n                if x + i <= target: \\n                    for seq in dp[i]: \\n                        dp[i+x].add(seq + (x,))\\n        return dp[-1]\\n```\\n\\nComment: \\nNote the similarity to that of [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/481569/Python3-A-concise-implementation-of-backtracking-algo).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        \\n        def fn(i, val): \\n            \"\"\"Populate ans via stack.\"\"\"\\n            if val == 0: ans.append(stack.copy())\\n            elif val > 0: \\n                for ii in range(i, len(candidates)): \\n                    if i == ii or candidates[ii-1] != candidates[ii]: \\n                        stack.append(candidates[ii])\\n                        fn(ii+1, val - candidates[ii])\\n                        stack.pop()\\n            \\n        ans, stack = [], []\\n        fn(0, target)\\n        return ans\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [set() for _ in range(target+1)]\\n        dp[0].add(())\\n        for x in candidates: \\n            for i in reversed(range(target)): \\n                if x + i <= target: \\n                    for seq in dp[i]: \\n                        dp[i+x].add(seq + (x,))\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415202,
                "title": "java-2ms-99-99-faster-100-less-memory",
                "content": "```\\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    Arrays.sort(candidates);\\n    List<List<Integer>> res = new ArrayList<List<Integer>>();\\n    helper(candidates, target, 0, res, new ArrayList<Integer>());\\n    return res;\\n}\\n    \\nprivate void helper(int[] candidates, int target, int startId, List<List<Integer>> res, List<Integer> curRes) {\\n\\tif (target == 0) {\\n        res.add(new ArrayList<Integer>(curRes));\\n    } else {\\n        for (int i = startId; i < candidates.length && candidates[i] <= target; i++) {\\n            if (i > startId && candidates[i] == candidates[i - 1]) { // to avoid duplicates skip all equal numbers except the first\\n                continue;\\n            }\\n            curRes.add(candidates[i]);\\n            helper(candidates, target - candidates[i], i + 1, res, curRes);\\n            curRes.remove(curRes.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    Arrays.sort(candidates);\\n    List<List<Integer>> res = new ArrayList<List<Integer>>();\\n    helper(candidates, target, 0, res, new ArrayList<Integer>());\\n    return res;\\n}\\n    \\nprivate void helper(int[] candidates, int target, int startId, List<List<Integer>> res, List<Integer> curRes) {\\n\\tif (target == 0) {\\n        res.add(new ArrayList<Integer>(curRes));\\n    } else {\\n        for (int i = startId; i < candidates.length && candidates[i] <= target; i++) {\\n            if (i > startId && candidates[i] == candidates[i - 1]) { // to avoid duplicates skip all equal numbers except the first\\n                continue;\\n            }\\n            curRes.add(candidates[i]);\\n            helper(candidates, target - candidates[i], i + 1, res, curRes);\\n            curRes.remove(curRes.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350011,
                "title": "python-generator-solution",
                "content": "```python\\nclass Solution:\\n    def backtrack(self, candidates, remaining, idx=0, got=[]):\\n        if remaining < 0:\\n            return\\n        \\n        if idx == len(candidates):\\n            if remaining == 0:\\n                yield tuple(got)\\n            return\\n\\n        got.append(candidates[idx])\\n        yield from self.backtrack(candidates, remaining - got[-1], idx + 1)\\n        got.pop()\\n        yield from self.backtrack(candidates, remaining, idx + 1)\\n            \\n        \\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        return set(self.backtrack(candidates, target))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def backtrack(self, candidates, remaining, idx=0, got=[]):\\n        if remaining < 0:\\n            return\\n        \\n        if idx == len(candidates):\\n            if remaining == 0:\\n                yield tuple(got)\\n            return\\n\\n        got.append(candidates[idx])\\n        yield from self.backtrack(candidates, remaining - got[-1], idx + 1)\\n        got.pop()\\n        yield from self.backtrack(candidates, remaining, idx + 1)\\n            \\n        \\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        return set(self.backtrack(candidates, target))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338279,
                "title": "java-backtracking-without-for-loop-bounded-knapsack-pattern",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n         List<List<Integer>> result = new ArrayList<>(); \\n        combinationSumHelper(candidates, target, 0, result, new LinkedList<>());\\n        return result;\\n    }\\n    \\n        public void combinationSumHelper(int[] candidates, int target, int index, List<List<Integer>> result, LinkedList<Integer> temp){\\n       //if you have met the target the add result from temp     \\n       if( target == 0){\\n           result.add(new ArrayList<>(temp));\\n           return;\\n       } \\n        \\n       //coundlnt find the target and exit     \\n       if(index >= candidates.length){\\n           return;\\n       }  \\n        \\n        //case 1: you include the number. for bounded knapsack u can include only once.\\n            //hence increment the index\\n       if(candidates[index] <= target){\\n           temp.add(candidates[index]);\\n           combinationSumHelper(candidates, target-candidates[index], index+1, result, temp);\\n           temp.removeLast();\\n       }  \\n        \\n       //skip duplicate starting points     \\n       while(index+1 < candidates.length && candidates[index]==candidates[index+1]) {\\n           index++;     \\n       }\\n\\n    //case 2: you  dont include the number. same for bounded and unbounded knapsack\\n       combinationSumHelper(candidates,target, index+1, result,temp ); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n         List<List<Integer>> result = new ArrayList<>(); \\n        combinationSumHelper(candidates, target, 0, result, new LinkedList<>());\\n        return result;\\n    }\\n    \\n        public void combinationSumHelper(int[] candidates, int target, int index, List<List<Integer>> result, LinkedList<Integer> temp){\\n       //if you have met the target the add result from temp     \\n       if( target == 0){\\n           result.add(new ArrayList<>(temp));\\n           return;\\n       } \\n        \\n       //coundlnt find the target and exit     \\n       if(index >= candidates.length){\\n           return;\\n       }  \\n        \\n        //case 1: you include the number. for bounded knapsack u can include only once.\\n            //hence increment the index\\n       if(candidates[index] <= target){\\n           temp.add(candidates[index]);\\n           combinationSumHelper(candidates, target-candidates[index], index+1, result, temp);\\n           temp.removeLast();\\n       }  \\n        \\n       //skip duplicate starting points     \\n       while(index+1 < candidates.length && candidates[index]==candidates[index+1]) {\\n           index++;     \\n       }\\n\\n    //case 2: you  dont include the number. same for bounded and unbounded knapsack\\n       combinationSumHelper(candidates,target, index+1, result,temp ); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310039,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 302616,
                "title": "swift-70-beat-intuitive-solution-using-modified-dfs-smarty-logix",
                "content": "```\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        \\n        var candidates = candidates.sorted()\\n        var res = [[Int]]()\\n        var temp = [Int]()\\n        \\n        helper(&res, &temp, candidates, 0, target)\\n        \\n        return res\\n    }\\n    \\n    func helper(_ res: inout [[Int]], _ temp: inout [Int], _ candidates: [Int], _ index: Int, _ target: Int) {\\n        \\n        if target == 0 { res.append(temp); return }\\n        if target < 0 { return }\\n        \\n        for i in index..<candidates.count {\\n            \\n            //Avoid dupes.\\n            if i > index && candidates[i] == candidates[i - 1] { \\n                continue\\n            }\\n            temp.append(candidates[i])\\n            helper(&res, &temp, candidates, i + 1, target - candidates[i])\\n            temp.removeLast()\\n        }\\n    }\\n}\\n```\\n\\nThe trick is to skip the dupes in such a way where you will still get the first \"run\" of the dupes...",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        \\n        var candidates = candidates.sorted()\\n        var res = [[Int]]()\\n        var temp = [Int]()\\n        \\n        helper(&res, &temp, candidates, 0, target)\\n        \\n        return res\\n    }\\n    \\n    func helper(_ res: inout [[Int]], _ temp: inout [Int], _ candidates: [Int], _ index: Int, _ target: Int) {\\n        \\n        if target == 0 { res.append(temp); return }\\n        if target < 0 { return }\\n        \\n        for i in index..<candidates.count {\\n            \\n            //Avoid dupes.\\n            if i > index && candidates[i] == candidates[i - 1] { \\n                continue\\n            }\\n            temp.append(candidates[i])\\n            helper(&res, &temp, candidates, i + 1, target - candidates[i])\\n            temp.removeLast()\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302609,
                "title": "c-95-beat-modified-dfs-requires-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        \\n        vector<vector<int>> aResult;\\n        vector<int> aTemp;\\n        \\n        helper(aResult, aTemp, candidates, 0, target);\\n        \\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<int>> &pRes, vector<int> &pTemp, vector<int> &pCandidates, int pIndex, int pTarget) {\\n        \\n        if (pTarget < 0) { return; }\\n        if (pTarget == 0) {\\n            pRes.push_back(pTemp);\\n            return;\\n        }\\n        \\n        for (int i=pIndex;i<pCandidates.size();i++) {\\n            \\n            if (i > pIndex && pCandidates[i - 1] == pCandidates[i]) { continue; }\\n            \\n            pTemp.push_back(pCandidates[i]);\\n            helper(pRes, pTemp, pCandidates, i + 1, pTarget - pCandidates[i]);\\n            pTemp.pop_back();\\n        }\\n    }\\n    \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        \\n        vector<vector<int>> aResult;\\n        vector<int> aTemp;\\n        \\n        helper(aResult, aTemp, candidates, 0, target);\\n        \\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<int>> &pRes, vector<int> &pTemp, vector<int> &pCandidates, int pIndex, int pTarget) {\\n        \\n        if (pTarget < 0) { return; }\\n        if (pTarget == 0) {\\n            pRes.push_back(pTemp);\\n            return;\\n        }\\n        \\n        for (int i=pIndex;i<pCandidates.size();i++) {\\n            \\n            if (i > pIndex && pCandidates[i - 1] == pCandidates[i]) { continue; }\\n            \\n            pTemp.push_back(pCandidates[i]);\\n            helper(pRes, pTemp, pCandidates, i + 1, pTarget - pCandidates[i]);\\n            pTemp.pop_back();\\n        }\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170901,
                "title": "python-solution",
                "content": "Recursion:\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(j, target):\\n            if target <= 0 or not candidates or j < 0:\\n                return []\\n            res = []\\n            for i in range(j,-1,-1):\\n                if candidates[i] > target:\\n                    continue\\n                elif i <= j-1 and candidates[i] == candidates[i+1]: # avoid duplicates\\n                    continue\\n                elif candidates[i] == target:\\n                    res.append([candidates[i]])\\n                else:\\n                    tmp = helper(i-1, target - candidates[i])\\n                    res += [lst+[candidates[i]] for lst in tmp]\\n            return res\\n        \\n        candidates = sorted(candidates)\\n        res = helper(len(candidates)-1, target)\\n        return res\\n```\\nRecursion with memoization:\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(j, target):\\n            if target <= 0 or not candidates or j < 0:\\n                return []\\n            elif (j, target) in dic:\\n                return dic[(j, target)]\\n            res = []\\n            for i in range(j,-1,-1):\\n                if candidates[i] > target:\\n                    continue\\n                elif i <= j-1 and candidates[i] == candidates[i+1]: # avoid duplicates\\n                    continue\\n                elif candidates[i] == target:\\n                    res.append([candidates[i]])\\n                else:\\n                    tmp = helper(i-1, target - candidates[i])\\n                    res += [lst+[candidates[i]] for lst in tmp]\\n            dic[(j,target)] = res\\n            return res\\n        \\n        dic = {}\\n        candidates = sorted(candidates)\\n        res = helper(len(candidates)-1, target)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(j, target):\\n            if target <= 0 or not candidates or j < 0:\\n                return []\\n            res = []\\n            for i in range(j,-1,-1):\\n                if candidates[i] > target:\\n                    continue\\n                elif i <= j-1 and candidates[i] == candidates[i+1]: # avoid duplicates\\n                    continue\\n                elif candidates[i] == target:\\n                    res.append([candidates[i]])\\n                else:\\n                    tmp = helper(i-1, target - candidates[i])\\n                    res += [lst+[candidates[i]] for lst in tmp]\\n            return res\\n        \\n        candidates = sorted(candidates)\\n        res = helper(len(candidates)-1, target)\\n        return res\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(j, target):\\n            if target <= 0 or not candidates or j < 0:\\n                return []\\n            elif (j, target) in dic:\\n                return dic[(j, target)]\\n            res = []\\n            for i in range(j,-1,-1):\\n                if candidates[i] > target:\\n                    continue\\n                elif i <= j-1 and candidates[i] == candidates[i+1]: # avoid duplicates\\n                    continue\\n                elif candidates[i] == target:\\n                    res.append([candidates[i]])\\n                else:\\n                    tmp = helper(i-1, target - candidates[i])\\n                    res += [lst+[candidates[i]] for lst in tmp]\\n            dic[(j,target)] = res\\n            return res\\n        \\n        dic = {}\\n        candidates = sorted(candidates)\\n        res = helper(len(candidates)-1, target)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16863,
                "title": "java-18-lines-solution",
                "content": "```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtracing(res, new ArrayList<>(), candidates, target, 0);\\n        return res;\\n    }\\n    private void backtracing(List<List<Integer>> res, List<Integer> tempList, int[] candidates, int target, int pos) {\\n        if (target == 0) res.add(new ArrayList<Integer>(tempList)); \\n        else if (target < 0) return;\\n        else {\\n            for (int i = pos; i < candidates.length; i++) {\\n                if (i > pos && candidates[i] == candidates[i - 1]) continue;\\n                tempList.add(candidates[i]);\\n                backtracing(res, tempList, candidates, target - candidates[i], i + 1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtracing(res, new ArrayList<>(), candidates, target, 0);\\n        return res;\\n    }\\n    private void backtracing(List<List<Integer>> res, List<Integer> tempList, int[] candidates, int target, int pos) {\\n        if (target == 0) res.add(new ArrayList<Integer>(tempList)); \\n        else if (target < 0) return;\\n        else {\\n            for (int i = pos; i < candidates.length; i++) {\\n                if (i > pos && candidates[i] == candidates[i - 1]) continue;\\n                tempList.add(candidates[i]);\\n                backtracing(res, tempList, candidates, target - candidates[i], i + 1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16893,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Combination Sum II** https://leetcode.com/problems/combination-sum-ii/\\n\\n**Algorithm**\\n* Recursion tree will help you solve this problem. https://goo.gl/photos/vEDezZoWctf7CgfM8\\n* Combination Sum I allowed duplicates. To avoid those, in the recursive call, use i + 1.\\n* Now other duplicates are also possible. Imagine [1,2,5, 7, 1] and target as 8. If we use DFS we will get [1,7] and then [7,1]. How do we avoid this?\\n* Sort candidates: [1,1,2,5,7]. Now when you start with index 0, your first element will be 1. It will allow you to pick the second element as 1 too. You will be able to pick [1,7]. But during recursion, when you reach the next start index as 1, your recursion tree will again start from 1. This will lead to a duplicate [1,7]. You want to avoid this.\\n\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        result = []\\n        candidates.sort()\\n        self.helper(0, candidates, target, [], result, 0)\\n        return result\\n\\n    def helper(self, idx, candidates, target, so_far, result, sum_so_far):\\n        if sum_so_far == target:\\n            result.append([x for x in so_far])\\n        else:\\n            for i in range(idx, len(candidates)):\\n                if i == idx or candidates[i] != candidates[i-1]:\\n                    if sum_so_far + candidates[i] <= target:\\n                        so_far.append(candidates[i])\\n                        self.helper(i+1, candidates, target, so_far, result, sum_so_far + candidates[i])\\n                        so_far.pop()\\n        return\\n```\\n\\n**Another Implementation**\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        all_solns = []\\n        self.helper([], 0, sorted(candidates), target, all_solns)        \\n        return all_solns\\n\\n    def helper(self, so_far, k, nums, target, all_solns):        \\n        sum_so_far = sum(so_far)\\n        if sum_so_far == target:\\n            all_solns.append([x for x in so_far])\\n        else:\\n            for i in range(k, len(nums)):\\n                if i > k and nums[i] == nums[i-1]:\\n                    continue\\n                if (sum_so_far + nums[i] <= target):\\n                    so_far.append(nums[i])\\n                    self.helper(so_far, i+1, nums, target, all_solns)\\n                    so_far.pop()\\n        return\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        result = []\\n        candidates.sort()\\n        self.helper(0, candidates, target, [], result, 0)\\n        return result\\n\\n    def helper(self, idx, candidates, target, so_far, result, sum_so_far):\\n        if sum_so_far == target:\\n            result.append([x for x in so_far])\\n        else:\\n            for i in range(idx, len(candidates)):\\n                if i == idx or candidates[i] != candidates[i-1]:\\n                    if sum_so_far + candidates[i] <= target:\\n                        so_far.append(candidates[i])\\n                        self.helper(i+1, candidates, target, so_far, result, sum_so_far + candidates[i])\\n                        so_far.pop()\\n        return\\n```\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        all_solns = []\\n        self.helper([], 0, sorted(candidates), target, all_solns)        \\n        return all_solns\\n\\n    def helper(self, so_far, k, nums, target, all_solns):        \\n        sum_so_far = sum(so_far)\\n        if sum_so_far == target:\\n            all_solns.append([x for x in so_far])\\n        else:\\n            for i in range(k, len(nums)):\\n                if i > k and nums[i] == nums[i-1]:\\n                    continue\\n                if (sum_so_far + nums[i] <= target):\\n                    so_far.append(nums[i])\\n                    self.helper(so_far, i+1, nums, target, all_solns)\\n                    so_far.pop()\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16976,
                "title": "19-lines-concise-and-easy-understand-c-solution-backtracking",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> tmp;\\n            backtracking(res, candidates, tmp, 0, target);\\n            return res;\\n        }\\n        void backtracking(vector<vector<int>>& res, vector<int>& candidates, vector<int> tmp, int index, int target){\\n            if(target < 0 )return;\\n            if(target == 0){\\n                res.push_back(tmp);\\n                return;\\n            }\\n            for(int i = index; i < candidates.size(); i++){\\n                if(i == index || candidates[i] != candidates[i - 1]){\\n                    tmp.push_back(candidates[i]);\\n                    backtracking(res, candidates, tmp, i + 1, target - candidates[i]);\\n                    tmp.pop_back();\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> tmp;\\n            backtracking(res, candidates, tmp, 0, target);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 17060,
                "title": "my-thoughts-and-solution-to-the-problem-java",
                "content": "Hello, I've solve the problem and I am here to give back to the community. Basically the question is pretty straight forward. I've approached the problem with sorting the array first, and keeping the current value and make recursive call to check for target - current value. Any suggestion on how I can make this code better is much appreciated. Thank you.\\n\\n    public class Solution {\\n        public List<List<Integer>> combinationSum2(int[] num, int target) {\\n            if(num.length==0) return new ArrayList<List<Integer>>();\\n            Arrays.sort(num); //sort the array of num so it's easier to manage\\n            List<List<Integer>> result = helper(num,target,0);\\n            if(result==null) return new ArrayList<List<Integer>>();\\n            return result;\\n        }\\n        public List<List<Integer>> helper(int[] num, int target, int index)\\n        {\\n            if(index>=num.length||num[index]>target) return null; //return null if you hit the end\\n            ArrayList<List<Integer>> result = new ArrayList<List<Integer>>();\\n            ArrayList<Integer> temp = new ArrayList<Integer>();\\n            Set<List<Integer>> s = new HashSet<List<Integer>>(); //check if there is no duplicates\\n            for(int i = index;i<num.length;i++)\\n            {\\n                 //if num[i]> target you dont need to check the rest. \\n                 //but it's break here because you still want to keep the rest of the result.\\n                if(num[i]>target) break; \\n                temp = new ArrayList<Integer>();\\n                //if it's found the rest of the numbers can be trimed, save some time on complexity\\n                if(num[i]==target) \\n                {\\n                    temp.add(num[i]);\\n                    result.add(temp);\\n                    return result;\\n                }\\n                ArrayList<List<Integer>> t = (ArrayList)helper(num,target-num[i],i+1);\\n                //t is the temporary ArrayList of the result of your recursion call\\n                // you want to add the value of your current num[i] in the beginning of each\\n                // returned List<Integer> and add it to result if it's not duplicated.\\n                if(t!=null)\\n                {\\n                    for(List<Integer> a:t)\\n                    {\\n                        a.add(0,num[i]);\\n                        if(!s.contains(a)) //make sure there is no duplicates\\n                        {\\n                            s.add(a);\\n                            result.add(a);\\n                        }\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum2(int[] num, int target) {\\n            if(num.length==0) return new ArrayList<List<Integer>>();\\n            Arrays.sort(num); //sort the array of num so it's easier to manage\\n            List<List<Integer>> result = helper(num,target,0);\\n            if(result==null) return new ArrayList<List<Integer>>();\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4029177,
                "title": "java-easy-100-backtracking-solution",
                "content": "```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        Arrays.sort(candidates);\\n\\n        this.backTrack(candidates, target, 0, new ArrayList<>(), result);\\n\\n        return result;\\n    }\\n\\n    private void backTrack(int[] candidates, int target, int start, List<Integer> curr, List<List<Integer>> result) {\\n        if(target == 0) {\\n            result.add(new ArrayList<>(curr));\\n            return;\\n        }\\n\\n        for(int i = start; i < candidates.length; ++i) {\\n            if(i > start && candidates[i] == candidates[i - 1])\\n                continue;\\n\\n            if(candidates[i] > target)\\n                break;\\n\\n            curr.add(candidates[i]);\\n            backTrack(candidates, target - candidates[i], i + 1, curr, result);\\n            curr.remove(curr.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        Arrays.sort(candidates);\\n\\n        this.backTrack(candidates, target, 0, new ArrayList<>(), result);\\n\\n        return result;\\n    }\\n\\n    private void backTrack(int[] candidates, int target, int start, List<Integer> curr, List<List<Integer>> result) {\\n        if(target == 0) {\\n            result.add(new ArrayList<>(curr));\\n            return;\\n        }\\n\\n        for(int i = start; i < candidates.length; ++i) {\\n            if(i > start && candidates[i] == candidates[i - 1])\\n                continue;\\n\\n            if(candidates[i] > target)\\n                break;\\n\\n            curr.add(candidates[i]);\\n            backTrack(candidates, target - candidates[i], i + 1, curr, result);\\n            curr.remove(curr.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998318,
                "title": "c-recursion-backtracking-two-approaches",
                "content": "# Approach 1: Extended Solution to [Combination Sum 1 ](https://leetcode.com/problems/combination-sum/discuss/3994292/C%2B%2B-or-Cpp-or-Cpp-Solution-or-Recursion-%2B-Backtracking) but will give TLE\\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& nums,int i, int target, vector<int> &comb, set<vector<int>> &result)\\n    { \\n        if(i>=nums.size())\\n        {\\n            if(target==0)\\n            {\\n                result.insert(comb);\\n            }\\n            return;\\n        }\\n\\n        comb.push_back(nums[i]); \\n        helper(nums,i+1,target-nums[i],comb,result); //pick up an element\\n        comb.pop_back();\\n\\t\\t\\n        helper(nums,i+1,target,comb,result); //non pick up an element\\n    }\\n\\t\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<int> comb;\\n        set<vector<int>> temp;\\n        vector<vector<int>> result;\\n        helper(candidates,0,target,comb,temp);\\n        for(auto x:temp)\\n        {\\n            result.push_back(x);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n\\n# Approach 2: Most Optimized Solution \\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& nums,int indx, int target,  vector<int> &comb, vector<vector<int>> &result)\\n    {\\n        if(target==0)\\n        {\\n            result.push_back(comb);\\n            return;\\n        }\\n        for(int i=indx;i<nums.size();i++)\\n        {\\n            if(i>indx && nums[i]==nums[i-1])\\n                continue;\\n            \\n            if(nums[i]>target)\\n                break;\\n            \\n            comb.push_back(nums[i]);\\n            helper(nums,i+1,target-nums[i],comb,result);\\n            comb.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<int> comb;\\n        vector<vector<int>> result;\\n        helper(candidates,0,target,comb,result);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& nums,int i, int target, vector<int> &comb, set<vector<int>> &result)\\n    { \\n        if(i>=nums.size())\\n        {\\n            if(target==0)\\n            {\\n                result.insert(comb);\\n            }\\n            return;\\n        }\\n\\n        comb.push_back(nums[i]); \\n        helper(nums,i+1,target-nums[i],comb,result); //pick up an element\\n        comb.pop_back();\\n\\t\\t\\n        helper(nums,i+1,target,comb,result); //non pick up an element\\n    }\\n\\t\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<int> comb;\\n        set<vector<int>> temp;\\n        vector<vector<int>> result;\\n        helper(candidates,0,target,comb,temp);\\n        for(auto x:temp)\\n        {\\n            result.push_back(x);\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& nums,int indx, int target,  vector<int> &comb, vector<vector<int>> &result)\\n    {\\n        if(target==0)\\n        {\\n            result.push_back(comb);\\n            return;\\n        }\\n        for(int i=indx;i<nums.size();i++)\\n        {\\n            if(i>indx && nums[i]==nums[i-1])\\n                continue;\\n            \\n            if(nums[i]>target)\\n                break;\\n            \\n            comb.push_back(nums[i]);\\n            helper(nums,i+1,target-nums[i],comb,result);\\n            comb.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<int> comb;\\n        vector<vector<int>> result;\\n        helper(candidates,0,target,comb,result);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966330,
                "title": "cpp-solution-easy-to-understand",
                "content": "# Intuition\\nThe problem requires finding all unique combinations of numbers from the \\'candidates\\' array that sum up to the \\'target\\' value. However, each number in the \\'candidates\\' array can only be used once in each combination. To solve this efficiently and avoid duplicates, we can use a depth-first search (DFS) algorithm. We will also sort the \\'candidates\\' array to group identical elements together.\\n\\n# Approach\\n1. Initialize an empty vector of vectors \\'res\\' to store the combinations.\\n2. Initialize an empty vector \\'curr\\' to store the current combination being constructed.\\n3. Sort the \\'candidates\\' vector to group identical elements together.\\n4. Call the DFS function \\'dfs\\' with the following parameters: \\'candidates\\', \\'0\\' as the starting index, \\'target\\', \\'0\\' as the initial sum, \\'curr\\', and \\'res\\'.\\n5. In the \\'dfs\\' function:\\n   a. Check if \\'sum\\' is equal to \\'target\\'. If they are equal, it means the current combination in \\'curr\\' is a valid combination that sums up to the \\'target\\'. Therefore, add \\'curr\\' to \\'res\\'.\\n   b. Check if \\'sum\\' is greater than \\'target\\'. If it is, return to avoid further exploration of this branch.\\n   c. Start a loop from the \\'start\\' index to the end of the \\'candidates\\' vector.\\n   d. Inside the loop:\\n      i. Check if \\'i\\' is greater than \\'start\\' and if the current element \\'candidates[i]\\' is the same as the previous element \\'candidates[i-1]\\'. If both conditions are true, skip the current iteration to avoid duplicate combinations.\\n      ii. Add the current element \\'candidates[i]\\' to \\'curr\\'.\\n      iii. Recursively call \\'dfs\\' with the updated \\'candidates\\', \\'i+1\\' as the new starting index to avoid reusing the same element, \\'target\\', \\'sum+candidates[i]\\' as the new sum, \\'curr\\', and \\'res\\'.\\n      iv. Remove the last element from \\'curr\\' to backtrack and explore other possibilities.\\n6. After the DFS is complete, \\'res\\' will contain all unique combinations.\\n7. Return \\'res\\' as the final result.\\n\\n# Complexity\\n- Time complexity: O(2^n * n), where \\'n\\' is the number of elements in \\'candidates\\'. In the worst case, there can be 2^n combinations to generate, and for each combination, we perform sorting with a maximum of \\'n\\' elements.\\n- Space complexity: O(2^n * n) for the \\'res\\' vector to store all combinations and O(n) for the \\'curr\\' vector. The overall space complexity is dominated by the \\'res\\' vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>>res;\\n        vector<int> curr;\\n        sort(candidates.begin(),candidates.end());\\n        dfs(candidates,0,target,0,curr,res);\\n        return res;\\n        \\n    }\\n    void dfs(vector<int> candidates, int start,int target,int sum, vector<int> &curr, vector<vector<int>> &res)\\n    {\\n        if(sum==target)\\n        {\\n            res.push_back(curr);\\n            return;\\n        }\\n        if(sum>target){\\n            return;\\n        }\\n        for(int i=start;i<candidates.size();i++)\\n        {\\n            if(i>start && candidates[i]==candidates[i-1])\\n            continue;\\n            curr.push_back(candidates[i]);\\n            dfs(candidates,i+1,target,sum+candidates[i],curr,res);\\n            curr.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>>res;\\n        vector<int> curr;\\n        sort(candidates.begin(),candidates.end());\\n        dfs(candidates,0,target,0,curr,res);\\n        return res;\\n        \\n    }\\n    void dfs(vector<int> candidates, int start,int target,int sum, vector<int> &curr, vector<vector<int>> &res)\\n    {\\n        if(sum==target)\\n        {\\n            res.push_back(curr);\\n            return;\\n        }\\n        if(sum>target){\\n            return;\\n        }\\n        for(int i=start;i<candidates.size();i++)\\n        {\\n            if(i>start && candidates[i]==candidates[i-1])\\n            continue;\\n            curr.push_back(candidates[i]);\\n            dfs(candidates,i+1,target,sum+candidates[i],curr,res);\\n            curr.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853451,
                "title": "easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The combinationSum2 method first sorts the candidates array in ascending order. Sorting helps in avoiding duplicates and optimizing the combination generation process.\\n\\n2. It initializes an empty vector ans to store the resulting combinations and an empty vector v to temporarily store a combination during the generation process.\\n\\n3. It calls the combinationSum_helper function with the sorted candidates array, the target value, the empty v vector, ans, and an initial index of 0.\\n\\n4. The combinationSum_helper function is a recursive function that generates combinations. It takes the current index, candidates, the remaining target, the temporary vector v, and the ans vector as parameters.\\n\\n5. In the combinationSum_helper function, the base cases are:\\n\\n   If target becomes 0, it means a valid combination is found. The current v vector is added to the ans vector.\\n   If target becomes negative, it means the current combination is not valid, so it returns.\\n\\n6. The function then iterates through the candidates array, starting from the given index. It avoids duplicates by checking if the current element is the same as the previous element and the current index is greater than the starting index. If this condition is met, the loop continues to the next iteration.\\n\\n7. For each valid candidate, it adds the candidate to the temporary vector v, subtracts the candidate from the remaining target, and makes a recursive call to combinationSum_helper with the updated parameters.\\n\\n8. After the recursive call returns, the last added candidate is removed from the temporary vector v (backtracking).\\n\\n9. The process continues until all combinations are generated.\\n\\n10. The sorted nature of the candidates array helps in avoiding duplicates and optimizing the combination generation process.\\n\\n11. The combinationSum2 method returns the ans vector containing all unique combinations.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void combinationSum_helper(vector<int>&candidates,int target,vector<int>&v,vector<vector<int>>&ans,int index){\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n    if(target<0){\\n        return;\\n    }\\n\\n    for(int i=index;i<candidates.size();i++){\\n        if(i>index && candidates[i]==candidates[i-1]){\\n            continue;\\n        }\\n        v.push_back(candidates[i]);\\n        combinationSum_helper(candidates,target-candidates[i],v,ans,i+1);\\n        v.pop_back();\\n    }\\n\\n\\n\\n\\n    }\\n\\n\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        combinationSum_helper(candidates,target,v, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void combinationSum_helper(vector<int>&candidates,int target,vector<int>&v,vector<vector<int>>&ans,int index){\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n    if(target<0){\\n        return;\\n    }\\n\\n    for(int i=index;i<candidates.size();i++){\\n        if(i>index && candidates[i]==candidates[i-1]){\\n            continue;\\n        }\\n        v.push_back(candidates[i]);\\n        combinationSum_helper(candidates,target-candidates[i],v,ans,i+1);\\n        v.pop_back();\\n    }\\n\\n\\n\\n\\n    }\\n\\n\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        combinationSum_helper(candidates,target,v, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851424,
                "title": "c-easy-killer-solution-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> refer combination sum solution and combination and subset for more clearity\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans={};\\n        vector<int> v;\\n        comb(0,nums,v,ans,target);\\n        return ans;\\n    }\\n    void comb(int start,vector<int>& nums,vector<int>& v,vector<vector<int>>&ans,int target)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n        for(int i=start;i<nums.size();i++)\\n        {\\n            if(i>start&&nums[i]==nums[i-1])continue;\\n            v.push_back(nums[i]);\\n            comb(i+1,nums,v,ans,target-nums[i]);\\n            v.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans={};\\n        vector<int> v;\\n        comb(0,nums,v,ans,target);\\n        return ans;\\n    }\\n    void comb(int start,vector<int>& nums,vector<int>& v,vector<vector<int>>&ans,int target)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n        for(int i=start;i<nums.size();i++)\\n        {\\n            if(i>start&&nums[i]==nums[i-1])continue;\\n            v.push_back(nums[i]);\\n            comb(i+1,nums,v,ans,target-nums[i]);\\n            v.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847301,
                "title": "python-99-53-faster-backtracking-easy",
                "content": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def solve(ind,target):\\n            if target==0:\\n                ans.append(op[:])\\n                return \\n            for i in range(ind,len(candidates)):\\n                if i>ind and candidates[i]==candidates[i-1]:\\n                    continue\\n                if candidates[i]>target:\\n                    break\\n                op.append(candidates[i])\\n                solve(i+1,target-candidates[i])\\n                op.pop()\\n        candidates.sort()\\n        ans=[]\\n        op=[]\\n        solve(0,target)\\n        return ans\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def solve(ind,target):\\n            if target==0:\\n                ans.append(op[:])\\n                return \\n            for i in range(ind,len(candidates)):\\n                if i>ind and candidates[i]==candidates[i-1]:\\n                    continue\\n                if candidates[i]>target:\\n                    break\\n                op.append(candidates[i])\\n                solve(i+1,target-candidates[i])\\n                op.pop()\\n        candidates.sort()\\n        ans=[]\\n        op=[]\\n        solve(0,target)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718563,
                "title": "c-super-easy-clean-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void solver(int i, int target, vector<int>& candi, vector<int>& res, vector<vector<int>>& ans){\\n        if(target == 0){\\n            ans.push_back(res);\\n            return;\\n        }\\n        if(i == candi.size()){\\n            return;\\n        }\\n\\n        if(candi[i] <= target){\\n            res.push_back(candi[i]);\\n            solver(i+1,target-candi[i],candi,res,ans);\\n            res.pop_back();\\n        }\\n\\n        while(i+1<candi.size() && candi[i] == candi[i+1]){\\n            i++;\\n        }\\n        // 1,1,1,2,2,3,4,5,6\\n        solver(i+1,target,candi,res,ans);\\n\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> res;\\n        solver(0,target,candidates,res,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solver(int i, int target, vector<int>& candi, vector<int>& res, vector<vector<int>>& ans){\\n        if(target == 0){\\n            ans.push_back(res);\\n            return;\\n        }\\n        if(i == candi.size()){\\n            return;\\n        }\\n\\n        if(candi[i] <= target){\\n            res.push_back(candi[i]);\\n            solver(i+1,target-candi[i],candi,res,ans);\\n            res.pop_back();\\n        }\\n\\n        while(i+1<candi.size() && candi[i] == candi[i+1]){\\n            i++;\\n        }\\n        // 1,1,1,2,2,3,4,5,6\\n        solver(i+1,target,candi,res,ans);\\n\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> res;\\n        solver(0,target,candidates,res,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473396,
                "title": "easy-java-solution-2ms-beats-99-69",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> finalList = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        helper(0, candidates, target,new ArrayList<Integer>(),finalList );\\n        return finalList;\\n    }\\n    public void helper(int index, int[] arr, int target, ArrayList<Integer> list, List<List<Integer>> finalList){\\n        \\n            if(target == 0){\\n                finalList.add(new ArrayList<>(list));\\n                return;\\n            }\\n            \\n        \\n        for(int i = index;i<arr.length;i++){\\n            if(i != index && arr[i] == arr[i-1]){\\n                continue;\\n            }\\n            if(arr[i] > target){break;}\\n            list.add(arr[i]);\\n            helper(i+1,arr,target-arr[i],list,finalList);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> finalList = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        helper(0, candidates, target,new ArrayList<Integer>(),finalList );\\n        return finalList;\\n    }\\n    public void helper(int index, int[] arr, int target, ArrayList<Integer> list, List<List<Integer>> finalList){\\n        \\n            if(target == 0){\\n                finalList.add(new ArrayList<>(list));\\n                return;\\n            }\\n            \\n        \\n        for(int i = index;i<arr.length;i++){\\n            if(i != index && arr[i] == arr[i-1]){\\n                continue;\\n            }\\n            if(arr[i] > target){break;}\\n            list.add(arr[i]);\\n            helper(i+1,arr,target-arr[i],list,finalList);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373591,
                "title": "pyhton3-backtrack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        res=[]\\n        currset=[]\\n        subset=[]\\n        def helper(i,candidates,currset,subset):\\n            if sum(currset)==target:\\n                subset.append(currset.copy())\\n                return \\n\\n            if(sum(currset)>target) or i>=len(candidates) :\\n                return\\n            currset.append(candidates[i])\\n            helper(i+1,candidates,currset,subset)\\n\\n            currset.pop()\\n\\n            while i+1<len(candidates) and candidates[i]==candidates[i+1]:\\n                i+=1\\n\\n            helper(i+1,candidates,currset,subset)\\n\\n        helper(0,candidates,currset,subset)\\n        return subset\\n\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        res=[]\\n        currset=[]\\n        subset=[]\\n        def helper(i,candidates,currset,subset):\\n            if sum(currset)==target:\\n                subset.append(currset.copy())\\n                return \\n\\n            if(sum(currset)>target) or i>=len(candidates) :\\n                return\\n            currset.append(candidates[i])\\n            helper(i+1,candidates,currset,subset)\\n\\n            currset.pop()\\n\\n            while i+1<len(candidates) and candidates[i]==candidates[i+1]:\\n                i+=1\\n\\n            helper(i+1,candidates,currset,subset)\\n\\n        helper(0,candidates,currset,subset)\\n        return subset\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346744,
                "title": "efficient-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo make combination we need to use the \"Pick\" and \"Not pick\" method\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe entire approach is same as Combination I.\\nBut, to ignore duplicate combination -->\\n- First we need to sort the given vector, so that all the duplicate elements of the given vector will be consecutively placed.\\n- Then, When we are about to \"Not pick\" an element we need to ignore all the similar consecutive elements. Which job is done by this block of code -->\\n```\\nwhile(i+1<c.size() && c[i]==c[i+1]){\\n            i++;\\n        }\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSame as Combination I\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSame as Combination I\\n\\nMy Combination I solution link \\uD83D\\uDC47\\nhttps://leetcode.com/problems/combination-sum/solutions/3344753/100-beats-easy-to-understand-c-code/\\n\\nPlease upvote if you find it helpful \\u2B06\\uFE0F\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void help(int i,int t,vector<int>& c,vector<int>&temp){\\n        if(t==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(t<0){\\n            return;\\n        }\\n        if(i==c.size()){\\n            return;\\n        }\\n        temp.push_back(c[i]);\\n        help(i+1,t-c[i],c,temp);\\n        temp.pop_back();\\n        while(i+1<c.size() && c[i]==c[i+1]){\\n            i++;\\n        }\\n        help(i+1,t,c,temp);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& c, int t) {\\n        vector<int>temp;\\n        sort(c.begin(),c.end());\\n        help(0,t,c,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nwhile(i+1<c.size() && c[i]==c[i+1]){\\n            i++;\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void help(int i,int t,vector<int>& c,vector<int>&temp){\\n        if(t==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(t<0){\\n            return;\\n        }\\n        if(i==c.size()){\\n            return;\\n        }\\n        temp.push_back(c[i]);\\n        help(i+1,t-c[i],c,temp);\\n        temp.pop_back();\\n        while(i+1<c.size() && c[i]==c[i+1]){\\n            i++;\\n        }\\n        help(i+1,t,c,temp);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& c, int t) {\\n        vector<int>temp;\\n        sort(c.begin(),c.end());\\n        help(0,t,c,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294871,
                "title": "recursion-java-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>>ans=new ArrayList<>();\\n        solve(0,target,candidates,ans,new ArrayList<>());\\n        return ans;\\n    }\\n    public void solve(int ind,int target,int[]candidates,List<List<Integer>>ans,ArrayList<Integer>temp){\\n        if(target==0){\\n            ans.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\n        for(int i=ind;i<candidates.length;i++){\\n            if(i!=ind && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i]>target) break;\\n\\n            temp.add(candidates[i]);\\n            solve(i+1,target-candidates[i],candidates,ans,temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>>ans=new ArrayList<>();\\n        solve(0,target,candidates,ans,new ArrayList<>());\\n        return ans;\\n    }\\n    public void solve(int ind,int target,int[]candidates,List<List<Integer>>ans,ArrayList<Integer>temp){\\n        if(target==0){\\n            ans.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\n        for(int i=ind;i<candidates.length;i++){\\n            if(i!=ind && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i]>target) break;\\n\\n            temp.add(candidates[i]);\\n            solve(i+1,target-candidates[i],candidates,ans,temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248311,
                "title": "java-simple-powerfull",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        combination2( 0,candidates, target, res, list);\\n        return res;\\n    }\\n    public void combination2(int index, int[] arr, int target, List<List<Integer>> res, List<Integer> list){\\n        if(target == 0){\\n            Collections.sort(list);\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i = index;i < arr.length;i++){\\n            if(i > index && arr[i] == arr[i - 1]) continue;\\n            if(target < arr[i]) break;\\n\\n            list.add(arr[i]);\\n            combination2(i + 1, arr, target - arr[i], res, list);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        combination2( 0,candidates, target, res, list);\\n        return res;\\n    }\\n    public void combination2(int index, int[] arr, int target, List<List<Integer>> res, List<Integer> list){\\n        if(target == 0){\\n            Collections.sort(list);\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i = index;i < arr.length;i++){\\n            if(i > index && arr[i] == arr[i - 1]) continue;\\n            if(target < arr[i]) break;\\n\\n            list.add(arr[i]);\\n            combination2(i + 1, arr, target - arr[i], res, list);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224015,
                "title": "optimized-solution-2ms-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:2n*k\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:k*x\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList());\\n        return ans;\\n    }\\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds) {\\n        if(target == 0) {\\n            ans.add(new ArrayList<>(ds)); \\n            return; \\n        }\\n        \\n        for(int i = ind; i < arr.length;i++) {\\n            if(i > ind && arr[i] == arr[i-1]) continue; \\n            if(arr[i]>target) break; \\n            \\n            ds.add(arr[i]); \\n            findCombinations(i+1, arr, target - arr[i], ans, ds); \\n            ds.remove(ds.size() - 1); \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList());\\n        return ans;\\n    }\\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds) {\\n        if(target == 0) {\\n            ans.add(new ArrayList<>(ds)); \\n            return; \\n        }\\n        \\n        for(int i = ind; i < arr.length;i++) {\\n            if(i > ind && arr[i] == arr[i-1]) continue; \\n            if(arr[i]>target) break; \\n            \\n            ds.add(arr[i]); \\n            findCombinations(i+1, arr, target - arr[i], ans, ds); \\n            ds.remove(ds.size() - 1); \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185178,
                "title": "python-backtracking-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()                      \\n        result = []\\n        def combine_sum_2(nums, start, path, result, target):\\n            if not target:\\n                result.append(path)\\n                return\\n            for i in range(start, len(nums)):\\n                if i > start and nums[i] == nums[i - 1]:\\n                    continue\\n                if nums[i] > target:\\n                    break\\n                combine_sum_2(nums, i + 1, path + [nums[i]], result, target - nums[i])\\n        combine_sum_2(candidates, 0, [], result, target)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()                      \\n        result = []\\n        def combine_sum_2(nums, start, path, result, target):\\n            if not target:\\n                result.append(path)\\n                return\\n            for i in range(start, len(nums)):\\n                if i > start and nums[i] == nums[i - 1]:\\n                    continue\\n                if nums[i] > target:\\n                    break\\n                combine_sum_2(nums, i + 1, path + [nums[i]], result, target - nums[i])\\n        combine_sum_2(candidates, 0, [], result, target)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182108,
                "title": "java-sol-2ms-beats-99-recursion",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> arr = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        func (candidates, arr, 0, target, new ArrayList<>());\\n        return arr;\\n    }\\n    void func (int[] candi, List<List<Integer>> arr, int idx, int target, List<Integer> temp) {\\n        if (target==0) {\\n            arr.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for (int i=idx; i<candi.length; i++) {\\n            if (i>idx && candi[i]==candi[i-1]) continue;\\n            if (candi[i]>target) break;\\n            temp.add(candi[i]);\\n            func (candi, arr, i+1, target-candi[i], temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> arr = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        func (candidates, arr, 0, target, new ArrayList<>());\\n        return arr;\\n    }\\n    void func (int[] candi, List<List<Integer>> arr, int idx, int target, List<Integer> temp) {\\n        if (target==0) {\\n            arr.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for (int i=idx; i<candi.length; i++) {\\n            if (i>idx && candi[i]==candi[i-1]) continue;\\n            if (candi[i]>target) break;\\n            temp.add(candi[i]);\\n            func (candi, arr, i+1, target-candi[i], temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177752,
                "title": "go-solution-recursive-dfs",
                "content": "#### Recursive DFS\\n\\n```go\\nimport (\\n    \"sort\"\\n)\\n\\nfunc combinationSum2(candidates []int, target int) [][]int {\\n    sort.Ints(candidates)\\n    combos := make([][]int, 0)\\n    \\n    var dfs func([]int, int, []int)\\n    dfs = func(nums []int, targ int, path []int) {\\n        if targ < 0 {\\n            return\\n        }\\n        if targ == 0 {\\n            combos = append(combos, path)\\n            return\\n        }\\n        \\n        for i, n := range nums {\\n            if i > 0 && nums[i] == nums[i-1] {\\n                continue\\n            }\\n            newPath := make([]int, len(path))\\n            copy(newPath, path)\\n            dfs(nums[i+1:], targ-n, append(newPath, n))\\n        }\\n        return\\n    }\\n    \\n    dfs(candidates, target, []int{})\\n    return combos\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```go\\nimport (\\n    \"sort\"\\n)\\n\\nfunc combinationSum2(candidates []int, target int) [][]int {\\n    sort.Ints(candidates)\\n    combos := make([][]int, 0)\\n    \\n    var dfs func([]int, int, []int)\\n    dfs = func(nums []int, targ int, path []int) {\\n        if targ < 0 {\\n            return\\n        }\\n        if targ == 0 {\\n            combos = append(combos, path)\\n            return\\n        }\\n        \\n        for i, n := range nums {\\n            if i > 0 && nums[i] == nums[i-1] {\\n                continue\\n            }\\n            newPath := make([]int, len(path))\\n            copy(newPath, path)\\n            dfs(nums[i+1:], targ-n, append(newPath, n))\\n        }\\n        return\\n    }\\n    \\n    dfs(candidates, target, []int{})\\n    return combos\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3158498,
                "title": "runtime-beats-97-33-combination-sum-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort the candidates list in ascending order.\\nDefine a backtracking function that takes in 3 parameters: start index, a list path to store each combination, and the target value.\\nIf the target value is 0, append the path list to the result res list.\\nLoop through the candidates list starting from the given start index.\\nIf the current index i is greater than start and the current candidate is the same as the previous candidate, continue to the next iteration.\\nIf the current candidate is greater than the target value, break the loop.\\nAdd the current candidate to the path list and call the backtracking function with i + 1 as the start index, the updated path list, and the target minus the current candidate.\\nReturn the result res list after the backtracking function is finished.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def backtrack(start, path, target):\\n            if target == 0:\\n                res.append(path)\\n                return\\n            for i in range(start, len(candidates)):\\n                if i > start and candidates[i] == candidates[i - 1]:\\n                    continue\\n                if candidates[i] > target:\\n                    break\\n                backtrack(i + 1, path + [candidates[i]], target - candidates[i])\\n\\n        candidates.sort()\\n        res = []\\n        backtrack(0, [], target)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def backtrack(start, path, target):\\n            if target == 0:\\n                res.append(path)\\n                return\\n            for i in range(start, len(candidates)):\\n                if i > start and candidates[i] == candidates[i - 1]:\\n                    continue\\n                if candidates[i] > target:\\n                    break\\n                backtrack(i + 1, path + [candidates[i]], target - candidates[i])\\n\\n        candidates.sort()\\n        res = []\\n        backtrack(0, [], target)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124204,
                "title": "2k-views-easy-to-understand-concise-and-precise-100-efficient-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void Ps(int ind,int target,vector<int> &v,vector<vector<int>> &ans , vector<int> &arr){\\n        if(target==0){\\n            ans.push_back(v);\\n            return ;\\n        }\\n        for(int i=ind;i<arr.size();i++){\\n            if(i>ind && arr[i]==arr[i-1]) continue;\\n            if(arr[i]>target) break;\\n            v.push_back(arr[i]);\\n            Ps(i+1,target-arr[i],v,ans,arr);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        Ps(0,target,v,ans,arr);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void Ps(int ind,int target,vector<int> &v,vector<vector<int>> &ans , vector<int> &arr){\\n        if(target==0){\\n            ans.push_back(v);\\n            return ;\\n        }\\n        for(int i=ind;i<arr.size();i++){\\n            if(i>ind && arr[i]==arr[i-1]) continue;\\n            if(arr[i]>target) break;\\n            v.push_back(arr[i]);\\n            Ps(i+1,target-arr[i],v,ans,arr);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        Ps(0,target,v,ans,arr);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105204,
                "title": "java-backtracking-explained",
                "content": "# Intuition\\n- Before starting the recursive call make sure to sort the elements because the ans should contain the combinations in sorted order and should not be repeated.\\n\\n- Initially, We start with the index 0, At index 0 we have n \\u2013 1 way to pick the first element of our subsequence.\\n\\n- Check if the current index value can be added to our ds. If yes add it to the ds and move the index by 1. while moving the index skip the consecutive repeated elements because they will form duplicate sequences.\\n\\n- Reduce the target by arr[i],call the recursive call for f(idx + 1,target \\u2013 1,ds,ans) after the call make sure to pop the element from the ds.\\n\\n- - if(arr[i] > target) then terminate the recursive call because there is no use to check as the array is sorted in the next recursive call the index will be moving by 1 all the elements to its right will be in increasing order.\\n\\n# Base Condition:\\n\\n- Whenever the target value is zero add the ds to the ans return.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(2^n*k)$$ \\n- - Assume if all the elements in the array are unique then the no. of subsequence you will get will be O(2^n). we also add the ds to our ans when we reach the base case that will take \\u201Ck\\u201D//average space for the ds.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans=new ArrayList<>();\\n        findCombiantions(0,candidates,target,ans,new ArrayList<>());\\n        return ans;\\n    }\\n    void findCombiantions(int ind, int[] nums, int target, List<List<Integer>> ans, ArrayList<Integer> ds) {\\n        if (target==0){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        for (int i = ind; i < nums.length ; i++) {\\n            if (i>ind && nums[i]==nums[i-1] ) continue;\\n            if (nums[i]>target) break;\\n            ds.add(nums[i]);\\n            findCombiantions(i+1,nums,target-nums[i],ans,ds);\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans=new ArrayList<>();\\n        findCombiantions(0,candidates,target,ans,new ArrayList<>());\\n        return ans;\\n    }\\n    void findCombiantions(int ind, int[] nums, int target, List<List<Integer>> ans, ArrayList<Integer> ds) {\\n        if (target==0){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        for (int i = ind; i < nums.length ; i++) {\\n            if (i>ind && nums[i]==nums[i-1] ) continue;\\n            if (nums[i]>target) break;\\n            ds.add(nums[i]);\\n            findCombiantions(i+1,nums,target-nums[i],ans,ds);\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100921,
                "title": "super-easily-understandable-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->https://www.youtube.com/watch?v=G1fRTGRxXU8&list=PLgUwDviBIf0rGlzIn_7rsaR2FQ5e6ZOL9&index=9\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void findcombination(int ind, int target,vector<int> &candidates,vector<vector<int>> &ans,vector<int> &ds){\\n        if(target==0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=ind;i<candidates.size();i++){\\n            if(i>ind && candidates[i]==candidates[i-1])continue;\\n            if(candidates[i]>target)break;\\n            ds.push_back(candidates[i]);\\n            findcombination(i+1,target-candidates[i],candidates,ans,ds);\\n            ds.pop_back();\\n        }\\n        \\n    }\\nvector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n    sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        findcombination(0,target,candidates,ans,ds);\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void findcombination(int ind, int target,vector<int> &candidates,vector<vector<int>> &ans,vector<int> &ds){\\n        if(target==0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=ind;i<candidates.size();i++){\\n            if(i>ind && candidates[i]==candidates[i-1])continue;\\n            if(candidates[i]>target)break;\\n            ds.push_back(candidates[i]);\\n            findcombination(i+1,target-candidates[i],candidates,ans,ds);\\n            ds.pop_back();\\n        }\\n        \\n    }\\nvector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n    sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        findcombination(0,target,candidates,ans,ds);\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088912,
                "title": "c-striver-approach-easy-explained",
                "content": "# Approach\\n- So Here Sort The Vector , Because We Are Having A Logic Of Not Using Extra Space\\n- Lets Deep Dive Into Our Recursive Code And I Will Explain It Line By Line\\n- So First Of All We Have Our Base Case , That Is If(target == 0) , we push the vector in our ans , which is vector<vector<int>> and we return\\n- After That As We Know The Question States We Need Lexicographical Answers Only , Means We Cannot Pick [1,2,1] , We Can Only Pick Answers Which Are Sorted In I.e [1,1,2] or [2,2]\\n- So Inorder To Avoid The Same Sequences We Keep A Check , That Is If We Are Picking The Element For First Time We Allow It , If The Same Number Comes Again , That Will Generate Same Answer\\n- So We Keep A Check By Using This  if(i > index && arr[i] == arr[i-1]) , If This Satisfies We Skip And Move To Next Index\\n- After That We Keep A Check If The arr[i] > Target that means we cannot have any combination , as after this all values will be high as we have the vector sorted\\n- After That We Add The ith Element In Our Temp Vector And We Again Call Recursion\\n- We Have To Also Do Backtracking For Removing The ith Element , So We Also Pop Back The Element\\n- Check Given Recursion Tree , And You Will Get What I am Trying To Explain\\n\\n# Recursion Tree \\n\\n```\\nInput: candidates = [1,1,1,2,2], target = 4\\nOutput: [[1,1,2],[2,2]]\\n```\\n\\n![WhatsApp Image 2023-01-23 at 11.28.03 AM.jpeg](https://assets.leetcode.com/users/images/42c631cb-fb47-4a1a-b6ba-1a7a98c486ae_1674453532.080475.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity:$$O(2^n * k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n * k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nvoid solve(int index,int target,vector<int> &arr,vector<vector<int>> &ans,vector<int> &ds)\\n{\\n    if(target == 0)\\n    {\\n        ans.push_back(ds);\\n        return;\\n    }\\n\\n    for(int i = index; i< arr.size();i++)\\n    {\\n       if(i > index && arr[i] == arr[i-1])\\n       continue;\\n\\n       if(arr[i] > target)\\n       break;\\n\\n       ds.push_back(arr[i]);\\n       solve(i+1,target-arr[i],arr,ans,ds);\\n       ds.pop_back();\\n    }\\n\\n    return;\\n}\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        solve(0,target,candidates,ans,ds);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nInput: candidates = [1,1,1,2,2], target = 4\\nOutput: [[1,1,2],[2,2]]\\n```\n```\\nclass Solution {\\nprivate:\\nvoid solve(int index,int target,vector<int> &arr,vector<vector<int>> &ans,vector<int> &ds)\\n{\\n    if(target == 0)\\n    {\\n        ans.push_back(ds);\\n        return;\\n    }\\n\\n    for(int i = index; i< arr.size();i++)\\n    {\\n       if(i > index && arr[i] == arr[i-1])\\n       continue;\\n\\n       if(arr[i] > target)\\n       break;\\n\\n       ds.push_back(arr[i]);\\n       solve(i+1,target-arr[i],arr,ans,ds);\\n       ds.pop_back();\\n    }\\n\\n    return;\\n}\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        solve(0,target,candidates,ans,ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074701,
                "title": "c-backtracking",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\u9700\\u8981\\u526A\\u679D\\uFF0C\\u5982\\u679C\\u4E00\\u4E2A\\u8282\\u70B9\\u6709\\u591A\\u6761\\u503C\\u76F8\\u540C\\u7684\\u6811\\u679D\\u76F8\\u90BB\\uFF0C\\u5219\\u53EA\\u904D\\u5386\\u7B2C\\u4E00\\u6761\\uFF0C\\u5269\\u4E0B\\u7684\\u90FD\\u526A\\u6389\\uFF0C\\u4E0D\\u8981\\u53BB\\u904D\\u5386.\\u4F53\\u73B0\\u5728\\u4EE3\\u7801\\u4E0A\\uFF0C\\u9700\\u8981\\u5148\\u8FDB\\u884C\\u6392\\u5E8F\\uFF0C\\u8BA9\\u76F8\\u540C\\u7684\\u5143\\u7D20\\u9760\\u5728\\u4E00\\u8D77\\uFF0C\\u5982\\u679C\\u53D1\\u73B0candidates[i] == candidates[i-1]\\uFF0C\\u5219\\u8DF3\\u8FC7.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    vector<int> path;\\n    int sum = 0;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        // if(candidates.size() == 0) return res;\\n        sort(candidates.begin(), candidates.end());\\n        backtrack(candidates, target, 0);\\n        return res;\\n    }\\n    void backtrack(vector<int>& candidates, int target, int u){\\n        if(sum == target){\\n            res.push_back(path);\\n            return;\\n        }\\n        if(sum > target) return;\\n        \\n        for(int i = u; i < candidates.size(); i ++){\\n            if(i > u && candidates[i] == candidates[i - 1]) continue;\\n            path.push_back(candidates[i]);\\n            sum += candidates[i];\\n            backtrack(candidates, target, i + 1);\\n            path.pop_back();\\n            sum -= candidates[i];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    vector<int> path;\\n    int sum = 0;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        // if(candidates.size() == 0) return res;\\n        sort(candidates.begin(), candidates.end());\\n        backtrack(candidates, target, 0);\\n        return res;\\n    }\\n    void backtrack(vector<int>& candidates, int target, int u){\\n        if(sum == target){\\n            res.push_back(path);\\n            return;\\n        }\\n        if(sum > target) return;\\n        \\n        for(int i = u; i < candidates.size(); i ++){\\n            if(i > u && candidates[i] == candidates[i - 1]) continue;\\n            path.push_back(candidates[i]);\\n            sum += candidates[i];\\n            backtrack(candidates, target, i + 1);\\n            path.pop_back();\\n            sum -= candidates[i];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040453,
                "title": "c-java-python-easiest-solution-detailed-explanation-code",
                "content": "\\n# Approach\\nThe code is a solution to the problem of finding all combinations of a given set of candidates that add up to a given target. The solution uses a recursive function Solve() that takes the candidates, target, current sum, an array to store the combinations, an array to store the current combination, and the current index being processed as input. The function checks if the current sum is equal to the target, if so it adds the current combination to the output. If the current sum is greater than the target, it returns.\\nIf the current index is equal to the size of the candidates, it returns.\\n\\nOne difference from the previous code is that it also skips any duplicates candidates by using a while loop after a recursive call using the current candidate. This will prevent the function from generating duplicate subsets.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O((2^n)*k)**, where 2^n is distribution of n elements, k is average length of every combination(mainly k for this -> ans.push_back(ds);)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(x)**, where x is length of longest combinations \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nClass Solution {\\npublic:\\n    void Solve(vector<int>& candidates, int target, int sum, vector<vector<int>>& output, vector<int>& ans, int index){\\n        if(target == sum){\\n            output.push_back(ans);\\n            return;\\n        }\\n        if(candidates.size() == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        ans.push_back(candidates[index]);\\n        Solve(candidates, target, sum + candidates[index], output, ans, index + 1);\\n        ans.pop_back();\\n        while(index < candidates.size()-1 && candidates[index] == candidates[index + 1])\\n            index++;\\n        Solve(candidates, target, sum, output, ans, index + 1);\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> ans;\\n        sort(candidates.begin(), candidates.end());\\n        Solve(candidates, target, 0, output, ans, 0);\\n        return output;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public void Solve(int[] candidates, int target, int sum, List<List<Integer>> output, List<Integer> ans, int index){\\n        if(target == sum){\\n            output.add(new ArrayList<>(ans));\\n            return;\\n        }\\n        if(candidates.length == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        ans.add(candidates[index]);\\n        Solve(candidates, target, sum + candidates[index], output, ans, index + 1);\\n        ans.remove(ans.size()-1);\\n        while(index < candidates.length-1 && candidates[index] == candidates[index + 1])\\n            index++;\\n        Solve(candidates, target, sum, output, ans, index + 1);\\n    }\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> output = new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        Solve(candidates, target, 0, output, ans, 0);\\n        return output;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def Solve(self, candidates, target, sum, output, ans, index):\\n        if target == sum:\\n            output.append(list(ans))\\n            return\\n        if len(candidates) == index:\\n            return\\n        if sum > target:\\n            return\\n        ans.append(candidates[index])\\n        self.Solve(candidates, target, sum + candidates[index], output, ans, index + 1)\\n        ans.pop()\\n        while index < len(candidates)-1 and candidates[index] == candidates[index + 1]:\\n            index += 1\\n        self.Solve(candidates, target, sum, output, ans, index + 1)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        output = []\\n        ans = []\\n        candidates.sort()\\n        self.Solve(candidates, target, 0, output, ans, 0)\\n        return output\\n\\n\\n```\\n**Note 0 : Also Recommend to see \"Combination Sum\" which is available in leetcode.** https://leetcode.com/problems/combination-sum/solutions/3027804/c-java-python-detailed-explanation-recursive-solution/\\n\\n**Note 1: Code for Java and Python might be wrong due to syntax error bcz Java and Python Solution is just the exact coversion of C++ code but logic is 100 % correct.**\\n\\n***Note 2: with the help of hashset we will get time limit exceeded error with this test case.**\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget = 30\\nclass Solution {\\npublic:\\n    void Solve(vector<int>& candidates, int target, int sum, set<vector<int>>& s, vector<int>& ans, int index){\\n        if(target == sum){\\n            s.insert(ans);\\n            return;\\n        }\\n        if(candidates.size() == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        if(sum + candidates[index] > target) \\n            return;\\n        ans.push_back(candidates[index]); \\n        Solve(candidates, target, sum + candidates[index], s, ans, index + 1);\\n        ans.pop_back();\\n        Solve(candidates, target, sum, s, ans, index + 1);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        vector<int> ans;\\n        sort(candidates.begin(), candidates.end());\\n        Solve(candidates, target, 0, s, ans, 0);\\n        for(auto vec : s)\\n            output.push_back(vec);\\n        return output;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```C++ []\\nClass Solution {\\npublic:\\n    void Solve(vector<int>& candidates, int target, int sum, vector<vector<int>>& output, vector<int>& ans, int index){\\n        if(target == sum){\\n            output.push_back(ans);\\n            return;\\n        }\\n        if(candidates.size() == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        ans.push_back(candidates[index]);\\n        Solve(candidates, target, sum + candidates[index], output, ans, index + 1);\\n        ans.pop_back();\\n        while(index < candidates.size()-1 && candidates[index] == candidates[index + 1])\\n            index++;\\n        Solve(candidates, target, sum, output, ans, index + 1);\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> ans;\\n        sort(candidates.begin(), candidates.end());\\n        Solve(candidates, target, 0, output, ans, 0);\\n        return output;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public void Solve(int[] candidates, int target, int sum, List<List<Integer>> output, List<Integer> ans, int index){\\n        if(target == sum){\\n            output.add(new ArrayList<>(ans));\\n            return;\\n        }\\n        if(candidates.length == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        ans.add(candidates[index]);\\n        Solve(candidates, target, sum + candidates[index], output, ans, index + 1);\\n        ans.remove(ans.size()-1);\\n        while(index < candidates.length-1 && candidates[index] == candidates[index + 1])\\n            index++;\\n        Solve(candidates, target, sum, output, ans, index + 1);\\n    }\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> output = new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        Solve(candidates, target, 0, output, ans, 0);\\n        return output;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def Solve(self, candidates, target, sum, output, ans, index):\\n        if target == sum:\\n            output.append(list(ans))\\n            return\\n        if len(candidates) == index:\\n            return\\n        if sum > target:\\n            return\\n        ans.append(candidates[index])\\n        self.Solve(candidates, target, sum + candidates[index], output, ans, index + 1)\\n        ans.pop()\\n        while index < len(candidates)-1 and candidates[index] == candidates[index + 1]:\\n            index += 1\\n        self.Solve(candidates, target, sum, output, ans, index + 1)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        output = []\\n        ans = []\\n        candidates.sort()\\n        self.Solve(candidates, target, 0, output, ans, 0)\\n        return output\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010879,
                "title": "backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n    }\\n\\n    void findCombination(int index, int target, vector<int>& candidates, vector<vector<int>>& ans, vector<int>& ds ){\\n\\n        if(target==0)\\n        {\\n            ans.push_back(ds);\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i]>target) break;\\n            ds.push_back(candidates[i]);\\n            findCombination(i+1,target-candidates[i],candidates,ans,ds);\\n            ds.pop_back();\\n\\n\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n    }\\n\\n    void findCombination(int index, int target, vector<int>& candidates, vector<vector<int>>& ans, vector<int>& ds ){\\n\\n        if(target==0)\\n        {\\n            ans.push_back(ds);\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i]>target) break;\\n            ds.push_back(candidates[i]);\\n            findCombination(i+1,target-candidates[i],candidates,ans,ds);\\n            ds.pop_back();\\n\\n\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860265,
                "title": "c-faster-than-100-concept-of-pick-subsequence",
                "content": "# Complexity\\n- Time complexity:\\nO(2^n)+k\\n\\n- Space complexity:\\nk*x (ignoring auxilary space used by recursion)\\n\\npls upvote if you like the solution.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvoid findCombination(int ind, int target, vector <int>& arr, vector<vector<int>>&ans,vector<int>&ds){\\n    if(target==0){\\n        ans.push_back(ds);\\n        return;\\n    }\\n    for(int i=ind; i<arr.size();i++){\\n        if(i>ind&& arr[i]==arr[i-1]) continue;\\n        if(arr[i]>target) break;\\n\\n        ds.push_back(arr[i]);\\n        findCombination(i+1, target-arr[i],arr, ans, ds);\\n        ds.pop_back();\\n    }\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector <int>ds;\\n        findCombination(0, target, candidates, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvoid findCombination(int ind, int target, vector <int>& arr, vector<vector<int>>&ans,vector<int>&ds){\\n    if(target==0){\\n        ans.push_back(ds);\\n        return;\\n    }\\n    for(int i=ind; i<arr.size();i++){\\n        if(i>ind&& arr[i]==arr[i-1]) continue;\\n        if(arr[i]>target) break;\\n\\n        ds.push_back(arr[i]);\\n        findCombination(i+1, target-arr[i],arr, ans, ds);\\n        ds.pop_back();\\n    }\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector <int>ds;\\n        findCombination(0, target, candidates, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1761591,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1569334,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1625415,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571097,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572732,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571098,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1782494,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1761589,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1825165,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1948051,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1761591,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1569334,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1625415,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571097,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572732,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571098,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1782494,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1761589,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1825165,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1948051,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1773550,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 1708453,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 1572711,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2052618,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2049804,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2046354,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2027816,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2027069,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2014335,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2011007,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2004828,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1997800,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1984747,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1957769,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1948099,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1937812,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1930902,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1925393,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1922337,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1818568,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1808121,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1806997,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1800119,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1788823,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1777795,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1775087,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1767902,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1752615,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1740987,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1735773,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            }
        ]
    },
    {
        "title": "Word Break II",
        "question_content": "<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p>\n\n<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsanddog&quot;, wordDict = [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]\n<strong>Output:</strong> [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;pineapplepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]\n<strong>Output:</strong> [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]\n<strong>Explanation:</strong> Note that you are allowed to reuse a dictionary word.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li>\n\t<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>\n\t<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>\n\t<li>Input is generated in a way that the length of the answer doesn&#39;t exceed&nbsp;10<sup>5</sup>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 44167,
                "title": "my-concise-java-solution-based-on-memorized-dfs",
                "content": "**Explanation**\\n\\nUsing DFS directly will lead to TLE, so I just used HashMap to save the previous results to prune duplicated branches, as the following:\\n \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        return DFS(s, wordDict, new HashMap<String, LinkedList<String>>());\\n    }       \\n    \\n    // DFS function returns an array including all substrings derived from s.\\n    List<String> DFS(String s, Set<String> wordDict, HashMap<String, LinkedList<String>>map) {\\n        if (map.containsKey(s)) \\n            return map.get(s);\\n            \\n        LinkedList<String>res = new LinkedList<String>();     \\n        if (s.length() == 0) {\\n            res.add(\"\");\\n            return res;\\n        }               \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                List<String>sublist = DFS(s.substring(word.length()), wordDict, map);\\n                for (String sub : sublist) \\n                    res.add(word + (sub.isEmpty() ? \"\" : \" \") + sub);               \\n            }\\n        }       \\n        map.put(s, res);\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nUsing DFS directly will lead to TLE, so I just used HashMap to save the previous results to prune duplicated branches, as the following:\\n \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        return DFS(s, wordDict, new HashMap<String, LinkedList<String>>());\\n    }       \\n    \\n    // DFS function returns an array including all substrings derived from s.\\n    List<String> DFS(String s, Set<String> wordDict, HashMap<String, LinkedList<String>>map) {\\n        if (map.containsKey(s)) \\n            return map.get(s);\\n            \\n        LinkedList<String>res = new LinkedList<String>();     \\n        if (s.length() == 0) {\\n            res.add(\"\");\\n            return res;\\n        }               \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                List<String>sublist = DFS(s.substring(word.length()), wordDict, map);\\n                for (String sub : sublist) \\n                    res.add(word + (sub.isEmpty() ? \"\" : \" \") + sub);               \\n            }\\n        }       \\n        map.put(s, res);\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44311,
                "title": "python-easy-to-understand-solution",
                "content": "    class Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.helper(s, wordDict, {})\\n        \\n    def helper(self, s, wordDict, memo):\\n        if s in memo: return memo[s]\\n        if not s: return []\\n        \\n        res = []\\n        for word in wordDict:\\n            if not s.startswith(word):\\n                continue\\n            if len(word) == len(s):\\n                res.append(word)\\n            else:\\n                resultOfTheRest = self.helper(s[len(word):], wordDict, memo)\\n                for item in resultOfTheRest:\\n                    item = word + ' ' + item\\n                    res.append(item)\\n        memo[s] = res\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.helper(s, wordDict, {}",
                "codeTag": "Java"
            },
            {
                "id": 2996989,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void solve(string s, vector<string>& res, unordered_set<string>& st, vector<string>&temp){\\n        if(s.length() == 0){\\n            string str = \"\";\\n            for(auto it:temp){\\n                str += it + \" \";\\n            }\\n            str.pop_back();\\n            res.push_back(str);\\n            return;\\n        }\\n        for(int i=0;i<s.length(); i++){\\n            if(st.count(s.substr(0, i+1))){\\n                temp.push_back(s.substr(0, i+1));\\n                solve(s.substr(i+1), res, st, temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string>res, temp;\\n        unordered_set<string>st(wordDict.begin(), wordDict.end());\\n        \\n        solve(s, res, st, temp);\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```\\n\\n```Java []\\nclass Solution {\\n    private void helper(String s, int i, Set<String> dict, List<String> cur, List<String> res) {\\n        if (i == s.length()) {\\n            if (cur.size() > 0) {\\n                StringBuilder sb = new StringBuilder();\\n                for (int j = 0; j < cur.size(); j++) {\\n                    if (j > 0) {\\n                        sb.append(\\' \\');\\n                    }\\n                    sb.append(cur.get(j));\\n                }\\n                res.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\n        for (int j = i+1; j <= s.length(); j++) {\\n            if (dict.contains(s.substring(i, j))) {\\n                cur.add(s.substring(i, j));\\n                helper(s, j, dict, cur, res);\\n                cur.remove(cur.size() - 1);\\n            }\\n        }\\n    }\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Set<String> dict = new HashSet<>(wordDict);\\n        List<String> res = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        helper(s, 0, dict, cur, res);\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void solve(string s, vector<string>& res, unordered_set<string>& st, vector<string>&temp){\\n        if(s.length() == 0){\\n            string str = \"\";\\n            for(auto it:temp){\\n                str += it + \" \";\\n            }\\n            str.pop_back();\\n            res.push_back(str);\\n            return;\\n        }\\n        for(int i=0;i<s.length(); i++){\\n            if(st.count(s.substr(0, i+1))){\\n                temp.push_back(s.substr(0, i+1));\\n                solve(s.substr(i+1), res, st, temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string>res, temp;\\n        unordered_set<string>st(wordDict.begin(), wordDict.end());\\n        \\n        solve(s, res, st, temp);\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```\n```Java []\\nclass Solution {\\n    private void helper(String s, int i, Set<String> dict, List<String> cur, List<String> res) {\\n        if (i == s.length()) {\\n            if (cur.size() > 0) {\\n                StringBuilder sb = new StringBuilder();\\n                for (int j = 0; j < cur.size(); j++) {\\n                    if (j > 0) {\\n                        sb.append(\\' \\');\\n                    }\\n                    sb.append(cur.get(j));\\n                }\\n                res.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\n        for (int j = i+1; j <= s.length(); j++) {\\n            if (dict.contains(s.substring(i, j))) {\\n                cur.add(s.substring(i, j));\\n                helper(s, j, dict, cur, res);\\n                cur.remove(cur.size() - 1);\\n            }\\n        }\\n    }\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Set<String> dict = new HashSet<>(wordDict);\\n        List<String> res = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        helper(s, 0, dict, cur, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44178,
                "title": "11ms-c-solution-concise",
                "content": "    class Solution {\\n        unordered_map<string, vector<string>> m;\\n    \\n        vector<string> combine(string word, vector<string> prev){\\n            for(int i=0;i<prev.size();++i){\\n                prev[i]+=\" \"+word;\\n            }\\n            return prev;\\n        }\\n    \\n    public:\\n        vector<string> wordBreak(string s, unordered_set<string>& dict) {\\n            if(m.count(s)) return m[s]; //take from memory\\n            vector<string> result;\\n            if(dict.count(s)){ //a whole string is a word\\n                result.push_back(s);\\n            }\\n            for(int i=1;i<s.size();++i){\\n                string word=s.substr(i);\\n                if(dict.count(word)){\\n                    string rem=s.substr(0,i);\\n                    vector<string> prev=combine(word,wordBreak(rem,dict));\\n                    result.insert(result.end(),prev.begin(), prev.end());\\n                }\\n            }\\n            m[s]=result; //memorize\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        unordered_map<string, vector<string>> m;\\n    \\n        vector<string> combine(string word, vector<string> prev){\\n            for(int i=0;i<prev.size();++i){\\n                prev[i]+=\" \"+word;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 44169,
                "title": "9-lines-python-10-lines-c",
                "content": "`sentences(i)` returns a list of all sentences that can be built from the suffix `s[i:]`.\\n\\n**Python:**\\n\\n    def wordBreak(self, s, wordDict):\\n        memo = {len(s): ['']}\\n        def sentences(i):\\n            if i not in memo:\\n                memo[i] = [s[i:j] + (tail and ' ' + tail)\\n                           for j in range(i+1, len(s)+1)\\n                           if s[i:j] in wordDict\\n                           for tail in sentences(j)]\\n            return memo[i]\\n        return sentences(0)\\n\\n**C++:**\\n\\n    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n        unordered_map<int, vector<string>> memo {{s.size(), {\"\"}}};\\n        function<vector<string>(int)> sentences = [&](int i) {\\n            if (!memo.count(i))\\n                for (int j=i+1; j<=s.size(); j++)\\n                    if (wordDict.count(s.substr(i, j-i)))\\n                        for (string tail : sentences(j))\\n                            memo[i].push_back(s.substr(i, j-i) + (tail==\"\" ? \"\" : ' ' + tail));\\n            return memo[i];\\n        };\\n        return sentences(0);\\n    }",
                "solutionTags": [
                    "Python"
                ],
                "code": "`sentences(i)` returns a list of all sentences that can be built from the suffix `s[i:]`.\\n\\n**Python:**\\n\\n    def wordBreak(self, s, wordDict):\\n        memo = {len(s): ['']}\\n        def sentences(i):\\n            if i not in memo:\\n                memo[i] = [s[i:j] + (tail and ' ' + tail)\\n                           for j in range(i+1, len(s)+1)\\n                           if s[i:j] in wordDict\\n                           for tail in sentences(j)]\\n            return memo[i]\\n        return sentences(0)\\n\\n**C++:**\\n\\n    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n        unordered_map<int, vector<string>> memo {{s.size(), {\"\"}}};\\n        function<vector<string>(int)> sentences = [&](int i) {\\n            if (!memo.count(i))\\n                for (int j=i+1; j<=s.size(); j++)\\n                    if (wordDict.count(s.substr(i, j-i)))\\n                        for (string tail : sentences(j))\\n                            memo[i].push_back(s.substr(i, j-i) + (tail==\"\" ? \"\" : ' ' + tail));\\n            return memo[i];\\n        };\\n        return sentences(0);\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 1241504,
                "title": "c-0ms-solution-commented-fully",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        //insert all the words in the set\\n        unordered_set<string> set;\\n        vector<string> res;\\n        for(auto word:wordDict)\\n            set.insert(word);\\n        //to store the current string \\n        string curr=\"\";\\n        findHelper(0,s,curr,set,res);\\n        return res;\\n    }\\n    \\n    void findHelper(int ind,string s,string curr,unordered_set<string> set,vector<string>& res)\\n    {\\n        if(ind==s.length())\\n        {\\n            //we have reached end\\n            curr.pop_back(); //remove the trailing space\\n            res.push_back(curr);\\n        }\\n        string str=\"\";\\n        for(int i=ind;i<s.length();i++)\\n        {\\n            //get every substring and check if it exists in set\\n            str.push_back(s[i]);\\n            if(set.count(str))\\n            {\\n                //we have got a word in dict \\n                //explore more and get other substrings\\n                findHelper(i+1,s,curr+str+\" \",set,res);\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Please upvote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        //insert all the words in the set\\n        unordered_set<string> set;\\n        vector<string> res;\\n        for(auto word:wordDict)\\n            set.insert(word);\\n        //to store the current string \\n        string curr=\"\";\\n        findHelper(0,s,curr,set,res);\\n        return res;\\n    }\\n    \\n    void findHelper(int ind,string s,string curr,unordered_set<string> set,vector<string>& res)\\n    {\\n        if(ind==s.length())\\n        {\\n            //we have reached end\\n            curr.pop_back(); //remove the trailing space\\n            res.push_back(curr);\\n        }\\n        string str=\"\";\\n        for(int i=ind;i<s.length();i++)\\n        {\\n            //get every substring and check if it exists in set\\n            str.push_back(s[i]);\\n            if(set.count(str))\\n            {\\n                //we have got a word in dict \\n                //explore more and get other substrings\\n                findHelper(i+1,s,curr+str+\" \",set,res);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44243,
                "title": "java-dp-dfs-memoization-dfs-and-dp-pruning-solutions-with-analysis",
                "content": "I've been struggling with this problem for a long time, and I'd love to share three different strategies I have tried to solve it. All of them are ACed. \\n\\nMethod 1: DP + DFS. Very similar to Word Break I, but instead of using a boolean dp array, I used an array of Lists to maintain all of the valid start positions for every end position. Then just do classic backtracking to find all solutions. The time complexity is O(n*m) + O(n * number of solutions), where n is the length of the input string, m is the length of the longest word in the dictionary. The run time was 6ms. It is very efficient because DP is used to find out all the valid answers, and no time is wasted on doing the backtracking. \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        List<Integer>[] starts = new List[s.length() + 1]; // valid start positions\\n        starts[0] = new ArrayList<Integer>();\\n        \\n        int maxLen = getMaxLen(wordDict);\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = i - 1; j >= i - maxLen && j >= 0; j--) {\\n                if (starts[j] == null) continue;\\n                String word = s.substring(j, i);\\n                if (wordDict.contains(word)) {\\n                    if (starts[i] == null) {\\n                        starts[i] = new ArrayList<Integer>();\\n                    }\\n                    starts[i].add(j);\\n                }\\n            }\\n        }\\n        \\n        List<String> rst = new ArrayList<>();\\n        if (starts[s.length()] == null) {\\n            return rst;\\n        }\\n        \\n        dfs(rst, \"\", s, starts, s.length());\\n        return rst;\\n    }\\n\\n  \\n    private void dfs(List<String> rst, String path, String s, List<Integer>[] starts, int end) {\\n        if (end == 0) {\\n            rst.add(path.substring(1));\\n            return;\\n        }\\n        \\n        for (Integer start: starts[end]) {\\n            String word = s.substring(start, end);\\n            dfs(rst, \" \" + word + path, s, starts, start);\\n        }\\n    }\\n\\n    private int getMaxLen(Set<String> wordDict) {\\n        int max = 0;\\n        for (String s : wordDict) {\\n            max = Math.max(max, s.length());\\n        }\\n        return max;\\n    }\\n\\n\\nMethod 2: Memoization + Backtracking. Before I came up with Method 1, I also tried using a HashMap to memoize all the possible strings that can be formed starting from index i. I referred to this post from [@Pixel_][1] \\nThe time complexity is O(len(wordDict) ^ len(s / minWordLenInDict)) as @Pixel_ mentioned. The space complexity would be larger than other methods though. Here is my code: \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        HashMap<Integer, List<String>> memo = new HashMap<>(); // <Starting index, rst list>\\n        return dfs(s, 0, wordDict, memo);\\n    }\\n    \\n    private List<String> dfs(String s, int start, Set<String> dict, HashMap<Integer, List<String>> memo) {\\n        if (memo.containsKey(start)) {\\n            return memo.get(start);\\n        }\\n        \\n        List<String> rst = new ArrayList<>();\\n        if (start == s.length()) {\\n            rst.add(\"\");\\n            return rst;\\n        }\\n        \\n        String curr = s.substring(start);\\n        for (String word: dict) {\\n            if (curr.startsWith(word)) {\\n                List<String> sublist = dfs(s, start + word.length(), dict, memo);\\n                for (String sub : sublist) {\\n                    rst.add(word + (sub.isEmpty() ? \"\" : \" \") + sub);\\n                }\\n            }\\n        }\\n        \\n        memo.put(start, rst);\\n        return rst;\\n    }\\n\\nMethod 3: DP Prunning + Backtracking. My very first solution is like this: using a boolean array to memoize whether a substring starting from position i to the end is breakable. This works well for worst cases like: s = \"aaaaaaaaaaaab\", dict = [\"a\", \"aa\", \"aaa\", \"aaaa\"]. However, for cases like: s = \"aaaaaaaaaaaaa\", dict = [\"a\", \"aa\", \"aaa\", \"aaaa\"], the time complexity is still O(2^n). Here is the code: \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        List<String> rst = new ArrayList<>();\\n        if (s == null || s.length() == 0 || wordDict == null) {\\n            return rst;\\n        }\\n        \\n        boolean[] canBreak = new boolean[s.length()];\\n        Arrays.fill(canBreak, true);\\n        StringBuilder sb = new StringBuilder();\\n        dfs(rst, sb, s, wordDict, canBreak, 0);\\n        return rst;\\n    }\\n    \\n    private void dfs(List<String> rst, StringBuilder sb, String s, Set<String> dict, \\n        boolean[] canBreak, int start) {\\n        if (start == s.length()) {\\n            rst.add(sb.substring(1));\\n            return;\\n        }\\n        \\n        if (!canBreak[start]) {\\n            return;\\n        }\\n        \\n        for (int i = start + 1; i <= s.length(); i++) {\\n            String word = s.substring(start, i);\\n            if (!dict.contains(word)) continue;\\n            \\n            int sbBeforeAdd = sb.length();\\n            sb.append(\" \" + word);\\n            \\n            int rstBeforeDFS = rst.size();\\n            dfs(rst, sb, s, dict, canBreak, i);\\n            if (rst.size() == rstBeforeDFS) {\\n                canBreak[i] = false;\\n            }\\n            sb.delete(sbBeforeAdd, sb.length());\\n        }\\n    }\\n    \\n    private int getMaxLen(Set<String> wordDict) {\\n        int max = 0;\\n        for (String s : wordDict) {\\n            max = Math.max(max, s.length());\\n        }\\n        return max;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/65692/my-concise-java-solution-based-on-memorized-dfs",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "I've been struggling with this problem for a long time, and I'd love to share three different strategies I have tried to solve it. All of them are ACed. \\n\\nMethod 1: DP + DFS. Very similar to Word Break I, but instead of using a boolean dp array, I used an array of Lists to maintain all of the valid start positions for every end position. Then just do classic backtracking to find all solutions. The time complexity is O(n*m) + O(n * number of solutions), where n is the length of the input string, m is the length of the longest word in the dictionary. The run time was 6ms. It is very efficient because DP is used to find out all the valid answers, and no time is wasted on doing the backtracking. \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        List<Integer>[] starts = new List[s.length() + 1]; // valid start positions\\n        starts[0] = new ArrayList<Integer>();\\n        \\n        int maxLen = getMaxLen(wordDict);\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = i - 1; j >= i - maxLen && j >= 0; j--) {\\n                if (starts[j] == null) continue;\\n                String word = s.substring(j, i);\\n                if (wordDict.contains(word)) {\\n                    if (starts[i] == null) {\\n                        starts[i] = new ArrayList<Integer>();\\n                    }\\n                    starts[i].add(j);\\n                }\\n            }\\n        }\\n        \\n        List<String> rst = new ArrayList<>();\\n        if (starts[s.length()] == null) {\\n            return rst;\\n        }\\n        \\n        dfs(rst, \"\", s, starts, s.length());\\n        return rst;\\n    }\\n\\n  \\n    private void dfs(List<String> rst, String path, String s, List<Integer>[] starts, int end) {\\n        if (end == 0) {\\n            rst.add(path.substring(1));\\n            return;\\n        }\\n        \\n        for (Integer start: starts[end]) {\\n            String word = s.substring(start, end);\\n            dfs(rst, \" \" + word + path, s, starts, start);\\n        }\\n    }\\n\\n    private int getMaxLen(Set<String> wordDict) {\\n        int max = 0;\\n        for (String s : wordDict) {\\n            max = Math.max(max, s.length());\\n        }\\n        return max;\\n    }\\n\\n\\nMethod 2: Memoization + Backtracking. Before I came up with Method 1, I also tried using a HashMap to memoize all the possible strings that can be formed starting from index i. I referred to this post from [@Pixel_][1] \\nThe time complexity is O(len(wordDict) ^ len(s / minWordLenInDict)) as @Pixel_ mentioned. The space complexity would be larger than other methods though. Here is my code: \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        HashMap<Integer, List<String>> memo = new HashMap<>(); // <Starting index, rst list>\\n        return dfs(s, 0, wordDict, memo);\\n    }\\n    \\n    private List<String> dfs(String s, int start, Set<String> dict, HashMap<Integer, List<String>> memo) {\\n        if (memo.containsKey(start)) {\\n            return memo.get(start);\\n        }\\n        \\n        List<String> rst = new ArrayList<>();\\n        if (start == s.length()) {\\n            rst.add(\"\");\\n            return rst;\\n        }\\n        \\n        String curr = s.substring(start);\\n        for (String word: dict) {\\n            if (curr.startsWith(word)) {\\n                List<String> sublist = dfs(s, start + word.length(), dict, memo);\\n                for (String sub : sublist) {\\n                    rst.add(word + (sub.isEmpty() ? \"\" : \" \") + sub);\\n                }\\n            }\\n        }\\n        \\n        memo.put(start, rst);\\n        return rst;\\n    }\\n\\nMethod 3: DP Prunning + Backtracking. My very first solution is like this: using a boolean array to memoize whether a substring starting from position i to the end is breakable. This works well for worst cases like: s = \"aaaaaaaaaaaab\", dict = [\"a\", \"aa\", \"aaa\", \"aaaa\"]. However, for cases like: s = \"aaaaaaaaaaaaa\", dict = [\"a\", \"aa\", \"aaa\", \"aaaa\"], the time complexity is still O(2^n). Here is the code: \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        List<String> rst = new ArrayList<>();\\n        if (s == null || s.length() == 0 || wordDict == null) {\\n            return rst;\\n        }\\n        \\n        boolean[] canBreak = new boolean[s.length()];\\n        Arrays.fill(canBreak, true);\\n        StringBuilder sb = new StringBuilder();\\n        dfs(rst, sb, s, wordDict, canBreak, 0);\\n        return rst;\\n    }\\n    \\n    private void dfs(List<String> rst, StringBuilder sb, String s, Set<String> dict, \\n        boolean[] canBreak, int start) {\\n        if (start == s.length()) {\\n            rst.add(sb.substring(1));\\n            return;\\n        }\\n        \\n        if (!canBreak[start]) {\\n            return;\\n        }\\n        \\n        for (int i = start + 1; i <= s.length(); i++) {\\n            String word = s.substring(start, i);\\n            if (!dict.contains(word)) continue;\\n            \\n            int sbBeforeAdd = sb.length();\\n            sb.append(\" \" + word);\\n            \\n            int rstBeforeDFS = rst.size();\\n            dfs(rst, sb, s, dict, canBreak, i);\\n            if (rst.size() == rstBeforeDFS) {\\n                canBreak[i] = false;\\n            }\\n            sb.delete(sbBeforeAdd, sb.length());\\n        }\\n    }\\n    \\n    private int getMaxLen(Set<String> wordDict) {\\n        int max = 0;\\n        for (String s : wordDict) {\\n            max = Math.max(max, s.length());\\n        }\\n        return max;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/65692/my-concise-java-solution-based-on-memorized-dfs",
                "codeTag": "Java"
            },
            {
                "id": 44368,
                "title": "python-easy-to-understand-solutions-memorization-dfs-dp-dfs",
                "content": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        return self.dfs(s, set(wordDict), {})\\n    \\n    def dfs(self, s, d, m):\\n        if s in m: # memorize\\n            return m[s]\\n        if not s:\\n            return [\"\"]\\n        res = []\\n        for i in range(1, len(s)+1):\\n            if s[:i] in d:\\n                for word in self.dfs(s[i:], d, m):\\n                    res.append(s[:i] + (\" \" if word else \"\") + word)\\n        m[s] = res\\n        return res\\n    \\n    def wordBreak1(self, s, wordDict):\\n        res = []\\n        self.dfs(s, set(wordDict), \"\", res)\\n        return res\\n    \\n    def dfs1(self, s, dic, path, res):\\n        if self.check(s, dic):\\n            if not s:\\n                res.append(path[1:])\\n            for i in range(1, len(s)+1):\\n                if s[:i] in d:\\n                    self.dfs(s[i:], dic, path+\" \"+s[:i], res)\\n                \\n    def check(self, s, dic):\\n        dp = [False] * (1+len(s))\\n        dp[0] = True\\n        for j in range(1, len(s)+1):\\n            for i in range(j):\\n                if dp[i] and s[i:j] in dic:\\n                    dp[j] = True\\n                    break\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        return self.dfs(s, set(wordDict), {})\\n    \\n    def dfs(self, s, d, m):\\n        if s in m: # memorize\\n            return m[s]\\n        if not s:\\n            return [\"\"]\\n        res = []\\n        for i in range(1, len(s)+1):\\n            if s[:i] in d:\\n                for word in self.dfs(s[i:], d, m):\\n                    res.append(s[:i] + (\" \" if word else \"\") + word)\\n        m[s] = res\\n        return res\\n    \\n    def wordBreak1(self, s, wordDict):\\n        res = []\\n        self.dfs(s, set(wordDict), \"\", res)\\n        return res\\n    \\n    def dfs1(self, s, dic, path, res):\\n        if self.check(s, dic):\\n            if not s:\\n                res.append(path[1:])\\n            for i in range(1, len(s)+1):\\n                if s[:i] in d:\\n                    self.dfs(s[i:], dic, path+\" \"+s[:i], res)\\n                \\n    def check(self, s, dic):\\n        dp = [False] * (1+len(s))\\n        dp[0] = True\\n        for j in range(1, len(s)+1):\\n            for i in range(j):\\n                if dp[i] and s[i:j] in dic:\\n                    dp[j] = True\\n                    break\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44179,
                "title": "slightly-modified-dp-java-solution",
                "content": "Hi guys!\\n\\nThere's a lot of concern in other posts about \"aaaa...aab\" test case that causes TLE when we run through our string not in reverse but from start to end. I've thought a bit on how to add a tiny modification and make just the whole thing more effective, not only pass the TLE case. \\n\\nThe approach is the same as before: we loop through all possible prefixes checking if it in the dictionary and caching the results. \\n\\nBut just before jumping into recursion we could also check that the right reminder has a prefix from the dictionary, because if it hasn't then there's no sense in splitting the reminder into sub-strings. It's just a linear check, which I think also could be optimized with some caching but even without optimization the solution is accepted. And also the code looks quite understandable.\\n\\n    public class Solution {\\n\\n        private final Map<String, List<String>> cache = new HashMap<>();\\n    \\n        private boolean containsSuffix(Set<String> dict, String str) {\\n            for (int i = 0; i < str.length(); i++) {\\n                if (dict.contains(str.substring(i))) return true;\\n            }\\n            return false;\\n        }\\n    \\n        public List<String> wordBreak(String s, Set<String> dict) {\\n            if (cache.containsKey(s)) return cache.get(s);\\n            List<String> result = new LinkedList<>();\\n            if (dict.contains(s)) result.add(s);\\n            for (int i = 1; i < s.length(); i++) {\\n                String left = s.substring(0,i), right = s.substring(i);\\n                if (dict.contains(left) && containsSuffix(dict, right)) {\\n                    for (String ss : wordBreak(right, dict)) {\\n                        result.add(left + \" \" + ss);\\n                    }\\n                }\\n            }\\n            cache.put(s, result);\\n            return result;\\n        }\\n    }\\n\\nHope it helps!",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n        private final Map<String, List<String>> cache = new HashMap<>();\\n    \\n        private boolean containsSuffix(Set<String> dict, String str) {\\n            for (int i = 0; i < str.length(); i++) {\\n                if (dict.contains(str.substring(i))) return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 763221,
                "title": "python-dp-solution-explained",
                "content": "First of all, this problem is extention of problem 139. Word Break, where we need just to check if word can be broken into other words. Here we need to give all possible splits. Let us first put all words into `set` and create two lists:\\n\\n1. `dp_solution[i]` is all possible splits for first `i` symbols of `s`\\n2. `dp[i]` is indicator if we can split word or not.\\n\\nAlso we create this two lists with size `(n+1)` to handle border cases, in `dp[-1]` we will keep result for empty string `\"\"`.\\n\\n1. First step is to check if our string can be splitted at all, using problem 139. We need to do it, to candle strings like `aaaaa...aaab`, with `wordDict = [a, aa, aaa, ..., aa..aa]`. In this case answer will be `no`, but if we try to build solution directly we will get MLE. Try to remove this lines of code from solution and you will see.\\n2. Now, we do one more pass over data and start to build solutions: if we found that `s[j: k + 1] in wordSet`, then for every already built solution `sol in dp_solution[j-1]` we can add it to `dp_solution[k]`. \\n3. Finally, we have some extraspaces in the beginning of each solution, and instead of last element `[-1]` we need to return previous `[-2]`, so we return return `[s[1:] for s in dp_solution[-2]]`\\n\\n**Complexity**: to create `dp` we need `O(n^2m)` time, where `m` is average length of word and `O(n^2)` space. However for `dp_solution` part we can have potentially exponential number of solutions, for example even for `s = aa.....aa`, `wordDict = [a, aa]`. I think leetcode just will not give you tests, where memory will exceed some limit.\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n        wordSet = set(wordDict)\\n        n = len(s)\\n        dp_solution = [[] for _ in range(n)] + [[\"\"]]\\n        dp = [0] * n + [1]\\n        \\n        for k in range(n):\\n            for j in range(k,-1,-1):\\n                if s[j: k + 1] in wordSet:\\n                    dp[k] = max(dp[k], dp[j-1])\\n\\n        if dp[-2] == 0: return []\\n\\n        for k in range(n):\\n            for j in range(k,-1,-1):\\n                if s[j: k + 1] in wordSet:\\n                    for sol in dp_solution[j-1]:\\n                        dp_solution[k].append(sol + \" \" + s[j: k + 1])\\n                        \\n        return [s[1:] for s in dp_solution[-2]]\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n        wordSet = set(wordDict)\\n        n = len(s)\\n        dp_solution = [[] for _ in range(n)] + [[\"\"]]\\n        dp = [0] * n + [1]\\n        \\n        for k in range(n):\\n            for j in range(k,-1,-1):\\n                if s[j: k + 1] in wordSet:\\n                    dp[k] = max(dp[k], dp[j-1])\\n\\n        if dp[-2] == 0: return []\\n\\n        for k in range(n):\\n            for j in range(k,-1,-1):\\n                if s[j: k + 1] in wordSet:\\n                    for sol in dp_solution[j-1]:\\n                        dp_solution[k].append(sol + \" \" + s[j: k + 1])\\n                        \\n        return [s[1:] for s in dp_solution[-2]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44255,
                "title": "my-concise-answer",
                "content": "    public class Solution {\\n    public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> result = new ArrayList<String>();\\n        for(int j = s.length() - 1; j >= 0; j--){\\n            if(dict.contains(s.substring(j)))\\n                break;\\n            else{\\n                if(j == 0)\\n                    return result;\\n            }\\n        }\\n        for(int i = 0; i < s.length()-1; i++)\\n        {\\n            if(dict.contains(s.substring(0,i+1)))\\n            {\\n                List<String> strs = wordBreak(s.substring(i+1,s.length()),dict);\\n                if(strs.size() != 0)\\n                    for(Iterator<String> it = strs.iterator();it.hasNext();)\\n                    {\\n                        result.add(s.substring(0,i+1)+\" \"+it.next());\\n                    }\\n            }\\n        }\\n        if(dict.contains(s)) result.add(s);\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> result = new ArrayList<String>();\\n        for(int j = s.length() - 1; j >= 0; j--){\\n            if(dict.contains(s.substring(j)))\\n                break;\\n            else{\\n                if(j == 0)\\n                    return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 194615,
                "title": "dp-solution-with-detailed-text-and-video-explanation",
                "content": "## LeetCode 140. Word Break II\\n### Note\\nIf you prefer video over text, please check out this link: https://www.youtube.com/watch?v=xun6zHlX8kI\\nwhich has the same content as follows.\\n### Explanation\\n```cpp\\nExample 1:\\ns = \"catsanddog\"\\nwordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\\n\\n// The basic idea for solving this problem is\\nThe result of a string can be generated from the results of its substrings.\\n\\n// Like, for string \"catsanddog\" (S) and one of its substrings \"catsand\" (T).\\n// Suppose we\\'ve known T can be broken into [\"cat\", \"sand\"] or [\"cats\", \"and\"],\\n// and \"catsanddog\"(S) = \"catsand\"(T) + \"dog\".\\n// We only need to check if \"dog\" is in the wordDict, which is true in this case.\\n// Let dp(S) denote the result of S.\\ndp(T) = \\n[\"cat\", \"sand\"], \\n[\"apple\", \"pen\"]\\n\\ndp(S) <= dp(T) + \"apple\" = \\n[\"cat\", \"sand\", \"apple\"], \\n[\"cats\", \"and\", \"apple\"] \\n\\n// Thus, we can have\\n>> state: Let dp[i] denote all valid breaks for s(0, i)\\nE.g. in the above case,\\ns(0, 6) = \"catsand\"\\ndp[6] = [\"cat\", \"sand\"], [\"cats\", \"and\"]\\n\\n// The way we solve this problem is like this:\\nwordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\\nindex:    0   1   2   3   4   5   6   7   8   9\\n        +---------------------------------------+\\ns:      | c | a | t | s | a | n | d | d | o | g |\\n        +---------------------------------------+\\n          i   \\n          j\\n\\ndp[0] = []\\ndp[1] = []\\ndp[2] = [\"cat\"]\\ndp[3] = [\"cats\"]\\ndp[4] = []\\ndp[5] = []\\ndp[6] = [\"cat sand\",\"cats and\"]\\ndp[7] = []\\ndp[8] = []\\ndp[9] = [\"cat sand dog\",\"cats and dog\"]\\n\\n>> recurrence relation:\\ndp[i] = \\nfor (int j = 0; j < i; j++) {\\n\\tsubstr = s[j, i];\\n  if (dp[j].size() > 0 && wordDict.contains(substr)) {\\n      for (String l : dp[j]) {\\n          dp[i].add(l + substr);\\n      }\\n  }\\n}\\n```\\n### Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int N = s.size();\\n        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());\\n        \\n        vector<vector<string>> dp(N + 1, vector<string>());\\n        dp[0].emplace_back(\"\");\\n        for(int i = 1; i <= N; ++i){\\n            for(int j = 0; j < i; ++j){\\n                string substr = s.substr(j, i - j);\\n                if(dp[j].size() > 0 && wordSet.find(substr) != wordSet.end()){\\n                    for(string& l : dp[j]){\\n                        dp[i].emplace_back(l + (l == \"\" ? \"\" : \" \") + substr);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[N];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nExample 1:\\ns = \"catsanddog\"\\nwordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\\n\\n// The basic idea for solving this problem is\\nThe result of a string can be generated from the results of its substrings.\\n\\n// Like, for string \"catsanddog\" (S) and one of its substrings \"catsand\" (T).\\n// Suppose we\\'ve known T can be broken into [\"cat\", \"sand\"] or [\"cats\", \"and\"],\\n// and \"catsanddog\"(S) = \"catsand\"(T) + \"dog\".\\n// We only need to check if \"dog\" is in the wordDict, which is true in this case.\\n// Let dp(S) denote the result of S.\\ndp(T) = \\n[\"cat\", \"sand\"], \\n[\"apple\", \"pen\"]\\n\\ndp(S) <= dp(T) + \"apple\" = \\n[\"cat\", \"sand\", \"apple\"], \\n[\"cats\", \"and\", \"apple\"] \\n\\n// Thus, we can have\\n>> state: Let dp[i] denote all valid breaks for s(0, i)\\nE.g. in the above case,\\ns(0, 6) = \"catsand\"\\ndp[6] = [\"cat\", \"sand\"], [\"cats\", \"and\"]\\n\\n// The way we solve this problem is like this:\\nwordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\\nindex:    0   1   2   3   4   5   6   7   8   9\\n        +---------------------------------------+\\ns:      | c | a | t | s | a | n | d | d | o | g |\\n        +---------------------------------------+\\n          i   \\n          j\\n\\ndp[0] = []\\ndp[1] = []\\ndp[2] = [\"cat\"]\\ndp[3] = [\"cats\"]\\ndp[4] = []\\ndp[5] = []\\ndp[6] = [\"cat sand\",\"cats and\"]\\ndp[7] = []\\ndp[8] = []\\ndp[9] = [\"cat sand dog\",\"cats and dog\"]\\n\\n>> recurrence relation:\\ndp[i] = \\nfor (int j = 0; j < i; j++) {\\n\\tsubstr = s[j, i];\\n  if (dp[j].size() > 0 && wordDict.contains(substr)) {\\n      for (String l : dp[j]) {\\n          dp[i].add(l + substr);\\n      }\\n  }\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int N = s.size();\\n        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());\\n        \\n        vector<vector<string>> dp(N + 1, vector<string>());\\n        dp[0].emplace_back(\"\");\\n        for(int i = 1; i <= N; ++i){\\n            for(int j = 0; j < i; ++j){\\n                string substr = s.substr(j, i - j);\\n                if(dp[j].size() > 0 && wordSet.find(substr) != wordSet.end()){\\n                    for(string& l : dp[j]){\\n                        dp[i].emplace_back(l + (l == \"\" ? \"\" : \" \") + substr);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[N];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507365,
                "title": "c-short-fast-dfs-hash-map-for-dp-speed-95-mem-94",
                "content": "```\\nclass Solution {\\n    public:\\n        vector<string> wordBreak(string s, vector<string>& wordDict) \\n        {\\n            int max_len = 0;\\n            unordered_set<string> dict;\\n            for(string& str : wordDict)\\n            {\\n                dict.insert(str);\\n                max_len = max(max_len, (int)str.length());\\n            }\\n\\n            unordered_map<int, vector<string>> mp;\\n            return break_word(s, 0, dict, max_len, mp);\\n        }\\n\\n    protected:\\n        vector<string> break_word(  const string& s, int n, unordered_set<string>& dict, \\n                                    int max_len, unordered_map<int, vector<string>>& mp)\\n        {\\n            if(mp.count(n)) return mp[n];\\n\\n            string str;\\n            for(int i = n; i < s.length() && str.length() <= max_len; ++i)\\n            {\\n                str += s[i];\\n                if(dict.count(str))\\n                {\\n                    if(i == s.length()-1)\\n                        mp[n].push_back(str);\\n                    else\\n                    {\\n                        vector<string> vs = break_word(s, i+1, dict, max_len, mp);\\n                        for(auto& a : vs) mp[n].push_back(str + \" \" + a);\\n                    }\\n                }\\n            }\\n            return mp[n];\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n        vector<string> wordBreak(string s, vector<string>& wordDict) \\n        {\\n            int max_len = 0;\\n            unordered_set<string> dict;\\n            for(string& str : wordDict)\\n            {\\n                dict.insert(str);\\n                max_len = max(max_len, (int)str.length());\\n            }\\n\\n            unordered_map<int, vector<string>> mp;\\n            return break_word(s, 0, dict, max_len, mp);\\n        }\\n\\n    protected:\\n        vector<string> break_word(  const string& s, int n, unordered_set<string>& dict, \\n                                    int max_len, unordered_map<int, vector<string>>& mp)\\n        {\\n            if(mp.count(n)) return mp[n];\\n\\n            string str;\\n            for(int i = n; i < s.length() && str.length() <= max_len; ++i)\\n            {\\n                str += s[i];\\n                if(dict.count(str))\\n                {\\n                    if(i == s.length()-1)\\n                        mp[n].push_back(str);\\n                    else\\n                    {\\n                        vector<string> vs = break_word(s, i+1, dict, max_len, mp);\\n                        for(auto& a : vs) mp[n].push_back(str + \" \" + a);\\n                    }\\n                }\\n            }\\n            return mp[n];\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764120,
                "title": "easy-to-understand-trie-solution-beats-100",
                "content": "**Intuition:**\\n* We need a DS to handle characters in a way that we can search for a particular word easily. (My choice was Trie).\\n* We should find all combinations of words in the given string s. (Hence I decided to solve it using dynamic programming/ recursion)\\n\\n**Explanation**\\n* If you are new to TRIE data structure, please go through [this problem.](https://leetcode.com/problems/implement-trie-prefix-tree/). We are going to implement a variant of the TRIE data structure.\\n* We only have to implement the `add` function of the Trie DS as we will be searching for the combinations of words using dp technique.\\n* This solution will involve two steps of preprocessing to reduce the time complexity.\\n\\t* First step is to form a TRIE with the given dictionary.\\n\\t* Second step is to check if all the letters in the string `s` are present in the dictionary. We will be using an int array `exists` which will be set to `1` whenever a letter is added to our TRIE. So, if there is any letter whose corresponding `exists` value is not `1`, then there is no way to form a combination with the given words, so we return an empty list.\\n* Now, how do we find the result?\\n* I have used DP technique to accomplish that. I have added comments wherever required in the below code so that you guys understand better.\\n* PS: I found the search method i implemented in this similar to this[question](https://leetcode.com/problems/all-paths-from-source-to-target/description/\\n\\n*Please upvote if you found this post useful and do post your questions down below if you have any.\\nCheers!*\\n\\n**Code**\\n```\\nclass Solution {\\n\\n    int[] exists;\\n    Trie root;\\n    \\n    public void search(List<String> ans, Trie curr, StringBuilder temp, char[] given, int index){\\n        if(index==given.length){\\n            return;\\n        } \\n        if(curr.children[given[index]-\\'a\\'] == null)return;\\n        \\n        Trie next = curr.children[given[index] - \\'a\\'];\\n        temp.append(given[index]);\\n        \\n        //If the word is present in the dictionary, we can either add a space or we continue going down in the trie\\n        if(next.isWord){\\n            //If we have reached the end of the string, add the value to Answer and terminate\\n            if(index+1 == given.length){\\n                ans.add(temp.toString());\\n                temp.deleteCharAt(temp.length()-1); \\n                return;\\n                }\\n            else{\\n                //We are adding space\\n                temp.append(\" \");\\n                //Since after adding space, the next letter should be the beginning of a new word from the dictionary, we pass in the ROOT trie node\\n                search(ans, root, temp, given, index+1);\\n                //remove the space we added in the above line.\\n                temp.deleteCharAt(temp.length()-1);      \\n            }\\n        }\\n        \\n        //since we have not added a space, we are technically going down in the same trie block. So we are moving the NEXT node in the CURR trie node.\\n        search(ans, next, temp, given, index+1);\\n            \\n        //Deleting the added character\\n        temp.deleteCharAt(temp.length()-1);            \\n\\n    }\\n    \\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        root = new Trie();\\n        exists = new int[26];\\n        List<String> ans = new ArrayList();\\n        for(String word : wordDict){\\n            root.addWord(word);\\n        }\\n        \\n        for(char c : s.toCharArray()){\\n            if(exists[c-\\'a\\']!=1)\\n                return new ArrayList();\\n        }\\n        search(ans, root, new StringBuilder(), s.toCharArray(), 0);\\n        return ans;\\n    }\\n\\n    \\n    class Trie{\\n        boolean isWord;\\n        Trie[] children;\\n        Trie(){\\n            isWord=false;\\n            children = new Trie[26];\\n        }\\n        public void addWord(String w){\\n            Trie curr = this;\\n            int index = 0;\\n            char[] word = w.toCharArray();\\n            while(index<word.length){   \\n                exists[word[index]-\\'a\\']=1;\\n                if(curr.children[word[index]-\\'a\\'] == null){\\n                    curr.children[word[index]-\\'a\\'] = new Trie();\\n                }  \\n                curr = curr.children[word[index]-\\'a\\'];\\n                index++;\\n            }\\n            curr.isWord = true;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[] exists;\\n    Trie root;\\n    \\n    public void search(List<String> ans, Trie curr, StringBuilder temp, char[] given, int index){\\n        if(index==given.length){\\n            return;\\n        } \\n        if(curr.children[given[index]-\\'a\\'] == null)return;\\n        \\n        Trie next = curr.children[given[index] - \\'a\\'];\\n        temp.append(given[index]);\\n        \\n        //If the word is present in the dictionary, we can either add a space or we continue going down in the trie\\n        if(next.isWord){\\n            //If we have reached the end of the string, add the value to Answer and terminate\\n            if(index+1 == given.length){\\n                ans.add(temp.toString());\\n                temp.deleteCharAt(temp.length()-1); \\n                return;\\n                }\\n            else{\\n                //We are adding space\\n                temp.append(\" \");\\n                //Since after adding space, the next letter should be the beginning of a new word from the dictionary, we pass in the ROOT trie node\\n                search(ans, root, temp, given, index+1);\\n                //remove the space we added in the above line.\\n                temp.deleteCharAt(temp.length()-1);      \\n            }\\n        }\\n        \\n        //since we have not added a space, we are technically going down in the same trie block. So we are moving the NEXT node in the CURR trie node.\\n        search(ans, next, temp, given, index+1);\\n            \\n        //Deleting the added character\\n        temp.deleteCharAt(temp.length()-1);            \\n\\n    }\\n    \\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        root = new Trie();\\n        exists = new int[26];\\n        List<String> ans = new ArrayList();\\n        for(String word : wordDict){\\n            root.addWord(word);\\n        }\\n        \\n        for(char c : s.toCharArray()){\\n            if(exists[c-\\'a\\']!=1)\\n                return new ArrayList();\\n        }\\n        search(ans, root, new StringBuilder(), s.toCharArray(), 0);\\n        return ans;\\n    }\\n\\n    \\n    class Trie{\\n        boolean isWord;\\n        Trie[] children;\\n        Trie(){\\n            isWord=false;\\n            children = new Trie[26];\\n        }\\n        public void addWord(String w){\\n            Trie curr = this;\\n            int index = 0;\\n            char[] word = w.toCharArray();\\n            while(index<word.length){   \\n                exists[word[index]-\\'a\\']=1;\\n                if(curr.children[word[index]-\\'a\\'] == null){\\n                    curr.children[word[index]-\\'a\\'] = new Trie();\\n                }  \\n                curr = curr.children[word[index]-\\'a\\'];\\n                index++;\\n            }\\n            curr.isWord = true;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44299,
                "title": "java-6ms-simple-solution-beating-88",
                "content": "    public class Solution {\\n        HashMap<Integer, List<String>> dp = new HashMap<>();\\n\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            int maxLength = -1;\\n            for(String ss : wordDict) maxLength = Math.max(maxLength, ss.length());\\n            return addSpaces(s, wordDict, 0, maxLength);\\n        }\\n        \\n        private List<String> addSpaces(String s, Set<String> wordDict, int start, int max){\\n            List<String> words = new ArrayList<>();\\n            if(start == s.length()) {\\n                words.add(\"\");\\n                return words;\\n            }\\n            for(int i = start + 1; i <= max + start && i <= s.length(); i++){\\n                String temp = s.substring(start, i);\\n                if(wordDict.contains(temp)){\\n                    List<String> ll;\\n                    if(dp.containsKey(i)) ll = dp.get(i);\\n                    else ll = addSpaces(s, wordDict, i, max);\\n                    for(String ss : ll) words.add(temp + (ss.equals(\"\") ? \"\" : \" \") + ss);\\n                }\\n                \\n            }\\n            dp.put(start, words);\\n            return words;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        HashMap<Integer, List<String>> dp = new HashMap<>();\\n\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            int maxLength = -1;\\n            for(String ss : wordDict) maxLength = Math.max(maxLength, ss.length());\\n            return addSpaces(s, wordDict, 0, maxLength);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 44262,
                "title": "my-c-dp-dfs-solution-4ms",
                "content": "The basic idea is to use DP to create an array isBreakable[i] to indicate whether s[i..sSize-1] is breakable. Then we can use such information to help us speed up the DFS path build process (buildPath). Learned from other posts, I first calculated minlen and maxlen to speed up the process.\\n  \\n\\n    class Solution {\\n    private: //DFS path build function\\n        void buildPath(bool isBreakable[], string &s, int pos, vector<string> &res, string curP, unordered_set<string>& wordDict, int minlen, int maxlen)\\n        {\\n            int i, len = s.size();\\n            for(i =minlen; i<= min(maxlen, len - pos); ++i)\\n                if( isBreakable[pos+i] && wordDict.count(s.substr(pos,i)) ) \\n                    if(pos+i == len) res.push_back(curP + s.substr(pos,i));\\n                    else buildPath(isBreakable, s, pos+i, res, curP + s.substr(pos,i) + \" \", wordDict, minlen, maxlen);\\n        }\\n        \\n    public:\\n        vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n            int sSize = s.size(), len, i, minlen = INT_MAX, maxlen = INT_MIN;\\n            vector<string> res;\\n            bool isBreakable[sSize+1];\\n            fill_n(isBreakable, sSize+1, false);\\n                \\n            for (string word : wordDict) { // find the minimum and maximum word length \\n                minlen = min(minlen, (int)word.length());\\n                maxlen = max(maxlen, (int)word.length()); \\n            }        \\n            //DP to build isBreakable\\n            for(i=sSize-minlen, isBreakable[sSize]= true; i>=0; --i)\\n                for(len=minlen; len<=min(maxlen, sSize-i); ++len)\\n                {\\n                    if(isBreakable[i+len] && wordDict.count(s.substr(i,len)) ) {isBreakable[i] = true; break;}\\n                }\\n            //if breakable, do DFS path building\\n            if(isBreakable[0]) buildPath(isBreakable, s, 0, res, \"\", wordDict, minlen, maxlen);\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private: //DFS path build function\\n        void buildPath(bool isBreakable[], string &s, int pos, vector<string> &res, string curP, unordered_set<string>& wordDict, int minlen, int maxlen)\\n        {\\n            int i, len = s.size();\\n            for(i =minlen; i<= min(maxlen, len - pos); ++i)\\n                if( isBreakable[pos+i] && wordDict.count(s.substr(pos,i)) ) \\n                    if(pos+i == len) res.push_back(curP + s.substr(pos,i));\\n                    else buildPath(isBreakable, s, pos+i, res, curP + s.substr(pos,i) + \" \", wordDict, minlen, maxlen);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 44264,
                "title": "java-dfs-dp-clean-solution",
                "content": "The basic backtracking idea is straightforward, find a possible break point and then recursively call the suffix of the original string.  The trick is that we use a map to keep the previous result which will terminate the recursion early to make sure we don't get TLE.\\n\\n\\n    public class Solution {\\n        public List<String> wordBreak(String s, Set<String> dict) {\\n            return dfs(s, dict, new HashMap<>());\\n        }\\n    \\n        public List<String> dfs(String s, Set<String> dict, Map<String, List<String>> memo){\\n            if(memo.containsKey(s)) {\\n                return memo.get(s);\\n            }\\n            List<String> res = new ArrayList<>();\\n            if(s == null || s.length() == 0) {\\n                return res;\\n            }\\n            int n = s.length();\\n            \\n            for(String w : dict) {\\n                if(!s.startsWith(w)) {\\n                    continue;\\n                }\\n                int end = w.length();\\n                if(end == n) {\\n                    res.add(w);\\n                } else {\\n                    List<String> sublist = dfs(s.substring(end), dict, memo);\\n                    for(String item : sublist) {\\n                        item = w + \" \" + item;\\n                        res.add(item);\\n                    }\\n                }\\n            }\\n            \\n            memo.put(s, res);\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n        public List<String> wordBreak(String s, Set<String> dict) {\\n            return dfs(s, dict, new HashMap<>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1175903,
                "title": "c-backtracking-simple-code",
                "content": "```\\nvector<string> sentences;\\nvector<string> wordBreak(string s, vector<string>& wordDict)\\n{\\n    unordered_set<string> setting;\\n    setting.insert(wordDict.begin(), wordDict.end());\\n    dfs(s, \"\", setting);\\n    return sentences;\\n}\\n\\nvoid dfs(string s, string sentence, unordered_set<string>& setting)\\n{\\n    if(s.empty())\\n    {\\n        sentence.pop_back();\\n        sentences.push_back(sentence);\\n        return;\\n    }\\n    int n = s.size();\\n    for(int i = 1; i <= n; i++)\\n    {\\n        if(!setting.count(s.substr(0, i)))\\n            continue;\\n        dfs(s.substr(i), sentence + s.substr(0, i) + \" \", setting);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvector<string> sentences;\\nvector<string> wordBreak(string s, vector<string>& wordDict)\\n{\\n    unordered_set<string> setting;\\n    setting.insert(wordDict.begin(), wordDict.end());\\n    dfs(s, \"\", setting);\\n    return sentences;\\n}\\n\\nvoid dfs(string s, string sentence, unordered_set<string>& setting)\\n{\\n    if(s.empty())\\n    {\\n        sentence.pop_back();\\n        sentences.push_back(sentence);\\n        return;\\n    }\\n    int n = s.size();\\n    for(int i = 1; i <= n; i++)\\n    {\\n        if(!setting.count(s.substr(0, i)))\\n            continue;\\n        dfs(s.substr(i), sentence + s.substr(0, i) + \" \", setting);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 978368,
                "title": "backtracking-memo-explanation-3-visuals-python",
                "content": "***TL;DR (Visuals  + Explanation below code snippet)*** This code follows the standard [backtracking template](https://leetcode.com/problems/subsets/discuss/973667/backtracking-template-explanation-visual-python). We keep track of indexes that cannot lead to valid solution and make sure we do not visit them. We do this by keeping a memo (memoization)\\n\\n\\n```python\\n def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res = []\\n        self.backtrack(0, len(s), [], res, s, wordDict, set()) \\n        return res\\n    \\n    def backtrack(self, start, end, sentence, result, string, wordDict, bad):\\n        # seen this prefix before, path did not lead to valid answer\\n        if start in bad: \\n            return  \\n        \\n        if start == end:\\n            result.append(\\' \\'.join(sentence))\\n            return\\n        \\n        before = len(result)\\n        for w in wordDict:\\n            if string[start:].startswith(w):\\n                sentence.append(w)\\n                self.backtrack(start + len(w), end, sentence, result, string, wordDict, bad)\\n                sentence.pop()\\n                \\n        after = len(result)\\n        # no result has been added bad path. \\n\\t\\t# the this index will never lead to a feasible solution\\n        if before == after: bad.add(start)\\n\\n```\\n### Explanation\\nThe goal of this problem is to return all possible sentences that meet the constraints of the problem. We need to be exaushtive (collect all possibilities). This is an indication the problem can be solved with backtracking. \\n\\nthe constraints for this problem as follows \\n1. we must construct words for our sentence from string ```s``` by adding spaces \\n2. every word in the sentence must be valid dictionary word \\n\\nsince we can construct sentences by adding spaces, all the characters in our original string ```s``` must be used. \\n\\nif we manage to use all characters we have found a solution.\\n\\nwe can mimick inserting spaces by looking at prefixes of substrings. \\n```python\\n\\ts[start:].startswith(w)\\n```\\n\\n### Optimization\\nfor some examples there are many combinations that fail to produce a solution.  this can lead to an enormous amount of unecessary recursive calls, wreaking havoc on the time complexity. \\n\\n***the key observation for optimization*** is that if a prefix starting from index ```start```does not lead to a feasible solution, any time that same index is visited again it will also will fail to lead to feasible solution. \\n\\n* The initial examples could have been better selected as they do not show the need for memoization and it is not immediately obvious.\\n\\n* to help the reader fully understand the code above and the reason why memoization must be used for an efficient solution 3 visuals have been included below \\n\\n### Visual Example 1\\nregardless of whether memiozation is used our not, this example performs the same.\\nwhen ```try ``` is used, it is to denote each word that is being looped through, the last word denotes the selected word. in the below examole ```applepen``` is the selected word. \\n```try: apple,  pen, applepen```\\n\\n![image](https://assets.leetcode.com/users/images/b9138d01-ef38-4e50-bf97-7c34dc6f5e36_1608427761.2446313.png)\\n\\n\\n### Visual Example 2 \\n\\nan example where memiozation is not used. nodes of the same color are repeating indexes. note this problem no sentences are generated. no path leads to a feasible solution. \\n![image](https://assets.leetcode.com/users/images/4eb795eb-faf2-428a-88e2-9bc6194749f3_1608427409.9636602.png)\\n\\n\\n\\n### Visual Example 3 \\n\\nThe same as example 2. This time memoization is used. indexes that lead to unfeasible solutions are cached. if index is in cache, no need to explore any further. the red ```X``` on a node in the recursion tree symbolizes that a index has been found in the cache. all nodes below a red ```X``` node in this diagram actually dont exist. no recursive call was made for these nodes. included them for a more complete visual\\n\\n\\n![image](https://assets.leetcode.com/users/images/6f21790a-74d1-4f5f-a567-0bd3898ed267_1608427614.8162823.png)\\n\\n\\n\\n\\n\\n[code courtesy of serdes\\n ](https://leetcode.com/problems/word-break-ii/discuss/973144/Python3-Recursive-Backtracking-w-Pruning.-O(S)-extra-space)",
                "solutionTags": [
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```python\\n def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res = []\\n        self.backtrack(0, len(s), [], res, s, wordDict, set()) \\n        return res\\n    \\n    def backtrack(self, start, end, sentence, result, string, wordDict, bad):\\n        # seen this prefix before, path did not lead to valid answer\\n        if start in bad: \\n            return  \\n        \\n        if start == end:\\n            result.append(\\' \\'.join(sentence))\\n            return\\n        \\n        before = len(result)\\n        for w in wordDict:\\n            if string[start:].startswith(w):\\n                sentence.append(w)\\n                self.backtrack(start + len(w), end, sentence, result, string, wordDict, bad)\\n                sentence.pop()\\n                \\n        after = len(result)\\n        # no result has been added bad path. \\n\\t\\t# the this index will never lead to a feasible solution\\n        if before == after: bad.add(start)\\n\\n```\n```s```\n```s```\n```python\\n\\ts[start:].startswith(w)\\n```\n```start```\n```try ```\n```applepen```\n```try: apple,  pen, applepen```\n```X```\n```X```",
                "codeTag": "Python3"
            },
            {
                "id": 1087111,
                "title": "clean-simple-javascript-with-explanation-walkthrough-100-100",
                "content": "![image](https://assets.leetcode.com/users/images/376b4b3d-7499-45be-9fa8-0baeb4f8c47e_1615591486.3132093.png)\\n\\nEDIT: This problem came up for me again recently and I couldn\\'t remember my exact code when I solved it the first time.  I think the code I wrote the second time around is easier to understand, so I\\'m including it right below this edit.  I slightly overcomplicated this one on the first go with the .forEach stuff.  Knowing the basic approach let me write a simpler solution this time around.  There\\'s also a one-liner at the very bottom because I was bored. lol\\n\\n```\\nconst wordBreak = (s, wordDict, cur = [], res = []) => {\\n  if (!s.length) return res.push(cur.join(\\' \\'));\\n  for (let word of wordDict) {\\n    if (!s.startsWith(word)) continue;\\n    cur.push(word);\\n    wordBreak(s.slice(word.length), wordDict, cur, res);\\n    cur.pop();\\n  }\\n  return res;\\n}\\n```\\n\\nTestCase: s = \\'catsanddog\\', wordDict = [\\'cat\\', \\'cats\\', \\'and\\', \\'sand\\', \\'dog\\']\\n\\nWe begin by initializing a new hash map in the arguments.  From there, algorithm checks to see if current string is in hashmap.  First time it runs, it\\'s obviously empty.  In fact, the first time a word is added, it will be the last word.  In this case -> {\\'dog\\': [\\'dog\\']} will be first entry.  This entry seems pointless, but from here, it will pop back up to last call \\'sanddog\\'.  Sand was the word found on this round of iterations, so {\\'sanddog\\': [\\'sand dog\\']} is the next entry, and so on back up until the initial call.  In this way, it will take the initial input string and recursively build up the hash map from smallest components until eventually {\\'catsanddog\\': [\\'cat sand dog\\', \\'cats and dog\\'].\\n\\nIn order to do this recursively, we take the initial string and loop through the dictionary.  We check the first word in the dictionary - cat and check if \\'catsanddog\\' starts with that word.  It does, so we initialize a new variable to equal what is left of the string - \\'sanddog\\'.  We then check if this new leftAfter string\\'s length is === 0 (Or !leftAfter.length.  This is the same as leftAfter.length === 0 since 0 is a false-y value).  If it is, we know we have matched the entire string.  If not, we call the function again on the new string.  This time the \\'leftAfter\\' string = \\'sanddog\\'.  Loop matches \\'sand\\', leftAfter is dog.  Function runs again with \\'dog\\' as the argument.  \\'Dog\\' matches in loop, leftAfter.length === 0.  {\\'dog\\':[\\'dog\\']} is set.  On the \\'sanddog\\' level of the recursion call (back on this one since dog found the end of the string and fully finished its execution) \\'sand\\' is the current word. else wordBreak(\\'dog\\', wordDict, cache) runs and returns [\\'dog\\']. For each loop runs on this array and pushes \\'sand\\' + \\' \\' + \\'dog\\' to result.  cache is set with \\'sanddog\\': [\\'sand dog\\'].  In this way, we recurse down to the smallest word and build the combinations up until the full string has been constructed in this manner.  \\n```\\nconst wordBreak = (s, wordDict, cache = new Map()) => {\\n    if(cache.has(s)) return cache.get(s);\\n\\t    \\n    const result = [];\\n    for(const word of wordDict){\\n        if (s.startsWith(word)){\\n            const leftAfter = s.slice(word.length);\\n            if(!leftAfter.length) result.push(word);\\n            else wordBreak(leftAfter, wordDict, cache).forEach(val => result.push(word + \\' \\' + val));\\n        }\\n    }\\n    \\n    cache.set(s, result);\\n    return result;\\n};\\n```\\n\\nFirst function call:  \\'catsanddog\\'  loop through dictionary finds two matches. \\'cat\\' and \\'cats\\'.\\n\\tLeftovers = \\'sanddog\\' and \\'anddog\\'.\\n\\nFunction runs on both of these in first level of recursive calls.  \\n\\t\\'sanddog\\' matches \\'sand\\'.  leftAfter = \\'dog\\' \\n\\t\\'anddog\\' matches \\'and\\'.  leftAfter = \\'dog\\'\\n\\t\\nFunction runs on \\'dog\\' twice in next level of recursive calls.\\n\\t\\'dog\\' matches \\'dog\\'.  results = [dog]. leftAfter = \\'\\'.  dog is added to memo and the second time this recursive call is ran, it is found.\\n\\t[\\'dog\\'] returned to call above.\\n\\t\\nAbove \\'sanddog\\' call with \\'sand\\' as current word and [\\'dog\\'] returned as potential matches for leftAfter.  ForEach loop runs on [\\'dog\\'].\\n\\'sand dog\\' is pushed to results.\\n\\nIn same fashion, \\'anddog\\' pushes [\\'and dog\\'] to results.  Both of these are added to memo and returned to calls above.\\n\\nBack on first call - words matched were \\'cat\\' and \\'cats\\'. \\n\\t[\\'sand dog\\'] is returned from recursive (sanddog) call.  forEach runs and adds \\'cat sand dog\\' to results.\\n\\t[\\'and dog\\'] is returned from recursive (anddog) call.  forEach runs and adds \\'cats and dog\\' to results.\\n\\t\\nResults are returned.\\n\\n\\nOne-liner:\\n```\\nconst wordBreak=(s,w,c,a=[])=>s?!(w.forEach(n=>s.startsWith(n)&&wordBreak(s.slice(n.length),w,c?`${c} ${n}`:n,a)))&&a:a.push(c)\\n```\\n\\nCool trie solution just because I\\'ve been practicing trie problems lately:\\n```\\nconst wordBreak = (s, words) => {\\n  const trie = words.reduce((trie, word) => {\\n    let runner = trie\\n    for (let char of word) {\\n      runner = runner[char] = runner[char] || {}\\n    }\\n    runner.end = word\\n    return trie\\n  }, {})\\n  \\n  const ans = new Array(s.length + 1).fill(false)\\n  ans[0] = [\\'\\']\\n  for (let i = 0; i < s.length + 1; i++) {\\n    if (!ans[i]) continue\\n    let runner = trie, runIdx = i + 1\\n    while (runner) {\\n      const char = s[runIdx - 1]\\n      runner = runner[char]\\n      if (runner && runner.end) {\\n        ans[runIdx] = ans[runIdx] || []\\n        ans[i].forEach(arr => ans[runIdx].push([...arr, runner.end]))\\n      }\\n      runIdx++\\n    }\\n  }\\n  return ans[s.length] ? ans[s.length].map(words => words.join(\\' \\')) : []\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nconst wordBreak = (s, wordDict, cur = [], res = []) => {\\n  if (!s.length) return res.push(cur.join(\\' \\'));\\n  for (let word of wordDict) {\\n    if (!s.startsWith(word)) continue;\\n    cur.push(word);\\n    wordBreak(s.slice(word.length), wordDict, cur, res);\\n    cur.pop();\\n  }\\n  return res;\\n}\\n```\n```\\nconst wordBreak = (s, wordDict, cache = new Map()) => {\\n    if(cache.has(s)) return cache.get(s);\\n\\t    \\n    const result = [];\\n    for(const word of wordDict){\\n        if (s.startsWith(word)){\\n            const leftAfter = s.slice(word.length);\\n            if(!leftAfter.length) result.push(word);\\n            else wordBreak(leftAfter, wordDict, cache).forEach(val => result.push(word + \\' \\' + val));\\n        }\\n    }\\n    \\n    cache.set(s, result);\\n    return result;\\n};\\n```\n```\\nconst wordBreak=(s,w,c,a=[])=>s?!(w.forEach(n=>s.startsWith(n)&&wordBreak(s.slice(n.length),w,c?`${c} ${n}`:n,a)))&&a:a.push(c)\\n```\n```\\nconst wordBreak = (s, words) => {\\n  const trie = words.reduce((trie, word) => {\\n    let runner = trie\\n    for (let char of word) {\\n      runner = runner[char] = runner[char] || {}\\n    }\\n    runner.end = word\\n    return trie\\n  }, {})\\n  \\n  const ans = new Array(s.length + 1).fill(false)\\n  ans[0] = [\\'\\']\\n  for (let i = 0; i < s.length + 1; i++) {\\n    if (!ans[i]) continue\\n    let runner = trie, runIdx = i + 1\\n    while (runner) {\\n      const char = s[runIdx - 1]\\n      runner = runner[char]\\n      if (runner && runner.end) {\\n        ans[runIdx] = ans[runIdx] || []\\n        ans[i].forEach(arr => ans[runIdx].push([...arr, runner.end]))\\n      }\\n      runIdx++\\n    }\\n  }\\n  return ans[s.length] ? ans[s.length].map(words => words.join(\\' \\')) : []\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44353,
                "title": "my-dp-solution-in-java",
                "content": "    public class Solution {\\n        public List<String> wordBreak(String s, Set<String> dict) {\\n            Map<Integer, List<String>> validMap = new HashMap<Integer, List<String>>();\\n    \\n            // initialize the valid values\\n            List<String> l = new ArrayList<String>();\\n            l.add(\"\");\\n            validMap.put(s.length(), l);\\n    \\n            // generate solutions from the end\\n            for(int i = s.length() - 1; i >= 0; i--) {\\n                List<String> values = new ArrayList<String>();\\n                for(int j = i + 1; j <= s.length(); j++) {\\n                    if (dict.contains(s.substring(i, j))) {\\n                        for(String word : validMap.get(j)) {\\n                            values.add(s.substring(i, j) + (word.isEmpty() ? \"\" : \" \") + word);\\n                        }\\n                    }\\n                }\\n                validMap.put(i, values);\\n            }\\n            return validMap.get(0);\\n        }\\n    }\\n\\nBasically my idea is the following:\\n\\n 1. Scan the the string from the tail\\n 2. Build possible solution for the current index based on DP results\\n 3. Return the solution when index==0",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> wordBreak(String s, Set<String> dict) {\\n            Map<Integer, List<String>> validMap = new HashMap<Integer, List<String>>();\\n    \\n            // initialize the valid values\\n            List<String> l = new ArrayList<String>();\\n            l.add(\"\");\\n            validMap.put(s.length(), l);\\n    \\n            // generate solutions from the end\\n            for(int i = s.length() - 1; i >= 0; i--) {\\n                List<String> values = new ArrayList<String>();\\n                for(int j = i + 1; j <= s.length(); j++) {\\n                    if (dict.contains(s.substring(i, j))) {\\n                        for(String word : validMap.get(j)) {\\n                            values.add(s.substring(i, j) + (word.isEmpty() ? \"\" : \" \") + word);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 2617582,
                "title": "0-ms-efficient-c-solution-simple-recursion",
                "content": "```\\n\\tvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string> ans;\\n        set<string> dict (wordDict.begin(), wordDict.end());\\n        f(0, s, \"\", ans, dict);\\n        return ans;\\n    }\\n\\n\\tvoid f(int ind, string &s, string temp, vector<string>& ans, set<string>& dict) {\\n        if(ind == s.length()) {\\n            temp.pop_back(); // pop the trailing space\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        string cur = \"\";\\n        for(int i = ind; i < s.length(); i++) {\\n            cur.push_back(s[i]);\\n            if(dict.find(cur) != dict.end()) {\\n                f(i+1, s, temp + cur + \" \", ans, dict); // adding current substring \\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\\tvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string> ans;\\n        set<string> dict (wordDict.begin(), wordDict.end());\\n        f(0, s, \"\", ans, dict);\\n        return ans;\\n    }\\n\\n\\tvoid f(int ind, string &s, string temp, vector<string>& ans, set<string>& dict) {\\n        if(ind == s.length()) {\\n            temp.pop_back(); // pop the trailing space\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        string cur = \"\";\\n        for(int i = ind; i < s.length(); i++) {\\n            cur.push_back(s[i]);\\n            if(dict.find(cur) != dict.end()) {\\n                f(i+1, s, temp + cur + \" \", ans, dict); // adding current substring \\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 279443,
                "title": "python-40ms-beating-98-4-thoroughly-commented-re-post",
                "content": "Apologies for being unable to find the code of which this is a re-post (I searched a fair few but couldn\\'t find it again). \\n\\nThis is similar to other solutions (esp. similar given that it\\'s a re-post), however this version is thoroughly commented to aid in your understanding. I have also adjusted the structure of the code & variable names for this same purpose. For noobies, understand that we are defining dfs within the first function, which means that the dfs function can use the non-local variable `result` because it\\'s defined previously in the same namespace. \\n\\nLet me know if you find the original code so that I can post a link here!\\n\\n**Second Solution**: I also added a second solution that uses a `deque` (double ended que) for O(1) adding to the path, but this doesn\\'t change the Leetcode performance. Its performance difference depends on (a) the number of possible paths (O(b^d) where `d` = len(s) / average length of sub-words and `b` is the number of matching sub-words at each point) because this impacts the number of times we use operations to add to the path, and (b) the difference in speed between those operations that we use to add to our path. It also depends on (c) the performance difference between the final append in the first solution and the performance of `\" \".join(path)` and the number of times we execute that operation (which equals the number of solutions for a given input).\\n\\n**Path Joining Operations**: Python\\'s normal string concatenation for all of those possible paths (O(n)) vs the speed of `.appendleft(str)` + `.popleft()` for a `deque` for those same possible paths + the time for all of the `\" \".join(path)`s to execute (each takes O(n) and it only occurs once for each solution).  Correct me if this has changed, but string concatenation in Python occurs in O(n+m) (where `n` and `m` are the lengths of the strings being added), which is obviously slower than the two constant time (O(1)) operations that are `deque`\\'s popleft and appendleft, thus for large inputs the `deque` solution should be faster.\\n\\n**First Solution that uses String Concatenation**\\n```python\\nclass Solution:\\n    def wordBreak(self, s, words):\\n        \"\"\"40ms, beating 98.4%. Uses DP to determine reachable locations\\n        in the word, then a DFS to explore paths from the start to the \\n        end of the word.\\n        \\n        Uses varying string concatenation to add to path.\\n        \"\"\"\\n        result = []\\n             \\n        def dfs(dp, end, path):\\n            \"\"\"A DFS to add paths that reach from the end of the word\\n            to the start.\\n            \"\"\"\\n            # If we have reached the start of the word, add to result\\n            if 0 == end:\\n                result.append(path)\\n                return\\n                \\n            # Otherwise consider each possible path from the end\\n            for word in dp[end]:\\n\\n                # If we already have a word in the path, add a space in between\\n                if path:\\n                    dfs(dp, end - len(word), word + \" \" + path)\\n                else:\\n                    dfs(dp, end - len(word), word)\\n        \\n        # Used for O(1) lookup\\n        word_set = set(words)\\n        \\n        # Used for limiting the search for substrings (words) ending at each position\\n        max_len = max([len(w) for w in words + [\\'\\']])\\n        \\n        # Stores whether a combination of words from `words` can reach the position\\n        dp = [[] for _ in range(len(s) + 1)]\\n        dp[0] = True\\n        \\n        # Words ending at i\\n        for i in range(1, len(s) + 1):\\n            \\n            # j defines a reachable location & start of a word ending at i\\n            for j in range(max(0, i - max_len), i):\\n            \\n                # If j is a reachable position & j to i defines a dictionary word\\n                if dp[j] and s[j:i] in word_set:\\n                    dp[i].append(s[j:i])\\n    \\n        # For each word in dp[len(s)], explore if it\\'s possible to reach the start of s.\\n        # If so, append a joining of the path to our output\\n        dfs(dp, len(s), \"\")\\n        return result\\n```\\n\\n**Second Solution using `deque`**:\\n```python\\nfrom collections import deque\\nclass Solution:\\n    def wordBreak(self, s, words):\\n        \"\"\"40ms, beating 98.4%. Uses DP to determine reachable locations\\n        in the word, then a DFS to explore paths from the start to the \\n        end of the word.\\n        \\n        Uses a deque() to append to and pop from left of list in O(1),\\n        and uses \" \".join(path) to add to result.\\n        \"\"\"\\n        result = []\\n             \\n        def dfs(dp, end, path):\\n            \"\"\"A DFS to add paths that reach from the end of the word\\n            to the start.\\n            \"\"\"\\n            # If we have reached the start of the word, add to result\\n            if 0 == end:\\n                result.append(\" \".join(path))\\n                return\\n                \\n            # Otherwise consider each possible path from the end\\n            for word in dp[end]:\\n                path.appendleft(word)\\n                dfs(dp, end-len(word), path)\\n                path.popleft()\\n\\n        # Used for O(1) lookup\\n        word_set = set(words)\\n        \\n        # Used for limiting the search for substrings (words) ending at each position\\n        max_len = max([len(w) for w in words + [\\'\\']])\\n        \\n        # Stores whether a combination of words from `words` can reach the position\\n        dp = [[] for _ in range(len(s) + 1)]\\n        dp[0] = True\\n        \\n        # Words ending at i\\n        for i in range(1, len(s) + 1):\\n            \\n            # j defines a reachable location & start of a word ending at i\\n            for j in range(max(0, i - max_len), i):\\n            \\n                # If j is a reachable position & j to i defines a dictionary word\\n                if dp[j] and s[j:i] in word_set:\\n                    dp[i].append(s[j:i])\\n    \\n        # For each word in dp[len(s)], explore if it\\'s possible to reach the start of s.\\n        # If so, append a joining of the path to our output\\n        dfs(dp, len(s), deque())\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Queue"
                ],
                "code": "```python\\nclass Solution:\\n    def wordBreak(self, s, words):\\n        \"\"\"40ms, beating 98.4%. Uses DP to determine reachable locations\\n        in the word, then a DFS to explore paths from the start to the \\n        end of the word.\\n        \\n        Uses varying string concatenation to add to path.\\n        \"\"\"\\n        result = []\\n             \\n        def dfs(dp, end, path):\\n            \"\"\"A DFS to add paths that reach from the end of the word\\n            to the start.\\n            \"\"\"\\n            # If we have reached the start of the word, add to result\\n            if 0 == end:\\n                result.append(path)\\n                return\\n                \\n            # Otherwise consider each possible path from the end\\n            for word in dp[end]:\\n\\n                # If we already have a word in the path, add a space in between\\n                if path:\\n                    dfs(dp, end - len(word), word + \" \" + path)\\n                else:\\n                    dfs(dp, end - len(word), word)\\n        \\n        # Used for O(1) lookup\\n        word_set = set(words)\\n        \\n        # Used for limiting the search for substrings (words) ending at each position\\n        max_len = max([len(w) for w in words + [\\'\\']])\\n        \\n        # Stores whether a combination of words from `words` can reach the position\\n        dp = [[] for _ in range(len(s) + 1)]\\n        dp[0] = True\\n        \\n        # Words ending at i\\n        for i in range(1, len(s) + 1):\\n            \\n            # j defines a reachable location & start of a word ending at i\\n            for j in range(max(0, i - max_len), i):\\n            \\n                # If j is a reachable position & j to i defines a dictionary word\\n                if dp[j] and s[j:i] in word_set:\\n                    dp[i].append(s[j:i])\\n    \\n        # For each word in dp[len(s)], explore if it\\'s possible to reach the start of s.\\n        # If so, append a joining of the path to our output\\n        dfs(dp, len(s), \"\")\\n        return result\\n```\n```python\\nfrom collections import deque\\nclass Solution:\\n    def wordBreak(self, s, words):\\n        \"\"\"40ms, beating 98.4%. Uses DP to determine reachable locations\\n        in the word, then a DFS to explore paths from the start to the \\n        end of the word.\\n        \\n        Uses a deque() to append to and pop from left of list in O(1),\\n        and uses \" \".join(path) to add to result.\\n        \"\"\"\\n        result = []\\n             \\n        def dfs(dp, end, path):\\n            \"\"\"A DFS to add paths that reach from the end of the word\\n            to the start.\\n            \"\"\"\\n            # If we have reached the start of the word, add to result\\n            if 0 == end:\\n                result.append(\" \".join(path))\\n                return\\n                \\n            # Otherwise consider each possible path from the end\\n            for word in dp[end]:\\n                path.appendleft(word)\\n                dfs(dp, end-len(word), path)\\n                path.popleft()\\n\\n        # Used for O(1) lookup\\n        word_set = set(words)\\n        \\n        # Used for limiting the search for substrings (words) ending at each position\\n        max_len = max([len(w) for w in words + [\\'\\']])\\n        \\n        # Stores whether a combination of words from `words` can reach the position\\n        dp = [[] for _ in range(len(s) + 1)]\\n        dp[0] = True\\n        \\n        # Words ending at i\\n        for i in range(1, len(s) + 1):\\n            \\n            # j defines a reachable location & start of a word ending at i\\n            for j in range(max(0, i - max_len), i):\\n            \\n                # If j is a reachable position & j to i defines a dictionary word\\n                if dp[j] and s[j:i] in word_set:\\n                    dp[i].append(s[j:i])\\n    \\n        # For each word in dp[len(s)], explore if it\\'s possible to reach the start of s.\\n        # If so, append a joining of the path to our output\\n        dfs(dp, len(s), deque())\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44271,
                "title": "java-recursive-dp-solution",
                "content": "    public class Solution {\\n        HashMap<String,List<String>> map = new HashMap<String,List<String>>();\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            List<String> res = new ArrayList<String>();\\n            if(s.isEmpty())\\n                return res; // return empty list upon empty string\\n            \\n            if(map.containsKey(s))\\n                return map.get(s);\\n            \\n            for(int i=0; i<s.length(); i++) {\\n                String firstWord = s.substring(0,i+1);\\n                if(wordDict.contains(firstWord)) {\\n                    List<String> rest = wordBreak(s.substring(i+1),wordDict);\\n                    if(rest.isEmpty()) {\\n                        if(i==s.length()-1)\\n                            res.add(firstWord);\\n                    } else {\\n                        for(String str : rest)\\n                            res.add(firstWord + \" \" + str);\\n                    }\\n                }\\n            }\\n            \\n            map.put(s,res);\\n            \\n            return res;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        HashMap<String,List<String>> map = new HashMap<String,List<String>>();\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            List<String> res = new ArrayList<String>();\\n            if(s.isEmpty())\\n                return res; // return empty list upon empty string\\n            \\n            if(map.containsKey(s))\\n                return map.get(s);\\n            \\n            for(int i=0; i<s.length(); i++) {\\n                String firstWord = s.substring(0,i+1);\\n                if(wordDict.contains(firstWord)) {\\n                    List<String> rest = wordBreak(s.substring(i+1),wordDict);\\n                    if(rest.isEmpty()) {\\n                        if(i==s.length()-1)\\n                            res.add(firstWord);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3107049,
                "title": "c-template-for-word-break-i-ii-concatenated-words",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition for all the problems:\\nAll the three given problems  can be divided into sub-problems .And  If these subproblems individually satisfy the required conditions, then  complete problem will also satisfy the same. And hence we can say whether it is true to find the word in the dictionary or not.\\n\\n# Approach\\n- **Naive Approach**: Use recursion and backtracking. For finding the solution, we check every prefix of the string in the word_dict of words, if it is found , then the recursive function is called for the remaining portion of that string. But this will be$$ 2^n$$ so will give tle . SO we can optimize using memoization or dp.\\n- **DP**: So as we can see that in recurion we call for evrery prefix substring and check if its presnt and like this the we check the whole is present or not .So similarly we can store the same ,like upto certain index whether the substring upto that index is present or not . In this way our dp array will be filled with 0\\'s and 1\\'s representing whether the substring upto that index is present or not . And at last if last index is true i.e dp[n] is true this means whole string is presnt .\\n- So applying this logic we can do all the three problems with a little modification based on requirements.\\n<!-- Describe your approach to solving the problem. -->\\n# **For Word Break I**\\n\\n# Code\\n\\n```\\n bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\\n        int n=s.size();\\n        vector<bool>dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(!dp[i])continue;\\n            for(int j=i+1;j<=n;j++){\\n                if( word_set.count(s.substr(i,j-i)))\\n                dp[j]=1;\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\\n# Complexity\\n- Time complexity:$$O(N^3)$$\\n    - $$N^2$$ for two loops and N for `substr`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# **For Word Break II**\\n```\\nvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n    \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);  \\n                    }\\n                }\\n            }\\n        }\\n         return dp[n];\\n    }\\n```\\n# Complexity\\n- Time complexity:$$O(N^3)$$\\n    - $$N^2$$ for two loops and N for `substr`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# **For concatenated Words**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>word_set(words.begin(),words.end());\\n        vector<string>ans;\\n        for(auto w:words){\\n            int n=w.size();\\n            vector<bool>dp(n+1,false);\\n            dp[0]=1;\\n            for(int i=0;i<n;i++){\\n                if(!dp[i])continue;\\n                for(int j=i+1;j<=n;j++){\\n                    if(j-i<n and word_set.count(w.substr(i,j-i)))\\n                    dp[j]=1;\\n                }\\n            }\\n            if(dp[n]==1)ans.push_back(w);\\n        }\\n       return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:$$O(N*W^3)$$\\n    - where `N=word.length and W = words[i].length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N*W)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\\n        int n=s.size();\\n        vector<bool>dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(!dp[i])continue;\\n            for(int j=i+1;j<=n;j++){\\n                if( word_set.count(s.substr(i,j-i)))\\n                dp[j]=1;\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\n```\\nvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n    \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);  \\n                    }\\n                }\\n            }\\n        }\\n         return dp[n];\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>word_set(words.begin(),words.end());\\n        vector<string>ans;\\n        for(auto w:words){\\n            int n=w.size();\\n            vector<bool>dp(n+1,false);\\n            dp[0]=1;\\n            for(int i=0;i<n;i++){\\n                if(!dp[i])continue;\\n                for(int j=i+1;j<=n;j++){\\n                    if(j-i<n and word_set.count(w.substr(i,j-i)))\\n                    dp[j]=1;\\n                }\\n            }\\n            if(dp[n]==1)ans.push_back(w);\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44195,
                "title": "accepted-java-solution-backtracking-but-what-s-the-difference-with-front-tracking",
                "content": "This is the accepted solution, which might be the \"backtracking\" algorithm. It starts to try the word from the backend.\\n\\n\\tpublic static List<String> wordBreak(String s, Set<String> dict) {\\n\\t\\tList<String> words = new ArrayList<String>();\\n\\t\\tint len = s.length();\\n\\t\\tfor (int i = len -1; i >= 0; i--) {\\n\\t\\t\\tString last = s.substring(i, len);\\n\\t\\t\\tif (dict.contains(last)) {\\n\\t\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\t\\twords.add(last);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tString remain = s.substring(0, i);\\n\\t\\t\\t\\t\\tList<String> remainSet = wordBreak(remain, dict);\\n\\t\\t\\t\\t\\tif (remainSet != null) {\\n\\t\\t\\t\\t\\t\\tfor (String item : remainSet) {\\n\\t\\t\\t\\t\\t\\t\\twords.add(item + \" \" + last);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn words;\\n\\t}\\n\\n\\nIt should be the same if it starts from the front, like following. (front-tracking is my invented word, maybe)\\n\\n\\tpublic static List<String> wordBreakFront(String s, Set<String> dict) {\\n\\t\\tList<String> words = new ArrayList<String>();\\n\\t\\t\\n\\t\\tint len = s.length();\\n\\t\\tfor (int i = 1; i <= len; i++) {\\n\\t\\t\\tString front = s.substring(0, i);\\n\\t\\t\\tif (dict.contains(front)) {\\n\\t\\t\\t\\tif (i == len) {\\n\\t\\t\\t\\t\\twords.add(front);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tString remain = s.substring(i, len);\\n\\t\\t\\t\\t\\tList<String> remainSet = wordBreak(remain, dict);\\n\\t\\t\\t\\t\\tif (remainSet != null) {\\n\\t\\t\\t\\t\\t\\tfor (String item : remainSet) {\\n\\t\\t\\t\\t\\t\\t\\twords.add(front + \" \" + item);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn words;\\n\\t}\\n\\nBut actually it is not!!!\\nThe later is not accepted for lower efficiency.\\n\\nBut Why?",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "This is the accepted solution, which might be the \"backtracking\" algorithm. It starts to try the word from the backend.\\n\\n\\tpublic static List<String> wordBreak(String s, Set<String> dict) {\\n\\t\\tList<String> words = new ArrayList<String>();\\n\\t\\tint len = s.length();\\n\\t\\tfor (int i = len -1; i >= 0; i--) {\\n\\t\\t\\tString last = s.substring(i, len);\\n\\t\\t\\tif (dict.contains(last)) {\\n\\t\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\t\\twords.add(last);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tString remain = s.substring(0, i);\\n\\t\\t\\t\\t\\tList<String> remainSet = wordBreak(remain, dict);\\n\\t\\t\\t\\t\\tif (remainSet != null) {\\n\\t\\t\\t\\t\\t\\tfor (String item : remainSet) {\\n\\t\\t\\t\\t\\t\\t\\twords.add(item + \" \" + last);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn words;\\n\\t}\\n\\n\\nIt should be the same if it starts from the front, like following. (front-tracking is my invented word, maybe)\\n\\n\\tpublic static List<String> wordBreakFront(String s, Set<String> dict) {\\n\\t\\tList<String> words = new ArrayList<String>();\\n\\t\\t\\n\\t\\tint len = s.length();\\n\\t\\tfor (int i = 1; i <= len; i++) {\\n\\t\\t\\tString front = s.substring(0, i);\\n\\t\\t\\tif (dict.contains(front)) {\\n\\t\\t\\t\\tif (i == len) {\\n\\t\\t\\t\\t\\twords.add(front);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tString remain = s.substring(i, len);\\n\\t\\t\\t\\t\\tList<String> remainSet = wordBreak(remain, dict);\\n\\t\\t\\t\\t\\tif (remainSet != null) {\\n\\t\\t\\t\\t\\t\\tfor (String item : remainSet) {\\n\\t\\t\\t\\t\\t\\t\\twords.add(front + \" \" + item);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn words;\\n\\t}\\n\\nBut actually it is not!!!\\nThe later is not accepted for lower efficiency.\\n\\nBut Why?",
                "codeTag": "Unknown"
            },
            {
                "id": 1947487,
                "title": "c-dp-100-0ms",
                "content": "\\t vector<string> wordBreak(string s, vector<string>& dict) {\\n        \\n        int n = s.size();\\n        unordered_map<string,int> map;\\n        \\n        for(int i=0;i<dict.size();i++)\\n        {\\n            map[dict[i]]++;\\n        }\\n        \\n        vector<vector<string>> dp(n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j>=0;j--)\\n            {\\n                string temp = s.substr(j,i-j+1);\\n                if(map.count(temp))\\n                {\\n                    if(j==0)\\n                    {\\n                        dp[i].push_back(temp);\\n                    }\\n                    else\\n                    {\\n                        for(int k=0;k<dp[j-1].size();k++)\\n                        {\\n                            dp[i].push_back(dp[j-1][k]+\" \"+temp);\\n                        }   \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n-1];\\n    }\\n\\nevery index of the dp array will store a vector which will store all possible strings which can be formed using the word and the dictionary till ith index.\\n\\nLet we are working on a string temp, we will start checking all the possible break points and at each break point we will check whether it is a valid break point or not.\\nA breakpoint is valid if string before break point can be broken down into words present in dictionary and string after the break point is a word in the dictionary.\\n\\nAt a valid break point , at the previous index there is a vector which has all the valid strings which can be made using the word starting from 0th index to that index , so we just have to append string after the breakpoint to all those strings, and by doing so you will get all possible strings in which the word (till the ith index) can be broken.",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t vector<string> wordBreak(string s, vector<string>& dict) {\\n        \\n        int n = s.size();\\n        unordered_map<string,int> map;\\n        \\n        for(int i=0;i<dict.size();i++)\\n        {\\n            map[dict[i]]++;\\n        }\\n        \\n        vector<vector<string>> dp(n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j>=0;j--)\\n            {\\n                string temp = s.substr(j,i-j+1);\\n                if(map.count(temp))\\n                {\\n                    if(j==0)\\n                    {\\n                        dp[i].push_back(temp);\\n                    }\\n                    else\\n                    {\\n                        for(int k=0;k<dp[j-1].size();k++)\\n                        {\\n                            dp[i].push_back(dp[j-1][k]+\" \"+temp);\\n                        }   \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n-1];\\n    }\\n\\nevery index of the dp array will store a vector which will store all possible strings which can be formed using the word and the dictionary till ith index.\\n\\nLet we are working on a string temp, we will start checking all the possible break points and at each break point we will check whether it is a valid break point or not.\\nA breakpoint is valid if string before break point can be broken down into words present in dictionary and string after the break point is a word in the dictionary.\\n\\nAt a valid break point , at the previous index there is a vector which has all the valid strings which can be made using the word starting from 0th index to that index , so we just have to append string after the breakpoint to all those strings, and by doing so you will get all possible strings in which the word (till the ith index) can be broken.",
                "codeTag": "Unknown"
            },
            {
                "id": 1474977,
                "title": "c-trie-dfs",
                "content": "**Time : O(N*M + 2^X)**\\nwhere,\\nN = No. of word in Dict.\\nM = length of longest word\\nX = length of string (s);\\n\\n**Prerequisite:** You should have basic knowledge of Trie.\\nFirst solve this *leetcode-208 [https://leetcode.com/problems/implement-trie-prefix-tree/](http://)*\\nthen, *leetcode-139 [https://leetcode.com/problems/word-break/](http://)*\\nthen try this **(Word Break II)** question.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    class Trie{\\n      public:\\n        Trie* child[26];\\n        bool isEnd=false;\\n    };\\n    \\n    void insert(string& word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(cur->child[ch-\\'a\\']==NULL) cur->child[ch-\\'a\\'] = new Trie();\\n            cur = cur->child[ch-\\'a\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    bool search(string& word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(cur->child[ch-\\'a\\']==NULL) return false;\\n            cur = cur->child[ch-\\'a\\'];\\n        }\\n        return cur->isEnd;\\n    }\\n    \\n    void dfs(string &s, int idx, Trie *root, string curStr){\\n        if(idx == s.size()){\\n            ans.push_back(curStr.substr(0,0+curStr.size()-1));   //before pushing in vector remove the extra-space in the last of the string \\n            return;\\n        }\\n        string str=\"\";\\n        for(int i=idx; i<s.size(); ++i){\\n            str.push_back(s[i]);\\n            if(search(str,root)) dfs(s,i+1,root, curStr+str+\" \");\\n        }\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        Trie *root = new Trie();\\n        for(auto &word : wordDict){\\n            insert(word,root);\\n        }\\n        dfs(s,0,root,\"\");\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    class Trie{\\n      public:\\n        Trie* child[26];\\n        bool isEnd=false;\\n    };\\n    \\n    void insert(string& word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(cur->child[ch-\\'a\\']==NULL) cur->child[ch-\\'a\\'] = new Trie();\\n            cur = cur->child[ch-\\'a\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    bool search(string& word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(cur->child[ch-\\'a\\']==NULL) return false;\\n            cur = cur->child[ch-\\'a\\'];\\n        }\\n        return cur->isEnd;\\n    }\\n    \\n    void dfs(string &s, int idx, Trie *root, string curStr){\\n        if(idx == s.size()){\\n            ans.push_back(curStr.substr(0,0+curStr.size()-1));   //before pushing in vector remove the extra-space in the last of the string \\n            return;\\n        }\\n        string str=\"\";\\n        for(int i=idx; i<s.size(); ++i){\\n            str.push_back(s[i]);\\n            if(search(str,root)) dfs(s,i+1,root, curStr+str+\" \");\\n        }\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        Trie *root = new Trie();\\n        for(auto &word : wordDict){\\n            insert(word,root);\\n        }\\n        dfs(s,0,root,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870172,
                "title": "python-simple-dp-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        cache={}\\n        def wordbr(s):\\n            if s not in cache: \\n                result=[]\\n                for w in wordDict:\\n                    if s[:len(w)]==w:\\n                        if len(s)==len(w):\\n                            result.append(w)\\n                        else:\\n                            for word in wordbr(s[len(w):]):\\n                                result.append(w+\" \"+word)\\n                cache[s]=result\\n            return cache[s]\\n        \\n        return wordbr(s)\\n```\\nplease upvote if you like..!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        cache={}\\n        def wordbr(s):\\n            if s not in cache: \\n                result=[]\\n                for w in wordDict:\\n                    if s[:len(w)]==w:\\n                        if len(s)==len(w):\\n                            result.append(w)\\n                        else:\\n                            for word in wordbr(s[len(w):]):\\n                                result.append(w+\" \"+word)\\n                cache[s]=result\\n            return cache[s]\\n        \\n        return wordbr(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163697,
                "title": "4ms-c-solution-based-on-word-break-i",
                "content": "Word Break I solution:\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> words(wordDict.begin(), wordDict.end());\\n        int n = s.size();\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j]) {\\n                    if (words.count(s.substr(j, i - j))) {\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\nWord Break II solution based on Word Break I dynamic programming solution, search results by backtracking\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_set<string> words;\\n\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        words.clear();\\n        copy(wordDict.begin(), wordDict.end(), inserter(words, words.end()));\\n\\n        int n = s.size();\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j]) {\\n                    if (words.count(s.substr(j, i - j))) {\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n        if (dp[n]) {\\n            constructSentence(s, dp, 0, res, \"\");\\n        }\\n        return res;\\n    }\\n\\n    void constructSentence(const string& s,\\n                           const vector<int>& dp,\\n                           int pos,\\n                           vector<string>& res,\\n                           string temp) {\\n        for (int i = pos + 1; i < dp.size(); ++i) {\\n            if (dp[i]) {\\n                string new_word = s.substr(pos, i - pos);\\n                if (words.count(new_word)) {\\n                    if (i + 1 == dp.size()) {\\n                        res.push_back(temp + new_word);\\n                        return;\\n                    }\\n                    constructSentence(s, dp, i, res, temp + new_word + \" \");\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> words(wordDict.begin(), wordDict.end());\\n        int n = s.size();\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j]) {\\n                    if (words.count(s.substr(j, i - j))) {\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    unordered_set<string> words;\\n\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        words.clear();\\n        copy(wordDict.begin(), wordDict.end(), inserter(words, words.end()));\\n\\n        int n = s.size();\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j]) {\\n                    if (words.count(s.substr(j, i - j))) {\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n        if (dp[n]) {\\n            constructSentence(s, dp, 0, res, \"\");\\n        }\\n        return res;\\n    }\\n\\n    void constructSentence(const string& s,\\n                           const vector<int>& dp,\\n                           int pos,\\n                           vector<string>& res,\\n                           string temp) {\\n        for (int i = pos + 1; i < dp.size(); ++i) {\\n            if (dp[i]) {\\n                string new_word = s.substr(pos, i - pos);\\n                if (words.count(new_word)) {\\n                    if (i + 1 == dp.size()) {\\n                        res.push_back(temp + new_word);\\n                        return;\\n                    }\\n                    constructSentence(s, dp, i, res, temp + new_word + \" \");\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44232,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Word Break II** https://leetcode.com/problems/word-break-ii/\\n\\n**Memoization**\\n* We parameterize the problem with a single variable k. helper(k, s, ....) returns all the solns to the problem for input string s[k:].\\n* Given a s and k, we divide the string into left and right half by running a loop i from k to len(s). left = s[k:i+1]. If left is a valid word, we call the sub-problem helper(i+1, s...). The output of the sub-problem is combined with left to produce all results.\\n* Corner case: left = s[k:len(s)]. The remainder for this problem is empty. So we return left as an answer given left is a valid word.\\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.helper(0, s, set(wordDict), {})\\n\\n    def helper(self, k, s, wordDict, cache):\\n        if k == len(s):\\n            return []\\n        elif k in cache:\\n            return cache[k]\\n        else:\\n            cache[k] = []\\n            for i in range(k, len(s)):\\n                left = s[k:i+1]\\n                if left in wordDict:\\n                    remainder = self.helper(i+1, s, wordDict, cache)\\n                    if remainder:\\n                        for x in remainder:\\n                            cache[k].append(left + \" \" + x)\\n                    elif (i == len(s)-1):\\n                        cache[k].append(left)\\n            return cache[k]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.helper(0, s, set(wordDict), {})\\n\\n    def helper(self, k, s, wordDict, cache):\\n        if k == len(s):\\n            return []\\n        elif k in cache:\\n            return cache[k]\\n        else:\\n            cache[k] = []\\n            for i in range(k, len(s)):\\n                left = s[k:i+1]\\n                if left in wordDict:\\n                    remainder = self.helper(i+1, s, wordDict, cache)\\n                    if remainder:\\n                        for x in remainder:\\n                            cache[k].append(left + \" \" + x)\\n                    elif (i == len(s)-1):\\n                        cache[k].append(left)\\n            return cache[k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938504,
                "title": "100-fastest-swift-solution-time-o-2-n-space-o-2-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(2 ^ n), where n is the length of the wordDict.\\n    //   - space: O(2 ^ n), where n is the length of the wordDict.\\n\\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var dict = [String: [String]]()\\n        return dfs(s, wordDict, &dict)\\n    }\\n\\n\\n    private func dfs(_ s: String, _ wordDict: [String], _ dict: inout [String: [String]]) -> [String] {\\n        if let val = dict[s] { return val }\\n        guard !s.isEmpty else { return [\"\"] }\\n        var ans = [String]()\\n\\n        for word in wordDict {\\n            guard s.hasPrefix(word) else { continue }\\n            let sublist = dfs(String(s.dropFirst(word.count)), wordDict, &dict)\\n            for sub in sublist {\\n                ans.append(\"\\\\(word)\\\\(sub.isEmpty ? \"\" : \" \")\\\\(sub)\")\\n            }\\n        }\\n\\n        dict[s] = ans\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(2 ^ n), where n is the length of the wordDict.\\n    //   - space: O(2 ^ n), where n is the length of the wordDict.\\n\\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var dict = [String: [String]]()\\n        return dfs(s, wordDict, &dict)\\n    }\\n\\n\\n    private func dfs(_ s: String, _ wordDict: [String], _ dict: inout [String: [String]]) -> [String] {\\n        if let val = dict[s] { return val }\\n        guard !s.isEmpty else { return [\"\"] }\\n        var ans = [String]()\\n\\n        for word in wordDict {\\n            guard s.hasPrefix(word) else { continue }\\n            let sublist = dfs(String(s.dropFirst(word.count)), wordDict, &dict)\\n            for sub in sublist {\\n                ans.append(\"\\\\(word)\\\\(sub.isEmpty ? \"\" : \" \")\\\\(sub)\")\\n            }\\n        }\\n\\n        dict[s] = ans\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763803,
                "title": "python-simple-dp-solution",
                "content": "The idea of the solution is to have a dictionary `dp` with keys as `start`, where `start` can be any value from 0 to `len(s) - 1`. The value of `dp` is a list of all valid sentences that make up `s[start:]`. This will take a top-down dynamic programming approach.\\n\\n**Example**\\nLet\\'s use example 1, where we are given `s = \"catsanddog\"` and `wordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]`. The following will be the `dp` dict after our program has run:\\n\\n`dp[7] = [\"dog\"]`\\n`dp[4] = [\"and dog\"]`\\n`dp[3] = [\"sand dog\"]`\\n`dp[0] = [\"cats and dog\", \"cat sand dog\"]`\\n\\n```\\nindex : 0 1 2 3 4 5 6 7 8 9\\ns     : c a t s a n d d o g\\n```\\n\\n**Code**\\nTo construct `dp`,  we will use a helper function. `start` is the beginning index of the substring. We first check that `dp[start]` has not been created, if it has been, just return it. \\n\\nThen for each word `w` in `wordDict`, we want to check if the substring starts with the word `w`. If so, then there are two cases. *Case 1* is if `w` is the end of `s`, in our example, that is \"dog\". We don\\'t want to keep searching deeper and we don\\'t want to add a space after \"dog\". *Case 2* is if we should keep searching deeper, in this case we will add future results. In our example, if `w = \"and\"`, we will add \"dog\" to create \"and dog\".\\n\\nFinally, we return `dp[start]`. Since `dp` is a defaultdict, it will return `[]` if we don\\'t append any items to it, which is the case of no valid sentences for the substring `s[start:]`.\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dp = defaultdict(list)\\n        \\n        def helper(start: int) -> List[str]:\\n            if start not in dp:\\n                for w in wordDict:\\n                    if start + len(w) <= len(s) and w == s[start:start+len(w)]:\\n                        if start + len(w) == len(s):\\n\\t\\t\\t\\t\\t\\t\\t# Case 1: No need to go deeper because we are at the end of s\\n                            dp[start].append(w)\\n                        else:\\n\\t\\t\\t\\t\\t\\t\\t# Case 2: Keep searching deeper\\n                            for suffix in helper(start + len(w)):\\n                                dp[start].append(w + \" \" + suffix)\\n            return dp[start]\\n        \\n        return helper(0)\\n```",
                "solutionTags": [],
                "code": "```\\nindex : 0 1 2 3 4 5 6 7 8 9\\ns     : c a t s a n d d o g\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dp = defaultdict(list)\\n        \\n        def helper(start: int) -> List[str]:\\n            if start not in dp:\\n                for w in wordDict:\\n                    if start + len(w) <= len(s) and w == s[start:start+len(w)]:\\n                        if start + len(w) == len(s):\\n\\t\\t\\t\\t\\t\\t\\t# Case 1: No need to go deeper because we are at the end of s\\n                            dp[start].append(w)\\n                        else:\\n\\t\\t\\t\\t\\t\\t\\t# Case 2: Keep searching deeper\\n                            for suffix in helper(start + len(w)):\\n                                dp[start].append(w + \" \" + suffix)\\n            return dp[start]\\n        \\n        return helper(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744674,
                "title": "diagrammatic-python-intuitive-solution-with-example",
                "content": "\\nLets start with a simple version of the problem.\\n\\nAssume you had a function `wordsEndingWith(i)` which gave you all possible strings which end with `s[i:]` i.e; `wordsEndingWith(0)`  would give you all words ending with \"CATSANDDOG\".\\n\\nSo, for example, you know CAT is in your dictionary, you need to know how \"SANDDOG\" could be broken, You\\'d call `wordsEndingWith(3)` which would return you `[\"SAND DOG\"]`. If your dictionary had \"SAN\" and \"DDOG\" too, this function would instead return `[\"SAND DOG\", \"SAN DDOG\"]` (_It returns all possibilities_)\\n\\nSo, all you need to do is call this function bottom up, right:\\n\\n<img src=\"https://assets.leetcode.com/users/images/20686d18-9101-4a89-8a48-adaaa12f44ef_1595190114.0389073.png\" width=400/>\\n\\n```python\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        def wordsEndingIn(i):\\n            if i == len(s):\\n                return [\"\"]\\n            ans = []\\n            for j in range(i+1, len(s)+1):\\n                if s[i:j] in wordDict:\\n                    for tail in wordsEndingIn(j):\\n                        if tail != \\'\\':\\n                            ans.append(s[i:j] + \" \" + tail) \\n                        else:\\n                            ans.append(s[i:j])\\n            return ans\\n        return wordsEndingIn(0)\\n```\\n\\n\\n<img src=\"https://assets.leetcode.com/users/images/50decb13-7f51-4cc7-9c93-50d41cc6bfcd_1595190815.615007.png\" width=400/>\\n\\n```\\n0 , catsanddog, []\\n\\t s[0:3] or cat is in wordDict, calling sentences(3)\\n3 , sanddog, []\\n\\t s[3:7] or sand is in wordDict, calling sentences(7)\\n7 , dog, []\\n\\t s[7:10] or dog is in wordDict, calling sentences(10)\\n10 , , []\\n----\\n\\t s[0:4] or cats is in wordDict, calling sentences(4)\\n4 , anddog, [[u\\'dog\\'], [u\\'sand dog\\']]\\n\\t s[4:7] or and is in wordDict, calling sentences(7)\\n7 , dog, [[u\\'dog\\'], [u\\'sand dog\\']]\\n\\t s[7:10] or dog is in wordDict, calling sentences(10)\\n10 , , [[u\\'dog\\'], [u\\'sand dog\\']]\\n----\\n\\n\\n\\n\\nAnother example:\\n\\n0 , pineapplepenapple, []\\n\\t s[0:4] or pine is in wordDict, calling sentences(4)\\n4 , applepenapple, []\\n\\t s[4:9] or apple is in wordDict, calling sentences(9)\\n9 , penapple, []\\n\\t s[9:12] or pen is in wordDict, calling sentences(12)\\n12 , apple, []\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , []\\n----\\n\\t s[4:12] or applepen is in wordDict, calling sentences(12)\\n12 , apple, [[u\\'apple\\'], [u\\'pen apple\\']]\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , [[u\\'apple\\'], [u\\'pen apple\\']]\\n----\\n\\t s[0:9] or pineapple is in wordDict, calling sentences(9)\\n9 , penapple, [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n\\t s[9:12] or pen is in wordDict, calling sentences(12)\\n12 , apple, [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n----\\n```\\n\\nAs you can see, the parts in blue are actually done repeatedly:\\n\\n<img src=\"https://assets.leetcode.com/users/images/e7a4c4de-52d4-4d30-aaf5-81f8693f9af2_1595190922.2887342.png\" width=400/>\\n\\nThey\\'ve already been computed. \\n\\nThus, we can save such expensive computations and reduce calls to this recursive function by maintaining a hashmap with results of previous calls.\\n\\n```python\\n\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        memo = {}\\n        def wordsEndingIn(i):\\n            if i == len(s):\\n                return [\"\"]\\n            if i in memo:\\n                return memo[i]\\n            ans = []\\n            for j in range(i+1, len(s)+1):\\n                if s[i:j] in wordDict:\\n                    for tail in wordsEndingIn(j):\\n                        if tail != \\'\\':\\n                            ans.append(s[i:j] + \" \" + tail) \\n                        else:\\n                            ans.append(s[i:j])\\n            memo[i] = ans\\n            return ans\\n        return wordsEndingIn(0)\\n        \\n\\t\\t```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        def wordsEndingIn(i):\\n            if i == len(s):\\n                return [\"\"]\\n            ans = []\\n            for j in range(i+1, len(s)+1):\\n                if s[i:j] in wordDict:\\n                    for tail in wordsEndingIn(j):\\n                        if tail != \\'\\':\\n                            ans.append(s[i:j] + \" \" + tail) \\n                        else:\\n                            ans.append(s[i:j])\\n            return ans\\n        return wordsEndingIn(0)\\n```\n```\\n0 , catsanddog, []\\n\\t s[0:3] or cat is in wordDict, calling sentences(3)\\n3 , sanddog, []\\n\\t s[3:7] or sand is in wordDict, calling sentences(7)\\n7 , dog, []\\n\\t s[7:10] or dog is in wordDict, calling sentences(10)\\n10 , , []\\n----\\n\\t s[0:4] or cats is in wordDict, calling sentences(4)\\n4 , anddog, [[u\\'dog\\'], [u\\'sand dog\\']]\\n\\t s[4:7] or and is in wordDict, calling sentences(7)\\n7 , dog, [[u\\'dog\\'], [u\\'sand dog\\']]\\n\\t s[7:10] or dog is in wordDict, calling sentences(10)\\n10 , , [[u\\'dog\\'], [u\\'sand dog\\']]\\n----\\n\\n\\n\\n\\nAnother example:\\n\\n0 , pineapplepenapple, []\\n\\t s[0:4] or pine is in wordDict, calling sentences(4)\\n4 , applepenapple, []\\n\\t s[4:9] or apple is in wordDict, calling sentences(9)\\n9 , penapple, []\\n\\t s[9:12] or pen is in wordDict, calling sentences(12)\\n12 , apple, []\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , []\\n----\\n\\t s[4:12] or applepen is in wordDict, calling sentences(12)\\n12 , apple, [[u\\'apple\\'], [u\\'pen apple\\']]\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , [[u\\'apple\\'], [u\\'pen apple\\']]\\n----\\n\\t s[0:9] or pineapple is in wordDict, calling sentences(9)\\n9 , penapple, [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n\\t s[9:12] or pen is in wordDict, calling sentences(12)\\n12 , apple, [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n----\\n```\n```python\\n\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        memo = {}\\n        def wordsEndingIn(i):\\n            if i == len(s):\\n                return [\"\"]\\n            if i in memo:\\n                return memo[i]\\n            ans = []\\n            for j in range(i+1, len(s)+1):\\n                if s[i:j] in wordDict:\\n                    for tail in wordsEndingIn(j):\\n                        if tail != \\'\\':\\n                            ans.append(s[i:j] + \" \" + tail) \\n                        else:\\n                            ans.append(s[i:j])\\n            memo[i] = ans\\n            return ans\\n        return wordsEndingIn(0)\\n        \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 44369,
                "title": "my-simple-c-dp-15ms-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> wordBreak(string s, unordered_set<string> &dict) {\\n            vector<string> res;\\n            if (dict.size() == 0) return res;\\n            \\n            vector<vector<int> > spaceIdx;\\n            spaceIdx.resize(s.size() + 1);\\n            spaceIdx[0].push_back(-1);\\n            \\n            for (int i = 1; i <= s.size(); i++) {\\n                for (int j = 0; j < i; j++) {\\n                    if (spaceIdx[j].size() && dict.count(s.substr(j, i - j))) {\\n                            spaceIdx[i].push_back(j);\\n                    }\\n                }\\n            }\\n            \\n            return backTrack(s, spaceIdx, s.size());\\n        }\\n        \\n        vector<string> backTrack(string& s, vector<vector<int> >& spaceIdx, int idx) {\\n            vector<string> res;\\n            if (idx <= 0) {res.push_back(\"\"); return res;}\\n            \\n            for (int i = 0; i < spaceIdx[idx].size(); i++) {\\n                string str = s.substr(spaceIdx[idx][i], idx - spaceIdx[idx][i]);\\n                vector<string> subRes = backTrack(s, spaceIdx, spaceIdx[idx][i]);\\n                for (int j = 0; j < subRes.size(); j++) {\\n                    if (subRes[j] != \"\") subRes[j] = subRes[j] + \" \" + str;\\n                    else subRes[j] = str;\\n                    res.push_back(subRes[j]);\\n                }\\n            }\\n            \\n            return res;\\n        }\\n    };\\n\\nThe idea is that for each index i of string s, for each j < i check if 1) s.substr(0, j) has valid solution and 2) s.substr(j, i - j + 1) is a valid word. If so then mark j as a sub-solution of i. At the end we trace back from the last index and construct valid word breaks using DFS.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> wordBreak(string s, unordered_set<string> &dict) {\\n            vector<string> res;\\n            if (dict.size() == 0) return res;\\n            \\n            vector<vector<int> > spaceIdx;\\n            spaceIdx.resize(s.size() + 1);\\n            spaceIdx[0].push_back(-1);\\n            \\n            for (int i = 1; i <= s.size(); i++) {\\n                for (int j = 0; j < i; j++) {\\n                    if (spaceIdx[j].size() && dict.count(s.substr(j, i - j))) {\\n                            spaceIdx[i].push_back(j);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 764151,
                "title": "javascript-75-80ms-heavily-commented-dp",
                "content": "```javascript\\nvar wordBreak = function(s, wordDict) {\\n    const memo = new Map();\\n    \\n    function run(str) {\\n        if(memo.has(str)) return memo.get(str);\\n        if(!str.length) return [];\\n        \\n        const result = [];\\n        \\n        for(let word of wordDict) {\\n            \\n            // find words in the dict that match the start of str\\n            if(str.startsWith(word)) {\\n                // remove the current word from the start of the str\\n                const next = str.slice(word.length);\\n                const paths = run(next); \\n                \\n                // if \\'paths\\' is empty arr, and \\'next\\' is empty str\\n                // current word will be the last one in the sequence\\n                if(!paths.length && !next.length) result.push(word);\\n                \\n                // else map the current word to the start of every path\\n                // and push each path to result\\n                result.push(...paths.map(rest => word + \\' \\' + rest));\\n            }\\n        }\\n        // cache result\\n        memo.set(str, result);\\n        return result;\\n    }\\n    return run(s);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```javascript\\nvar wordBreak = function(s, wordDict) {\\n    const memo = new Map();\\n    \\n    function run(str) {\\n        if(memo.has(str)) return memo.get(str);\\n        if(!str.length) return [];\\n        \\n        const result = [];\\n        \\n        for(let word of wordDict) {\\n            \\n            // find words in the dict that match the start of str\\n            if(str.startsWith(word)) {\\n                // remove the current word from the start of the str\\n                const next = str.slice(word.length);\\n                const paths = run(next); \\n                \\n                // if \\'paths\\' is empty arr, and \\'next\\' is empty str\\n                // current word will be the last one in the sequence\\n                if(!paths.length && !next.length) result.push(word);\\n                \\n                // else map the current word to the start of every path\\n                // and push each path to result\\n                result.push(...paths.map(rest => word + \\' \\' + rest));\\n            }\\n        }\\n        // cache result\\n        memo.set(str, result);\\n        return result;\\n    }\\n    return run(s);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 587053,
                "title": "problem-is-not-correctly-defined",
                "content": "After solving Word Break problem I was quick to come up with dynamic approach for Word Break II, which is identical to official **Approach 3**. \\nAnd for many of you this approach failed with TLE or Out of memory just like it failed for me for the following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nWhat did I do? Looked up the best rated problem with neat DFS approach\\nhttps://leetcode.com/problems/word-break-ii/discuss/44167/My-concise-JAVA-solution-based-on-memorized-DFS\\n\\nThe only reason it succeeds because the way DFS works ... goes deep, go-go-go ... encounter a problem, return empty list early compared with dynamic approach. Basically it \\'short-circuits\\' in this case.\\n\\nBUT if input with s.length() == 151 is a valid input string, then I can construct test case by replacing \\'b\\' with \\'a\\'. Then neither DFS nor dynamic approach would succeed in time/memory limit. Given that test case can have input s with 151 characters and there is no limit on wordDict size this is perfectly valid test case ... or many other similar test cases one can construt to \\'fail\\' both DFS and DP solutions.\\n\\nProblem needs to specify proper restrictions/limit on input size, e.g.\\na <= s.length() <= b\\nc <= wordDict.size() <= d\\nonlyl lower-case or any characters etc.",
                "solutionTags": [],
                "code": "After solving Word Break problem I was quick to come up with dynamic approach for Word Break II, which is identical to official **Approach 3**. \\nAnd for many of you this approach failed with TLE or Out of memory just like it failed for me for the following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nWhat did I do? Looked up the best rated problem with neat DFS approach\\nhttps://leetcode.com/problems/word-break-ii/discuss/44167/My-concise-JAVA-solution-based-on-memorized-DFS\\n\\nThe only reason it succeeds because the way DFS works ... goes deep, go-go-go ... encounter a problem, return empty list early compared with dynamic approach. Basically it \\'short-circuits\\' in this case.\\n\\nBUT if input with s.length() == 151 is a valid input string, then I can construct test case by replacing \\'b\\' with \\'a\\'. Then neither DFS nor dynamic approach would succeed in time/memory limit. Given that test case can have input s with 151 characters and there is no limit on wordDict size this is perfectly valid test case ... or many other similar test cases one can construt to \\'fail\\' both DFS and DP solutions.\\n\\nProblem needs to specify proper restrictions/limit on input size, e.g.\\na <= s.length() <= b\\nc <= wordDict.size() <= d\\nonlyl lower-case or any characters etc.",
                "codeTag": "Unknown"
            },
            {
                "id": 296870,
                "title": "simple-javascript-solution",
                "content": "```\\nvar wordBreak = function(s, wordDict, cache = new Map()) {\\n    if(cache.has(s))\\n        return cache.get(s);\\n    \\n    if(s.length === 0){\\n        cache.set(s, []);\\n        return [];\\n    }\\n    \\n    const result = [];\\n    for(let word of wordDict){\\n        const index = s.indexOf(word);\\n        if(index === 0){\\n            const newStr = s.slice(word.length);\\n            const values = wordBreak(newStr, wordDict, cache);\\n            if(values.length === 0 && newStr.length === 0)\\n                result.push(word);\\n            else{\\n                values.forEach(val => {\\n                    result.push(word + \\' \\' + val);\\n                });\\n            }\\n        }\\n    }\\n    \\n    cache.set(s, result);\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar wordBreak = function(s, wordDict, cache = new Map()) {\\n    if(cache.has(s))\\n        return cache.get(s);\\n    \\n    if(s.length === 0){\\n        cache.set(s, []);\\n        return [];\\n    }\\n    \\n    const result = [];\\n    for(let word of wordDict){\\n        const index = s.indexOf(word);\\n        if(index === 0){\\n            const newStr = s.slice(word.length);\\n            const values = wordBreak(newStr, wordDict, cache);\\n            if(values.length === 0 && newStr.length === 0)\\n                result.push(word);\\n            else{\\n                values.forEach(val => {\\n                    result.push(word + \\' \\' + val);\\n                });\\n            }\\n        }\\n    }\\n    \\n    cache.set(s, result);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 175737,
                "title": "python-solution-continuation-to-word-break",
                "content": "After the DP solution of Word Break, simply use Backtrack to get the valid words that can form a sentence.\\n\\n```\\n  def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        dp = [False]*(len(s)+1)\\n        dp[0] = True\\n        \\n        for i in range(len(s)+1):\\n            for j in range(i):\\n                if dp[j] == True and s[j:i] in wordDict:\\n                    dp[i] = True\\n        \\n        if dp[-1] == False:\\n            return []\\n        \\n        pos = []\\n        \\n        for i in range(len(dp)):\\n            if dp[i] == True:\\n                pos.append(i-1)\\n        pos.pop(0)\\n        res = []\\n        self.build(pos, s, \"\", res, wordDict, 0)\\n        return res\\n    \\n    def build(self, pos, s, choice, res, wordDict, start):\\n        if start > pos[-1]:\\n            res.append(choice[:-1])\\n            return \\n        \\n        for i in range(len(pos)):\\n            if s[start: pos[i]+1] in wordDict:\\n                self.build(pos, s, choice+s[start:pos[i]+1]+\" \", res, wordDict, pos[i]+1)\\n```",
                "solutionTags": [],
                "code": "```\\n  def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        dp = [False]*(len(s)+1)\\n        dp[0] = True\\n        \\n        for i in range(len(s)+1):\\n            for j in range(i):\\n                if dp[j] == True and s[j:i] in wordDict:\\n                    dp[i] = True\\n        \\n        if dp[-1] == False:\\n            return []\\n        \\n        pos = []\\n        \\n        for i in range(len(dp)):\\n            if dp[i] == True:\\n                pos.append(i-1)\\n        pos.pop(0)\\n        res = []\\n        self.build(pos, s, \"\", res, wordDict, 0)\\n        return res\\n    \\n    def build(self, pos, s, choice, res, wordDict, start):\\n        if start > pos[-1]:\\n            res.append(choice[:-1])\\n            return \\n        \\n        for i in range(len(pos)):\\n            if s[start: pos[i]+1] in wordDict:\\n                self.build(pos, s, choice+s[start:pos[i]+1]+\" \", res, wordDict, pos[i]+1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 44191,
                "title": "java-dp-solution",
                "content": "    public class Solution {\\n        \\n      public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> res = new ArrayList<String>();\\n        // Do a fast check and see if we can break the input string\\n        if (!canBreak(s, dict))\\n          return res;\\n        \\n        helper(s, dict, 0, \"\", res);\\n        return res;\\n      }\\n      \\n      void helper(String s, Set<String> dict, int start, String sol, List<String> res) {\\n        if (start == s.length()) {\\n          res.add(sol);\\n          return;\\n        }\\n        \\n        for (int i = start; i < s.length(); i++) {\\n          String sub = s.substring(start, i + 1);\\n          \\n          if (dict.contains(sub))\\n            helper(s, dict, i + 1, sol + (sol.length() == 0 ? \"\" : \" \") + sub, res);\\n        }\\n      }\\n      \\n      // Solution from \"Word Break\"\\n      boolean canBreak(String s, Set<String> dict) {\\n          if (s == null || s.length() == 0) return false;\\n          \\n          int n = s.length();\\n          \\n          // dp[i] represents whether s[0...i] can be formed by dict\\n          boolean[] dp = new boolean[n];\\n          \\n          for (int i = 0; i < n; i++) {\\n              for (int j = 0; j <= i; j++) {\\n                  String sub = s.substring(j, i + 1);\\n                  \\n                  if (dict.contains(sub) && (j == 0 || dp[j - 1])) {\\n                      dp[i] = true;\\n                      break;\\n                  }\\n              }\\n          }\\n          \\n          return dp[n - 1];\\n      }\\n    \\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        \\n      public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> res = new ArrayList<String>();\\n        // Do a fast check and see if we can break the input string\\n        if (!canBreak(s, dict))\\n          return res;\\n        \\n        helper(s, dict, 0, \"\", res);\\n        return res;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2191120,
                "title": "trie-dp-100-faster-c",
                "content": "\\tstruct Node{\\n\\t\\tbool end=false;\\n\\t\\tNode* charset[26];\\n\\n\\t\\tbool containsChar(char ch){\\n\\t\\t\\treturn charset[ch-\\'a\\']!= NULL;\\n\\t\\t}\\n\\n\\t\\tNode* getNode(char ch){\\n\\t\\t\\treturn charset[ch-\\'a\\'];\\n\\t\\t}\\n\\n\\t\\tvoid putChar(char ch, Node* node){\\n\\t\\t\\tcharset[ch-\\'a\\']= node;\\n\\t\\t}\\n\\n\\t};\\n\\n\\n\\tclass Trie{\\n\\t\\tpublic:\\n\\t\\t\\tNode* root;\\n\\t\\tpublic: \\n\\t\\t\\tTrie(){\\n\\t\\t\\t\\troot = new Node();\\n\\t\\t\\t}\\n\\t\\tpublic:\\n\\t\\t\\tvoid insertNode(string s){\\n\\t\\t\\t\\tNode* node = root;\\n\\t\\t\\t\\tfor(int i=0; i<s.size(); i++){\\n\\t\\t\\t\\t\\tif(!node->containsChar(s[i])){\\n\\t\\t\\t\\t\\t\\t\\tnode->putChar(s[i], new Node());\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnode = node->getNode(s[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnode->end = true;\\n\\t\\t\\t}\\n\\t};\\n\\n\\n\\n\\tclass Solution {\\n\\n\\t\\t// sentences function returns the possible sentences as vector of its words,\\n\\t\\t// using words from wordDict and considering the substring\\n\\t\\t// of s  from position pos to end of s .\\n\\n\\n\\tpublic:\\n\\t\\tvector<vector<string>> sentences(string &s,int pos,Node* root,unordered_map<int,vector<vector<string>>> &mem){\\n\\t\\t\\tif(pos>=s.size())\\n\\t\\t\\t\\treturn {{\"\"}};\\n\\n\\t\\t\\tif(mem.find(pos) != mem.end())\\n\\t\\t\\t\\treturn mem[pos];\\n\\n\\t\\t\\tvector<vector<string>> ans,subans;\\n\\t\\t\\tstring temp=\"\";\\n\\n\\t\\t\\t// from pos we iterate and try to find a word in wordDict if exists then move to next substring \\n\\t\\t\\t// and get the possible sentences from it, then append the word found in current call to it.\\n\\t\\t\\t// say we found that cat is a word from wordDict, \\n\\t\\t\\t// again if we find cats is also a word from wordDict, checking it will take O(1) if we use trie\\n\\t\\t\\t// we don\\'t have to check for cats once we found cat , we only check for s after cat\\n\\t\\t\\tNode* node = root;\\n\\t\\t\\tfor(int i=pos; i<s.size(); i++){\\n\\t\\t\\t\\ttemp += s[i];\\n\\t\\t\\t\\tnode= node->getNode(s[i]);\\n\\t\\t\\t\\t// if cats doesn\\'t exist catsa won\\'t exist. \\n\\t\\t\\t\\tif(!node)\\n\\t\\t\\t\\t\\treturn ans;\\n\\n\\t\\t\\t\\tif(node->end){\\n\\n\\t\\t\\t\\t\\tsubans = sentences(s,i+1, root,mem);\\n\\n\\t\\t\\t\\t\\tif(subans.size()>0){\\n\\t\\t\\t\\t\\t\\tfor(int i=0; i<subans.size(); i++){\\n\\t\\t\\t\\t\\t\\t\\tif(subans[i][0].size()==0)\\n\\t\\t\\t\\t\\t\\t\\t\\tsubans[i][0]= temp;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tsubans[i].push_back(temp);\\n\\n\\t\\t\\t\\t\\t\\t\\tans.push_back(subans[i]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tmem[pos]= ans;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tvector<string> wordBreak(string s, vector<string>& wordDict) {\\n\\t\\t\\tTrie trie;\\n\\t\\t\\tfor(string s: wordDict){\\n\\t\\t\\t\\ttrie.insertNode(s);\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<vector<string>> ans;\\n\\t\\t\\tunordered_map<int,vector<vector<string>>> mem;\\n\\t\\t\\tans= sentences(s,0,trie.root,mem);\\n\\n\\t\\t\\tvector<string> sentences;\\n\\n\\t\\t\\t// make the possible sentences from words of each possible string\\n\\t\\t\\tfor(vector<string> v: ans){\\n\\t\\t\\t\\tstring temp= v.back();\\n\\t\\t\\t\\tfor(int i=v.size()-2; i>=0; i--){\\n\\t\\t\\t\\t\\ttemp += \" \"+v[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsentences.push_back(temp);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn sentences;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "class Solution {\\n\\n\\t\\t// sentences function returns the possible sentences as vector of its words,\\n\\t\\t// using words from wordDict and considering the substring\\n\\t\\t// of s  from position pos to end of s .\\n\\n\\n\\tpublic:\\n\\t\\tvector<vector<string>> sentences(string &s,int pos,Node* root,unordered_map<int,vector<vector<string>>> &mem){\\n\\t\\t\\tif(pos>=s.size())\\n\\t\\t\\t\\treturn {{\"\"}",
                "codeTag": "Java"
            },
            {
                "id": 44287,
                "title": "java-beating-95-13-with-explanation-dfs-memoization-to-avoid-tle",
                "content": "Basically the idea is to use a boolean array to avoid repeated computation.\\nboolean[] invalid = new boolean[s.length()+1]\\ninvalid[i] means whether s.substring(i) is \"not breakable\"\\nThe helper function will return a boolean value whether the substring is \"breakable\" or not.\\nFor each call to helper function, denote current substring as [left, s.length()). Iterate right pointer i from left+1 to s.length(). If [left, i) can be found in the dict, and [i, s.length()) is \"breakable\", then the whole [left, s.length()) is \"breakable\".\\n\\n     /**\\n     * Leetcode 140. Word Break II.\\n     * https://leetcode.com/problems/word-break-ii/\\n     * Keyword: DFS, backtracking\\n     *\\n     * @param s        string to break\\n     * @param wordDict word dictionary\\n     * @return all the possible ways to break the string into words in the dictionary\\n     */\\n    public List<String> wordBreak2(String s, Set<String> wordDict) {\\n        List<String> res = new ArrayList<>();\\n        wordBreak2(s, 0, wordDict, \"\", new boolean[s.length() + 1], res);\\n        return res;\\n    }\\n\\n    /**\\n     * Helper function for Leetcode 140. Word Break II.\\n     *\\n     * @param s        string to break\\n     * @param left     start point\\n     * @param wordDict dictionary\\n     * @param prev     previous word found\\n     * @param invalid  invalid[i] means whether [i, s.length()) is unbreakable\\n     * @param res      list to store results\\n     * @return true if s.substring(left) is breakable.\\n     */\\n    private boolean wordBreak2(String s, int left, Set<String> wordDict, String prev, boolean[] invalid, List<String> res) {\\n        // Base case: successfully moved to the end, add result to the list.\\n        if (left == s.length()) {\\n            res.add(prev.trim());\\n            return true;\\n        }\\n        // whether s.substring(left) is breakable\\n        boolean possible = false;\\n        // iterate the pointer from left+1 to the end, find whether [left, i) is valid\\n        for (int i = left + 1; i <= s.length(); i++) {\\n            // if s.substring(i) is unbreakable, continue\\n            if (invalid[i]) {\\n                continue;\\n            }\\n            String sub = s.substring(left, i);\\n            // if substring [left,i) is valid, move on and break from i\\n            if (wordDict.contains(sub)) {\\n                boolean flag = wordBreak2(s, i, wordDict, prev.concat(\" \").concat(sub), invalid, res);\\n                // as long as at least one valid substring [i, end), possible is true\\n                possible = flag || possible;\\n            }\\n        }\\n        // update invalid array\\n        invalid[left] = !possible;\\n        return possible;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Basically the idea is to use a boolean array to avoid repeated computation.\\nboolean[] invalid = new boolean[s.length()+1]\\ninvalid[i] means whether s.substring(i) is \"not breakable\"\\nThe helper function will return a boolean value whether the substring is \"breakable\" or not.\\nFor each call to helper function, denote current substring as [left, s.length()). Iterate right pointer i from left+1 to s.length(). If [left, i) can be found in the dict, and [i, s.length()) is \"breakable\", then the whole [left, s.length()) is \"breakable\".\\n\\n     /**\\n     * Leetcode 140. Word Break II.\\n     * https://leetcode.com/problems/word-break-ii/\\n     * Keyword: DFS, backtracking\\n     *\\n     * @param s        string to break\\n     * @param wordDict word dictionary\\n     * @return all the possible ways to break the string into words in the dictionary\\n     */\\n    public List<String> wordBreak2(String s, Set<String> wordDict) {\\n        List<String> res = new ArrayList<>();\\n        wordBreak2(s, 0, wordDict, \"\", new boolean[s.length() + 1], res);\\n        return res;\\n    }\\n\\n    /**\\n     * Helper function for Leetcode 140. Word Break II.\\n     *\\n     * @param s        string to break\\n     * @param left     start point\\n     * @param wordDict dictionary\\n     * @param prev     previous word found\\n     * @param invalid  invalid[i] means whether [i, s.length()) is unbreakable\\n     * @param res      list to store results\\n     * @return true if s.substring(left) is breakable.\\n     */\\n    private boolean wordBreak2(String s, int left, Set<String> wordDict, String prev, boolean[] invalid, List<String> res) {\\n        // Base case: successfully moved to the end, add result to the list.\\n        if (left == s.length()) {\\n            res.add(prev.trim());\\n            return true;\\n        }\\n        // whether s.substring(left) is breakable\\n        boolean possible = false;\\n        // iterate the pointer from left+1 to the end, find whether [left, i) is valid\\n        for (int i = left + 1; i <= s.length(); i++) {\\n            // if s.substring(i) is unbreakable, continue\\n            if (invalid[i]) {\\n                continue;\\n            }\\n            String sub = s.substring(left, i);\\n            // if substring [left,i) is valid, move on and break from i\\n            if (wordDict.contains(sub)) {\\n                boolean flag = wordBreak2(s, i, wordDict, prev.concat(\" \").concat(sub), invalid, res);\\n                // as long as at least one valid substring [i, end), possible is true\\n                possible = flag || possible;\\n            }\\n        }\\n        // update invalid array\\n        invalid[left] = !possible;\\n        return possible;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44291,
                "title": "concise-java-solution-recursion-memoization",
                "content": "    public class Solution {\\n    Map<String, List<String>> mem = new HashMap<>();\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        if (mem.get(s) != null) return mem.get(s);\\n        List<String> result = new ArrayList<>();\\n        if (wordDict.contains(s)) result.add(s);\\n        for (int i = 1; i < s.length(); i++) {\\n            String word = s.substring(0, i);\\n            if (wordDict.contains(word)) {\\n                List<String> tmp = wordBreak(s.substring(i), wordDict);\\n                for (String str : tmp) {\\n                    result.add(word + \" \" + str);\\n                }\\n            }\\n        }\\n        mem.put(s, result);\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "class Solution {\\n    Map<String, List<String>> mem = new HashMap<>();\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        if (mem.get(s) != null) return mem.get(s);\\n        List<String> result = new ArrayList<>();\\n        if (wordDict.contains(s)) result.add(s);\\n        for (int i = 1; i < s.length(); i++) {\\n            String word = s.substring(0, i);\\n            if (wordDict.contains(word)) {\\n                List<String> tmp = wordBreak(s.substring(i), wordDict);\\n                for (String str : tmp) {\\n                    result.add(word + \" \" + str);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 44446,
                "title": "this-is-my-accepted-java-version-program-is-there-any-better-solution",
                "content": "This is my solution. I use DP- with a hashmap recording all the strings that are computed before. \\nMy idea is simple, just partition the string from the first character until the last character. Each time the string is divided into two parts: left and right. Only if the left string exists in the dict, we will try to get all of the combinations of the right string. And then form the list of combinations of the left and right.\\n\\nThe time complexity is O(n^2). Is there any better run time solution?\\n\\n    public class Solution {\\n    HashMap<String, List<String>> map= new HashMap<String, List<String>>();\\n    public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> list=new ArrayList<String>();\\n                \\n        if(map.containsKey(s)) return map.get(s);\\n        \\n        for(int i=1; i<=s.length();i++){\\n            String left=s.substring(0,i);\\n            String right=s.substring(i);\\n            if(dict.contains(left)){\\n                List<String> a=wordBreak(right, dict);\\n                for(String b:a){\\n                    list.add(left+\" \"+b);\\n                }\\n                if(right.length()==0) list.add(left);\\n            }\\n            \\n        }\\n   \\n        map.put(s, list);\\n        return list;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    HashMap<String, List<String>> map= new HashMap<String, List<String>>();\\n    public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> list=new ArrayList<String>();\\n                \\n        if(map.containsKey(s)) return map.get(s);\\n        \\n        for(int i=1; i<=s.length();i++){\\n            String left=s.substring(0,i);\\n            String right=s.substring(i);\\n            if(dict.contains(left)){\\n                List<String> a=wordBreak(right, dict);\\n                for(String b:a){\\n                    list.add(left+\" \"+b);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3106566,
                "title": "beats-100-c-dp-very-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust like word break I here we just have to check prefix substrings are prsnt or not if yes keep adding them uo and graudaully it keeps growing downwards and atlast dp[n] will store the all the strings mad efrom dictionary. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**DP**\\n# Complexity\\n- Time complexity:$$O(N^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n        \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(dp[i].size() > 0 && word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n         return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n        \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(dp[i].size() > 0 && word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n         return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246823,
                "title": "c-0ms-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<string>> memo; //using for memoization (though only recurssive solution can get accepted but for the sake of learning dp)\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        if(memo.find(s) != memo.end()) return memo[s]; //if the target string found in memo, return the vector;\\n        \\n        vector<string> ans; \\n        \\n        //Base case: s = empty string\\n        if(s == \"\"){\\n            ans.push_back(\"\");\\n            return ans;\\n        }\\n        \\n        //else check for every possiblility in wordDict\\n        //which is found in our target string s\\n        \\n        for(const auto word: wordDict){\\n            \\n            //the word which is found at start will only lead to valid possiblities further\\n            if(s.find(word) == 0){\\n                \\n                string remain = s.substr(word.length()); //get the remaining substring \\n                \\n                vector<string> remainAns;\\n                \\n                remainAns = wordBreak(remain , wordDict); //vector<string1,string2, ...>\\n\\n                for(int i=0; i<remainAns.size(); i++){\\n                    \\n                    //add the word to the output string\\n                    if(remainAns[i] == \"\"){     \\n                        remainAns[i] = word;    // e.g 1) remainAns[i] = \"dog\"\\n                    }\\n                    else{\\n                        remainAns[i] = word + \" \" + remainAns[i];  //e.g 2) remainAns[i] = \"and dog\"\\n                    }\\n                    ans.push_back(remainAns[i]);\\n                }\\n            }\\n        }\\n        memo[s] = ans; //storing it in memo for future help\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<string>> memo; //using for memoization (though only recurssive solution can get accepted but for the sake of learning dp)\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        if(memo.find(s) != memo.end()) return memo[s]; //if the target string found in memo, return the vector;\\n        \\n        vector<string> ans; \\n        \\n        //Base case: s = empty string\\n        if(s == \"\"){\\n            ans.push_back(\"\");\\n            return ans;\\n        }\\n        \\n        //else check for every possiblility in wordDict\\n        //which is found in our target string s\\n        \\n        for(const auto word: wordDict){\\n            \\n            //the word which is found at start will only lead to valid possiblities further\\n            if(s.find(word) == 0){\\n                \\n                string remain = s.substr(word.length()); //get the remaining substring \\n                \\n                vector<string> remainAns;\\n                \\n                remainAns = wordBreak(remain , wordDict); //vector<string1,string2, ...>\\n\\n                for(int i=0; i<remainAns.size(); i++){\\n                    \\n                    //add the word to the output string\\n                    if(remainAns[i] == \"\"){     \\n                        remainAns[i] = word;    // e.g 1) remainAns[i] = \"dog\"\\n                    }\\n                    else{\\n                        remainAns[i] = word + \" \" + remainAns[i];  //e.g 2) remainAns[i] = \"and dog\"\\n                    }\\n                    ans.push_back(remainAns[i]);\\n                }\\n            }\\n        }\\n        memo[s] = ans; //storing it in memo for future help\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526377,
                "title": "accepted-c-backtracking-solution-memoization",
                "content": "```\\n    public class Solution\\n    {\\n        private IList<string> Helper(ref string s, int idx, IList<string>[] cache, ISet<string> set)\\n        {\\n            if (cache[idx] != null)\\n            {\\n                return cache[idx];\\n            }\\n\\n            IList<string> res = new List<string>();\\n\\n            for (int l = 1; l <= s.Length - idx; l++)\\n            {\\n                var word = s.Substring(idx, l);\\n                if (set.Contains(word))\\n                {\\n                    var next = idx + l;\\n                    if (next == s.Length)\\n                    {\\n                        res.Add(word);\\n                    }\\n                    else\\n                    {\\n                        var inner = Helper(ref s, next, cache, set);\\n                        foreach (var subsentence in inner)\\n                        {\\n                            res.Add($\"{word} {subsentence}\");\\n                        }\\n                    }\\n                }\\n            }\\n\\n            cache[idx] = res;\\n            return res;\\n        }\\n\\n        public IList<string> WordBreak(string s, IList<string> wordDict)\\n        {\\n            IList<string>[] cache = new IList<string>[s.Length];\\n            ISet<string> set = wordDict.ToHashSet();\\n            var res = Helper(ref s, 0, cache, set);\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private IList<string> Helper(ref string s, int idx, IList<string>[] cache, ISet<string> set)\\n        {\\n            if (cache[idx] != null)\\n            {\\n                return cache[idx];\\n            }\\n\\n            IList<string> res = new List<string>();\\n\\n            for (int l = 1; l <= s.Length - idx; l++)\\n            {\\n                var word = s.Substring(idx, l);\\n                if (set.Contains(word))\\n                {\\n                    var next = idx + l;\\n                    if (next == s.Length)\\n                    {\\n                        res.Add(word);\\n                    }\\n                    else\\n                    {\\n                        var inner = Helper(ref s, next, cache, set);\\n                        foreach (var subsentence in inner)\\n                        {\\n                            res.Add($\"{word} {subsentence}\");\\n                        }\\n                    }\\n                }\\n            }\\n\\n            cache[idx] = res;\\n            return res;\\n        }\\n\\n        public IList<string> WordBreak(string s, IList<string> wordDict)\\n        {\\n            IList<string>[] cache = new IList<string>[s.Length];\\n            ISet<string> set = wordDict.ToHashSet();\\n            var res = Helper(ref s, 0, cache, set);\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482162,
                "title": "java-bruteforce-memorized-dfs-approach-clean-code-9ms",
                "content": "**Apprach 1: Bruteforce - TLE**\\n```java\\nclass Solution {\\n    List<String> result = new LinkedList<>();\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        result.clear();\\n        backtracking(s, 0, new HashSet<>(wordDict), new LinkedList<>(), \"\");\\n        return result;\\n    }\\n\\n    private void backtracking(String s, int step, HashSet<String> wordDict, LinkedList<String> output, String temp) {\\n        if (step == s.length()) {\\n            if (output.size() > 0) {\\n                result.add(String.join(\" \", output));\\n            }\\n            return;\\n        }\\n\\n        for (int i = step; i < s.length(); i++) {\\n            temp += s.charAt(i);\\n            if (wordDict.contains(temp)) { // existed in the wordDict\\n                output.add(temp);\\n                backtracking(s, i + 1, wordDict, output, \"\");\\n                output.removeLast();\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**Approach 2: DFS + Memorized - 9ms**\\n```java\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return DFS(s, wordDict, new HashMap<>());\\n    }\\n\\n    private List<String> DFS(String s, List<String> wordDict, Map<String, List<String>> cache) {\\n        if (cache.containsKey(s)) return cache.get(s);\\n        List<String> res = new LinkedList<>();\\n        if (s.length() == 0) { // found an answer\\n            res.add(\"\");\\n        } else {\\n            for (String word : wordDict) {\\n                if (s.startsWith(word)) {\\n                    List<String> subList = DFS(s.substring(word.length()), wordDict, cache);\\n                    for (String sub : subList) {\\n                        if (sub.isEmpty())\\n                            res.add(word);\\n                        else\\n                            res.add(word + \" \" + sub);\\n                    }\\n                }\\n            }\\n        }\\n        cache.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    List<String> result = new LinkedList<>();\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        result.clear();\\n        backtracking(s, 0, new HashSet<>(wordDict), new LinkedList<>(), \"\");\\n        return result;\\n    }\\n\\n    private void backtracking(String s, int step, HashSet<String> wordDict, LinkedList<String> output, String temp) {\\n        if (step == s.length()) {\\n            if (output.size() > 0) {\\n                result.add(String.join(\" \", output));\\n            }\\n            return;\\n        }\\n\\n        for (int i = step; i < s.length(); i++) {\\n            temp += s.charAt(i);\\n            if (wordDict.contains(temp)) { // existed in the wordDict\\n                output.add(temp);\\n                backtracking(s, i + 1, wordDict, output, \"\");\\n                output.removeLast();\\n            }\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return DFS(s, wordDict, new HashMap<>());\\n    }\\n\\n    private List<String> DFS(String s, List<String> wordDict, Map<String, List<String>> cache) {\\n        if (cache.containsKey(s)) return cache.get(s);\\n        List<String> res = new LinkedList<>();\\n        if (s.length() == 0) { // found an answer\\n            res.add(\"\");\\n        } else {\\n            for (String word : wordDict) {\\n                if (s.startsWith(word)) {\\n                    List<String> subList = DFS(s.substring(word.length()), wordDict, cache);\\n                    for (String sub : subList) {\\n                        if (sub.isEmpty())\\n                            res.add(word);\\n                        else\\n                            res.add(word + \" \" + sub);\\n                    }\\n                }\\n            }\\n        }\\n        cache.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44258,
                "title": "python-dfs-solution-o-mn-n-running-time",
                "content": "    class Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        #running time: O(mn^2), n = len(s), m = len(wordDict)\\n        \"\"\"\\n        Let\\u2018s say the average word length in wordDict is k, so it takes n/k times to reach end.\\n        Each time, the helper function would be called and it's running time is O(m*n)\\n        So the whole runinng time  would be O( m*n*n/k), which is O(m*n^2)\\n        \"\"\"\\n        dic=collections.defaultdict(list)\\n        \\n        def helper(s):\\n            if not s: return [None]\\n            if s in dic: return dic[s]\\n            res =[]\\n            for word in wordDict:\\n                n = len(word)\\n                if word == s[:n]:\\n                    for each in helper(s[n:]):\\n                        if each:res.append(word+\" \"+each)\\n                        else: res.append(word)\\n                dic[s] = res\\n            return res\\n        \\n        return helper(s)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "    class Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        #running time: O(mn^2), n = len(s), m = len(wordDict)\\n        \"\"\"\\n        Let\\u2018s say the average word length in wordDict is k, so it takes n/k times to reach end.\\n        Each time, the helper function would be called and it's running time is O(m*n)\\n        So the whole runinng time  would be O( m*n*n/k), which is O(m*n^2)\\n        \"\"\"\\n        dic=collections.defaultdict(list)\\n        \\n        def helper(s):\\n            if not s: return [None]\\n            if s in dic: return dic[s]\\n            res =[]\\n            for word in wordDict:\\n                n = len(word)\\n                if word == s[:n]:\\n                    for each in helper(s[n:]):\\n                        if each:res.append(word+\" \"+each)\\n                        else: res.append(word)\\n                dic[s] = res\\n            return res\\n        \\n        return helper(s)",
                "codeTag": "Java"
            },
            {
                "id": 3332872,
                "title": "c-memoization-trie-well-explained-solution-faster-than-100",
                "content": "**Intuition :**\\n\\nAs we can see, this problem invoves **forward partitioning**, i.e., we have to create partitions at all the gaps between letters and check for the condition:\\n* If the substring generated by partitioning is present in the dictionary, we can continue from the next letter and store the created string in a temporary variable. While returning, concatenate the generated strings with the stored temporary one. \\n\\n\\n* e.g., ![image](https://assets.leetcode.com/users/images/55459ded-54f5-4d25-9574-7839f4560a63_1679586683.848477.jpeg)\\n\\nThus, as we have to search for every partition, we can do DP here for minimising the **outer Time Complexity** to be O(n^2) instead of O(2^n) by normal recursive approach.\\n\\nAlso, as we have to search for words in the dict, we can use set or map but **trie** is a better option according to the time needed.\\n\\nSo, at first, all the words of dictiionary are stored in the trie. \\nNow, a recursive function is called with the **string s**, root of the trie and the index (initially 0).\\n\\nInternally, it is checked if after a partition (rather traversing the trie), we reach at the end of a word, we store it in temp variable and call from the next index and the root of the trie itself (as shown in the figure).\\n\\n**The code :**\\n```\\nstruct Node {\\n    Node * links[26];\\n    bool flag=false;\\n    \\n    bool containsKey (char ch){\\n        return (links[ch-\\'a\\']!=NULL);\\n    }\\n    \\n    void put (char ch, Node * node){\\n        links[ch-\\'a\\']=node;\\n    }\\n    \\n    Node * get (char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    \\n    void setEnd() {\\n        flag=true;\\n    }\\n    \\n    bool isEnd () {\\n        return flag;\\n    }\\n};\\n\\n\\nclass Trie { \\n    \\npublic:\\n    \\n    Node * root;\\n    \\n    Trie() {\\n        root= new Node();\\n    }\\n    \\n    void insert(string word) {\\n        Node * node=root;\\n        for (int i=0;i<word.length();i++){\\n            if (! node->containsKey(word[i])){\\n                node->put(word[i], new Node());\\n            }\\n            //pointing to reference node\\n            node=node->get(word[i]);\\n        }\\n        // marking done\\n        node->setEnd();\\n    }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<string> solve (string s, int start, unordered_map <int, vector<string>> &mp, Node * root){\\n        \\n        if (mp.find(start)!=mp.end()) return mp[start];\\n        \\n        int n = s.length();\\n        vector<string> res;\\n        \\n        if (start==n){\\n            res.push_back(\"\");\\n            return mp[start]=res;\\n        }\\n        \\n        Node * cur=root;\\n        \\n        for (int i=start;i<n;i++){\\n            if (! cur->containsKey(s[i])) break;\\n            \\n            cur=cur->get(s[i]);\\n            if (cur->isEnd()){\\n                string temp= s.substr(start, i-start+1);\\n                if (i<s.length()-1){\\n                    temp+=\" \";\\n                }\\n                \\n                vector<string> temp2= solve(s,i+1,mp,root);\\n                for (string a:temp2){\\n                    string temp3=temp+a;\\n                    res.push_back(temp3);\\n                }\\n            }\\n        }\\n        return mp[start]=res;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        Trie trie;\\n        for (auto &temp : wordDict){\\n            trie.insert(temp);\\n        }\\n        unordered_map <int, vector<string>> mp;\\n        return solve (s,0,mp,trie.root);\\n    }\\n};\\n```\\nNote :\\n```\\ns.substr(i,j)= substring of s starting from index i and length j.\\n```\\n\\n**If you like the solution, do upvote.**",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nstruct Node {\\n    Node * links[26];\\n    bool flag=false;\\n    \\n    bool containsKey (char ch){\\n        return (links[ch-\\'a\\']!=NULL);\\n    }\\n    \\n    void put (char ch, Node * node){\\n        links[ch-\\'a\\']=node;\\n    }\\n    \\n    Node * get (char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    \\n    void setEnd() {\\n        flag=true;\\n    }\\n    \\n    bool isEnd () {\\n        return flag;\\n    }\\n};\\n\\n\\nclass Trie { \\n    \\npublic:\\n    \\n    Node * root;\\n    \\n    Trie() {\\n        root= new Node();\\n    }\\n    \\n    void insert(string word) {\\n        Node * node=root;\\n        for (int i=0;i<word.length();i++){\\n            if (! node->containsKey(word[i])){\\n                node->put(word[i], new Node());\\n            }\\n            //pointing to reference node\\n            node=node->get(word[i]);\\n        }\\n        // marking done\\n        node->setEnd();\\n    }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<string> solve (string s, int start, unordered_map <int, vector<string>> &mp, Node * root){\\n        \\n        if (mp.find(start)!=mp.end()) return mp[start];\\n        \\n        int n = s.length();\\n        vector<string> res;\\n        \\n        if (start==n){\\n            res.push_back(\"\");\\n            return mp[start]=res;\\n        }\\n        \\n        Node * cur=root;\\n        \\n        for (int i=start;i<n;i++){\\n            if (! cur->containsKey(s[i])) break;\\n            \\n            cur=cur->get(s[i]);\\n            if (cur->isEnd()){\\n                string temp= s.substr(start, i-start+1);\\n                if (i<s.length()-1){\\n                    temp+=\" \";\\n                }\\n                \\n                vector<string> temp2= solve(s,i+1,mp,root);\\n                for (string a:temp2){\\n                    string temp3=temp+a;\\n                    res.push_back(temp3);\\n                }\\n            }\\n        }\\n        return mp[start]=res;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        Trie trie;\\n        for (auto &temp : wordDict){\\n            trie.insert(temp);\\n        }\\n        unordered_map <int, vector<string>> mp;\\n        return solve (s,0,mp,trie.root);\\n    }\\n};\\n```\n```\\ns.substr(i,j)= substring of s starting from index i and length j.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144682,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    void find(string s, unordered_set<string> st, int ind, string cur)\\n    {\\n        if(ind==s.size())\\n        {\\n            cur.pop_back();\\n            res.push_back(cur);\\n        }\\n        string a=\"\";\\n        for(int i=ind; i<s.size();i++)\\n        {\\n            string sub=s.substr(ind, i-ind+1);\\n            if(st.find(sub)!=st.end())\\n            {\\n                find(s, st, i+1, cur+sub+\" \");\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& dict) {\\n        unordered_set<string> st;\\n        for(string a:dict)\\n        st.insert(a);\\n        find(s, st, 0, \"\");\\n        return res;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    void find(string s, unordered_set<string> st, int ind, string cur)\\n    {\\n        if(ind==s.size())\\n        {\\n            cur.pop_back();\\n            res.push_back(cur);\\n        }\\n        string a=\"\";\\n        for(int i=ind; i<s.size();i++)\\n        {\\n            string sub=s.substr(ind, i-ind+1);\\n            if(st.find(sub)!=st.end())\\n            {\\n                find(s, st, i+1, cur+sub+\" \");\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& dict) {\\n        unordered_set<string> st;\\n        for(string a:dict)\\n        st.insert(a);\\n        find(s, st, 0, \"\");\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679588,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<int,vector<string>> hm;\\n        unordered_set<string> hs(wordDict.begin(),wordDict.end());\\n        return wordBreakHelper(s, 0, hs, hm);\\n    }\\n\\t\\n    vector<string> wordBreakHelper(string s, int start, unordered_set<string> dict, unordered_map<int,vector<string>> hm ){\\n    if (hm.find(start)!=hm.end())\\n        return hm[start]; \\n\\n    vector<string> validSubstr;\\n\\n    if (start == s.size())\\n        validSubstr.push_back(\"\");\\n\\n    for (int end = start + 1; end <= s.size(); end++) {\\n        string prefix = s.substr(start, end-start);\\n        if (dict.find(prefix)!=dict.end()) //check if prefix is present in dict\\n\\t\\t{\\n            vector<string> suffixes = wordBreakHelper(s, end, dict, hm); //calculate valid sentences for remaining part\\n            for (string suffix : suffixes)\\n               validSubstr.push_back(prefix + (suffix==\"\" ? \"\" : \" \") + suffix);  //combine with prefixe\\n        }\\n    }\\n \\n    hm.insert({start, validSubstr}); //store the result\\n    return validSubstr;\\n }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<int,vector<string>> hm;\\n        unordered_set<string> hs(wordDict.begin(),wordDict.end());\\n        return wordBreakHelper(s, 0, hs, hm);\\n    }\\n\\t\\n    vector<string> wordBreakHelper(string s, int start, unordered_set<string> dict, unordered_map<int,vector<string>> hm ){\\n    if (hm.find(start)!=hm.end())\\n        return hm[start]; \\n\\n    vector<string> validSubstr;\\n\\n    if (start == s.size())\\n        validSubstr.push_back(\"\");\\n\\n    for (int end = start + 1; end <= s.size(); end++) {\\n        string prefix = s.substr(start, end-start);\\n        if (dict.find(prefix)!=dict.end()) //check if prefix is present in dict\\n\\t\\t{\\n            vector<string> suffixes = wordBreakHelper(s, end, dict, hm); //calculate valid sentences for remaining part\\n            for (string suffix : suffixes)\\n               validSubstr.push_back(prefix + (suffix==\"\" ? \"\" : \" \") + suffix);  //combine with prefixe\\n        }\\n    }\\n \\n    hm.insert({start, validSubstr}); //store the result\\n    return validSubstr;\\n }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602252,
                "title": "time-beats-99-83-space-beats-88-35",
                "content": "**Explanation**: Whenever I say \"path\", I mean the sequence of words that can be spaced out and appended to our answer. I will be using the word \"path\" a lot to illustrate how this problem is pretty much the combination of [257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/) and [139. Word Break](https://leetcode.com/problems/word-break/). Before continuing, I recommend solving the 2 problems that I linked. Essentially, we are constructing all valid \"paths\" that \"might\" lead us to a solution. When we reach the base case, we know that we constructed a valid \"path\", and we therefore append the \"path\" to the result.\\n\\nBelow is the code, please let me know if you have any questions!\\n```\\nclass Solution:\\n    def _wordBreak(self, s, wordDict, start, cur, res):\\n        # Base Case\\n        if start == len(s) and cur:\\n            res.append(\\' \\'.join(cur))\\n            \\n        for i in range(start, len(s)):\\n            word = s[start: i+1]\\n            \\n            if word in wordDict:\\n                \\n                # Append the word since it is in the dictionary\\n                cur.append(word)\\n                \\n                # Recursive Step\\n                self._wordBreak(s, wordDict, i+1, cur, res)\\n                \\n                # Backtracking / Post-processing / Pop the word we appended\\n                cur.pop()\\n        \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res = []\\n        self._wordBreak(s, set(wordDict), 0, [], res)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def _wordBreak(self, s, wordDict, start, cur, res):\\n        # Base Case\\n        if start == len(s) and cur:\\n            res.append(\\' \\'.join(cur))\\n            \\n        for i in range(start, len(s)):\\n            word = s[start: i+1]\\n            \\n            if word in wordDict:\\n                \\n                # Append the word since it is in the dictionary\\n                cur.append(word)\\n                \\n                # Recursive Step\\n                self._wordBreak(s, wordDict, i+1, cur, res)\\n                \\n                # Backtracking / Post-processing / Pop the word we appended\\n                cur.pop()\\n        \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res = []\\n        self._wordBreak(s, set(wordDict), 0, [], res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260118,
                "title": "c-easy-backtracking",
                "content": "```\\nvoid wb(vector<string>& res, vector<string>& dict, string s, int idx, int n, string str)\\n   {\\n       if(idx == n)\\n        {\\n            str.pop_back();\\n            res.push_back(str);\\n        }\\n        else\\n        {\\n            for(int k = idx; k < n; k++)\\n            {\\n                string temp = s.substr(idx, k - idx + 1);\\n                if(find(dict.begin(), dict.end(), temp) != dict.end())\\n                   wb(res, dict, s, k + 1, n, str + temp + \\' \\');\\n             }\\n        }\\n   }\\n\\n   vector<string> wordBreak(string s, vector<string>& dict) \\n    {\\n        vector<string> res;\\n        wb(res, dict, s, 0, s.size(), \"\");\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvoid wb(vector<string>& res, vector<string>& dict, string s, int idx, int n, string str)\\n   {\\n       if(idx == n)\\n        {\\n            str.pop_back();\\n            res.push_back(str);\\n        }\\n        else\\n        {\\n            for(int k = idx; k < n; k++)\\n            {\\n                string temp = s.substr(idx, k - idx + 1);\\n                if(find(dict.begin(), dict.end(), temp) != dict.end())\\n                   wb(res, dict, s, k + 1, n, str + temp + \\' \\');\\n             }\\n        }\\n   }\\n\\n   vector<string> wordBreak(string s, vector<string>& dict) \\n    {\\n        vector<string> res;\\n        wb(res, dict, s, 0, s.size(), \"\");\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 763538,
                "title": "java-dp-backtracking",
                "content": "```\\nclass Solution {\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n        List<String>[] str = DP(s, wordDict, dp);\\n        if(!dp[n]) return Collections.emptyList();\\n\\n        List<String> result = new LinkedList<>();\\n        StringBuilder builder = new StringBuilder();\\n        backtracking(result, builder, 0, str);\\n        return result;\\n    }\\n\\n    private void backtracking(List<String> result, StringBuilder builder, int index, List<String>[] str) {\\n\\n        if(index == str.length - 1) {\\n            result.add(builder.deleteCharAt(builder.length() - 1).toString());\\n            return;\\n        }\\n        List<String> list = str[index];\\n        for(String next : list) {\\n            int size = builder.length();\\n            builder.append(next);\\n            builder.append(\" \");\\n            backtracking(result, builder, index + next.length(), str);\\n            builder.delete(size, builder.length());\\n        }\\n\\n    }\\n\\n    private List<String>[] DP(String s, List<String> wordDict, boolean[] dp) {\\n\\n        List<String>[] str = new List[dp.length];\\n        for(int i = 0; i < dp.length - 1; i++) {\\n            if(dp[i]) {\\n                List<String> list = new LinkedList<>();\\n                for (String word: wordDict) {\\n                    if(s.indexOf(word, i) == i) {\\n                        dp[i + word.length()] = true;\\n                        list.add(word);\\n                    }\\n                }\\n                str[i] = list;\\n            }\\n        }\\n        return str;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n        List<String>[] str = DP(s, wordDict, dp);\\n        if(!dp[n]) return Collections.emptyList();\\n\\n        List<String> result = new LinkedList<>();\\n        StringBuilder builder = new StringBuilder();\\n        backtracking(result, builder, 0, str);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 44286,
                "title": "java-solution-with-memorization",
                "content": "```\\nprivate Map<String, List<String>> map = new HashMap<>();\\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        if (map.containsKey(s)) {\\n            return map.get(s);\\n        }\\n        List<String> list = new ArrayList<>();\\n        if (wordDict.contains(s)) {\\n            list.add(s);\\n        }\\n        for (int i = 1; i < s.length(); i++) {\\n            String word = s.substring(i);\\n            if (wordDict.contains(word)) {\\n                List<String> prior = wordBreak(s.substring(0, i), wordDict);\\n                for (String s1 : prior) {\\n                    list.add(s1 + \" \" + word);\\n                }\\n            }\\n        }\\n        map.put(s, list);\\n        return list;\\n    }\\n````",
                "solutionTags": [],
                "code": "```\\nprivate Map<String, List<String>> map = new HashMap<>();\\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        if (map.containsKey(s)) {\\n            return map.get(s);\\n        }\\n        List<String> list = new ArrayList<>();\\n        if (wordDict.contains(s)) {\\n            list.add(s);\\n        }\\n        for (int i = 1; i < s.length(); i++) {\\n            String word = s.substring(i);\\n            if (wordDict.contains(word)) {\\n                List<String> prior = wordBreak(s.substring(0, i), wordDict);\\n                for (String s1 : prior) {\\n                    list.add(s1 + \" \" + word);\\n                }\\n            }\\n        }\\n        map.put(s, list);\\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44314,
                "title": "10ms-java-solution-with-dp-and-trie",
                "content": "    public List<String> wordBreak(String s, Set<String> wordDict) {\\n            Trie trie = new Trie();\\n            for(String word : wordDict) trie.put(word);\\n            List<String> res = new ArrayList<String>();\\n            List[] dp = new List[s.length()]; // store all the possible legal results of the substring of s starts from index i\\n            char[] c = s.toCharArray();\\n            getDP(c, 0, trie, dp);\\n            for (StringBuilder sb : (List<StringBuilder>)dp[0]) res.add(sb.toString());\\n            return res;\\n        }\\n        // get dp[start]\\n        private List<StringBuilder> getDP(char[] c, int start, Trie trie, List[] dp){\\n            List<Integer> ends = trie.getLegalEnds(c, start);// get all legal end indices starts from index \"start\"\\n            dp[start] = new ArrayList<StringBuilder>();\\n            for (int end : ends){\\n                if (end == c.length - 1) dp[start].add(new StringBuilder().append(c, start, end - start + 1));\\n                else{\\n                    if (dp[end + 1] == null) dp[end + 1] = getDP(c, end + 1, trie, dp);// if don't have dp[i], get it first\\n                    for (StringBuilder sb : (List<StringBuilder>)dp[end + 1]) // combine\\n                        dp[start].add(new StringBuilder().append(c, start, end - start + 1).append(\" \").append(sb));\\n                }\\n            }\\n            return dp[start];\\n        }\\n        \\n        //trie implementation with a little adjustment\\n        private class Trie{\\n            private class Node{\\n                boolean exist = false;\\n                Node[] next = new Node[26];\\n            }\\n            Node root = new Node();\\n            private void put(String word){\\n                put(word, root, 0);\\n            }\\n            private Node put(String word, Node root, int p){\\n                if (root == null) root = new Node();\\n                if (p == word.length()) {\\n                    root.exist = true;\\n                    return root;\\n                }\\n                root.next[word.charAt(p) - 'a'] = put(word, root.next[word.charAt(p) - 'a'], p + 1);\\n                return root;\\n            }\\n            private List<Integer> getLegalEnds(char[] c, int start){\\n                List<Integer> res = new ArrayList<Integer>();\\n                get(c, root, start, res);\\n                return res;\\n            }\\n            private void get(char[] c, Node root, int p, List<Integer> res){\\n                if (root == null) return;\\n                if (root.exist) res.add(p - 1); \\n                if (p == c.length) return;\\n                get(c, root.next[c[p] - 'a'], p + 1, res);\\n            }\\n        }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public List<String> wordBreak(String s, Set<String> wordDict) {\\n            Trie trie = new Trie();\\n            for(String word : wordDict) trie.put(word);\\n            List<String> res = new ArrayList<String>();\\n            List[] dp = new List[s.length()]; // store all the possible legal results of the substring of s starts from index i\\n            char[] c = s.toCharArray();\\n            getDP(c, 0, trie, dp);\\n            for (StringBuilder sb : (List<StringBuilder>)dp[0]) res.add(sb.toString());\\n            return res;\\n        }\\n        // get dp[start]\\n        private List<StringBuilder> getDP(char[] c, int start, Trie trie, List[] dp){\\n            List<Integer> ends = trie.getLegalEnds(c, start);// get all legal end indices starts from index \"start\"\\n            dp[start] = new ArrayList<StringBuilder>();\\n            for (int end : ends){\\n                if (end == c.length - 1) dp[start].add(new StringBuilder().append(c, start, end - start + 1));\\n                else{\\n                    if (dp[end + 1] == null) dp[end + 1] = getDP(c, end + 1, trie, dp);// if don't have dp[i], get it first\\n                    for (StringBuilder sb : (List<StringBuilder>)dp[end + 1]) // combine\\n                        dp[start].add(new StringBuilder().append(c, start, end - start + 1).append(\" \").append(sb));\\n                }\\n            }\\n            return dp[start];\\n        }\\n        \\n        //trie implementation with a little adjustment\\n        private class Trie{\\n            private class Node{\\n                boolean exist = false;\\n                Node[] next = new Node[26];\\n            }\\n            Node root = new Node();\\n            private void put(String word){\\n                put(word, root, 0);\\n            }\\n            private Node put(String word, Node root, int p){\\n                if (root == null) root = new Node();\\n                if (p == word.length()) {\\n                    root.exist = true;\\n                    return root;\\n                }\\n                root.next[word.charAt(p) - 'a'] = put(word, root.next[word.charAt(p) - 'a'], p + 1);\\n                return root;\\n            }\\n            private List<Integer> getLegalEnds(char[] c, int start){\\n                List<Integer> res = new ArrayList<Integer>();\\n                get(c, root, start, res);\\n                return res;\\n            }\\n            private void get(char[] c, Node root, int p, List<Integer> res){\\n                if (root == null) return;\\n                if (root.exist) res.add(p - 1); \\n                if (p == c.length) return;\\n                get(c, root.next[c[p] - 'a'], p + 1, res);\\n            }\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 44332,
                "title": "my-python-56ms-solution",
                "content": "    class Solution(object):\\n        def wordBreak(self, s, wordDict):\\n            \"\"\"\\n            :type s: str\\n            :type wordDict: Set[str]\\n            :rtype: List[str]\\n            \"\"\"\\n            return findWords(0, len(s), s, wordDict, {})\\n    \\n    def findWords(start, end, s, wordDict, cache):\\n        if start in cache:\\n            return cache[start]\\n        cache[start] = []\\n        candidate = ''\\n        current = start\\n        while current < end:\\n            candidate += s[current]\\n            current += 1\\n            if candidate in wordDict:\\n                if current == end:\\n                    cache[start].append(candidate)\\n                else:\\n                    for x in findWords(current, end, s, wordDict, cache):\\n                        cache[start].append(candidate + ' ' + x)\\n        return cache[start]",
                "solutionTags": [],
                "code": "class Solution(object):\\n        def wordBreak(self, s, wordDict):\\n            \"\"\"\\n            :type s: str\\n            :type wordDict: Set[str]\\n            :rtype: List[str]\\n            \"\"\"\\n            return findWords(0, len(s), s, wordDict, {}",
                "codeTag": "Java"
            },
            {
                "id": 44364,
                "title": "an-elegant-python-solution-with-dp",
                "content": "Basic idea is starting from left most character of string, increase the index, if s[:idx+1] is a valid word, try generate all combinations of s[idx+1:]. Continue doing this until index reaches the end of string. This is a recursive solution, so each time all word break options are calculated, cache them.\\n\\n    class Solution:\\n        # @param s, a string\\n        # @param dict, a set of string\\n        # @return a list of strings\\n        def wordBreak(self, s, dict):\\n            self.dict = dict\\n            self.cache = {}\\n            return self.break_helper(s)\\n            \\n        def break_helper(self, s):\\n            combs = []\\n            if s in self.cache:\\n                return self.cache[s]\\n            if len(s) == 0:\\n                return []\\n                \\n            for i in range(len(s)):\\n                if s[:i+1] in self.dict:\\n                    if i == len(s) - 1:\\n                        combs.append(s[:i+1])\\n                    else:\\n                        sub_combs = self.break_helper(s[i+1:])\\n                        for sub_comb in sub_combs:\\n                            combs.append(s[:i+1] + ' ' + sub_comb)\\n                        \\n            self.cache[s] = combs\\n            return combs",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param s, a string\\n        # @param dict, a set of string\\n        # @return a list of strings\\n        def wordBreak(self, s, dict):\\n            self.dict = dict\\n            self.cache = {}",
                "codeTag": "Java"
            },
            {
                "id": 3110612,
                "title": "java-hashset-backtracking-simple-concise",
                "content": "```\\nclass Solution {\\n    private List<String> sentences;\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Set<String> words = new HashSet<>(wordDict);\\n        sentences = new ArrayList<>();\\n        wordBreak(words, s, 0, \"\");\\n        return sentences;\\n    }\\n\\n    private void wordBreak(Set<String> words, String s, int i, String sentence) {\\n        if (i == s.length()) {\\n            sentences.add(sentence);\\n            return;\\n        }\\n\\n        for (int j = i; j < s.length(); j++) {\\n            String word = s.substring(i, j + 1);\\n            if (words.contains(word)) {\\n                if (sentence.length() == 0) {\\n                    wordBreak(words, s, j + 1, sentence + word);\\n                } else {\\n                    wordBreak(words, s, j + 1, sentence + \" \" + word);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    private List<String> sentences;\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Set<String> words = new HashSet<>(wordDict);\\n        sentences = new ArrayList<>();\\n        wordBreak(words, s, 0, \"\");\\n        return sentences;\\n    }\\n\\n    private void wordBreak(Set<String> words, String s, int i, String sentence) {\\n        if (i == s.length()) {\\n            sentences.add(sentence);\\n            return;\\n        }\\n\\n        for (int j = i; j < s.length(); j++) {\\n            String word = s.substring(i, j + 1);\\n            if (words.contains(word)) {\\n                if (sentence.length() == 0) {\\n                    wordBreak(words, s, j + 1, sentence + word);\\n                } else {\\n                    wordBreak(words, s, j + 1, sentence + \" \" + word);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714550,
                "title": "c-dfs-faster-easy-to-understand",
                "content": "* ***DFS***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    unordered_set<string> s;\\n\\n    vector<string> res;\\n\\n    void helper(string& str, int i, int n, string curr)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            curr.pop_back();\\n\\n            res.push_back(curr);\\n\\n            return;\\n        }\\n        \\n        // partition str at j and if substring is present int set then call for next\\n\\n        for(int j = i; j < n; j++)\\n        {\\n            if(s.count(str.substr(i, j - i + 1)))\\n            {\\n                helper(str, j + 1, n, curr + str.substr(i, j - i + 1) + \\' \\');\\n            }\\n        }\\n    }\\n    \\n    vector<string> wordBreak(string str, vector<string>& wordDict) {\\n\\n        int n = str.size();\\n        \\n        // insert all the words into set\\n\\n        for(auto word : wordDict)\\n        {\\n            s.insert(word);\\n        }\\n\\n        helper(str, 0, n, \"\");\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    unordered_set<string> s;\\n\\n    vector<string> res;\\n\\n    void helper(string& str, int i, int n, string curr)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            curr.pop_back();\\n\\n            res.push_back(curr);\\n\\n            return;\\n        }\\n        \\n        // partition str at j and if substring is present int set then call for next\\n\\n        for(int j = i; j < n; j++)\\n        {\\n            if(s.count(str.substr(i, j - i + 1)))\\n            {\\n                helper(str, j + 1, n, curr + str.substr(i, j - i + 1) + \\' \\');\\n            }\\n        }\\n    }\\n    \\n    vector<string> wordBreak(string str, vector<string>& wordDict) {\\n\\n        int n = str.size();\\n        \\n        // insert all the words into set\\n\\n        for(auto word : wordDict)\\n        {\\n            s.insert(word);\\n        }\\n\\n        helper(str, 0, n, \"\");\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588753,
                "title": "simple-backtracking-solution-with-path-taken",
                "content": "```\\ndef wordBreak(s, wordDict):\\n\\tresult = []\\n\\tdef backtrack(start, path):\\n\\t\\t# base case/constraint\\n\\t\\tif start == len(s):\\n\\t\\t\\tresult.append(\\' \\'.join(path))\\n\\t\\t\\treturn\\n\\t\\t# iterate through remaining characters\\n\\t\\tfor i in range(start, len(s) + 1):\\n\\t\\t\\t# if the remaning characters form a valid word, only then try to backtrack \\n\\t\\t\\t# with the starting index being the end index of the previous valid word\\n\\t\\t\\tif start[start: i] in wordDict:\\n\\t\\t\\t\\tbacktrack(i, path + [s[start: i]])\\n\\tbacktrack(0, [])\\n\\treturn result\\n```\\nI had not come accross any solution in this discussion thread that used a similart solution to how you would find all permutations of a list. It is easy to understand and doesnt require memoization.",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\ndef wordBreak(s, wordDict):\\n\\tresult = []\\n\\tdef backtrack(start, path):\\n\\t\\t# base case/constraint\\n\\t\\tif start == len(s):\\n\\t\\t\\tresult.append(\\' \\'.join(path))\\n\\t\\t\\treturn\\n\\t\\t# iterate through remaining characters\\n\\t\\tfor i in range(start, len(s) + 1):\\n\\t\\t\\t# if the remaning characters form a valid word, only then try to backtrack \\n\\t\\t\\t# with the starting index being the end index of the previous valid word\\n\\t\\t\\tif start[start: i] in wordDict:\\n\\t\\t\\t\\tbacktrack(i, path + [s[start: i]])\\n\\tbacktrack(0, [])\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2369047,
                "title": "c-100-faster-backtracking-easy-to-understand",
                "content": "# Please UpVote if this solution helps you\\n\\n```\\nvoid solve(string &s,vector<string> &wordDict,string op,int index, vector<string> &ans)\\n    {\\n        if(index == s.length())\\n        {\\n            op.pop_back();    //We pop back here to remove space from the last\\n            ans.push_back(op);\\n            return;\\n        }\\n        string temp = \"\";\\n        for(int i = index;i<s.length();i++)\\n        {\\n            temp += s[i];\\n            if(find(wordDict.begin(),wordDict.end(),temp) != wordDict.end())\\n            {\\n                 solve(s,wordDict,op+temp+\" \",i+1,ans);    //If word find then check for next word\\n            } \\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n       vector<string> ans;\\n       string op = \"\";\\n       solve(s,wordDict,op,0,ans);\\n       return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "# Please UpVote if this solution helps you\\n\\n```\\nvoid solve(string &s,vector<string> &wordDict,string op,int index, vector<string> &ans)\\n    {\\n        if(index == s.length())\\n        {\\n            op.pop_back();    //We pop back here to remove space from the last\\n            ans.push_back(op);\\n            return;\\n        }\\n        string temp = \"\";\\n        for(int i = index;i<s.length();i++)\\n        {\\n            temp += s[i];\\n            if(find(wordDict.begin(),wordDict.end(),temp) != wordDict.end())\\n            {\\n                 solve(s,wordDict,op+temp+\" \",i+1,ans);    //If word find then check for next word\\n            } \\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n       vector<string> ans;\\n       string op = \"\";\\n       solve(s,wordDict,op,0,ans);\\n       return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1377390,
                "title": "c-100-faster-dp-solution-with-explanation-and-comments",
                "content": "This question is similar to word break 1. The only difference here is that here when we get a true (dictionary match), we add the strings to the anwser using the previously calculated strings. This is a bottom up DP solution.\\n\\nWe do this by building answers and store them in a dp vector where dp[i] stores answer for a string ending at the ith index.\\n* dp[i].first -> A boolean stores if the substring can be partitioned\\n* dp[i].second -> A set that stores all strings created till now for a string ending at the ith index\\n```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        \\n        int n = s.size();\\n        \\n        //First we make a dictionary set to fetch words in O(1)\\n        unordered_set<string> dictionary;\\n        for(int i=0; i<wordDict.size(); i++){\\n            dictionary.insert(wordDict[i]);\\n        }\\n        \\n        //Here we store values. dp[i].first stores if the substring can be partitioned\\n        //We create a vector of n+1 size and initialize the first index to true\\n        vector<pair<bool,unordered_set<string>>> dp(n+1);\\n        for(int i=1; i<=n; i++){\\n            dp[i].first = false;\\n        }\\n        \\n        //We initilaize this to true for the case that a dictionary word is the entire string\\n        dp[0].first = true;\\n        \\n        for(int i=1; i<=n; i++){\\n    \\n            //If dp[i-1] was true, we can start building possible words from the (i-1)st index that are in the dictionary\\n            if(dp[i-1].first){\\n                string str = \"\";\\n                for(int j=i-1; j<n; j++){\\n                    str += s[j];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//Check if the string from (i-1)st index to jth index exists in dictionary\\n                    if(dictionary.count(str)==1){\\n                        \\n                        //If we find a matching word, this means that the entire string till j can be partitioned\\n                        //So we mark it as true and get string possibilities till here using the previous answer\\n                        dp[j+1].first = true;\\n    \\n                        //If the earlier index did not have any string present (Case where first word in string)\\n                        if(dp[i-1].second.size()==0)\\n                            dp[j+1].second.insert(str);\\n                        \\n                        //Build strings for all possibilities using the last answer\\n                        else{\\n                            for(auto& tempS : dp[i-1].second){\\n                                string newS = tempS + \" \" + str;\\n                                dp[j+1].second.insert(newS);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<string> ans;\\n        \\n        //Return all strings for the string ending at (n-1)st index\\n        for(auto& str : dp[n].second){\\n            ans.push_back(str);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPlease feel free to suggest improvements to this code if any!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        \\n        int n = s.size();\\n        \\n        //First we make a dictionary set to fetch words in O(1)\\n        unordered_set<string> dictionary;\\n        for(int i=0; i<wordDict.size(); i++){\\n            dictionary.insert(wordDict[i]);\\n        }\\n        \\n        //Here we store values. dp[i].first stores if the substring can be partitioned\\n        //We create a vector of n+1 size and initialize the first index to true\\n        vector<pair<bool,unordered_set<string>>> dp(n+1);\\n        for(int i=1; i<=n; i++){\\n            dp[i].first = false;\\n        }\\n        \\n        //We initilaize this to true for the case that a dictionary word is the entire string\\n        dp[0].first = true;\\n        \\n        for(int i=1; i<=n; i++){\\n    \\n            //If dp[i-1] was true, we can start building possible words from the (i-1)st index that are in the dictionary\\n            if(dp[i-1].first){\\n                string str = \"\";\\n                for(int j=i-1; j<n; j++){\\n                    str += s[j];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//Check if the string from (i-1)st index to jth index exists in dictionary\\n                    if(dictionary.count(str)==1){\\n                        \\n                        //If we find a matching word, this means that the entire string till j can be partitioned\\n                        //So we mark it as true and get string possibilities till here using the previous answer\\n                        dp[j+1].first = true;\\n    \\n                        //If the earlier index did not have any string present (Case where first word in string)\\n                        if(dp[i-1].second.size()==0)\\n                            dp[j+1].second.insert(str);\\n                        \\n                        //Build strings for all possibilities using the last answer\\n                        else{\\n                            for(auto& tempS : dp[i-1].second){\\n                                string newS = tempS + \" \" + str;\\n                                dp[j+1].second.insert(newS);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<string> ans;\\n        \\n        //Return all strings for the string ending at (n-1)st index\\n        for(auto& str : dp[n].second){\\n            ans.push_back(str);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251729,
                "title": "python-trie-no-dp",
                "content": "```python\\nclass Solution:\\n    class Trie:\\n        def __init__(self):\\n            self.root = {}\\n            self.WORD_DELIM = \\'$\\'\\n            \\n        def addWord(self, word):\\n            cur = self.root\\n            for char in word:\\n                if char not in cur:\\n                    cur[char] = {}\\n                cur = cur[char]\\n            cur[self.WORD_DELIM] = word\\n            \\n        def addWords(self, words):\\n            for word in words:\\n                self.addWord(word)\\n                \\n        def getValidSentences(self, word, res = \\'\\'):            \\n            res = []\\n            def dfs(word=word, temp=[]):\\n                cur = self.root\\n                for i,char in enumerate(word):\\n                    if self.WORD_DELIM in cur:\\n                        dfs(word[i:], temp + [cur[self.WORD_DELIM]])\\n                    if char not in cur:\\n                        break\\n                    cur = cur[char]\\n                else:\\n                    if self.WORD_DELIM in cur:\\n                        res.append(\\' \\'.join(temp + [cur[self.WORD_DELIM]]))\\n            dfs()\\n            return res\\n                \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        trie = self.Trie()\\n        trie.addWords(wordDict)\\n        return trie.getValidSentences(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```python\\nclass Solution:\\n    class Trie:\\n        def __init__(self):\\n            self.root = {}\\n            self.WORD_DELIM = \\'$\\'\\n            \\n        def addWord(self, word):\\n            cur = self.root\\n            for char in word:\\n                if char not in cur:\\n                    cur[char] = {}\\n                cur = cur[char]\\n            cur[self.WORD_DELIM] = word\\n            \\n        def addWords(self, words):\\n            for word in words:\\n                self.addWord(word)\\n                \\n        def getValidSentences(self, word, res = \\'\\'):            \\n            res = []\\n            def dfs(word=word, temp=[]):\\n                cur = self.root\\n                for i,char in enumerate(word):\\n                    if self.WORD_DELIM in cur:\\n                        dfs(word[i:], temp + [cur[self.WORD_DELIM]])\\n                    if char not in cur:\\n                        break\\n                    cur = cur[char]\\n                else:\\n                    if self.WORD_DELIM in cur:\\n                        res.append(\\' \\'.join(temp + [cur[self.WORD_DELIM]]))\\n            dfs()\\n            return res\\n                \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        trie = self.Trie()\\n        trie.addWords(wordDict)\\n        return trie.getValidSentences(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204725,
                "title": "c-0-ms-solution-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        string op=\"\";\\n        solve(s, op, wordDict, 0);\\n        return ans;\\n    }\\n    \\n    void solve(string ip, string op, vector<string>mp, int start) {\\n        if(start == ip.size()){\\n            op.pop_back();\\n            ans.push_back(op);\\n            op.push_back(\\' \\');\\n            return;\\n        }\\n        \\n       for(int i=start; i<ip.length(); i++){\\n\\t   //check if the substring is present in the dictionary\\n\\t   \\n           if(find(mp.begin(), mp.end(), ip.substr(start, i-start+1)) != mp.end()) {\\n\\t\\t   //if the above substring is present in the dictionary, add it to the output string\\n\\t\\t   //also add a space after adding the word\\n\\t\\t   \\n               string prev = op;\\n               op += (ip.substr(start, i-start+1));\\n               op.push_back(\\' \\');\\n               solve(ip, op, mp, i+1);\\n\\t\\t\\t   \\n\\t\\t\\t   //backtrack step\\n               op = prev;\\n           }\\n       }\\n    return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        string op=\"\";\\n        solve(s, op, wordDict, 0);\\n        return ans;\\n    }\\n    \\n    void solve(string ip, string op, vector<string>mp, int start) {\\n        if(start == ip.size()){\\n            op.pop_back();\\n            ans.push_back(op);\\n            op.push_back(\\' \\');\\n            return;\\n        }\\n        \\n       for(int i=start; i<ip.length(); i++){\\n\\t   //check if the substring is present in the dictionary\\n\\t   \\n           if(find(mp.begin(), mp.end(), ip.substr(start, i-start+1)) != mp.end()) {\\n\\t\\t   //if the above substring is present in the dictionary, add it to the output string\\n\\t\\t   //also add a space after adding the word\\n\\t\\t   \\n               string prev = op;\\n               op += (ip.substr(start, i-start+1));\\n               op.push_back(\\' \\');\\n               solve(ip, op, mp, i+1);\\n\\t\\t\\t   \\n\\t\\t\\t   //backtrack step\\n               op = prev;\\n           }\\n       }\\n    return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765548,
                "title": "javascript-python3-c-top-down-bottom-up-partial",
                "content": "**Synopsis:**\\n\\nWe can use [\\uD83C\\uDFA8 The ART of Dynamic Programming ](https://leetcode.com/discuss/general-discussion/712010/the-art-of-dynamic-programming-an-intuitive-approach-from-apprentice-to-master/) to construct the answer from right-to-left as the recursive stack unwinds by returning the list of words which can be created at each i-th index based upon the suffix at `S[i]` which is the substring `S[i:N)`, ie. the characters in `S` from `i` inclusive to `N` non-inclusive.\\n\\n**Note:** for the bottom-up solutions, only the JS solution is AC.  Both Python and C++ result in TLE.  This is really strange, I\\'m probably missing something basic, I\\'ll come back and revisit those another time.\\n\\n---\\n\\n**Step 0:** Start with a naive DFS + BT solution.  These solutions TLE as expected, and we cannot add a memo to these solutions because the path is constructed as a parameter passed into the recursive function.  In order to use memoization, we need to return the path as the recursive stack unwinds.\\n\\n*Javascript*\\n```\\nlet wordBreak = (S, A, words = new Set(), ans = []) => {\\n    let N = S.length;\\n    A.forEach(word => words.add(word));\\n    let go = (i = 0, path = []) => {\\n        if (i == N) {\\n            ans.push(path.join(\\' \\'));\\n            return;\\n        }\\n        for (let j = i + 1; j <= N; ++j) { // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (words.has(cand))\\n                go(j, path.concat(cand));  // \\uD83D\\uDE80 DFS + BT\\n        }\\n    };\\n    go();\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        words = []\\n        N = len(S)\\n        dict = set(A)\\n        def go(i = 0, path = []):\\n            if i == N:\\n                words.append(path.copy())\\n                return\\n            for j in range(i + 1, N + 1): # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    path.append(cand)\\n                    go(j, path)           # \\uD83D\\uDE80 DFS + BT\\n                    path.pop()\\n        go()\\n        return list(map(lambda row: \\' \\'.join(row), words))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    using func = function<void(int, VS&&)>;\\n    VS wordBreak(string S, VS& A, VS words = {}) {\\n        int N = S.size();\\n        Set dict{ A.begin(), A.end() };\\n        func go = [&](int i, VS&& path = {}) {\\n            if (i == N) {\\n                stringstream ss; copy(path.begin(), path.end(), ostream_iterator<string>(ss, \" \"));\\n                auto ans = ss.str();\\n                ans.pop_back(); // remove trailing whitespace\\n                words.emplace_back(ans);\\n                return;\\n            }\\n            for (auto j{ i + 1 }; j <= N; ++j) { // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                auto cand = S.substr(i, j - i);\\n                if (dict.find(cand) != dict.end()) {\\n                    path.push_back(cand);\\n                    go(j, move(path));           // \\uD83D\\uDE80 DFS + BT\\n                    path.pop_back();\\n                }\\n            }\\n        };\\n        go(0, {});\\n        return words;\\n    }\\n};\\n```\\n\\n---\\n\\n**Step 1: Brute-Force** (TLE)\\n\\nAs mentioned in the previous step, \"In order to use memoization, we need to return the path as the recursive stack unwinds.\"  So let\\'s first create a brute-force solution which returns the answer as the recursive stack unwinds, then we\\'ll add memoization to this brute-force solution in the next step.\\n\\n*Javascript*\\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    A.forEach(word => dict.add(word));\\n    let go = (i = 0, words = []) => {\\n        if (i == N)                                  // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n            return [[]];\\n        for (let j = i + 1; j <= N; ++j) {           // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (let tail of go(j))\\n                    words.push([cand].concat(tail)); // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        }\\n        return words;\\n    };\\n    return go().map(a => a.join(\\' \\'));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        dict = set(A)\\n        def go(i = 0):\\n            words = []\\n            if i == N:                              # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n                return [[]]\\n            for j in range(i + 1, N + 1):           # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for last in go(j):\\n                        words.append([cand] + last) # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n            return words\\n        return list(map(lambda row: \\' \\'.join(row), go()))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n\\tusing VS = vector<string>;\\n\\tusing Set = unordered_set<string>;\\n\\tusing func = function<VS(int)>;\\n\\tVS wordBreak(string S, VS& A, Set dict = {}) {\\n\\t\\tint N = S.size();\\n\\t\\tfor (auto& word: A)\\n\\t\\t\\tdict.insert(word);\\n\\t\\tfunc go = [&](int i, VS words = {}) {\\n\\t\\t\\tif (i == N)                             // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n\\t\\t\\t\\treturn VS{\"\"};\\n\\t\\t\\tfor (auto j{ i + 1 }; j <= N; ++j) {    // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n\\t\\t\\t\\tauto cand = S.substr(i, j - i);\\n\\t\\t\\t\\tif (dict.find(cand) != dict.end())\\n\\t\\t\\t\\t\\tfor (auto& tail: go(j))         // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n\\t\\t\\t\\t\\t\\twords.emplace_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n\\t\\t\\t}\\n\\t\\t\\treturn words;\\n\\t\\t};\\n\\t\\treturn go(0);\\n\\t}\\n};\\n```\\n\\n---\\n\\n**Step 2: Memo** (AC)\\n\\nSimply add a memo onto the previous brute-force solutions for AC.\\n\\n*Javascript*\\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    let m = Array(N + 1).fill(null);\\n    A.forEach(word => dict.add(word));\\n    let go = (i = 0, words = []) => {\\n        if (m[i] != null)                            // \\uD83E\\uDD14 memo\\n            return m[i];\\n        if (i == N)                                  // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n            return m[i] = [[]];\\n        for (let j = i + 1; j <= N; ++j) {           // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (let tail of go(j))\\n                    words.push([cand].concat(tail)); // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        }\\n        return m[i] = words;\\n    };\\n    return go().map(a => a.join(\\' \\'));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        m = [None] * (N + 1)\\n        dict = set(A)\\n        def go(i = 0):\\n            if m[i] != None:                        # \\uD83E\\uDD14 memo\\n                return m[i]\\n            words = []\\n            if i == N:                              # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n                return [[]]\\n            for j in range(i + 1, N + 1):           # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for last in go(j):\\n                        words.append([cand] + last) # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n            m[i] = words\\n            return m[i]\\n        return list(map(lambda row: \\' \\'.join(row), go()))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n\\tusing VS = vector<string>;\\n\\tusing Set = unordered_set<string>;\\n\\tusing func = function<VS(int)>;\\n\\tusing Map = unordered_map<int, VS>;\\n\\tVS wordBreak(string S, VS& A, Set dict = {}, Map m = {}) {\\n\\t\\tint N = S.size();\\n\\t\\tfor (auto& word: A)\\n\\t\\t\\tdict.insert(word);\\n\\t\\tfunc go = [&](int i, VS words = {}) {\\n\\t\\t\\tif (m.find(i) != m.end())               // \\uD83E\\uDD14 memo\\n\\t\\t\\t\\treturn m[i];\\n\\t\\t\\tif (i == N)                             // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n\\t\\t\\t\\treturn m[i] = VS{\"\"};\\n\\t\\t\\tfor (auto j{ i + 1 }; j <= N; ++j) {    // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n\\t\\t\\t\\tauto cand = S.substr(i, j - i);\\n\\t\\t\\t\\tif (dict.find(cand) != dict.end())\\n\\t\\t\\t\\t\\tfor (auto& tail: go(j))         // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n\\t\\t\\t\\t\\t\\twords.emplace_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n\\t\\t\\t}\\n\\t\\t\\treturn m[i] = words;\\n\\t\\t};\\n\\t\\treturn go(0);\\n\\t}\\n};\\n```\\n\\n---\\n\\n**Step 3: Bottom-Up**\\n\\n**Note:** only the JS solution is AC.  Both Python and C++ result in TLE.  This is really strange, I\\'m probably missing something basic, I\\'ll come back and revisit those another time.\\n\\n*Javascript*\\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    let dp = [...Array(N + 1)].map(_ => []);         // \\uD83E\\uDD14 memo\\n    dp[N] = [[]];                                    // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n    A.forEach(word => dict.add(word));\\n    for (let i = N - 1; 0 <= i; --i) {               // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n        for (let j = i + 1; j <= N; ++j) {\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (tail of dp[j])\\n                    dp[i].push([cand].concat(tail)); // \\uD83D\\uDE80 concat each tail onto the current candidate, \\uD83D\\uDC48 ie. build the answer from right to left \\n        }\\n    }\\n    return dp[0].map(words => words.join(\\' \\'));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        dp = list(map(lambda _: [], [None] * (N + 1)))         # \\uD83E\\uDD14 memo\\n        dp[N] = [[]]                                           # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n        dict = set(A)\\n        for i in range(N - 1, -1, -1):                         # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            for j in range(i + 1, N + 1):\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for tail in dp[j]:\\n                        dp[i].append([cand] + tail)            # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        return list(map(lambda words: \\' \\'.join(words), dp[0]))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using VVS = vector<VS>;\\n    using Set = unordered_set<string>;\\n    VS wordBreak(string S, VS& A) {\\n        int N = S.size();\\n        VVS dp(N + 1);                              // \\uD83E\\uDD14 memo\\n        dp.back().push_back(\"\");                    // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n        Set dict{ A.begin(), A.end() };\\n        for (auto i{ N - 1 }; 0 <= i; --i) {        // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            for (auto j{ i + 1 }; j <= N; ++j) {\\n                auto cand = S.substr(i, j - i);\\n                if (dict.find(cand) != dict.end())\\n                    for (auto& tail: dp[j])         // \\uD83D\\uDE80 concat each tail onto the current candidate, \\uD83D\\uDC48 ie. build the answer from right to left\\n                        dp[i].push_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet wordBreak = (S, A, words = new Set(), ans = []) => {\\n    let N = S.length;\\n    A.forEach(word => words.add(word));\\n    let go = (i = 0, path = []) => {\\n        if (i == N) {\\n            ans.push(path.join(\\' \\'));\\n            return;\\n        }\\n        for (let j = i + 1; j <= N; ++j) { // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (words.has(cand))\\n                go(j, path.concat(cand));  // \\uD83D\\uDE80 DFS + BT\\n        }\\n    };\\n    go();\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        words = []\\n        N = len(S)\\n        dict = set(A)\\n        def go(i = 0, path = []):\\n            if i == N:\\n                words.append(path.copy())\\n                return\\n            for j in range(i + 1, N + 1): # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    path.append(cand)\\n                    go(j, path)           # \\uD83D\\uDE80 DFS + BT\\n                    path.pop()\\n        go()\\n        return list(map(lambda row: \\' \\'.join(row), words))\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    using func = function<void(int, VS&&)>;\\n    VS wordBreak(string S, VS& A, VS words = {}) {\\n        int N = S.size();\\n        Set dict{ A.begin(), A.end() };\\n        func go = [&](int i, VS&& path = {}) {\\n            if (i == N) {\\n                stringstream ss; copy(path.begin(), path.end(), ostream_iterator<string>(ss, \" \"));\\n                auto ans = ss.str();\\n                ans.pop_back(); // remove trailing whitespace\\n                words.emplace_back(ans);\\n                return;\\n            }\\n            for (auto j{ i + 1 }; j <= N; ++j) { // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                auto cand = S.substr(i, j - i);\\n                if (dict.find(cand) != dict.end()) {\\n                    path.push_back(cand);\\n                    go(j, move(path));           // \\uD83D\\uDE80 DFS + BT\\n                    path.pop_back();\\n                }\\n            }\\n        };\\n        go(0, {});\\n        return words;\\n    }\\n};\\n```\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    A.forEach(word => dict.add(word));\\n    let go = (i = 0, words = []) => {\\n        if (i == N)                                  // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n            return [[]];\\n        for (let j = i + 1; j <= N; ++j) {           // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (let tail of go(j))\\n                    words.push([cand].concat(tail)); // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        }\\n        return words;\\n    };\\n    return go().map(a => a.join(\\' \\'));\\n};\\n```\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        dict = set(A)\\n        def go(i = 0):\\n            words = []\\n            if i == N:                              # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n                return [[]]\\n            for j in range(i + 1, N + 1):           # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for last in go(j):\\n                        words.append([cand] + last) # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n            return words\\n        return list(map(lambda row: \\' \\'.join(row), go()))\\n```\n```\\nclass Solution {\\npublic:\\n\\tusing VS = vector<string>;\\n\\tusing Set = unordered_set<string>;\\n\\tusing func = function<VS(int)>;\\n\\tVS wordBreak(string S, VS& A, Set dict = {}) {\\n\\t\\tint N = S.size();\\n\\t\\tfor (auto& word: A)\\n\\t\\t\\tdict.insert(word);\\n\\t\\tfunc go = [&](int i, VS words = {}) {\\n\\t\\t\\tif (i == N)                             // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n\\t\\t\\t\\treturn VS{\"\"};\\n\\t\\t\\tfor (auto j{ i + 1 }; j <= N; ++j) {    // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n\\t\\t\\t\\tauto cand = S.substr(i, j - i);\\n\\t\\t\\t\\tif (dict.find(cand) != dict.end())\\n\\t\\t\\t\\t\\tfor (auto& tail: go(j))         // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n\\t\\t\\t\\t\\t\\twords.emplace_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n\\t\\t\\t}\\n\\t\\t\\treturn words;\\n\\t\\t};\\n\\t\\treturn go(0);\\n\\t}\\n};\\n```\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    let m = Array(N + 1).fill(null);\\n    A.forEach(word => dict.add(word));\\n    let go = (i = 0, words = []) => {\\n        if (m[i] != null)                            // \\uD83E\\uDD14 memo\\n            return m[i];\\n        if (i == N)                                  // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n            return m[i] = [[]];\\n        for (let j = i + 1; j <= N; ++j) {           // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (let tail of go(j))\\n                    words.push([cand].concat(tail)); // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        }\\n        return m[i] = words;\\n    };\\n    return go().map(a => a.join(\\' \\'));\\n};\\n```\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        m = [None] * (N + 1)\\n        dict = set(A)\\n        def go(i = 0):\\n            if m[i] != None:                        # \\uD83E\\uDD14 memo\\n                return m[i]\\n            words = []\\n            if i == N:                              # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n                return [[]]\\n            for j in range(i + 1, N + 1):           # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for last in go(j):\\n                        words.append([cand] + last) # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n            m[i] = words\\n            return m[i]\\n        return list(map(lambda row: \\' \\'.join(row), go()))\\n```\n```\\nclass Solution {\\npublic:\\n\\tusing VS = vector<string>;\\n\\tusing Set = unordered_set<string>;\\n\\tusing func = function<VS(int)>;\\n\\tusing Map = unordered_map<int, VS>;\\n\\tVS wordBreak(string S, VS& A, Set dict = {}, Map m = {}) {\\n\\t\\tint N = S.size();\\n\\t\\tfor (auto& word: A)\\n\\t\\t\\tdict.insert(word);\\n\\t\\tfunc go = [&](int i, VS words = {}) {\\n\\t\\t\\tif (m.find(i) != m.end())               // \\uD83E\\uDD14 memo\\n\\t\\t\\t\\treturn m[i];\\n\\t\\t\\tif (i == N)                             // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n\\t\\t\\t\\treturn m[i] = VS{\"\"};\\n\\t\\t\\tfor (auto j{ i + 1 }; j <= N; ++j) {    // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n\\t\\t\\t\\tauto cand = S.substr(i, j - i);\\n\\t\\t\\t\\tif (dict.find(cand) != dict.end())\\n\\t\\t\\t\\t\\tfor (auto& tail: go(j))         // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n\\t\\t\\t\\t\\t\\twords.emplace_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n\\t\\t\\t}\\n\\t\\t\\treturn m[i] = words;\\n\\t\\t};\\n\\t\\treturn go(0);\\n\\t}\\n};\\n```\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    let dp = [...Array(N + 1)].map(_ => []);         // \\uD83E\\uDD14 memo\\n    dp[N] = [[]];                                    // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n    A.forEach(word => dict.add(word));\\n    for (let i = N - 1; 0 <= i; --i) {               // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n        for (let j = i + 1; j <= N; ++j) {\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (tail of dp[j])\\n                    dp[i].push([cand].concat(tail)); // \\uD83D\\uDE80 concat each tail onto the current candidate, \\uD83D\\uDC48 ie. build the answer from right to left \\n        }\\n    }\\n    return dp[0].map(words => words.join(\\' \\'));\\n};\\n```\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        dp = list(map(lambda _: [], [None] * (N + 1)))         # \\uD83E\\uDD14 memo\\n        dp[N] = [[]]                                           # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n        dict = set(A)\\n        for i in range(N - 1, -1, -1):                         # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            for j in range(i + 1, N + 1):\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for tail in dp[j]:\\n                        dp[i].append([cand] + tail)            # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        return list(map(lambda words: \\' \\'.join(words), dp[0]))\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using VVS = vector<VS>;\\n    using Set = unordered_set<string>;\\n    VS wordBreak(string S, VS& A) {\\n        int N = S.size();\\n        VVS dp(N + 1);                              // \\uD83E\\uDD14 memo\\n        dp.back().push_back(\"\");                    // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n        Set dict{ A.begin(), A.end() };\\n        for (auto i{ N - 1 }; 0 <= i; --i) {        // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            for (auto j{ i + 1 }; j <= N; ++j) {\\n                auto cand = S.substr(i, j - i);\\n                if (dict.find(cand) != dict.end())\\n                    for (auto& tail: dp[j])         // \\uD83D\\uDE80 concat each tail onto the current candidate, \\uD83D\\uDC48 ie. build the answer from right to left\\n                        dp[i].push_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763825,
                "title": "python-short-recursion-99-5",
                "content": "I\\'m sure the timings are variable but that\\'s what it yielded for me. Also, although I\\'ve called the function DFS the tree structure is perhaps not immediately obvious. \\n\\nThis problem seems oddly easy if you rule out the pathological cases of the form `s=\\'aa...aba...aa\\'` where the words are all `a` string and the like. In the below solution this is done by creating a set of all letters in the words `wordLets` and all letters in the string `stringLets` and returning the empty list if the set difference is non-empty. After that we perform a DFS for the remaining cases. \\n\\nThe DFS takes two arguments `so_far` is a list of the words found so far and `ind` is the start index, which will be right after the last word added to the list. If `ind == n` that means we managed to progress all the way to the end of the string, in which case, wejoin the list of words we\\'ve found and append it to the solution list. Otherwise, if we find a slice `s[ind:i]` which is in the word dictionary, then we call the DFS function recursively with this word added to `so_far` and restarting our scan from position `ind = i` in the string.\\n\\nWe also change the list of input words into a set for faster lookup.\\n\\n\\t\\n\\t\\n\\t\\n\\tdef wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n\\n        wordLets = set(\\'\\'.join(wordDict))\\n        wordDict = set(wordDict) #Fast lookup\\n        stringLets = set(s)\\n        \\n        if stringLets - wordLets:\\n            return []\\n        \\n        word_list_list = []\\n        n = len(s)\\n        \\n        def DFS(so_far = [], ind = 0):\\n            if ind == n:\\n                word_list_list.append(\\' \\'.join(so_far))\\n                return\\n            for i in range(ind, n+1):\\n                if s[ind:i] in wordDict:\\n                    DFS(so_far+[s[ind:i]], i)\\n                    \\n        DFS()\\n        \\n        return word_list_list",
                "solutionTags": [],
                "code": "I\\'m sure the timings are variable but that\\'s what it yielded for me. Also, although I\\'ve called the function DFS the tree structure is perhaps not immediately obvious. \\n\\nThis problem seems oddly easy if you rule out the pathological cases of the form `s=\\'aa...aba...aa\\'` where the words are all `a` string and the like. In the below solution this is done by creating a set of all letters in the words `wordLets` and all letters in the string `stringLets` and returning the empty list if the set difference is non-empty. After that we perform a DFS for the remaining cases. \\n\\nThe DFS takes two arguments `so_far` is a list of the words found so far and `ind` is the start index, which will be right after the last word added to the list. If `ind == n` that means we managed to progress all the way to the end of the string, in which case, wejoin the list of words we\\'ve found and append it to the solution list. Otherwise, if we find a slice `s[ind:i]` which is in the word dictionary, then we call the DFS function recursively with this word added to `so_far` and restarting our scan from position `ind = i` in the string.\\n\\nWe also change the list of input words into a set for faster lookup.\\n\\n\\t\\n\\t\\n\\t\\n\\tdef wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n\\n        wordLets = set(\\'\\'.join(wordDict))\\n        wordDict = set(wordDict) #Fast lookup\\n        stringLets = set(s)\\n        \\n        if stringLets - wordLets:\\n            return []\\n        \\n        word_list_list = []\\n        n = len(s)\\n        \\n        def DFS(so_far = [], ind = 0):\\n            if ind == n:\\n                word_list_list.append(\\' \\'.join(so_far))\\n                return\\n            for i in range(ind, n+1):\\n                if s[ind:i] in wordDict:\\n                    DFS(so_far+[s[ind:i]], i)\\n                    \\n        DFS()\\n        \\n        return word_list_list",
                "codeTag": "Python3"
            },
            {
                "id": 763397,
                "title": "simple-dp-swift-solution",
                "content": "It\\'s not hard\\n```\\nclass Solution {\\n    \\n    var cache: [String: [String]] = [:]\\n    \\n    func wordBreak(_ str: String, _ wordDict: [String]) -> [String] {\\n        if let ans = cache[str] {\\n            return ans\\n        }\\n        var ans: [String] = []\\n        for word in wordDict {\\n            if str.hasPrefix(word) {\\n                if str.count == word.count {\\n                    ans.append(word)\\n                } else {\\n                    let substr = str.substring(from: word.endIndex)\\n                    var subwords = wordBreak(substr, wordDict)\\n                    for substr in subwords {\\n                        ans.append(word + \" \" + substr)\\n                    }\\n                }\\n            } \\n        }\\n        cache[str] = ans\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    \\n    var cache: [String: [String]] = [:]\\n    \\n    func wordBreak(_ str: String, _ wordDict: [String]) -> [String] {\\n        if let ans = cache[str] {\\n            return ans\\n        }\\n        var ans: [String] = []\\n        for word in wordDict {\\n            if str.hasPrefix(word) {\\n                if str.count == word.count {\\n                    ans.append(word)\\n                } else {\\n                    let substr = str.substring(from: word.endIndex)\\n                    var subwords = wordBreak(substr, wordDict)\\n                    for substr in subwords {\\n                        ans.append(word + \" \" + substr)\\n                    }\\n                }\\n            } \\n        }\\n        cache[str] = ans\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534028,
                "title": "cpp-dfs-memo-to-speed-up",
                "content": "```\\n\\nclass Solution { // dfs + memo\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        map<int, vector<string>> memo;\\n        return dfs(s, dict, 0, memo);\\n    }\\n    vector<string> dfs(string s, set<string> &wordDict, int index, map<int, vector<string>> &memo) {\\n        if(memo.count(index)) return memo[index];\\n        vector<string> ret;\\n        for(int i = index; i < s.size(); i++) {\\n            string cur = s.substr(index, i - index + 1);\\n            if(wordDict.count(cur)) {\\n                if(i == s.size() - 1) ret.push_back(cur);\\n                vector<string> tmp = dfs(s, wordDict, i + 1, memo);\\n                for(string e :tmp) ret.push_back(cur + \" \" + e);\\n            }\\n        }\\n        memo[index] = ret;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution { // dfs + memo\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        map<int, vector<string>> memo;\\n        return dfs(s, dict, 0, memo);\\n    }\\n    vector<string> dfs(string s, set<string> &wordDict, int index, map<int, vector<string>> &memo) {\\n        if(memo.count(index)) return memo[index];\\n        vector<string> ret;\\n        for(int i = index; i < s.size(); i++) {\\n            string cur = s.substr(index, i - index + 1);\\n            if(wordDict.count(cur)) {\\n                if(i == s.size() - 1) ret.push_back(cur);\\n                vector<string> tmp = dfs(s, wordDict, i + 1, memo);\\n                for(string e :tmp) ret.push_back(cur + \" \" + e);\\n            }\\n        }\\n        memo[index] = ret;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481615,
                "title": "python-dfs-memo",
                "content": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n        return self.helper(s, memo, wordDict)\\n    def helper(self, s, memo, wordDict):\\n        if s in memo:\\n            return memo[s]\\n        ans = []\\n        if s in wordDict:\\n            ans.append(s)\\n            \\n        for i in range(1, len(s)):  \\n            right = s[i:]\\n            if right not in wordDict:\\n                continue\\n            left = s[:i]\\n            ans += [w + \" \" + right for w in self.helper(left, memo, wordDict)]\\n            \\n        memo[s] = ans\\n        return memo[s]\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n        return self.helper(s, memo, wordDict)\\n    def helper(self, s, memo, wordDict):\\n        if s in memo:\\n            return memo[s]\\n        ans = []\\n        if s in wordDict:\\n            ans.append(s)\\n            \\n        for i in range(1, len(s)):  \\n            right = s[i:]\\n            if right not in wordDict:\\n                continue\\n            left = s[:i]\\n            ans += [w + \" \" + right for w in self.helper(left, memo, wordDict)]\\n            \\n        memo[s] = ans\\n        return memo[s]\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 437669,
                "title": "c-trie-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        bool isWord;\\n        unordered_map<char,TrieNode*> children;\\n        TrieNode(){\\n            isWord=false;\\n        }\\n    };\\n    \\n    void buildTrie(string &s){\\n        TrieNode* cur=root;\\n        for(int i=0;i<s.size();i++){\\n            if(cur->children.find(s[i])==cur->children.end()){\\n                cur->children[s[i]]=new TrieNode();\\n            }\\n            cur=cur->children[s[i]];\\n        }\\n        cur->isWord=true;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        root=new TrieNode();\\n        for(string &word:wordDict){\\n            buildTrie(word);\\n        }\\n        unordered_map<int,vector<string>> memo;\\n        return dfs(s,0,memo);\\n    }\\n    \\n    vector<string> dfs(string &s,int pos,unordered_map<int,vector<string>> &memo){\\n        vector<string> res;\\n        if(pos==s.size()){\\n            res.push_back(\"\");\\n            return res;\\n        }\\n        \\n        if(memo.count(pos)){\\n            return memo[pos];\\n        }\\n        \\n        TrieNode *cur=root;\\n        \\n        for(int i=pos;i<s.size();i++){\\n            if(cur->children.find(s[i])==cur->children.end()){\\n                break;\\n            }\\n            cur=cur->children[s[i]];\\n            if(cur->isWord){\\n                int len=i-pos+1;\\n                string tmp=s.substr(pos,len);\\n                if(i<s.size()-1){\\n                    tmp+=\" \";\\n                }\\n                auto next=dfs(s,i+1,memo);\\n                for(string &n:next){\\n                    string t=tmp+n;\\n                    res.push_back(t);\\n                }                \\n            }\\n        }\\n        \\n        memo[pos]=res;\\n        return res;\\n    }\\n    \\nprivate:\\n    TrieNode* root;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        bool isWord;\\n        unordered_map<char,TrieNode*> children;\\n        TrieNode(){\\n            isWord=false;\\n        }\\n    };\\n    \\n    void buildTrie(string &s){\\n        TrieNode* cur=root;\\n        for(int i=0;i<s.size();i++){\\n            if(cur->children.find(s[i])==cur->children.end()){\\n                cur->children[s[i]]=new TrieNode();\\n            }\\n            cur=cur->children[s[i]];\\n        }\\n        cur->isWord=true;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        root=new TrieNode();\\n        for(string &word:wordDict){\\n            buildTrie(word);\\n        }\\n        unordered_map<int,vector<string>> memo;\\n        return dfs(s,0,memo);\\n    }\\n    \\n    vector<string> dfs(string &s,int pos,unordered_map<int,vector<string>> &memo){\\n        vector<string> res;\\n        if(pos==s.size()){\\n            res.push_back(\"\");\\n            return res;\\n        }\\n        \\n        if(memo.count(pos)){\\n            return memo[pos];\\n        }\\n        \\n        TrieNode *cur=root;\\n        \\n        for(int i=pos;i<s.size();i++){\\n            if(cur->children.find(s[i])==cur->children.end()){\\n                break;\\n            }\\n            cur=cur->children[s[i]];\\n            if(cur->isWord){\\n                int len=i-pos+1;\\n                string tmp=s.substr(pos,len);\\n                if(i<s.size()-1){\\n                    tmp+=\" \";\\n                }\\n                auto next=dfs(s,i+1,memo);\\n                for(string &n:next){\\n                    string t=tmp+n;\\n                    res.push_back(t);\\n                }                \\n            }\\n        }\\n        \\n        memo[pos]=res;\\n        return res;\\n    }\\n    \\nprivate:\\n    TrieNode* root;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322400,
                "title": "standard-python-dp-solutions-bottom-up-top-down",
                "content": "Please see and vote for my Python DP solutions for\\n[139. Word Break](https://leetcode.com/problems/word-break/discuss/322388/Standard-DP-solutions-(Bottom-up-Top-down))\\n[140. Word Break II](https://leetcode.com/problems/word-break-ii/discuss/322400/Standard-Python-DP-solutions-(Bottom-up-Top-down))\\n[472. Concatenated Words](https://leetcode.com/problems/concatenated-words/discuss/322444/Python-solutions%3A-top-down-DP-Trie)\\n\\nMethod 1: standard DP\\n```\\nLet dp[i] = a list of all possible segmentations of s[:i], i=0,1,2,...,len(s).\\nInitially set dp = [[] for _ in range(len(s) + 1)].\\nBase case: dp[0] = [\\'\\'].\\nRecursive relationship for dp[i]:\\nfor j = i-1, i-2, ..., 0,\\n     if dp[j] != [] and s[j:i] in wordDict: \\n\\t     for each s_break in dp[j]: append s_break + \\' \\' + s[j:i] to dp[i].\\n```\\n\\nSolution 1: bottom-up approach with time O(W + n^3 + 2^n) and **space O(W + n * 2^n)** (Memory Limit Exceeded, 31 / 39 test cases passed)\\n(space complexity: dp: O(n), each dp[i]: O(n), each word in dp[i]: O(n) )\\n```\\n    def wordBreak(self, s, wordDict):\\n        word_set = set(wordDict)\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0] = [\\'\\']\\n        for i in range(1, n + 1):\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and dp[j] != []:\\n                    for s_break in dp[j]:\\n                        dp[i].append(s_break + (\\' \\' if s_break != \\'\\' else \\'\\') + s[j:i])\\n                j -= 1\\n        return dp[n]\\n```\\n\\nSolution 2:  top-down approach with time O(W + n^3 + 2^n) and **space O(W + n * 2 ^ n)** (56 ms, beat 44%)\\n(dp[i] will be calculated only if it is necessary. In some test cases, not all d[i] are calculated)\\n```\\n    def wordBreak(self, s, wordDict):\\n        def recursive(i):\\n            if i in dp:\\n                return dp[i]\\n            dp[i] = []\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and recursive(j) != []:\\n                    for s_break in dp[j]:\\n                        dp[i].append(s_break + (\\' \\' if s_break != \\'\\' else \\'\\') + s[j:i])\\n                j -= 1\\n            return dp[i]\\n            \\n        word_set = set(wordDict)\\n        dp = {0: [\\'\\']}\\n        return recursive(len(s))\\n```\\n\\nMethod 2: standard DP + DFS reconstruction\\n```\\nLet dp[i] = a list of all possible last positions of segmentations of s[:i], i=0,1,2,...,len(s).\\nInitially set dp = [[] for _ in range(len(s) + 1)].\\nBase case: dp[0] = [0].\\nRecursive relationship for dp[i]:\\nfor j = i -1, i-2, ..., 0,\\n     if dp[j] != [] and s[j:i] in wordDict: \\n\\t     dp[i].append(j)\\nUse DFS to reconstruct all possible segmentations from the end to the start.\\n```\\n\\nSolution 3: bottom-up approach with time O(W + n^3 + 2^n) and **space O(W + n^2 + n * 2^n)** (52 ms, beat 59.98%)\\ncreate a set of words:  time: O(W), space: O(W)\\n\\ndynamic programming: \\ntime: O(n^3) ((O(n) subproblems, O(n) steps in the nested loop, and O(n) for substring slicing s[j:i]\\nspace: O(n^2)\\n\\nDFS reconstruction: time: O(2^n), space: O(n * 2^n)\\n\\n```\\n    def wordBreak(self, s, wordDict):\\n        def dfs(i, path):\\n            if i == 0:\\n                path.append(0)\\n                paths.append(path[::-1])\\n            else:\\n                for j in dp[i]:\\n                    dfs(j, path + [i])\\n                \\n        word_set = set(wordDict)\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0] = [0]\\n        for i in range(1, n + 1):\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and dp[j] != []:\\n                    dp[i].append(j)\\n                j -= 1\\n        paths = []\\n        dfs(n, [])\\n        res = []\\n        for path in paths:\\n            s_break = \\' \\'.join([s[path[k]:path[k+1]] for k in range(len(path) - 1)])\\n            res.append(s_break)\\n        return res\\n```\\n\\nSolution 4: top-down approach with time O(W + n^3 + 2^n) and **space O(W + n^2 + n*2^n)** (44 ms, 87.26%)\\n(dp[i] will be calculated only if it is necessary. In some test cases, not all d[i] are calculated)\\ncreate a set of words:  time: O(W), space: O(W)\\n\\ndynamic programming: \\ntime: O(n^3) ((O(n) subproblems, O(n) steps in the nested loop, and O(n) for substring slicing s[j:i]\\nspace: O(n^2)\\n\\nDFS reconstruction: time: O(2^n), space: O(n * 2^n)\\n```\\n    def wordBreak(self, s, wordDict):\\n        def dfs(i, path):\\n            if i == 0:\\n                path.append(0)\\n                paths.append(path[::-1])\\n            else:\\n                for j in dp[i]:\\n                    dfs(j, path + [i])\\n        \\n        def recursive(i):\\n            if i in dp:\\n                return dp[i]\\n            dp[i] = []\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and recursive(j) != []:\\n                    dp[i].append(j)\\n                j -= 1\\n            return dp[i]\\n            \\n        word_set = set(wordDict)\\n        dp = {0: 0}\\n        recursive(len(s))\\n        paths = []\\n        dfs(len(s), [])\\n        res = []\\n        for path in paths:\\n            s_break = \\' \\'.join([s[path[k]:path[k+1]] for k in range(len(path) - 1)])\\n            res.append(s_break)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nLet dp[i] = a list of all possible segmentations of s[:i], i=0,1,2,...,len(s).\\nInitially set dp = [[] for _ in range(len(s) + 1)].\\nBase case: dp[0] = [\\'\\'].\\nRecursive relationship for dp[i]:\\nfor j = i-1, i-2, ..., 0,\\n     if dp[j] != [] and s[j:i] in wordDict: \\n\\t     for each s_break in dp[j]: append s_break + \\' \\' + s[j:i] to dp[i].\\n```\n```\\n    def wordBreak(self, s, wordDict):\\n        word_set = set(wordDict)\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0] = [\\'\\']\\n        for i in range(1, n + 1):\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and dp[j] != []:\\n                    for s_break in dp[j]:\\n                        dp[i].append(s_break + (\\' \\' if s_break != \\'\\' else \\'\\') + s[j:i])\\n                j -= 1\\n        return dp[n]\\n```\n```\\n    def wordBreak(self, s, wordDict):\\n        def recursive(i):\\n            if i in dp:\\n                return dp[i]\\n            dp[i] = []\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and recursive(j) != []:\\n                    for s_break in dp[j]:\\n                        dp[i].append(s_break + (\\' \\' if s_break != \\'\\' else \\'\\') + s[j:i])\\n                j -= 1\\n            return dp[i]\\n            \\n        word_set = set(wordDict)\\n        dp = {0: [\\'\\']}\\n        return recursive(len(s))\\n```\n```\\nLet dp[i] = a list of all possible last positions of segmentations of s[:i], i=0,1,2,...,len(s).\\nInitially set dp = [[] for _ in range(len(s) + 1)].\\nBase case: dp[0] = [0].\\nRecursive relationship for dp[i]:\\nfor j = i -1, i-2, ..., 0,\\n     if dp[j] != [] and s[j:i] in wordDict: \\n\\t     dp[i].append(j)\\nUse DFS to reconstruct all possible segmentations from the end to the start.\\n```\n```\\n    def wordBreak(self, s, wordDict):\\n        def dfs(i, path):\\n            if i == 0:\\n                path.append(0)\\n                paths.append(path[::-1])\\n            else:\\n                for j in dp[i]:\\n                    dfs(j, path + [i])\\n                \\n        word_set = set(wordDict)\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0] = [0]\\n        for i in range(1, n + 1):\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and dp[j] != []:\\n                    dp[i].append(j)\\n                j -= 1\\n        paths = []\\n        dfs(n, [])\\n        res = []\\n        for path in paths:\\n            s_break = \\' \\'.join([s[path[k]:path[k+1]] for k in range(len(path) - 1)])\\n            res.append(s_break)\\n        return res\\n```\n```\\n    def wordBreak(self, s, wordDict):\\n        def dfs(i, path):\\n            if i == 0:\\n                path.append(0)\\n                paths.append(path[::-1])\\n            else:\\n                for j in dp[i]:\\n                    dfs(j, path + [i])\\n        \\n        def recursive(i):\\n            if i in dp:\\n                return dp[i]\\n            dp[i] = []\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and recursive(j) != []:\\n                    dp[i].append(j)\\n                j -= 1\\n            return dp[i]\\n            \\n        word_set = set(wordDict)\\n        dp = {0: 0}\\n        recursive(len(s))\\n        paths = []\\n        dfs(len(s), [])\\n        res = []\\n        for path in paths:\\n            s_break = \\' \\'.join([s[path[k]:path[k+1]] for k in range(len(path) - 1)])\\n            res.append(s_break)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 309369,
                "title": "java-95-11-runtime-4ms-99-77-memory-36-2-mb-human-readable",
                "content": "```\\nclass Solution {\\n    public List<String> wordBreak(String wordToBreak, List<String> wordDict) {        \\n        return findSolutions(wordToBreak, wordDict, new HashMap<>());\\n    }\\n    \\n    public List<String> findSolutions(String wordToBreak, List<String> wordDict, Map<String, List<String>> wordBrokenDict){\\n        if(wordBrokenDict.containsKey(wordToBreak)){\\n            return wordBrokenDict.get(wordToBreak);\\n        }\\n        \\n        List<String> solutions = new ArrayList<>();\\n        for(String word: wordDict){\\n            if(!wordToBreak.startsWith(word)){\\n                continue;\\n            }\\n            \\n            if(wordToBreak.length() == word.length()){\\n                solutions.add(word);\\n                continue;\\n            }\\n            \\n            List<String> subSolutions = findSolutions(wordToBreak.substring(word.length()), wordDict, wordBrokenDict);\\n            for(String subSolution: subSolutions) {\\n                StringBuilder strBuilder = new StringBuilder();\\n                strBuilder.append(word).append(\\' \\').append(subSolution);\\n                solutions.add(strBuilder.toString());\\n            }\\n        }\\n        \\n        wordBrokenDict.put(wordToBreak, solutions);\\n        return solutions;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String wordToBreak, List<String> wordDict) {        \\n        return findSolutions(wordToBreak, wordDict, new HashMap<>());\\n    }\\n    \\n    public List<String> findSolutions(String wordToBreak, List<String> wordDict, Map<String, List<String>> wordBrokenDict){\\n        if(wordBrokenDict.containsKey(wordToBreak)){\\n            return wordBrokenDict.get(wordToBreak);\\n        }\\n        \\n        List<String> solutions = new ArrayList<>();\\n        for(String word: wordDict){\\n            if(!wordToBreak.startsWith(word)){\\n                continue;\\n            }\\n            \\n            if(wordToBreak.length() == word.length()){\\n                solutions.add(word);\\n                continue;\\n            }\\n            \\n            List<String> subSolutions = findSolutions(wordToBreak.substring(word.length()), wordDict, wordBrokenDict);\\n            for(String subSolution: subSolutions) {\\n                StringBuilder strBuilder = new StringBuilder();\\n                strBuilder.append(word).append(\\' \\').append(subSolution);\\n                solutions.add(strBuilder.toString());\\n            }\\n        }\\n        \\n        wordBrokenDict.put(wordToBreak, solutions);\\n        return solutions;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222797,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        def dfs(i):\\n            if i == len(s):\\n                return [\"\"]\\n            if i in dic:\\n                return dic[i]\\n            res = []\\n            for j in range(i, len(s)):\\n                head = s[i:j+1]\\n                if head in wordSet:\\n                    tmp = dfs(j+1)\\n                    for string in tmp:\\n                        string = head +\" \"+string\\n                        res.append(string.strip())\\n            dic[i] = res\\n            return res\\n        \\n        dic = {}\\n        wordSet = set(wordDict)\\n        return dfs(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        def dfs(i):\\n            if i == len(s):\\n                return [\"\"]\\n            if i in dic:\\n                return dic[i]\\n            res = []\\n            for j in range(i, len(s)):\\n                head = s[i:j+1]\\n                if head in wordSet:\\n                    tmp = dfs(j+1)\\n                    for string in tmp:\\n                        string = head +\" \"+string\\n                        res.append(string.strip())\\n            dic[i] = res\\n            return res\\n        \\n        dic = {}\\n        wordSet = set(wordDict)\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190915,
                "title": "c-neat",
                "content": "```\nclass Solution {\npublic:\n    unordered_map<int, vector<string>> umap;\n    \n    vector<string> helper(string &s, unordered_set<string> &dict, int pos) {\n        if (umap.find(pos) != umap.end())\n            return umap[pos];\n        \n        vector<string> res;\n\n        if (dict.find(s.substr(pos)) != dict.end())\n            res.push_back(s.substr(pos));\n        \n        for (int end = pos + 1; end < s.size(); ++end) {\n            string subs = s.substr(pos, end-pos);\n            if (dict.find(subs) != dict.end()) {\n                vector<string> nextlist = helper(s, dict, end);\n                for (auto list_string : nextlist) {\n                    res.push_back(subs + \" \" + list_string);\n                }\n            }\n        }\n        umap[pos] = res;\n        return umap[pos];\n    } \n    \n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\n        return helper(s, dict, 0);\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    unordered_map<int, vector<string>> umap;\n    \n    vector<string> helper(string &s, unordered_set<string> &dict, int pos) {\n        if (umap.find(pos) != umap.end())\n            return umap[pos];\n        \n        vector<string> res;\n\n        if (dict.find(s.substr(pos)) != dict.end())\n            res.push_back(s.substr(pos));\n        \n        for (int end = pos + 1; end < s.size(); ++end) {\n            string subs = s.substr(pos, end-pos);\n            if (dict.find(subs) != dict.end()) {\n                vector<string> nextlist = helper(s, dict, end);\n                for (auto list_string : nextlist) {\n                    res.push_back(subs + \" \" + list_string);\n                }\n            }\n        }\n        umap[pos] = res;\n        return umap[pos];\n    } \n    \n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\n        return helper(s, dict, 0);\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 116479,
                "title": "solution-using-bfs-idea-from-word-break-i",
                "content": "  This solution is inspired by BFS from Word Break I. Exact same code, just modifying a little bit. First,\tget rid of `visited[]` array. Second, and another queue, this queue will go along with the index queue to store the substrings level by level of the tree.\n\n\tpublic List<String> wordBreak(String s, List<String> wordDict) {\n        Set<String> wordDictSet = new HashSet(wordDict);\n        Queue<Integer> queue = new LinkedList<>();        \n        Queue<String> queueStr = new LinkedList<>();\n        List<String> list = new ArrayList<>();        \n        \n        queue.add(0);\n        queueStr.offer(\"\");\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                String currentStr = queueStr.poll();\n                int start = queue.poll();          \n                for (int end = start + 1; end <= s.length(); end++) {\n                    String subStr = s.substring(start, end);\n                    if (wordDictSet.contains(subStr)) {\n                        String newStr = currentStr + subStr;\n                        if (end == s.length())\n                            list.add(newStr);\n                        else {\n                            queueStr.add(newStr + \" \");\n                            queue.add(end);\n                        }\n                    }\n                }\n            }\n        }                                        \n        return list;            \n    }",
                "solutionTags": [],
                "code": "\tpublic List<String> wordBreak(String s, List<String> wordDict) {\n        Set<String> wordDictSet = new HashSet(wordDict);\n        Queue<Integer> queue = new LinkedList<>();        \n        Queue<String> queueStr = new LinkedList<>();\n        List<String> list = new ArrayList<>();        \n        queue.add(0);\n        queueStr.offer(\"\");\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                String currentStr = queueStr.poll();\n                int start = queue.poll();          \n                for (int end = start + 1; end <= s.length(); end++) {\n                    String subStr = s.substring(start, end);\n                    if (wordDictSet.contains(subStr)) {\n                        String newStr = currentStr + subStr;\n                        if (end == s.length())\n                            list.add(newStr);\n                        else {\n                            queueStr.add(newStr + \" \");\n                            queue.add(end);\n                        }\n                    }\n                }\n            }\n        }                                        \n        return list;            \n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44301,
                "title": "c-12ms-dp-solution",
                "content": "The flag can be used to save repetitive examinations of of bad substrs.\\n\\n    class Solution {\\n    public:\\n    void helper(vector<bool>& flag, string s, int n, string pre, vector<string> &res, unordered_set<string>& wordDict){\\n        if (n>=s.size()) {res.push_back(pre);return;}\\n        for (int i=n;i<s.size();i++){\\n            if (flag[i+1] && wordDict.find(s.substr(n,i-n+1))!=wordDict.end()){\\n                helper(flag,s,i+1,pre+s.substr(n,i-n+1)+\" \",res,wordDict);\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n        vector<string> res;\\n        if (s.empty()) {res.push_back(\"\");return res;}\\n        int k=s.size();\\n        vector<bool> flag(k+1,0);\\n        flag[k] = 1;\\n        for (int i=k-1;i>=0;i--){\\n            int j=i;\\n            while(j<=k-1){\\n                if (flag[j+1] && wordDict.find(s.substr(i,j-i+1))!=wordDict.end()){\\n                    flag[i] = 1;break;\\n                }\\n                j++;\\n            }\\n        }\\n        if (flag[0]==0) return res;   // no possible solution if flag[0]==false\\n        helper(flag,s,0, \"\",res,wordDict);\\n        for (auto &s:res){\\n            s.pop_back();\\n        }\\n        return res;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    void helper(vector<bool>& flag, string s, int n, string pre, vector<string> &res, unordered_set<string>& wordDict){\\n        if (n>=s.size()) {res.push_back(pre);return;}",
                "codeTag": "Java"
            },
            {
                "id": 44323,
                "title": "8-ms-c-solution-with-explanation-dp-no-recursion",
                "content": "This solution is a two-stage dynamic program.  First: we use the solution from the Word Break problem to find all the break points -- the positions where we might possibly insert a space.  The second dynamic program then builds up the actual solution by skipping through the break-points.\\n\\nNote: comments use python-like notation to indicate substrings.  That is: s[:i] is the substring of s from position 0 up to, but not including, position j.\\n\\n    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n        int n = s.size();\\n        if (n == 0)\\n            return {};\\n            \\n        // First: identify the break points (and that there exists at least one way to break it).\\n        // D[i] = True if it is possible to break up s[:i] in at least one way.\\n        vector<bool> D(n+1, false);\\n        D[0] = true;\\n        for (int i=1; i <= n; i++) {\\n            for (int j=i-1; j >= 0 && D[i] == false; j--) {\\n                D[i] = D[j] && wordDict.find(s.substr(j, i-j)) != wordDict.end();\\n            }\\n        }\\n        \\n        if (!D[n])  // There is no solution.\\n            return {};\\n            \\n        // Find the i such that D[i] is true.\\n        // In given example: break_points = [0,3,4,7,10].\\n        vector<int> break_points;\\n        for (int i=0; i < D.size(); i++) {\\n            if (D[i]) {\\n                break_points.push_back(i);\\n            }\\n        }\\n        \\n        int m = break_points.size();\\n\\n        // Now find the solution based on the breakpoints.\\n        // E[i]: Set of all strings we can create using s[:break_points[i]].\\n        // In the example: E[0] = [\"\"], E[1] = [\"cat\"], E[2] = [\"cats\"], E[3] = [\"cats and\", cat sand\"]\\n        vector<vector<string>> E(m); \\n        E[0] = {\"\"};\\n        for (int i = 0; i < m; i++) {\\n            for (int j=i-1; j >=0; j--) {  // Will now compute E\\n                // t is the string defined from breakpoints i to j\\n                string t = s.substr(break_points[j], break_points[i] - break_points[j]);  \\n                if (wordDict.find(t) != wordDict.end()) {\\n                    for (auto& u : E[j]) \\n                        E[i].push_back(u + \" \" + t);\\n                }\\n            }\\n        }\\n        \\n        // Need to chop off the extra \" \" at the start of each string in E[m-1]\\n        vector<string> R;\\n        transform(E[m-1].begin(), E[m-1].end(), back_inserter(R), [](string& s) {return s.substr(1,s.size()-1);});\\n        return R;\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "This solution is a two-stage dynamic program.  First: we use the solution from the Word Break problem to find all the break points -- the positions where we might possibly insert a space.  The second dynamic program then builds up the actual solution by skipping through the break-points.\\n\\nNote: comments use python-like notation to indicate substrings.  That is: s[:i] is the substring of s from position 0 up to, but not including, position j.\\n\\n    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n        int n = s.size();\\n        if (n == 0)\\n            return {};\\n            \\n        // First: identify the break points (and that there exists at least one way to break it).\\n        // D[i] = True if it is possible to break up s[:i] in at least one way.\\n        vector<bool> D(n+1, false);\\n        D[0] = true;\\n        for (int i=1; i <= n; i++) {\\n            for (int j=i-1; j >= 0 && D[i] == false; j--) {\\n                D[i] = D[j] && wordDict.find(s.substr(j, i-j)) != wordDict.end();\\n            }\\n        }\\n        \\n        if (!D[n])  // There is no solution.\\n            return {};\\n            \\n        // Find the i such that D[i] is true.\\n        // In given example: break_points = [0,3,4,7,10].\\n        vector<int> break_points;\\n        for (int i=0; i < D.size(); i++) {\\n            if (D[i]) {\\n                break_points.push_back(i);\\n            }\\n        }\\n        \\n        int m = break_points.size();\\n\\n        // Now find the solution based on the breakpoints.\\n        // E[i]: Set of all strings we can create using s[:break_points[i]].\\n        // In the example: E[0] = [\"\"], E[1] = [\"cat\"], E[2] = [\"cats\"], E[3] = [\"cats and\", cat sand\"]\\n        vector<vector<string>> E(m); \\n        E[0] = {\"\"};\\n        for (int i = 0; i < m; i++) {\\n            for (int j=i-1; j >=0; j--) {  // Will now compute E\\n                // t is the string defined from breakpoints i to j\\n                string t = s.substr(break_points[j], break_points[i] - break_points[j]);  \\n                if (wordDict.find(t) != wordDict.end()) {\\n                    for (auto& u : E[j]) \\n                        E[i].push_back(u + \" \" + t);\\n                }\\n            }\\n        }\\n        \\n        // Need to chop off the extra \" \" at the start of each string in E[m-1]\\n        vector<string> R;\\n        transform(E[m-1].begin(), E[m-1].end(), back_inserter(R), [](string& s) {return s.substr(1,s.size()-1);});\\n        return R;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44321,
                "title": "16ms-java-dp-dfs-solution",
                "content": "    public class Solution {\\n        List<String> result;\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            result = new ArrayList<String>();\\n            int n = s.length();\\n            List<Integer>[] pointer = new List[n];\\n            for(int i=0;i<n;i++) pointer[i]=new ArrayList<Integer>();\\n            //DP to record break point\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<=i;j++){\\n                    if(wordDict.contains(s.substring(j,i+1))&&(j==0||pointer[j-1].size()>0))\\n                        pointer[i].add(j);\\n                }\\n            }\\n            helper(pointer, s, n-1, \"\");\\n            return result;\\n        }\\n        //DFS to retrieve results\\n        public void helper(List<Integer>[] pointer, String s, int i, String pattern){\\n            if(i<0){\\n                result.add(pattern);\\n                return;\\n            }\\n            for(Integer item:pointer[i]){\\n                String nextPattern = pattern.length()==0?s.substring(item,i+1):s.substring(item,i+1)+\" \"+pattern;\\n                helper(pointer, s, item-1, nextPattern);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        List<String> result;\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            result = new ArrayList<String>();\\n            int n = s.length();\\n            List<Integer>[] pointer = new List[n];\\n            for(int i=0;i<n;i++) pointer[i]=new ArrayList<Integer>();\\n            //DP to record break point\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<=i;j++){\\n                    if(wordDict.contains(s.substring(j,i+1))&&(j==0||pointer[j-1].size()>0))\\n                        pointer[i].add(j);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 44386,
                "title": "my-concise-c-solution",
                "content": "It seems we have to have another round of getting result after the DP search (to not exceed memory limit). Here I inserted spaces to the original string instead of constructing strings.\\n\\n    vector<string> wordBreak(string s, unordered_set<string> &dict)\\n    {\\n    \\tvector<vector<int>> flag(s.size() + 1, vector<int>());\\n    \\tflag[0].push_back(0);\\n    \\tfor (int i = 1; i <= s.size(); i++)\\n    \\t{\\n    \\t\\tfor (int j = 0; j < i; j++)\\n    \\t\\t{\\n    \\t\\t\\tif (!flag[j].empty() && dict.find(s.substr(j, i - j)) != dict.end())\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tflag[i].push_back(j);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\tvector<string> result;\\n    \\tgetResult(result, flag, s, s.size());\\n    \\treturn result;\\n    }\\n    \\n    void getResult(vector<string> &result, vector<vector<int>> &flag, string s, int n)\\n    {\\n    \\tfor (int i : flag[n])\\n    \\t{\\n    \\t\\tif (i == 0)\\n    \\t\\t{\\n    \\t\\t\\tresult.push_back(s);\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\ts.insert(s.begin() + i, ' ');\\n    \\t\\tgetResult(result, flag, s, i);\\n    \\t\\ts.erase(i, 1);\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "It seems we have to have another round of getting result after the DP search (to not exceed memory limit). Here I inserted spaces to the original string instead of constructing strings.\\n\\n    vector<string> wordBreak(string s, unordered_set<string> &dict)\\n    {\\n    \\tvector<vector<int>> flag(s.size() + 1, vector<int>());\\n    \\tflag[0].push_back(0);\\n    \\tfor (int i = 1; i <= s.size(); i++)\\n    \\t{\\n    \\t\\tfor (int j = 0; j < i; j++)\\n    \\t\\t{\\n    \\t\\t\\tif (!flag[j].empty() && dict.find(s.substr(j, i - j)) != dict.end())\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tflag[i].push_back(j);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\tvector<string> result;\\n    \\tgetResult(result, flag, s, s.size());\\n    \\treturn result;\\n    }\\n    \\n    void getResult(vector<string> &result, vector<vector<int>> &flag, string s, int n)\\n    {\\n    \\tfor (int i : flag[n])\\n    \\t{\\n    \\t\\tif (i == 0)\\n    \\t\\t{\\n    \\t\\t\\tresult.push_back(s);\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\ts.insert(s.begin() + i, ' ');\\n    \\t\\tgetResult(result, flag, s, i);\\n    \\t\\ts.erase(i, 1);\\n    \\t}\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44428,
                "title": "my-solution-using-python",
                "content": "I used a *Trie* to store all the dict words, and then for every position *i* in s, find those position(s) *ed* so that [st, ed) is a dict word. \\n\\nAfter that is basiclly a search problem, simply using dfs (or you can call it memorized search) to check  whether from position *i* we can divide s[i:] with dict words.(say this array is called v, and v[i] = True if s[i:] is dividable.\\n\\nIf v[0] is True, then find all the solutions using recurse.\\n\\nHere is my code using Python.\\n\\n\\n    class Node:\\n    \\tdef __init__(self):\\n    \\t\\tself.next = [ None for i in range(26) ]\\n    \\t\\tself.mark = False\\n    \\n    class Solution:\\n    \\t# @param s, a string\\n    \\t# @param dict, a set of string\\n    \\t# @return a list of strings\\n    \\tdef insert(self, word):\\n    \\t\\tp = self.root\\n    \\t\\tfor s in word:\\n    \\t\\t\\tk = ord(s) - ord('a')\\n    \\t\\t\\tif p.next[k] == None:\\n    \\t\\t\\t\\tp.next[k] = Node()\\n    \\t\\t\\tp = p.next[k]\\n    \\t\\tp.mark = True\\n    \\n    \\tdef build(self, s, st):\\n    \\t\\tn = len(s)\\n    \\t\\tp = self.root\\n    \\t\\tfor i in range(st, n):\\n    \\t\\t\\tif p == None:\\n    \\t\\t\\t\\treturn \\n    \\t\\t\\tk = ord(s[i]) - ord('a')\\n    \\t\\t\\tif p.next[k] == None:\\n    \\t\\t\\t\\treturn\\n    \\t\\t\\tp = p.next[k]\\n    \\t\\t\\tif p.mark:\\n    \\t\\t\\t\\tself.g[st].append(i + 1)    # [st, i + 1) is a word in dict\\n    \\tdef path(self, st):\\n    \\t\\tif st == self.n:\\n    \\t\\t\\tself.v[st] = 1\\n    \\t\\t\\treturn 1\\n    \\t\\tif self.v[st] != -1:\\n    \\t\\t\\treturn self.v[st]\\n    \\t\\tfor ed in self.g[st]:\\n    \\t\\t\\tif self.path(ed):\\n    \\t\\t\\t\\tself.v[st] = 1\\n    \\t\\tif self.v[st] == -1:\\n    \\t\\t\\tself.v[st] = 0\\n    \\t\\treturn self.v[st]\\n    \\n    \\tdef get(self, st):\\n    \\t\\tif st == self.n:\\n    \\t\\t\\treturn []\\n    \\t\\tres = []\\n    \\t\\tfor ed in self.g[st]:\\n    \\t\\t\\tif self.v[ed] == 1:\\n    \\t\\t\\t\\ttmp = self.get(ed)\\n    \\t\\t\\t\\tss = self.s[st:ed]\\n    \\t\\t\\t\\tfor sp in tmp:\\n    \\t\\t\\t\\t\\tres.append(ss + ' ' + sp)\\n    \\t\\t\\t\\tif tmp == []:\\n    \\t\\t\\t\\t\\tres.append(ss)\\n    \\t\\treturn res\\n    \\n    \\tdef wordBreak(self, s, dict):\\n    \\t\\tn = len(s)\\n    \\t\\tself.root = Node()\\n    \\t\\tself.n = n\\n    \\t\\tself.s = s\\n    \\t\\t#self.dict = dict\\n    \\t\\tself.g = [ [] for i in range(n + 1) ]\\n    \\t\\tself.v = [ -1 for i in range(n + 1) ]\\n    \\t\\tfor word in dict:\\n    \\t\\t\\tself.insert(word)\\n    \\t\\tfor i in range(n):\\n    \\t\\t\\tself.build(s, i)\\n    \\t\\tok = self.path(0)\\n    \\t\\tret = []\\n    \\t\\tif ok == 1:\\n    \\t\\t\\tret = self.get(0)\\n    \\t\\treturn ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "I used a *Trie* to store all the dict words, and then for every position *i* in s, find those position(s) *ed* so that [st, ed) is a dict word. \\n\\nAfter that is basiclly a search problem, simply using dfs (or you can call it memorized search) to check  whether from position *i* we can divide s[i:] with dict words.(say this array is called v, and v[i] = True if s[i:] is dividable.\\n\\nIf v[0] is True, then find all the solutions using recurse.\\n\\nHere is my code using Python.\\n\\n\\n    class Node:\\n    \\tdef __init__(self):\\n    \\t\\tself.next = [ None for i in range(26) ]\\n    \\t\\tself.mark = False\\n    \\n    class Solution:\\n    \\t# @param s, a string\\n    \\t# @param dict, a set of string\\n    \\t# @return a list of strings\\n    \\tdef insert(self, word):\\n    \\t\\tp = self.root\\n    \\t\\tfor s in word:\\n    \\t\\t\\tk = ord(s) - ord('a')\\n    \\t\\t\\tif p.next[k] == None:\\n    \\t\\t\\t\\tp.next[k] = Node()\\n    \\t\\t\\tp = p.next[k]\\n    \\t\\tp.mark = True\\n    \\n    \\tdef build(self, s, st):\\n    \\t\\tn = len(s)\\n    \\t\\tp = self.root\\n    \\t\\tfor i in range(st, n):\\n    \\t\\t\\tif p == None:\\n    \\t\\t\\t\\treturn \\n    \\t\\t\\tk = ord(s[i]) - ord('a')\\n    \\t\\t\\tif p.next[k] == None:\\n    \\t\\t\\t\\treturn\\n    \\t\\t\\tp = p.next[k]\\n    \\t\\t\\tif p.mark:\\n    \\t\\t\\t\\tself.g[st].append(i + 1)    # [st, i + 1) is a word in dict\\n    \\tdef path(self, st):\\n    \\t\\tif st == self.n:\\n    \\t\\t\\tself.v[st] = 1\\n    \\t\\t\\treturn 1\\n    \\t\\tif self.v[st] != -1:\\n    \\t\\t\\treturn self.v[st]\\n    \\t\\tfor ed in self.g[st]:\\n    \\t\\t\\tif self.path(ed):\\n    \\t\\t\\t\\tself.v[st] = 1\\n    \\t\\tif self.v[st] == -1:\\n    \\t\\t\\tself.v[st] = 0\\n    \\t\\treturn self.v[st]\\n    \\n    \\tdef get(self, st):\\n    \\t\\tif st == self.n:\\n    \\t\\t\\treturn []\\n    \\t\\tres = []\\n    \\t\\tfor ed in self.g[st]:\\n    \\t\\t\\tif self.v[ed] == 1:\\n    \\t\\t\\t\\ttmp = self.get(ed)\\n    \\t\\t\\t\\tss = self.s[st:ed]\\n    \\t\\t\\t\\tfor sp in tmp:\\n    \\t\\t\\t\\t\\tres.append(ss + ' ' + sp)\\n    \\t\\t\\t\\tif tmp == []:\\n    \\t\\t\\t\\t\\tres.append(ss)\\n    \\t\\treturn res\\n    \\n    \\tdef wordBreak(self, s, dict):\\n    \\t\\tn = len(s)\\n    \\t\\tself.root = Node()\\n    \\t\\tself.n = n\\n    \\t\\tself.s = s\\n    \\t\\t#self.dict = dict\\n    \\t\\tself.g = [ [] for i in range(n + 1) ]\\n    \\t\\tself.v = [ -1 for i in range(n + 1) ]\\n    \\t\\tfor word in dict:\\n    \\t\\t\\tself.insert(word)\\n    \\t\\tfor i in range(n):\\n    \\t\\t\\tself.build(s, i)\\n    \\t\\tok = self.path(0)\\n    \\t\\tret = []\\n    \\t\\tif ok == 1:\\n    \\t\\t\\tret = self.get(0)\\n    \\t\\treturn ret",
                "codeTag": "Java"
            },
            {
                "id": 3567048,
                "title": "brute-force-c-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nvoid solve(int i,int &n,string s1,string s2,string &s,unordered_set<string> &st,vector<string> &ans){\\n    if(i>=n){\\n        cout<<s2<<\" \"<<s1<<endl;\\n        if(st.count(s1)){\\n            s2 += s1;\\n            ans.push_back(s2);\\n        }\\n        return;\\n    }\\n    string str = \"\";\\n    if(st.count(s1)){\\n        solve(i+1,n,str+s[i],s2+s1+\" \",s,st,ans);\\n    }\\n    solve(i+1,n,str+s1+s[i],s2,s,st,ans);\\n}\\n    vector<string> wordBreak(string str, vector<string>& wordDict) {\\n        unordered_set<string> s;\\n        for(auto &i: wordDict){\\n            s.insert(i);\\n        }\\n        vector<string> ans;\\n        int n = str.length();\\n        solve(0,n,\"\",\"\",str,s,ans);\\n        // for(auto &i: ans)i.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid solve(int i,int &n,string s1,string s2,string &s,unordered_set<string> &st,vector<string> &ans){\\n    if(i>=n){\\n        cout<<s2<<\" \"<<s1<<endl;\\n        if(st.count(s1)){\\n            s2 += s1;\\n            ans.push_back(s2);\\n        }\\n        return;\\n    }\\n    string str = \"\";\\n    if(st.count(s1)){\\n        solve(i+1,n,str+s[i],s2+s1+\" \",s,st,ans);\\n    }\\n    solve(i+1,n,str+s1+s[i],s2,s,st,ans);\\n}\\n    vector<string> wordBreak(string str, vector<string>& wordDict) {\\n        unordered_set<string> s;\\n        for(auto &i: wordDict){\\n            s.insert(i);\\n        }\\n        vector<string> ans;\\n        int n = str.length();\\n        solve(0,n,\"\",\"\",str,s,ans);\\n        // for(auto &i: ans)i.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3000934,
                "title": "backtracking-5ms",
                "content": "# Intuition\\nThe phrase \"all possible solutions\" suggests a backtracking approach. Using DP doesn\\'t save time here. The reason that DP can reduce an exponential running time to polynomial running time is that it doesn\\'t requires explicit enumeration of all cases as long as we are certain we have the optimal value for each subproblem. The cases that aren\\'t optimal can be ignored in DP, but not in backtracking.\\n\\n# Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Time complexity: $$O(2^n)$$. It\\'s proportional to the number of nodes in the recursion tree. And it\\'s the same as total number of ways to partition a string to all combinations of substrings.\\n\\n- Space complexity: $$O(n)$$. Only the StringBuilder requires extra memory.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> results = new LinkedList<>();\\n        StringBuilder tempHolder = new StringBuilder();\\n        findNextWord(results, tempHolder, s, wordDict, 0);\\n        return results;\\n    }\\n\\n    private void findNextWord(List<String> results, StringBuilder tempHolder, String s, List<String> wordDict, int start) {\\n        if (start == s.length()) {\\n            results.add(tempHolder.toString().trim());\\n            return;\\n        }\\n\\n        for (int end = start; end < s.length(); end++) {\\n            String word = s.substring(start, end + 1);\\n            if (wordDict.contains(word)) {\\n                tempHolder.append(word + \" \");\\n                findNextWord(results, tempHolder, s, wordDict, end + 1);\\n                tempHolder.delete(tempHolder.length() - word.length() - 1, tempHolder.length());\\n            }\\n        }\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> results = new LinkedList<>();\\n        StringBuilder tempHolder = new StringBuilder();\\n        findNextWord(results, tempHolder, s, wordDict, 0);\\n        return results;\\n    }\\n\\n    private void findNextWord(List<String> results, StringBuilder tempHolder, String s, List<String> wordDict, int start) {\\n        if (start == s.length()) {\\n            results.add(tempHolder.toString().trim());\\n            return;\\n        }\\n\\n        for (int end = start; end < s.length(); end++) {\\n            String word = s.substring(start, end + 1);\\n            if (wordDict.contains(word)) {\\n                tempHolder.append(word + \" \");\\n                findNextWord(results, tempHolder, s, wordDict, end + 1);\\n                tempHolder.delete(tempHolder.length() - word.length() - 1, tempHolder.length());\\n            }\\n        }\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987454,
                "title": "c-simple-recursive-approach-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(string s, unordered_set<string>& dict,int start, int index,string current,vector<string>& ans){\\n        if(start==s.size()){\\n            ans.push_back(current);\\n            return;\\n        }\\n        if(index==s.size()) return;\\n\\n        string sub=s.substr(start,index-start+1);\\n\\n        if(dict.count(sub)>0){\\n            string recursion;\\n            if(current.size()==0) recursion=sub;\\n            else recursion=current+\" \"+sub; \\n            helper(s,dict,index+1,index+1,recursion,ans);\\n        }\\n        helper(s,dict,start,index+1,current,ans);\\n        return;\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict;\\n        for(int i=0;i<wordDict.size();i++){\\n                dict.insert(wordDict[i]);\\n        }\\n        vector<string> ans;\\n        helper(s,dict,0,0,\"\",ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(string s, unordered_set<string>& dict,int start, int index,string current,vector<string>& ans){\\n        if(start==s.size()){\\n            ans.push_back(current);\\n            return;\\n        }\\n        if(index==s.size()) return;\\n\\n        string sub=s.substr(start,index-start+1);\\n\\n        if(dict.count(sub)>0){\\n            string recursion;\\n            if(current.size()==0) recursion=sub;\\n            else recursion=current+\" \"+sub; \\n            helper(s,dict,index+1,index+1,recursion,ans);\\n        }\\n        helper(s,dict,start,index+1,current,ans);\\n        return;\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict;\\n        for(int i=0;i<wordDict.size();i++){\\n                dict.insert(wordDict[i]);\\n        }\\n        vector<string> ans;\\n        helper(s,dict,0,0,\"\",ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778161,
                "title": "recursion-dp-always-does-the-job",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nrecursive approach\\n# Complexity\\n- Time complexity:n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:high\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726138,
                "title": "easy-to-understand-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> st;\\n    void f(int ind,string str,string s,vector<string>& ans){\\n\\t\\n        if(ind==s.length()){\\n            ans.push_back(str);\\n            return ;\\n        }\\n\\t\\t\\n        string temp = \"\";                              //temporary string for finding string in dictionary from ind\\n\\t\\t\\n        for(int i=ind;i<s.length();i++){\\n            temp += s[i];\\n            if(st.count(temp)){\\n                string k = str;                         //By initialising str to k then we don\\'t need to do backtrack\\n                if(str.size()!=0) k += \" \";         // Edge Case \\n                k += temp;\\n                f(i+1,k,s,ans);\\n            }\\n        }\\n    }\\n\\t\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        for(auto i:wordDict) st.insert(i);\\n        int ind=0;\\n        vector<string> ans;\\n        string str = \"\";\\n        f(ind,str,s,ans);                  //Function Call\\n        return ans;\\n    }\\n};\\n```\\n\\n# ****PLease Upvote",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> st;\\n    void f(int ind,string str,string s,vector<string>& ans){\\n\\t\\n        if(ind==s.length()){\\n            ans.push_back(str);\\n            return ;\\n        }\\n\\t\\t\\n        string temp = \"\";                              //temporary string for finding string in dictionary from ind\\n\\t\\t\\n        for(int i=ind;i<s.length();i++){\\n            temp += s[i];\\n            if(st.count(temp)){\\n                string k = str;                         //By initialising str to k then we don\\'t need to do backtrack\\n                if(str.size()!=0) k += \" \";         // Edge Case \\n                k += temp;\\n                f(i+1,k,s,ans);\\n            }\\n        }\\n    }\\n\\t\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        for(auto i:wordDict) st.insert(i);\\n        int ind=0;\\n        vector<string> ans;\\n        string str = \"\";\\n        f(ind,str,s,ans);                  //Function Call\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288246,
                "title": "diagram-explanation-dp-backtracking-trie-solution",
                "content": "## Code is at the bottom in C++\\nLets understand this with the first example. Consider making a trie to store words for relatively faster lookup.\\n![image](https://assets.leetcode.com/users/images/9ff5e4ec-6db6-40eb-ba09-3281696025b8_1657941546.7179804.png)\\nNow suppose we are at \\'d\\' of \"catsand\", are there possible breaks till here?\\n![image](https://assets.leetcode.com/users/images/85680f03-064a-42dd-8e41-01abaae1b129_1657941962.613613.png)\\nAll we need to store there is the indices of beginning of suffixes so that later on when we need to choose where to do the slicing, we have our index with us.\\nIntuitively enough, if there are no possible indexes that made a suffix to form the string, we can\\'t form any permutation. Now, onto the code.\\n```c++\\nstruct trie {\\n    trie *ch[26];\\n    bool isEnd;\\n    trie()\\n    {\\n        for(int i=0;i<26;i++) ch[i]=NULL;\\n        isEnd=false;\\n    }\\n};\\nvoid insert(trie *head,string &s)\\n{\\n    int n=s.length();\\n    trie *curr=head;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(!curr->ch[s[i]-\\'a\\']) curr->ch[s[i]-\\'a\\']=new trie();\\n        curr=curr->ch[s[i]-\\'a\\'];\\n    }\\n    curr->isEnd=true;\\n}\\nbool search(trie *head,string &str,int l,int r)\\n{\\n    trie *curr=head;\\n    for(int i=l;i<=r;i++)\\n    {\\n        if(!curr->ch[str[i]-\\'a\\']) return false;\\n        curr=curr->ch[str[i]-\\'a\\'];\\n    }\\n    return curr->isEnd;\\n}\\nclass Solution {\\npublic:\\n    void stringMaker(string &s,vector<string> &ans,vector<vector<int>> &index,int ind,string buff)\\n    {\\n        if(ind==-1)\\n        {\\n            buff.pop_back();\\n            reverse(buff.begin(),buff.end());\\n            ans.push_back(buff);\\n            return;\\n        }\\n        \\n        for(auto i:index[ind])\\n        {\\n            string temp=\"\";\\n            for(int j=ind;j>=i;j--)\\n            {\\n                temp+=s[j];\\n            }\\n            stringMaker(s,ans,index,i-1,buff+temp+\" \");\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        trie *head=new trie();\\n        for(string &s:wordDict) insert(head,s);\\n        int n=s.length();\\n        //possible to make this by slicing [..]  [i....j]\\n        //just before index i. If i=0, there was no space\\n        vector<vector<int>> dp(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(search(head,s,0,i)) dp[i].push_back(0);\\n            for(int j=1;j<=i;j++)\\n            {\\n                if(dp[j-1].size() && search(head,s,j,i))\\n                    dp[i].push_back(j);\\n            }\\n        }\\n        vector<string> ans;\\n        if(dp[n-1].size()==0) return ans;\\n        stringMaker(s,ans,dp,n-1,\"\");\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```c++\\nstruct trie {\\n    trie *ch[26];\\n    bool isEnd;\\n    trie()\\n    {\\n        for(int i=0;i<26;i++) ch[i]=NULL;\\n        isEnd=false;\\n    }\\n};\\nvoid insert(trie *head,string &s)\\n{\\n    int n=s.length();\\n    trie *curr=head;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(!curr->ch[s[i]-\\'a\\']) curr->ch[s[i]-\\'a\\']=new trie();\\n        curr=curr->ch[s[i]-\\'a\\'];\\n    }\\n    curr->isEnd=true;\\n}\\nbool search(trie *head,string &str,int l,int r)\\n{\\n    trie *curr=head;\\n    for(int i=l;i<=r;i++)\\n    {\\n        if(!curr->ch[str[i]-\\'a\\']) return false;\\n        curr=curr->ch[str[i]-\\'a\\'];\\n    }\\n    return curr->isEnd;\\n}\\nclass Solution {\\npublic:\\n    void stringMaker(string &s,vector<string> &ans,vector<vector<int>> &index,int ind,string buff)\\n    {\\n        if(ind==-1)\\n        {\\n            buff.pop_back();\\n            reverse(buff.begin(),buff.end());\\n            ans.push_back(buff);\\n            return;\\n        }\\n        \\n        for(auto i:index[ind])\\n        {\\n            string temp=\"\";\\n            for(int j=ind;j>=i;j--)\\n            {\\n                temp+=s[j];\\n            }\\n            stringMaker(s,ans,index,i-1,buff+temp+\" \");\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        trie *head=new trie();\\n        for(string &s:wordDict) insert(head,s);\\n        int n=s.length();\\n        //possible to make this by slicing [..]  [i....j]\\n        //just before index i. If i=0, there was no space\\n        vector<vector<int>> dp(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(search(head,s,0,i)) dp[i].push_back(0);\\n            for(int j=1;j<=i;j++)\\n            {\\n                if(dp[j-1].size() && search(head,s,j,i))\\n                    dp[i].push_back(j);\\n            }\\n        }\\n        vector<string> ans;\\n        if(dp[n-1].size()==0) return ans;\\n        stringMaker(s,ans,dp,n-1,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739705,
                "title": "solution-swift-word-break-ii-test-cases",
                "content": "```swift\\nclass Solution {\\n    private var memo: [String:[String]] = [:]\\n    private var words: [String] = []\\n    \\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var wChars: Set<Character> = []\\n        \\n        for w in wordDict { w.forEach { wChars.insert($0) } }\\n        \\n        self.words = wordDict\\n        \\n        guard Set<Character>(s).isSubset(of: wChars) else {\\n            return []\\n        }\\n        return dfs(s)\\n    }\\n    \\n    private func dfs(_ s: String) -> [String] {\\n        guard memo[s] == nil else { return memo[s]! }\\n        \\n        var arr: [String] = []\\n        \\n        guard !s.isEmpty else {\\n            arr.append(\"\")\\n            return arr\\n        }\\n        \\n        for w in words where s.hasPrefix(w) {\\n            let subList = dfs(String(s[s.index(s.startIndex, offsetBy: w.count)...]))\\n            for s in subList { arr.append(w + (s.isEmpty ? \"\" : \" \") + s) }\\n        }\\n        memo[s] = arr\\n        return arr\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.029 (0.031) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.wordBreak(\"catsanddog\", [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"])\\n        XCTAssertEqual(value.sorted(), [\"cats and dog\",\"cat sand dog\"].sorted())\\n    }\\n    \\n    // Note that you are allowed to reuse a dictionary word.\\n    func test1() {\\n        let value = solution.wordBreak(\"pineapplepenapple\", [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"])\\n        XCTAssertEqual(value.sorted(), [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"].sorted())\\n    }\\n    \\n    func test2() {\\n        let value = solution.wordBreak(\"catsandog\", [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"])\\n        XCTAssertEqual(value, [])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    private var memo: [String:[String]] = [:]\\n    private var words: [String] = []\\n    \\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var wChars: Set<Character> = []\\n        \\n        for w in wordDict { w.forEach { wChars.insert($0) } }\\n        \\n        self.words = wordDict\\n        \\n        guard Set<Character>(s).isSubset(of: wChars) else {\\n            return []\\n        }\\n        return dfs(s)\\n    }\\n    \\n    private func dfs(_ s: String) -> [String] {\\n        guard memo[s] == nil else { return memo[s]! }\\n        \\n        var arr: [String] = []\\n        \\n        guard !s.isEmpty else {\\n            arr.append(\"\")\\n            return arr\\n        }\\n        \\n        for w in words where s.hasPrefix(w) {\\n            let subList = dfs(String(s[s.index(s.startIndex, offsetBy: w.count)...]))\\n            for s in subList { arr.append(w + (s.isEmpty ? \"\" : \" \") + s) }\\n        }\\n        memo[s] = arr\\n        return arr\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.wordBreak(\"catsanddog\", [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"])\\n        XCTAssertEqual(value.sorted(), [\"cats and dog\",\"cat sand dog\"].sorted())\\n    }\\n    \\n    // Note that you are allowed to reuse a dictionary word.\\n    func test1() {\\n        let value = solution.wordBreak(\"pineapplepenapple\", [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"])\\n        XCTAssertEqual(value.sorted(), [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"].sorted())\\n    }\\n    \\n    func test2() {\\n        let value = solution.wordBreak(\"catsandog\", [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"])\\n        XCTAssertEqual(value, [])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426014,
                "title": "python-interview-friendly-simple-recursion",
                "content": "Not the best or the fastest, but definitely more interview friendly version. Good old recursion. \\n\\nSplit the string at all indexes. Then basically there is always two parts - the first part (word) and rest of the string. If word is in the wordDict, take the second part, and do the same thing until there is no string left. At that point, simply join the path with space and append to the output. \\n\\nConvert wordDict to hashset for O(1) lookup time. \\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        def recur(s, path):\\n            if not s:\\n                out.append(\\' \\'.join(path))\\n                return\\n            for i in range(1,len(s)+1):\\n                w,new_s = s[:i], s[i:]\\n                if w in wordDict:\\n                    recur(new_s, path + [w])\\n        wordDict, out = set(wordDict), []\\n        recur(s,[])\\n        return out\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        def recur(s, path):\\n            if not s:\\n                out.append(\\' \\'.join(path))\\n                return\\n            for i in range(1,len(s)+1):\\n                w,new_s = s[:i], s[i:]\\n                if w in wordDict:\\n                    recur(new_s, path + [w])\\n        wordDict, out = set(wordDict), []\\n        recur(s,[])\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325635,
                "title": "trie-dfs-java",
                "content": "```\\nclass Solution {\\n    \\n    Trie root = new Trie();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        for(String word : wordDict) {\\n            addWord(word, root);\\n        }\\n        List<String> res = new ArrayList<>();\\n        List<String> current = new ArrayList<>();\\n        dfs(s, 0, root, current, res);\\n        return res;\\n    }\\n    private void dfs(String s, int index, Trie node, List<String> current, List<String> res) {\\n        if(index == s.length()) {\\n            if(node == root) {\\n                res.add(String.join(\" \", current));\\n            }\\n            return;\\n        }\\n        if(node == null) return;//invalid\\n        Trie trie = node.next[s.charAt(index) - \\'a\\'];\\n        if(trie != null && trie.isWord) {\\n            current.add(trie.word);\\n            dfs(s, index + 1, root, current, res);\\n            current.remove(current.size() - 1);\\n        }\\n        dfs(s, index + 1, trie, current, res);\\n    }\\n    private void addWord(String word, Trie dic) {\\n        Trie ptr = root;\\n        for(int i = 0; i < word.length(); ++i) {\\n            int idx = word.charAt(i) - \\'a\\';\\n            if(ptr.next[idx] == null) ptr.next[idx] = new Trie();\\n            ptr = ptr.next[idx];\\n        }\\n        ptr.isWord = true;\\n        ptr.word = word;\\n    }\\n    \\n    class Trie {\\n        boolean isWord;\\n        String word;\\n        Trie[] next;\\n        Trie() {\\n            next = new Trie[26];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Trie root = new Trie();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        for(String word : wordDict) {\\n            addWord(word, root);\\n        }\\n        List<String> res = new ArrayList<>();\\n        List<String> current = new ArrayList<>();\\n        dfs(s, 0, root, current, res);\\n        return res;\\n    }\\n    private void dfs(String s, int index, Trie node, List<String> current, List<String> res) {\\n        if(index == s.length()) {\\n            if(node == root) {\\n                res.add(String.join(\" \", current));\\n            }\\n            return;\\n        }\\n        if(node == null) return;//invalid\\n        Trie trie = node.next[s.charAt(index) - \\'a\\'];\\n        if(trie != null && trie.isWord) {\\n            current.add(trie.word);\\n            dfs(s, index + 1, root, current, res);\\n            current.remove(current.size() - 1);\\n        }\\n        dfs(s, index + 1, trie, current, res);\\n    }\\n    private void addWord(String word, Trie dic) {\\n        Trie ptr = root;\\n        for(int i = 0; i < word.length(); ++i) {\\n            int idx = word.charAt(i) - \\'a\\';\\n            if(ptr.next[idx] == null) ptr.next[idx] = new Trie();\\n            ptr = ptr.next[idx];\\n        }\\n        ptr.isWord = true;\\n        ptr.word = word;\\n    }\\n    \\n    class Trie {\\n        boolean isWord;\\n        String word;\\n        Trie[] next;\\n        Trie() {\\n            next = new Trie[26];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325222,
                "title": "simple-backtracking-solution",
                "content": "1. create a set for constant time O(1) lookup\\n2. iterate over string to expand the substring. \\n3. if a substring appears within `wordDict` \\n\\t3.1 we will explore this permutation by adding the substring to the path and backtracking on the remainder of the string\\n\\t3.2 if all the characters in the string are used up (`s.length === 0`) that means we have a valid permutation, so add it to the results\\n4. after the base case is reached (`s.length === 0` or no substrings found in `wordDict` remove the prior substring from `path` and continue expanding the current substring\\n\\ntime complexity: `O(n^2)` where `n` is the length of the string `s`\\n- for each recursive backtracking call we iterate through the remaining string. the `substring()` and `slice()` methods are linear operations `O(n)` in themselves, so it seems this may degrade to `O(n^3)`, thoughts? \\n\\nspace complexity: `O(n + m)` where `n` is the length of string `s` and `m` is the amount of words in `wordDict`\\n\\n```\\nconst backtrack = (s, words, path, result) => {\\n    if (s.length === 0) {\\n        result.push(path.join(\\' \\'))\\n        return\\n    }\\n    for (let i = 1; i <= s.length; i++) {\\n        const substring = s.substring(0, i)\\n        if (words.has(substring)) {\\n            path.push(substring)\\n            backtrack(s.slice(i), words, path, result)\\n            path.pop()\\n        }\\n    }\\n}\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {string[]}\\n */\\nconst wordBreak = (s, wordDict) => {\\n    const result = []\\n    const words = new Set(wordDict)\\n    backtrack(s, words, [], result)\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nconst backtrack = (s, words, path, result) => {\\n    if (s.length === 0) {\\n        result.push(path.join(\\' \\'))\\n        return\\n    }\\n    for (let i = 1; i <= s.length; i++) {\\n        const substring = s.substring(0, i)\\n        if (words.has(substring)) {\\n            path.push(substring)\\n            backtrack(s.slice(i), words, path, result)\\n            path.pop()\\n        }\\n    }\\n}\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {string[]}\\n */\\nconst wordBreak = (s, wordDict) => {\\n    const result = []\\n    const words = new Set(wordDict)\\n    backtrack(s, words, [], result)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1176760,
                "title": "0ms-c-easy-trie-solution",
                "content": "Scan given string char by char. If char exists in current trie node, \\n1) continue with next node. \\n``` find(s, i+1, r, temp->child[ch], root, sen + s[i]);```\\n2) additionally, if node is \"end node\", put a space and restart from the root node\\n``` find(s, i+1, r, root, root, sen + s[i] + \\' \\');```\\n\\nPlease check the code . You might find it easier to understand than my explanantion :P\\n\\n```\\nclass Solution {\\n    class TRIENODE{\\n    public:\\n        TRIENODE* child[26];\\n        bool isEnd;\\n        \\n        TRIENODE(){\\n          for(int i=0;i<26;i++){\\n              child[i] = 0;\\n          }\\n          isEnd = false;\\n        }\\n    };\\n    \\n    class TRIE{\\n    public:\\n        TRIENODE* root;\\n        \\n        TRIE(){\\n          root = new TRIENODE;\\n        }\\n        \\n        void insert(string s){\\n            TRIENODE* temp = root;\\n            for(auto ch:s){\\n                if(!temp->child[ch-\\'a\\']){\\n                    temp->child[ch-\\'a\\'] = new TRIENODE;\\n                }\\n                temp = temp->child[ch-\\'a\\'];\\n            }\\n            temp->isEnd = true;\\n        }    \\n    };\\n    \\n    vector<string> ans;\\n    \\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        TRIE* trie = new TRIE;\\n        for(auto s:wordDict){\\n            trie->insert(s);\\n        }\\n        \\n        find(s,0,s.size()-1,trie->root,trie->root,\"\");\\n        return ans;\\n    }\\n    \\n    void find(string s, int i, int r, TRIENODE* temp, TRIENODE* root,string sen){\\n        if(i>r){           \\n            if(temp->isEnd){\\n                ans.push_back(sen);                \\n            }\\n            return;\\n        }\\n        \\n        int ch = s[i]-\\'a\\';\\n        if(temp->child[ch]){\\n            find(s, i+1, r, temp->child[ch], root, sen + s[i]);            \\n            if(temp->child[ch]->isEnd){\\n                find(s, i+1, r, root, root, sen + s[i] + \\' \\');\\n            }            \\n        }\\n    }\\n};\\n```\\n\\nPS: This solution gives TLE for https://leetcode.com/problems/word-break/ where strings can be much longer.",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "``` find(s, i+1, r, temp->child[ch], root, sen + s[i]);```\n``` find(s, i+1, r, root, root, sen + s[i] + \\' \\');```\n```\\nclass Solution {\\n    class TRIENODE{\\n    public:\\n        TRIENODE* child[26];\\n        bool isEnd;\\n        \\n        TRIENODE(){\\n          for(int i=0;i<26;i++){\\n              child[i] = 0;\\n          }\\n          isEnd = false;\\n        }\\n    };\\n    \\n    class TRIE{\\n    public:\\n        TRIENODE* root;\\n        \\n        TRIE(){\\n          root = new TRIENODE;\\n        }\\n        \\n        void insert(string s){\\n            TRIENODE* temp = root;\\n            for(auto ch:s){\\n                if(!temp->child[ch-\\'a\\']){\\n                    temp->child[ch-\\'a\\'] = new TRIENODE;\\n                }\\n                temp = temp->child[ch-\\'a\\'];\\n            }\\n            temp->isEnd = true;\\n        }    \\n    };\\n    \\n    vector<string> ans;\\n    \\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        TRIE* trie = new TRIE;\\n        for(auto s:wordDict){\\n            trie->insert(s);\\n        }\\n        \\n        find(s,0,s.size()-1,trie->root,trie->root,\"\");\\n        return ans;\\n    }\\n    \\n    void find(string s, int i, int r, TRIENODE* temp, TRIENODE* root,string sen){\\n        if(i>r){           \\n            if(temp->isEnd){\\n                ans.push_back(sen);                \\n            }\\n            return;\\n        }\\n        \\n        int ch = s[i]-\\'a\\';\\n        if(temp->child[ch]){\\n            find(s, i+1, r, temp->child[ch], root, sen + s[i]);            \\n            if(temp->child[ch]->isEnd){\\n                find(s, i+1, r, root, root, sen + s[i] + \\' \\');\\n            }            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1034185,
                "title": "very-easy-backtracking-solution",
                "content": "public class Solution {\\n\\n    List<String> answer = new ArrayList();\\n    \\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n\\t    \\n        Set<String> set = new HashSet<>(wordDict);\\n        \\n        backtrack(s, \"\", answer, set);\\n        \\n        return answer;\\n    \\n    }\\n    \\n    public void backtrack(String s, String temp, List<String> answer, Set<String> set) {\\n        \\n        if(s.length()==0) {\\n            answer.add(temp);\\n            return;\\n        }\\n        \\n        for(int i=0;i<s.length();i++) {\\n            \\n            String left = s.substring(0,i+1);\\n            \\n            if(set.contains(left)) {\\n                String right = s.substring(i+1);\\n                backtrack(right, temp + left + \" \", answer, set);\\n            }\\n        }\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    List<String> answer = new ArrayList();\\n    \\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n\\t    \\n        Set<String> set = new HashSet<>(wordDict);\\n        \\n        backtrack(s, \"\", answer, set);\\n        \\n        return answer;\\n    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 908609,
                "title": "java-dsf-memo-5ms",
                "content": "Time complexity: O(n * 2^n) \\nSpace complexity: O(n * 2^n) \\n\\nHere a good explaination: \\nhttps://medium.com/@salonikaurone/leetcode-word-break-ii-explained-d41ecfbe8fc5#:~:text=because%20we%20have%20memoisation%2C%20we,of%20characters%20in%20the%20input\\n\\n```\\nclass Solution {\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        \\n        return dsf(s, 0, wordDict, new HashMap<>());\\n    }\\n    \\n    \\n    private List<String> dsf(String str, int startIndex, List<String> words, \\n                        Map<Integer, List<String>> map){\\n        \\n        if (map.containsKey(startIndex)) {\\n            return map.get(startIndex);\\n        }\\n        \\n        List<String> strs = new ArrayList<>();\\n        for (String word : words) {\\n            if (str.startsWith(word, startIndex)) {\\n                \\n                if (str.length() == startIndex + word.length()) {\\n                    strs.add(word);\\n                } else {\\n                    List<String> strings = dsf(str, startIndex + word.length(), words, map);\\n                    for (String ss : strings) {\\n                        strs.add(word + \" \" + ss);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        map.put(startIndex, strs);\\n        return map.get(startIndex);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        \\n        return dsf(s, 0, wordDict, new HashMap<>());\\n    }\\n    \\n    \\n    private List<String> dsf(String str, int startIndex, List<String> words, \\n                        Map<Integer, List<String>> map){\\n        \\n        if (map.containsKey(startIndex)) {\\n            return map.get(startIndex);\\n        }\\n        \\n        List<String> strs = new ArrayList<>();\\n        for (String word : words) {\\n            if (str.startsWith(word, startIndex)) {\\n                \\n                if (str.length() == startIndex + word.length()) {\\n                    strs.add(word);\\n                } else {\\n                    List<String> strings = dsf(str, startIndex + word.length(), words, map);\\n                    for (String ss : strings) {\\n                        strs.add(word + \" \" + ss);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        map.put(startIndex, strs);\\n        return map.get(startIndex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809872,
                "title": "c-memoization-solution-fast-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<string>> vis;\\n    vector<string> merge(string s, vector<string> vec){\\n        vector<string> ret;\\n        for(string i:vec) ret.push_back(s+\" \"+i);\\n        return ret;\\n    }\\n    vector<string> dfs(string s, unordered_set<string>& wordDict){\\n        vector<string> res;\\n        if(vis.count(s)) return vis[s];\\n        if(wordDict.count(s)) res.push_back(s);\\n        for(int i=1;i<=s.size();++i){\\n            string cur = s.substr(0,i);\\n            if(wordDict.count(cur)){\\n                vector<string> vec = merge(cur,dfs(s.substr(i),wordDict));\\n                res.insert(res.end(),vec.begin(),vec.end());\\n            }\\n        }\\n        vis[s] = res;\\n        return res;\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDic) {\\n        unordered_set<string> wordDict(wordDic.begin(),wordDic.end());\\n        return dfs(s,wordDict);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<string>> vis;\\n    vector<string> merge(string s, vector<string> vec){\\n        vector<string> ret;\\n        for(string i:vec) ret.push_back(s+\" \"+i);\\n        return ret;\\n    }\\n    vector<string> dfs(string s, unordered_set<string>& wordDict){\\n        vector<string> res;\\n        if(vis.count(s)) return vis[s];\\n        if(wordDict.count(s)) res.push_back(s);\\n        for(int i=1;i<=s.size();++i){\\n            string cur = s.substr(0,i);\\n            if(wordDict.count(cur)){\\n                vector<string> vec = merge(cur,dfs(s.substr(i),wordDict));\\n                res.insert(res.end(),vec.begin(),vec.end());\\n            }\\n        }\\n        vis[s] = res;\\n        return res;\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDic) {\\n        unordered_set<string> wordDict(wordDic.begin(),wordDic.end());\\n        return dfs(s,wordDict);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763391,
                "title": "java-using-trie",
                "content": "```\\nclass Solution {\\n    private Tries root;\\n    private List<String> wordList;\\n    private char[] input;\\n    private Set<Character> lookup;\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        this.wordList = new LinkedList<>();\\n        if(s.length() == 0) \\n            return this.wordList;\\n        this.lookup = new HashSet<>();\\n        this.root = new Tries();\\n        this.input = s.toCharArray();\\n        for(String word : wordDict) {\\n            addWord(word.toCharArray());\\n        }\\n        if(isValid()) \\n            splitWord(new StringBuilder(), 0, root);\\n        return wordList;\\n    }\\n    \\n    private void splitWord(StringBuilder sb, int i, Tries cur) {\\n        if(i == input.length) {\\n            wordList.add(sb.toString());\\n            return;\\n        }\\n        // System.out.println(\"\\\\n\" + input[i]);\\n        if(sb.length() > 0) sb.append(\" \");\\n        while(i < input.length && cur != null) {\\n            // System.out.print(input[i] + \" > \");\\n            cur = cur.children.get(input[i]);\\n            sb.append(input[i]);\\n            if(cur != null && cur.end) {\\n                splitWord(new StringBuilder(sb), i + 1, root);\\n            }\\n            i++;\\n        }\\n    }\\n    \\n    class Tries {\\n        Map<Character, Tries> children;\\n        boolean end;\\n        Tries() {\\n            children = new HashMap<>();\\n        }\\n    }\\n    \\n    private void addWord(char[] s) {\\n        Tries cur = root;\\n        for(int i = 0; i < s.length; i++) {\\n            this.lookup.add(s[i]);\\n            if(cur.children.containsKey(s[i]) == false) {\\n                cur.children.put(s[i], new Tries());\\n            }\\n            cur = cur.children.get(s[i]);\\n        }\\n        cur.end = true;\\n    } \\n    \\n    private boolean isValid() {\\n        for(int i = 0; i < input.length; i++) {\\n            if(lookup.contains(input[i])) continue;\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    private Tries root;\\n    private List<String> wordList;\\n    private char[] input;\\n    private Set<Character> lookup;\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        this.wordList = new LinkedList<>();\\n        if(s.length() == 0) \\n            return this.wordList;\\n        this.lookup = new HashSet<>();\\n        this.root = new Tries();\\n        this.input = s.toCharArray();\\n        for(String word : wordDict) {\\n            addWord(word.toCharArray());\\n        }\\n        if(isValid()) \\n            splitWord(new StringBuilder(), 0, root);\\n        return wordList;\\n    }\\n    \\n    private void splitWord(StringBuilder sb, int i, Tries cur) {\\n        if(i == input.length) {\\n            wordList.add(sb.toString());\\n            return;\\n        }\\n        // System.out.println(\"\\\\n\" + input[i]);\\n        if(sb.length() > 0) sb.append(\" \");\\n        while(i < input.length && cur != null) {\\n            // System.out.print(input[i] + \" > \");\\n            cur = cur.children.get(input[i]);\\n            sb.append(input[i]);\\n            if(cur != null && cur.end) {\\n                splitWord(new StringBuilder(sb), i + 1, root);\\n            }\\n            i++;\\n        }\\n    }\\n    \\n    class Tries {\\n        Map<Character, Tries> children;\\n        boolean end;\\n        Tries() {\\n            children = new HashMap<>();\\n        }\\n    }\\n    \\n    private void addWord(char[] s) {\\n        Tries cur = root;\\n        for(int i = 0; i < s.length; i++) {\\n            this.lookup.add(s[i]);\\n            if(cur.children.containsKey(s[i]) == false) {\\n                cur.children.put(s[i], new Tries());\\n            }\\n            cur = cur.children.get(s[i]);\\n        }\\n        cur.end = true;\\n    } \\n    \\n    private boolean isValid() {\\n        for(int i = 0; i < input.length; i++) {\\n            if(lookup.contains(input[i])) continue;\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763261,
                "title": "python-sol-by-dfs-with-prefix-matching-w-comment",
                "content": "Python sol by DFS with prefix matching\\n\\n---\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        solution = []\\n        \\n        word_pool = set(wordDict)\\n        \\n        \\n        if set(s) > set(\\'\\'.join(wordDict)):\\n            \\n            # Quick response if it is impossible to make s\\n            return []        \\n        \\n        #----------------------------------------\\n        \\n        def helper(s, words):\\n            # find all possible generation of s from word pool in DFS\\n            \\n            if s == \"\":\\n                # base case also known as stop condition\\n                # s can be generated from word pool\\n                solution.append(\\' \\'.join(words))\\n                return\\n            \\n            \\n            for prefix in word_pool:\\n                # general case\\n                \\n                if len(prefix) > len(s):\\n                    \\n                    # Skip when prefix is longer than s\\n                    continue\\n                \\n                if s.startswith(prefix):\\n                    \\n                    # Keep finding in DFS\\n                    helper(s[len(prefix):], words[:] + [prefix])\\n                    \\n            return\\n        \\n        #----------------------------------------\\n        \\n        helper(s, words=[])\\n        \\n        return solution\\n```\\n\\n---\\n\\nShare another **Implemetation** by DFS with postfix matching\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        wordSet = set(wordDict)\\n        \\n        @cache\\n        def dp(s):\\n            \\n            ## Base case on empty string\\n            if not s:\\n                return []\\n            \\n            ## General case\\n            res = []\\n            \\n            # Type_1: Current s is in wordSet\\n            if s in wordSet:\\n                res.append( s ) \\n            \\n            # Type_2: Decompose s into smaller words in wordSet\\n            for k in range(1, len(s)):\\n                \\n                postfix = s[k:]\\n                if postfix not in wordSet: continue\\n                \\n                res += [ prefix + \" \" + postfix for prefix in dp(s[:k])]\\n            \\n            return res\\n        \\n        # ---------------------------------\\n        return dp( s )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        solution = []\\n        \\n        word_pool = set(wordDict)\\n        \\n        \\n        if set(s) > set(\\'\\'.join(wordDict)):\\n            \\n            # Quick response if it is impossible to make s\\n            return []        \\n        \\n        #----------------------------------------\\n        \\n        def helper(s, words):\\n            # find all possible generation of s from word pool in DFS\\n            \\n            if s == \"\":\\n                # base case also known as stop condition\\n                # s can be generated from word pool\\n                solution.append(\\' \\'.join(words))\\n                return\\n            \\n            \\n            for prefix in word_pool:\\n                # general case\\n                \\n                if len(prefix) > len(s):\\n                    \\n                    # Skip when prefix is longer than s\\n                    continue\\n                \\n                if s.startswith(prefix):\\n                    \\n                    # Keep finding in DFS\\n                    helper(s[len(prefix):], words[:] + [prefix])\\n                    \\n            return\\n        \\n        #----------------------------------------\\n        \\n        helper(s, words=[])\\n        \\n        return solution\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        wordSet = set(wordDict)\\n        \\n        @cache\\n        def dp(s):\\n            \\n            ## Base case on empty string\\n            if not s:\\n                return []\\n            \\n            ## General case\\n            res = []\\n            \\n            # Type_1: Current s is in wordSet\\n            if s in wordSet:\\n                res.append( s ) \\n            \\n            # Type_2: Decompose s into smaller words in wordSet\\n            for k in range(1, len(s)):\\n                \\n                postfix = s[k:]\\n                if postfix not in wordSet: continue\\n                \\n                res += [ prefix + \" \" + postfix for prefix in dp(s[:k])]\\n            \\n            return res\\n        \\n        # ---------------------------------\\n        return dp( s )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557592,
                "title": "javascript-accepted-solution",
                "content": "Runtime: 52 ms, faster than 99.23% of JavaScript online submissions for Word Break II.\\nMemory Usage: 37.2 MB, less than 100.00% of JavaScript online submissions for Word Break II.\\n\\n```\\nconst dfs = (s, set, memo) => {\\n    if (memo.has(s)) {\\n        return memo.get(s);\\n    }\\n    \\n    let i = 1;\\n    const result = [];\\n    \\n    while ( i < s.length + 1 ) {\\n        const thisWord = s.substring(0, i);\\n        \\n        if (set.has(thisWord)) {\\n            if (i === s.length) {\\n                result.push(thisWord);\\n                break;\\n            }\\n            \\n            const nextCombos = dfs(s.substring(i), set, memo);\\n            nextCombos.forEach(combo => {\\n                result.push(`${thisWord} ${combo}`);    \\n            })\\n        }\\n        \\n        i++;\\n    }\\n    \\n    memo.set(s, result);\\n    \\n    return result;\\n}\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {string[]}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    return dfs(s, new Set(wordDict), new Map);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst dfs = (s, set, memo) => {\\n    if (memo.has(s)) {\\n        return memo.get(s);\\n    }\\n    \\n    let i = 1;\\n    const result = [];\\n    \\n    while ( i < s.length + 1 ) {\\n        const thisWord = s.substring(0, i);\\n        \\n        if (set.has(thisWord)) {\\n            if (i === s.length) {\\n                result.push(thisWord);\\n                break;\\n            }\\n            \\n            const nextCombos = dfs(s.substring(i), set, memo);\\n            nextCombos.forEach(combo => {\\n                result.push(`${thisWord} ${combo}`);    \\n            })\\n        }\\n        \\n        i++;\\n    }\\n    \\n    memo.set(s, result);\\n    \\n    return result;\\n}\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {string[]}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    return dfs(s, new Set(wordDict), new Map);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 496272,
                "title": "dfs-trie-python",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n\\nclass Trie:\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def getRoot(self):\\n        return self.root\\n    \\n    def insertWord(self, word: str):\\n\\n        nextNode = self.root\\n        for c in word:\\n            if c not in nextNode.children:\\n                nextNode.children[c] = TrieNode()\\n            nextNode = nextNode.children[c]\\n        nextNode.isWord = True\\n\\nclass Solution:\\n    trieNode = None\\n    s = None\\n    memoize = None\\n    \\n    def checkConnection(self, prevNode, currentChar: chr) -> TrieNode:\\n        if currentChar in prevNode.children:\\n            return prevNode.children[currentChar]\\n        return None\\n\\n    def wordBreakHelper(self, index: int, node) -> List[List[str]]:\\n        \\n        if index in self.memoize:\\n            return self.memoize[index][:]\\n\\n        result = []\\n        current = []\\n        \\n        start = index\\n        while index < len(self.s):\\n            node = self.checkConnection(node, self.s[index])\\n            \\n            if node is None:\\n                break\\n            \\n            # valid path\\n            current.append(self.s[index])\\n\\n            if node.isWord:\\n                current_word = \\'\\'.join(current)\\n                \\n                if index+1 < len(self.s):\\n                    tempResult = self.wordBreakHelper(index+1, self.trieNode.getRoot())\\n\\n                    #print(tempResult, current_word)\\n                    for val in tempResult:\\n                        result.append([current_word] + val)\\n                else:\\n                    result.append([current_word])\\n\\n            index += 1\\n            \\n        self.memoize[start] = result\\n        return self.memoize[start][:]\\n\\n\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n\\n        self.trieNode = Trie()\\n        self.s = s\\n        self.memoize = {}\\n        # creating a Trie\\n        \\n        for s in wordDict:\\n            self.trieNode.insertWord(s)\\n        \\n        \\n        final_result = self.wordBreakHelper(0, self.trieNode.getRoot())\\n        \\n        \\n        #print(self.memoize)\\n        return [\\' \\'.join(word_list) for word_list in final_result]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n\\nclass Trie:\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def getRoot(self):\\n        return self.root\\n    \\n    def insertWord(self, word: str):\\n\\n        nextNode = self.root\\n        for c in word:\\n            if c not in nextNode.children:\\n                nextNode.children[c] = TrieNode()\\n            nextNode = nextNode.children[c]\\n        nextNode.isWord = True\\n\\nclass Solution:\\n    trieNode = None\\n    s = None\\n    memoize = None\\n    \\n    def checkConnection(self, prevNode, currentChar: chr) -> TrieNode:\\n        if currentChar in prevNode.children:\\n            return prevNode.children[currentChar]\\n        return None\\n\\n    def wordBreakHelper(self, index: int, node) -> List[List[str]]:\\n        \\n        if index in self.memoize:\\n            return self.memoize[index][:]\\n\\n        result = []\\n        current = []\\n        \\n        start = index\\n        while index < len(self.s):\\n            node = self.checkConnection(node, self.s[index])\\n            \\n            if node is None:\\n                break\\n            \\n            # valid path\\n            current.append(self.s[index])\\n\\n            if node.isWord:\\n                current_word = \\'\\'.join(current)\\n                \\n                if index+1 < len(self.s):\\n                    tempResult = self.wordBreakHelper(index+1, self.trieNode.getRoot())\\n\\n                    #print(tempResult, current_word)\\n                    for val in tempResult:\\n                        result.append([current_word] + val)\\n                else:\\n                    result.append([current_word])\\n\\n            index += 1\\n            \\n        self.memoize[start] = result\\n        return self.memoize[start][:]\\n\\n\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n\\n        self.trieNode = Trie()\\n        self.s = s\\n        self.memoize = {}\\n        # creating a Trie\\n        \\n        for s in wordDict:\\n            self.trieNode.insertWord(s)\\n        \\n        \\n        final_result = self.wordBreakHelper(0, self.trieNode.getRoot())\\n        \\n        \\n        #print(self.memoize)\\n        return [\\' \\'.join(word_list) for word_list in final_result]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424750,
                "title": "simplified-word-break-1-and-2-java-based-on-dp-one-dimensional-array-and-dfs",
                "content": "Idea is to use one dimensional DP array and keep updating it until we reach to the end. \\n\\nWord break 1: result is in the last index.\\nWord break 2: result will be built by dfs on dp array.\\n\\n**Word Break 1**\\n![image](https://assets.leetcode.com/users/tyr1on/image_1573326539.png)\\n\\n\\n```\\n\\tpublic static boolean wordBreak(String s, List<String> wordDict) {\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                String check = s.substring(j, i);\\n                if (dp[j] && wordDict.contains(check)) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n```\\n\\n**Word Break 2**\\n![image](https://assets.leetcode.com/users/tyr1on/image_1573326566.png)\\n\\n\\n```\\n\\tpublic static List<String> wordBreakII(String word, List<String> dict) {\\n        if (null == word || word.isEmpty() ||\\n                null == dict || dict.isEmpty()) {\\n            return Collections.emptyList();\\n        }\\n\\n        // dp array\\n        List<String>[] dp = new ArrayList[word.length() + 1];\\n        dp[0] = new ArrayList<>();\\n\\n        for (int i = 1; i <= word.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                // form a word and check if it is in dict\\n                String check = word.substring(j, i);\\n                if (null != dp[j] && dict.contains(check)) {\\n                    if (null == dp[i]) {\\n                        dp[i] = new ArrayList<>();\\n                    }\\n                    dp[i].add(check);\\n                }\\n            }\\n        }\\n\\n        // if dictionary words cannot join to given word\\n        if (null == dp[word.length()]) {\\n            return Collections.emptyList();\\n        }\\n\\n        List<String> result = new ArrayList<>();\\n        // start dfs from back\\n        dfs(dp, result, \"\", word.length());\\n        return result;\\n    }\\n\\n    // perform dfs from the end of the dp array to form the result list\\n    public static void dfs(List<String>[] dp, List<String> result, String current, int i) {\\n        if (i == 0) {\\n            result.add(current.trim());\\n            return;\\n        }\\n\\n        for (String s : dp[i]) {\\n            // append string to previous result\\n            String combined = s + \" \" + current;\\n            dfs(dp, result, combined, i - s.length());\\n        }\\n    }\\n```\\n\\nA lannister always pays his debt!",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tpublic static boolean wordBreak(String s, List<String> wordDict) {\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                String check = s.substring(j, i);\\n                if (dp[j] && wordDict.contains(check)) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n```\n```\\n\\tpublic static List<String> wordBreakII(String word, List<String> dict) {\\n        if (null == word || word.isEmpty() ||\\n                null == dict || dict.isEmpty()) {\\n            return Collections.emptyList();\\n        }\\n\\n        // dp array\\n        List<String>[] dp = new ArrayList[word.length() + 1];\\n        dp[0] = new ArrayList<>();\\n\\n        for (int i = 1; i <= word.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                // form a word and check if it is in dict\\n                String check = word.substring(j, i);\\n                if (null != dp[j] && dict.contains(check)) {\\n                    if (null == dp[i]) {\\n                        dp[i] = new ArrayList<>();\\n                    }\\n                    dp[i].add(check);\\n                }\\n            }\\n        }\\n\\n        // if dictionary words cannot join to given word\\n        if (null == dp[word.length()]) {\\n            return Collections.emptyList();\\n        }\\n\\n        List<String> result = new ArrayList<>();\\n        // start dfs from back\\n        dfs(dp, result, \"\", word.length());\\n        return result;\\n    }\\n\\n    // perform dfs from the end of the dp array to form the result list\\n    public static void dfs(List<String>[] dp, List<String> result, String current, int i) {\\n        if (i == 0) {\\n            result.add(current.trim());\\n            return;\\n        }\\n\\n        for (String s : dp[i]) {\\n            // append string to previous result\\n            String combined = s + \" \" + current;\\n            dfs(dp, result, combined, i - s.length());\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327441,
                "title": "c-98-beaten-o-n-m-m-max-word-len-hot-stinger-solution",
                "content": "This seems to work. Basically just solving word-break-1, only continuing to explore the solution space even if we get a match. Use sets to make sure you aren\\'t exploring the same branch twice. Otherwise the program will be slow and you will have many duplicate answers for some test cases.\\n\\nIf you have done all the problems up to this point, you have have the tools to solve this. If you can\\'t then you are an idiot. Plain and simple. A simpleton who is no better than a vegetable. And you should be served on a plate to a race of feasting giants.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int mMaxLength;\\n    int mMinLength;\\n    unordered_set<string> mDictionary;\\n    vector<unordered_set<string>> mMatchSets;\\n    vector<string> mTemp;\\n    char *mAnsStr;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        \\n        vector<string> aResult;\\n        if (wordDict.size() <= 0) { return aResult; }\\n        \\n        for (int i=0;i<s.size();i++) {\\n            unordered_set<string> aSet;\\n            mMatchSets.push_back(aSet);\\n        }\\n        \\n        mAnsStr = new char[s.size() + s.size() + 2]; //some space to write to...\\n        \\n        mMaxLength = 0;\\n        mMinLength = -1;\\n        for (auto aWord : wordDict) {\\n            \\n            mDictionary.insert(aWord);\\n            if (aWord.size() > mMaxLength) {\\n                mMaxLength = aWord.size();\\n            }\\n            if (mMinLength == -1 || aWord.size() < mMinLength) {\\n                mMinLength = aWord.size();\\n            }\\n        }\\n        \\n        wordBreakExplorer(s, wordDict, s.size() - 1); //Find all the answers.\\n        wordBreakSolutionBuilder(aResult, s, 0); //Build all the solutions.\\n        \\n        return aResult;\\n    }\\n\\n    void wordBreakExplorer(string &pString, vector<string>& pDict, int pStart) {\\n        if (pStart < 0) { return; }\\n        \\n        int aInd1 = pStart - mMinLength + 1;\\n        int aInd2 = pStart - mMaxLength + 1;\\n        \\n        if (aInd1 < 0) { return; }\\n        if (aInd2 < 0) { aInd2 = 0; }\\n        \\n        int aLength = mMinLength;\\n        for (int i=aInd1;i>=aInd2;i--) {\\n            \\n            string aChunk = pString.substr(i, aLength);\\n            if (mMatchSets[i].count(aChunk) == 0) {\\n\\n                if (mDictionary.count(aChunk) > 0) {\\n                    mMatchSets[i].insert(aChunk);\\n                    wordBreakExplorer(pString, pDict, i - 1);\\n                }\\n            }\\n            aLength++;\\n        }\\n    }\\n    \\n    \\n    void wordBreakSolutionBuilder(vector<string> &pResult, string &pString, int pStart) {\\n        \\n        if (pStart == pString.size()) {\\n            //Turn the answer into a space-separated word.\\n            int aIndex = 0;\\n            for (auto aString : mTemp) {\\n                for (int i=0;i<aString.size();i++) {\\n                    mAnsStr[aIndex++] = aString[i]; \\n                }\\n                mAnsStr[aIndex++] = \\' \\';\\n            }\\n            mAnsStr[aIndex - 1] = 0;\\n            pResult.push_back(string(mAnsStr));\\n            return;\\n        }\\n        \\n        for (auto aWord : mMatchSets[pStart]) {\\n            //Crawl the solution space. Like a baby crawls for milk bottles.\\n            mTemp.push_back(aWord);\\n            wordBreakSolutionBuilder(pResult, pString, pStart + aWord.size());   \\n            mTemp.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mMaxLength;\\n    int mMinLength;\\n    unordered_set<string> mDictionary;\\n    vector<unordered_set<string>> mMatchSets;\\n    vector<string> mTemp;\\n    char *mAnsStr;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        \\n        vector<string> aResult;\\n        if (wordDict.size() <= 0) { return aResult; }\\n        \\n        for (int i=0;i<s.size();i++) {\\n            unordered_set<string> aSet;\\n            mMatchSets.push_back(aSet);\\n        }\\n        \\n        mAnsStr = new char[s.size() + s.size() + 2]; //some space to write to...\\n        \\n        mMaxLength = 0;\\n        mMinLength = -1;\\n        for (auto aWord : wordDict) {\\n            \\n            mDictionary.insert(aWord);\\n            if (aWord.size() > mMaxLength) {\\n                mMaxLength = aWord.size();\\n            }\\n            if (mMinLength == -1 || aWord.size() < mMinLength) {\\n                mMinLength = aWord.size();\\n            }\\n        }\\n        \\n        wordBreakExplorer(s, wordDict, s.size() - 1); //Find all the answers.\\n        wordBreakSolutionBuilder(aResult, s, 0); //Build all the solutions.\\n        \\n        return aResult;\\n    }\\n\\n    void wordBreakExplorer(string &pString, vector<string>& pDict, int pStart) {\\n        if (pStart < 0) { return; }\\n        \\n        int aInd1 = pStart - mMinLength + 1;\\n        int aInd2 = pStart - mMaxLength + 1;\\n        \\n        if (aInd1 < 0) { return; }\\n        if (aInd2 < 0) { aInd2 = 0; }\\n        \\n        int aLength = mMinLength;\\n        for (int i=aInd1;i>=aInd2;i--) {\\n            \\n            string aChunk = pString.substr(i, aLength);\\n            if (mMatchSets[i].count(aChunk) == 0) {\\n\\n                if (mDictionary.count(aChunk) > 0) {\\n                    mMatchSets[i].insert(aChunk);\\n                    wordBreakExplorer(pString, pDict, i - 1);\\n                }\\n            }\\n            aLength++;\\n        }\\n    }\\n    \\n    \\n    void wordBreakSolutionBuilder(vector<string> &pResult, string &pString, int pStart) {\\n        \\n        if (pStart == pString.size()) {\\n            //Turn the answer into a space-separated word.\\n            int aIndex = 0;\\n            for (auto aString : mTemp) {\\n                for (int i=0;i<aString.size();i++) {\\n                    mAnsStr[aIndex++] = aString[i]; \\n                }\\n                mAnsStr[aIndex++] = \\' \\';\\n            }\\n            mAnsStr[aIndex - 1] = 0;\\n            pResult.push_back(string(mAnsStr));\\n            return;\\n        }\\n        \\n        for (auto aWord : mMatchSets[pStart]) {\\n            //Crawl the solution space. Like a baby crawls for milk bottles.\\n            mTemp.push_back(aWord);\\n            wordBreakSolutionBuilder(pResult, pString, pStart + aWord.size());   \\n            mTemp.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44210,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var cache = [String: [String]]()\\n        return DFS(s, wordDict, &cache)\\n    }\\n    \\n    func DFS(_ s: String, _ wordDict: [String], _ cache: inout [String: [String]]) -> [String] {\\n        if s.characters.count == 0 {\\n            return [\"\"]\\n        }\\n        if let value = cache[s] {\\n            return value\\n        }\\n        \\n        var result = [String]()\\n        \\n        for word in wordDict {\\n            if s.hasPrefix(word) {\\n                let subWordBreaks = DFS(s.substring(from: word.endIndex), wordDict, &cache)\\n                for subWordBreak in subWordBreaks {\\n                    if subWordBreak.isEmpty {\\n                        result.append(word)\\n                    } else {\\n                        result.append(word + \" \" + subWordBreak)\\n                    }\\n                }\\n            }\\n        }\\n        cache[s] = result;\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var cache = [String: [String]]()\\n        return DFS(s, wordDict, &cache)\\n    }\\n    \\n    func DFS(_ s: String, _ wordDict: [String], _ cache: inout [String: [String]]) -> [String] {\\n        if s.characters.count == 0 {\\n            return [\"\"]\\n        }\\n        if let value = cache[s] {\\n            return value\\n        }\\n        \\n        var result = [String]()\\n        \\n        for word in wordDict {\\n            if s.hasPrefix(word) {\\n                let subWordBreaks = DFS(s.substring(from: word.endIndex), wordDict, &cache)\\n                for subWordBreak in subWordBreaks {\\n                    if subWordBreak.isEmpty {\\n                        result.append(word)\\n                    } else {\\n                        result.append(word + \" \" + subWordBreak)\\n                    }\\n                }\\n            }\\n        }\\n        cache[s] = result;\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44225,
                "title": "golang-3ms-solution",
                "content": "```\\nimport \"strings\"\\n\\nfunc wordBreak(s string, wordDict []string) []string {\\n    mp := make(map[string][]string)\\n    return dfs(s, wordDict, mp)    \\n}\\n\\nfunc dfs(s string, wordDict []string, mp map[string][]string) []string {\\n    _, ok := mp[s]\\n    if ok {\\n        return mp[s]\\n    }\\n    \\n    res := make([]string, 0)\\n    if len(s) == 0 {\\n        res = append(res, \"\")\\n        return res\\n    }\\n    for _,word:= range wordDict {\\n        if strings.HasPrefix(s, word) {\\n            sublist := dfs(s[len(word):], wordDict, mp)\\n            for _, sub:= range sublist {\\n                a := \" \"\\n                if len(sub) == 0 {\\n                    a = \"\"\\n                }\\n                res = append(res, word + a + sub)\\n            }\\n        }        \\n    }\\n    mp[s] = res\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport \"strings\"\\n\\nfunc wordBreak(s string, wordDict []string) []string {\\n    mp := make(map[string][]string)\\n    return dfs(s, wordDict, mp)    \\n}\\n\\nfunc dfs(s string, wordDict []string, mp map[string][]string) []string {\\n    _, ok := mp[s]\\n    if ok {\\n        return mp[s]\\n    }\\n    \\n    res := make([]string, 0)\\n    if len(s) == 0 {\\n        res = append(res, \"\")\\n        return res\\n    }\\n    for _,word:= range wordDict {\\n        if strings.HasPrefix(s, word) {\\n            sublist := dfs(s[len(word):], wordDict, mp)\\n            for _, sub:= range sublist {\\n                a := \" \"\\n                if len(sub) == 0 {\\n                    a = \"\"\\n                }\\n                res = append(res, word + a + sub)\\n            }\\n        }        \\n    }\\n    mp[s] = res\\n    return res\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 44308,
                "title": "c-dfs-caching",
                "content": "    public class Solution {\\n        Dictionary<string, List<string>> dp = new Dictionary<string, List<string>>();\\n    \\n        public IList<string> WordBreak(string s, ISet<string> wordDict)\\n        {\\n            return WordBreak(s, 0, s.Length - 1, wordDict);\\n        }\\n    \\n        public IList<string> WordBreak(string s, int start, int end, ISet<string> wordDict)\\n        {\\n            string key = start + \"_\" + end;\\n            if (dp.ContainsKey(key))\\n            {\\n                return dp[key];\\n            }\\n    \\n            List<string> sentences = new List<string>();\\n            for (int sub = start ; sub < end ; sub++)\\n            {\\n                int subLength = sub - start + 1;\\n                string subStr = s.Substring(start, subLength);\\n                if (wordDict.Contains(subStr))\\n                {\\n                    IList<string> rest = WordBreak(s, sub + 1, end, wordDict);\\n                    if (rest.Any())\\n                    {\\n                        sentences.AddRange(rest.Select(ss => subStr + \" \" + ss));\\n                    }\\n                }\\n            }\\n    \\n            string curSentence = s.Substring(start, end - start + 1);\\n            if (wordDict.Contains(curSentence))\\n            {\\n                sentences.Add(curSentence);\\n            }\\n    \\n            dp[key] = sentences;\\n            return sentences;\\n        }\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        Dictionary<string, List<string>> dp = new Dictionary<string, List<string>>();\\n    \\n        public IList<string> WordBreak(string s, ISet<string> wordDict)\\n        {\\n            return WordBreak(s, 0, s.Length - 1, wordDict);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 44345,
                "title": "python-dp-solution-in-11-lines",
                "content": "    \\n\\n\\n    \\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        M = {}\\n        def dfs(remain_str):\\n            if not remain_str: return ['']\\n            if remain_str in M: return M[remain_str]\\n            ret = []    \\n            for i in xrange(1,len(remain_str)+1):\\n                if remain_str[:i] in wordDict: \\n                    for r in dfs(remain_str[i:]): \\n                        ret.append( (remain_str[:i]+' '+r).strip() )\\n            M[remain_str] = tuple(ret)\\n            return ret\\n        return dfs(s)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    \\n\\n\\n    \\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        M = {}\\n        def dfs(remain_str):\\n            if not remain_str: return ['']\\n            if remain_str in M: return M[remain_str]\\n            ret = []    \\n            for i in xrange(1,len(remain_str)+1):\\n                if remain_str[:i] in wordDict: \\n                    for r in dfs(remain_str[i:]): \\n                        ret.append( (remain_str[:i]+' '+r).strip() )\\n            M[remain_str] = tuple(ret)\\n            return ret\\n        return dfs(s)",
                "codeTag": "Python3"
            },
            {
                "id": 44322,
                "title": "c-solution-using-dp-and-backtrace-8ms",
                "content": "1. using dp to just like \"work break\".\\n2. backtrace with dp.\\n\\n    class Solution {\\n    \\n        vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n            if(s.empty() || wordDict.empty()) return vector<string>();\\n            int n = s.size();\\n            vector<bool> dp(n+1, false);\\n            dp[n] = true;\\n            \\n            for(int i=n-1; i >= 0; --i)\\n                for(int j=i+1; j <= n; ++j)\\n                    if(dp[j] && wordDict.find(s.substr(i, j-i)) != wordDict.end()) {\\n                        dp[i] = true;\\n                        break;\\n                    }\\n            if(!dp[0]) return vector<string>();\\n            \\n            vector<string> ret;\\n            bt(s, 0, wordDict, dp, ret);\\n            return ret;\\n        }\\n    \\n        void bt(string &s, int idx, unordered_set<string> &dict, vector<bool> &dp, vector<string> &ret) {\\n            static string tmp;\\n            if(idx == s.size()) {\\n                ret.push_back(tmp);\\n                return ;\\n            }\\n            for(int i=idx+1; i <= s.size(); ++i) {\\n                string str(s, idx, i-idx);\\n                if(dp[i] && dict.find(str) != dict.end()) {\\n                    if(idx != 0) tmp += \" \";\\n                    tmp += str;\\n                    cout << tmp << endl;\\n                    \\n                    bt(s, i, dict, dp, ret);\\n                    \\n                    if(idx == 0) tmp.erase(tmp.size()-str.size());\\n                    else tmp.erase(tmp.size()-str.size()-1);\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    \\n        vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n            if(s.empty() || wordDict.empty()) return vector<string>();\\n            int n = s.size();\\n            vector<bool> dp(n+1, false);\\n            dp[n] = true;\\n            \\n            for(int i=n-1; i >= 0; --i)\\n                for(int j=i+1; j <= n; ++j)\\n                    if(dp[j] && wordDict.find(s.substr(i, j-i)) != wordDict.end()) {\\n                        dp[i] = true;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3457927,
                "title": "java-backtraking-easy-to-understand-4ms",
                "content": "4 ms, faster than 61.24% of Java online submissions for Word Break II.\\n```\\nclass Solution {\\n    List<String> wordDict;\\n    String s;\\n    Set<String> res = new HashSet<String>();\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        this.wordDict = wordDict;\\n        this.s = s;\\n        helper(0, 0, new ArrayList<String>());\\n        return new ArrayList<String>(res);\\n    }\\n    public void helper(int i, int j, List<String> arr) {\\n        if(j == s.length()) {\\n            int size = 0;\\n            for(String c : arr) size += c.length();\\n            if(size == s.length()) {\\n                res.add(arr.stream().map(Object::toString)\\n                          .collect(Collectors.joining(\" \")));\\n            }\\n            return;\\n        }\\n        while(j < s.length()) {\\n            if(wordDict.contains(s.substring(i, j + 1))) {\\n                arr.add(s.substring(i, j + 1));\\n                helper(j + 1, j + 1, arr);\\n                helper(i, j + 1, arr);\\n                arr.remove(arr.size() - 1);\\n            }\\n            j++;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<String> wordDict;\\n    String s;\\n    Set<String> res = new HashSet<String>();\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        this.wordDict = wordDict;\\n        this.s = s;\\n        helper(0, 0, new ArrayList<String>());\\n        return new ArrayList<String>(res);\\n    }\\n    public void helper(int i, int j, List<String> arr) {\\n        if(j == s.length()) {\\n            int size = 0;\\n            for(String c : arr) size += c.length();\\n            if(size == s.length()) {\\n                res.add(arr.stream().map(Object::toString)\\n                          .collect(Collectors.joining(\" \")));\\n            }\\n            return;\\n        }\\n        while(j < s.length()) {\\n            if(wordDict.contains(s.substring(i, j + 1))) {\\n                arr.add(s.substring(i, j + 1));\\n                helper(j + 1, j + 1, arr);\\n                helper(i, j + 1, arr);\\n                arr.remove(arr.size() - 1);\\n            }\\n            j++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205780,
                "title": "140-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe time complexity of this algorithm is O(n^3), where n is the length of the input string s. The space complexity is also O(n^3), due to the memoization dictionary. However, in practice, the space complexity will be much lower, as the memoization dictionary will only contain results for a small subset of all possible substrings of s.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        # Create a set of words for fast lookup\\n        word_set = set(wordDict)\\n        # Create a memoization dictionary to store previously calculated results\\n        memo = {}\\n        \\n        # Define a recursive function to find all possible sentences\\n        def dfs(s):\\n            # If the current string s has already been calculated, return the result\\n            if s in memo:\\n                return memo[s]\\n            \\n            # If the string s is empty, return an empty list\\n            if not s:\\n                return []\\n            \\n            # Initialize the result list\\n            res = []\\n            \\n            # Iterate over all possible splits of the string s\\n            for i in range(1, len(s) + 1):\\n                # If the left part of the split is a valid word\\n                if s[:i] in word_set:\\n                    # Recursively find all possible sentences for the right part of the split\\n                    right_sents = dfs(s[i:])\\n                    # If there are any possible sentences for the right part of the split\\n                    if right_sents:\\n                        # Append the current word and all possible sentences for the right part of the split\\n                        for right_sent in right_sents:\\n                            res.append(s[:i] + \" \" + right_sent)\\n                    # If there are no possible sentences for the right part of the split, but the right part is empty\\n                    elif not s[i:]:\\n                        # Append just the current word\\n                        res.append(s[:i])\\n            \\n            # Store the result for the current string s in the memoization dictionary and return it\\n            memo[s] = res\\n            return res\\n        \\n        # Call the recursive function to find all possible sentences for the input string s\\n        return dfs(s)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        # Create a set of words for fast lookup\\n        word_set = set(wordDict)\\n        # Create a memoization dictionary to store previously calculated results\\n        memo = {}\\n        \\n        # Define a recursive function to find all possible sentences\\n        def dfs(s):\\n            # If the current string s has already been calculated, return the result\\n            if s in memo:\\n                return memo[s]\\n            \\n            # If the string s is empty, return an empty list\\n            if not s:\\n                return []\\n            \\n            # Initialize the result list\\n            res = []\\n            \\n            # Iterate over all possible splits of the string s\\n            for i in range(1, len(s) + 1):\\n                # If the left part of the split is a valid word\\n                if s[:i] in word_set:\\n                    # Recursively find all possible sentences for the right part of the split\\n                    right_sents = dfs(s[i:])\\n                    # If there are any possible sentences for the right part of the split\\n                    if right_sents:\\n                        # Append the current word and all possible sentences for the right part of the split\\n                        for right_sent in right_sents:\\n                            res.append(s[:i] + \" \" + right_sent)\\n                    # If there are no possible sentences for the right part of the split, but the right part is empty\\n                    elif not s[i:]:\\n                        # Append just the current word\\n                        res.append(s[:i])\\n            \\n            # Store the result for the current string s in the memoization dictionary and return it\\n            memo[s] = res\\n            return res\\n        \\n        # Call the recursive function to find all possible sentences for the input string s\\n        return dfs(s)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107035,
                "title": "c-dp-solution-with-explanation-0ms-100-faster-runtime",
                "content": "# Intuition\\n\\nThe first observation to make out from the given description is that this problem involves the concept of subproblem within a problem - i.e. DP; meaning, the problem can be broken down into smaller fractions and the final answer can be found by combining the answers to these subproblems.\\n\\n# Approach\\n\\nWe will first insert the list of words into an unordered set (unsorted) so that finding the strings within the set takes negligible time.\\n\\nNext, we declare an array of array of strings (2D vector) of size one more than the size of the given original string. This two-dimensional array of strings stores in each index \\'i\\' the list of strings that upon concatenation result in a prefix string of length \\'i\\'.\\n\\nNow we iterate from index i = 0 to the size of the string and for each \\'i\\', from j = i + 1 to the end of the string and check if the resultant substring from position \\'i\\' of length \\'j - i\\' is contained in the list of words in wordDict.\\n\\nIf it is contained in the list of words, the from index \\'i\\', we obtain all the strings that lead up to the prefix string of length \\'i\\' and we append the string of length \\'j - i\\' and push the list in the position \\'j\\' (dp[j]).\\n\\nThe final answer is obtained at the last position of the dp array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set <string> st;\\n\\n        for(auto x: wordDict)\\n            st.insert(x);\\n        \\n        int n = s.size();\\n        vector <vector <string> > dp(n + 1);\\n        dp[0] = {\"\"};\\n\\n        for(int i = 0; i < n; i++) {\\n            if(dp[i].size() == 0)\\n                continue;\\n            \\n            for(int j = i + 1; j <= n; j++) {\\n                string tmp = s.substr(i, j - i);\\n\\n                if(st.count(tmp)) {\\n                    for(auto x: dp[i]) {\\n                        string str = x;\\n                        str += tmp;\\n                        str.push_back(\\' \\');\\n                        dp[j].push_back(str);\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(auto &x: dp[n]) // for the elimination of terminal space characters\\n            x.pop_back();\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set <string> st;\\n\\n        for(auto x: wordDict)\\n            st.insert(x);\\n        \\n        int n = s.size();\\n        vector <vector <string> > dp(n + 1);\\n        dp[0] = {\"\"};\\n\\n        for(int i = 0; i < n; i++) {\\n            if(dp[i].size() == 0)\\n                continue;\\n            \\n            for(int j = i + 1; j <= n; j++) {\\n                string tmp = s.substr(i, j - i);\\n\\n                if(st.count(tmp)) {\\n                    for(auto x: dp[i]) {\\n                        string str = x;\\n                        str += tmp;\\n                        str.push_back(\\' \\');\\n                        dp[j].push_back(str);\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(auto &x: dp[n]) // for the elimination of terminal space characters\\n            x.pop_back();\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801907,
                "title": "fast",
                "content": "```\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```",
                "solutionTags": [],
                "code": "```\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749473,
                "title": "recursion-beats-100-cpp",
                "content": "```\\nclass Solution {\\n     void solve(int index,string &s,unordered_set<string> &hashset,int &n,string sub_ans,vector<string> &ans){\\n        if(index==n){\\n            sub_ans=sub_ans.substr(1); //to remove leading space\\n            ans.push_back(sub_ans);\\n            return;\\n        }\\n        string temp=\"\"; \\n*         //tring every possible partition \\n        for(int i=index;i<n;i++){\\n            //temp is the word formed by partition\\n            temp+=s[i];\\n            //if word before partition exist in hashset then check for remaining word\\n            if(hashset.find(temp)!=hashset.end()){\\n               solve(i+1,s,hashset,n,sub_ans+\" \"+temp,ans);\\n            }\\n        }\\n        \\n    }\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string> ans; //answer vector\\n        //storing all the words in hashset\\n        unordered_set<string> hashset; \\n        for(auto i:wordDict){\\n            hashset.insert(i);\\n        }\\n        int n=s.length();\\n        string sub_ans=\"\"; //empty string to store sentence\\n        solve(0,s,hashset,n,sub_ans,ans); //helpercode call\\n        return ans; \\n        \\n    }\\n};\\n## //please upvote if it was helpfull\\n",
                "solutionTags": [],
                "code": "class Solution {\\n     void solve(int index,string &s,unordered_set<string> &hashset,int &n,string sub_ans,vector<string> &ans){\\n        if(index==n){\\n            sub_ans=sub_ans.substr(1); //to remove leading space\\n            ans.push_back(sub_ans);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2739918,
                "title": "very-easy-and-simple-recursive-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        helper(s, dictionary, ans, \"\");\\n        return ans;\\n    }\\n\\n    void helper(String s, List<String> d, List<String> ans, String temp){\\n        if(s.length() == 0){\\n            ans.add(temp.trim());\\n            return;\\n        }\\n    \\n        for(int i = s.length() - 1; i >= 0; i--){\\n            String right = s.substring(i, s.length());\\n            if(d.contains(right)){\\n                String left = s.substring(0, i);\\n                helper(left, d, ans, right + \" \" + temp);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        helper(s, dictionary, ans, \"\");\\n        return ans;\\n    }\\n\\n    void helper(String s, List<String> d, List<String> ans, String temp){\\n        if(s.length() == 0){\\n            ans.add(temp.trim());\\n            return;\\n        }\\n    \\n        for(int i = s.length() - 1; i >= 0; i--){\\n            String right = s.substring(i, s.length());\\n            if(d.contains(right)){\\n                String left = s.substring(0, i);\\n                helper(left, d, ans, right + \" \" + temp);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671659,
                "title": "java-backtracking-faster-than-100-short-code",
                "content": "Unlike the Dynamic programming solution mentioned in the solution, a backtracking approach gives the same time complexity on an asymptotic case.\\n```\\nclass Solution {\\n    List<String> ans;\\n    public void breakWord(String s, int start, Set<String> dict, List<String> curr){\\n        for(int i=start+1;i<=s.length();i++){\\n            String f = s.substring(start, i);\\n            if(dict.contains(f)){\\n                curr.add(f);\\n                if(i==s.length()){\\n                    String[] stringparts = curr.toArray(String[]::new);\\n                    ans.add(String.join(\" \", stringparts));\\n                }    \\n                else breakWord(s, i, dict, curr);\\n                curr.remove(curr.size()-1);\\n            }\\n        }\\n    }\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        ans = new ArrayList<String>();\\n        Set<String> dict = new HashSet();\\n        for(String w:wordDict) dict.add(w);\\n        breakWord(s, 0, dict, new ArrayList<String>());\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<String> ans;\\n    public void breakWord(String s, int start, Set<String> dict, List<String> curr){\\n        for(int i=start+1;i<=s.length();i++){\\n            String f = s.substring(start, i);\\n            if(dict.contains(f)){\\n                curr.add(f);\\n                if(i==s.length()){\\n                    String[] stringparts = curr.toArray(String[]::new);\\n                    ans.add(String.join(\" \", stringparts));\\n                }    \\n                else breakWord(s, i, dict, curr);\\n                curr.remove(curr.size()-1);\\n            }\\n        }\\n    }\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        ans = new ArrayList<String>();\\n        Set<String> dict = new HashSet();\\n        for(String w:wordDict) dict.add(w);\\n        breakWord(s, 0, dict, new ArrayList<String>());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627035,
                "title": "short-and-standard-backtracking-solution-java",
                "content": "```\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<List<String>> res = new ArrayList<>();\\n        dfs(s, wordDict, res, 0, new ArrayList<>());\\n        return res.stream().map(list -> String.join(\" \", list)).collect(Collectors.toList());\\n    }\\n    // classical backtracking - performance better compare with below solution-2\\n    public static void dfs(String s, List<String> wordDict, List<List<String>> res,\\n                           int start, List<String> track) {\\n        if (start == s.length()) {\\n            res.add(new ArrayList<>(track));\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            String next = s.substring(start, i + 1); // catch: substring from start\\n            if (wordDict.contains(next)) {\\n                track.add(next);\\n                dfs(s, wordDict, res, i + 1, track);\\n                track.remove(track.size()-1);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<List<String>> res = new ArrayList<>();\\n        dfs(s, wordDict, res, 0, new ArrayList<>());\\n        return res.stream().map(list -> String.join(\" \", list)).collect(Collectors.toList());\\n    }\\n    // classical backtracking - performance better compare with below solution-2\\n    public static void dfs(String s, List<String> wordDict, List<List<String>> res,\\n                           int start, List<String> track) {\\n        if (start == s.length()) {\\n            res.add(new ArrayList<>(track));\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            String next = s.substring(start, i + 1); // catch: substring from start\\n            if (wordDict.contains(next)) {\\n                track.add(next);\\n                dfs(s, wordDict, res, i + 1, track);\\n                track.remove(track.size()-1);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375696,
                "title": "java-concise-and-simple-code-with-comments",
                "content": "Runtime: 4 ms, faster than 61.76% of Java online submissions for Word Break II.\\nMemory Usage: 40.5 MB, less than 93.93% of Java online submissions for Word Break II.\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> words) {\\n        List<String> ans = new ArrayList<>();\\n        helper(\"\", s, words, ans);\\n        return ans;\\n    }\\n    \\n    void helper(String curr, String s, List<String> words, List<String> ans) {\\n        if(s.length() == 0) {\\n            ans.add(curr.trim()); // Remove any whitespace at the end\\n            return;\\n        }\\n        for(String word : words) {\\n            if(s.indexOf(word) == 0) { // Check if s starts with current word\\n               helper(curr + \" \" + word, s.substring(word.length()), words, ans); // Call helper for remaining s\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> words) {\\n        List<String> ans = new ArrayList<>();\\n        helper(\"\", s, words, ans);\\n        return ans;\\n    }\\n    \\n    void helper(String curr, String s, List<String> words, List<String> ans) {\\n        if(s.length() == 0) {\\n            ans.add(curr.trim()); // Remove any whitespace at the end\\n            return;\\n        }\\n        for(String word : words) {\\n            if(s.indexOf(word) == 0) { // Check if s starts with current word\\n               helper(curr + \" \" + word, s.substring(word.length()), words, ans); // Call helper for remaining s\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2302827,
                "title": "c-simple-c-code-100-time-83-space",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n![image](https://assets.leetcode.com/users/images/e0c05b38-fafa-41a9-b1d8-98c3c09a6133_1658213884.0128381.png)\\n\\n```\\nclass Solution {\\n    vector<string> ans;\\n    unordered_map<string, int> um;\\n    void dfs(string &s, string &comb, int i)\\n    {\\n        if(i == s.size())\\n        {\\n            if(comb.size() != 0)\\n            {\\n                string f = comb.substr(0,comb.size()-1);\\n                ans.push_back(f);   \\n            }\\n            return;\\n        }\\n        string tmp = \"\";\\n        for(int j = i; j < s.size(); j++)\\n        {\\n            tmp += s[j];\\n            if(um.count(tmp))\\n            {\\n                string store = comb;\\n                comb += tmp + \\' \\';\\n                dfs(s, comb, j+1);\\n                comb = store;\\n            }\\n        }\\n        return;\\n    }\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        string combs = \"\";\\n        for(string &str : wordDict)\\n            um[str]++;\\n        dfs(s, combs, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    vector<string> ans;\\n    unordered_map<string, int> um;\\n    void dfs(string &s, string &comb, int i)\\n    {\\n        if(i == s.size())\\n        {\\n            if(comb.size() != 0)\\n            {\\n                string f = comb.substr(0,comb.size()-1);\\n                ans.push_back(f);   \\n            }\\n            return;\\n        }\\n        string tmp = \"\";\\n        for(int j = i; j < s.size(); j++)\\n        {\\n            tmp += s[j];\\n            if(um.count(tmp))\\n            {\\n                string store = comb;\\n                comb += tmp + \\' \\';\\n                dfs(s, comb, j+1);\\n                comb = store;\\n            }\\n        }\\n        return;\\n    }\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        string combs = \"\";\\n        for(string &str : wordDict)\\n            um[str]++;\\n        dfs(s, combs, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252707,
                "title": "c-easy-to-understand-simple-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    set<string> dict;\\n    int n;\\n    void backtrack(string &s,vector<string> &ans,string str)\\n    {\\n        if(s.size()==0)\\n        {\\n            ans.push_back(str);\\n            return;\\n        }\\n        for(int j=1;j<=s.size();j++)\\n        {\\n            string left=s.substr(0,j);\\n            string right=s.substr(j);\\n            if(dict.find(left)!=dict.end())\\n            {\\n                string z=str;\\n                str+=left;\\n                str+=\\' \\';\\n                backtrack(right,ans,str);\\n                str=z;\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        n=s.length();\\n        for(auto &word:wordDict)\\n        {\\n            dict.insert(word);\\n        }\\n        \\n        vector<string> ans;\\n        backtrack(s,ans,\"\");\\n        for(auto &x:ans)\\n        {\\n            x.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    set<string> dict;\\n    int n;\\n    void backtrack(string &s,vector<string> &ans,string str)\\n    {\\n        if(s.size()==0)\\n        {\\n            ans.push_back(str);\\n            return;\\n        }\\n        for(int j=1;j<=s.size();j++)\\n        {\\n            string left=s.substr(0,j);\\n            string right=s.substr(j);\\n            if(dict.find(left)!=dict.end())\\n            {\\n                string z=str;\\n                str+=left;\\n                str+=\\' \\';\\n                backtrack(right,ans,str);\\n                str=z;\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        n=s.length();\\n        for(auto &word:wordDict)\\n        {\\n            dict.insert(word);\\n        }\\n        \\n        vector<string> ans;\\n        backtrack(s,ans,\"\");\\n        for(auto &x:ans)\\n        {\\n            x.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915607,
                "title": "python-faster-than-95-explanation-simple-code",
                "content": "# \\t<----- IF YOU LIKE THE SOLUTION UPVOTE HERE\\n\\t\\nApproach : \\n1. \\t find the sequences of word from the wordDict which will exactly equal to  our orignal s string.\\n2. \\t After finding the sequences of word just add them using space between each word.\\n\\t\\n\\tclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n            lst  = []\\n            def rec(start,sentence):\\n                if start >= len(s):\\n                    lst.append(sentence[:-1]) #[:-1] bcz at last of the sentence there is space to not incluide it I use last index\\n\\n                for i in range(start,len(s)):      # evert time I am going in forwad directon if the below IF condition satisfy\\n                    if s[start:i+1] in wordDict:\\n                        rec(i+1,sentence + s[start:i+1] + \" \")  # In question they have mension that give space between each word\\n                        \\n            rec(0,\\'\\')\\n            return lst",
                "solutionTags": [
                    "Python"
                ],
                "code": "# \\t<----- IF YOU LIKE THE SOLUTION UPVOTE HERE\\n\\t\\nApproach : \\n1. \\t find the sequences of word from the wordDict which will exactly equal to  our orignal s string.\\n2. \\t After finding the sequences of word just add them using space between each word.\\n\\t\\n\\tclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n            lst  = []\\n            def rec(start,sentence):\\n                if start >= len(s):\\n                    lst.append(sentence[:-1]) #[:-1] bcz at last of the sentence there is space to not incluide it I use last index\\n\\n                for i in range(start,len(s)):      # evert time I am going in forwad directon if the below IF condition satisfy\\n                    if s[start:i+1] in wordDict:\\n                        rec(i+1,sentence + s[start:i+1] + \" \")  # In question they have mension that give space between each word\\n                        \\n            rec(0,\\'\\')\\n            return lst",
                "codeTag": "Java"
            },
            {
                "id": 1764843,
                "title": "python-trie",
                "content": "```\\nclass Solution:\\n    \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        trie = {}\\n\\t\\t#filling the trie\\n        for word in wordDict:\\n            currentDict = trie\\n            for letter in word:\\n                if letter in currentDict:\\n                    currentDict = currentDict[letter]\\n                else:\\n                    currentDict[letter] = {}\\n                    currentDict = currentDict[letter]\\n            currentDict[\\'_\\'] = 0\\n\\t\\t\\t\\n        #function to go through the trie    \\n        def iterate(st, final_res, current, currentTrie):\\n            for i in range(len(st)):       \\n                if \\'_\\' in currentTrie: #found the end of the word, start new search branch\\n                    iterate(st[i:], final_res, current + [st[:i]], trie)\\n                    \\n                if st[i] in currentTrie:\\n                    currentTrie = currentTrie[st[i]]\\n                else: #no possible to fit the word, end this search branch\\n                    return\\n\\n            #last symbol check   \\n            if \\'_\\' in currentTrie:\\n                final_res.append(current + [st])\\n\\n        res = []\\n        iterate(s, res, [], trie)\\n        return [\\' \\'.join(r) for r in res]\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        trie = {}\\n\\t\\t#filling the trie\\n        for word in wordDict:\\n            currentDict = trie\\n            for letter in word:\\n                if letter in currentDict:\\n                    currentDict = currentDict[letter]\\n                else:\\n                    currentDict[letter] = {}\\n                    currentDict = currentDict[letter]\\n            currentDict[\\'_\\'] = 0\\n\\t\\t\\t\\n        #function to go through the trie    \\n        def iterate(st, final_res, current, currentTrie):\\n            for i in range(len(st)):       \\n                if \\'_\\' in currentTrie: #found the end of the word, start new search branch\\n                    iterate(st[i:], final_res, current + [st[:i]], trie)\\n                    \\n                if st[i] in currentTrie:\\n                    currentTrie = currentTrie[st[i]]\\n                else: #no possible to fit the word, end this search branch\\n                    return\\n\\n            #last symbol check   \\n            if \\'_\\' in currentTrie:\\n                final_res.append(current + [st])\\n\\n        res = []\\n        iterate(s, res, [], trie)\\n        return [\\' \\'.join(r) for r in res]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703604,
                "title": "java-evolve-from-139-word-break",
                "content": "//Problem is very similar to \"139. Word Break\"\\n\\n//Here is the solution built on top of \"139. Word Break\" that uses bfs like approach\\n\\n\\tpublic  List<String>  wordBreak(String s, List<String> wordDict) \\n    {\\n        List<String> ans=new LinkedList<>();\\n        Set<String> wordDictSet = new HashSet<>(wordDict);\\n\\n        Queue<Pair<Integer, StringBuilder>> queue = new LinkedList<>();     \\n        queue.add(new Pair(0, new StringBuilder()));\\n    \\n        while (!queue.isEmpty()) \\n        {\\n            Pair<Integer, StringBuilder> cpair=queue.poll();\\n            int start=cpair.getKey();\\n            StringBuilder sb=cpair.getValue();\\n            \\n            for (int end=start+1; end<=s.length(); end++) \\n            {\\n                if (wordDictSet.contains(s.substring(start, end))) \\n                {\\n                    StringBuilder sbu=new StringBuilder(sb);\\n                    sbu.append(s.substring(start, end) + \" \");\\n                    \\n                    if (end == s.length())\\n                    {\\n                        ans.add(sbu.toString().trim());\\n                        continue;\\n                    }\\n                    queue.add(new Pair(end, sbu));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t\\n//\\tAnd here is actual solution for \"139. Word Break\"\\n   \\n\\tpublic boolean wordBreak(String s, List<String> wordDict) \\n    {\\n        Set<String> wordDictSet = new HashSet<>(wordDict);\\n        boolean[] visited = new boolean[s.length()];\\n        \\n        Queue<Integer> queue = new LinkedList<>(); //keeps index    \\n        queue.add(0);\\n    \\n        while (!queue.isEmpty()) \\n        {\\n            int start = queue.poll();\\n            if (visited[start]) \\n                continue;\\n    \\n            for (int end=start+1; end<=s.length(); end++) \\n            {\\n                if (wordDictSet.contains(s.substring(start, end))) \\n                {\\n                    queue.add(end);\\n                    if (end == s.length()) \\n                        return true;\\n                }\\n            }\\n            visited[start] = true;\\n        }\\n        return false;\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "//Problem is very similar to \"139. Word Break\"\\n\\n//Here is the solution built on top of \"139. Word Break\" that uses bfs like approach\\n\\n\\tpublic  List<String>  wordBreak(String s, List<String> wordDict) \\n    {\\n        List<String> ans=new LinkedList<>();\\n        Set<String> wordDictSet = new HashSet<>(wordDict);\\n\\n        Queue<Pair<Integer, StringBuilder>> queue = new LinkedList<>();     \\n        queue.add(new Pair(0, new StringBuilder()));\\n    \\n        while (!queue.isEmpty()) \\n        {\\n            Pair<Integer, StringBuilder> cpair=queue.poll();\\n            int start=cpair.getKey();\\n            StringBuilder sb=cpair.getValue();\\n            \\n            for (int end=start+1; end<=s.length(); end++) \\n            {\\n                if (wordDictSet.contains(s.substring(start, end))) \\n                {\\n                    StringBuilder sbu=new StringBuilder(sb);\\n                    sbu.append(s.substring(start, end) + \" \");\\n                    \\n                    if (end == s.length())\\n                    {\\n                        ans.add(sbu.toString().trim());\\n                        continue;\\n                    }\\n                    queue.add(new Pair(end, sbu));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t\\n//\\tAnd here is actual solution for \"139. Word Break\"\\n   \\n\\tpublic boolean wordBreak(String s, List<String> wordDict) \\n    {\\n        Set<String> wordDictSet = new HashSet<>(wordDict);\\n        boolean[] visited = new boolean[s.length()];\\n        \\n        Queue<Integer> queue = new LinkedList<>(); //keeps index    \\n        queue.add(0);\\n    \\n        while (!queue.isEmpty()) \\n        {\\n            int start = queue.poll();\\n            if (visited[start]) \\n                continue;\\n    \\n            for (int end=start+1; end<=s.length(); end++) \\n            {\\n                if (wordDictSet.contains(s.substring(start, end))) \\n                {\\n                    queue.add(end);\\n                    if (end == s.length()) \\n                        return true;\\n                }\\n            }\\n            visited[start] = true;\\n        }\\n        return false;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1683301,
                "title": "trie-runtime-0ms-100-faster",
                "content": "**Don\\'t Forget to Upvote!**\\n```\\nclass Solution {\\npublic:\\n\\n    class TrieNode{\\n    public:\\n        bool end;\\n        vector<TrieNode*> child;\\n\\n        TrieNode(){\\n            end = false;\\n            child.assign(26,nullptr);\\n        }\\n    };\\n\\n    class Trie{\\n    public:\\n        TrieNode* root;\\n\\n        Trie(){\\n            root = new TrieNode();\\n        }\\n\\n        void insert(string s){\\n            TrieNode* curr = root;\\n            for(auto& c:s){\\n                if(!curr->child[c-\\'a\\'])\\n                    curr->child[c-\\'a\\'] = new TrieNode();\\n                curr = curr->child[c-\\'a\\'];\\n            }\\n            curr->end = true;\\n        }\\n\\n        bool search(string s){\\n            TrieNode* curr = root;\\n            for(auto& c:s){\\n                if(!curr->child[c-\\'a\\'])\\n                    return false;\\n                curr = curr->child[c-\\'a\\'];\\n            }\\n            return curr->end;\\n        }\\n    };\\n\\n    Trie trie;\\n    vector<string> ans;\\n\\n    void recurse(int index,string curr,string sentence,string s){\\n        if(index==s.length()){\\n            sentence.erase(sentence.begin());\\n            ans.push_back(sentence);\\n            return;\\n        }\\n\\n        for(int i=index;i<s.length();i++){\\n            curr.push_back(s[i]);\\n            if(trie.search(curr))\\n                recurse(i+1,\"\",sentence+\" \"+curr,s);\\n        }\\n    }\\n\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        for(auto& str:wordDict){\\n            trie.insert(str);\\n        }\\n        recurse(0,\"\",\"\",s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    class TrieNode{\\n    public:\\n        bool end;\\n        vector<TrieNode*> child;\\n\\n        TrieNode(){\\n            end = false;\\n            child.assign(26,nullptr);\\n        }\\n    };\\n\\n    class Trie{\\n    public:\\n        TrieNode* root;\\n\\n        Trie(){\\n            root = new TrieNode();\\n        }\\n\\n        void insert(string s){\\n            TrieNode* curr = root;\\n            for(auto& c:s){\\n                if(!curr->child[c-\\'a\\'])\\n                    curr->child[c-\\'a\\'] = new TrieNode();\\n                curr = curr->child[c-\\'a\\'];\\n            }\\n            curr->end = true;\\n        }\\n\\n        bool search(string s){\\n            TrieNode* curr = root;\\n            for(auto& c:s){\\n                if(!curr->child[c-\\'a\\'])\\n                    return false;\\n                curr = curr->child[c-\\'a\\'];\\n            }\\n            return curr->end;\\n        }\\n    };\\n\\n    Trie trie;\\n    vector<string> ans;\\n\\n    void recurse(int index,string curr,string sentence,string s){\\n        if(index==s.length()){\\n            sentence.erase(sentence.begin());\\n            ans.push_back(sentence);\\n            return;\\n        }\\n\\n        for(int i=index;i<s.length();i++){\\n            curr.push_back(s[i]);\\n            if(trie.search(curr))\\n                recurse(i+1,\"\",sentence+\" \"+curr,s);\\n        }\\n    }\\n\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        for(auto& str:wordDict){\\n            trie.insert(str);\\n        }\\n        recurse(0,\"\",\"\",s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666710,
                "title": "5-ms-simple-c-backtracking-solution-with-explanation-easy-to-understand-code",
                "content": "We have to look it as a dfs problem. We loop through our string from left to right and divide it each time. If we have the left substring in the dictionary then we add this string in the curr vector and call recursively for the right substring.\\n```Base case``` if empty string then we loop over our curr vector and form the sentence and return\\n\\nHope this helps. \\n\\n```\\nvector<string> ans;\\n    unordered_set<string> hash;\\n    \\n    void helper(string s, vector<string> &curr){\\n        if(s.length() == 0){\\n            string res;\\n            for(int i=0;i<curr.size(); ++i){\\n                res += curr[i];\\n                if(i != curr.size() - 1) res+= \" \";\\n            }\\n            ans.push_back(res);\\n            return;\\n        }\\n        \\n        for(int i=1;i<=s.length(); ++i){\\n            string left = s.substr(0, i);\\n            if(hash.count(left)) {\\n                curr.push_back(left);\\n                helper(s.substr(i), curr);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string> curr;\\n        for(auto x: wordDict) hash.insert(x);\\n        helper(s, curr);\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```Base case```\n```\\nvector<string> ans;\\n    unordered_set<string> hash;\\n    \\n    void helper(string s, vector<string> &curr){\\n        if(s.length() == 0){\\n            string res;\\n            for(int i=0;i<curr.size(); ++i){\\n                res += curr[i];\\n                if(i != curr.size() - 1) res+= \" \";\\n            }\\n            ans.push_back(res);\\n            return;\\n        }\\n        \\n        for(int i=1;i<=s.length(); ++i){\\n            string left = s.substr(0, i);\\n            if(hash.count(left)) {\\n                curr.push_back(left);\\n                helper(s.substr(i), curr);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string> curr;\\n        for(auto x: wordDict) hash.insert(x);\\n        helper(s, curr);\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1532818,
                "title": "python-beats-88-37",
                "content": "Super easy solution with naive approach of simply building word character by character and then backtracking if out of bounds\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res, end = [], len(s)\\n        def helper(start, curr):\\n            if start == end:\\n                res.append(\" \".join(curr))\\n                return\\n            tmp = \"\"\\n            for i in range(start, end):\\n                tmp += s[i]\\n                if tmp in wordDict:\\n                    curr.append(tmp)\\n                    helper(i + 1, curr)\\n                    curr.pop()\\n        helper(0, [])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res, end = [], len(s)\\n        def helper(start, curr):\\n            if start == end:\\n                res.append(\" \".join(curr))\\n                return\\n            tmp = \"\"\\n            for i in range(start, end):\\n                tmp += s[i]\\n                if tmp in wordDict:\\n                    curr.append(tmp)\\n                    helper(i + 1, curr)\\n                    curr.pop()\\n        helper(0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437714,
                "title": "python-clean-iterative-dfs-backtracking",
                "content": "### Iterative DFS\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:        \\n        \\n        N = len(s)    \\n        queue, sentences = deque([(0, \\'\\')]), []\\n        while queue:\\n            i, sentence = queue.pop()\\n            if i == N: \\n                sentences.append(sentence[1:])\\n                continue\\n            for word in wordDict:\\n                index = i+len(word)\\n                if index <= N and s[i:index] == word: \\n                    queue.append((index, sentence+\\' \\'+word))\\n        return sentences\\n```    \\n### Backtracking\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n    \\n        def backtrack(i = 0, sentence = \\'\\'):\\n            nonlocal N\\n            if i == N: \\n                sentences.append(sentence[1:])\\n                return\\n            for word in wordDict:\\n                index = i+len(word)\\n                if index <= N and s[i:index] == word and i not in visited:\\n                    visited.add(i)\\n                    backtrack(index, sentence+\\' \\'+word)\\n                    visited.remove(i)\\n            \\n        N = len(s)\\n        sentences, visited = [], set()\\n        backtrack()\\n        return sentences\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:        \\n        \\n        N = len(s)    \\n        queue, sentences = deque([(0, \\'\\')]), []\\n        while queue:\\n            i, sentence = queue.pop()\\n            if i == N: \\n                sentences.append(sentence[1:])\\n                continue\\n            for word in wordDict:\\n                index = i+len(word)\\n                if index <= N and s[i:index] == word: \\n                    queue.append((index, sentence+\\' \\'+word))\\n        return sentences\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n    \\n        def backtrack(i = 0, sentence = \\'\\'):\\n            nonlocal N\\n            if i == N: \\n                sentences.append(sentence[1:])\\n                return\\n            for word in wordDict:\\n                index = i+len(word)\\n                if index <= N and s[i:index] == word and i not in visited:\\n                    visited.add(i)\\n                    backtrack(index, sentence+\\' \\'+word)\\n                    visited.remove(i)\\n            \\n        N = len(s)\\n        sentences, visited = [], set()\\n        backtrack()\\n        return sentences\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400590,
                "title": "c-fastest-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>v;\\n    void solve(string s,unordered_set<string>set,string res,int pos)\\n    {\\n        if(pos==s.size())\\n        {\\n            res.pop_back();\\n            v.push_back(res);\\n            return;\\n        }\\n        for(int i=pos+1;i<=s.size();++i)\\n        {\\n            string ss=s.substr(pos,i-pos);\\n            if(set.find(ss)!=set.end())\\n            {\\n                solve(s,set,res+ss+\\' \\',i);\\n            }\\n        }\\n      \\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> set;\\n        for(auto x:wordDict)\\n            set.insert(x);\\n        string res;\\n        solve(s,set,res,0);\\n        return v;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>v;\\n    void solve(string s,unordered_set<string>set,string res,int pos)\\n    {\\n        if(pos==s.size())\\n        {\\n            res.pop_back();\\n            v.push_back(res);\\n            return;\\n        }\\n        for(int i=pos+1;i<=s.size();++i)\\n        {\\n            string ss=s.substr(pos,i-pos);\\n            if(set.find(ss)!=set.end())\\n            {\\n                solve(s,set,res+ss+\\' \\',i);\\n            }\\n        }\\n      \\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> set;\\n        for(auto x:wordDict)\\n            set.insert(x);\\n        string res;\\n        solve(s,set,res,0);\\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384083,
                "title": "simple-java-backtracking-solution-with-explaination-0ms-100-no-tle",
                "content": "Add all words in WordDict to a hash set for O(1) access.\\n\\nIterate through every character of the string and check if the substring is present in the set. If the substirng is present in the dictionary set, it means the substring could be one of the broken parts of the string. So, add it to the temporary list and then similarly recurse to check more words from next index.\\n\\nThe termination condition will be, if we have reached to the end of string. Then, format the temporary list into the desired space separated string.\\n\\n\\n\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> list = new ArrayList<>();\\n        Set<String> set = new HashSet<>(wordDict);\\n        wordBreak(list, new ArrayList<>(), 0, set,s);\\n        return list;\\n    }\\n    \\n    private void wordBreak(List<String> list, List<String> temp, int index, Set<String> set, String s) {\\n        if(index==s.length()) { //  reached at the end of string\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0; i<temp.size()-1; i++) {\\n                sb.append(temp.get(i)).append(\" \");\\n            }\\n            sb.append(temp.get(temp.size()-1));\\n            list.add(sb.toString());\\n            return;\\n        }\\n        \\n        for(int i=index; i<s.length(); i++) {\\n            String str = s.substring(index, i+1);\\n            if(!set.contains(str)) continue;\\n            temp.add(str); // add to the temporary list\\n            wordBreak(list, temp, i+1, set,s); // recurse to check every word from next index\\n            temp.remove(temp.size()-1); //backtrack\\n        }\\n    }\\n}\\n```\\n\\n\\nI think TC is 2^n, the string of length has (n+1) ways to be broken into two parts. Then at each step we have two options to further split or not.In worst case, when all choices are made,time complexity will be 2^n.  Feel free to point out if I am misssing anything. \\n\\nI have actually a query, I think it is a brute force approach. Even then why the running time is 0ms and is better than 100% solutions. Am i missing anything?",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> list = new ArrayList<>();\\n        Set<String> set = new HashSet<>(wordDict);\\n        wordBreak(list, new ArrayList<>(), 0, set,s);\\n        return list;\\n    }\\n    \\n    private void wordBreak(List<String> list, List<String> temp, int index, Set<String> set, String s) {\\n        if(index==s.length()) { //  reached at the end of string\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0; i<temp.size()-1; i++) {\\n                sb.append(temp.get(i)).append(\" \");\\n            }\\n            sb.append(temp.get(temp.size()-1));\\n            list.add(sb.toString());\\n            return;\\n        }\\n        \\n        for(int i=index; i<s.length(); i++) {\\n            String str = s.substring(index, i+1);\\n            if(!set.contains(str)) continue;\\n            temp.add(str); // add to the temporary list\\n            wordBreak(list, temp, i+1, set,s); // recurse to check every word from next index\\n            temp.remove(temp.size()-1); //backtrack\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340887,
                "title": "java-trie",
                "content": "```\\nclass Solution {\\n    class Trie{\\n        Trie children[] = new Trie[26];\\n        boolean isEndOfWord;\\n        public Trie(){\\n            for(int i=0;i<26;i++)\\n                children[i] = null;\\n            isEndOfWord = false;\\n        }\\n    }\\n    public void addWord(Trie root,String s){\\n        Trie node = root;\\n        for(int i=0;i<s.length();i++){\\n            int ch = s.charAt(i) - \\'a\\';\\n            if(node.children[ch]==null)\\n                node.children[ch] = new Trie();\\n            node = node.children[ch];\\n        }\\n        node.isEndOfWord = true;\\n    }\\n    public boolean search(Trie root, String s){\\n        Trie node = root;\\n        for(int i=0;i<s.length();i++){\\n            int ch = s.charAt(i) - \\'a\\';\\n            if(node.children[ch]==null)\\n                return false;\\n            node = node.children[ch];\\n        }\\n        return node.isEndOfWord;\\n    }\\n    \\n    List<String> list;\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Trie root = new Trie();\\n        for(String st:wordDict){\\n            addWord(root,st);\\n        }\\n        list = new ArrayList();\\n        findRemainingSubString(root,\"\",s,s.length());\\n        return list;\\n    }\\n    public boolean findRemainingSubString(Trie root,String str,String s,int total){\\n        if(s==null || s.length()==0)\\n            return true;\\n        for(int i=0;i<=s.length();i++){\\n            String st = str;\\n            if(search(root,s.substring(0,i))){\\n                st = st + s.substring(0,i)+ \" \";\\n                if(!findRemainingSubString(root,st,s.substring(i),total+1))\\n                    return false;\\n                if(st.trim().length()==total)\\n                    list.add(st.trim());\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    class Trie{\\n        Trie children[] = new Trie[26];\\n        boolean isEndOfWord;\\n        public Trie(){\\n            for(int i=0;i<26;i++)\\n                children[i] = null;\\n            isEndOfWord = false;\\n        }\\n    }\\n    public void addWord(Trie root,String s){\\n        Trie node = root;\\n        for(int i=0;i<s.length();i++){\\n            int ch = s.charAt(i) - \\'a\\';\\n            if(node.children[ch]==null)\\n                node.children[ch] = new Trie();\\n            node = node.children[ch];\\n        }\\n        node.isEndOfWord = true;\\n    }\\n    public boolean search(Trie root, String s){\\n        Trie node = root;\\n        for(int i=0;i<s.length();i++){\\n            int ch = s.charAt(i) - \\'a\\';\\n            if(node.children[ch]==null)\\n                return false;\\n            node = node.children[ch];\\n        }\\n        return node.isEndOfWord;\\n    }\\n    \\n    List<String> list;\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Trie root = new Trie();\\n        for(String st:wordDict){\\n            addWord(root,st);\\n        }\\n        list = new ArrayList();\\n        findRemainingSubString(root,\"\",s,s.length());\\n        return list;\\n    }\\n    public boolean findRemainingSubString(Trie root,String str,String s,int total){\\n        if(s==null || s.length()==0)\\n            return true;\\n        for(int i=0;i<=s.length();i++){\\n            String st = str;\\n            if(search(root,s.substring(0,i))){\\n                st = st + s.substring(0,i)+ \" \";\\n                if(!findRemainingSubString(root,st,s.substring(i),total+1))\\n                    return false;\\n                if(st.trim().length()==total)\\n                    list.add(st.trim());\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163512,
                "title": "backtracking-javascript",
                "content": "```\\nvar wordBreak = function(s, wordDict) {\\n    /*\\n        1) create a hashmap and store words of dict by first\\n        letter\\n        2) iterate though the given string and if we found\\n        start letter in hashmap, we will get all the words in it\\n        and try to create a sentance starting from each of them\\n        3) for example, if we got c: [cat, cats] -> we take cat\\n        and see if this is a substring of the string, if it is,\\n        call recursion on the rest of the string, now the first letter is\\n        s -> check if we have any words starting from s\\n        4) add the path to an array and if the str is empty add to res and rturn\\n    */\\n    let dict = new Map();\\n    for (let word of wordDict) {\\n        if (!dict.has(word[0])) dict.set(word[0], []);\\n        dict.get(word[0]).push(word);\\n    }\\n    \\n    let sentences = [];\\n    function recurse(sentence, string) {\\n        if (string === \\'\\') {\\n            sentences.push(sentence.join(\\' \\'));\\n            return;\\n        }\\n        if (dict.has(string[0])) {\\n            let words = dict.get(string[0]);\\n            for (let word of words) {\\n                let len = word.length;\\n                let substring = string.substring(0, len);\\n                if (substring === word) {\\n                         sentence.push(word);\\n                         recurse([...sentence], string.substring(len));\\n                         sentence.pop();\\n                }\\n            }\\n        }\\n    }\\n    \\n    recurse([], s);\\n    return sentences;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar wordBreak = function(s, wordDict) {\\n    /*\\n        1) create a hashmap and store words of dict by first\\n        letter\\n        2) iterate though the given string and if we found\\n        start letter in hashmap, we will get all the words in it\\n        and try to create a sentance starting from each of them\\n        3) for example, if we got c: [cat, cats] -> we take cat\\n        and see if this is a substring of the string, if it is,\\n        call recursion on the rest of the string, now the first letter is\\n        s -> check if we have any words starting from s\\n        4) add the path to an array and if the str is empty add to res and rturn\\n    */\\n    let dict = new Map();\\n    for (let word of wordDict) {\\n        if (!dict.has(word[0])) dict.set(word[0], []);\\n        dict.get(word[0]).push(word);\\n    }\\n    \\n    let sentences = [];\\n    function recurse(sentence, string) {\\n        if (string === \\'\\') {\\n            sentences.push(sentence.join(\\' \\'));\\n            return;\\n        }\\n        if (dict.has(string[0])) {\\n            let words = dict.get(string[0]);\\n            for (let word of words) {\\n                let len = word.length;\\n                let substring = string.substring(0, len);\\n                if (substring === word) {\\n                         sentence.push(word);\\n                         recurse([...sentence], string.substring(len));\\n                         sentence.pop();\\n                }\\n            }\\n        }\\n    }\\n    \\n    recurse([], s);\\n    return sentences;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1158796,
                "title": "my-concise-java-solution-memorized-dfs-backtracking-easy-to-understand",
                "content": "- iterate all the words in the wordDict, find if the prefix of the current string matches a word in the dictionary\\n- current string = prefix + suffix\\n- if true, we do the same operation to the suffix, and find its list of word break ==> **sublist**\\n- return the final list of word break of the original string by concating **prefix + sublist**\\n\\nThe time complexity is O(len(wordDict) ^ len(s / minWordLenInDict)) \\n\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        // dfs with memorization\\n        return dfs(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n    \\n    private List<String> dfs(String s, List<String> wordDict, HashMap<String, List<String>> memo) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                String next = s.substring(word.length());\\n                List<String> sublist = dfs(s.substring(word.length()), wordDict, memo);\\n                if (next.isEmpty()) res.add(word);\\n                else {\\n                    for(String sub: sublist) {\\n                        res.add(word + \" \" + sub);\\n                    }\\n                }            \\n            }\\n        } \\n        memo.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        // dfs with memorization\\n        return dfs(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n    \\n    private List<String> dfs(String s, List<String> wordDict, HashMap<String, List<String>> memo) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                String next = s.substring(word.length());\\n                List<String> sublist = dfs(s.substring(word.length()), wordDict, memo);\\n                if (next.isEmpty()) res.add(word);\\n                else {\\n                    for(String sub: sublist) {\\n                        res.add(word + \" \" + sub);\\n                    }\\n                }            \\n            }\\n        } \\n        memo.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984991,
                "title": "my-java-solution-backtracking-6ms",
                "content": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return backtrack(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n    \\n    private List<String> backtrack(String s, List<String> wordDict, HashMap<String, List<String>> mem) {\\n        if (mem.containsKey(s)) {\\n            return mem.get(s);\\n        }\\n        \\n        List<String> res = new ArrayList<String>();\\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                String next = s.substring(word.length());\\n                if (next.isEmpty()) res.add(word);\\n                else {\\n                    for(String sub: backtrack(next, wordDict, mem)) {\\n                        res.add(word + \" \" + sub);\\n                    }\\n                }\\n            }\\n        }\\n        mem.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return backtrack(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n    \\n    private List<String> backtrack(String s, List<String> wordDict, HashMap<String, List<String>> mem) {\\n        if (mem.containsKey(s)) {\\n            return mem.get(s);\\n        }\\n        \\n        List<String> res = new ArrayList<String>();\\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                String next = s.substring(word.length());\\n                if (next.isEmpty()) res.add(word);\\n                else {\\n                    for(String sub: backtrack(next, wordDict, mem)) {\\n                        res.add(word + \" \" + sub);\\n                    }\\n                }\\n            }\\n        }\\n        mem.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964708,
                "title": "java-simple-line-by-line-explanation-extra-optimization-over-cache-5ms",
                "content": "```\\nclass Solution {\\n    \\n    // initialize cache - given a string -> holds possible combinations of valid sentences with spaces\\n    Map < String, List < String >> cache = new HashMap < > ();\\n    \\n    public List < String > wordBreak(String s, List < String > wordDict) {\\n        int maxLen = 0;\\n        \\n        // initialize dictionary in hashset (!remember lookup in list is O(n) not O(1))\\n        Set < String > dict = new HashSet < > (wordDict);\\n        \\n        // optimization - find the largest word length in dictionary\\n        for (String word: wordDict) {\\n            maxLen = Math.max(word.length(), maxLen);\\n        }\\n\\n        return findValidSentences(s, dict, maxLen);\\n    }\\n\\n    public List < String > findValidSentences(String s, Set < String > dict, int maxLen) {\\n        \\n        // if cache already has possibilities with the string return list\\n        if (cache.containsKey(s)) {\\n            return cache.get(s);\\n        }\\n        \\n        // else build\\n        List < String > result = new ArrayList < > ();\\n        \\n        // if string itself a valid word add - helps avoiding extra space for last iteration like \"cats and dogs \" - notice extra space at end\\n        if (dict.contains(s)) {\\n            result.add(s);\\n        }\\n        \\n        /* find from len 1 till n-1 length (full word already added)\\n        \\n           break word = left + right parts\\n           \\n           notice in for loop below: we are only checking for left part to a max of maxLen in dictionary since\\n           \\n           if dict = [car,rabbit,bus]\\n           \\n           word = rabbitcarbus\\n           \\n           word = [rabbit]carbus - iterating window limited to maxLen\\n           \\n           iterating beyond this is useless, since maximum length word that can be formed is rabbit in dict,\\n           there cant be a word greater than longest word in dictionary - doubles the overall performance as input scales\\n      \\n        */\\n\\t\\t\\n        for (int i = 1; i <= maxLen && i < s.length(); i++) {\\n            \\n            // find left part\\n            String left = s.substring(0, i);\\n            \\n            // if left already in dictionary - find combinations with right part\\n            if (dict.contains(left)) {\\n                \\n                // find all possible valid combinations with right part\\n                List < String > rightSentences = findValidSentences(s.substring(i, s.length()), dict, maxLen);\\n\\n                // combine both left + right = valid sentence combinations for give String s\\n                for (String right: rightSentences) {\\n                    result.add(left + \" \" + right);\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        // cache it for repeated usage\\n        cache.put(s, result);\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // initialize cache - given a string -> holds possible combinations of valid sentences with spaces\\n    Map < String, List < String >> cache = new HashMap < > ();\\n    \\n    public List < String > wordBreak(String s, List < String > wordDict) {\\n        int maxLen = 0;\\n        \\n        // initialize dictionary in hashset (!remember lookup in list is O(n) not O(1))\\n        Set < String > dict = new HashSet < > (wordDict);\\n        \\n        // optimization - find the largest word length in dictionary\\n        for (String word: wordDict) {\\n            maxLen = Math.max(word.length(), maxLen);\\n        }\\n\\n        return findValidSentences(s, dict, maxLen);\\n    }\\n\\n    public List < String > findValidSentences(String s, Set < String > dict, int maxLen) {\\n        \\n        // if cache already has possibilities with the string return list\\n        if (cache.containsKey(s)) {\\n            return cache.get(s);\\n        }\\n        \\n        // else build\\n        List < String > result = new ArrayList < > ();\\n        \\n        // if string itself a valid word add - helps avoiding extra space for last iteration like \"cats and dogs \" - notice extra space at end\\n        if (dict.contains(s)) {\\n            result.add(s);\\n        }\\n        \\n        /* find from len 1 till n-1 length (full word already added)\\n        \\n           break word = left + right parts\\n           \\n           notice in for loop below: we are only checking for left part to a max of maxLen in dictionary since\\n           \\n           if dict = [car,rabbit,bus]\\n           \\n           word = rabbitcarbus\\n           \\n           word = [rabbit]carbus - iterating window limited to maxLen\\n           \\n           iterating beyond this is useless, since maximum length word that can be formed is rabbit in dict,\\n           there cant be a word greater than longest word in dictionary - doubles the overall performance as input scales\\n      \\n        */\\n\\t\\t\\n        for (int i = 1; i <= maxLen && i < s.length(); i++) {\\n            \\n            // find left part\\n            String left = s.substring(0, i);\\n            \\n            // if left already in dictionary - find combinations with right part\\n            if (dict.contains(left)) {\\n                \\n                // find all possible valid combinations with right part\\n                List < String > rightSentences = findValidSentences(s.substring(i, s.length()), dict, maxLen);\\n\\n                // combine both left + right = valid sentence combinations for give String s\\n                for (String right: rightSentences) {\\n                    result.add(left + \" \" + right);\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        // cache it for repeated usage\\n        cache.put(s, result);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906710,
                "title": "4-ms-c-1-d-dp-solution-easy-approach",
                "content": "* Store dictionary words in set for quick access\\n* Helper function solves for the subproblems of the main problem\\n* vdp array to check if the dp value is available or not\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string> dict;\\n    int n;\\n    string str;\\n    \\n    vector<string> helper(int i, vector<vector<string>> &dp, bool vdp[])\\n    {\\n        vector<string> tv;\\n        if(i==n)\\n        {\\n            return tv;\\n        }\\n        if(vdp[i])\\n        {\\n            return dp[i];\\n        }\\n        string ts = \"\";\\n        for(int k = i; k<n; k++)\\n        {\\n            ts+=str[k];\\n            if(dict.find(ts) == dict.end())\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                \\n                if(k+1==n)\\n                {\\n                    tv.push_back(ts);\\n                    continue;\\n                }\\n                vector<string> hv = helper(k+1, dp, vdp);\\n                for(int x = 0; x<hv.size(); x++)\\n                {\\n                    tv.push_back(ts+\" \"+hv[x]);\\n                }\\n            }\\n        }\\n        dp[i] = tv;\\n        vdp[i] = 1;\\n        return tv;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        n = s.length();\\n        str = s;\\n        for(int i =0; i<wordDict.size(); i++)\\n        {\\n            dict.insert(wordDict[i]);\\n        }\\n        vector<vector<string>> dp(n);\\n        bool vdp[n];\\n        memset(vdp,0,sizeof(vdp));\\n        return helper(0,dp,vdp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> dict;\\n    int n;\\n    string str;\\n    \\n    vector<string> helper(int i, vector<vector<string>> &dp, bool vdp[])\\n    {\\n        vector<string> tv;\\n        if(i==n)\\n        {\\n            return tv;\\n        }\\n        if(vdp[i])\\n        {\\n            return dp[i];\\n        }\\n        string ts = \"\";\\n        for(int k = i; k<n; k++)\\n        {\\n            ts+=str[k];\\n            if(dict.find(ts) == dict.end())\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                \\n                if(k+1==n)\\n                {\\n                    tv.push_back(ts);\\n                    continue;\\n                }\\n                vector<string> hv = helper(k+1, dp, vdp);\\n                for(int x = 0; x<hv.size(); x++)\\n                {\\n                    tv.push_back(ts+\" \"+hv[x]);\\n                }\\n            }\\n        }\\n        dp[i] = tv;\\n        vdp[i] = 1;\\n        return tv;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        n = s.length();\\n        str = s;\\n        for(int i =0; i<wordDict.size(); i++)\\n        {\\n            dict.insert(wordDict[i]);\\n        }\\n        vector<vector<string>> dp(n);\\n        bool vdp[n];\\n        memset(vdp,0,sizeof(vdp));\\n        return helper(0,dp,vdp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780244,
                "title": "top-down-very-clean-memo-code-java",
                "content": "```\\nclass Solution { //TOP DOWN, VERY CLEAN MEMO CODE\\n    Map<String, List<String>> memo = new HashMap<>();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                if (s.length() == word.length())\\n                    res.add(word);\\n                else {\\n                    List<String> sub = wordBreak(s.substring(word.length()), wordDict);\\n                    for (String w : sub)\\n                        res.add(word + \" \" + w);\\n                }\\n            }\\n        }\\n        \\n        memo.put(s, res);\\n        return memo.get(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution { //TOP DOWN, VERY CLEAN MEMO CODE\\n    Map<String, List<String>> memo = new HashMap<>();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                if (s.length() == word.length())\\n                    res.add(word);\\n                else {\\n                    List<String> sub = wordBreak(s.substring(word.length()), wordDict);\\n                    for (String w : sub)\\n                        res.add(word + \" \" + w);\\n                }\\n            }\\n        }\\n        \\n        memo.put(s, res);\\n        return memo.get(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769290,
                "title": "go-0-ms-dp-solution-beats-100-time",
                "content": "```\\nfunc wordBreak(s string, wordDict []string) []string {\\n    dp := make(map[string][]string)    \\n    set := make(map[string]bool)\\n    for _, v := range wordDict {\\n        set[v] = true\\n    }\\n    return generate(s, dp, set)\\n}\\n\\nfunc generate(s string, dp map[string][]string, set map[string]bool) []string{\\n    \\n    if val , ok := dp[s]; ok {\\n        return val\\n    }\\n    \\n    var output []string\\n    \\n    if len(s) == 0 {\\n        output = append(output, \"\")\\n        return output\\n    }\\n    \\n    var prefix string\\n    \\n    for i := 0; i < len(s); i++ {\\n        prefix += string(s[i])\\n        \\n        if _, ok := set[prefix]; ok {        \\n            var smallOutput []string = generate(s[i + 1 : ], dp, set)\\n            for _, val := range smallOutput {\\n                if len(val) > 0 {\\n                    output = append(output, prefix + \" \" + val)   \\n                }else {\\n                    output = append(output, prefix)\\n                }\\n            }\\n        }\\n    }\\n    \\n    dp[s] = output\\n    return output\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc wordBreak(s string, wordDict []string) []string {\\n    dp := make(map[string][]string)    \\n    set := make(map[string]bool)\\n    for _, v := range wordDict {\\n        set[v] = true\\n    }\\n    return generate(s, dp, set)\\n}\\n\\nfunc generate(s string, dp map[string][]string, set map[string]bool) []string{\\n    \\n    if val , ok := dp[s]; ok {\\n        return val\\n    }\\n    \\n    var output []string\\n    \\n    if len(s) == 0 {\\n        output = append(output, \"\")\\n        return output\\n    }\\n    \\n    var prefix string\\n    \\n    for i := 0; i < len(s); i++ {\\n        prefix += string(s[i])\\n        \\n        if _, ok := set[prefix]; ok {        \\n            var smallOutput []string = generate(s[i + 1 : ], dp, set)\\n            for _, val := range smallOutput {\\n                if len(val) > 0 {\\n                    output = append(output, prefix + \" \" + val)   \\n                }else {\\n                    output = append(output, prefix)\\n                }\\n            }\\n        }\\n    }\\n    \\n    dp[s] = output\\n    return output\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764419,
                "title": "java-recursive-memoized-solution-w-video-explanation",
                "content": "https://www.youtube.com/watch?v=9-grHHGUVls\\n```\\nclass Solution {\\n    Map<String, List<String>> memo = new HashMap<>();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                if (s.length() == word.length())\\n                    res.add(word);\\n                else {\\n                    List<String> sub = wordBreak(s.substring(word.length()), wordDict);\\n                    for (String w : sub)\\n                        res.add(word + \" \" + w);\\n                }\\n            }\\n        }\\n        \\n        memo.put(s, res);\\n        return memo.get(s);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, List<String>> memo = new HashMap<>();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                if (s.length() == word.length())\\n                    res.add(word);\\n                else {\\n                    List<String> sub = wordBreak(s.substring(word.length()), wordDict);\\n                    for (String w : sub)\\n                        res.add(word + \" \" + w);\\n                }\\n            }\\n        }\\n        \\n        memo.put(s, res);\\n        return memo.get(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764113,
                "title": "kotlin-concise-solution",
                "content": "```\\nclass Solution {\\n\\n    fun wordBreak(s: String, wordDict: List<String>): List<String> {\\n        return buildWord(s, wordDict, hashMapOf())\\n    }\\n\\n    private fun buildWord(\\n        text: String,\\n        wordDict: List<String>,\\n        map: HashMap<String, LinkedList<String>>\\n    ): List<String> {\\n        if (map.containsKey(text)) return map[text]!!\\n\\n        val result = LinkedList<String>()\\n        if (text.isEmpty()) return result.apply { add(\"\") }\\n\\n        for (word in wordDict) {\\n            if (text.startsWith(word)) {\\n                buildWord(text.substring(word.length), wordDict, map)\\n                    .forEach { subWord -> result.add(\"$word${if (subWord.isEmpty()) \"\" else \" \"}$subWord\") }\\n            }\\n        }\\n\\n        map[text] = result\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    fun wordBreak(s: String, wordDict: List<String>): List<String> {\\n        return buildWord(s, wordDict, hashMapOf())\\n    }\\n\\n    private fun buildWord(\\n        text: String,\\n        wordDict: List<String>,\\n        map: HashMap<String, LinkedList<String>>\\n    ): List<String> {\\n        if (map.containsKey(text)) return map[text]!!\\n\\n        val result = LinkedList<String>()\\n        if (text.isEmpty()) return result.apply { add(\"\") }\\n\\n        for (word in wordDict) {\\n            if (text.startsWith(word)) {\\n                buildWord(text.substring(word.length), wordDict, map)\\n                    .forEach { subWord -> result.add(\"$word${if (subWord.isEmpty()) \"\" else \" \"}$subWord\") }\\n            }\\n        }\\n\\n        map[text] = result\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763711,
                "title": "java-backtrackig-memoization",
                "content": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n    \\n        Set<String> dict = new HashSet<>(wordDict);\\n        Map<String,List<String>> memo = new HashMap<>();\\n          \\n       return helper(dict, s , memo);\\n    }\\n    \\n    \\n    private List<String> helper(Set<String> dict , String s , Map<String,List<String>> memo){\\n        \\n        if(memo.containsKey(s))\\n            return memo.get(s);\\n         \\n        List<String> ans = new ArrayList<>();\\n        \\n        if(s == null || s.isEmpty()){\\n            return ans;\\n          }\\n  \\n        int N = s.length();    \\n      \\n        for(String word : dict){\\n         \\n            if(!s.startsWith(word)){\\n               continue;\\n            } \\n            int len = word.length();\\n           if(N == len){\\n               ans.add(word);\\n           }else{\\n               List<String> res = helper(dict , s.substring(len),memo );\\n               for(String str : res){\\n                   ans.add( word + \" \" + str);\\n               }\\n           }\\n        }\\n        memo.put(s,ans);\\n      return ans;  \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n    \\n        Set<String> dict = new HashSet<>(wordDict);\\n        Map<String,List<String>> memo = new HashMap<>();\\n          \\n       return helper(dict, s , memo);\\n    }\\n    \\n    \\n    private List<String> helper(Set<String> dict , String s , Map<String,List<String>> memo){\\n        \\n        if(memo.containsKey(s))\\n            return memo.get(s);\\n         \\n        List<String> ans = new ArrayList<>();\\n        \\n        if(s == null || s.isEmpty()){\\n            return ans;\\n          }\\n  \\n        int N = s.length();    \\n      \\n        for(String word : dict){\\n         \\n            if(!s.startsWith(word)){\\n               continue;\\n            } \\n            int len = word.length();\\n           if(N == len){\\n               ans.add(word);\\n           }else{\\n               List<String> res = helper(dict , s.substring(len),memo );\\n               for(String str : res){\\n                   ans.add( word + \" \" + str);\\n               }\\n           }\\n        }\\n        memo.put(s,ans);\\n      return ans;  \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763410,
                "title": "java-80-fast-explained-code",
                "content": "If you found the solution helpful, kindly like and upvote. :)\\n\\n**MAIN IDEA**\\n1. Take the words from the dictionary, and check if the target String starts with that.\\n2. If it does, we will generate all the valid substrings, and simply add that to our result.\\n\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return wordHelper(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n\\n\\tprivate List<String> wordHelper(String s, List<String> wordDict, Map<String, List<String>> cache) {\\n\\t\\tif(cache.containsKey(s))\\n\\t\\t\\treturn cache.get(s);\\n\\t\\tList<String> res= new ArrayList<String>();\\n\\t\\tif(s.length()==0) \\n\\t\\t{\\n\\t\\t\\tres.add(\"\");\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tfor(String word:wordDict)\\n\\t\\t{\\n\\t\\t\\t//Check if the word starts with the dictionary word\\n\\t\\t\\tif(s.startsWith(word))\\n\\t\\t\\t{\\n\\t\\t\\t\\t//Now we need to find all the subsets of in the String from the dict\\n\\t\\t\\t\\t//and add them to a List\\n\\t\\t\\t\\tList<String> subStr= wordHelper(s.substring(word.length()), wordDict, cache);\\n\\t\\t\\t\\t//Now we have all the subsets, we will now start making our results\\n\\t\\t\\t\\tfor(String subs: subStr)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString space= subs.isEmpty()? \"\":\" \";\\n\\t\\t\\t\\t\\tres.add(word+space+subs);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcache.put(s, res);\\n\\t\\treturn res;       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return wordHelper(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n\\n\\tprivate List<String> wordHelper(String s, List<String> wordDict, Map<String, List<String>> cache) {\\n\\t\\tif(cache.containsKey(s))\\n\\t\\t\\treturn cache.get(s);\\n\\t\\tList<String> res= new ArrayList<String>();\\n\\t\\tif(s.length()==0) \\n\\t\\t{\\n\\t\\t\\tres.add(\"\");\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tfor(String word:wordDict)\\n\\t\\t{\\n\\t\\t\\t//Check if the word starts with the dictionary word\\n\\t\\t\\tif(s.startsWith(word))\\n\\t\\t\\t{\\n\\t\\t\\t\\t//Now we need to find all the subsets of in the String from the dict\\n\\t\\t\\t\\t//and add them to a List\\n\\t\\t\\t\\tList<String> subStr= wordHelper(s.substring(word.length()), wordDict, cache);\\n\\t\\t\\t\\t//Now we have all the subsets, we will now start making our results\\n\\t\\t\\t\\tfor(String subs: subStr)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString space= subs.isEmpty()? \"\":\" \";\\n\\t\\t\\t\\t\\tres.add(word+space+subs);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcache.put(s, res);\\n\\t\\treturn res;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763317,
                "title": "word-break-2-c-solution-with-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<string>> word_map;\\n    vector<vector<string>> dp;\\n    vector<bool> visited;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        n = s.length();\\n        word_map = vector<vector<string>> (n);\\n        dp = vector<vector<string>>(n);\\n        visited = vector<bool>(n, false);\\n        \\n        populate_word_map(s, wordDict);\\n        create_sentences(0);\\n        \\n        return dp[0];\\n    }\\n    \\n    void populate_word_map(const string& s, vector<string>& wordDict) {\\n        int pos, l;\\n        for (auto& word : wordDict) {\\n            pos = 0;\\n            l = word.length();\\n            while ((pos = s.find(word, pos)) != string::npos) {\\n                word_map[pos].push_back(word);\\n                pos ++;\\n            }\\n        }\\n    }\\n    \\n    void create_sentences(int pos) {\\n        for (auto& word : word_map[pos]) {\\n            int new_pos = pos + word.length();\\n            \\n            if (new_pos == n) {\\n                dp[pos].push_back(word);\\n            } else {\\n                if (!visited[new_pos])\\n                    create_sentences(new_pos);\\n                for (auto& sentence : dp[new_pos])\\n                    dp[pos].push_back(word + \" \" + sentence);\\n            }\\n        }\\n        \\n        visited[pos] = true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<string>> word_map;\\n    vector<vector<string>> dp;\\n    vector<bool> visited;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        n = s.length();\\n        word_map = vector<vector<string>> (n);\\n        dp = vector<vector<string>>(n);\\n        visited = vector<bool>(n, false);\\n        \\n        populate_word_map(s, wordDict);\\n        create_sentences(0);\\n        \\n        return dp[0];\\n    }\\n    \\n    void populate_word_map(const string& s, vector<string>& wordDict) {\\n        int pos, l;\\n        for (auto& word : wordDict) {\\n            pos = 0;\\n            l = word.length();\\n            while ((pos = s.find(word, pos)) != string::npos) {\\n                word_map[pos].push_back(word);\\n                pos ++;\\n            }\\n        }\\n    }\\n    \\n    void create_sentences(int pos) {\\n        for (auto& word : word_map[pos]) {\\n            int new_pos = pos + word.length();\\n            \\n            if (new_pos == n) {\\n                dp[pos].push_back(word);\\n            } else {\\n                if (!visited[new_pos])\\n                    create_sentences(new_pos);\\n                for (auto& sentence : dp[new_pos])\\n                    dp[pos].push_back(word + \" \" + sentence);\\n            }\\n        }\\n        \\n        visited[pos] = true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763276,
                "title": "c-dfs-with-cache",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n       \\tunordered_set<string> dict;\\n       \\tfor (auto w : wordDict) {\\n       \\t\\tdict.insert(w);\\n       \\t}\\n\\n       \\tvector<string> sentences;\\n       \\tunordered_map<int, vector<string>> cache;\\n       \\tdfs(s, 0, dict, sentences, cache);\\n       \\treturn sentences;\\n    }\\n\\n    void dfs(string &s, int idx, unordered_set<string> &dict, vector<string> &sentences, unordered_map<int, vector<string>> &cache) {\\n    \\tint n = s.length();\\n    \\tif (n == idx) {\\n    \\t\\tsentences.push_back(\"\");\\n    \\t\\treturn;\\n    \\t}\\n\\n    \\tstring word;\\n    \\tfor (int i = idx; i < n; ++i) {\\n    \\t\\tword.push_back(s[i]);\\n    \\t\\tif (dict.count(word)) {\\n    \\t\\t\\tvector<string> sents;\\n                if (cache.count(i + 1)) {\\n                    sents = cache[i + 1];\\n                } else {\\n    \\t\\t\\t    dfs(s, i + 1, dict, sents, cache);\\n                    cache[i + 1] = sents;\\n                }\\n    \\t\\t\\tfor (auto s : sents) {\\n    \\t\\t\\t\\tsentences.push_back(word);\\n    \\t\\t\\t\\tif (!s.empty()) {\\n    \\t\\t\\t\\t\\tsentences.back() += \" \" + s;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n       \\tunordered_set<string> dict;\\n       \\tfor (auto w : wordDict) {\\n       \\t\\tdict.insert(w);\\n       \\t}\\n\\n       \\tvector<string> sentences;\\n       \\tunordered_map<int, vector<string>> cache;\\n       \\tdfs(s, 0, dict, sentences, cache);\\n       \\treturn sentences;\\n    }\\n\\n    void dfs(string &s, int idx, unordered_set<string> &dict, vector<string> &sentences, unordered_map<int, vector<string>> &cache) {\\n    \\tint n = s.length();\\n    \\tif (n == idx) {\\n    \\t\\tsentences.push_back(\"\");\\n    \\t\\treturn;\\n    \\t}\\n\\n    \\tstring word;\\n    \\tfor (int i = idx; i < n; ++i) {\\n    \\t\\tword.push_back(s[i]);\\n    \\t\\tif (dict.count(word)) {\\n    \\t\\t\\tvector<string> sents;\\n                if (cache.count(i + 1)) {\\n                    sents = cache[i + 1];\\n                } else {\\n    \\t\\t\\t    dfs(s, i + 1, dict, sents, cache);\\n                    cache[i + 1] = sents;\\n                }\\n    \\t\\t\\tfor (auto s : sents) {\\n    \\t\\t\\t\\tsentences.push_back(word);\\n    \\t\\t\\t\\tif (!s.empty()) {\\n    \\t\\t\\t\\t\\tsentences.back() += \" \" + s;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706993,
                "title": "python3-top-down-dp",
                "content": "Algo: \\nDefine `fn(i)` to be the sentences formed by `s[i:]`. Then, the recursion satisfies \\n\\n`fn(i) = [[word] + x for x in fn(i + len(word)] for word in wordDict if s[i:].startswith(word)` \\n\\n(56ms, 38.79%)\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        wordDict = set(wordDict) #edit: better performance \\n        \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return sentences of s[i:]\"\"\"\\n            if i == len(s): return [[]]\\n            ans = []\\n            for ii in range(i+1, len(s)+1):\\n                if s[i:ii] in wordDict: \\n                    ans.extend([s[i:ii]] + x for x in fn(ii))\\n            return ans \\n        \\n        return [\" \".join(x) for x in fn(0)]\\n```\\n\\nAlternatively one could go forward path (40ms, 84.72%) like below \\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return sentences from s[:i]\"\"\"\\n            if i == 0: return [[]] #boundary condition \\n            ans = []\\n            for word in wordDict: \\n                if s[i-len(word):i] == word:\\n                    ans.extend([x + [word] for x in fn(i-len(word))])\\n            return ans \\n            \\n        return [\" \".join(x) for x in fn(len(s))]\\n```\\n\\nThe bottom-up implementation is very easy to go TLE. The reason is that it doesn\\'t a lot of unnecessary calculations while top-down only does what\\'s required.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        wordDict = set(wordDict) #edit: better performance \\n        \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return sentences of s[i:]\"\"\"\\n            if i == len(s): return [[]]\\n            ans = []\\n            for ii in range(i+1, len(s)+1):\\n                if s[i:ii] in wordDict: \\n                    ans.extend([s[i:ii]] + x for x in fn(ii))\\n            return ans \\n        \\n        return [\" \".join(x) for x in fn(0)]\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return sentences from s[:i]\"\"\"\\n            if i == 0: return [[]] #boundary condition \\n            ans = []\\n            for word in wordDict: \\n                if s[i-len(word):i] == word:\\n                    ans.extend([x + [word] for x in fn(i-len(word))])\\n            return ans \\n            \\n        return [\" \".join(x) for x in fn(len(s))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 670116,
                "title": "java-backtrack-solusion-with-detail-comments-and-thoughts-step-by-step",
                "content": "This is kind of  a String-Problem. So the idea first come up to my mind is BackTrack!!\\nBackTrack is an useful method to traverse all the combinations of string-like brute force. \\nAlso the solusion is really easy to come up with!\\n\\n```\\n public List<String> wordBreak1(String s, List<String> wordDict) {     \\n        List<String> res = new ArrayList<>();\\n        int n=s.length();\\n        if(n<=0) return res; \\n        Set<String> dic = new HashSet<>(wordDict);\\n        \\n        backTrack1(res,\"\",s,dic,0);\\n        \\n        return res;\\n    }\\n    //TLE \\n    void backTrack1(List<String> res, String path, String s, Set<String> dic, int idx ){\\n        if(idx==s.length()){\\n            res.add(path);\\n            return;\\n        }\\n        for(int i=idx;i<s.length();i++){\\n            String cur=s.substring(idx,i+1);\\n            if(dic.contains(cur)){\\n                if(idx==0)  backTrack1(res, cur,s,dic,i+1);\\n                else backTrack1(res, path+\" \"+ cur,s,dic,i+1);\\n            }\\n        }   \\n    }\\n```\\nThis solusion works correctly! But, in some extremely conditions, it will TLE. \\nWe know the Time Complexity of BackTrack algorithm is **expotional**( O(N^M) N is the longth of string).\\n\\nNext step is to improve our solution. \\nLets see the parameters of the method, everytime we use a string to concatenate with other string.\\nSo we can use StringBuilder to replace it. However, only change this, still TLE.\\n\\nNext, we thought to use some extra memory to improve the running time. It not difficult to come up with the strategy-- **Space exchange Time**!\\n\\nThat is why I thought to use a HashMap to store all the sub-problem results. Each time we get the sub-result only use O(1) time.  Here is the code!\\n\\n```\\n  public List<String> wordBreak(String s, List<String> wordDict) {\\n        \\n        List<String> res = new ArrayList<>();\\n        int n=s.length();\\n\\t\\t//This is the conner case\\n        if(n<=0) return res;\\n        \\n\\t\\t//change the List to the Set, becasue we always want to check with it.\\n        Set<String> dic = new HashSet<>(wordDict);\\n        \\n        res =backTrack(s,dic);\\n        \\n        return res;\\n    }\\n\\t\\n    //Using hashMap to store the sub-problem results\\n    HashMap<String,List<String>> map = new HashMap<>();\\n    \\n    List<String> backTrack(String s, Set<String> dic){\\n       \\n        List<String> res  = new ArrayList<>();\\n\\t\\t//this is the conner case\\n        if(s.length()<=0){\\n            res.add(\"\");\\n            return res;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n\\t\\t\\t//we get cur split string\\n            String cur=s.substring(0,i+1);\\n            \\n            if(dic.contains(cur)){  \\n                \\n                String next=s.substring(i+1);\\n                List<String> subans =new ArrayList<>();\\n\\t\\t\\t\\t//here our map used\\n                if(map.containsKey(next)){\\n                    subans=map.get(next);\\n                }else{\\n                    subans = backTrack(next,dic);\\n                } \\n\\t\\t\\t\\t//combine the total answer\\n                for(String str:subans){            \\n                    if(str.equals(\"\")) res.add(cur);\\n                    else res.add(cur+\" \"+str);\\n                }\\n            }\\n        }\\n\\t\\t//add this level result to the map\\n        map.put(s,res);\\n        return res;  \\n   }\\n```\\nIf you like my idea, please vote it!!",
                "solutionTags": [],
                "code": "```\\n public List<String> wordBreak1(String s, List<String> wordDict) {     \\n        List<String> res = new ArrayList<>();\\n        int n=s.length();\\n        if(n<=0) return res; \\n        Set<String> dic = new HashSet<>(wordDict);\\n        \\n        backTrack1(res,\"\",s,dic,0);\\n        \\n        return res;\\n    }\\n    //TLE \\n    void backTrack1(List<String> res, String path, String s, Set<String> dic, int idx ){\\n        if(idx==s.length()){\\n            res.add(path);\\n            return;\\n        }\\n        for(int i=idx;i<s.length();i++){\\n            String cur=s.substring(idx,i+1);\\n            if(dic.contains(cur)){\\n                if(idx==0)  backTrack1(res, cur,s,dic,i+1);\\n                else backTrack1(res, path+\" \"+ cur,s,dic,i+1);\\n            }\\n        }   \\n    }\\n```\n```\\n  public List<String> wordBreak(String s, List<String> wordDict) {\\n        \\n        List<String> res = new ArrayList<>();\\n        int n=s.length();\\n\\t\\t//This is the conner case\\n        if(n<=0) return res;\\n        \\n\\t\\t//change the List to the Set, becasue we always want to check with it.\\n        Set<String> dic = new HashSet<>(wordDict);\\n        \\n        res =backTrack(s,dic);\\n        \\n        return res;\\n    }\\n\\t\\n    //Using hashMap to store the sub-problem results\\n    HashMap<String,List<String>> map = new HashMap<>();\\n    \\n    List<String> backTrack(String s, Set<String> dic){\\n       \\n        List<String> res  = new ArrayList<>();\\n\\t\\t//this is the conner case\\n        if(s.length()<=0){\\n            res.add(\"\");\\n            return res;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n\\t\\t\\t//we get cur split string\\n            String cur=s.substring(0,i+1);\\n            \\n            if(dic.contains(cur)){  \\n                \\n                String next=s.substring(i+1);\\n                List<String> subans =new ArrayList<>();\\n\\t\\t\\t\\t//here our map used\\n                if(map.containsKey(next)){\\n                    subans=map.get(next);\\n                }else{\\n                    subans = backTrack(next,dic);\\n                } \\n\\t\\t\\t\\t//combine the total answer\\n                for(String str:subans){            \\n                    if(str.equals(\"\")) res.add(cur);\\n                    else res.add(cur+\" \"+str);\\n                }\\n            }\\n        }\\n\\t\\t//add this level result to the map\\n        map.put(s,res);\\n        return res;  \\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 627264,
                "title": "simple-c-solution-dp-and-dfs",
                "content": "Base On Word Break I , I will use  vector<vector<string>> dp to keep the possible candidates\\n\\n```\\nvector<string> wordBreak(string s, vector<string>& dict) {\\n        vector<string> res;\\n        if (dict.size() == 0) return res;\\n        int n = s.size();\\n        vector<vector<string>> dp(n+1, vector<string>());\\n        dp[0] = {\" \"};\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >=0; --j) {\\n                if (!dp[j].empty()) {\\n                    string word = s.substr(j, i-j);\\n                    if (find(dict.begin(), dict.end(), word) != dict.end()) {\\n                        dp[i].push_back(word);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        dfs(n, dp, \"\", res);\\n        \\n        return res;\\n    }\\n    \\n    void dfs(int loc, vector<vector<string>> dp, string word, vector<string> &res) {\\n        if (loc == 0) {\\n            res.push_back(word);\\n            return;\\n        }\\n        \\n        for (auto subword : dp[loc]) {\\n            int len = subword.size();\\n            string updateword = subword + (word.empty() ? \"\" : \" \")  + word;\\n            dfs(loc - len, dp, updateword, res);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> wordBreak(string s, vector<string>& dict) {\\n        vector<string> res;\\n        if (dict.size() == 0) return res;\\n        int n = s.size();\\n        vector<vector<string>> dp(n+1, vector<string>());\\n        dp[0] = {\" \"};\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >=0; --j) {\\n                if (!dp[j].empty()) {\\n                    string word = s.substr(j, i-j);\\n                    if (find(dict.begin(), dict.end(), word) != dict.end()) {\\n                        dp[i].push_back(word);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        dfs(n, dp, \"\", res);\\n        \\n        return res;\\n    }\\n    \\n    void dfs(int loc, vector<vector<string>> dp, string word, vector<string> &res) {\\n        if (loc == 0) {\\n            res.push_back(word);\\n            return;\\n        }\\n        \\n        for (auto subword : dp[loc]) {\\n            int len = subword.size();\\n            string updateword = subword + (word.empty() ? \"\" : \" \")  + word;\\n            dfs(loc - len, dp, updateword, res);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 627065,
                "title": "java-6-ms-faster-than-92-33-trie-based-dfs-approach",
                "content": "I implemented a Trie based DP approach to generate all combinations of words from the dictionary of words using the input String.\\n```\\npublic List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> res = new ArrayList<>();\\n        \\n        if(s.isEmpty())\\n            return res;\\n        \\n        Trie root = new Trie();\\n        buildTrie(wordDict, root);\\n        Map<String, List<String>> map = new HashMap<>();\\n        buildWord(s, root, map);\\n        \\n        return map.get(s);\\n    }\\n    \\n    List<String> buildWord(String s, Trie root, Map<String, List<String>> map){\\n        if(map.containsKey(s)){\\n            return map.get(s);\\n        }\\n        \\n       List<String> res = new ArrayList<>();\\n        if(s.isEmpty()){\\n            res.add(\"\");\\n        }else{\\n            Trie node = root;\\n            for(int i=0;i<s.length();i++){\\n                \\n                char c = s.charAt(i);    \\n                if(node.next.containsKey(c)){\\n                    node = node.next.get(c);\\n                    \\n                    if(node.word != null){\\n                        String str = i == s.length() ? \"\" : s.substring(i+1);\\n                        List<String> data = buildWord(str, root, map );\\n                        \\n                        for(String s1: data){\\n                            res.add(node.word + (s1.isEmpty() ? \"\" : \" \" + s1));\\n                        }\\n                    }\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        map.put(s, res);\\n        return res;  \\n    }\\n    \\n    void buildTrie(List<String> wordDict, Trie root){ \\n        for(String w: wordDict){\\n            Trie node = root;   \\n            for(char c: w.toCharArray()){\\n                Trie n = null;\\n                if(!node.next.containsKey(c)){\\n                    n = new Trie();\\n                    node.next.put(c, n);\\n                }else{\\n                    n = node.next.get(c);\\n                }\\n                \\n                node = n; \\n            }\\n            node.word = w;\\n        }\\n    }\\n    \\n    class Trie{\\n        Map<Character, Trie> next = new HashMap<>();\\n        String word;\\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "I implemented a Trie based DP approach to generate all combinations of words from the dictionary of words using the input String.\\n```\\npublic List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> res = new ArrayList<>();\\n        \\n        if(s.isEmpty())\\n            return res;\\n        \\n        Trie root = new Trie();\\n        buildTrie(wordDict, root);\\n        Map<String, List<String>> map = new HashMap<>();\\n        buildWord(s, root, map);\\n        \\n        return map.get(s);\\n    }\\n    \\n    List<String> buildWord(String s, Trie root, Map<String, List<String>> map){\\n        if(map.containsKey(s)){\\n            return map.get(s);\\n        }\\n        \\n       List<String> res = new ArrayList<>();\\n        if(s.isEmpty()){\\n            res.add(\"\");\\n        }else{\\n            Trie node = root;\\n            for(int i=0;i<s.length();i++){\\n                \\n                char c = s.charAt(i);    \\n                if(node.next.containsKey(c)){\\n                    node = node.next.get(c);\\n                    \\n                    if(node.word != null){\\n                        String str = i == s.length() ? \"\" : s.substring(i+1);\\n                        List<String> data = buildWord(str, root, map );\\n                        \\n                        for(String s1: data){\\n                            res.add(node.word + (s1.isEmpty() ? \"\" : \" \" + s1));\\n                        }\\n                    }\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        map.put(s, res);\\n        return res;  \\n    }\\n    \\n    void buildTrie(List<String> wordDict, Trie root){ \\n        for(String w: wordDict){\\n            Trie node = root;   \\n            for(char c: w.toCharArray()){\\n                Trie n = null;\\n                if(!node.next.containsKey(c)){\\n                    n = new Trie();\\n                    node.next.put(c, n);\\n                }else{\\n                    n = node.next.get(c);\\n                }\\n                \\n                node = n; \\n            }\\n            node.word = w;\\n        }\\n    }\\n    \\n    class Trie{\\n        Map<Character, Trie> next = new HashMap<>();\\n        String word;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 609287,
                "title": "c-dp-memoisation-20-lines-61-on-time-70-on-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string& s, int idx, unordered_set<string>& words, unordered_map<int, vector<string>>& dp) {\\n        if (dp.count(idx) == 0) {\\n            for (int i = idx-1; i >= 0; i--) {\\n                string tail = s.substr(i, idx-i);\\n                if (words.count(tail) == 0) continue;\\n                for (string sol : wordBreak(s, i, words, dp)) {\\n                    dp[idx].push_back(sol.append(tail).append(\" \"));\\n                }\\n            }\\n        }\\n        \\n        return dp[idx];\\n    }\\n    \\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> words(wordDict.cbegin(), wordDict.cend());\\n        unordered_map<int, vector<string>> dp;\\n        dp[0] = {\"\"};\\n\\n        vector<string> result = wordBreak(s, s.length(), words, dp);\\n        for (string& sentence : result) sentence.pop_back();\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string& s, int idx, unordered_set<string>& words, unordered_map<int, vector<string>>& dp) {\\n        if (dp.count(idx) == 0) {\\n            for (int i = idx-1; i >= 0; i--) {\\n                string tail = s.substr(i, idx-i);\\n                if (words.count(tail) == 0) continue;\\n                for (string sol : wordBreak(s, i, words, dp)) {\\n                    dp[idx].push_back(sol.append(tail).append(\" \"));\\n                }\\n            }\\n        }\\n        \\n        return dp[idx];\\n    }\\n    \\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> words(wordDict.cbegin(), wordDict.cend());\\n        unordered_map<int, vector<string>> dp;\\n        dp[0] = {\"\"};\\n\\n        vector<string> result = wordBreak(s, s.length(), words, dp);\\n        for (string& sentence : result) sentence.pop_back();\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606894,
                "title": "python-solution-and-thought-process",
                "content": "**Step 1: Identify Subproblems:**\\n```\\ndp[i] = all possible sentences in s[i:]\\ndp[i] =\\n    res = []\\n    for word in wordDict:\\n        if word != s[i:i+len(word)]:\\n            continue\\n        elif len(word) == len(s)-i:\\n            res.append(word)\\n        else:\\n            for sentence in dp[i+len(word)]:\\n                res.append(word + \\' \\' + sentence)\\n    return res\\n```\\n\\n**2. Analyze options for implementation**\\nTop down recursive solution time complexity:\\n```\\nN = len(wordDict)\\nM = min([len(word) for word in wordDict])\\nS = len(sentence)\\nO(N*N^S*S/M) = O(NN^2S/M)\\n```\\n**Note:** I\\'m not 100% sure if the top down time complexity analysis I did was correct when taking memoization into account. If someone could chime in here?\\n\\nBottom up iterative solution time complexity:\\n```\\nN = len(wordDict)\\nM = min([len(word) for word in wordDict])\\nS = len(sentence)\\nO(S*N*N^S) = O(NN^2S)\\n```\\n\\nChoose top down recursive solution to avoid TLE.\\n\\n**3. Python Code**\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        @lru_cache(maxsize=None)\\n        def dp(i):\\n            res = []\\n            for word in wordDict:\\n                if word != s[i:i+len(word)]:\\n                    continue\\n                elif len(word) == len(s)-i:\\n                    res.append(word)\\n                else:\\n                    for sentence in dp(i+len(word)):\\n                        res.append(word + \\' \\' + sentence)        \\n            return res\\n        \\n        return dp(0)\\n```\\n\\nNote:\\n* Code is based on https://leetcode.com/problems/word-break-ii/discuss/44311/Python-easy-to-understand-solution",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndp[i] = all possible sentences in s[i:]\\ndp[i] =\\n    res = []\\n    for word in wordDict:\\n        if word != s[i:i+len(word)]:\\n            continue\\n        elif len(word) == len(s)-i:\\n            res.append(word)\\n        else:\\n            for sentence in dp[i+len(word)]:\\n                res.append(word + \\' \\' + sentence)\\n    return res\\n```\n```\\nN = len(wordDict)\\nM = min([len(word) for word in wordDict])\\nS = len(sentence)\\nO(N*N^S*S/M) = O(NN^2S/M)\\n```\n```\\nN = len(wordDict)\\nM = min([len(word) for word in wordDict])\\nS = len(sentence)\\nO(S*N*N^S) = O(NN^2S)\\n```\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        @lru_cache(maxsize=None)\\n        def dp(i):\\n            res = []\\n            for word in wordDict:\\n                if word != s[i:i+len(word)]:\\n                    continue\\n                elif len(word) == len(s)-i:\\n                    res.append(word)\\n                else:\\n                    for sentence in dp(i+len(word)):\\n                        res.append(word + \\' \\' + sentence)        \\n            return res\\n        \\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533512,
                "title": "javascript-dfs-memo",
                "content": "```\\nvar wordBreak = function(s, wordDict) {\\n    \\n    const dictSet = new Set(wordDict);\\n    const memo = {};\\n\\n    function dfs(start) {\\n        \\n        if(start > s.length-1) { \\n            return [[]];\\n        }\\n        \\n        if(memo[start] !== undefined) {\\n            return memo[start];\\n        }\\n        \\n        const out = [];\\n        \\n        for(let i = start; i < s.length; i++) {\\n            const substr = s.substring(start, i+1);\\n            if(dictSet.has(substr)) {\\n                let next = dfs(i+1); \\n                for(let n of next) {\\n                    out.push([substr, ...n]);\\n                }\\n            }\\n        }  \\n        return memo[start] = out;\\n        \\n    }\\n    \\n    const res = dfs(0)\\n\\n    return res.filter(a => a.join(\\'\\') === s).map(a => a.join(\\' \\'));\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvar wordBreak = function(s, wordDict) {\\n    \\n    const dictSet = new Set(wordDict);\\n    const memo = {};\\n\\n    function dfs(start) {\\n        \\n        if(start > s.length-1) { \\n            return [[]];\\n        }\\n        \\n        if(memo[start] !== undefined) {\\n            return memo[start];\\n        }\\n        \\n        const out = [];\\n        \\n        for(let i = start; i < s.length; i++) {\\n            const substr = s.substring(start, i+1);\\n            if(dictSet.has(substr)) {\\n                let next = dfs(i+1); \\n                for(let n of next) {\\n                    out.push([substr, ...n]);\\n                }\\n            }\\n        }  \\n        return memo[start] = out;\\n        \\n    }\\n    \\n    const res = dfs(0)\\n\\n    return res.filter(a => a.join(\\'\\') === s).map(a => a.join(\\' \\'));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508994,
                "title": "c-straightforward-dfs-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string, vector<string>> memo;\\n        return dfs(s, memo, wordDict);\\n    }\\n    \\n    vector<string> dfs(string s, unordered_map<string, vector<string>>& memo, vector<string>& wordDict) {\\n        if (memo.find(s) != memo.end()) {\\n            return memo[s];\\n        }\\n        \\n        vector<string> results;\\n        if (s.size() == 0) {\\n            return {\"\"};\\n        }\\n        \\n        for (string word : wordDict) {\\n            int len = word.size();\\n            if (len <= s.size()) {\\n                if (s.substr(0, len) != word) continue;\\n                string suffix = s.substr(len);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//build results from suffix partition results - solve based on subproblems\\n                vector<string> segs = dfs(suffix, memo, wordDict);\\n                for (string seg : segs) {\\n                    results.push_back(seg.empty() ? word + seg : word + \" \" + seg);\\n                }\\n            }\\n        }\\n        \\n        memo[s] = results; //memoization\\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string, vector<string>> memo;\\n        return dfs(s, memo, wordDict);\\n    }\\n    \\n    vector<string> dfs(string s, unordered_map<string, vector<string>>& memo, vector<string>& wordDict) {\\n        if (memo.find(s) != memo.end()) {\\n            return memo[s];\\n        }\\n        \\n        vector<string> results;\\n        if (s.size() == 0) {\\n            return {\"\"};\\n        }\\n        \\n        for (string word : wordDict) {\\n            int len = word.size();\\n            if (len <= s.size()) {\\n                if (s.substr(0, len) != word) continue;\\n                string suffix = s.substr(len);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//build results from suffix partition results - solve based on subproblems\\n                vector<string> segs = dfs(suffix, memo, wordDict);\\n                for (string seg : segs) {\\n                    results.push_back(seg.empty() ? word + seg : word + \" \" + seg);\\n                }\\n            }\\n        }\\n        \\n        memo[s] = results; //memoization\\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 469507,
                "title": "c-dp-dfs-solution-95",
                "content": "We first construct a dp array for the original string. If `s[:k]` is breakable (i.e. can be broken into valid words), there must be a position `l`, where `s[:k-l]` is also breakable and `s[k-l:]` is a valid word. There can be multiple valid `l` for a given `k`. \\n\\nTo implement dp, we store all possible `k-l` positions as a set in `dp[k]`. For a given `k` we scan all possible word length `l` in the dictionary, and insert `k-l` into `dp[k]` if `l == k` or `dp[k-l]` is non-empty.\\n\\nAfter consturcting `dp` array, we use DFS to reconstruct result vector and return.\\n\\nTo increase the performance, we preprocess `dictWords` to get all possible word lengths in the dictionary.\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(const vector<unordered_set<int>>& dp, int k, vector<string>& rst, string& s) {\\n\\t\\t// function to reconstruct result string vector from dp array\\n        if (k < s.size()) {\\n             s.insert(k, 1, \\' \\');\\n        }\\n        for (int knext : dp[k]) {\\n            if (knext == 0) {\\n                rst.push_back(s);\\n            }\\n            else {\\n                dfs(dp, knext, rst, s);   \\n            }\\n        }\\n        if (k < s.size()) {\\n            s.erase(k, 1);\\n        }\\n    }\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        // preprocess wordDict, generate hash table for possible lengths and words\\n        unordered_set<int> lens;\\n        unordered_set<string> dict;\\n           for (int i(0); i < wordDict.size(); ++i) {\\n            lens.insert(wordDict[i].size());\\n            dict.insert(wordDict[i]);\\n        }\\n        // DP: dp[k] stores all possible last space positions for substring s[:k]\\n        //  i.e. if l is in dp[k], it means s[:l] can be broken into valid words and s[l:k] is a valid word\\n        const int N = s.size();\\n        vector<unordered_set<int>> dp(N+1, unordered_set<int>());\\n        for (int k(1); k <= N; ++k) {\\n            for (int l : lens) {\\n               if (l <= k) {\\n                   const string seg(s.begin() + k-l, s.begin() + k);\\n                   if (dict.count(seg)) {\\n                       if (l == k or !dp[k-l].empty()) {\\n                           dp[k].insert(k-l);\\n                       }\\n                   }\\n               }\\n            }\\n        }\\n        // generate recult with DFS\\n        vector<string> rst;\\n        dfs(dp, N, rst, s);\\n        return rst;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(const vector<unordered_set<int>>& dp, int k, vector<string>& rst, string& s) {\\n\\t\\t// function to reconstruct result string vector from dp array\\n        if (k < s.size()) {\\n             s.insert(k, 1, \\' \\');\\n        }\\n        for (int knext : dp[k]) {\\n            if (knext == 0) {\\n                rst.push_back(s);\\n            }\\n            else {\\n                dfs(dp, knext, rst, s);   \\n            }\\n        }\\n        if (k < s.size()) {\\n            s.erase(k, 1);\\n        }\\n    }\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        // preprocess wordDict, generate hash table for possible lengths and words\\n        unordered_set<int> lens;\\n        unordered_set<string> dict;\\n           for (int i(0); i < wordDict.size(); ++i) {\\n            lens.insert(wordDict[i].size());\\n            dict.insert(wordDict[i]);\\n        }\\n        // DP: dp[k] stores all possible last space positions for substring s[:k]\\n        //  i.e. if l is in dp[k], it means s[:l] can be broken into valid words and s[l:k] is a valid word\\n        const int N = s.size();\\n        vector<unordered_set<int>> dp(N+1, unordered_set<int>());\\n        for (int k(1); k <= N; ++k) {\\n            for (int l : lens) {\\n               if (l <= k) {\\n                   const string seg(s.begin() + k-l, s.begin() + k);\\n                   if (dict.count(seg)) {\\n                       if (l == k or !dp[k-l].empty()) {\\n                           dp[k].insert(k-l);\\n                       }\\n                   }\\n               }\\n            }\\n        }\\n        // generate recult with DFS\\n        vector<string> rst;\\n        dfs(dp, N, rst, s);\\n        return rst;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564947,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1564626,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1564923,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566021,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566968,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566945,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1567520,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1568130,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566752,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1567887,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1564947,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1564626,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1564923,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566021,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566968,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566945,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1567520,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1568130,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566752,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1567887,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1570691,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1569464,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1567212,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1766491,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1576594,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1575746,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1571304,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1571305,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1571306,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 2027607,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 2018427,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 2001030,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1999468,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1999390,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1977737,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1975487,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1926529,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1919580,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1911042,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1812430,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            }
        ]
    }
]