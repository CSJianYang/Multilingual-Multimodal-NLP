[
    {
        "title": "Removing Minimum and Maximum From Array",
        "question_content": "You are given a 0-indexed array of distinct integers nums.\nThere is an element in nums that has the lowest value and an element that has the highest value. We call them the minimum and maximum respectively. Your goal is to remove both these elements from the array.\nA deletion is defined as either removing an element from the front of the array or removing an element from the back of the array.\nReturn the minimum number of deletions it would take to remove both the minimum and maximum element from the array.\n&nbsp;\nExample 1:\n\nInput: nums = [2,10,7,5,4,1,8,6]\nOutput: 5\nExplanation: \nThe minimum element in the array is nums[5], which is 1.\nThe maximum element in the array is nums[1], which is 10.\nWe can remove both the minimum and maximum by removing 2 elements from the front and 3 elements from the back.\nThis results in 2 + 3 = 5 deletions, which is the minimum number possible.\n\nExample 2:\n\nInput: nums = [0,-4,19,1,8,-2,-3,5]\nOutput: 3\nExplanation: \nThe minimum element in the array is nums[1], which is -4.\nThe maximum element in the array is nums[2], which is 19.\nWe can remove both the minimum and maximum by removing 3 elements from the front.\nThis results in only 3 deletions, which is the minimum number possible.\n\nExample 3:\n\nInput: nums = [101]\nOutput: 1\nExplanation:  \nThere is only one element in the array, which makes it both the minimum and maximum element.\nWe can remove it with 1 deletion.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t-105 <= nums[i] <= 105\n\tThe integers in nums are distinct.",
        "solutions": [
            {
                "id": 1599809,
                "title": "c-only-3-cases",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n**Intuition**: Find the two indices of the maximum and minimum elements, say `a` and `b`. The order doesn\\'t matter. We only need to consider 3 cases:\\n1. Delete both from left and right.\\n2. Delete only from left\\n3. Delete only from right\\n\\n**Algorithm**:\\n\\nMake sure `a <= b`, and return the minimum of the following:\\n* `(a + 1) + (N - b)` -> delete both from left and right\\n* `b + 1` -> delete from left\\n* `N - a` -> delete from right\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/removing-minimum-and-maximum-from-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& A) {\\n        int a = max_element(begin(A), end(A)) - begin(A), b = min_element(begin(A), end(A)) - begin(A), N = A.size();\\n        if (a > b) swap(a, b);\\n        return min({ a + 1 + N - b, b + 1, N - a });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/removing-minimum-and-maximum-from-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& A) {\\n        int a = max_element(begin(A), end(A)) - begin(A), b = min_element(begin(A), end(A)) - begin(A), N = A.size();\\n        if (a > b) swap(a, b);\\n        return min({ a + 1 + N - b, b + 1, N - a });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599848,
                "title": "java-c-python-straight-forward-solutions",
                "content": "# **Explanation**\\nFind index `i` of the minimum\\nFind index `j` of the maximum\\n\\nTo remove element `A[i]`,\\nwe can remove `i + 1` elements from front,\\nor we can remove `n - i` elements from back.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minimumDeletions(int[] A) {\\n        int i = 0, j = 0, n = A.length;\\n        for (int k = 0; k < n; ++k) {\\n            if (A[i] < A[k]) i = k;\\n            if (A[j] > A[k]) j = k;\\n        }\\n        return Math.min(Math.min(Math.max(i + 1, j + 1), Math.max(n - i, n - j)), Math.min(i + 1 + n - j, j + 1 + n - i));\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimumDeletions(vector<int>& A) {\\n        int i = 0, j = 0, n = A.size();\\n        for (int k = 0; k < n; ++k) {\\n            if (A[i] < A[k]) i = k;\\n            if (A[j] > A[k]) j = k;\\n        }\\n        return min({max(i + 1, j + 1), max(n - i, n - j), i + 1 + n - j, j + 1 + n - i});\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minimumDeletions(self, A):\\n        i, j, n = A.index(min(A)), A.index(max(A)), len(A)\\n        return min(max(i + 1, j + 1), max(n - i, n - j), i + 1 + n - j, j + 1 + n - i)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minimumDeletions(int[] A) {\\n        int i = 0, j = 0, n = A.length;\\n        for (int k = 0; k < n; ++k) {\\n            if (A[i] < A[k]) i = k;\\n            if (A[j] > A[k]) j = k;\\n        }\\n        return Math.min(Math.min(Math.max(i + 1, j + 1), Math.max(n - i, n - j)), Math.min(i + 1 + n - j, j + 1 + n - i));\\n    }\\n```\n```cpp\\n    int minimumDeletions(vector<int>& A) {\\n        int i = 0, j = 0, n = A.size();\\n        for (int k = 0; k < n; ++k) {\\n            if (A[i] < A[k]) i = k;\\n            if (A[j] > A[k]) j = k;\\n        }\\n        return min({max(i + 1, j + 1), max(n - i, n - j), i + 1 + n - j, j + 1 + n - i});\\n    }\\n```\n```py\\n    def minimumDeletions(self, A):\\n        i, j, n = A.index(min(A)), A.index(max(A)), len(A)\\n        return min(max(i + 1, j + 1), max(n - i, n - j), i + 1 + n - j, j + 1 + n - i)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1601689,
                "title": "remove-from-left-right-or-both",
                "content": "If `i` and `j` are indexes of elements we want to remove (assuming `i <= j` for simplicity), we have three options: remove from left till `j`, remove from right till `i`, or from both sides.\\n\\nWe return the minimum of those options, depending on where those indexes are:\\n\\n![image](https://assets.leetcode.com/users/images/b41f285c-b7af-4d52-86ac-6755f97876a4_1638150537.971104.png)\\n\\n**C++**\\n```cpp\\nint minimumDeletions(vector<int>& n) {\\n    auto [it1, it2] = minmax_element(begin(n), end(n));\\n    int i = min(it1, it2) - begin(n), j = max(it1, it2) - begin(n);\\n    return min({ j + 1, (int)n.size() - i, i + 1 + (int)n.size() - j });\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minimumDeletions(vector<int>& n) {\\n    auto [it1, it2] = minmax_element(begin(n), end(n));\\n    int i = min(it1, it2) - begin(n), j = max(it1, it2) - begin(n);\\n    return min({ j + 1, (int)n.size() - i, i + 1 + (int)n.size() - j });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1599835,
                "title": "c-simple-solution-w-explanation-return-minimum-of-3-possible-cases",
                "content": "\\u2714\\uFE0F ***Solution***\\n\\nWe first find indices of min and max element.\\nThen we have 3 possible cases -\\n1. We can delete both indices starting from the start of array.\\n2. We can delete both indices starting from the end of array.\\n3. We can delete one index starting from start of array and one index starting from end of array. \\n\\nWe choose the case which requires minimum moves.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& A) {\\n        auto [it1, it2] = minmax_element(begin(A), end(A));\\n        int mini = it1 - begin(A), maxi = it2 - begin(A), n = size(A);\\n        return min({1+max(mini, maxi), n-min(mini, maxi), 1+min(mini, maxi) + (n-max(mini, maxi))});\\n    }\\n};\\n```\\n\\n***Time Complexity :*** `O(N)`\\n***Space Complexity :*** `O(1)`",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& A) {\\n        auto [it1, it2] = minmax_element(begin(A), end(A));\\n        int mini = it1 - begin(A), maxi = it2 - begin(A), n = size(A);\\n        return min({1+max(mini, maxi), n-min(mini, maxi), 1+min(mini, maxi) + (n-max(mini, maxi))});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607875,
                "title": "short-and-simple-c-solution",
                "content": "There are 3 possible cases:\\n1. Delete both min and max element from left.\\n2. Delete both from right\\n3. Delete one from left and other from right.\\n\\n**Steps :**\\n* We will store index of min and max element in i and j variable (where j always points to the greater index). \\n* For case 1: no of elements to be deleted = j+1\\n* For case 2: no of elements to be deleted = n - i\\n* For case 3: no of elements to be deleted = (i+1) + (n-j)\\n* Return min of above 3 cases\\n\\n```\\nint minimumDeletions(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = min_element(nums.begin() , nums.end()) - nums.begin();\\n        int j = max_element(nums.begin() , nums.end()) - nums.begin();\\n        \\n\\t\\t//to make sure j points to greater index\\n        if(i>j) swap(i,j);\\n        \\n        return min(j+1 , min(n-i , i+1+n-j));\\n    }\\n```\\n\\nTime Complexity: O(n) , to find index of min and max element\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimumDeletions(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = min_element(nums.begin() , nums.end()) - nums.begin();\\n        int j = max_element(nums.begin() , nums.end()) - nums.begin();\\n        \\n\\t\\t//to make sure j points to greater index\\n        if(i>j) swap(i,j);\\n        \\n        return min(j+1 , min(n-i , i+1+n-j));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1599796,
                "title": "python-4-cases-readable",
                "content": "**Explanation:**\\n\\nThere are only 4 cases to consider.\\n\\n* **Case 1:** [**1,10000**,5,6,7,8,9,2] - It\\'s optimal to grab both from the front.\\n\\n* **Case 2:** [2,3,4,5,6,7,**10000,1**] - It\\'s optimal to grab both from the back.\\n\\n* **Case 3:** [2,3,**10000**,5,6,7,4,**1**] - It\\'s optimal to grab the max from the front and min from back.\\n\\n* **Case 4:** [2,3,**1**,5,6,7,4,**10000**] - It\\'s optimal to grab the min from the front and max from back.\\n\\nConsider them all and take the minimum.\\n\\n---\\n\\n**Code:**\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        minFromFront = nums.index(min(nums))\\n        maxFromFront = nums.index(max(nums))\\n        \\n        minFromBack = len(nums) - minFromFront - 1\\n        maxFromBack = len(nums) - maxFromFront - 1 \\n        \\n        return min(max(minFromFront, maxFromFront) + 1,  # Case 1\\n                   max(minFromBack, maxFromBack) + 1,    # Case 2\\n                   minFromBack + maxFromFront + 2,       # Case 3 \\n                   minFromFront + maxFromBack + 2)       # Case 4\\n```\\n\\n---\\n\\n**Time Complexity:** O(N)\\n**Space Complexity:** O(1)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        minFromFront = nums.index(min(nums))\\n        maxFromFront = nums.index(max(nums))\\n        \\n        minFromBack = len(nums) - minFromFront - 1\\n        maxFromBack = len(nums) - maxFromFront - 1 \\n        \\n        return min(max(minFromFront, maxFromFront) + 1,  # Case 1\\n                   max(minFromBack, maxFromBack) + 1,    # Case 2\\n                   minFromBack + maxFromFront + 2,       # Case 3 \\n                   minFromFront + maxFromBack + 2)       # Case 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600076,
                "title": "intuition-explained-with-visualization-easy-simple-and-clean-code",
                "content": "-----------------------------------------------\\n# **Approach :**\\n-----------------------------------------------\\n* **Intuition :**\\n\\n\\t* Basically there are 3 possible cases we can have for deletion of min and max element:\\n\\n\\t\\t1.   Delete minimum element from **starting** and maximum from **ending**.\\n\\t\\t2.   Delete both min and max element from **starting**.\\n\\t\\t3.   Delete both min and max element from **ending**.\\n\\n\\t* We need to return the minimum of values that we get from the above cases.\\n\\t* Let us see how these cases look like : \\t\\t\\t\\n\\n\\t\\t\\t\\t\\t\\t   (i)             (j)\\n\\t\\t\\t [ _ _ _ _ _ min _ _ _ _ _ _ max _ _ _ _ _ _ ] \\n\\t\\t\\t   <-- a -->      <-- b -->       <-- c -->\\n\\t\\t\\t  <------------------- n ------------------->\\n\\t\\t\\t Here, \\n\\t\\t\\t -> a : distance of minimum element from starting\\n\\t\\t\\t -> b : distance between minimum and maximum element \\n\\t\\t\\t -> c : distance between maximum element from ending\\n\\t\\t\\t -> n : length of array\\n\\n\\t\\t\\t Now lets look at different cases that we thought of,\\n\\n\\t\\t\\t Case 1 : No. of deletion = (a + c) = ((i+1) + (n-j)),\\n\\t\\t\\t Case 2 : No. of deletion = (a + b) = (j+1)\\n\\t\\t\\t Case 3 : No. of deletion = (b + c) = (n - i)\\n\\n\\t* Using above equations we can now easily get distances using index of min and max element.\\n\\t* Answer is minimum of these 3 cases\\n\\t\\t\\nNote : Assume that minimum element always occur before maximum element. If not, then swap its index.\\n\\n-----------------------------------------------\\n\\n* **Code :**\\n\\n\\t```\\n\\tint minimumDeletions(vector<int>& nums) {\\n\\n\\t\\tint minIdx = 0, maxIdx = 0;\\n\\t\\tint mx = INT_MIN, mn = INT_MAX;\\n\\t\\tint n = nums.size();\\n\\n\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\tif(nums[i] < mn) {\\n\\t\\t\\t\\tminIdx = i;\\n\\t\\t\\t\\tmn = nums[i];\\n\\t\\t\\t}\\n\\t\\t\\tif(nums[i] > mx) {\\n\\t\\t\\t\\tmaxIdx = i; \\n\\t\\t\\t\\tmx = nums[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// For simplicity, we always assume minIdx occur before maxIdx\\n\\t\\tif (maxIdx < minIdx) \\n\\t\\t\\tswap(maxIdx, minIdx);\\n\\n\\t\\treturn min({(n-maxIdx) + (minIdx+1),  maxIdx+1, n-minIdx});\\n\\t}\\n\\t```\\n-----------------------------------------------\\n* **Complexity :** \\n\\n\\t* Time : `O(N)`, to get min and max elements\\' index\\n\\t* Space : `O(1)`\\n-----------------------------------------------\\n***If you  find this solution helpful, do give it a like :)***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint minimumDeletions(vector<int>& nums) {\\n\\n\\t\\tint minIdx = 0, maxIdx = 0;\\n\\t\\tint mx = INT_MIN, mn = INT_MAX;\\n\\t\\tint n = nums.size();\\n\\n\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\tif(nums[i] < mn) {\\n\\t\\t\\t\\tminIdx = i;\\n\\t\\t\\t\\tmn = nums[i];\\n\\t\\t\\t}\\n\\t\\t\\tif(nums[i] > mx) {\\n\\t\\t\\t\\tmaxIdx = i; \\n\\t\\t\\t\\tmx = nums[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// For simplicity, we always assume minIdx occur before maxIdx\\n\\t\\tif (maxIdx < minIdx) \\n\\t\\t\\tswap(maxIdx, minIdx);\\n\\n\\t\\treturn min({(n-maxIdx) + (minIdx+1),  maxIdx+1, n-minIdx});\\n\\t}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1599907,
                "title": "c-easy-to-understand-o-n",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int minimumDeletions(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int mxi = 0, mni = 0;\\n        int mn = INT_MAX, mx = INT_MIN;\\n\\t\\t\\n\\t\\t//Finding minimum and maximum element\\n \\xA0 \\xA0 \\xA0 \\xA0for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, nums[i]);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0mx = max(mx, nums[i]);\\n        }\\n\\t\\t\\n\\t\\t//Storing indexes of minimum and maxumum element\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (nums[i] == mn)\\n                mni = i;\\n            if (nums[i] == mx)\\n                mxi = i;\\n        }\\n\\t\\t\\n\\t\\t//When removed from front only\\n        int f = max(mxi, mni) + 1;\\n\\t\\t\\n\\t\\t//When removed from back only\\n        int l = n - min(mni, mxi);\\n\\t\\t\\n\\t\\t//When removed from both front and back\\n        int fl = (min(mni, mxi) + 1) + (n - max(mni, mxi));\\n\\t\\t\\n        return min(min(f, l), fl);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minimumDeletions(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int mxi = 0, mni = 0;\\n        int mn = INT_MAX, mx = INT_MIN;\\n\\t\\t\\n\\t\\t//Finding minimum and maximum element\\n \\xA0 \\xA0 \\xA0 \\xA0for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, nums[i]);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0mx = max(mx, nums[i]);\\n        }\\n\\t\\t\\n\\t\\t//Storing indexes of minimum and maxumum element\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (nums[i] == mn)\\n                mni = i;\\n            if (nums[i] == mx)\\n                mxi = i;\\n        }\\n\\t\\t\\n\\t\\t//When removed from front only\\n        int f = max(mxi, mni) + 1;\\n\\t\\t\\n\\t\\t//When removed from back only\\n        int l = n - min(mni, mxi);\\n\\t\\t\\n\\t\\t//When removed from both front and back\\n        int fl = (min(mni, mxi) + 1) + (n - max(mni, mxi));\\n\\t\\t\\n        return min(min(f, l), fl);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397134,
                "title": "c-simple-c-code",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 1;\\n        int mn = 0, mx = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[mn] > nums[i])\\n                mn = i;\\n            if(nums[mx] < nums[i])\\n                mx = i;\\n        }\\n        int a = min(mn,mx), b = max(mn,mx);\\n        return min({b+1,n-a,n+1+a-b});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return 1;\\n        int mn = 0, mx = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[mn] > nums[i])\\n                mn = i;\\n            if(nums[mx] < nums[i])\\n                mx = i;\\n        }\\n        int a = min(mn,mx), b = max(mn,mx);\\n        return min({b+1,n-a,n+1+a-b});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601233,
                "title": "very-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int minIndex = INT_MAX;\\n        int maxIndex = INT_MIN;\\n        int minele = INT_MAX;\\n        int maxele = INT_MIN;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            minele = min(minele,nums[i]);\\n            maxele = max(maxele,nums[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == minele) minIndex = i;\\n            if(nums[i] == maxele) maxIndex = i;\\n        }\\n        int x = minIndex;\\n        if(minIndex > maxIndex){\\n            minIndex = maxIndex;\\n            maxIndex = x;\\n        } \\n        int op1 = maxIndex+1;\\n        int op2 = (minIndex+1) + (n-maxIndex);\\n        int op3 = n-minIndex;\\n        int ans = min(op1,min(op2,op3));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int minIndex = INT_MAX;\\n        int maxIndex = INT_MIN;\\n        int minele = INT_MAX;\\n        int maxele = INT_MIN;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            minele = min(minele,nums[i]);\\n            maxele = max(maxele,nums[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i] == minele) minIndex = i;\\n            if(nums[i] == maxele) maxIndex = i;\\n        }\\n        int x = minIndex;\\n        if(minIndex > maxIndex){\\n            minIndex = maxIndex;\\n            maxIndex = x;\\n        } \\n        int op1 = maxIndex+1;\\n        int op2 = (minIndex+1) + (n-maxIndex);\\n        int op3 = n-minIndex;\\n        int ans = min(op1,min(op2,op3));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516000,
                "title": "explanation-with-pictures-simple-and-easy-to-understand-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI have attached the self explanatory explanation for the solution below:\\n\\n![solution.png](https://assets.leetcode.com/users/images/c5d56c9a-fba7-453a-ba96-551b86eaa82c_1683892364.997667.png)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n\\n        int minIdx = min_element(nums.begin(),nums.end())-nums.begin()\\n        int maxIdx = max_element(nums.begin(),nums.end())-nums.begin();\\n        \\n        int leftDiff = min(minIdx,maxIdx)+1;\\n        int rightDiff = nums.size()-max(minIdx,maxIdx);\\n        int middleDiff = abs(minIdx-maxIdx);\\n        \\n        return min({leftDiff+middleDiff,leftDiff+rightDiff,middleDiff+rightDiff});\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n\\n        int minIdx = min_element(nums.begin(),nums.end())-nums.begin()\\n        int maxIdx = max_element(nums.begin(),nums.end())-nums.begin();\\n        \\n        int leftDiff = min(minIdx,maxIdx)+1;\\n        int rightDiff = nums.size()-max(minIdx,maxIdx);\\n        int middleDiff = abs(minIdx-maxIdx);\\n        \\n        return min({leftDiff+middleDiff,leftDiff+rightDiff,middleDiff+rightDiff});\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599836,
                "title": "java-simple-and-intutive",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        int minInd = 0;\\n        int maxInd = 0;\\n        int n = nums.length;\\n        \\n        //First Find out the max and min element index\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n                maxInd = i;\\n            }\\n            \\n            if(nums[i]<min){\\n                min = nums[i];\\n                minInd = i;\\n            }\\n        }\\n        \\n        //if both index are same then return the part in which less number of elements are there\\n        if(maxInd==minInd){\\n            return Math.min(maxInd+1,n-maxInd);\\n        }\\n        \\n        //max element is right side of min element\\n        if(maxInd>minInd){\\n            int count = Math.min(maxInd+1,n-minInd); // min of all the elements till max element and all the elements to the right of min element\\n            int count1 = minInd+1+(n-maxInd); // all elements to the left of min and right of max\\n            return Math.min(count,count1); // min of both\\n        }\\n        // min element is right side of the max element\\n        else{\\n            int count = Math.min(minInd+1,n-maxInd);\\n            int count1 = maxInd+1+(n-minInd);\\n            return Math.min(count,count1);\\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        int minInd = 0;\\n        int maxInd = 0;\\n        int n = nums.length;\\n        \\n        //First Find out the max and min element index\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n                maxInd = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2543584,
                "title": "100-faster-simple-java-solution",
                "content": "#### Please upvote if it helped \\uD83D\\uDC4D\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        \\n        int n = nums.length;\\n        if(n==1) return 1;\\n        \\n        int minId = 0, maxId = 0;\\n\\t\\t\\n        // first find max & min element index        \\n        for(int i=0; i<n; i++){\\n            if(nums[i] > nums[maxId])\\n                maxId = i;\\n            if(nums[i] < nums[minId])\\n                minId = i;\\n        }\\n        \\n        int numOfDelFromLeft = Math.max(maxId, minId) + 1;\\n        int numOfDelFromRight = n - Math.min(maxId, minId);\\n        int numOfDelFromLeftAndRight = (Math.min(maxId, minId) + 1) + (n - Math.max(maxId, minId)) ;\\n        \\n        return Math.min(numOfDelFromLeftAndRight , ( Math.min(numOfDelFromLeft, numOfDelFromRight) ));\\n    }\\n}\\n```\\n\\n---\\nRuntime: 2 ms, faster than 100.00% of Java online submissions for Removing Minimum and Maximum From Array.\\nMemory Usage: 55.7 MB, less than 87.13% of Java online submissions for Removing Minimum and Maximum From Array.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        \\n        int n = nums.length;\\n        if(n==1) return 1;\\n        \\n        int minId = 0, maxId = 0;\\n\\t\\t\\n        // first find max & min element index        \\n        for(int i=0; i<n; i++){\\n            if(nums[i] > nums[maxId])\\n                maxId = i;\\n            if(nums[i] < nums[minId])\\n                minId = i;\\n        }\\n        \\n        int numOfDelFromLeft = Math.max(maxId, minId) + 1;\\n        int numOfDelFromRight = n - Math.min(maxId, minId);\\n        int numOfDelFromLeftAndRight = (Math.min(maxId, minId) + 1) + (n - Math.max(maxId, minId)) ;\\n        \\n        return Math.min(numOfDelFromLeftAndRight , ( Math.min(numOfDelFromLeft, numOfDelFromRight) ));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199871,
                "title": "2091-removing-minimum-and-maximum-from-array",
                "content": "**Basic Implementation also u can use sliding window type  algo**\\n* Basically * we have to take three cases **\\n* Traversing from  begining of the array and max of there indexs will be answer*\\n*  Traversing from  end  of the array and max of there n -  indexs will be answer**\\n*  Checking from both begining and end of both indexs(minimum) and taking there sum is the answer\\n Now see the code if not getting clearly\\n```\\n int minimumDeletions(vector<int>& arr) {\\n        int maxi=*max_element(arr.begin(),arr.end());\\n            int mini=*min_element(arr.begin(),arr.end());\\n        int mx,mn;\\n        int n=arr.size();\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==maxi)mx=i;\\n            if(arr[i]==mini)mn=i;\\n        }\\n        int ans;\\n        int op1=0,op2=0,op3=0;\\n        op1=max(mx,mn)+1;\\n        op2=max(n-mx,n-mn);\\n        op3=min(mx+1,n-mx)+min(mn+1,n-mn);\\n        //cout<<op1<<\" \"<<op2<<\" \"<<op3<<endl;\\n        return min({op1,op2,op3});\\n    }\\n\\t```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n int minimumDeletions(vector<int>& arr) {\\n        int maxi=*max_element(arr.begin(),arr.end());\\n            int mini=*min_element(arr.begin(),arr.end());\\n        int mx,mn;\\n        int n=arr.size();\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==maxi)mx=i;\\n            if(arr[i]==mini)mn=i;\\n        }\\n        int ans;\\n        int op1=0,op2=0,op3=0;\\n        op1=max(mx,mn)+1;\\n        op2=max(n-mx,n-mn);\\n        op3=min(mx+1,n-mx)+min(mn+1,n-mn);\\n        //cout<<op1<<\" \"<<op2<<\" \"<<op3<<endl;\\n        return min({op1,op2,op3});\\n    }\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 1607640,
                "title": "java",
                "content": "There are only three ways to delete min val and max val:\\n1. Delete from left to right\\n2. Delete from right to left\\n3. Delete from left and right\\n\\nThe solution is to check all these 3 ways and choose the minimum result\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(int[] arr) {\\n        int min = 0;\\n        int max = 0;\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] < arr[min]) min = i;\\n            if (arr[i] > arr[max]) max = i;\\n        }\\n        \\n        int ans = Math.max(min, max) + 1; // delete from left to right\\n        ans = Math.min(ans, Math.max(arr.length - min, arr.length - max)); // from right to the left\\n        \\n\\t\\t// looking for boundaries\\n        int left  = Math.min(min, max);  \\n        int right = Math.max(min, max);\\n        \\n        ans = Math.min(ans, left + 1 + arr.length - right); // delete from left and right\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(int[] arr) {\\n        int min = 0;\\n        int max = 0;\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] < arr[min]) min = i;\\n            if (arr[i] > arr[max]) max = i;\\n        }\\n        \\n        int ans = Math.max(min, max) + 1; // delete from left to right\\n        ans = Math.min(ans, Math.max(arr.length - min, arr.length - max)); // from right to the left\\n        \\n\\t\\t// looking for boundaries\\n        int left  = Math.min(min, max);  \\n        int right = Math.max(min, max);\\n        \\n        ans = Math.min(ans, left + 1 + arr.length - right); // delete from left and right\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599862,
                "title": "python3-3-candidates",
                "content": "Pleaes check out this [commit](https://github.com/gaosanyong/leetcode/commit/b3dd8d234940d5e4afc6a22cc8fc1f4a2e69dd3d) for solutions of weekly 269.\\n```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        imin = nums.index(min(nums))\\n        imax = nums.index(max(nums))\\n        return min(max(imin, imax)+1, len(nums)-min(imin, imax), len(nums)+1+min(imin, imax)-max(imin, imax))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        imin = nums.index(min(nums))\\n        imax = nums.index(max(nums))\\n        return min(max(imin, imax)+1, len(nums)-min(imin, imax), len(nums)+1+min(imin, imax)-max(imin, imax))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731552,
                "title": "one-liner-and-easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        return min((min(nums.index(min(nums))+1,len(nums)-nums.index(min(nums)))+min(nums.index(max(nums))+1,len(nums)-nums.index(max(nums)))),max(nums.index(min(nums))+1,nums.index(max(nums))+1),max(len(nums)-nums.index(min(nums)),len(nums)-nums.index(max(nums))))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        return min((min(nums.index(min(nums))+1,len(nums)-nums.index(min(nums)))+min(nums.index(max(nums))+1,len(nums)-nums.index(max(nums)))),max(nums.index(min(nums))+1,nums.index(max(nums))+1),max(len(nums)-nums.index(min(nums)),len(nums)-nums.index(max(nums))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970943,
                "title": "q2091-accepted-c-easy-simple-explained",
                "content": "CRUX \\nThere are \\'3\\' possible outcomes of min and mac index\\n1)Both are towards the Left side of the vector [0,-4,19,1,8,-2,-3,5]\\n2)Both are towards the Right side of the vector [0,1,8,-2,-3,5,-4,19]\\n3)One lies in the left half and other lies in the right half [2,10,7,5,4,1,8,6]\\nFor Left and Right 1 & 2 Its Simple :\\n```\\n(maxIdx<=n/2 && minIdx<=n/2)\\n\\t   return max(minIdx,maxIdx)+1;\\n(maxIdx>n/2 && minIdx>n/2)\\n\\t\\treturn n-min(minIdx,maxIdx);\\n```\\nFor 3)\\n```\\nreturn min(minIdx,maxIdx)+n-max(minIdx,maxIdx)+1\\n```\\nReturn the Min of any of the three.\\nThus the Final Sol looks like this down \\uD83D\\uDC47\\uD83C\\uDFFB\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n=nums.size();\\n        int minIdx=min_element(nums.begin(),nums.end())-nums.begin();\\n        int maxIdx=max_element(nums.begin(),nums.end())-nums.begin();\\n        //3 Cases\\n        return min(max(minIdx,maxIdx)+1,\\n                    min(n-min(minIdx,maxIdx), \\n                    min(minIdx,maxIdx)+1+n-max(minIdx,maxIdx)));\\n    }\\n};\\n```\\nPLEASE UPVOTE",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n(maxIdx<=n/2 && minIdx<=n/2)\\n\\t   return max(minIdx,maxIdx)+1;\\n(maxIdx>n/2 && minIdx>n/2)\\n\\t\\treturn n-min(minIdx,maxIdx);\\n```\n```\\nreturn min(minIdx,maxIdx)+n-max(minIdx,maxIdx)+1\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n=nums.size();\\n        int minIdx=min_element(nums.begin(),nums.end())-nums.begin();\\n        int maxIdx=max_element(nums.begin(),nums.end())-nums.begin();\\n        //3 Cases\\n        return min(max(minIdx,maxIdx)+1,\\n                    min(n-min(minIdx,maxIdx), \\n                    min(minIdx,maxIdx)+1+n-max(minIdx,maxIdx)));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880132,
                "title": "best-easy-solution-with-explanation",
                "content": "- see both Methods\\n- to understand the problems solution properly\\n- \\n- both are same only if you see properly\\n- but method 2 more nice than method 1\\n    - (Method 1) (to understand concept/Approach)\\n    - (Method 2) is best (as solution)\\n\\n\\n# (Method 1)\\n- to understand concept/Approach\\n```java\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int max_index = 0;\\n        int min_index = 0;\\n        int n = nums.length;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] > nums[max_index])\\n                max_index = i;\\n\\n            if (nums[i] < nums[min_index])\\n                min_index = i;\\n        }\\n        // 3 cases\\n        // - both delete from left\\n        // - both delete from right\\n        // - right and left together\\n\\n        // delete from left side\\n        int rightmost = Math.max(max_index, min_index);\\n        int del_from_left = rightmost + 1;\\n\\n        // delete from right side\\n        int leftmost = Math.min(max_index, min_index);\\n        int del_from_right = n - leftmost;\\n\\n        // from both sides\\n        int del_from_both = (n - rightmost) + (leftmost + 1);\\n\\n        // return which is the min distance out of 3 cases\\n        return Math.min(\\n                Math.min(del_from_left, del_from_right),\\n                del_from_both);\\n    }\\n}\\n```\\n\\n# (Method 2)\\n```java\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        // no need of max/min value,\\n        // directly store the min/max index of element\\n        int max_index = 0;\\n        int min_index = 0;\\n        int n = nums.length; // since needed multiple time\\n\\n        // finding the min/max index in the unsorted nums\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] > nums[max_index])\\n                max_index = i;\\n\\n            if (nums[i] < nums[min_index])\\n                min_index = i;\\n        }\\n\\n        // in case if min_value_index comes after the max_value_index\\n        // why swap? : so that caluculate become easy no multiple equations\\n        // why? : so that leftmost index is store in min_index only\\n        // viseversa ... saves memeory and time\\n        if (min_index > max_index) {\\n            int temp = min_index;\\n            min_index = max_index;\\n            max_index = temp;\\n        }\\n\\n        // int del_from_left = max_index + 1;\\n        // int del_from_right = n - min_index;\\n        // int del_from_both = (n - max_index) + (min_index + 1);\\n\\n        // return which is the min distance out of 3 cases\\n        return Math.min(\\n                Math.min(\\n                        max_index + 1, // del_from_left\\n                        n - min_index // del_from_right\\n                ),\\n                (n - max_index) + (min_index + 1) // del_from_both\\n        );\\n    }\\n}\\n```\\n\\n.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sort",
                    "Sorting"
                ],
                "code": "```java\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int max_index = 0;\\n        int min_index = 0;\\n        int n = nums.length;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] > nums[max_index])\\n                max_index = i;\\n\\n            if (nums[i] < nums[min_index])\\n                min_index = i;\\n        }\\n        // 3 cases\\n        // - both delete from left\\n        // - both delete from right\\n        // - right and left together\\n\\n        // delete from left side\\n        int rightmost = Math.max(max_index, min_index);\\n        int del_from_left = rightmost + 1;\\n\\n        // delete from right side\\n        int leftmost = Math.min(max_index, min_index);\\n        int del_from_right = n - leftmost;\\n\\n        // from both sides\\n        int del_from_both = (n - rightmost) + (leftmost + 1);\\n\\n        // return which is the min distance out of 3 cases\\n        return Math.min(\\n                Math.min(del_from_left, del_from_right),\\n                del_from_both);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        // no need of max/min value,\\n        // directly store the min/max index of element\\n        int max_index = 0;\\n        int min_index = 0;\\n        int n = nums.length; // since needed multiple time\\n\\n        // finding the min/max index in the unsorted nums\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] > nums[max_index])\\n                max_index = i;\\n\\n            if (nums[i] < nums[min_index])\\n                min_index = i;\\n        }\\n\\n        // in case if min_value_index comes after the max_value_index\\n        // why swap? : so that caluculate become easy no multiple equations\\n        // why? : so that leftmost index is store in min_index only\\n        // viseversa ... saves memeory and time\\n        if (min_index > max_index) {\\n            int temp = min_index;\\n            min_index = max_index;\\n            max_index = temp;\\n        }\\n\\n        // int del_from_left = max_index + 1;\\n        // int del_from_right = n - min_index;\\n        // int del_from_both = (n - max_index) + (min_index + 1);\\n\\n        // return which is the min distance out of 3 cases\\n        return Math.min(\\n                Math.min(\\n                        max_index + 1, // del_from_left\\n                        n - min_index // del_from_right\\n                ),\\n                (n - max_index) + (min_index + 1) // del_from_both\\n        );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208396,
                "title": "c-with-explanation-and-comments-3-cases-intuitive",
                "content": "**Thoughts**\\nFirst calculate the indexes of both minimum and maximum elements, say `i` and `j`. Make sure that `i <= j`. Now there arises three cases - \\n\\n- Remove elements from both sides -> `n-(j-i+1)+2`\\n- Remove elements only from left side -> `n-i`\\n- Remove elements only from right side. -> `j+1`\\n\\n**Why +2 when removing elements from both sides?**\\nn - (j-i+1) will give us all the elements from both sides other than the minimum and maximum element. So just add 2 to get those as well.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return 1;\\n        \\n        auto minMax = minmax_element(nums.begin(), nums.end());\\n        \\n        int i = minMax.first - nums.begin();\\n        int j = minMax.second - nums.begin();\\n        \\n\\t\\t// Making sure i <= j\\n        if (i > j) swap(i, j);\\n\\t\\t\\n        return min({n-(j-i+1)+2, n-i, j+1});\\n    }\\n};\\n```\\n\\n**Please Upvote, if found useful :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return 1;\\n        \\n        auto minMax = minmax_element(nums.begin(), nums.end());\\n        \\n        int i = minMax.first - nums.begin();\\n        int j = minMax.second - nums.begin();\\n        \\n\\t\\t// Making sure i <= j\\n        if (i > j) swap(i, j);\\n\\t\\t\\n        return min({n-(j-i+1)+2, n-i, j+1});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800650,
                "title": "c-easy-to-understand-99-fastest-of-all-c-solutions",
                "content": "```\\nint s=nums.size(); \\nint mn,mx;     // variables to find minimum and maximum index.\\nint t=nums[0];\\n     for(int i=0;i<s;i++)\\n            if(nums[i]>=t)\\n                t=nums[i], mx=i;  //finding maximum index.\\n        for(int i=0;i<s;i++)\\n            if(nums[i]<=t)\\n                t=nums[i],mn=i;  //finding minimum index.\\n        int ans=0;\\n         int a=max(mn,mx)+1; //deletion from front.\\n     int b=min(mx,mn)+1+(s-max(mx,mn)); //deletion from front & back.\\n         int c=s-min(mx,mn); //deletion from back.\\n        ans=min(a,b);   // finding minimum no. of deletions.\\n        ans=min(ans,c);\\n        if(s==1) // If size of nums array is only 1.\\n            return 1;\\n        return ans;\\n\\t\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint s=nums.size(); \\nint mn,mx;     // variables to find minimum and maximum index.\\nint t=nums[0];\\n     for(int i=0;i<s;i++)\\n            if(nums[i]>=t)\\n                t=nums[i], mx=i;  //finding maximum index.\\n        for(int i=0;i<s;i++)\\n            if(nums[i]<=t)\\n                t=nums[i],mn=i;  //finding minimum index.\\n        int ans=0;\\n         int a=max(mn,mx)+1; //deletion from front.\\n     int b=min(mx,mn)+1+(s-max(mx,mn)); //deletion from front & back.\\n         int c=s-min(mx,mn); //deletion from back.\\n        ans=min(a,b);   // finding minimum no. of deletions.\\n        ans=min(ans,c);\\n        if(s==1) // If size of nums array is only 1.\\n            return 1;\\n        return ans;\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1663785,
                "title": "c-easy-solution-o-n-with-explanation",
                "content": "Find **index** of **minium** and **maximum element** in the array.\\n**Return minimun** from **number of operation to remove first element and then second element** and **number of operation to remove second element and then first element**.\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        \\n        int indmin, indmax, mini(INT_MAX), maxi(INT_MIN), n(nums.size());\\n        \\n        for (int i=0; i<n; i++)\\n        {\\n            if (maxi < nums[i]) maxi = nums[i], indmax = i;\\n            if (mini > nums[i]) mini = nums[i], indmin = i;\\n        }\\n        \\n        int before(min(indmin, indmax)), after(max(indmin, indmax));\\n        return min(before+1 + min(n-after, after-before), n-after + min(before+1, after-before));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        \\n        int indmin, indmax, mini(INT_MAX), maxi(INT_MIN), n(nums.size());\\n        \\n        for (int i=0; i<n; i++)\\n        {\\n            if (maxi < nums[i]) maxi = nums[i], indmax = i;\\n            if (mini > nums[i]) mini = nums[i], indmin = i;\\n        }\\n        \\n        int before(min(indmin, indmax)), after(max(indmin, indmax));\\n        return min(before+1 + min(n-after, after-before), n-after + min(before+1, after-before));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844009,
                "title": "99-98-beats-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n\\n# Approach\\nGreedy \\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int maxind = 0;\\n        int minind = 0;\\n\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i] > nums[maxind])maxind=i;\\n            if(nums[i] < nums[minind])minind=i;\\n        }\\n        int i=0;\\n        while(i<min(minind,maxind)){\\n            i++;\\n        }\\n        int j=n-1;\\n        while(j>max(minind,maxind)){\\n            j--;\\n        }\\n        int leftele  = max(maxind,minind)+1;\\n        int rightele = n-min(minind,maxind);\\n        int midele = min(minind,maxind)+1+(n-max(minind,maxind));\\n\\n        return min(leftele,min(rightele,midele));\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int maxind = 0;\\n        int minind = 0;\\n\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i] > nums[maxind])maxind=i;\\n            if(nums[i] < nums[minind])minind=i;\\n        }\\n        int i=0;\\n        while(i<min(minind,maxind)){\\n            i++;\\n        }\\n        int j=n-1;\\n        while(j>max(minind,maxind)){\\n            j--;\\n        }\\n        int leftele  = max(maxind,minind)+1;\\n        int rightele = n-min(minind,maxind);\\n        int midele = min(minind,maxind)+1+(n-max(minind,maxind));\\n\\n        return min(leftele,min(rightele,midele));\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443205,
                "title": "c-solution-with-explaination-four-valid-case-possible",
                "content": "\\n\\n    class Solution {\\n    public:\\n    int minimumDeletions(vector<int>& nums) {\\n        // Finding index of min and max element\\n        int maxi=INT_MIN,mini=INT_MAX,a=0,b=0,n=nums.size(),ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(maxi<nums[i]){\\n                maxi=nums[i];\\n                a=i;\\n            }\\n            if(mini>nums[i]){\\n                mini=nums[i];\\n                b=i;\\n            }\\n        }\\n        a++; // index of max element from begin\\n        b++; // index of min elemnt from begin\\n        int la=n-a+1; // index of max element from last\\n        int lb=n-b+1; // index of min element from last\\n        // case 1 : from begin,deleting both element\\n        ans=min(ans,max(a,b));\\n        // case 2 : from last,deleting both element\\n        ans=min(ans,max(la,lb));\\n        // case 3 : deleting min from begin and max from last\\n        ans=min(ans,b+la);\\n        // case 4 : deleting max from begin and min from last\\n        ans=min(ans,a+lb);\\n        return ans;\\n       }\\n    };",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n    int minimumDeletions(vector<int>& nums) {\\n        // Finding index of min and max element\\n        int maxi=INT_MIN,mini=INT_MAX,a=0,b=0,n=nums.size(),ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(maxi<nums[i]){\\n                maxi=nums[i];\\n                a=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3259425,
                "title": "time-o-n-space-o-1-c-remove-from-left-right-or-both",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int mx = INT_MIN,mn = INT_MAX,mni,mxi,i,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            if(nums[i]<mn){\\n                mn = nums[i];\\n                mni = i;\\n            }\\n            if(nums[i]>mx){\\n                mx = nums[i];\\n                mxi = i;\\n            }\\n        }\\n        if(mni<mxi){\\n            swap(mni,mxi);\\n        }\\n        return min({mxi+1+n-mni,n-mxi,mni+1});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int mx = INT_MIN,mn = INT_MAX,mni,mxi,i,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            if(nums[i]<mn){\\n                mn = nums[i];\\n                mni = i;\\n            }\\n            if(nums[i]>mx){\\n                mx = nums[i];\\n                mxi = i;\\n            }\\n        }\\n        if(mni<mxi){\\n            swap(mni,mxi);\\n        }\\n        return min({mxi+1+n-mni,n-mxi,mni+1});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778054,
                "title": "c-simple-approach-observation",
                "content": "```\\nint minimumDeletions(vector<int>& nums) {\\n        \\n        int maxi = *max_element(nums.begin(),nums.end());\\n        int mini = *min_element(nums.begin(),nums.end());\\n        int i1=-1, i2=-1;\\n        for(int i=0;i<nums.size();i++) {\\n            if(nums[i]==maxi) i1=i;\\n            if(nums[i]==mini) i2=i;\\n        }\\n\\t\\t//when all deleted from front\\n        int a = max(i1,i2) + 1;\\n\\t\\t//when all deleted from back\\n        int b = nums.size() - min(i1,i2);\\n\\t\\t//when deleted from both the front and the back \\n        int c = (min(i1,i2)) + (nums.size()+1-max(i1,i2));\\n        int ans = min(a,min(b,c));\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimumDeletions(vector<int>& nums) {\\n        \\n        int maxi = *max_element(nums.begin(),nums.end());\\n        int mini = *min_element(nums.begin(),nums.end());\\n        int i1=-1, i2=-1;\\n        for(int i=0;i<nums.size();i++) {\\n            if(nums[i]==maxi) i1=i;\\n            if(nums[i]==mini) i2=i;\\n        }\\n\\t\\t//when all deleted from front\\n        int a = max(i1,i2) + 1;\\n\\t\\t//when all deleted from back\\n        int b = nums.size() - min(i1,i2);\\n\\t\\t//when deleted from both the front and the back \\n        int c = (min(i1,i2)) + (nums.size()+1-max(i1,i2));\\n        int ans = min(a,min(b,c));\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2201682,
                "title": "basic-python-solution",
                "content": "simply find the minimum of the two options available. first option is going one way to the larger index and deleting the smaller along the way (consider this from both sides). second option is going from left for the smaller index and going from right for the larger index.\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        x = nums.index(min(nums)) + 1\\n        y = nums.index(max(nums)) + 1\\n        \\n        res = min(max(n-x+1, n-y+1) , max(x,y))       #minimum of going from right and going from left\\n        if x > y:  #exchange if needed so as to do one operation later assuming x is the smaller index\\n            x, y = y, x\\n        \\n        option = x + (n - y) + 1 #going left for smaller and right for larger\\n        res = min(res, option)\\n        \\n        return res if n > 2 else n\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        x = nums.index(min(nums)) + 1\\n        y = nums.index(max(nums)) + 1\\n        \\n        res = min(max(n-x+1, n-y+1) , max(x,y))       #minimum of going from right and going from left\\n        if x > y:  #exchange if needed so as to do one operation later assuming x is the smaller index\\n            x, y = y, x\\n        \\n        option = x + (n - y) + 1 #going left for smaller and right for larger\\n        res = min(res, option)\\n        \\n        return res if n > 2 else n\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889949,
                "title": "100-beats-15-lines-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly if we think greedily we can see that there is only three possible ways to get the answer. \\n1. Delete only from the front side\\n2. Delete from the back side only.\\n3. Delete one element from front and one front from back,which one is deleted from front side-the max element or the minimum element will depent which comes first. \\n               This will be minimum of min_idx(index of minimum element) and max_idx(index of maximum element).\\n     Similary,which one to be deleted from back side will be the one that comes first from the back side that is minimum of (n-index of minimum element) and max_idx(n-index of maximum element) , where n is length of vector.\\n\\n\\n---\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the index of minimum element.\\n2. Find the index of maximum element.\\n3. Store min(idx_min+1,index_max+1)------plus one is for just total count\\n4. Store min(n-idx_min,n-index_max)------>plus one is for just total count\\n5. Store min(idx_min+1,index_max+1) + min(n-idx_min,n-index_max);\\n6. Return minimum of third, fourth and fifth point.\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        0(N)-----> for traversal \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(1)-----> no data structure used for storage\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n\\n// finding index of minimum amd maximum element\\n        int idx_max=-1;\\n        int idx_min=-1;\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<mini){\\n                mini = nums[i];\\n                idx_min = i;\\n            }\\n\\n             if(nums[i]>maxi){\\n                maxi = nums[i];\\n                idx_max = i;\\n            }\\n        }\\n// Three posibilties of answer\\n       int num1 = max(idx_min+1,idx_max+1);// from front deletion only\\n       int num2 = max(n-idx_min,n-idx_max);// from back deletion only\\n       int num3 = min(idx_min+1,idx_max+1)+ min(n-idx_min,n-idx_max);  // from front and back deletion both\\n\\n---\\n\\n\\n//minimum of all three possibilties\\n       return min(min(num1,num2),num3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n\\n// finding index of minimum amd maximum element\\n        int idx_max=-1;\\n        int idx_min=-1;\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<mini){\\n                mini = nums[i];\\n                idx_min = i;\\n            }\\n\\n             if(nums[i]>maxi){\\n                maxi = nums[i];\\n                idx_max = i;\\n            }\\n        }\\n// Three posibilties of answer\\n       int num1 = max(idx_min+1,idx_max+1);// from front deletion only\\n       int num2 = max(n-idx_min,n-idx_max);// from back deletion only\\n       int num3 = min(idx_min+1,idx_max+1)+ min(n-idx_min,n-idx_max);  // from front and back deletion both\\n\\n---\\n\\n\\n//minimum of all three possibilties\\n       return min(min(num1,num2),num3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845261,
                "title": "python-3-remove-from-left-right-both-sides-beats-99-766ms",
                "content": "```python3 []\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        minp, maxp, minel, maxel, L = 0, 0, float(\\'inf\\'), float(\\'-inf\\'), len(nums)\\n        for i, n in enumerate(nums):\\n            if n > maxel:\\n                maxel = n\\n                maxp = i\\n            if n < minel:\\n                minel = n\\n                minp = i\\n        \\n        left, right = min(minp, maxp), max(minp, maxp)\\n\\n        return min(right + 1, L - left, left + 1 + (L - right))\\n```\\n![Screenshot 2023-08-01 at 03.35.12.png](https://assets.leetcode.com/users/images/f3739c71-bc19-48aa-8d37-e878b2884d1e_1690850133.0411804.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        minp, maxp, minel, maxel, L = 0, 0, float(\\'inf\\'), float(\\'-inf\\'), len(nums)\\n        for i, n in enumerate(nums):\\n            if n > maxel:\\n                maxel = n\\n                maxp = i\\n            if n < minel:\\n                minel = n\\n                minp = i\\n        \\n        left, right = min(minp, maxp), max(minp, maxp)\\n\\n        return min(right + 1, L - left, left + 1 + (L - right))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744757,
                "title": "best-python3-code-beats-up-to-93",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBest easy to understand code of python\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n![Screenshot from 2023-07-10 14-53-18.png](https://assets.leetcode.com/users/images/ffe51283-a87a-47d0-b421-b180c300c0d0_1688982827.2243848.png)\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        maximum = nums.index(max(nums))\\n        minimum = nums.index(min(nums))\\n        if maximum > minimum:\\n            middle_list = nums[minimum+1:maximum]\\n        else:\\n            middle_list = nums[maximum+1:minimum]\\n        if maximum < minimum:\\n            addition = minimum+1\\n        else:\\n            addition = maximum+1\\n        if maximum < minimum:\\n            subtracting = len(nums)-maximum\\n        else:\\n            subtracting = len(nums)-minimum\\n        return(min(subtracting,addition,len(nums)-len(middle_list)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        maximum = nums.index(max(nums))\\n        minimum = nums.index(min(nums))\\n        if maximum > minimum:\\n            middle_list = nums[minimum+1:maximum]\\n        else:\\n            middle_list = nums[maximum+1:minimum]\\n        if maximum < minimum:\\n            addition = minimum+1\\n        else:\\n            addition = maximum+1\\n        if maximum < minimum:\\n            subtracting = len(nums)-maximum\\n        else:\\n            subtracting = len(nums)-minimum\\n        return(min(subtracting,addition,len(nums)-len(middle_list)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734536,
                "title": "python3-solution-easy-to-under-stand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, a: List[int]) -> int:\\n#        a=[2,10,7,5,4,1,8,6]\\n        b=a.index(max(a))\\n        c=a.index(min(a))\\n        if b>c:\\n            d=a[c+1:b]\\n        else:\\n            d=a[b+1:c]\\n        print(d)\\n        if b>c:\\n            y=b+1\\n        else:\\n            y=c+1\\n        print(y)\\n        if b>c:\\n            u=len(a)-c\\n        else:\\n            u=len(a)-b\\n        print(u)\\n        return(min(u,y,len(a)-len(d)))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, a: List[int]) -> int:\\n#        a=[2,10,7,5,4,1,8,6]\\n        b=a.index(max(a))\\n        c=a.index(min(a))\\n        if b>c:\\n            d=a[c+1:b]\\n        else:\\n            d=a[b+1:c]\\n        print(d)\\n        if b>c:\\n            y=b+1\\n        else:\\n            y=c+1\\n        print(y)\\n        if b>c:\\n            u=len(a)-c\\n        else:\\n            u=len(a)-b\\n        print(u)\\n        return(min(u,y,len(a)-len(d)))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574597,
                "title": "easy-solution-for-beginners-to-understand",
                "content": "# About the problem:\\n*Return the minimum number of deletions it would take to remove both the minimum and maximum element from the array.*\\n\\n# Approach:\\n1. Declare a variable` len` and assign the array\\'s length to it.\\n2. Find the index of the minimum element in the array using `.indexOf()` method and `Math.min()` method.\\n3. Similarly, to find the index of the maximum element in the array, we use the `.indedxOf()` and `Math.max()` method.\\n4. We go on to check whether the index of the min element is greater than max index or not. If yes then we swap the position.\\n5. we then assign the respective values to the 3 methods of deletion and find the min of them using Math.min function.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumDeletions = function(nums) {\\n    const len=nums.length;\\n    let minIndex=nums.indexOf(Math.min(...nums));//find index of min ele in array\\n    let maxIndex=nums.indexOf(Math.max(...nums));//find index of max ele in array\\n    if(minIndex>maxIndex)[minIndex,maxIndex]=[maxIndex,minIndex];\\n    let bothremove = (len - maxIndex)+(minIndex + 1);\\n    let rightremove = (len - minIndex);\\n    let leftremove = (maxIndex + 1);\\n    return Math.min(bothremove, rightremove, leftremove);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumDeletions = function(nums) {\\n    const len=nums.length;\\n    let minIndex=nums.indexOf(Math.min(...nums));//find index of min ele in array\\n    let maxIndex=nums.indexOf(Math.max(...nums));//find index of max ele in array\\n    if(minIndex>maxIndex)[minIndex,maxIndex]=[maxIndex,minIndex];\\n    let bothremove = (len - maxIndex)+(minIndex + 1);\\n    let rightremove = (len - minIndex);\\n    let leftremove = (maxIndex + 1);\\n    return Math.min(bothremove, rightremove, leftremove);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486242,
                "title": "easy-to-understand-sol-using-cpp",
                "content": "![Code.jpg](https://assets.leetcode.com/users/images/b990f2ec-246b-42e8-a557-f69fcd376984_1683230273.8073368.jpeg)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int min = INT_MAX;\\n        int max = INT_MIN;\\n        int mini , maxi;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<min){\\n                min = nums[i];\\n                mini = i;\\n            }\\n            if(nums[i]>max){\\n                max = nums[i];\\n                maxi = i;\\n            }\\n        }\\n        int f,b,m,res;\\n        if(mini >= maxi){\\n            f = mini+1;\\n            b = nums.size()-maxi;\\n            m = (nums.size()-mini)+maxi+1;\\n\\n        }\\n        else{\\n            f = maxi+1;\\n            b = nums.size()-mini;\\n            m = (nums.size()-maxi)+mini+1;\\n        }\\n        if(f<=b && f<=m) return f;\\n        else if(b<=m && b<=f) return b;\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int min = INT_MAX;\\n        int max = INT_MIN;\\n        int mini , maxi;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<min){\\n                min = nums[i];\\n                mini = i;\\n            }\\n            if(nums[i]>max){\\n                max = nums[i];\\n                maxi = i;\\n            }\\n        }\\n        int f,b,m,res;\\n        if(mini >= maxi){\\n            f = mini+1;\\n            b = nums.size()-maxi;\\n            m = (nums.size()-mini)+maxi+1;\\n\\n        }\\n        else{\\n            f = maxi+1;\\n            b = nums.size()-mini;\\n            m = (nums.size()-maxi)+mini+1;\\n        }\\n        if(f<=b && f<=m) return f;\\n        else if(b<=m && b<=f) return b;\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334040,
                "title": "commented-cpp-code-easy-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        unordered_map<int,int>mpp;\\n\\n        // we just have to find the minimum and maximum element index \\n        // you can also do that by iterating over the nums array \\n        // and can reduce the extra O(n) space complexity!!!!\\n        // then TIME COMPLEXITY = O(n)\\n        //      SPACE COMPLEXITY = O(1)\\n\\n        // mapping every element with it\\'s index\\n        for(int i = 0; i<nums.size(); i++){\\n            mpp[nums[i]] = i;\\n        }\\n\\n        // finding the maximum and minimum element\\n        int maxi = *max_element(nums.begin(), nums.end());\\n        int mini = *min_element(nums.begin(), nums.end());\\n\\n        // finding index of the maximum and minimum element\\n        int maxIndex = mpp[maxi];\\n        int minIndex = mpp[mini];\\n\\n        // 3 cases arise\\n\\n        // case 1 :- \\n        // we delete element form both left and right\\n        int left = min(maxIndex, minIndex) + 1;\\n        int right = nums.size() - max(maxIndex, minIndex);\\n        int tempAns1 = left+right;\\n\\n        // case 2 :-\\n        // delete both element from left\\n        int tempAns2 = max(maxIndex, minIndex) + 1;\\n\\n        // case 3 :- \\n        // delete both element from right\\n        int tempAns3 = nums.size() - min(maxIndex, minIndex);\\n\\n        return min({tempAns1, tempAns2, tempAns3});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        unordered_map<int,int>mpp;\\n\\n        // we just have to find the minimum and maximum element index \\n        // you can also do that by iterating over the nums array \\n        // and can reduce the extra O(n) space complexity!!!!\\n        // then TIME COMPLEXITY = O(n)\\n        //      SPACE COMPLEXITY = O(1)\\n\\n        // mapping every element with it\\'s index\\n        for(int i = 0; i<nums.size(); i++){\\n            mpp[nums[i]] = i;\\n        }\\n\\n        // finding the maximum and minimum element\\n        int maxi = *max_element(nums.begin(), nums.end());\\n        int mini = *min_element(nums.begin(), nums.end());\\n\\n        // finding index of the maximum and minimum element\\n        int maxIndex = mpp[maxi];\\n        int minIndex = mpp[mini];\\n\\n        // 3 cases arise\\n\\n        // case 1 :- \\n        // we delete element form both left and right\\n        int left = min(maxIndex, minIndex) + 1;\\n        int right = nums.size() - max(maxIndex, minIndex);\\n        int tempAns1 = left+right;\\n\\n        // case 2 :-\\n        // delete both element from left\\n        int tempAns2 = max(maxIndex, minIndex) + 1;\\n\\n        // case 3 :- \\n        // delete both element from right\\n        int tempAns3 = nums.size() - min(maxIndex, minIndex);\\n\\n        return min({tempAns1, tempAns2, tempAns3});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272496,
                "title": "easy-python-solution-run-time-100",
                "content": "![image.png](https://assets.leetcode.com/users/images/44456bde-213f-416e-8e25-7f7f5b3dc56a_1678282137.2027247.png)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimumDeletions(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        mx=nums.index(max(nums))\\n        mn=nums.index(min(nums))\\n        mx_idx=max(mn,mx)\\n        mn_idx=min(mn,mx)\\n        lf_idx=len(nums)-mn_idx\\n        r_idx=len(nums)+1+mn_idx-mx_idx\\n        return min(lf_idx,mx_idx+1,r_idx)\\n        \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumDeletions(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        mx=nums.index(max(nums))\\n        mn=nums.index(min(nums))\\n        mx_idx=max(mn,mx)\\n        mn_idx=min(mn,mx)\\n        lf_idx=len(nums)-mn_idx\\n        r_idx=len(nums)+1+mn_idx-mx_idx\\n        return min(lf_idx,mx_idx+1,r_idx)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937954,
                "title": "t-o-n-s-o-1-faster-than-100-javascript",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nvar minimumDeletions = function (nums) {\\n  let min = Infinity,\\n    max = -Infinity,\\n    minIdx = 0,\\n    maxIdx = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] < min) {\\n      min = nums[i];\\n      minIdx = i;\\n    }\\n    if (nums[i] > max) {\\n      max = nums[i];\\n      maxIdx = i;\\n    }\\n  }\\n//reuse those 2 variables :)\\n  min = minIdx < maxIdx ? minIdx : maxIdx;\\n  max = minIdx < maxIdx ? maxIdx : minIdx;\\n  return Math.min(min + (nums.length - max) + 1, max + 1, nums.length - min);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumDeletions = function (nums) {\\n  let min = Infinity,\\n    max = -Infinity,\\n    minIdx = 0,\\n    maxIdx = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] < min) {\\n      min = nums[i];\\n      minIdx = i;\\n    }\\n    if (nums[i] > max) {\\n      max = nums[i];\\n      maxIdx = i;\\n    }\\n  }\\n//reuse those 2 variables :)\\n  min = minIdx < maxIdx ? minIdx : maxIdx;\\n  max = minIdx < maxIdx ? maxIdx : minIdx;\\n  return Math.min(min + (nums.length - max) + 1, max + 1, nums.length - min);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2857942,
                "title": "simple-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are 3 ways in which we can delete the max and min elements \\n\\n1) Delete both by popping from right end;\\n2) Delete both by popping from left end\\n3) Delete element nearer to right end from right side  and \\n          element nearer to left end from left side\\n\\n# Approach\\n\\nFind deletions needed for each type and return the minimun of them.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->   **O(n)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> **O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n=nums.size();int minnum=nums[0], maxnum=nums[0] ,minindex=0, maxindex=0;\\n        int ans1=0,ans2=0;\\n        if(n==1)return 1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<minnum){\\n                minnum=nums[i];\\n                minindex=i;\\n            }\\n            if(nums[i]>maxnum){\\n                maxnum=nums[i];\\n                maxindex=i;\\n            }\\n        }\\n      \\n    //   TYPE 1 (DELETION FROM RIGHT END)   n-min(minindex,maxindex);\\n    //   TYPE 2 (DELETION FROM LEFT END )   max(minindex,maxindex)+1;\\n    //   TYPE 3 (DELETING MAX INDEX FROM RIGHT AND MIN INDEX FROM LEFT) \\n    //          n - max(minindex,maxindex) +    min(minindex,maxindex) + 1;\\n\\n    // return min number of deletions after calcuationg deletions needed for each type\\n\\nans1=min( n-min(minindex,maxindex), max(minindex,maxindex)+1);\\n\\nans2= n - max(minindex,maxindex) + min(minindex,maxindex) + 1;\\n\\n      return min(ans1,ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n=nums.size();int minnum=nums[0], maxnum=nums[0] ,minindex=0, maxindex=0;\\n        int ans1=0,ans2=0;\\n        if(n==1)return 1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<minnum){\\n                minnum=nums[i];\\n                minindex=i;\\n            }\\n            if(nums[i]>maxnum){\\n                maxnum=nums[i];\\n                maxindex=i;\\n            }\\n        }\\n      \\n    //   TYPE 1 (DELETION FROM RIGHT END)   n-min(minindex,maxindex);\\n    //   TYPE 2 (DELETION FROM LEFT END )   max(minindex,maxindex)+1;\\n    //   TYPE 3 (DELETING MAX INDEX FROM RIGHT AND MIN INDEX FROM LEFT) \\n    //          n - max(minindex,maxindex) +    min(minindex,maxindex) + 1;\\n\\n    // return min number of deletions after calcuationg deletions needed for each type\\n\\nans1=min( n-min(minindex,maxindex), max(minindex,maxindex)+1);\\n\\nans2= n - max(minindex,maxindex) + min(minindex,maxindex) + 1;\\n\\n      return min(ans1,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794020,
                "title": "javascript-solution-o-n-time",
                "content": "```\\nvar minimumDeletions = function(nums) {\\n    let minInd = 0;\\n    let maxInd = 0;\\n    \\n    for(let i = 0; i< nums.length; i++) {\\n        \\n        if(nums[i] > nums[maxInd]) maxInd = i;\\n        if(nums[i] < nums[minInd]) minInd = i;\\n    }\\n    \\n    /*\\n        [,,,,,,i,,,,,,,,j,,,,,,,,]\\n        \\n        a = i + 1;\\n        b = N - j;\\n        c = N - i;\\n        d = j + 1;\\n        \\n        ans = minimum of  a + b, c, d\\n    */\\n    return Math.min(Math.min(maxInd,minInd) + 1 + nums.length - Math.max(maxInd, minInd), nums.length - Math.min(maxInd, minInd), Math.max(maxInd, minInd) + 1 );\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumDeletions = function(nums) {\\n    let minInd = 0;\\n    let maxInd = 0;\\n    \\n    for(let i = 0; i< nums.length; i++) {\\n        \\n        if(nums[i] > nums[maxInd]) maxInd = i;\\n        if(nums[i] < nums[minInd]) minInd = i;\\n    }\\n    \\n    /*\\n        [,,,,,,i,,,,,,,,j,,,,,,,,]\\n        \\n        a = i + 1;\\n        b = N - j;\\n        c = N - i;\\n        d = j + 1;\\n        \\n        ans = minimum of  a + b, c, d\\n    */\\n    return Math.min(Math.min(maxInd,minInd) + 1 + nums.length - Math.max(maxInd, minInd), nums.length - Math.min(maxInd, minInd), Math.max(maxInd, minInd) + 1 );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2510548,
                "title": "c-solution-easy-explaination",
                "content": "```\\n/*\\nPlease upvote if explanation is easily understandable......\\n1. find minimum element index and maximum element index.\\n2. there will be four choices to do deletions and make minimum move.\\na. we are deleting both from front.\\nb. we are deleting both from end.\\nc. we are deleting minm from end and maxm from start and vice versa.\\nthe minimum of all four will be our result\\n.*/\\n int minimumDeletions(vector<int>& nums) {\\n        int minm = 100001, maxm = -100001;\\n        int n = nums.size();\\n        int minm_i = -1, maxm_i = -1;\\n        for(int i= 0 ; i< nums.size(); i++){\\n            if(minm > nums[i]){\\n                minm = nums[i];\\n                minm_i = i;\\n            }\\n            if(maxm < nums[i]){\\n                maxm = nums[i];\\n                maxm_i = i;\\n            }\\n        }\\n        int front = max(minm_i, maxm_i)+1;\\n        int back = max(n - minm_i, n - maxm_i);\\n        int frontback = minm_i+1 + n - maxm_i;\\n        int frontback2 = maxm_i+1 + n - minm_i;\\n        return min(min(front, back), min(frontback, frontback2));\\n    }",
                "solutionTags": [],
                "code": "```\\n/*\\nPlease upvote if explanation is easily understandable......\\n1. find minimum element index and maximum element index.\\n2. there will be four choices to do deletions and make minimum move.\\na. we are deleting both from front.\\nb. we are deleting both from end.\\nc. we are deleting minm from end and maxm from start and vice versa.\\nthe minimum of all four will be our result\\n.*/\\n int minimumDeletions(vector<int>& nums) {\\n        int minm = 100001, maxm = -100001;\\n        int n = nums.size();\\n        int minm_i = -1, maxm_i = -1;\\n        for(int i= 0 ; i< nums.size(); i++){\\n            if(minm > nums[i]){\\n                minm = nums[i];\\n                minm_i = i;\\n            }\\n            if(maxm < nums[i]){\\n                maxm = nums[i];\\n                maxm_i = i;\\n            }\\n        }\\n        int front = max(minm_i, maxm_i)+1;\\n        int back = max(n - minm_i, n - maxm_i);\\n        int frontback = minm_i+1 + n - maxm_i;\\n        int frontback2 = maxm_i+1 + n - minm_i;\\n        return min(min(front, back), min(frontback, frontback2));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2199702,
                "title": "java-explained-commented-code",
                "content": "```\\n\\tclass Solution {\\n\\t\\tpublic int minimumDeletions (int[] nums) {\\n\\t\\t\\tint n = nums.length;\\n            \\n            //Trivial cases\\n            if (n == 1) return 1;\\n            if (n == 2 || n == 3) return 2;\\n            \\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint minIdx = 0; //index of minimum element\\n\\t\\t\\tint maxIdx = 0; //index of maximum element\\n            \\n\\t\\t\\twhile (i < n) {\\n\\t\\t\\t\\tif (nums[i] > nums[maxIdx])\\n\\t\\t\\t\\t\\tmaxIdx = i; \\n\\t\\t\\t\\tif (nums[i] < nums[minIdx])\\n\\t\\t\\t\\t\\tminIdx = i;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n            /*\\n            [2, 10, 7, 5, 4, 1, 8, 6]\\n            [2, maxIdx, 7, 5, 4, minIdx, 8, 6]\\n            [2, left, 7, 5, 4, right, 8, 6]\\n            left = 1\\n            right = 5\\n            */\\n\\t\\t\\tint left = Math.min(maxIdx, minIdx);\\n\\t\\t\\tint right = Math.max(maxIdx, minIdx);\\n            /*\\n            We have 3 options - just find the minimum \\n            1. (left + 1) + (n - right)\\n            2. (right + 1)\\n            3. (n - left)\\n            */\\n\\t\\t\\tint res = Math.min((Math.min((right + 1), (n - left))), ((left + 1) + (n - right)));\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tclass Solution {\\n\\t\\tpublic int minimumDeletions (int[] nums) {\\n\\t\\t\\tint n = nums.length;\\n            \\n            //Trivial cases\\n            if (n == 1) return 1;\\n            if (n == 2 || n == 3) return 2;\\n            \\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint minIdx = 0; //index of minimum element\\n\\t\\t\\tint maxIdx = 0; //index of maximum element\\n            \\n\\t\\t\\twhile (i < n) {\\n\\t\\t\\t\\tif (nums[i] > nums[maxIdx])\\n\\t\\t\\t\\t\\tmaxIdx = i; \\n\\t\\t\\t\\tif (nums[i] < nums[minIdx])\\n\\t\\t\\t\\t\\tminIdx = i;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n            /*\\n            [2, 10, 7, 5, 4, 1, 8, 6]\\n            [2, maxIdx, 7, 5, 4, minIdx, 8, 6]\\n            [2, left, 7, 5, 4, right, 8, 6]\\n            left = 1\\n            right = 5\\n            */\\n\\t\\t\\tint left = Math.min(maxIdx, minIdx);\\n\\t\\t\\tint right = Math.max(maxIdx, minIdx);\\n            /*\\n            We have 3 options - just find the minimum \\n            1. (left + 1) + (n - right)\\n            2. (right + 1)\\n            3. (n - left)\\n            */\\n\\t\\t\\tint res = Math.min((Math.min((right + 1), (n - left))), ((left + 1) + (n - right)));\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179765,
                "title": "simple-approach-java-o-n",
                "content": "class Solution {\\n                 \\n    public int minimumDeletions(int[] nums) {\\n        int n = nums.length;\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        int min_index = 0;\\n        int max_index=0;\\n        for(int i =0;i <n ;i++)\\n        {\\n            if(nums[i]> max)\\n            {\\n                max = nums[i];\\n                max_index = i;\\n            }\\n            if(nums[i]<min)\\n            {\\n                min = nums[i];\\n                min_index = i;\\n            }\\n        }\\n        // 3 cases -both delete from left\\n        //          - BOTH DELETE FROM RIGHT\\n        //          - right and left together\\n      \\n        \\n        // delete from left side\\n        int rightmost = Math.max(max_index, min_index);\\n        int del_from_left = rightmost+1;\\n        //delete from right side\\n        int leftmost = Math.min(max_index, min_index);\\n         int del_from_right = n-leftmost;\\n                    \\n        int temp = Math.min(del_from_left, del_from_right);\\n                     \\n        // from both sides\\n        int del_from_both = (n-rightmost) + leftmost+1;\\n        \\n        return Math.min(temp, del_from_both);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n                 \\n    public int minimumDeletions(int[] nums) {\\n        int n = nums.length;\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        int min_index = 0;\\n        int max_index=0;\\n        for(int i =0;i <n ;i++)\\n        {\\n            if(nums[i]> max)\\n            {\\n                max = nums[i];\\n                max_index = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2047566,
                "title": "c-easiest-code-o-n-time-o-1-space",
                "content": "```\\n int minimumDeletions(vector<int>& nums) {\\n        int mi=0,mx=0,n=nums.size();\\n        for (int i=0;i<n;i++)\\n        {\\n            if(nums[mi]>nums[i]) mi=i;\\n            if(nums[mx]<nums[i]) mx=i;\\n        }\\n        if(mi>mx) swap(mi,mx);\\n        int ans= mi+1 + n-mx;\\n        ans= min(ans, n-mi);\\n        ans= min(ans, mx+1);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int minimumDeletions(vector<int>& nums) {\\n        int mi=0,mx=0,n=nums.size();\\n        for (int i=0;i<n;i++)\\n        {\\n            if(nums[mi]>nums[i]) mi=i;\\n            if(nums[mx]<nums[i]) mx=i;\\n        }\\n        if(mi>mx) swap(mi,mx);\\n        int ans= mi+1 + n-mx;\\n        ans= min(ans, n-mi);\\n        ans= min(ans, mx+1);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2029921,
                "title": "easy-c-solution-3-cases",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n=nums.size();\\n        if(nums.size()==1)return 1;\\n        int max_idx=max_element(nums.begin(),nums.end())-nums.begin();\\n        int min_idx=min_element(nums.begin(),nums.end())-nums.begin();\\n        int left=min(min_idx,max_idx);\\n        int right=max(min_idx,max_idx);\\n        return min({right+1,n-left,left+1+n-right});\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n=nums.size();\\n        if(nums.size()==1)return 1;\\n        int max_idx=max_element(nums.begin(),nums.end())-nums.begin();\\n        int min_idx=min_element(nums.begin(),nums.end())-nums.begin();\\n        int left=min(min_idx,max_idx);\\n        int right=max(min_idx,max_idx);\\n        return min({right+1,n-left,left+1+n-right});\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805202,
                "title": "python-easy-solution-5-lines-only",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        min_index = nums.index(min(nums))\\n        max_index = nums.index(max(nums))\\n        return min(max(min_index,max_index)+1,len(nums)-min(min_index,max_index),min(min_index,max_index)+1+len(nums)-max(min_index,max_index))\\n```\\n\\nIf we delete from left side : ```max(min_index,max_index)+1```\\nif we delete from right side:  ```len(nums)-min(min_index,max_index)```\\nif we delete from both sides: ```min(min_index,max_index)+1+len(nums)-max(min_index,max_index))```\\n\\nreturn  = minimum on all i.e., min(left,right,both)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        min_index = nums.index(min(nums))\\n        max_index = nums.index(max(nums))\\n        return min(max(min_index,max_index)+1,len(nums)-min(min_index,max_index),min(min_index,max_index)+1+len(nums)-max(min_index,max_index))\\n```\n```max(min_index,max_index)+1```\n```len(nums)-min(min_index,max_index)```\n```min(min_index,max_index)+1+len(nums)-max(min_index,max_index))```",
                "codeTag": "Java"
            },
            {
                "id": 1718349,
                "title": "easy-c-solution-with-explanation",
                "content": "The approach to the problem is simple. First, we need to calculate the position of minimum and maximum elements as shown in the code, through comments and store it in **i** and **j** respectively.\\nThen we need to calculate the number of deletion operations from both the start and the end as depicted in the below picture:\\n![image](https://assets.leetcode.com/users/images/02f72e2e-894b-47a6-abbc-2f8815bdd73c_1643108980.7939186.png)\\n\\nThen we can just check the minimum of all combinations which are deletion of:\\nmin from start and max from start (stored in **a**)\\nmin from end and max from end (stored in **b**)\\nmin from end and max from start (stored in **c**)\\nmin from start and max from end (stored in **d**)\\n\\n**Time Complexity:** O(n), to find index of min and max element\\n**Space Complexity:** O(1), constant space is used\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        if(nums.size()<=2)\\n            return nums.size();\\n\\t\\tauto i=max_element(nums.begin(),nums.end());\\n        auto j=min_element(nums.begin(),nums.end());\\n        int min_s,min_e,max_s,max_e;\\n        /*\\n            max_s : number of operations to delete maximum element from front\\n            max_e : number of operations to delete maximum element from back\\n\\t\\t\\tmin_s : number of operations to delete minimum element from front\\n            min_e : number of operations to delete minimum element from back\\n           \\n        */\\n        max_s=i-nums.begin()+1;\\n        max_e=nums.end()-i;\\n        min_s=j-nums.begin()+1;\\n        min_e=nums.end()-j;\\n        //if deletion is done from front for both\\n        int a=max(min_s,max_s);\\n        //if deletion is done from back for both\\n        int b=max(min_e,max_e);\\n        //if max element is deleted form front and min element from back\\n        int c=min_e+max_s;\\n        //if min element is deleted form front and max element from back\\n        int d=min_s+max_e;\\n        \\n        //return the minimum of all\\n        return min(a,min(b,min(c,d)));\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        if(nums.size()<=2)\\n            return nums.size();\\n\\t\\tauto i=max_element(nums.begin(),nums.end());\\n        auto j=min_element(nums.begin(),nums.end());\\n        int min_s,min_e,max_s,max_e;\\n        /*\\n            max_s : number of operations to delete maximum element from front\\n            max_e : number of operations to delete maximum element from back\\n\\t\\t\\tmin_s : number of operations to delete minimum element from front\\n            min_e : number of operations to delete minimum element from back\\n           \\n        */\\n        max_s=i-nums.begin()+1;\\n        max_e=nums.end()-i;\\n        min_s=j-nums.begin()+1;\\n        min_e=nums.end()-j;\\n        //if deletion is done from front for both\\n        int a=max(min_s,max_s);\\n        //if deletion is done from back for both\\n        int b=max(min_e,max_e);\\n        //if max element is deleted form front and min element from back\\n        int c=min_e+max_s;\\n        //if min element is deleted form front and max element from back\\n        int d=min_s+max_e;\\n        \\n        //return the minimum of all\\n        return min(a,min(b,min(c,d)));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617410,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nint minimumDeletions(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint minIdx{ 0 }, maxIdx{ 0 };\\n\\tfor (int i = 1; i < n; ++i) {\\n\\t\\tif (nums[i] < nums[minIdx]) minIdx = i;\\n\\t\\tif (nums[i] > nums[maxIdx]) maxIdx = i;\\n\\t}\\n\\tint dis_min = min(minIdx + 1, n - minIdx);\\n\\tint dis_max = min(maxIdx + 1, n - maxIdx);\\n\\tint between = abs(maxIdx - minIdx);\\n\\treturn min(\\n\\t\\tdis_min + dis_max, // remove in different sides\\n\\t\\tbetween + min(dis_min, dis_max) // remove in same side\\n\\t);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumDeletions(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint minIdx{ 0 }, maxIdx{ 0 };\\n\\tfor (int i = 1; i < n; ++i) {\\n\\t\\tif (nums[i] < nums[minIdx]) minIdx = i;\\n\\t\\tif (nums[i] > nums[maxIdx]) maxIdx = i;\\n\\t}\\n\\tint dis_min = min(minIdx + 1, n - minIdx);\\n\\tint dis_max = min(maxIdx + 1, n - maxIdx);\\n\\tint between = abs(maxIdx - minIdx);\\n\\treturn min(\\n\\t\\tdis_min + dis_max, // remove in different sides\\n\\t\\tbetween + min(dis_min, dis_max) // remove in same side\\n\\t);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1609043,
                "title": "python-3-o-n-solution",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        min_i = max_i = None\\n        min_num, max_num = math.inf, -math.inf\\n        for i, num in enumerate(nums):\\n            if num < min_num:\\n                min_i, min_num = i, num\\n            if num > max_num:\\n                max_i, max_num = i, num\\n       \\n        if min_i > max_i:\\n            min_i, max_i = max_i, min_i\\n\\t\\t\\n        n = len(nums)\\n        \\n        return min(min_i + 1 + n - max_i,  # delete from left and right\\n                   max_i + 1,  # delete from left only\\n                   n - min_i)  # delete from right only",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        min_i = max_i = None\\n        min_num, max_num = math.inf, -math.inf\\n        for i, num in enumerate(nums):\\n            if num < min_num:\\n                min_i, min_num = i, num\\n            if num > max_num:\\n                max_i, max_num = i, num\\n       \\n        if min_i > max_i:\\n            min_i, max_i = max_i, min_i\\n\\t\\t\\n        n = len(nums)\\n        \\n        return min(min_i + 1 + n - max_i,  # delete from left and right\\n                   max_i + 1,  # delete from left only\\n                   n - min_i)  # delete from right only",
                "codeTag": "Java"
            },
            {
                "id": 1599820,
                "title": "java-simple-o-n",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int minI = -1;\\n        int max = Integer.MIN_VALUE;\\n        int maxI = -1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] < min){\\n                min = nums[i];\\n                minI = i;\\n            }\\n            if(nums[i] > max){\\n                max = nums[i];\\n                maxI = i;\\n            }\\n        }\\n        int minDel = Integer.MAX_VALUE;\\n        if(minI > maxI){\\n            minDel = Math.min(minDel, (maxI + 1) + (nums.length-minI));      \\n            minDel = Math.min(minDel, (minI + 1));\\n            minDel = Math.min(minDel, (nums.length-maxI));\\n        }else {\\n            minDel = Math.min(minDel, (minI + 1) + (nums.length-maxI));      \\n            minDel = Math.min(minDel, (maxI + 1));\\n            minDel = Math.min(minDel, (nums.length-minI));\\n        }\\n        return minDel;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int minI = -1;\\n        int max = Integer.MIN_VALUE;\\n        int maxI = -1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] < min){\\n                min = nums[i];\\n                minI = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1599811,
                "title": "c-easy-solution-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        vector<int> v(nums.begin(),nums.end());\\n        sort(v.begin(),v.end());\\n        int f=find(nums.begin(),nums.end(),v[0])-nums.begin();\\n        int s=find(nums.begin(),nums.end(),v.back())-nums.begin();\\n        int n=nums.size();\\n        int ans;\\n        if(f>s)\\n        {\\n            ans=f+1;\\n            ans=min(ans,n-s);\\n            ans=min(ans,s+1+n-f);\\n        }\\n        else {\\n            ans=s+1;\\n            ans=min(ans,n-f);\\n            ans=min(ans,f+1+n-s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        vector<int> v(nums.begin(),nums.end());\\n        sort(v.begin(),v.end());\\n        int f=find(nums.begin(),nums.end(),v[0])-nums.begin();\\n        int s=find(nums.begin(),nums.end(),v.back())-nums.begin();\\n        int n=nums.size();\\n        int ans;\\n        if(f>s)\\n        {\\n            ans=f+1;\\n            ans=min(ans,n-s);\\n            ans=min(ans,s+1+n-f);\\n        }\\n        else {\\n            ans=s+1;\\n            ans=min(ans,n-f);\\n            ans=min(ans,f+1+n-s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037888,
                "title": "straight-forward-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int minPosition = 0;\\n        int maxPostion = 0;\\n        int minElemrnt = INT_MAX;\\n        int maxElement = INT_MIN;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<minElemrnt){\\n                minElemrnt = min(minElemrnt,nums[i]);\\n               minPosition =i ;\\n            }\\n             if(nums[i]>maxElement){\\n                maxElement = max(maxElement,nums[i]);\\n                maxPostion =i ;\\n            }\\n        }\\n\\n        int distancefront = max(minPosition+1 , maxPostion+1 );\\n        int distanceEnd = max((nums.size()-minPosition),(nums.size()-maxPostion));\\n        int distanceBoth = 0;\\n        if(minPosition<maxPostion){\\n              distanceBoth = minPosition+1+ nums.size()-maxPostion;\\n        }\\n        else{\\n             distanceBoth = maxPostion+1+ nums.size()-minPosition;\\n        }\\n        \\n        return min(distanceBoth,min(distancefront,distanceEnd));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int minPosition = 0;\\n        int maxPostion = 0;\\n        int minElemrnt = INT_MAX;\\n        int maxElement = INT_MIN;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<minElemrnt){\\n                minElemrnt = min(minElemrnt,nums[i]);\\n               minPosition =i ;\\n            }\\n             if(nums[i]>maxElement){\\n                maxElement = max(maxElement,nums[i]);\\n                maxPostion =i ;\\n            }\\n        }\\n\\n        int distancefront = max(minPosition+1 , maxPostion+1 );\\n        int distanceEnd = max((nums.size()-minPosition),(nums.size()-maxPostion));\\n        int distanceBoth = 0;\\n        if(minPosition<maxPostion){\\n              distanceBoth = minPosition+1+ nums.size()-maxPostion;\\n        }\\n        else{\\n             distanceBoth = maxPostion+1+ nums.size()-minPosition;\\n        }\\n        \\n        return min(distanceBoth,min(distancefront,distanceEnd));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034271,
                "title": "fully-explained-optimal-solution",
                "content": "# Intuition\\nThere can be 3 ways to remove the minimum and maximum element from the array -\\n$$arr = [2,10,7,5,4,1,8,6]$$\\nmaxi = 10 , maxIdx = 1\\nmini = 1 , minIdx = 5\\n\\nWe try to make sure that the minimum element is closer to the left and the maximum element is closer to the right.\\n\\nIn this case, we swap and make $$maxIdx = 5$$ and $$minIdx = 1$$\\n\\n**Case 1 -** remove minimum element from the left by removing $$minIdx+1$$ elements **and** maximum element from the right by removing $$n-maxIdx$$ elements.\\n\\n**Case 2 -** Remove $$maxIdx+1$$ elements from the left. This will remove both the minimum and maximum element from the array.\\n\\n**Case 3 -** Remove $$n-minIdx$$ elements from the right. This will remove both the minimum and maximum element from the array.\\n\\n# Complexity\\n- Time complexity : $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxi = *max_element(begin(nums),end(nums));\\n        int mini = *min_element(begin(nums),end(nums));\\n\\n        int minIdx,maxIdx;\\n        for(int i=0 ; i<n ; i++) {\\n            if(nums[i] == mini) minIdx = i;\\n            if(nums[i] == maxi) maxIdx = i;\\n        }\\n\\n        if(minIdx > maxIdx) swap(minIdx,maxIdx);\\n\\n        int a = (minIdx+1)+(n-maxIdx);\\n        int b = maxIdx+1;\\n        int c = n-minIdx;\\n\\n        return min({a,b,c}); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxi = *max_element(begin(nums),end(nums));\\n        int mini = *min_element(begin(nums),end(nums));\\n\\n        int minIdx,maxIdx;\\n        for(int i=0 ; i<n ; i++) {\\n            if(nums[i] == mini) minIdx = i;\\n            if(nums[i] == maxi) maxIdx = i;\\n        }\\n\\n        if(minIdx > maxIdx) swap(minIdx,maxIdx);\\n\\n        int a = (minIdx+1)+(n-maxIdx);\\n        int b = maxIdx+1;\\n        int c = n-minIdx;\\n\\n        return min({a,b,c}); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984533,
                "title": "beats-100-in-tc-beats-89-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min =Integer.MAX_VALUE;\\n        int max =Integer.MIN_VALUE;\\n        int minI =0 ,maxI=0;\\n        for(int i =0;i<nums.length;i++){\\n            if(nums[i]>max)\\n            {   \\n                max = nums[i];\\n                maxI = i;\\n            \\n            }\\n             if(nums[i]<min)\\n                {\\n                    min = nums[i];\\n                    minI= i;\\n                }}\\n\\nreturn Math.min(Math.max(maxI+1,minI+1),Math.min(Math.max(nums.length - maxI, nums.length - minI),Math.min(minI+1 + nums.length - maxI, maxI+1 +nums.length - minI)));   \\n                 \\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min =Integer.MAX_VALUE;\\n        int max =Integer.MIN_VALUE;\\n        int minI =0 ,maxI=0;\\n        for(int i =0;i<nums.length;i++){\\n            if(nums[i]>max)\\n            {   \\n                max = nums[i];\\n                maxI = i;\\n            \\n            }\\n             if(nums[i]<min)\\n                {\\n                    min = nums[i];\\n                    minI= i;\\n                }}\\n\\nreturn Math.min(Math.max(maxI+1,minI+1),Math.min(Math.max(nums.length - maxI, nums.length - minI),Math.min(minI+1 + nums.length - maxI, maxI+1 +nums.length - minI)));   \\n                 \\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965996,
                "title": "c-clean-code-easy-to-understand",
                "content": "# Intuition\\nYou have to simply find the two indexes of the smallest & largest elements. And then we have to determine which one of them is left & which one is right. It is important because this will help in determining what is the min number of deletions we need. For e.g.\\n\\nWe have 3 cases we need to consider for min answers:\\n1. Delete both elements from the left end of the vector. In which case, the num of deletions = right index + 1;\\n2. Delete both elements from the right end of the vector. In which case, the num of deletions = left index + 1;\\n3. Delete all elements from the left end so left element gets out and delete all elements from the right end so right element gets out. In which case, the num of deletions = left index + 1 + vector_size - right_index_pos;\\n\\nAs our solution, we need the min of these 3 solutions.\\n\\n**Show your love if you liked my implmentation** :) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int min(int a, int b)\\n    {\\n        return a <= b ? a: b;\\n    }\\n\\n    int minimumDeletions(vector<int>& nums) \\n    {\\n        int mx = distance(nums.begin(), max_element(nums.begin(), nums.end()));\\n        int mn = distance(nums.begin(), min_element(nums.begin(), nums.end()));  \\n        int ans = INT_MAX, l, r;\\n\\n        l = mn <= mx ? mn : mx;\\n        r = mx >= mn ? mx: mn;\\n\\n        ans = min(ans, r+1);\\n        ans = min(ans, nums.size()-l);\\n        ans = min(ans, l+1 + nums.size()-r);\\n        \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int min(int a, int b)\\n    {\\n        return a <= b ? a: b;\\n    }\\n\\n    int minimumDeletions(vector<int>& nums) \\n    {\\n        int mx = distance(nums.begin(), max_element(nums.begin(), nums.end()));\\n        int mn = distance(nums.begin(), min_element(nums.begin(), nums.end()));  \\n        int ans = INT_MAX, l, r;\\n\\n        l = mn <= mx ? mn : mx;\\n        r = mx >= mn ? mx: mn;\\n\\n        ans = min(ans, r+1);\\n        ans = min(ans, nums.size()-l);\\n        ans = min(ans, l+1 + nums.size()-r);\\n        \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819858,
                "title": "beats-90-cpp-sol",
                "content": "# **Upvote me \\uD83E\\uDD79**\\n\\n# Approach\\nApproach is written in the form of comments inside the code just go through the code once, you will surely understand the logic!!!!\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Pls Upvote me if you find Helpful !\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        // storing no with their index so that we can get min index and max index\\n        unordered_map<int,int>mpp;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            mpp[nums[i]] = i;\\n        }\\n\\n        // now finding the minimum and maximum index\\n        int mini = *min_element(nums.begin(), nums.end());\\n        int maxi = *max_element(nums.begin(), nums.end());\\n        int minIndex = mpp[mini];\\n        int maxIndex = mpp[maxi];\\n\\n        // three cases of deletion now\\n        // 1 case : deleting from left and right both sides\\n        int left = min(maxIndex, minIndex)+1;\\n        int right = nums.size() - max(maxIndex, minIndex);\\n        int tempAns1 = left+right;\\n\\n        // 2 case : deletig both no from left size\\n        int tempAns2 = max(maxIndex, minIndex) + 1;\\n\\n        // deleting both no from right size\\n        int tempAns3 = nums.size() - min(maxIndex, minIndex);\\n\\n        return min({tempAns1, tempAns2, tempAns3});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        // storing no with their index so that we can get min index and max index\\n        unordered_map<int,int>mpp;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            mpp[nums[i]] = i;\\n        }\\n\\n        // now finding the minimum and maximum index\\n        int mini = *min_element(nums.begin(), nums.end());\\n        int maxi = *max_element(nums.begin(), nums.end());\\n        int minIndex = mpp[mini];\\n        int maxIndex = mpp[maxi];\\n\\n        // three cases of deletion now\\n        // 1 case : deleting from left and right both sides\\n        int left = min(maxIndex, minIndex)+1;\\n        int right = nums.size() - max(maxIndex, minIndex);\\n        int tempAns1 = left+right;\\n\\n        // 2 case : deletig both no from left size\\n        int tempAns2 = max(maxIndex, minIndex) + 1;\\n\\n        // deleting both no from right size\\n        int tempAns3 = nums.size() - min(maxIndex, minIndex);\\n\\n        return min({tempAns1, tempAns2, tempAns3});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788273,
                "title": "easy-to-understand-clear-code-c",
                "content": "\\n\\n# Approach\\n1. Remove from front \\n2. Remove from back \\n3. Remove from front and back \\n4. find the Min of min(min(front,back,),frontBack);\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int minimumDeletions(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int maxIndex = 0, minIndex = 0;\\n        int mini = INT_MAX, maxi = INT_MIN ;\\n\\t\\t\\n\\t\\t//Finding minimum and maximum element\\n        for (int i = 0; i < n; i++){\\n\\n            if(nums[i] < mini){\\n                mini = nums[i]; //min element found\\n                minIndex = i; //minIndex stored\\n            }\\n            if(nums[i]>maxi){\\n                maxi=nums[i]; //max element found\\n                maxIndex=i; //maxIndex stored\\n            }\\n        }\\n     \\n\\t\\t//When removed from front only\\n        int front = max(maxIndex, minIndex) + 1;\\n\\t\\t\\n\\t\\t//When removed from back only\\n        int back = n - min(minIndex, maxIndex);\\n\\t\\t\\n\\t\\t//When removed from both front and back\\n        int frontBack = (min(minIndex, maxIndex) + 1) + (n - max(minIndex, maxIndex));\\n\\t\\t\\n       return min(min(front, back), frontBack);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minimumDeletions(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int maxIndex = 0, minIndex = 0;\\n        int mini = INT_MAX, maxi = INT_MIN ;\\n\\t\\t\\n\\t\\t//Finding minimum and maximum element\\n        for (int i = 0; i < n; i++){\\n\\n            if(nums[i] < mini){\\n                mini = nums[i]; //min element found\\n                minIndex = i; //minIndex stored\\n            }\\n            if(nums[i]>maxi){\\n                maxi=nums[i]; //max element found\\n                maxIndex=i; //maxIndex stored\\n            }\\n        }\\n     \\n\\t\\t//When removed from front only\\n        int front = max(maxIndex, minIndex) + 1;\\n\\t\\t\\n\\t\\t//When removed from back only\\n        int back = n - min(minIndex, maxIndex);\\n\\t\\t\\n\\t\\t//When removed from both front and back\\n        int frontBack = (min(minIndex, maxIndex) + 1) + (n - max(minIndex, maxIndex));\\n\\t\\t\\n       return min(min(front, back), frontBack);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414910,
                "title": "c-simple-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThink in 3 cases which we can delete the elements\\n   1.Delete elements from left.\\n   2.Delete elements from right.\\n   3.Delete one from left end and other from right end.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Find the index of minimum and maximum element.\\n2.Choose optimal answer by considering 3 cases.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxi(vector<int>& nums)\\n    {\\n        int k=INT_MIN,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(k<nums[i]){\\n                k=nums[i];\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n    int mini(vector<int>& nums)\\n    {\\n        int k=INT_MAX,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(k>nums[i]){\\n                k=nums[i];\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumDeletions(vector<int>& nums) {\\n        int k=nums.size();\\n        if(k<=2) return k;//we can return the size of element if it is less than or equal to 2 as returning the size will be the optimal answer.\\n        int m=mini(nums),n=maxi(nums);//Choose the index of minimum and maximum element\\n        int ans=max(m,n)+1;//deletion from left\\n        ans=min(ans,k-min(m,n));//deletion from right\\n        ans=min(ans,k-m+n+1);\\n        ans=min(ans,k-n+m+1);\\n        //deleting one from left and other from right end.\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi(vector<int>& nums)\\n    {\\n        int k=INT_MIN,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(k<nums[i]){\\n                k=nums[i];\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n    int mini(vector<int>& nums)\\n    {\\n        int k=INT_MAX,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(k>nums[i]){\\n                k=nums[i];\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumDeletions(vector<int>& nums) {\\n        int k=nums.size();\\n        if(k<=2) return k;//we can return the size of element if it is less than or equal to 2 as returning the size will be the optimal answer.\\n        int m=mini(nums),n=maxi(nums);//Choose the index of minimum and maximum element\\n        int ans=max(m,n)+1;//deletion from left\\n        ans=min(ans,k-min(m,n));//deletion from right\\n        ans=min(ans,k-m+n+1);\\n        ans=min(ans,k-n+m+1);\\n        //deleting one from left and other from right end.\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211559,
                "title": "beats-86-brute-force",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int mn=INT_MAX,mx=INT_MIN ;\\n        int a,b;\\n        int s=nums.size(); \\n        for(int i=0;i<s;i++){\\n            if(mn>nums[i]){\\n                mn=nums[i];\\n                a=i ;\\n            }\\n            if(mx<nums[i]) {\\n                mx=nums[i];\\n                b=i; \\n            } \\n        }\\n    int j=max(a,b)+1;  \\n    int k=s-min(a,b);\\n    return min(min(j,k),min(a,b)+1+s-max(a,b));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int mn=INT_MAX,mx=INT_MIN ;\\n        int a,b;\\n        int s=nums.size(); \\n        for(int i=0;i<s;i++){\\n            if(mn>nums[i]){\\n                mn=nums[i];\\n                a=i ;\\n            }\\n            if(mx<nums[i]) {\\n                mx=nums[i];\\n                b=i; \\n            } \\n        }\\n    int j=max(a,b)+1;  \\n    int k=s-min(a,b);\\n    return min(min(j,k),min(a,b)+1+s-max(a,b));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080911,
                "title": "easy-approach-well-explained-beats-90",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        if(nums.size()==1)return 1;\\n\\n        //Idea is to find the minimum & maximum element\\'s indexes and take minimum of removing from front & back & from only front & from only back\\n\\n        int min_idx=-1,max_idx=-1;\\n        int min_val=INT_MAX,max_val=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<min_val){\\n                min_val=nums[i];\\n                min_idx=i;\\n            }\\n            if(nums[i]>max_val){\\n                max_val=nums[i];\\n                max_idx=i;\\n            }\\n        }\\n        int ans=INT_MAX;\\n        max_val=max(min_idx,max_idx);\\n        ans=min(ans,(abs(0-max_val)+1));//both from start;\\n        min_val=min(min_idx,max_idx);\\n        int end=nums.size()-1;\\n        ans=min(ans,(abs(end-min_val)+1));//both from end;\\n\\n        //remove smaller index from start & greater from last\\n        ans=min(ans,((abs(0-min_val)+1)+(abs(end-max_val)+1)));\\n\\n        //return minimum of all 3 possibilities\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        if(nums.size()==1)return 1;\\n\\n        //Idea is to find the minimum & maximum element\\'s indexes and take minimum of removing from front & back & from only front & from only back\\n\\n        int min_idx=-1,max_idx=-1;\\n        int min_val=INT_MAX,max_val=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<min_val){\\n                min_val=nums[i];\\n                min_idx=i;\\n            }\\n            if(nums[i]>max_val){\\n                max_val=nums[i];\\n                max_idx=i;\\n            }\\n        }\\n        int ans=INT_MAX;\\n        max_val=max(min_idx,max_idx);\\n        ans=min(ans,(abs(0-max_val)+1));//both from start;\\n        min_val=min(min_idx,max_idx);\\n        int end=nums.size()-1;\\n        ans=min(ans,(abs(end-min_val)+1));//both from end;\\n\\n        //remove smaller index from start & greater from last\\n        ans=min(ans,((abs(0-min_val)+1)+(abs(end-max_val)+1)));\\n\\n        //return minimum of all 3 possibilities\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881480,
                "title": "c-very-simple",
                "content": "\\'\\'\\' int minimumDeletions(vector<int>& nums) {\\n        \\n        int mini = min_element(nums.begin(),nums.end())-nums.begin();\\n        int maxi = max_element(nums.begin(),nums.end())-nums.begin();\\n        \\n         \\n        int cnt1 = max(mini,maxi)+1;  // if deletion starts from  starting index\\n        \\n        int cnt2 = nums.size()-min(mini,maxi); // if deletion starts from end index\\n        \\n        int cnt = min(cnt1,cnt2);  // take minimum\\n        \\n       int cnt4 =min(mini,maxi)+1+nums.size()-max(mini,maxi); //now if delete from strat as well as end \\n        \\n        return min(cnt4,cnt);\\n \\n    }\\'\\'\\'\\n",
                "solutionTags": [],
                "code": "\\'\\'\\' int minimumDeletions(vector<int>& nums) {\\n        \\n        int mini = min_element(nums.begin(),nums.end())-nums.begin();\\n        int maxi = max_element(nums.begin(),nums.end())-nums.begin();\\n        \\n         \\n        int cnt1 = max(mini,maxi)+1;  // if deletion starts from  starting index\\n        \\n        int cnt2 = nums.size()-min(mini,maxi); // if deletion starts from end index\\n        \\n        int cnt = min(cnt1,cnt2);  // take minimum\\n        \\n       int cnt4 =min(mini,maxi)+1+nums.size()-max(mini,maxi); //now if delete from strat as well as end \\n        \\n        return min(cnt4,cnt);\\n \\n    }\\'\\'\\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2687037,
                "title": "very-simple-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int size1 = nums.size();\\n        if(nums.size() == 1)\\n        {\\n            return 1;\\n        }\\n        \\n        int max = 0;\\n        int min = 0;\\n        \\n        for(int i=1; i<nums.size(); i++)\\n        {\\n            if(nums[max] < nums[i])\\n                max = i;\\n            if(nums[min] > nums[i])\\n                min = i;\\n        }\\n        \\n        int a = min + 1;\\n        int b = size1 - min;\\n        \\n        int c = max + 1;\\n        int d = size1 - max;\\n        \\n        int start, start_end, end;\\n        \\n        if(a > c)\\n            start = a;\\n        else\\n            start = c;\\n        \\n        int ans = 0;\\n        \\n        if(a > b)\\n            ans += b;\\n        else\\n            ans += a;\\n        \\n        if(c > d)\\n            ans += d;\\n        else\\n            ans += c;\\n        \\n        start_end = ans;\\n        \\n        if(b > d)\\n            end = b;\\n        else\\n            end = d;\\n        \\n        if(start < start_end)\\n        {\\n            if(start < end)\\n            {\\n                return start;\\n            }\\n            else\\n                return end;\\n        }\\n        else\\n        {\\n            if(start_end < end)\\n                return start_end;\\n            else\\n                return end;\\n            \\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int size1 = nums.size();\\n        if(nums.size() == 1)\\n        {\\n            return 1;\\n        }\\n        \\n        int max = 0;\\n        int min = 0;\\n        \\n        for(int i=1; i<nums.size(); i++)\\n        {\\n            if(nums[max] < nums[i])\\n                max = i;\\n            if(nums[min] > nums[i])\\n                min = i;\\n        }\\n        \\n        int a = min + 1;\\n        int b = size1 - min;\\n        \\n        int c = max + 1;\\n        int d = size1 - max;\\n        \\n        int start, start_end, end;\\n        \\n        if(a > c)\\n            start = a;\\n        else\\n            start = c;\\n        \\n        int ans = 0;\\n        \\n        if(a > b)\\n            ans += b;\\n        else\\n            ans += a;\\n        \\n        if(c > d)\\n            ans += d;\\n        else\\n            ans += c;\\n        \\n        start_end = ans;\\n        \\n        if(b > d)\\n            end = b;\\n        else\\n            end = d;\\n        \\n        if(start < start_end)\\n        {\\n            if(start < end)\\n            {\\n                return start;\\n            }\\n            else\\n                return end;\\n        }\\n        else\\n        {\\n            if(start_end < end)\\n                return start_end;\\n            else\\n                return end;\\n            \\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584510,
                "title": "java-solution-easy-commented-self-explanatory-code",
                "content": "#### **Please Upvote !!!**\\n```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return 1;\\n\\n        int minIdx = 0, maxIdx = 0;\\n        \\n        // find the indices of the minimum and maximum elements in the array\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > nums[maxIdx]) maxIdx = i;\\n            else if (nums[i] < nums[minIdx]) minIdx = i;\\n        }\\n\\n        int minDel = Integer.MAX_VALUE;     // minimum deletions\\n\\n        minDel = Math.min(minDel, Math.max(minIdx, maxIdx) + 1);    // if minIdx and maxIdx lie in first half of nums\\n        minDel = Math.min(minDel, n - Math.min(minIdx, maxIdx));    // if minIdx and maxIdx lie in second half of nums\\n\\n        // if minIdx lies at first half and maxIdx at second half of nums\\n        if (minIdx < n / 2 && maxIdx > n / 2) {                     \\n            minDel = Math.min(minDel, minIdx + 1 + nums.length - maxIdx);\\n        }\\n        \\n        // if maxIdx lies at first half and minIdx at second half of nums\\n        else if (minIdx > n / 2 && maxIdx < n / 2) {              \\n            minDel = Math.min(minDel, maxIdx + 1 + nums.length - minIdx);\\n        }\\n        \\n        return minDel;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return 1;\\n\\n        int minIdx = 0, maxIdx = 0;\\n        \\n        // find the indices of the minimum and maximum elements in the array\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > nums[maxIdx]) maxIdx = i;\\n            else if (nums[i] < nums[minIdx]) minIdx = i;\\n        }\\n\\n        int minDel = Integer.MAX_VALUE;     // minimum deletions\\n\\n        minDel = Math.min(minDel, Math.max(minIdx, maxIdx) + 1);    // if minIdx and maxIdx lie in first half of nums\\n        minDel = Math.min(minDel, n - Math.min(minIdx, maxIdx));    // if minIdx and maxIdx lie in second half of nums\\n\\n        // if minIdx lies at first half and maxIdx at second half of nums\\n        if (minIdx < n / 2 && maxIdx > n / 2) {                     \\n            minDel = Math.min(minDel, minIdx + 1 + nums.length - maxIdx);\\n        }\\n        \\n        // if maxIdx lies at first half and minIdx at second half of nums\\n        else if (minIdx > n / 2 && maxIdx < n / 2) {              \\n            minDel = Math.min(minDel, maxIdx + 1 + nums.length - minIdx);\\n        }\\n        \\n        return minDel;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583742,
                "title": "simple-c-3-case-solution-remove-from-left-or-right-or-from-both-end",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return 1;\\n        int itr1 = min_element(nums.begin(),nums.end())-nums.begin();\\n        int itr2 = max_element(nums.begin(),nums.end())-nums.begin();\\n        int del = max(itr1+1,itr2+1);\\n        del = min((int)max(nums.size()-itr1,nums.size()-itr2),del);\\n        del = min(itr1+(int)nums.size()-itr2+1,del);\\n        del = min(itr2+(int)nums.size()-itr1+1,del);\\n        return del;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return 1;\\n        int itr1 = min_element(nums.begin(),nums.end())-nums.begin();\\n        int itr2 = max_element(nums.begin(),nums.end())-nums.begin();\\n        int del = max(itr1+1,itr2+1);\\n        del = min((int)max(nums.size()-itr1,nums.size()-itr2),del);\\n        del = min(itr1+(int)nums.size()-itr2+1,del);\\n        del = min(itr2+(int)nums.size()-itr1+1,del);\\n        return del;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527666,
                "title": "java-fast-and-easy-to-understand",
                "content": "Having doubts? Ask me in the comment section. If you like this solution please leave an upvote. Thanks for visiting! Happy Coding  ; )\\n# Approach:\\nFinding min and max number is trivial\\n\\nNow, after finding them, there can be three cases:\\n![image](https://assets.leetcode.com/users/images/b413fa74-e005-4ba2-9780-17dcdd60c137_1662264625.41051.jpeg)\\n\\nHere `minIdx = min(min, max)`\\n`maxIdx = max(min, max)`\\nWe have to find min( a+b, c, d);\\nthat would be our answer.\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min = 0, max = 0;\\n        for(int i=1; i<nums.length; i++) {\\n            if(nums[i] < nums[min]) {\\n                min = i;\\n            } \\n            else if(nums[i] > nums[max]) {\\n                max = i;\\n            }\\n        }\\n        int minIdx = Integer.min(min, max), maxIdx = Integer.max(min, max);\\n        return Integer.min(Integer.min(maxIdx+1, nums.length-minIdx), minIdx+1+nums.length-maxIdx);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min = 0, max = 0;\\n        for(int i=1; i<nums.length; i++) {\\n            if(nums[i] < nums[min]) {\\n                min = i;\\n            } \\n            else if(nums[i] > nums[max]) {\\n                max = i;\\n            }\\n        }\\n        int minIdx = Integer.min(min, max), maxIdx = Integer.max(min, max);\\n        return Integer.min(Integer.min(maxIdx+1, nums.length-minIdx), minIdx+1+nums.length-maxIdx);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521529,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int length = nums.length;\\n        int front = 0;\\n        int firstFound;\\n        \\n        if (length == 0) {\\n            return 0;\\n        } \\n        \\n        int min = 0;\\n        int max = 0;\\n        \\n        for(int i = 1; i < length; i++) {\\n            \\n            if (nums[i] > nums[max]) {\\n                max = i;\\n            }\\n            if (nums[i] < nums[min]) {\\n                min = i;\\n            }\\n            \\n        }\\n        \\n        int deletionInBetweenInclusive = Math.abs(min - max) + 1;\\n        int deletionFromFrontExclusive = Math.min(min, max);\\n        int deletionFromBackExclusive = length - Math.max(min, max) -1;\\n        \\n        return Math.min(Math.min(deletionFromFrontExclusive + deletionInBetweenInclusive, deletionFromBackExclusive + deletionInBetweenInclusive),\\n                        deletionFromFrontExclusive + deletionFromBackExclusive + 2);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int length = nums.length;\\n        int front = 0;\\n        int firstFound;\\n        \\n        if (length == 0) {\\n            return 0;\\n        } \\n        \\n        int min = 0;\\n        int max = 0;\\n        \\n        for(int i = 1; i < length; i++) {\\n            \\n            if (nums[i] > nums[max]) {\\n                max = i;\\n            }\\n            if (nums[i] < nums[min]) {\\n                min = i;\\n            }\\n            \\n        }\\n        \\n        int deletionInBetweenInclusive = Math.abs(min - max) + 1;\\n        int deletionFromFrontExclusive = Math.min(min, max);\\n        int deletionFromBackExclusive = length - Math.max(min, max) -1;\\n        \\n        return Math.min(Math.min(deletionFromFrontExclusive + deletionInBetweenInclusive, deletionFromBackExclusive + deletionInBetweenInclusive),\\n                        deletionFromFrontExclusive + deletionFromBackExclusive + 2);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515579,
                "title": "python-faster-100-00-memory-80-31-short",
                "content": "The minimum of  \\n1. removing them from the left and right\\n2. removing the deeper one from the back or the front\\n\\n`\\n\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n\\t\\n        if len(nums) < 3:\\n            return len(nums)\\n\\n        idx_max = nums.index(max(nums))\\n        idx_min = nums.index(min(nums))\\n        if idx_min > idx_max:\\n            idx_min, idx_max = idx_max, idx_min\\n        \\n        cut_lr = (1 + idx_min) + (len(nums) - idx_max)\\n        cut_both = min(idx_max + 1, len(nums) - idx_min)\\n        \\n        return min(cut_lr, cut_both)\\n`",
                "solutionTags": [],
                "code": "The minimum of  \\n1. removing them from the left and right\\n2. removing the deeper one from the back or the front\\n\\n`\\n\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n\\t\\n        if len(nums) < 3:\\n            return len(nums)\\n\\n        idx_max = nums.index(max(nums))\\n        idx_min = nums.index(min(nums))\\n        if idx_min > idx_max:\\n            idx_min, idx_max = idx_max, idx_min\\n        \\n        cut_lr = (1 + idx_min) + (len(nums) - idx_max)\\n        cut_both = min(idx_max + 1, len(nums) - idx_min)\\n        \\n        return min(cut_lr, cut_both)\\n`",
                "codeTag": "Python3"
            },
            {
                "id": 2463919,
                "title": "simple-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)return 1;\\n        int ind1 = min_element(nums.begin(),nums.end()) - nums.begin() + 1;\\n        int ind2 = max_element(nums.begin(),nums.end()) - nums.begin() + 1;\\n        \\n        \\n        int x = max(ind1,ind2);\\n        int y = max(n-ind1+1,n-ind2+1);\\n        int z = ind1 + (n-ind2 + 1);\\n        int w = ind2 + (n-ind1 + 1);\\n        \\n        \\n        return min({w,x,y,z});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)return 1;\\n        int ind1 = min_element(nums.begin(),nums.end()) - nums.begin() + 1;\\n        int ind2 = max_element(nums.begin(),nums.end()) - nums.begin() + 1;\\n        \\n        \\n        int x = max(ind1,ind2);\\n        int y = max(n-ind1+1,n-ind2+1);\\n        int z = ind1 + (n-ind2 + 1);\\n        int w = ind2 + (n-ind1 + 1);\\n        \\n        \\n        return min({w,x,y,z});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457064,
                "title": "javascript-min-option",
                "content": "```\\nvar minimumDeletions = function(nums) {\\n    const len = nums.length;\\n    // find min and max index in array\\n    let minIndex = nums.indexOf(Math.min(...nums));\\n    let maxIndex = nums.indexOf(Math.max(...nums));\\n    // ensure that min is the lower one\\n    if (minIndex > maxIndex) [minIndex, maxIndex] = [maxIndex, minIndex];\\n    // option 1 remove both ends\\n    let both = (len - maxIndex) + (minIndex + 1);\\n    // option 2, just the right\\n    let right = len - minIndex;\\n    // option 3 just the left\\n    let left = maxIndex + 1;\\n    return Math.min(both, right, left);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumDeletions = function(nums) {\\n    const len = nums.length;\\n    // find min and max index in array\\n    let minIndex = nums.indexOf(Math.min(...nums));\\n    let maxIndex = nums.indexOf(Math.max(...nums));\\n    // ensure that min is the lower one\\n    if (minIndex > maxIndex) [minIndex, maxIndex] = [maxIndex, minIndex];\\n    // option 1 remove both ends\\n    let both = (len - maxIndex) + (minIndex + 1);\\n    // option 2, just the right\\n    let right = len - minIndex;\\n    // option 3 just the left\\n    let left = maxIndex + 1;\\n    return Math.min(both, right, left);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2440742,
                "title": "c-easy",
                "content": "**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int size = nums.size();\\n        \\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        \\n        int min_index = 0;\\n        int max_index = 0;\\n        \\n        for( int i=0 ; i <size ;i++){\\n            if( nums[i] < mini ){\\n                mini = nums[i];\\n                min_index = i;\\n            }\\n            \\n            if( nums[i] > maxi ){\\n                maxi = nums[i];\\n                max_index = i;\\n            }\\n            \\n        }\\n                        \\n        int count_front = 0;\\n        int count_back = 0;\\n        int count_mix = 0;\\n        \\n        count_front = max (min_index+1 , max_index+1 ) ;\\n        count_back = max( size - min_index  , size-max_index );\\n        \\n        if(min_index < max_index )\\n            count_mix = min_index+1 + (size - max_index);\\n        else\\n            count_mix = max_index+1 + (size - min_index);\\n        \\n        \\n        int ans = min (count_mix , min(count_front,count_back ) );\\n        \\n        return ans;\\n    }\\n\\t};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int size = nums.size();\\n        \\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        \\n        int min_index = 0;\\n        int max_index = 0;\\n        \\n        for( int i=0 ; i <size ;i++){\\n            if( nums[i] < mini ){\\n                mini = nums[i];\\n                min_index = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2432403,
                "title": "very-simple-java-solution-2ms-100-faster",
                "content": "class Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int max = -100001;\\n        int min = 100001;\\n        int minindex = 0;\\n        int maxindex = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            if(max < nums[i]){\\n                max = nums[i];\\n                maxindex = i;\\n            }\\n            if(min > nums[i]){\\n                min = nums[i];\\n                minindex = i;\\n            }\\n        }\\n        int ans = nums.length+1;\\n        //move both to left find minimum\\n        //move both to right find minimum\\n        // move smaller index value to left and higher index value to right\\n        ans = Math.min(Math.max(minindex,maxindex)+1,ans);\\n        ans = Math.min(ans,nums.length-Math.min(minindex,maxindex));\\n        ans = Math.min(ans,Math.min(minindex,maxindex)+1+nums.length-Math.max(minindex,maxindex));\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int max = -100001;\\n        int min = 100001;\\n        int minindex = 0;\\n        int maxindex = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            if(max < nums[i]){\\n                max = nums[i];\\n                maxindex = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2266367,
                "title": "o-n-with-simple-application-and-understanding-pretty-fast",
                "content": "public int minimumDeletions(int[] nums) {\\n        int deletions = 0;\\n        int localMinima = Integer.MAX_VALUE;\\n        int localMaxima = Integer.MIN_VALUE;\\n        int minIndex = 0;\\n        int maxIndex = 0;\\n\\n        //finding minIndex and maxIndex\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < localMinima){\\n                localMinima = nums[i];\\n                minIndex = i;\\n            }\\n            if(nums[i] > localMaxima ){\\n                localMaxima = nums[i];\\n                maxIndex = i;\\n            }\\n        }\\n        //find minimum and maximum number on number line\\n        int minimum = Math.min(minIndex, maxIndex);\\n        int maximum = Math.max(minIndex,maxIndex);\\n\\n        int mid = nums.length/2;\\n        if(minimum < mid && maximum < mid){\\n            deletions = maximum+1;\\n        }\\n        else if(minimum >mid && maximum > mid){\\n            deletions = nums.length - minimum;\\n        }\\n        else if(maximum == mid && minimum <mid){\\n            deletions = mid+1;\\n        }\\n        else if(minimum == mid && maximum > mid){\\n            deletions = nums.length - mid;\\n        }\\n\\n        else if (minimum == mid && minimum == mid){\\n            deletions = mid+1;\\n        }\\n        else{\\n            deletions = Math.min(nums.length - maximum + minimum+1, Math.min(maximum+1,nums.length-minimum));\\n        }\\n\\n        return deletions;\\n\\n    }\\n",
                "solutionTags": [],
                "code": "public int minimumDeletions(int[] nums) {\\n        int deletions = 0;\\n        int localMinima = Integer.MAX_VALUE;\\n        int localMaxima = Integer.MIN_VALUE;\\n        int minIndex = 0;\\n        int maxIndex = 0;\\n\\n        //finding minIndex and maxIndex\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < localMinima){\\n                localMinima = nums[i];\\n                minIndex = i;\\n            }\\n            if(nums[i] > localMaxima ){\\n                localMaxima = nums[i];\\n                maxIndex = i;\\n            }\\n        }\\n        //find minimum and maximum number on number line\\n        int minimum = Math.min(minIndex, maxIndex);\\n        int maximum = Math.max(minIndex,maxIndex);\\n\\n        int mid = nums.length/2;\\n        if(minimum < mid && maximum < mid){\\n            deletions = maximum+1;\\n        }\\n        else if(minimum >mid && maximum > mid){\\n            deletions = nums.length - minimum;\\n        }\\n        else if(maximum == mid && minimum <mid){\\n            deletions = mid+1;\\n        }\\n        else if(minimum == mid && maximum > mid){\\n            deletions = nums.length - mid;\\n        }\\n\\n        else if (minimum == mid && minimum == mid){\\n            deletions = mid+1;\\n        }\\n        else{\\n            deletions = Math.min(nums.length - maximum + minimum+1, Math.min(maximum+1,nums.length-minimum));\\n        }\\n\\n        return deletions;\\n\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2253436,
                "title": "simple-solution-with-explanation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1 || n == 2)\\n        {\\n            return n;\\n        }\\n        \\n        int minidx = 0,maxidx = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] > nums[maxidx])\\n                maxidx = i;\\n            else if (nums[i] < nums[minidx])\\n                minidx = i;\\n        }\\n        // Total elements deleted \\n        // If deleted from left\\n        int l = max(minidx +1 , maxidx + 1);\\n        \\n        // If deleted from right\\n        int r = max(n - minidx, n - maxidx);\\n        \\n        // If deleted from both sides\\n        int both = n - (max(maxidx,minidx) - min(maxidx,minidx) +1) + 2;\\n        return min(l,min(r,both));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1 || n == 2)\\n        {\\n            return n;\\n        }\\n        \\n        int minidx = 0,maxidx = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] > nums[maxidx])\\n                maxidx = i;\\n            else if (nums[i] < nums[minidx])\\n                minidx = i;\\n        }\\n        // Total elements deleted \\n        // If deleted from left\\n        int l = max(minidx +1 , maxidx + 1);\\n        \\n        // If deleted from right\\n        int r = max(n - minidx, n - maxidx);\\n        \\n        // If deleted from both sides\\n        int both = n - (max(maxidx,minidx) - min(maxidx,minidx) +1) + 2;\\n        return min(l,min(r,both));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208746,
                "title": "c-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n=nums.size(), maxi=INT_MIN, mini=INT_MAX, si, ei;\\n        for(int i=0; i<n; i++) {\\n            if(maxi<nums[i]) {\\n                maxi=nums[i]; si=i;\\n            }\\n            if(mini>nums[i]) {\\n                mini=nums[i]; ei=i;\\n            }\\n        }\\n        if(si>ei) swap(si,ei);\\n        return min({si+1+n-ei,ei+1,n-si});\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n=nums.size(), maxi=INT_MIN, mini=INT_MAX, si, ei;\\n        for(int i=0; i<n; i++) {\\n            if(maxi<nums[i]) {\\n                maxi=nums[i]; si=i;\\n            }\\n            if(mini>nums[i]) {\\n                mini=nums[i]; ei=i;\\n            }\\n        }\\n        if(si>ei) swap(si,ei);\\n        return min({si+1+n-ei,ei+1,n-si});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206579,
                "title": "python-solution-with-explanation",
                "content": "```class Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        \\n        if len(nums)==1:\\n            return 1\\n        \\n        x = nums.index(max(nums))\\n        y = nums.index(min(nums))\\n        l = len(nums)\\n        \\n        \\n        return min(max(x+1,y+1), max(l-x,l-y), x+1+l-y, y+1+l-x)\\n    \\n    # max(x+1,y+1) -> length from the left side of the list till the number with the highest index\\n    # max(l-x,l-y) -> length from the right side of the list till the number with the highest index\\n    # x+1+l-y -> assuming the smallest number is in the left half of the list and the biggest on the right half, x+1 is the length from left end and l-y is the length from the right end\\n    # y+1+l-x -> assuming the biggest number is in the left half of the list and the smallest on the right half, y+1 is the length from left end and l-x is the length from the right end\\n    \\n    #These are the four possibilities, from which we compare and get the smallest length i.e. no. of cards that need to be picked.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        \\n        if len(nums)==1:\\n            return 1\\n        \\n        x = nums.index(max(nums))\\n        y = nums.index(min(nums))\\n        l = len(nums)\\n        \\n        \\n        return min(max(x+1,y+1), max(l-x,l-y), x+1+l-y, y+1+l-x)\\n    \\n    # max(x+1,y+1) -> length from the left side of the list till the number with the highest index\\n    # max(l-x,l-y) -> length from the right side of the list till the number with the highest index\\n    # x+1+l-y -> assuming the smallest number is in the left half of the list and the biggest on the right half, x+1 is the length from left end and l-y is the length from the right end\\n    # y+1+l-x -> assuming the biggest number is in the left half of the list and the smallest on the right half, y+1 is the length from left end and l-x is the length from the right end\\n    \\n    #These are the four possibilities, from which we compare and get the smallest length i.e. no. of cards that need to be picked.\\n",
                "codeTag": "Java"
            },
            {
                "id": 2206391,
                "title": "easy-c-direct-solution-3-cases",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int max1=max_element(nums.begin(),nums.end())-nums.begin();//index of maximum element\\n        int min1=min_element(nums.begin(),nums.end())-nums.begin();//index of minimum element\\n        int op1=-1,op2=-1,op3=-1,n=nums.size(),ans;\\n        int maxi=max(max1,min1);\\n        int mini=min(max1,min1);\\n        //maxi and mini are set to avoid wrong answer in case index of maximum element comes before index of minimum element\\n        op1=maxi+1;//first operation removing from front\\n        op2=n-mini;//second operation removing from back\\n        op3=mini+(n-maxi+1);//third operation removing from front as well as back\\n        ans=min(op1,op2);\\n        ans=min(ans,op3);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int max1=max_element(nums.begin(),nums.end())-nums.begin();//index of maximum element\\n        int min1=min_element(nums.begin(),nums.end())-nums.begin();//index of minimum element\\n        int op1=-1,op2=-1,op3=-1,n=nums.size(),ans;\\n        int maxi=max(max1,min1);\\n        int mini=min(max1,min1);\\n        //maxi and mini are set to avoid wrong answer in case index of maximum element comes before index of minimum element\\n        op1=maxi+1;//first operation removing from front\\n        op2=n-mini;//second operation removing from back\\n        op3=mini+(n-maxi+1);//third operation removing from front as well as back\\n        ans=min(op1,op2);\\n        ans=min(ans,op3);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203790,
                "title": "clear-cases-java-greedy",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int minIndex = nums.length - 1, maxIndex = 0;\\n        int maxValue = Integer.MIN_VALUE, minValue = Integer.MAX_VALUE;\\n        for (int index = 0; index < nums.length; index++) {\\n            if (nums[index] < minValue) {\\n                minValue = nums[index];\\n                minIndex = index;\\n            }\\n            \\n            if (nums[index] > maxValue) {\\n                maxValue = nums[index];\\n                maxIndex = index;\\n            }\\n        }\\n        \\n        if (minIndex == maxIndex) {\\n\\t\\t\\t// when both are equal, which ever side gives min is the answer.\\n\\t\\t\\t// 0 ... index or index ... nums.length\\n            return Math.min(nums.length - minIndex, minIndex + 1);\\n        } else {\\n            if (minIndex > maxIndex) { // this is required, if minIndex is found at the higher index than the maxIndex\\n                int swapHelper = minIndex;\\n                minIndex = maxIndex;\\n                maxIndex = swapHelper;\\n            }\\n            \\n\\t\\t\\t// 1. All left means that let\\'s plan to delete from left side of the minIndex and maxIndex we found. so which ever\\n\\t\\t\\t// is maximum we need to return back\\n\\t\\t\\t// 2. All right means that let\\'s plan to delete from right side of minIndex and maxIndex, same as (1. All Left)\\n\\t\\t\\t// 3. Let\\'s plan to delete from both the side, meaning start from 0 ... minIndex + maxIndex ... nums.length\\n            return Math.min(\\n                Math.min(\\n                    // 1. all left\\n                    Math.max(minIndex + 1, maxIndex + 1),\\n                    // 2. all right\\n                    Math.max(nums.length - minIndex, nums.length - maxIndex)\\n                ),\\n                // 3. both left and right\\n                nums.length - maxIndex + 1 + minIndex\\n            );\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int minIndex = nums.length - 1, maxIndex = 0;\\n        int maxValue = Integer.MIN_VALUE, minValue = Integer.MAX_VALUE;\\n        for (int index = 0; index < nums.length; index++) {\\n            if (nums[index] < minValue) {\\n                minValue = nums[index];\\n                minIndex = index;\\n            }\\n            \\n            if (nums[index] > maxValue) {\\n                maxValue = nums[index];\\n                maxIndex = index;\\n            }\\n        }\\n        \\n        if (minIndex == maxIndex) {\\n\\t\\t\\t// when both are equal, which ever side gives min is the answer.\\n\\t\\t\\t// 0 ... index or index ... nums.length\\n            return Math.min(nums.length - minIndex, minIndex + 1);\\n        } else {\\n            if (minIndex > maxIndex) { // this is required, if minIndex is found at the higher index than the maxIndex\\n                int swapHelper = minIndex;\\n                minIndex = maxIndex;\\n                maxIndex = swapHelper;\\n            }\\n            \\n\\t\\t\\t// 1. All left means that let\\'s plan to delete from left side of the minIndex and maxIndex we found. so which ever\\n\\t\\t\\t// is maximum we need to return back\\n\\t\\t\\t// 2. All right means that let\\'s plan to delete from right side of minIndex and maxIndex, same as (1. All Left)\\n\\t\\t\\t// 3. Let\\'s plan to delete from both the side, meaning start from 0 ... minIndex + maxIndex ... nums.length\\n            return Math.min(\\n                Math.min(\\n                    // 1. all left\\n                    Math.max(minIndex + 1, maxIndex + 1),\\n                    // 2. all right\\n                    Math.max(nums.length - minIndex, nums.length - maxIndex)\\n                ),\\n                // 3. both left and right\\n                nums.length - maxIndex + 1 + minIndex\\n            );\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200487,
                "title": "o-n-simple-solution-using-max-and-min-c",
                "content": "Please do **UPVOTE** if you understand and like my solution/approach. It means a lot to me :)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int> &nums) {\\n        int n = (int)(nums.size());\\n        int mx = INT_MIN, mn = INT_MAX;\\n        int max_idx = -1, min_idx = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > mx) {\\n                mx = nums[i];\\n                max_idx = i;\\n            }\\n            if (nums[i] < mn) {\\n                mn = nums[i];\\n                min_idx = i;\\n            }\\n        }\\n        int lcnt_max = max_idx + 1, rcnt_max = n - max_idx;\\n        int lcnt_min = min_idx + 1, rcnt_min = n - min_idx;\\n        int mn1 = min(max(lcnt_max, lcnt_min), (lcnt_max + rcnt_min));\\n        int mn2 = min(max(rcnt_max, rcnt_min), (lcnt_min + rcnt_max));\\n        return min(mn1, mn2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int> &nums) {\\n        int n = (int)(nums.size());\\n        int mx = INT_MIN, mn = INT_MAX;\\n        int max_idx = -1, min_idx = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] > mx) {\\n                mx = nums[i];\\n                max_idx = i;\\n            }\\n            if (nums[i] < mn) {\\n                mn = nums[i];\\n                min_idx = i;\\n            }\\n        }\\n        int lcnt_max = max_idx + 1, rcnt_max = n - max_idx;\\n        int lcnt_min = min_idx + 1, rcnt_min = n - min_idx;\\n        int mn1 = min(max(lcnt_max, lcnt_min), (lcnt_max + rcnt_min));\\n        int mn2 = min(max(rcnt_max, rcnt_min), (lcnt_min + rcnt_max));\\n        return min(mn1, mn2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200364,
                "title": "c-straight-and-simple-concept-o-n-for-finding-index",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<=2)return n;\\n        int ans=0;\\n        int i=max_element(nums.begin(),nums.end())-nums.begin();\\n        int j=min_element(nums.begin(),nums.end())-nums.begin();\\n        ans=max(i,j)+1;// ----->|\\n        int x=(n-min(i,j));// |<-----\\n        int z=min(i,j)+1;int y=(n-max(i,j));// ---->| + |<----\\n        ans=min(ans,min(x,(z+y)));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<=2)return n;\\n        int ans=0;\\n        int i=max_element(nums.begin(),nums.end())-nums.begin();\\n        int j=min_element(nums.begin(),nums.end())-nums.begin();\\n        ans=max(i,j)+1;// ----->|\\n        int x=(n-min(i,j));// |<-----\\n        int z=min(i,j)+1;int y=(n-max(i,j));// ---->| + |<----\\n        ans=min(ans,min(x,(z+y)));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199751,
                "title": "go-one-pass-o-n-why-slow",
                "content": "```\\nfunc minimumDeletions(nums []int) int {\\n    if len(nums) < 2 { return len(nums)}\\n    \\n    min, minIdx, max, maxIdx := nums[0], 0, nums[0], 0\\n    \\n    for i := 0; i < len(nums); i++ {\\n        if nums[i] < min {\\n            min = nums[i]\\n            minIdx = i\\n        } \\n        \\n        if nums[i] > max {\\n            max = nums[i]\\n            maxIdx = i\\n        }\\n    }\\n    \\n    var left, right int\\n    \\n    if minIdx < maxIdx {\\n        left, right = minIdx, maxIdx\\n    } else {\\n        left, right = maxIdx, minIdx\\n    }\\n\\n    return sumOfTwoMin(left + 1, right - left, len(nums) - right)\\n}\\n\\nfunc sumOfTwoMin(a, b, c int) int {\\n    if a >= b && a >= c {\\n        return b + c\\n    } else if b >= a && b >= c {\\n        return a + c\\n    } else {\\n        return a + b\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumDeletions(nums []int) int {\\n    if len(nums) < 2 { return len(nums)}\\n    \\n    min, minIdx, max, maxIdx := nums[0], 0, nums[0], 0\\n    \\n    for i := 0; i < len(nums); i++ {\\n        if nums[i] < min {\\n            min = nums[i]\\n            minIdx = i\\n        } \\n        \\n        if nums[i] > max {\\n            max = nums[i]\\n            maxIdx = i\\n        }\\n    }\\n    \\n    var left, right int\\n    \\n    if minIdx < maxIdx {\\n        left, right = minIdx, maxIdx\\n    } else {\\n        left, right = maxIdx, minIdx\\n    }\\n\\n    return sumOfTwoMin(left + 1, right - left, len(nums) - right)\\n}\\n\\nfunc sumOfTwoMin(a, b, c int) int {\\n    if a >= b && a >= c {\\n        return b + c\\n    } else if b >= a && b >= c {\\n        return a + c\\n    } else {\\n        return a + b\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2199320,
                "title": "c-simple-solution",
                "content": "## Solution\\n\\nLanguage: **C++**\\n\\n```c++\\nclass Solution {\\npublic:\\n \\xA0 \\xA0int minimumDeletions(vector<int>& nums) {\\n \\xA0 \\xA0 \\xA0 \\xA0int mn_idx = min_element(nums.begin(), nums.end()) - nums.begin();\\n \\xA0 \\xA0 \\xA0 \\xA0int mx_idx = max_element(nums.begin(), nums.end()) - nums.begin();\\n \\xA0 \\xA0 \\xA0 \\xA0int choice1 = max(mn_idx, mx_idx) + 1; // taking both from the start\\n \\xA0 \\xA0 \\xA0 \\xA0int choice2 = nums.size() - min(mn_idx, mx_idx); // taking both from the end\\n \\xA0 \\xA0 \\xA0 \\xA0int choice3 = \\xA0min(mn_idx, mx_idx) + 1 + nums.size() - max(mn_idx, mx_idx); // taking one from start and one from the end.\\n \\xA0 \\xA0 \\xA0 \\xA0return min({choice1, choice2, choice3});\\n \\xA0  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n \\xA0 \\xA0int minimumDeletions(vector<int>& nums) {\\n \\xA0 \\xA0 \\xA0 \\xA0int mn_idx = min_element(nums.begin(), nums.end()) - nums.begin();\\n \\xA0 \\xA0 \\xA0 \\xA0int mx_idx = max_element(nums.begin(), nums.end()) - nums.begin();\\n \\xA0 \\xA0 \\xA0 \\xA0int choice1 = max(mn_idx, mx_idx) + 1; // taking both from the start\\n \\xA0 \\xA0 \\xA0 \\xA0int choice2 = nums.size() - min(mn_idx, mx_idx); // taking both from the end\\n \\xA0 \\xA0 \\xA0 \\xA0int choice3 = \\xA0min(mn_idx, mx_idx) + 1 + nums.size() - max(mn_idx, mx_idx); // taking one from start and one from the end.\\n \\xA0 \\xA0 \\xA0 \\xA0return min({choice1, choice2, choice3});\\n \\xA0  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132175,
                "title": "c-easy-peasy-lemon-squeezy",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minimumDeletions(vector<int>& nums) {\\n\\t\\t\\t\\tint n = nums.size();\\n\\t\\t\\t\\tint a = nums[0];\\n\\t\\t\\t\\tint aindex = 0;\\n\\t\\t\\t\\tint b = nums[0];\\n\\t\\t\\t\\tint bindex = 0;\\n\\n\\t\\t\\t\\t// a = max\\n\\t\\t\\t\\t// b = min\\n\\n\\t\\t\\t\\tfor(int i=1; i<n; i++){\\n\\t\\t\\t\\t\\tif(nums[i]>a){\\n\\t\\t\\t\\t\\t\\ta = nums[i];\\n\\t\\t\\t\\t\\t\\taindex = i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(nums[i]<b){\\n\\t\\t\\t\\t\\t\\tb = nums[i];\\n\\t\\t\\t\\t\\t\\tbindex = i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tint x = min(aindex+1,n-aindex);\\n\\t\\t\\t\\tint y = min(bindex+1,n-bindex);\\n\\t\\t\\t\\tint z = max(aindex,bindex)+1;\\n\\t\\t\\t\\tint w = n-min(aindex,bindex);\\n\\t\\t\\t\\tint res =  min({x+y,z,w});\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minimumDeletions(vector<int>& nums) {\\n\\t\\t\\t\\tint n = nums.size();\\n\\t\\t\\t\\tint a = nums[0];\\n\\t\\t\\t\\tint aindex = 0;\\n\\t\\t\\t\\tint b = nums[0];\\n\\t\\t\\t\\tint bindex = 0;\\n\\n\\t\\t\\t\\t// a = max\\n\\t\\t\\t\\t// b = min\\n\\n\\t\\t\\t\\tfor(int i=1; i<n; i++){\\n\\t\\t\\t\\t\\tif(nums[i]>a){\\n\\t\\t\\t\\t\\t\\ta = nums[i];\\n\\t\\t\\t\\t\\t\\taindex = i;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2098116,
                "title": "short-and-easy-soln-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int minE = 0;\\n        int maxE = 0;\\n        int a = nums[0];\\n        int b= nums[0];\\n        \\n        for(int i=1;i<nums.size();i++){\\n            if(a>nums[i]){\\n                a=nums[i];\\n                minE=i;\\n            }\\n            if(b<nums[i]){\\n                b=nums[i];\\n                maxE = i;\\n            }    \\n        }\\n        int n = nums.size();\\n        int one = max(minE,maxE)+1;\\n        int two =max(n-minE,n-maxE);\\n        int three = minE+1+(n-maxE);\\n        int four = maxE+1 + (n-minE);\\n        \\n        int ans =min(one,min(two,min(three,four)));\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int minE = 0;\\n        int maxE = 0;\\n        int a = nums[0];\\n        int b= nums[0];\\n        \\n        for(int i=1;i<nums.size();i++){\\n            if(a>nums[i]){\\n                a=nums[i];\\n                minE=i;\\n            }\\n            if(b<nums[i]){\\n                b=nums[i];\\n                maxE = i;\\n            }    \\n        }\\n        int n = nums.size();\\n        int one = max(minE,maxE)+1;\\n        int two =max(n-minE,n-maxE);\\n        int three = minE+1+(n-maxE);\\n        int four = maxE+1 + (n-minE);\\n        \\n        int ans =min(one,min(two,min(three,four)));\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066534,
                "title": "easy-c-solution",
                "content": "```\\nint minimumDeletions(vector<int>& nums) {\\n        if (nums.size() <= 2)\\n            return nums.size();\\n        else if (nums.size() == 3)\\n            return 2;\\n        else {\\n            int n = nums.size();\\n\\t\\t\\t\\n            // getting indices of min and max elements in the array\\n            int maxIndex = max_element(nums.begin(), nums.end()) - nums.begin();\\n            int minIndex = min_element(nums.begin(), nums.end()) - nums.begin();\\n            \\n\\t\\t\\t// a should come before b\\n            int a = min(maxIndex, minIndex);\\n            int b = max(maxIndex, minIndex);\\n                        \\n            int leftCut = b-0+1;\\n            int rightCut = (n-1)-a+1;\\n            int bothSideCut = a-0+1 + (n-1)-b+1;\\n            \\n\\t\\t\\t// returning the minimum of all 3\\n            return min(leftCut, min(rightCut, bothSideCut));\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimumDeletions(vector<int>& nums) {\\n        if (nums.size() <= 2)\\n            return nums.size();\\n        else if (nums.size() == 3)\\n            return 2;\\n        else {\\n            int n = nums.size();\\n\\t\\t\\t\\n            // getting indices of min and max elements in the array\\n            int maxIndex = max_element(nums.begin(), nums.end()) - nums.begin();\\n            int minIndex = min_element(nums.begin(), nums.end()) - nums.begin();\\n            \\n\\t\\t\\t// a should come before b\\n            int a = min(maxIndex, minIndex);\\n            int b = max(maxIndex, minIndex);\\n                        \\n            int leftCut = b-0+1;\\n            int rightCut = (n-1)-a+1;\\n            int bothSideCut = a-0+1 + (n-1)-b+1;\\n            \\n\\t\\t\\t// returning the minimum of all 3\\n            return min(leftCut, min(rightCut, bothSideCut));\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2060933,
                "title": "java-compare-all-cases",
                "content": "```\\nclass Solution {\\n\\n  public int minimumDeletions(int[] nums) {\\n    int minIdx = 0;\\n    int maxIdx = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n      int num = nums[i];\\n      if (num > nums[maxIdx]) {\\n        maxIdx = i;\\n      }\\n      if (num < nums[minIdx]) {\\n        minIdx = i;\\n      }\\n    }\\n    int a = Math.max(minIdx, maxIdx) + 1;\\n    int b = nums.length - Math.min(minIdx, maxIdx);\\n    int c = minIdx > maxIdx\\n      ? maxIdx + 1 + (nums.length - minIdx)\\n      : minIdx + 1 + (nums.length - maxIdx);\\n    int res = Math.min(a, b);\\n    res = Math.min(res, c);\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n  public int minimumDeletions(int[] nums) {\\n    int minIdx = 0;\\n    int maxIdx = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n      int num = nums[i];\\n      if (num > nums[maxIdx]) {\\n        maxIdx = i;\\n      }\\n      if (num < nums[minIdx]) {\\n        minIdx = i;\\n      }\\n    }\\n    int a = Math.max(minIdx, maxIdx) + 1;\\n    int b = nums.length - Math.min(minIdx, maxIdx);\\n    int c = minIdx > maxIdx\\n      ? maxIdx + 1 + (nums.length - minIdx)\\n      : minIdx + 1 + (nums.length - maxIdx);\\n    int res = Math.min(a, b);\\n    res = Math.min(res, c);\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052777,
                "title": "c-simple-problem-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& v) {\\n        int ma = INT_MIN, mi = INT_MAX, l = v.size();\\n        int ind1, ind2;\\n        for(int i=0; i<l; ++i){\\n            if(v[i]>ma){\\n                ma = v[i];\\n                ind1 = i;\\n            }\\n            if(v[i]<mi){\\n                mi = v[i];\\n                ind2 = i;\\n            }\\n        }\\n        if(ind1<ind2){\\n            return min({ind2+1,l+ind1-ind2+1,l-ind1});\\n        }\\n        else{\\n            return min({ind1+1,l+ind2-ind1+1,l-ind2});\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& v) {\\n        int ma = INT_MIN, mi = INT_MAX, l = v.size();\\n        int ind1, ind2;\\n        for(int i=0; i<l; ++i){\\n            if(v[i]>ma){\\n                ma = v[i];\\n                ind1 = i;\\n            }\\n            if(v[i]<mi){\\n                mi = v[i];\\n                ind2 = i;\\n            }\\n        }\\n        if(ind1<ind2){\\n            return min({ind2+1,l+ind1-ind2+1,l-ind1});\\n        }\\n        else{\\n            return min({ind1+1,l+ind2-ind1+1,l-ind2});\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009850,
                "title": "2091-removing-minimum-and-maximum-from-array-c",
                "content": "#simple approach\\n#all conditions checked in compact form\\n#vote if you get helped\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        \\n        int big = INT_MIN;\\n        int b;                  // to store index of largest element\\n        int small = INT_MAX;\\n        int s;                  // to store index of smallest element\\n        int n = nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i] > big){\\n                big = nums[i];\\n                b = i+1;\\n            }\\n            if(nums[i] < small){\\n                small = nums[i];\\n                s = i+1;\\n            }\\n        }\\n        \\n        int x = min(max(b,s), max(n-b+1, n-s+1));\\n        int y = min(b+n-s+1, s+n-b+1);\\n        \\n        return min(x, y);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        \\n        int big = INT_MIN;\\n        int b;                  // to store index of largest element\\n        int small = INT_MAX;\\n        int s;                  // to store index of smallest element\\n        int n = nums.size();\\n        \\n        for(int i=0; i<n; i++){\\n            if(nums[i] > big){\\n                big = nums[i];\\n                b = i+1;\\n            }\\n            if(nums[i] < small){\\n                small = nums[i];\\n                s = i+1;\\n            }\\n        }\\n        \\n        int x = min(max(b,s), max(n-b+1, n-s+1));\\n        int y = min(b+n-s+1, s+n-b+1);\\n        \\n        return min(x, y);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2009732,
                "title": "multiple-cases",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        min_index = nums.index(min(nums))\\n        max_index = nums.index(max(nums))\\n        return min( max(min_index,max_index)+1, n - min(min_index,max_index), min_index+n-max_index+1,max_index+n-min_index+1  )\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        min_index = nums.index(min(nums))\\n        max_index = nums.index(max(nums))\\n        return min( max(min_index,max_index)+1, n - min(min_index,max_index), min_index+n-max_index+1,max_index+n-min_index+1  )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970680,
                "title": "from-start-end-or-both",
                "content": "**Intuition:**\\nThere is not much we could do except for three options.\\nAlso which elemnt is max or min doesn\\'t matter what matters is the index\\nCase 1: Either remove the first element from start and second element from end\\nCase 2: Remove both the elements from the end\\nCase 3:Remove both the elements from the start\\n\\n\\tdef minimumDeletions(self, nums: List[int]) -> int:\\n\\t\\t\\t#we have three options to remove the elements \\n\\t\\t\\t#one from both side\\n\\t\\t\\t#two from start \\n\\t\\t\\t#three from end\\n\\t\\t\\t#we actually dont care which index is of min and which is of max\\n\\t\\t\\t#what we care is which index is largers and which is smaller\\n\\t\\t\\tindexa = nums.index(min(nums))\\n\\t\\t\\tindexb = nums.index(max(nums))\\n\\t\\t\\t#swapping so that indexa always comes first \\n\\t\\t\\tif indexb<indexa:\\n\\t\\t\\t\\tindexa, indexb = indexb, indexa\\n\\t\\t\\tN = len(nums)\\n\\t\\t\\t#min of case1,2,3\\n\\t\\t\\treturn min((indexa+1) + (N-indexb), indexb+1, N-indexa)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "**Intuition:**\\nThere is not much we could do except for three options.\\nAlso which elemnt is max or min doesn\\'t matter what matters is the index\\nCase 1: Either remove the first element from start and second element from end\\nCase 2: Remove both the elements from the end\\nCase 3:Remove both the elements from the start\\n\\n\\tdef minimumDeletions(self, nums: List[int]) -> int:\\n\\t\\t\\t#we have three options to remove the elements \\n\\t\\t\\t#one from both side\\n\\t\\t\\t#two from start \\n\\t\\t\\t#three from end\\n\\t\\t\\t#we actually dont care which index is of min and which is of max\\n\\t\\t\\t#what we care is which index is largers and which is smaller\\n\\t\\t\\tindexa = nums.index(min(nums))\\n\\t\\t\\tindexb = nums.index(max(nums))\\n\\t\\t\\t#swapping so that indexa always comes first \\n\\t\\t\\tif indexb<indexa:\\n\\t\\t\\t\\tindexa, indexb = indexb, indexa\\n\\t\\t\\tN = len(nums)\\n\\t\\t\\t#min of case1,2,3\\n\\t\\t\\treturn min((indexa+1) + (N-indexb), indexb+1, N-indexa)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1880395,
                "title": "java-solution-of-3-cases-remove-from-left-right-or-both-sides",
                "content": "There are 3 cases for this problem.\\n\\n1. You can delete from left to right.\\n2. You can delete from right to left.\\n3. You can delete from both sides.\\n\\nYou need to find the indexes of minimum and maximum numbers. After that it is comparison of three edge cases.\\n\\n```\\npublic int minimumDeletions(int[] nums) {\\n\\n        int n = nums.length;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int minIndex = 0;\\n        int maxIndex = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < min) {\\n                min = nums[i];\\n                minIndex = i;\\n            }\\n            if (nums[i] > max) {\\n                max = nums[i];\\n                maxIndex = i;\\n            }\\n        }\\n\\n        int firstCase = 0;\\n        int secondCase = 0;\\n        int thirdCase = 0;\\n\\n        if (minIndex > maxIndex) {\\n            firstCase = minIndex + 1;\\n            secondCase = n - maxIndex;\\n            thirdCase = maxIndex + 1 + (n - minIndex);\\n        } else {\\n            firstCase = maxIndex + 1;\\n            secondCase = n - minIndex;\\n            thirdCase = minIndex + 1 + (n - maxIndex);\\n        }\\n\\n        return Math.min(firstCase, Math.min(secondCase, thirdCase));\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minimumDeletions(int[] nums) {\\n\\n        int n = nums.length;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int minIndex = 0;\\n        int maxIndex = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] < min) {\\n                min = nums[i];\\n                minIndex = i;\\n            }\\n            if (nums[i] > max) {\\n                max = nums[i];\\n                maxIndex = i;\\n            }\\n        }\\n\\n        int firstCase = 0;\\n        int secondCase = 0;\\n        int thirdCase = 0;\\n\\n        if (minIndex > maxIndex) {\\n            firstCase = minIndex + 1;\\n            secondCase = n - maxIndex;\\n            thirdCase = maxIndex + 1 + (n - minIndex);\\n        } else {\\n            firstCase = maxIndex + 1;\\n            secondCase = n - minIndex;\\n            thirdCase = minIndex + 1 + (n - maxIndex);\\n        }\\n\\n        return Math.min(firstCase, Math.min(secondCase, thirdCase));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1747906,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return 1;\\n        int mini=INT_MAX,maxi=INT_MIN;\\n        for(auto x:nums){\\n            mini = min(mini,x);\\n            maxi = max(maxi,x);\\n        }\\n        int idx1,idx2;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==mini)idx1=i;\\n            if(nums[i]==maxi)idx2=i;\\n        }\\n        //cout<<idx1<<\" \"<<idx2;\\n        int a = idx1+1+n-idx2; \\n        int b = idx2+1+n-idx1;\\n        int c = min(max(n-idx1,n-idx2),max(idx1,idx2)+1);\\n        int ans = min(c,min(a,b));\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n// DO A DRY RUN FOR BETTER UNDERSTANDING",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return 1;\\n        int mini=INT_MAX,maxi=INT_MIN;\\n        for(auto x:nums){\\n            mini = min(mini,x);\\n            maxi = max(maxi,x);\\n        }\\n        int idx1,idx2;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==mini)idx1=i;\\n            if(nums[i]==maxi)idx2=i;\\n        }\\n        //cout<<idx1<<\" \"<<idx2;\\n        int a = idx1+1+n-idx2; \\n        int b = idx2+1+n-idx1;\\n        int c = min(max(n-idx1,n-idx2),max(idx1,idx2)+1);\\n        int ans = min(c,min(a,b));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1736613,
                "title": "java-greedy-solution-explained",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int max = 0,min = 0;\\n        for(int i = 1; i < nums.length; i++) // We would find the index of Max & Min Elements here\\n        {\\n            max = nums[i] > nums[max] ? i : max;\\n            min = nums[i] < nums[min] ? i : min;\\n        }\\n        int front = Math.max(max,min) + 1; // To check the case when we remove elements from the Front\\n        int back = nums.length - Math.min(max,min); // To check the case when we remove elements from the Back\\n        int both = Math.min(max,min) + 1 + nums.length - Math.max(min,max); // To check the case when we remove elements from both ends\\n        return Math.min(both, Math.min(front, back)); // return the minimum of all\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int max = 0,min = 0;\\n        for(int i = 1; i < nums.length; i++) // We would find the index of Max & Min Elements here\\n        {\\n            max = nums[i] > nums[max] ? i : max;\\n            min = nums[i] < nums[min] ? i : min;\\n        }\\n        int front = Math.max(max,min) + 1; // To check the case when we remove elements from the Front\\n        int back = nums.length - Math.min(max,min); // To check the case when we remove elements from the Back\\n        int both = Math.min(max,min) + 1 + nums.length - Math.max(min,max); // To check the case when we remove elements from both ends\\n        return Math.min(both, Math.min(front, back)); // return the minimum of all\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1717792,
                "title": "simple-java-solution-with-comment-explanations-greedy",
                "content": "```\\nclass Solution {\\n     public int minimumDeletions(int[] nums) {\\n        if(nums.length == 1) return 1;\\n         \\n        int maxInd = 0;\\n        int minInd = 0;\\n        int len = nums.length;\\n         // find max & min value index\\n        for(int i = 0;i<len;i++){\\n            if(nums[i]<nums[minInd]) minInd  = i;\\n            if(nums[i]>nums[maxInd]) maxInd  = i;\\n        }\\n         // swap the indices if maxInd lies before minInd\\n        if(minInd>maxInd){\\n            int temp = minInd;\\n            minInd = maxInd;\\n            maxInd = temp;\\n        }\\n        /* there are  3 possibilites\\n         1. ele,ele,min,ele,ele,max,ele ---> remove=(min+1)+(len-max)\\n         2. ele,ele,max,min,ele,ele,ele ---> remove=(len-min)\\n         3. ele,min,max,ele,ele,ele,ele----> remove =(max+1)\\n            return minimum of these three will be answer\\n         */\\n         return Math.min(minInd+1+len-maxInd,Math.min(len-minInd,maxInd+1));\\n    }\\n}",
                "solutionTags": [
                    "Array",
                    "Greedy"
                ],
                "code": "class Solution {\\n     public int minimumDeletions(int[] nums) {\\n        if(nums.length == 1) return 1;\\n         \\n        int maxInd = 0;\\n        int minInd = 0;\\n        int len = nums.length;\\n         // find max & min value index\\n        for(int i = 0;i<len;i++){\\n            if(nums[i]<nums[minInd]) minInd  = i;\\n            if(nums[i]>nums[maxInd]) maxInd  = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1685910,
                "title": "c-4-line-code-very-easy-3-simple-case",
                "content": "```\\nint minimumDeletions(vector<int>& nums) {\\n        int x=min_element(nums.begin(),nums.end())-nums.begin();\\n        int y=max_element(nums.begin(),nums.end())-nums.begin();\\n        int n=nums.size();\\n        if(x>y) swap(x,y);\\n        int ans1=(y+1); // if both of them are removed from left side of array\\n        int ans2=(n-x);  // if both of them are removed from right side of array\\n        int ans3=(x+1+n-y); // if one elemnt is removed from left and one from right \\n        return min(ans3,min(ans2,ans1));\\n    }",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nint minimumDeletions(vector<int>& nums) {\\n        int x=min_element(nums.begin(),nums.end())-nums.begin();\\n        int y=max_element(nums.begin(),nums.end())-nums.begin();\\n        int n=nums.size();\\n        if(x>y) swap(x,y);\\n        int ans1=(y+1); // if both of them are removed from left side of array\\n        int ans2=(n-x);  // if both of them are removed from right side of array\\n        int ans3=(x+1+n-y); // if one elemnt is removed from left and one from right \\n        return min(ans3,min(ans2,ans1));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1642748,
                "title": "rust-simple-implementation-with-comments",
                "content": "```\\nimpl Solution {\\n    pub fn minimum_deletions(nums: Vec<i32>) -> i32 {\\n        if nums.len() <= 2 {\\n            return nums.len() as i32;\\n        }\\n\\n        let mut idx_max = 0;\\n        let mut idx_min = 0;\\n        for (i, n) in nums.iter().enumerate() {\\n            if *n < nums[idx_min] {\\n                idx_min = i;\\n            }\\n            if *n > nums[idx_max] {\\n                idx_max = i;\\n            }\\n        }\\n        \\n        // remove from left\\n        let mut result = idx_max.max(idx_min) + 1;\\n        // remove from right\\n        result = result.min(nums.len() - idx_min.min(idx_max));\\n        // remove from left and right\\n        result = result.min((idx_max.min(idx_min) + 1) + nums.len() - idx_min.max(idx_max));\\n        \\n        result as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_deletions(nums: Vec<i32>) -> i32 {\\n        if nums.len() <= 2 {\\n            return nums.len() as i32;\\n        }\\n\\n        let mut idx_max = 0;\\n        let mut idx_min = 0;\\n        for (i, n) in nums.iter().enumerate() {\\n            if *n < nums[idx_min] {\\n                idx_min = i;\\n            }\\n            if *n > nums[idx_max] {\\n                idx_max = i;\\n            }\\n        }\\n        \\n        // remove from left\\n        let mut result = idx_max.max(idx_min) + 1;\\n        // remove from right\\n        result = result.min(nums.len() - idx_min.min(idx_max));\\n        // remove from left and right\\n        result = result.min((idx_max.min(idx_min) + 1) + nums.len() - idx_min.max(idx_max));\\n        \\n        result as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635940,
                "title": "c-3-cases-o-n-commented-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumDeletions(vector<int>& nums) {\\n        int n = (int) nums.size();\\n        \\n        // finding Index of Minimum and Maximum element\\n        int minInd = min_element(nums.begin(), nums.end()) - nums.begin() + 1; \\n        int maxInd = max_element(nums.begin(), nums.end()) - nums.begin() + 1; \\n        \\n        /*\\n            Case 1 : Removing both element from front \\n                     max(minInd, maxInd)\\n            Case 2 : Removing both element from Back\\n                     n - min(minInd, maxInd) + 1\\n            Case 3 : Removing One element from front and One element from the Back\\n                     min(minInd,maxInd) + n - max(maxInd, minInd) + 1\\n                     \\n            Answer = min(Case 1, Case 2, Case 3);\\n        */\\n        return min({max(minInd, maxInd), n-min(minInd, maxInd)+1, \\n                       min(minInd,maxInd)+n-max(maxInd,minInd)+1});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumDeletions(vector<int>& nums) {\\n        int n = (int) nums.size();\\n        \\n        // finding Index of Minimum and Maximum element\\n        int minInd = min_element(nums.begin(), nums.end()) - nums.begin() + 1; \\n        int maxInd = max_element(nums.begin(), nums.end()) - nums.begin() + 1; \\n        \\n        /*\\n            Case 1 : Removing both element from front \\n                     max(minInd, maxInd)\\n            Case 2 : Removing both element from Back\\n                     n - min(minInd, maxInd) + 1\\n            Case 3 : Removing One element from front and One element from the Back\\n                     min(minInd,maxInd) + n - max(maxInd, minInd) + 1\\n                     \\n            Answer = min(Case 1, Case 2, Case 3);\\n        */\\n        return min({max(minInd, maxInd), n-min(minInd, maxInd)+1, \\n                       min(minInd,maxInd)+n-max(maxInd,minInd)+1});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625106,
                "title": "python-3-5-lines-90-faster-3-diff-methods",
                "content": "Method 1: Fastest\\n```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        \\n        front_idx_maxi = nums.index(max(nums))\\n        front_idx_mini = nums.index(min(nums))\\n        \\n        n = len(nums)\\n                        \\n        li = sorted([front_idx_maxi,front_idx_mini])\\n        \\n        return min(li[1]+1,n-li[0],(li[0]+1)+(n-li[1]))   \\n```\\nMethod 2:\\nLess fast but can understand the one above\\n```\\n#front --> \\n        #bacck --> \\n        #front and back-->\\n        #ans is minimum of these\\n        front_idx_maxi = nums.index(max(nums))\\n        front_idx_mini = nums.index(min(nums))\\n        \\n        n = len(nums)\\n                        \\n        li = sorted([front_idx_maxi,front_idx_mini])\\n        front = li[1]+1\\n        back = n-li[0]\\n        mixed = (li[0]+1)+(n-li[1])\\n        \\n        return min(front,back,mixed)\\n```\\nMethod 3:\\nBrute force(my initial approach)\\n```\\n#front --> \\n        #bacck --> \\n        #front and back-->\\n        #ans is minimum of these\\n        maxi = max(nums)\\n        mini = min(nums)\\n        n = len(nums)\\n        \\n        back_idx_maxi = back_idx_mini = front_idx_maxi = front_idx_mini =  -1\\n        \\n        for i in range(n):\\n            if maxi==nums[i]:\\n                front_idx_maxi = i+1\\n                back_idx_maxi = (n-i)\\n            if mini==nums[i]:\\n                front_idx_mini = i+1\\n                back_idx_mini = (n-i)\\n        \\n        front_swaps  = max(front_idx_maxi,front_idx_mini)\\n        back_swaps = max(back_idx_maxi,back_idx_mini)\\n        dq_swaps = min((front_idx_maxi+back_idx_mini),(back_idx_maxi+front_idx_mini))\\n        \\n        return min(front_swaps,back_swaps,dq_swaps)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        \\n        front_idx_maxi = nums.index(max(nums))\\n        front_idx_mini = nums.index(min(nums))\\n        \\n        n = len(nums)\\n                        \\n        li = sorted([front_idx_maxi,front_idx_mini])\\n        \\n        return min(li[1]+1,n-li[0],(li[0]+1)+(n-li[1]))   \\n```\n```\\n#front --> \\n        #bacck --> \\n        #front and back-->\\n        #ans is minimum of these\\n        front_idx_maxi = nums.index(max(nums))\\n        front_idx_mini = nums.index(min(nums))\\n        \\n        n = len(nums)\\n                        \\n        li = sorted([front_idx_maxi,front_idx_mini])\\n        front = li[1]+1\\n        back = n-li[0]\\n        mixed = (li[0]+1)+(n-li[1])\\n        \\n        return min(front,back,mixed)\\n```\n```\\n#front --> \\n        #bacck --> \\n        #front and back-->\\n        #ans is minimum of these\\n        maxi = max(nums)\\n        mini = min(nums)\\n        n = len(nums)\\n        \\n        back_idx_maxi = back_idx_mini = front_idx_maxi = front_idx_mini =  -1\\n        \\n        for i in range(n):\\n            if maxi==nums[i]:\\n                front_idx_maxi = i+1\\n                back_idx_maxi = (n-i)\\n            if mini==nums[i]:\\n                front_idx_mini = i+1\\n                back_idx_mini = (n-i)\\n        \\n        front_swaps  = max(front_idx_maxi,front_idx_mini)\\n        back_swaps = max(back_idx_maxi,back_idx_mini)\\n        dq_swaps = min((front_idx_maxi+back_idx_mini),(back_idx_maxi+front_idx_mini))\\n        \\n        return min(front_swaps,back_swaps,dq_swaps)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614629,
                "title": "c-single-pass-solution-explained-100-time-70-space",
                "content": "This problem is much easier than it looks, once you figure out the core logic.\\n\\nFirst of all, we want to find the positions of our minimum and maximum values - knowing that all values are distinct, we also know we will only found one of them; and we should do that in a single pass, if possible.\\n\\nOnce there, we will have to figure out which one of the two is closer to the border, remove it and do the same with the remaining one, considering an updated border (because of the cells we removed before).\\n\\nIn order to so, we will start creating a few support variables:\\n* `lPos` and `hPos` are our two pointers to the lower and higher value we will find - both set to `0` as a default;\\n* `len` will store the length of the input vector;\\n* `d1` and `d2` will store the distance from the border of each point.\\n\\nWe will then do our single pass on `nums` and for each number `n` we will find there, we will compare it to `low` or `high` (both initialised to the value of the first element, since `lPos` and `hPos` are already pointing there, it also means we can potentially skip some checks turning the second condition into an `else if`, instead of an `if`) and update our two pointers accordingly.\\n\\nOnce done, we will make sure for the sake of simplicity that `lPos` is never after `hPos`: we can do that since it does not really matter to us if we remove the minimum first or the other way around - we just have to do so in the cheapest way.\\n\\nKnowing this, we also know that `d1` will be the distance from the leftmost border and `d2` from the rightmost.\\n\\nWe want them to remove the lesser of them and:\\n* if it is `d1`, then we will `return` it plus the minimum between `hPos - d1` (the distance of `hPos` from the leftmost border) and `d2` (the distance of `hPos` from the rightmost border). Plus `1`, since we are using a `0`-indexed series;\\n* alternatively, we will `return` `d2` plus the minimum between `d1 + 1` (since removing from the left, we need to remove the element as well, as mentioned above) and `hPos - lPos`, which is the distance from the rightmost border, simplified from `len - d2 - lPos` and thus `len - (len - hPos) - lPos`).\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        // support variables\\n        if (nums.size() < 3) return nums.size();\\n        int lPos = 0, hPos = 0, len = nums.size(), d1, d2;\\n        // parsing nums to find the positions of min and max elements\\n        for (int i = 0, low = nums[0], high = nums[0], n, lmt = nums.size(); i < lmt; i++) {\\n            n = nums[i];\\n            if (n < low) {\\n                low = n;\\n                lPos = i;\\n            }\\n            else if (n > high) {\\n                high = n;\\n                hPos = i;\\n            }\\n        }\\n        // making sure lPos comes first\\n        if (lPos > hPos) swap(lPos, hPos);\\n        d1 = lPos, d2 = len - hPos;\\n        // first case, we remove lPos first\\n        if (d1 < d2) {\\n            return d1 + min(hPos - d1, d2) + 1;\\n        }\\n        // second case, we remove hPos first\\n        return d2 + min(d1 + 1, hPos - lPos); // the latter being len - (len - hPos) - lPos\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        // support variables\\n        if (nums.size() < 3) return nums.size();\\n        int lPos = 0, hPos = 0, len = nums.size(), d1, d2;\\n        // parsing nums to find the positions of min and max elements\\n        for (int i = 0, low = nums[0], high = nums[0], n, lmt = nums.size(); i < lmt; i++) {\\n            n = nums[i];\\n            if (n < low) {\\n                low = n;\\n                lPos = i;\\n            }\\n            else if (n > high) {\\n                high = n;\\n                hPos = i;\\n            }\\n        }\\n        // making sure lPos comes first\\n        if (lPos > hPos) swap(lPos, hPos);\\n        d1 = lPos, d2 = len - hPos;\\n        // first case, we remove lPos first\\n        if (d1 < d2) {\\n            return d1 + min(hPos - d1, d2) + 1;\\n        }\\n        // second case, we remove hPos first\\n        return d2 + min(d1 + 1, hPos - lPos); // the latter being len - (len - hPos) - lPos\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613178,
                "title": "java-get-minimum-of-3-cases-o-n",
                "content": "First pass through the array to find the indices of the min and max numbers. Then, arrange these two indices into `minToDelete` and `maxToDelete`, since the index of the max number may be before the index of the min number.\\n\\nThen there will be 3 cases that can remove both numbers. You may remove all the numbers from the index 0 to `maxToDelete`, or remove from `minToDelete` until the end, or finally remove from both ends (0 to `minToDelete` and `maxToDelete` until the end. Return the minimum of these 3 cases.\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int minIndex = 0;\\n        int max = Integer.MIN_VALUE;\\n        int maxIndex = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            if (num < min) {\\n                min = num;\\n                minIndex = i;\\n            }\\n            if (num > max) {\\n                max = num;\\n                maxIndex = i;\\n            }\\n        }\\n        int minToDelete = Math.min(minIndex, maxIndex);\\n        int maxToDelete = Math.max(minIndex, maxIndex);\\n        int bothSides = minToDelete  + (nums.length - maxToDelete) + 1;\\n        int front = maxToDelete + 1;\\n        int back = nums.length - minToDelete;\\n        return Math.min(Math.min(bothSides, front), back);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int minIndex = 0;\\n        int max = Integer.MIN_VALUE;\\n        int maxIndex = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            if (num < min) {\\n                min = num;\\n                minIndex = i;\\n            }\\n            if (num > max) {\\n                max = num;\\n                maxIndex = i;\\n            }\\n        }\\n        int minToDelete = Math.min(minIndex, maxIndex);\\n        int maxToDelete = Math.max(minIndex, maxIndex);\\n        int bothSides = minToDelete  + (nums.length - maxToDelete) + 1;\\n        int front = maxToDelete + 1;\\n        int back = nums.length - minToDelete;\\n        return Math.min(Math.min(bothSides, front), back);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608606,
                "title": "faster-than-99-95-java-easy-with-self-explanatory-vars",
                "content": "```\\n\\n public int minimumDeletions(int[] nums) {\\n        \\n        int min = Integer.MAX_VALUE ; \\n        \\n        int max = Integer.MIN_VALUE ; \\n        \\n        int minIndex = 0 ; \\n        \\n        \\n        int maxIndex = 0 ; \\n        \\n        \\n        \\n        for(int i=0 ; i<nums.length ; i++){\\n            \\n            if(min>nums[i]){\\n                min = nums[i];\\n                minIndex = i ; \\n            }\\n            \\n            if(max<nums[i]){\\n                max = nums[i];\\n                maxIndex = i ; \\n            }\\n            \\n            \\n        }\\n        \\n        int n = nums.length-1  ; \\n        \\n        \\n        int distFromLeft = Math.max(minIndex,maxIndex)+1 ; \\n        \\n        int distFromRight = n - Math.min(minIndex,maxIndex) + 1 ; \\n        \\n        int distBetween = n - Math.max(maxIndex, minIndex) + Math.min(maxIndex,minIndex) + 2 ;\\n        \\n        \\n        return Math.min(distBetween,Math.min(distFromLeft,distFromRight));\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n public int minimumDeletions(int[] nums) {\\n        \\n        int min = Integer.MAX_VALUE ; \\n        \\n        int max = Integer.MIN_VALUE ; \\n        \\n        int minIndex = 0 ; \\n        \\n        \\n        int maxIndex = 0 ; \\n        \\n        \\n        \\n        for(int i=0 ; i<nums.length ; i++){\\n            \\n            if(min>nums[i]){\\n                min = nums[i];\\n                minIndex = i ; \\n            }\\n            \\n            if(max<nums[i]){\\n                max = nums[i];\\n                maxIndex = i ; \\n            }\\n            \\n            \\n        }\\n        \\n        int n = nums.length-1  ; \\n        \\n        \\n        int distFromLeft = Math.max(minIndex,maxIndex)+1 ; \\n        \\n        int distFromRight = n - Math.min(minIndex,maxIndex) + 1 ; \\n        \\n        int distBetween = n - Math.max(maxIndex, minIndex) + Math.min(maxIndex,minIndex) + 2 ;\\n        \\n        \\n        return Math.min(distBetween,Math.min(distFromLeft,distFromRight));\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1608530,
                "title": "python-easy-one-pass-o-n-solution",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        maxi, mini, n = 0,0,len(nums)\\n        \\n        for i in range(n):\\n            if nums[i] < nums[mini]: mini = i\\n            if nums[i] > nums[maxi]: maxi = i\\n        i = min(mini,maxi)\\n        j = max(maxi,mini)\\n        return min(j+1, n-i , i+1+n-j)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        maxi, mini, n = 0,0,len(nums)\\n        \\n        for i in range(n):\\n            if nums[i] < nums[mini]: mini = i\\n            if nums[i] > nums[maxi]: maxi = i\\n        i = min(mini,maxi)\\n        j = max(maxi,mini)\\n        return min(j+1, n-i , i+1+n-j)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608318,
                "title": "easy-java-solution-explanation",
                "content": "```\\n\\t//the array logic =>\\n\\t//this can be done in 3 ways :-\\n\\t//1. delete element from left only \\n\\t//2. delete from right only\\n\\t//3. find the closeness of element from both ends ie alternate deletion\\n\\t//   out of all the operatin the min is our answer .\\n\\t    public int minimumDeletions(int[] nums) {\\n\\t        int min=Integer.MAX_VALUE;\\n\\t        int max=Integer.MIN_VALUE;\\n\\t        int mini=-1;\\n\\t        int maxi=-1;\\n\\t        for(int i=0;i<nums.length;i++){\\n\\t            if(nums[i]>max){\\n\\t                max=Math.max(nums[i],max);\\n\\t                maxi=i;\\n\\t            }\\n\\t            if(nums[i]<min){\\n\\t                min=Math.min(nums[i],min);\\n\\t                mini=i;\\n\\t            }\\n\\t        }\\n\\t        if(maxi>mini){\\n\\t            int op1=maxi+1;//left\\n\\t            int op2=nums.length-mini;//right\\n\\t            int op3=mini+1+nums.length-maxi;//from ends\\n\\t            return Math.min(op1,Math.min(op2,op3));\\n\\t        }\\n\\t        \\n\\t        else{\\n\\t            int op1=mini+1;\\n\\t            int op2=nums.length-maxi;\\n\\t            int op3=maxi+1+nums.length-mini;\\n\\t            return Math.min(op1,Math.min(op2,op3));\\t                \\n\\t            }\\n\\t    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t//the array logic =>\\n\\t//this can be done in 3 ways :-\\n\\t//1. delete element from left only \\n\\t//2. delete from right only\\n\\t//3. find the closeness of element from both ends ie alternate deletion\\n\\t//   out of all the operatin the min is our answer .\\n\\t    public int minimumDeletions(int[] nums) {\\n\\t        int min=Integer.MAX_VALUE;\\n\\t        int max=Integer.MIN_VALUE;\\n\\t        int mini=-1;\\n\\t        int maxi=-1;\\n\\t        for(int i=0;i<nums.length;i++){\\n\\t            if(nums[i]>max){\\n\\t                max=Math.max(nums[i],max);\\n\\t                maxi=i;\\n\\t            }\\n\\t            if(nums[i]<min){\\n\\t                min=Math.min(nums[i],min);\\n\\t                mini=i;\\n\\t            }\\n\\t        }\\n\\t        if(maxi>mini){\\n\\t            int op1=maxi+1;//left\\n\\t            int op2=nums.length-mini;//right\\n\\t            int op3=mini+1+nums.length-maxi;//from ends\\n\\t            return Math.min(op1,Math.min(op2,op3));\\n\\t        }\\n\\t        \\n\\t        else{\\n\\t            int op1=mini+1;\\n\\t            int op2=nums.length-maxi;\\n\\t            int op3=maxi+1+nums.length-mini;\\n\\t            return Math.min(op1,Math.min(op2,op3));\\t                \\n\\t            }\\n\\t    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1607534,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==0 || n==1) return n;\\n        int mx = max_element(begin(nums),end(nums)) - nums.begin();\\n        int mn = min_element(begin(nums),end(nums)) - nums.begin();\\n        int res = 0;\\n        if(mx<mn) res = min(min(mn+1,mx + 1 + n - mn),n - mx);\\n        else if(mn<mx) res = min(min(mx + 1,mn + 1 + n - mx),n - mn);\\n        else res = min(mx + 1,n - mx);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==0 || n==1) return n;\\n        int mx = max_element(begin(nums),end(nums)) - nums.begin();\\n        int mn = min_element(begin(nums),end(nums)) - nums.begin();\\n        int res = 0;\\n        if(mx<mn) res = min(min(mn+1,mx + 1 + n - mn),n - mx);\\n        else if(mn<mx) res = min(min(mx + 1,mn + 1 + n - mx),n - mn);\\n        else res = min(mx + 1,n - mx);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607111,
                "title": "easy-java",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min = nums[0];\\n        int max = nums[0];\\n        int minIdx = 0, maxIdx = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n                maxIdx = i;\\n            } else if (nums[i] < min) {\\n                min = nums[i];\\n                minIdx = i;\\n            } \\n        }\\n        \\n        int smaller = Math.min(minIdx, maxIdx);\\n        int bigger = Math.max(minIdx, maxIdx);\\n        \\n        // the min of three options.\\n        return Math.min(Math.min(bigger + 1, nums.length - smaller), nums.length - bigger + smaller + 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min = nums[0];\\n        int max = nums[0];\\n        int minIdx = 0, maxIdx = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n                maxIdx = i;\\n            } else if (nums[i] < min) {\\n                min = nums[i];\\n                minIdx = i;\\n            } \\n        }\\n        \\n        int smaller = Math.min(minIdx, maxIdx);\\n        int bigger = Math.max(minIdx, maxIdx);\\n        \\n        // the min of three options.\\n        return Math.min(Math.min(bigger + 1, nums.length - smaller), nums.length - bigger + smaller + 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605275,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        i=nums.index(min(nums))\\n        j=nums.index(max(nums))\\n        n=len(nums)\\n        if i>j:\\n            temp=i\\n            i=j\\n            j=temp\\n        return min(i+1+n-j,j+1,n-i)\\n```\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        i=nums.index(min(nums))\\n        j=nums.index(max(nums))\\n        n=len(nums)\\n        if i>j:\\n            temp=i\\n            i=j\\n            j=temp\\n        return min(i+1+n-j,j+1,n-i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605270,
                "title": "explined-and-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        // int min = *min_element(nums.begin(),nums.end());\\n        // int max = *max_element(nums.begin(),nums.end());\\n        int n = nums.size();\\n        \\n        int i = min_element(nums.begin(),nums.end()) - nums.begin();\\n        int j = max_element(nums.begin(),nums.end()) - nums.begin();\\n        \\n        if(i>j) swap(i,j);\\n        \\n        //way no 1 : deletele from the front and from the back\\n        int way1 = (i+1) + (n-j); //total no of deleted elements\\n        \\n        //way no 2 : delelete all the way from back\\n        int way2 = (n-i); //total no of deleted elemnts\\n            \\n        //way no  3 : delete all the way from front\\n        int way3 = (j+1); // total mo of deleted elemts\\n        \\n        return min(way1,min(way2,way3));\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        // int min = *min_element(nums.begin(),nums.end());\\n        // int max = *max_element(nums.begin(),nums.end());\\n        int n = nums.size();\\n        \\n        int i = min_element(nums.begin(),nums.end()) - nums.begin();\\n        int j = max_element(nums.begin(),nums.end()) - nums.begin();\\n        \\n        if(i>j) swap(i,j);\\n        \\n        //way no 1 : deletele from the front and from the back\\n        int way1 = (i+1) + (n-j); //total no of deleted elements\\n        \\n        //way no 2 : delelete all the way from back\\n        int way2 = (n-i); //total no of deleted elemnts\\n            \\n        //way no  3 : delete all the way from front\\n        int way3 = (j+1); // total mo of deleted elemts\\n        \\n        return min(way1,min(way2,way3));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1605249,
                "title": "java-easy-just-do-what-they-have-said-to-do",
                "content": "```\\npublic int minimumDeletions(int[] nums) {\\n    int minInd = 0, maxInd = 0, len = nums.length;\\n    for (int i = 1; i < len; i++) {\\n        if (nums[i] < nums[minInd])\\n            minInd = i;\\n        else if (nums[i] > nums[maxInd])\\n            maxInd = i;\\n    }\\n    \\n    // ......|.........|........\\n    //   d1       d2        d3   \\n    int d1 = Math.min(minInd, maxInd)+1;\\n    int d3 = len-1-Math.max(minInd, maxInd)+1;\\n    int d2 = len-d1-d3+1;\\n    \\n    return d1 < d3 ? d1 + Math.min(d2, d3) : d3 + Math.min(d1, d2); \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minimumDeletions(int[] nums) {\\n    int minInd = 0, maxInd = 0, len = nums.length;\\n    for (int i = 1; i < len; i++) {\\n        if (nums[i] < nums[minInd])\\n            minInd = i;\\n        else if (nums[i] > nums[maxInd])\\n            maxInd = i;\\n    }\\n    \\n    // ......|.........|........\\n    //   d1       d2        d3   \\n    int d1 = Math.min(minInd, maxInd)+1;\\n    int d3 = len-1-Math.max(minInd, maxInd)+1;\\n    int d2 = len-d1-d3+1;\\n    \\n    return d1 < d3 ? d1 + Math.min(d2, d3) : d3 + Math.min(d1, d2); \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1604267,
                "title": "easy-python-solution",
                "content": "We need to consider three cases:\\n1) We remove both max and min from front.\\n2) We remove both max and min from back.\\n3) We remove max from front and min from back or max from back and min from front.\\n\\n\\t\\tclass Solution:\\n\\t\\tdef minimumDeletions(self, arr: List[int]) -> int:\\n\\t\\t\\td=defaultdict()\\n\\t\\t\\tn=len(arr)\\n\\t\\t\\tfor i,a in enumerate(arr):\\n\\t\\t\\t\\td[a]=i\\n\\t\\t\\tmaxi=max(arr)\\n\\t\\t\\tmini=min(arr)\\n\\t\\t\\trem_front=max((d[maxi]+1),(d[mini]+1))\\n\\t\\t\\trem_back=max(n-d[mini],n-d[maxi])\\n\\t\\t\\tboth_mix=min(((d[maxi]+1)+(n-d[mini])),((d[mini]+1)+(n-d[maxi])))\\n\\t\\t\\treturn(min(rem_front,rem_back,both_mix))\\n\\nNote :- When we are removing from front we do idx+1 because lets say max/min is at idx 1 we will have to remove 2 elements, this is handeled for removal from back as we do n-idx where n=len(arr).",
                "solutionTags": [],
                "code": "We need to consider three cases:\\n1) We remove both max and min from front.\\n2) We remove both max and min from back.\\n3) We remove max from front and min from back or max from back and min from front.\\n\\n\\t\\tclass Solution:\\n\\t\\tdef minimumDeletions(self, arr: List[int]) -> int:\\n\\t\\t\\td=defaultdict()\\n\\t\\t\\tn=len(arr)\\n\\t\\t\\tfor i,a in enumerate(arr):\\n\\t\\t\\t\\td[a]=i\\n\\t\\t\\tmaxi=max(arr)\\n\\t\\t\\tmini=min(arr)\\n\\t\\t\\trem_front=max((d[maxi]+1),(d[mini]+1))\\n\\t\\t\\trem_back=max(n-d[mini],n-d[maxi])\\n\\t\\t\\tboth_mix=min(((d[maxi]+1)+(n-d[mini])),((d[mini]+1)+(n-d[maxi])))\\n\\t\\t\\treturn(min(rem_front,rem_back,both_mix))\\n\\nNote :- When we are removing from front we do idx+1 because lets say max/min is at idx 1 we will have to remove 2 elements, this is handeled for removal from back as we do n-idx where n=len(arr).",
                "codeTag": "Java"
            },
            {
                "id": 1604067,
                "title": "java-o-n-time-o-1-space-easy-to-understand-detailed-explanation",
                "content": "```\\nInuition: .A deletion is defined as either removing an element from the front of the array or removing an element from the back of the array.\\n         \\n          .Therefore to remove an element be it max element in array or min element in array. We have to remove it from that side(left or right)\\n           which is closer to the ends(left or right).\\n    \\n         .To be more specific for nums[indx] we need to make choice for \\n          min(left side removal--- indx+1 ele. to be removed, right side removal--- len-indx ele. to be removed).\\n\\t\\t  .Any corrections, suggestions and optimizations to code are welcomed :)\\n```\\n```\\n//Time complexity: O(N), N is the length of them nums array\\n// Auxiliary Space: O(1)\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, minIndx = -1, maxIndx = -1, len = nums.length, indx = 0;\\n        if(len <= 2){\\n            return len;\\n        }\\n        for(int num : nums){\\n            if(min > num){\\n                min = Math.min(min, num);\\n                minIndx = indx;\\n            }\\n            if(max < num){\\n                max = Math.max(max, num);\\n                maxIndx = indx;\\n            }\\n            indx++;            \\n        }\\n        int totalDel = 0;\\n        // Math.min(Math.max(minIndx+1,  maxIndx+1), Math.max(len-minIndx, len-maxIndx))-- for cases like[0,-4,19,1,8,-2,-3,5]\\n        // Math.min(minIndx+1+len-maxIndx, maxIndx+1+len-minIndx))---for cases like [2,10,7,5,4,1,8,6]        \\n       return totalDel = Math.min(Math.min(Math.max(minIndx+1,  maxIndx+1), Math.max(len-minIndx, len-maxIndx)),\\n\\t   Math.min(minIndx+1+len-maxIndx, maxIndx+1+len-minIndx));      \\n    }\\n}\\n```\\nIf you found this post helpful, please like and comment so that it can reach others and help them :)",
                "solutionTags": [],
                "code": "```\\nInuition: .A deletion is defined as either removing an element from the front of the array or removing an element from the back of the array.\\n         \\n          .Therefore to remove an element be it max element in array or min element in array. We have to remove it from that side(left or right)\\n           which is closer to the ends(left or right).\\n    \\n         .To be more specific for nums[indx] we need to make choice for \\n          min(left side removal--- indx+1 ele. to be removed, right side removal--- len-indx ele. to be removed).\\n\\t\\t  .Any corrections, suggestions and optimizations to code are welcomed :)\\n```\n```\\n//Time complexity: O(N), N is the length of them nums array\\n// Auxiliary Space: O(1)\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, minIndx = -1, maxIndx = -1, len = nums.length, indx = 0;\\n        if(len <= 2){\\n            return len;\\n        }\\n        for(int num : nums){\\n            if(min > num){\\n                min = Math.min(min, num);\\n                minIndx = indx;\\n            }\\n            if(max < num){\\n                max = Math.max(max, num);\\n                maxIndx = indx;\\n            }\\n            indx++;            \\n        }\\n        int totalDel = 0;\\n        // Math.min(Math.max(minIndx+1,  maxIndx+1), Math.max(len-minIndx, len-maxIndx))-- for cases like[0,-4,19,1,8,-2,-3,5]\\n        // Math.min(minIndx+1+len-maxIndx, maxIndx+1+len-minIndx))---for cases like [2,10,7,5,4,1,8,6]        \\n       return totalDel = Math.min(Math.min(Math.max(minIndx+1,  maxIndx+1), Math.max(len-minIndx, len-maxIndx)),\\n\\t   Math.min(minIndx+1+len-maxIndx, maxIndx+1+len-minIndx));      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603056,
                "title": "c-easy-to-understand-commented-code",
                "content": "class Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\nvector<pair<int,int>> v;\\n        for(int i=0;i<nums.size();i++){\\n            v.push_back({nums[i],i});\\n        }\\n        sort(v.begin(),v.end());\\n        int n=nums.size();\\n        int mn=v[0].second;\\n        int mx=v[n-1].second;        \\n       \\n        //Both are deleted from front.\\n        int c1=max(mx+1,mn+1);\\n        //Both are deleted from back.\\n        int c2=max(n-mx,n-mn);\\n        //mn deleted from front| mx deleted from back.\\n        int c3= mn+1+(n-mx);\\n        //mx deleted from front| mn deleted from back.\\n        int c4=mx+1+(n-mn);\\n        return min({c1,c2,c3,c4});\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\nvector<pair<int,int>> v;\\n        for(int i=0;i<nums.size();i++){\\n            v.push_back({nums[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 1600893,
                "title": "simple-c-solution",
                "content": "There will be 3 cases \\n1- if elements are removed from front\\n2- if elements are removed from back\\n3- if elements are removed from both front and back, mininimum of these two cases will give the ans.\\n```\\nint minimumDeletions(vector<int>& nums) {\\n        int n=nums.size();\\n        int li=0, si=0;\\n        int l=nums[0], s=nums[0];\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i]>l){\\n                l=nums[i];\\n                li=i;\\n            }\\n            if(s>nums[i]){\\n                s=nums[i];\\n                si=i;\\n            }\\n        }\\n        int a=max(li,si)+1;\\n        int b=max(n-si,n-li);\\n        int c=min(li,si)+1+ n- max(li,si);\\n        return min(a,min(b,c));\\n\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "There will be 3 cases \\n1- if elements are removed from front\\n2- if elements are removed from back\\n3- if elements are removed from both front and back, mininimum of these two cases will give the ans.\\n```\\nint minimumDeletions(vector<int>& nums) {\\n        int n=nums.size();\\n        int li=0, si=0;\\n        int l=nums[0], s=nums[0];\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i]>l){\\n                l=nums[i];\\n                li=i;\\n            }\\n            if(s>nums[i]){\\n                s=nums[i];\\n                si=i;\\n            }\\n        }\\n        int a=max(li,si)+1;\\n        int b=max(n-si,n-li);\\n        int c=min(li,si)+1+ n- max(li,si);\\n        return min(a,min(b,c));\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1600755,
                "title": "simple-o-n-solution-2ms-faster-than-100",
                "content": "```\\n\\n```class Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min = 0;\\n        int max = 0;\\n        for(int i=1; i<nums.length; i++)\\n        {\\n            if(nums[i]<nums[min])\\n            {\\n                min = i;\\n            }\\n            if(nums[i]>nums[max])\\n                max = i;\\n        }\\n        if(min>max)\\n        {\\n            int temp = min;\\n            min = max;\\n            max = temp;\\n        }\\n        int left = max + 1;\\n        int right =nums.length - min;\\n        int both = (min+1) + (nums.length-max);\\n        return left>right?(right>both?both:right):(left>both?both:left);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1600716,
                "title": "very-easy-c-solution",
                "content": "class Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int v=0;\\n        int res=INT_MIN, ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            ans=min(ans,nums[i]);\\n            res=max(res,nums[i]);\\n        }\\n        int ka=0,kb=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==res) ka=i;\\n            if(nums[i]==ans) kb=i;\\n        }\\n        int f=max(ka,kb)+1; //removing only from front\\n        int l=nums.size()-min(ka,kb);  //removing only from end\\n        int r =(min(ka, kb)+1)+(nums.size()-max(ka,kb)); // removing from both front and back\\n        \\n        return min(min(f,l),r);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int v=0;\\n        int res=INT_MIN, ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            ans=min(ans,nums[i]);\\n            res=max(res,nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1600709,
                "title": "python-greedy-o-n",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        x=min(nums)\\n        y=max(nums)\\n        x=nums.index(x)\\n        y=nums.index(y)\\n        n=len(nums)\\n        x+=1\\n        y+=1\\n        return min(max(x,y),max(n-x+1,n-y+1),x+(n-y+1),y+(n-x+1))\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        x=min(nums)\\n        y=max(nums)\\n        x=nums.index(x)\\n        y=nums.index(y)\\n        n=len(nums)\\n        x+=1\\n        y+=1\\n        return min(max(x,y),max(n-x+1,n-y+1),x+(n-y+1),y+(n-x+1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600392,
                "title": "rust-minimum-of-the-three-cases",
                "content": "```\\nimpl Solution {\\n    // Time complexity: O(N).\\n    // Space complexity: O(1).\\n    pub fn minimum_deletions(nums: Vec<i32>) -> i32 {\\n        let mut min_n = nums[0];\\n        let mut max_n = nums[0];\\n        let mut min_i = 0;\\n        let mut max_i = 0;\\n\\n        for i in 1..nums.len() {\\n            if nums[i] > max_n {\\n                max_n = nums[i];\\n                max_i = i;\\n            } else if nums[i] < min_n {\\n                min_n = nums[i];\\n                min_i = i\\n            }\\n        }\\n\\n        // Three cases:\\n        // 1) both numbers are in the left half - deletions are only from the left side,\\n        // 2) both numbers are in the right half - deletions are only from the right side,\\n        // 3) the numbers are in different halves - deletions are from both sides.\\n\\n        // Case 1 solution.\\n        let max_left_distance = max_i.max(min_i) + 1;\\n\\n        // Case 2 solution.\\n        let max_right_distance = nums.len() - max_i.min(min_i);\\n\\n        // Case 3 solution.\\n        let min_left_distance = max_i.min(min_i) + 1;\\n        let min_right_distance = nums.len() - max_i.max(min_i);\\n\\n        // Find the minimum of the three cases.\\n        (min_left_distance + min_right_distance).min(max_left_distance.min(max_right_distance)) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    // Time complexity: O(N).\\n    // Space complexity: O(1).\\n    pub fn minimum_deletions(nums: Vec<i32>) -> i32 {\\n        let mut min_n = nums[0];\\n        let mut max_n = nums[0];\\n        let mut min_i = 0;\\n        let mut max_i = 0;\\n\\n        for i in 1..nums.len() {\\n            if nums[i] > max_n {\\n                max_n = nums[i];\\n                max_i = i;\\n            } else if nums[i] < min_n {\\n                min_n = nums[i];\\n                min_i = i\\n            }\\n        }\\n\\n        // Three cases:\\n        // 1) both numbers are in the left half - deletions are only from the left side,\\n        // 2) both numbers are in the right half - deletions are only from the right side,\\n        // 3) the numbers are in different halves - deletions are from both sides.\\n\\n        // Case 1 solution.\\n        let max_left_distance = max_i.max(min_i) + 1;\\n\\n        // Case 2 solution.\\n        let max_right_distance = nums.len() - max_i.min(min_i);\\n\\n        // Case 3 solution.\\n        let min_left_distance = max_i.min(min_i) + 1;\\n        let min_right_distance = nums.len() - max_i.max(min_i);\\n\\n        // Find the minimum of the three cases.\\n        (min_left_distance + min_right_distance).min(max_left_distance.min(max_right_distance)) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1600068,
                "title": "simple-java-o-n-time-and-o-1-space-solution",
                "content": "`\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        if(nums.length == 1) return 1;\\n        \\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        \\n        int minIndex = 0;\\n        int maxIndex = 0;\\n        \\n        for(int i = 0; i < nums.length; ++i){\\n            int n = nums[i];\\n            \\n            if(n < min) {\\n                min = n;\\n                minIndex = i;\\n            }\\n            if(n > max) {\\n                max = n;\\n                maxIndex = i;\\n            }\\n        }\\n        \\n        int deleteFromFront = Math.max(minIndex,maxIndex) + 1;\\n        int deleteFromLast = nums.length - Math.min(minIndex,maxIndex);\\n        int deleteFromBothSide = Math.min(minIndex,maxIndex) + nums.length - Math.max(minIndex,maxIndex) + 1;\\n        \\n        return Math.min(deleteFromFront,Math.min(deleteFromLast,deleteFromBothSide));\\n    }\\n}\\n`",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minimumDeletions(int[] nums) {\\n        if(nums.length == 1) return 1;\\n        \\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        \\n        int minIndex = 0;\\n        int maxIndex = 0;\\n        \\n        for(int i = 0; i < nums.length; ++i){\\n            int n = nums[i];\\n            \\n            if(n < min) {\\n                min = n;\\n                minIndex = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1600052,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        \\n        int n = nums.length;\\n        if(n == 1 || n == 2) return n;\\n        \\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        int min_idx = 0, max_idx = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(nums[i] < min){\\n                min = nums[i];\\n                min_idx = i;\\n            }\\n            if(nums[i] > max){\\n                max = nums[i];\\n                max_idx = i;\\n            }\\n        }\\n        \\n        int l = Math.min(min_idx,max_idx);\\n        int r = Math.max(min_idx,max_idx);\\n        \\n        int c1 = (r  + 1); // removing both from beginning\\n        int c2 = (n - l); // // removing both from end\\n        int c3 = (l + 1) + (n - r); //  removing smaller one to left and  larger one to right\\n        \\n\\t\\t// considered all three cases, my answer will be the minimum of all three\\n        int ans = Math.min(c1,Math.min(c2,c3));\\n        \\n        return ans;\\n    } \\n}",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int minimumDeletions(int[] nums) {\\n        \\n        int n = nums.length;\\n        if(n == 1 || n == 2) return n;\\n        \\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        int min_idx = 0, max_idx = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(nums[i] < min){\\n                min = nums[i];\\n                min_idx = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1600017,
                "title": "c-with-explanation",
                "content": "Find length between Max and Min.\\nIf length is greater than the biggest distance from Max or Min indexes to the left or right side,\\nwe delete numbers from both side.\\nElse we choose shortest distance from edges to the indexes and sum up with length between Max and Min.\\n```\\npublic class Solution \\n{\\n    public int MinimumDeletions(int[] nums)\\n    {\\n        if(nums.Length <= 2) return nums.Length;\\n        int[] arr = new int[]{Array.IndexOf(nums, nums.Max()), Array.IndexOf(nums, nums.Min())};\\n        \\n        Array.Sort(arr);\\n        \\n        int left = arr[0];\\n        int right = arr[1];\\n        int diff = right - left;\\n        \\n        if(diff >= Math.Max(left + 1, nums.Length - right))\\n        {\\n            return left + 1 + (nums.Length - right);\\n        }\\n        return diff + Math.Min(left + 1, nums.Length - right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int MinimumDeletions(int[] nums)\\n    {\\n        if(nums.Length <= 2) return nums.Length;\\n        int[] arr = new int[]{Array.IndexOf(nums, nums.Max()), Array.IndexOf(nums, nums.Min())};\\n        \\n        Array.Sort(arr);\\n        \\n        int left = arr[0];\\n        int right = arr[1];\\n        int diff = right - left;\\n        \\n        if(diff >= Math.Max(left + 1, nums.Length - right))\\n        {\\n            return left + 1 + (nums.Length - right);\\n        }\\n        return diff + Math.Min(left + 1, nums.Length - right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600009,
                "title": "java-solution-4-cases-with-comments",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        if (nums.length == 1) return 1;\\n        \\n        // Find the indexes of minimums and maximums\\n        int minIdx = -1;\\n        int maxIdx = -1;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        \\n        for (int i=0; i<nums.length; i++) {\\n            if (nums[i] < min) {\\n                min = nums[i];\\n                minIdx = i;\\n            }\\n            \\n            if (nums[i] > max) {\\n                max = nums[i];\\n                maxIdx = i;\\n            }\\n        }\\n        \\n        int midPoint = nums.length / 2;\\n        \\n        if (minIdx <= midPoint && maxIdx <= midPoint) {\\n            // min and max are both on the left side\\n            return Math.max(minIdx, maxIdx) + 1;\\n        } else if (minIdx >= midPoint && maxIdx >= midPoint) {\\n            // min and max are both on the right side\\n            return nums.length - Math.min(minIdx, maxIdx);\\n        } else if (minIdx < midPoint && maxIdx > midPoint) {\\n            // min is on the left side and max is on the right side\\n            // choose the best between 3 options: deleting all from left, all from right\\n            // or the sum of deleting min from left and max from right\\n            int op1 = (minIdx+1) + (nums.length - maxIdx);\\n            int op2 = maxIdx+1;\\n            int op3 = nums.length - minIdx;\\n            return Math.min(Math.min(op1, op2), op3);\\n        } else {\\n            // min is on the right side and max is on the left side\\n            // choose the best between 3 options: deleting all from left, all from right\\n            // or the sum of deleting max from left and min from right\\n            int op1 = (maxIdx+1) + (nums.length - minIdx);\\n            int op2 = minIdx+1;\\n            int op3 = nums.length - maxIdx;\\n            return Math.min(Math.min(op1, op2), op3);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        if (nums.length == 1) return 1;\\n        \\n        // Find the indexes of minimums and maximums\\n        int minIdx = -1;\\n        int maxIdx = -1;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        \\n        for (int i=0; i<nums.length; i++) {\\n            if (nums[i] < min) {\\n                min = nums[i];\\n                minIdx = i;\\n            }\\n            \\n            if (nums[i] > max) {\\n                max = nums[i];\\n                maxIdx = i;\\n            }\\n        }\\n        \\n        int midPoint = nums.length / 2;\\n        \\n        if (minIdx <= midPoint && maxIdx <= midPoint) {\\n            // min and max are both on the left side\\n            return Math.max(minIdx, maxIdx) + 1;\\n        } else if (minIdx >= midPoint && maxIdx >= midPoint) {\\n            // min and max are both on the right side\\n            return nums.length - Math.min(minIdx, maxIdx);\\n        } else if (minIdx < midPoint && maxIdx > midPoint) {\\n            // min is on the left side and max is on the right side\\n            // choose the best between 3 options: deleting all from left, all from right\\n            // or the sum of deleting min from left and max from right\\n            int op1 = (minIdx+1) + (nums.length - maxIdx);\\n            int op2 = maxIdx+1;\\n            int op3 = nums.length - minIdx;\\n            return Math.min(Math.min(op1, op2), op3);\\n        } else {\\n            // min is on the right side and max is on the left side\\n            // choose the best between 3 options: deleting all from left, all from right\\n            // or the sum of deleting max from left and min from right\\n            int op1 = (maxIdx+1) + (nums.length - minIdx);\\n            int op2 = minIdx+1;\\n            int op3 = nums.length - maxIdx;\\n            return Math.min(Math.min(op1, op2), op3);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599991,
                "title": "java-simple-o-n",
                "content": "```\\n   public int minimumDeletions(int[] nums) {\\n        int len = nums.length;\\n        int minnum = nums[0], maxnum = nums[0];\\n        int minidx = 0, maxidx = 0;\\n        \\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] < minnum){\\n                minnum = nums[i];\\n                minidx = i;\\n            }\\n            if(nums[i] > maxnum){\\n                maxnum = nums[i];\\n                maxidx = i;\\n            }\\n        }\\n        int f = Math.max(minidx, maxidx)+1;   //both from left side\\n        int s = len - Math.min(minidx, maxidx);   //both from right side\\n        int t = Math.min(minidx, maxidx)+1 + len - (Math.max(minidx, maxidx)); //one each from either sides\\n        \\n        return Math.min(f, Math.min(s,t));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public int minimumDeletions(int[] nums) {\\n        int len = nums.length;\\n        int minnum = nums[0], maxnum = nums[0];\\n        int minidx = 0, maxidx = 0;\\n        \\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] < minnum){\\n                minnum = nums[i];\\n                minidx = i;\\n            }\\n            if(nums[i] > maxnum){\\n                maxnum = nums[i];\\n                maxidx = i;\\n            }\\n        }\\n        int f = Math.max(minidx, maxidx)+1;   //both from left side\\n        int s = len - Math.min(minidx, maxidx);   //both from right side\\n        int t = Math.min(minidx, maxidx)+1 + len - (Math.max(minidx, maxidx)); //one each from either sides\\n        \\n        return Math.min(f, Math.min(s,t));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1599983,
                "title": "c-simple-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& n) {\\n        if(n.size()<=2)\\n            return n.size();\\n        auto i=min_element(n.begin(),n.end());\\n        auto j=max_element(n.begin(),n.end());\\n        int min_s,min_e,max_s,max_e;\\n        /*\\n            min_s : number of operations to delete minimum element from front\\n            min_e : number of operations to delete minimum element from back\\n            max_s : number of operations to delete maximum element from front\\n            max_e : number of operations to delete maximum element from back\\n        */\\n        min_s=i-n.begin()+1;\\n        min_e=n.end()-i;\\n        max_s=j-n.begin()+1;\\n        max_e=n.end()-j;\\n        //if deletion is done from front for both\\n        int a=max(min_s,max_s);\\n        //if deletion is done from back for both\\n        int b=max(min_e,max_e);\\n        //if max element is deleted form front and min element from back\\n        int c=min_e+max_s;\\n        //if min element is deleted form front and max element from back\\n        int d=min_s+max_e;\\n        \\n        //return the minimum of all\\n        return min(a,min(b,min(c,d)));\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& n) {\\n        if(n.size()<=2)\\n            return n.size();\\n        auto i=min_element(n.begin(),n.end());\\n        auto j=max_element(n.begin(),n.end());\\n        int min_s,min_e,max_s,max_e;\\n        /*\\n            min_s : number of operations to delete minimum element from front\\n            min_e : number of operations to delete minimum element from back\\n            max_s : number of operations to delete maximum element from front\\n            max_e : number of operations to delete maximum element from back\\n        */\\n        min_s=i-n.begin()+1;\\n        min_e=n.end()-i;\\n        max_s=j-n.begin()+1;\\n        max_e=n.end()-j;\\n        //if deletion is done from front for both\\n        int a=max(min_s,max_s);\\n        //if deletion is done from back for both\\n        int b=max(min_e,max_e);\\n        //if max element is deleted form front and min element from back\\n        int c=min_e+max_s;\\n        //if min element is deleted form front and max element from back\\n        int d=min_s+max_e;\\n        \\n        //return the minimum of all\\n        return min(a,min(b,min(c,d)));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599956,
                "title": "c-simple-easy-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int maxIdx = max_element(nums.begin(), nums.end()) - nums.begin(); // index of max element\\n        int minIdx = min_element(nums.begin(), nums.end()) - nums.begin(); // index of min element\\n        int n = nums.size();\\n        \\n        int left = max(maxIdx, minIdx) + 1; // no. of deletions if we try to delete from left\\n        int right = n - min(maxIdx, minIdx); // no. of deletions if we try to remove from right\\n        int opp = min(maxIdx, minIdx) + 1 + n - max(maxIdx, minIdx); // deletions from opposite directions\\n        return min(opp, min(left, right)); // return minimum of the three\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int maxIdx = max_element(nums.begin(), nums.end()) - nums.begin(); // index of max element\\n        int minIdx = min_element(nums.begin(), nums.end()) - nums.begin(); // index of min element\\n        int n = nums.size();\\n        \\n        int left = max(maxIdx, minIdx) + 1; // no. of deletions if we try to delete from left\\n        int right = n - min(maxIdx, minIdx); // no. of deletions if we try to remove from right\\n        int opp = min(maxIdx, minIdx) + 1 + n - max(maxIdx, minIdx); // deletions from opposite directions\\n        return min(opp, min(left, right)); // return minimum of the three\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599874,
                "title": "staright-forward-easy-to-chase",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min=0;\\n        int max=0;\\n        int n=nums.length;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>nums[max]) max=i;\\n              if(nums[i]<nums[min]) min=i;\\n        }\\n        int ans=Integer.MAX_VALUE;\\n      \\n        if(max<=min){\\n            ans=Math.min(ans,min+1);\\n            ans=Math.min(ans,max+1+n-min);\\n            ans=Math.min(ans,n-max);\\n        }else{\\n            ans=Math.min(ans,max+1);\\n            ans=Math.min(ans,min+1+n-max);\\n            ans=Math.min(ans,n-min);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min=0;\\n        int max=0;\\n        int n=nums.length;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>nums[max]) max=i;\\n              if(nums[i]<nums[min]) min=i;\\n        }\\n        int ans=Integer.MAX_VALUE;\\n      \\n        if(max<=min){\\n            ans=Math.min(ans,min+1);\\n            ans=Math.min(ans,max+1+n-min);\\n            ans=Math.min(ans,n-max);\\n        }else{\\n            ans=Math.min(ans,max+1);\\n            ans=Math.min(ans,min+1+n-max);\\n            ans=Math.min(ans,n-min);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599806,
                "title": "java-simple",
                "content": "````\\nclass Solution {\\n    public int minimumDeletions(int[] a) {\\n        int n = a.length, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        int min_i = -1, max_i = -1;\\n        for(int i = 0; i < n; i++){\\n            if(a[i] < min){\\n                min = a[i];\\n                min_i = i;\\n            }\\n            if(a[i] > max){\\n                max = a[i];\\n                max_i = i;\\n            }\\n        }\\n        // swapping to make the smaller index go to the left\\n        // and greater to the right \\n        if(max_i < min_i){\\n            int temp = max_i;\\n            max_i = min_i;\\n            min_i = temp;\\n        }\\n        /*\\n                [-----------------------------------------------------------]\\n                          ^                                      ^\\n                        min_i                                  max_i\\n                        \\n                        now there are three candidates to be answer\\n                        1 ) max_i + 1 -> removing all the indixes from [0, max_i]   (min_i and max_i both on left)\\n                        2 ) n - min_i -> removing all the indixes from [min_i, n - 1]   (min_i and max_i both on right)\\n                        2 ) removing portion of indices [0, min_i] and [max_i, n - 1]   (one on left and one on right\\n                                                                                         and in this case we have to compare \\n                                                                                         result to the upper two cases)\\n                        \\n        */\\n        int candidate1 = max_i + 1;\\n        int candidate2 = n - min_i;\\n        int candidate3 = min_i + 1 + n - max_i;\\n        return Math.min( Math.min( candidate1, candidate2), candidate3);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumDeletions(int[] a) {\\n        int n = a.length, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        int min_i = -1, max_i = -1;\\n        for(int i = 0; i < n; i++){\\n            if(a[i] < min){\\n                min = a[i];\\n                min_i = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1599805,
                "title": "python-simple-three-cases",
                "content": "```\\n# We either:\\n# 1. just remove from the front\\n# 2. just remove from the back\\n# 3. remove from both the front and the back\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        a = nums.index(min(nums))\\n        b = nums.index(max(nums))\\n        if a > b:\\n            b, a = a, b\\n        return min(b + 1, len(nums) - a, a + 1 + len(nums) - b)\\n```",
                "solutionTags": [],
                "code": "```\\n# We either:\\n# 1. just remove from the front\\n# 2. just remove from the back\\n# 3. remove from both the front and the back\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        a = nums.index(min(nums))\\n        b = nums.index(max(nums))\\n        if a > b:\\n            b, a = a, b\\n        return min(b + 1, len(nums) - a, a + 1 + len(nums) - b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599797,
                "title": "c-greedy-solution-3-cases",
                "content": "\\nThere are three cases to get the minimum steps to remove min number and max number:\\n1. remove from left, includes min and max, \\n2. remove from right, includes min and max.\\n3. remove from left and right. \\nthe answer is the minimum result of these three cases.\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int minNumberIdx = min_element(nums.begin(), nums.end()) - nums.begin();\\n        int maxNumberIdx = max_element(nums.begin(), nums.end()) - nums.begin();\\n        int mn = min(minNumberIdx, maxNumberIdx), mx = max(minNumberIdx, maxNumberIdx);\\n        int n = nums.size();\\n        return min({mx + 1, n - mn, mn + 1 + n - mx});\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int minNumberIdx = min_element(nums.begin(), nums.end()) - nums.begin();\\n        int maxNumberIdx = max_element(nums.begin(), nums.end()) - nums.begin();\\n        int mn = min(minNumberIdx, maxNumberIdx), mx = max(minNumberIdx, maxNumberIdx);\\n        int n = nums.size();\\n        return min({mx + 1, n - mn, mn + 1 + n - mx});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080515,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int minind,maxind;\\n        int n=nums.size();\\n        int mini=INT_MAX,maxi=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            if(mini>nums[i]){\\n                mini=nums[i];\\n                minind=i;\\n            }\\n            if(maxi<nums[i]){\\n                maxi=nums[i];\\n                maxind=i;\\n            }\\n        }\\n        //deleting both element from front\\n        int val1=max(minind,maxind)+1;\\n\\n        //deleting both element from end\\n        int val2=n-min(maxind,minind);\\n\\n        //deleting from different end\\n        int val3=min(minind+1,n-minind)+min(maxind+1,n-maxind); \\n\\n        int ans=min({val1,val2,val3});\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int minind,maxind;\\n        int n=nums.size();\\n        int mini=INT_MAX,maxi=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            if(mini>nums[i]){\\n                mini=nums[i];\\n                minind=i;\\n            }\\n            if(maxi<nums[i]){\\n                maxi=nums[i];\\n                maxind=i;\\n            }\\n        }\\n        //deleting both element from front\\n        int val1=max(minind,maxind)+1;\\n\\n        //deleting both element from end\\n        int val2=n-min(maxind,minind);\\n\\n        //deleting from different end\\n        int val3=min(minind+1,n-minind)+min(maxind+1,n-maxind); \\n\\n        int ans=min({val1,val2,val3});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062390,
                "title": "basic-nested-lf-else-97-54-beats",
                "content": "# Intuition\\nWe need to remove the min and max element from the list in such a way that the no.of deletions is the least. \\n\\n# Approach\\nFor starters we need to find out from which end we need to start out deletions.\\n\\nFor finding that:\\n1)Find out the index\\'s of both the elements\\n2)Check the distance the extreme elements are from the left end and right end\\n3)Consider the element which is closest to any of the end\\n\\nNow we need to follow similar procedure to eliminate the remaining element\\n\\nFor finding that:\\n1)Know the index of the remaining element\\n2)Check the distance of that element from both the ends in the new list\\n3)Consider deletion from the side with the lesser distance.\\n\\nBy using nested if we can understand the exact way the control has to work and the problem can be broken down into parts for simplification.\\n\\nThe code may be long,but it is very simple to understand.Please go through it thorougly.\\n\\n# Complexity\\n- Time complexity:\\n0(1)\\n\\n- Space complexity:\\nidk how to find space complexity :(\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        si=nums.index(min(nums))#index of smallest number\\n        li=nums.index(max(nums))#index of biggest number\\n        if si<li:\\n            if si<len(nums)-li-1:\\n                #removes from the start to the smallest element\\n                sum=si+1\\n                if li-si<len(nums)-li-1:\\n                    sum+=li-si\\n                else:\\n                    sum+=len(nums)-li\\n            else:\\n                #removes from end to the biggest element\\n                sum=len(nums)-li\\n                if si<li-si-1:\\n                    sum+=si+1\\n                else:\\n                    sum+=li-si\\n        else:\\n            if li<len(nums)-si-1:\\n                #removing from the start to the biggest element\\n                sum=li+1\\n                if si-li<len(nums)-si-1:\\n                    sum+=si-li\\n                else:\\n                    sum+=len(nums)-si\\n            else:\\n                #removing from back to the smallest element\\n                sum=len(nums)-si\\n                if li<si-li-1:\\n                    sum+=li+1\\n                else:\\n                    sum+=si-li\\n        return sum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        si=nums.index(min(nums))#index of smallest number\\n        li=nums.index(max(nums))#index of biggest number\\n        if si<li:\\n            if si<len(nums)-li-1:\\n                #removes from the start to the smallest element\\n                sum=si+1\\n                if li-si<len(nums)-li-1:\\n                    sum+=li-si\\n                else:\\n                    sum+=len(nums)-li\\n            else:\\n                #removes from end to the biggest element\\n                sum=len(nums)-li\\n                if si<li-si-1:\\n                    sum+=si+1\\n                else:\\n                    sum+=li-si\\n        else:\\n            if li<len(nums)-si-1:\\n                #removing from the start to the biggest element\\n                sum=li+1\\n                if si-li<len(nums)-si-1:\\n                    sum+=si-li\\n                else:\\n                    sum+=len(nums)-si\\n            else:\\n                #removing from back to the smallest element\\n                sum=len(nums)-si\\n                if li<si-li-1:\\n                    sum+=li+1\\n                else:\\n                    sum+=si-li\\n        return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048420,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int i,n=nums.size(),mn=INT_MAX,mx=INT_MIN;\\n        for(auto x: nums){\\n            mn=min(x,mn);\\n            mx=max(x,mx);\\n        }\\nint lmn=1,rmn=1,lmx=1,rmx=1;\\n\\nfor(i=0;i<n;i++){\\n    if(nums[i]==mn){\\n        lmn=i+1;\\n        break;\\n    }\\n}\\n\\nfor(i=0;i<n;i++){\\n    if(nums[i]==mx){\\n        lmx=i+1;\\n        break;\\n    }\\n}\\n\\nfor(i=n-1;i>=0;i--){\\n    if(nums[i]==mn){\\n        rmn=n-i;\\n        break;\\n    }\\n}\\n\\nfor(i=n-1;i>=0;i--){\\n    if(nums[i]==mx){\\n        rmx=n-i;\\n        break;\\n    }\\n}\\nint l=max(lmx,lmn);\\nint a=min(lmn,lmx),b=min(rmn,rmx),c=max(rmn,rmx);\\na+=b;\\n\\nreturn min(l,min(a,c));\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int i,n=nums.size(),mn=INT_MAX,mx=INT_MIN;\\n        for(auto x: nums){\\n            mn=min(x,mn);\\n            mx=max(x,mx);\\n        }\\nint lmn=1,rmn=1,lmx=1,rmx=1;\\n\\nfor(i=0;i<n;i++){\\n    if(nums[i]==mn){\\n        lmn=i+1;\\n        break;\\n    }\\n}\\n\\nfor(i=0;i<n;i++){\\n    if(nums[i]==mx){\\n        lmx=i+1;\\n        break;\\n    }\\n}\\n\\nfor(i=n-1;i>=0;i--){\\n    if(nums[i]==mn){\\n        rmn=n-i;\\n        break;\\n    }\\n}\\n\\nfor(i=n-1;i>=0;i--){\\n    if(nums[i]==mx){\\n        rmx=n-i;\\n        break;\\n    }\\n}\\nint l=max(lmx,lmn);\\nint a=min(lmn,lmx),b=min(rmn,rmx),c=max(rmn,rmx);\\na+=b;\\n\\nreturn min(l,min(a,c));\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046788,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int maxi=-1;int mini=-1;\\n        int max=Integer.MIN_VALUE,min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>=max){\\n                max=nums[i];\\n                maxi=i;\\n            }\\n            if(nums[i]<=min){\\n                min=nums[i];\\n                mini=i;\\n            }\\n        }\\n        int f=Math.min(maxi,mini);\\n        int b=Math.max(maxi,mini);\\n        int mid=(f-0)+(nums.length-b)+1;\\n        int f1=b+1;\\n        int b2=nums.length-f;\\n        return Math.min(f1,Math.min(b2,mid));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int maxi=-1;int mini=-1;\\n        int max=Integer.MIN_VALUE,min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>=max){\\n                max=nums[i];\\n                maxi=i;\\n            }\\n            if(nums[i]<=min){\\n                min=nums[i];\\n                mini=i;\\n            }\\n        }\\n        int f=Math.min(maxi,mini);\\n        int b=Math.max(maxi,mini);\\n        int mid=(f-0)+(nums.length-b)+1;\\n        int f1=b+1;\\n        int b2=nums.length-f;\\n        return Math.min(f1,Math.min(b2,mid));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037485,
                "title": "typescript-clean-solution-tc-beats-100-sc-beats-100",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunction minimumDeletions(nums: number[]): number {\\n    if (nums.length < 3) return nums.length;\\n\\n    let minI: number = 0;\\n    let maxI: number = 0;\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] < nums[minI]) {\\n            minI = i;\\n        }\\n        if (nums[i] > nums[maxI]) {\\n            maxI = i;\\n        }\\n    }\\n\\n    return Math.min(\\n        Math.min(minI, maxI) + nums.length - Math.max(minI, maxI) + 1,\\n        Math.max(minI, maxI) + 1,\\n        nums.length - Math.min(minI, maxI)\\n    );\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction minimumDeletions(nums: number[]): number {\\n    if (nums.length < 3) return nums.length;\\n\\n    let minI: number = 0;\\n    let maxI: number = 0;\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] < nums[minI]) {\\n            minI = i;\\n        }\\n        if (nums[i] > nums[maxI]) {\\n            maxI = i;\\n        }\\n    }\\n\\n    return Math.min(\\n        Math.min(minI, maxI) + nums.length - Math.max(minI, maxI) + 1,\\n        Math.max(minI, maxI) + 1,\\n        nums.length - Math.min(minI, maxI)\\n    );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037062,
                "title": "beats-95-easy-c-solution-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMaxi(vector<int>& nums)\\n    {\\n        int maxi = INT_MIN;\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i] > maxi)\\n            {\\n                maxi = nums[i];\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int getMini(vector<int>& nums)\\n    {\\n        int mini = INT_MAX;\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i] < mini)\\n            {\\n                mini = nums[i];\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int minimumDeletions(vector<int>& nums) {\\n\\n        if(nums.size() == 1)\\n        {\\n            return 1;\\n        }\\n\\n        int maxi = getMaxi(nums);\\n        int mini = getMini(nums);\\n        \\n        cout<<maxi<<mini;\\n        int front = max(maxi, mini)+1;\\n        int back = nums.size() - min(maxi, mini);\\n        int frontBack = (min(mini, maxi) + 1) + (nums.size() - max(mini, maxi));\\n\\n        return min({front, back, frontBack});\\n    \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaxi(vector<int>& nums)\\n    {\\n        int maxi = INT_MIN;\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i] > maxi)\\n            {\\n                maxi = nums[i];\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int getMini(vector<int>& nums)\\n    {\\n        int mini = INT_MAX;\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i] < mini)\\n            {\\n                mini = nums[i];\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int minimumDeletions(vector<int>& nums) {\\n\\n        if(nums.size() == 1)\\n        {\\n            return 1;\\n        }\\n\\n        int maxi = getMaxi(nums);\\n        int mini = getMini(nums);\\n        \\n        cout<<maxi<<mini;\\n        int front = max(maxi, mini)+1;\\n        int back = nums.size() - min(maxi, mini);\\n        int frontBack = (min(mini, maxi) + 1) + (nums.size() - max(mini, maxi));\\n\\n        return min({front, back, frontBack});\\n    \\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4036963,
                "title": "beats-100-unique-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\noON)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    int mn(int a,int b)\\n    {\\n        return (a>b)?b:a;\\n    }\\n    int mx(int a,int b)\\n    {\\n        return (a<b)?b:a;\\n    }\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int max=-1;\\n        int min=-1;\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<mini){\\n                mini = nums[i];\\n                min = i;\\n            }\\n\\n             if(nums[i]>maxi){\\n                maxi = nums[i];\\n                max = i;\\n            }\\n        }\\n       int num1 = mx(min+1,max+1);\\n       int num2 = mx(n-min,n-max);\\n       int num3 = mn(min+1,max+1)+ mn(n-min,n-max);\\n       return mn(mn(num1,num2),num3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mn(int a,int b)\\n    {\\n        return (a>b)?b:a;\\n    }\\n    int mx(int a,int b)\\n    {\\n        return (a<b)?b:a;\\n    }\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int max=-1;\\n        int min=-1;\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<mini){\\n                mini = nums[i];\\n                min = i;\\n            }\\n\\n             if(nums[i]>maxi){\\n                maxi = nums[i];\\n                max = i;\\n            }\\n        }\\n       int num1 = mx(min+1,max+1);\\n       int num2 = mx(n-min,n-max);\\n       int num3 = mn(min+1,max+1)+ mn(n-min,n-max);\\n       return mn(mn(num1,num2),num3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036699,
                "title": "simply-checking-out-the-three-possibilities-that-are-available-to-us-o-n-time-o-1-space",
                "content": "# Intuition\\nSimple traversal approch where we are simply checking out the three possibilities and taking the minimmim from those possibilities.\\n\\n# Approach\\nThe 3 possibilities that we ghave are:\\n1) what if we start from the beginning and delete the both minimmum and maximmim element: t=max(minp, maxp)+1\\n2) What if we start from the last and delete the both minimmum and the maximmum element:  p=max(n-minp, n-maxp)\\n3) lastly what if we start from the beginning and take the element which is closet to the starting point and closest to the last index and start deleting elements from both the start and the end.\\nf=min(minp, maxp)+1 + min(n-minp, n-maxp)\\n4) Then we simply take the minimmu value from these three possibilities which would require us to cause the most minimmum elements t be deleted form the array \\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        minp, maxp=nums.index(min(nums)), nums.index(max(nums))\\n        t=max(minp, maxp)+1\\n        p=max(n-minp, n-maxp)\\n        \\n        return min(f, t, p)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        minp, maxp=nums.index(min(nums)), nums.index(max(nums))\\n        t=max(minp, maxp)+1\\n        p=max(n-minp, n-maxp)\\n        \\n        return min(f, t, p)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036468,
                "title": "python-solution-o-n-time",
                "content": "# Complexity\\n- Time complexity:\\n    O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return 1\\n        maxi = max(nums)\\n        mini = min(nums)\\n        \\n        n = len(nums)\\n        a = []\\n        b= []\\n\\n        for i in range(n):\\n            if nums[i] == maxi or nums[i] == mini:\\n                a.append(i+1)\\n        for i in range(n-1,-1,-1):\\n            if nums[i] == maxi or nums[i] == mini:\\n                b.append(n-i)\\n        return min(a[-1],b[-1], a[0]+b[0])\\n       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return 1\\n        maxi = max(nums)\\n        mini = min(nums)\\n        \\n        n = len(nums)\\n        a = []\\n        b= []\\n\\n        for i in range(n):\\n            if nums[i] == maxi or nums[i] == mini:\\n                a.append(i+1)\\n        for i in range(n-1,-1,-1):\\n            if nums[i] == maxi or nums[i] == mini:\\n                b.append(n-i)\\n        return min(a[-1],b[-1], a[0]+b[0])\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036115,
                "title": "only-3-ways-possible",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int getmindeletions(int left, int right, int size){\\n        int count1 = right + 1;                 // all the elements are deleted from left to right index\\n        int count2 = size - left;               // all the elements are deleted from right to left index\\n        int count3 = left + 1 + size - right;   // all the elements from start to left and end to right are deleted.\\n        return min(count3,min(count1,count2));\\n    }\\n\\n    int minimumDeletions(vector<int>& nums) {\\n        if(nums.size()==1) return 1;                // Only one element: one element is removed\\n\\n        int minindex,maxindex;\\n\\n        int min = INT_MAX;\\n        int max = INT_MIN;\\n\\n        for(int i = 0 ; i < nums.size() ; ++i){\\n            if(nums[i] < min){                      // We check for minimum\\n                min = nums[i];\\n                minindex = i;\\n            }\\n            if(nums[i] > max){                      // We check for maximum\\n                max = nums[i];\\n                maxindex = i;\\n            } \\n        }\\n\\n        // Call the function in accordance with left and right indexes for minimum and maximum respectively.\\n        return minindex < maxindex ? getmindeletions(minindex,maxindex,nums.size()) : getmindeletions(maxindex,minindex,nums.size());\\n  \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int getmindeletions(int left, int right, int size){\\n        int count1 = right + 1;                 // all the elements are deleted from left to right index\\n        int count2 = size - left;               // all the elements are deleted from right to left index\\n        int count3 = left + 1 + size - right;   // all the elements from start to left and end to right are deleted.\\n        return min(count3,min(count1,count2));\\n    }\\n\\n    int minimumDeletions(vector<int>& nums) {\\n        if(nums.size()==1) return 1;                // Only one element: one element is removed\\n\\n        int minindex,maxindex;\\n\\n        int min = INT_MAX;\\n        int max = INT_MIN;\\n\\n        for(int i = 0 ; i < nums.size() ; ++i){\\n            if(nums[i] < min){                      // We check for minimum\\n                min = nums[i];\\n                minindex = i;\\n            }\\n            if(nums[i] > max){                      // We check for maximum\\n                max = nums[i];\\n                maxindex = i;\\n            } \\n        }\\n\\n        // Call the function in accordance with left and right indexes for minimum and maximum respectively.\\n        return minindex < maxindex ? getmindeletions(minindex,maxindex,nums.size()) : getmindeletions(maxindex,minindex,nums.size());\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035960,
                "title": "easy-to-understand-solution-in-java-using-greedy-approach-self-explanatory",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min =0, max =0,res=Integer.MAX_VALUE,n = nums.length;\\n\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]<nums[min] )\\n                min=i;\\n            if(nums[i]>nums[max])\\n                max=i;\\n        }\\n        if(min==max)\\n        {\\n            return Math.min(min,n-min)+1;\\n        }\\n        else\\n        {\\n            int leftRight = Math.min(max,min)+1 + n-Math.max(max,min);\\n            int right =  n-Math.min(max,min);\\n            int left = Math.max(max,min)+1; \\n            return Math.min(leftRight,Math.min(left,right));\\n        }\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min =0, max =0,res=Integer.MAX_VALUE,n = nums.length;\\n\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]<nums[min] )\\n                min=i;\\n            if(nums[i]>nums[max])\\n                max=i;\\n        }\\n        if(min==max)\\n        {\\n            return Math.min(min,n-min)+1;\\n        }\\n        else\\n        {\\n            int leftRight = Math.min(max,min)+1 + n-Math.max(max,min);\\n            int right =  n-Math.min(max,min);\\n            int left = Math.max(max,min)+1; \\n            return Math.min(leftRight,Math.min(left,right));\\n        }\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035867,
                "title": "c-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int maxi, mini, maxVal, minVal;\\n        maxVal=nums[0], minVal=nums[0], maxi=0, mini=0;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i]>maxVal) maxVal=nums[i], maxi=i;\\n            if(nums[i]<minVal) minVal=nums[i], mini=i;\\n        }\\n        int n=nums.size();\\n        int maxf=maxi+1, maxb=n-maxi, minf=mini+1, minb=n-mini;\\n        if(maxf<=maxb && minf<=minb) return max(maxf, minf);\\n        else if(maxb<=maxf && minb<=minf) return max(maxb, minb);\\n        else return min(min(minf, maxf)+min(minb, maxb) , min(max(minf, maxf), max(minb, maxb)));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int maxi, mini, maxVal, minVal;\\n        maxVal=nums[0], minVal=nums[0], maxi=0, mini=0;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i]>maxVal) maxVal=nums[i], maxi=i;\\n            if(nums[i]<minVal) minVal=nums[i], mini=i;\\n        }\\n        int n=nums.size();\\n        int maxf=maxi+1, maxb=n-maxi, minf=mini+1, minb=n-mini;\\n        if(maxf<=maxb && minf<=minb) return max(maxf, minf);\\n        else if(maxb<=maxf && minb<=minf) return max(maxb, minb);\\n        else return min(min(minf, maxf)+min(minb, maxb) , min(max(minf, maxf), max(minb, maxb)));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035450,
                "title": "c-easy-beginner-s-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int low = INT_MAX, high = INT_MIN;\\n        int n = nums.size();\\n        for(int i = 0;i<n;i++)\\n        {\\n            low = min(nums[i], low);\\n            high = max(nums[i], high);\\n        }\\n        int low_index = find(nums.begin(), nums.end(), low) - nums.begin();\\n        int high_index = find(nums.begin(), nums.end(), high) - nums.begin();\\n        cout<<\"low -> \"<<low_index<<\" high -> \"<<high_index<<endl;\\n        int one = max(low_index, high_index); //+1\\n        one++;\\n        int two = max(n-low_index, n-high_index);\\n        int three = min(low_index, high_index) + 1 + n - max(low_index, high_index);\\n        cout<<one<<\" \"<<two<<\" \"<<three;\\n        return min(one, min(two,three));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        int low = INT_MAX, high = INT_MIN;\\n        int n = nums.size();\\n        for(int i = 0;i<n;i++)\\n        {\\n            low = min(nums[i], low);\\n            high = max(nums[i], high);\\n        }\\n        int low_index = find(nums.begin(), nums.end(), low) - nums.begin();\\n        int high_index = find(nums.begin(), nums.end(), high) - nums.begin();\\n        cout<<\"low -> \"<<low_index<<\" high -> \"<<high_index<<endl;\\n        int one = max(low_index, high_index); //+1\\n        one++;\\n        int two = max(n-low_index, n-high_index);\\n        int three = min(low_index, high_index) + 1 + n - max(low_index, high_index);\\n        cout<<one<<\" \"<<two<<\" \"<<three;\\n        return min(one, min(two,three));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4035310,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        \\n        int maxIndex = -1,minIndex=-1;\\n        int maxi = INT_MIN,mini = INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>maxi){\\n                maxi = nums[i];\\n                maxIndex = i;\\n            }\\n            if(nums[i]<mini){\\n                mini = nums[i];\\n                minIndex = i;\\n            }\\n        }\\n\\n        if(minIndex>maxIndex){\\n            int op1 = nums.size()-minIndex + maxIndex + 1;\\n            int op2 = minIndex+1;\\n            int op3 = nums.size()-maxIndex;\\n            return min({op1,op2,op3});\\n        }\\n        else{\\n            int op1 = nums.size()-maxIndex + minIndex + 1;\\n            int op2 = maxIndex+1;\\n            int op3 = nums.size()-minIndex;\\n            return min({op1,op2,op3});\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        \\n        int maxIndex = -1,minIndex=-1;\\n        int maxi = INT_MIN,mini = INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>maxi){\\n                maxi = nums[i];\\n                maxIndex = i;\\n            }\\n            if(nums[i]<mini){\\n                mini = nums[i];\\n                minIndex = i;\\n            }\\n        }\\n\\n        if(minIndex>maxIndex){\\n            int op1 = nums.size()-minIndex + maxIndex + 1;\\n            int op2 = minIndex+1;\\n            int op3 = nums.size()-maxIndex;\\n            return min({op1,op2,op3});\\n        }\\n        else{\\n            int op1 = nums.size()-maxIndex + minIndex + 1;\\n            int op2 = maxIndex+1;\\n            int op3 = nums.size()-minIndex;\\n            return min({op1,op2,op3});\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035070,
                "title": "4-combinations-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        \\n        int maxi = nums[0];\\n        int mini = nums[0];\\n        \\n        int maxPos = 0;\\n        int minPos = 0;\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i] > maxi){\\n                maxi = nums[i];\\n                maxPos = i;\\n            }\\n            \\n            if(nums[i] < mini){\\n                mini = nums[i];\\n                minPos = i;\\n            }\\n        }\\n        \\n        // trying 4 possible combinations\\n        // remove both from front\\n        // remove both from end\\n        // remove first from front, second from back\\n        // remove second from front, first from back\\n\\n        int ans = min({max(maxPos, minPos)+1, (int)nums.size()-min(maxPos, minPos), maxPos+1+(int)nums.size()-minPos, minPos+1+(int)nums.size()-maxPos});\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        \\n        int maxi = nums[0];\\n        int mini = nums[0];\\n        \\n        int maxPos = 0;\\n        int minPos = 0;\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i] > maxi){\\n                maxi = nums[i];\\n                maxPos = i;\\n            }\\n            \\n            if(nums[i] < mini){\\n                mini = nums[i];\\n                minPos = i;\\n            }\\n        }\\n        \\n        // trying 4 possible combinations\\n        // remove both from front\\n        // remove both from end\\n        // remove first from front, second from back\\n        // remove second from front, first from back\\n\\n        int ans = min({max(maxPos, minPos)+1, (int)nums.size()-min(maxPos, minPos), maxPos+1+(int)nums.size()-minPos, minPos+1+(int)nums.size()-maxPos});\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035037,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_deletions(nums: Vec<i32>) -> i32 {\\n        let mut min_idx = 0;\\n        let mut max_idx = 0;\\n\\n        for i in 0..nums.len() {\\n            if nums[i] < nums[min_idx] {\\n                min_idx = i;\\n            }\\n            if nums[i] > nums[max_idx] {\\n                max_idx = i;\\n            }\\n        }\\n\\n        if min_idx > max_idx {\\n            std::mem::swap(&mut min_idx, &mut max_idx);\\n        }\\n\\n        let mut ans = 0;\\n\\n        let min_left = min_idx as i32 + 1;\\n        let mut min_right = nums.len() as i32 - min_idx as i32;\\n\\n        let mut max_left = max_idx as i32 + 1;\\n        let max_right = nums.len() as i32 - max_idx as i32;\\n\\n        ans += (min_left).min(max_right);\\n\\n        if ans == min_left {\\n            max_left -= ans;\\n            ans += (max_left).min(max_right);\\n        } else {\\n            min_right -= ans;\\n            ans += (min_left).min(min_right);\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_deletions(nums: Vec<i32>) -> i32 {\\n        let mut min_idx = 0;\\n        let mut max_idx = 0;\\n\\n        for i in 0..nums.len() {\\n            if nums[i] < nums[min_idx] {\\n                min_idx = i;\\n            }\\n            if nums[i] > nums[max_idx] {\\n                max_idx = i;\\n            }\\n        }\\n\\n        if min_idx > max_idx {\\n            std::mem::swap(&mut min_idx, &mut max_idx);\\n        }\\n\\n        let mut ans = 0;\\n\\n        let min_left = min_idx as i32 + 1;\\n        let mut min_right = nums.len() as i32 - min_idx as i32;\\n\\n        let mut max_left = max_idx as i32 + 1;\\n        let max_right = nums.len() as i32 - max_idx as i32;\\n\\n        ans += (min_left).min(max_right);\\n\\n        if ans == min_left {\\n            max_left -= ans;\\n            ans += (max_left).min(max_right);\\n        } else {\\n            min_right -= ans;\\n            ans += (min_left).min(min_right);\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034962,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) \\n    {\\n        int mini = 0;\\n        int maxi = 0;\\n        int n = nums.size();\\n\\n        for(int i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[mini] > nums[i])mini = i;\\n            if(nums[maxi] < nums[i])maxi = i;\\n        }\\n\\n        int front = max(abs(maxi + 1) , abs(mini + 1));\\n        int back = max(abs(n-maxi) , abs(n-mini));\\n        int both;\\n\\n        if(maxi < mini)\\n        {\\n            both = abs(maxi-0+1) + abs(n-mini);\\n        }\\n        else\\n        {\\n            both = abs(mini-0+1) + abs(n-maxi);\\n        }\\n\\n        int ans = min(front,min(back,both));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) \\n    {\\n        int mini = 0;\\n        int maxi = 0;\\n        int n = nums.size();\\n\\n        for(int i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[mini] > nums[i])mini = i;\\n            if(nums[maxi] < nums[i])maxi = i;\\n        }\\n\\n        int front = max(abs(maxi + 1) , abs(mini + 1));\\n        int back = max(abs(n-maxi) , abs(n-mini));\\n        int both;\\n\\n        if(maxi < mini)\\n        {\\n            both = abs(maxi-0+1) + abs(n-mini);\\n        }\\n        else\\n        {\\n            both = abs(mini-0+1) + abs(n-maxi);\\n        }\\n\\n        int ans = min(front,min(back,both));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034717,
                "title": "removing-minimum-and-maximum-from-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int mine = 0;\\n        int maxe =0;\\n        int maxin = Integer.MIN_VALUE;\\n        int minin = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            maxin = Math.max(nums[i],maxin);\\n            minin = Math.min(nums[i],minin);\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==maxin)\\n            maxe = i;\\n            if(nums[i]==minin)\\n            mine = i;\\n        }\\n        int front = Math.max(mine,maxe)+1;\\n        int back = Math.max(nums.length-mine,nums.length-maxe);\\n        int frontmin = mine+1+nums.length-maxe;\\n        int frontmax = maxe+1+nums.length-mine;\\n        int minv = Math.min(frontmin,frontmax);\\n        int minv1 = Math.min(front,back);\\n        int ans = Math.min(minv,minv1);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int mine = 0;\\n        int maxe =0;\\n        int maxin = Integer.MIN_VALUE;\\n        int minin = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            maxin = Math.max(nums[i],maxin);\\n            minin = Math.min(nums[i],minin);\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==maxin)\\n            maxe = i;\\n            if(nums[i]==minin)\\n            mine = i;\\n        }\\n        int front = Math.max(mine,maxe)+1;\\n        int back = Math.max(nums.length-mine,nums.length-maxe);\\n        int frontmin = mine+1+nums.length-maxe;\\n        int frontmax = maxe+1+nums.length-mine;\\n        int minv = Math.min(frontmin,frontmax);\\n        int minv1 = Math.min(front,back);\\n        int ans = Math.min(minv,minv1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034549,
                "title": "c-the-only-solution-that-you-need-for-this-problem",
                "content": "Imagine you and one of your friends standing in a bus filled with people and you both need to get down the next station.\\n(Considering a bus which has exit gates at the starting and then end and you can choose any)\\n\\nWhat can you 2 do?\\n**a. Both of you get down from the front door\\nb. Both of you get down from the end door\\nc. You get down from the front door and your friend gets down from the end door\\nd. You get down from the back door and your friend gets down from the front door.**\\n\\nBeing a LeetCoder, you\\'d consider all these situations and take the one which takes the **MINIMUM** effort (Effort of sliding through all the people in the bus).\\n\\nNow, think about the problem. Isn\\'t it the same?\\nAnd now look at the code:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& bus) {\\n        int youInTheBus = min_element(bus.begin() , bus.end()) - bus.begin();\\n        int yourFriendInTheBus = max_element(bus.begin() , bus.end()) - bus.begin();\\n\\n        // Situation where you and your friend gets from the different doors\\n        int youGetOutFromTheFrontDoorAndYourFriendGetsDownFromTheBackDoor = youInTheBus + bus.size() - yourFriendInTheBus + 1;\\n\\n        int youGetOutFromTheBackDoorAndYourFriendGetsDownFromTheFrontDoor = yourFriendInTheBus + bus.size() - youInTheBus + 1;\\n        \\n        int gettingOffFromDifferentDoors = min(\\n            youGetOutFromTheFrontDoorAndYourFriendGetsDownFromTheBackDoor , \\n            youGetOutFromTheBackDoorAndYourFriendGetsDownFromTheFrontDoor\\n        );\\n        \\n        // Situation where you and your friend gets off from the front door\\n        int gettingFromTheFrontDoor = max(\\n            youInTheBus + 1 , \\n            yourFriendInTheBus + 1\\n        );\\n\\n        // Situation where you and your friend gets from the back door\\n        int gettingFromTheBackDoor = max(\\n            bus.size() - youInTheBus , \\n            bus.size() - yourFriendInTheBus\\n        );\\n\\n        return min({\\n            gettingOffFromDifferentDoors , \\n            gettingFromTheFrontDoor , \\n            gettingFromTheBackDoor\\n        });\\n    }\\n};\\n```\\n\\n# P.S.: You\\'re Welcome :)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& bus) {\\n        int youInTheBus = min_element(bus.begin() , bus.end()) - bus.begin();\\n        int yourFriendInTheBus = max_element(bus.begin() , bus.end()) - bus.begin();\\n\\n        // Situation where you and your friend gets from the different doors\\n        int youGetOutFromTheFrontDoorAndYourFriendGetsDownFromTheBackDoor = youInTheBus + bus.size() - yourFriendInTheBus + 1;\\n\\n        int youGetOutFromTheBackDoorAndYourFriendGetsDownFromTheFrontDoor = yourFriendInTheBus + bus.size() - youInTheBus + 1;\\n        \\n        int gettingOffFromDifferentDoors = min(\\n            youGetOutFromTheFrontDoorAndYourFriendGetsDownFromTheBackDoor , \\n            youGetOutFromTheBackDoorAndYourFriendGetsDownFromTheFrontDoor\\n        );\\n        \\n        // Situation where you and your friend gets off from the front door\\n        int gettingFromTheFrontDoor = max(\\n            youInTheBus + 1 , \\n            yourFriendInTheBus + 1\\n        );\\n\\n        // Situation where you and your friend gets from the back door\\n        int gettingFromTheBackDoor = max(\\n            bus.size() - youInTheBus , \\n            bus.size() - yourFriendInTheBus\\n        );\\n\\n        return min({\\n            gettingOffFromDifferentDoors , \\n            gettingFromTheFrontDoor , \\n            gettingFromTheBackDoor\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034138,
                "title": "cpp-very-easy-implementation-clean-and-clear-code",
                "content": "\\n# Complexity\\n- Time complexity:``O(N)``\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:``O(1)``\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallest(vector<int>& nums,int n){\\n        int ans=0;\\n        int small=nums[0];\\n        for(int j=1;j<n;j++){\\n            if(nums[j]<small){\\n                small=nums[j];\\n                ans=j;\\n            }\\n        }\\n        return ans;\\n    }\\n    int largest(vector<int>& nums,int n){\\n        int ans=0;\\n        int large=nums[0];\\n        for(int j=1;j<n;j++){\\n            if(nums[j]>large){\\n                large=nums[j];\\n                ans=j;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumDeletions(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)return 1;\\n        int mini=smallest(nums,n);\\n        int maxi=largest(nums,n);\\n        int front=max(maxi,mini)+1;\\n        int back=n-min(maxi,mini);\\n        int both = min(maxi,mini)+1 + n-max(maxi,mini);\\n        return min(front,min(back,both));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallest(vector<int>& nums,int n){\\n        int ans=0;\\n        int small=nums[0];\\n        for(int j=1;j<n;j++){\\n            if(nums[j]<small){\\n                small=nums[j];\\n                ans=j;\\n            }\\n        }\\n        return ans;\\n    }\\n    int largest(vector<int>& nums,int n){\\n        int ans=0;\\n        int large=nums[0];\\n        for(int j=1;j<n;j++){\\n            if(nums[j]>large){\\n                large=nums[j];\\n                ans=j;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumDeletions(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)return 1;\\n        int mini=smallest(nums,n);\\n        int maxi=largest(nums,n);\\n        int front=max(maxi,mini)+1;\\n        int back=n-min(maxi,mini);\\n        int both = min(maxi,mini)+1 + n-max(maxi,mini);\\n        return min(front,min(back,both));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034014,
                "title": "easy-linear-time-complexity-solution-beats-100-time-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are 4 possible ways to delete the min and max element:\\n1) Delete both of them together from the front.\\n2) Delete both of them together from the last.\\n3) Delete min from the first and max from the last.\\n4) Delete min from the end and max from the front.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the position of the min and the max element. Find out all the 4 distances and the minimum amongst them.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        int minInd = 0;\\n        int maxInd = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(max<nums[i]){\\n                maxInd = i;\\n                max = nums[i];\\n            }\\n            if(min>nums[i]){\\n                minInd = i;\\n                min = nums[i];\\n            }\\n        }\\n        int maxEnd = Math.max(nums.length - minInd, nums.length - maxInd);\\n        int maxFront = Math.max(minInd+1, maxInd+1);\\n        int sum1 = minInd+1 + nums.length-maxInd;\\n        int sum2 = maxInd+1+nums.length - minInd;\\n        int minDis = nums.length;\\n        if(minDis>maxEnd){\\n            minDis = maxEnd;\\n        }\\n        if(minDis>maxFront){\\n            minDis = maxFront;\\n        }\\n        if(minDis>sum1){\\n            minDis = sum1;\\n        }\\n        if(minDis>sum2){\\n            minDis = sum2;\\n        }\\n        return minDis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        int minInd = 0;\\n        int maxInd = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(max<nums[i]){\\n                maxInd = i;\\n                max = nums[i];\\n            }\\n            if(min>nums[i]){\\n                minInd = i;\\n                min = nums[i];\\n            }\\n        }\\n        int maxEnd = Math.max(nums.length - minInd, nums.length - maxInd);\\n        int maxFront = Math.max(minInd+1, maxInd+1);\\n        int sum1 = minInd+1 + nums.length-maxInd;\\n        int sum2 = maxInd+1+nums.length - minInd;\\n        int minDis = nums.length;\\n        if(minDis>maxEnd){\\n            minDis = maxEnd;\\n        }\\n        if(minDis>maxFront){\\n            minDis = maxFront;\\n        }\\n        if(minDis>sum1){\\n            minDis = sum1;\\n        }\\n        if(minDis>sum2){\\n            minDis = sum2;\\n        }\\n        return minDis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033908,
                "title": "is-o-n-and-o-1-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        pair <int,int> mini(INT_MAX, -1);\\n        pair <int,int> maxi(INT_MIN, -1);\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            if(mini.first > nums[i]){\\n                mini.first = nums[i];\\n                mini.second = i;\\n            }\\n            if(maxi.first < nums[i]){\\n                maxi.first = nums[i];\\n                maxi.second = i;\\n            }\\n        }\\n        int first = abs(mini.second-maxi.second);\\n        return min({1+abs(max(mini.second, maxi.second)), abs(n-first+1), abs(n-min(mini.second, maxi.second))});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        pair <int,int> mini(INT_MAX, -1);\\n        pair <int,int> maxi(INT_MIN, -1);\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            if(mini.first > nums[i]){\\n                mini.first = nums[i];\\n                mini.second = i;\\n            }\\n            if(maxi.first < nums[i]){\\n                maxi.first = nums[i];\\n                maxi.second = i;\\n            }\\n        }\\n        int first = abs(mini.second-maxi.second);\\n        return min({1+abs(max(mini.second, maxi.second)), abs(n-first+1), abs(n-min(mini.second, maxi.second))});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033860,
                "title": "c-solution-intuition-based-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n       O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        if(nums.size() <= 2)\\n        return  nums.size();\\n        int minimum = 0;\\n        int maxi = INT_MIN;\\n        int mini = INT_MAX;\\n        int min_idx, max_idx = 0;\\n         int n = nums.size();  \\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] > maxi){\\n             maxi = max(maxi,nums[i]);\\n             max_idx = i;\\n            }\\n            if(nums[i] < mini){\\n             mini = min(mini, nums[i]);\\n             min_idx = i;\\n        }        \\n    }\\n    int front = min(min_idx, max_idx);\\n    int back = max(min_idx, max_idx);\\n\\n    if( front  > n / 2 && back > n / 2)\\n    {\\n        return n - min(front,back);\\n        \\n    }\\n    else if(front < n / 2 && back < n/2)\\n    {\\n         return max(front+1,back+1);\\n    }\\n  \\n   return  min(min(n - min(front,back), max(front+1,back+1)), n - back + front + 1);\\n   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) {\\n        if(nums.size() <= 2)\\n        return  nums.size();\\n        int minimum = 0;\\n        int maxi = INT_MIN;\\n        int mini = INT_MAX;\\n        int min_idx, max_idx = 0;\\n         int n = nums.size();  \\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] > maxi){\\n             maxi = max(maxi,nums[i]);\\n             max_idx = i;\\n            }\\n            if(nums[i] < mini){\\n             mini = min(mini, nums[i]);\\n             min_idx = i;\\n        }        \\n    }\\n    int front = min(min_idx, max_idx);\\n    int back = max(min_idx, max_idx);\\n\\n    if( front  > n / 2 && back > n / 2)\\n    {\\n        return n - min(front,back);\\n        \\n    }\\n    else if(front < n / 2 && back < n/2)\\n    {\\n         return max(front+1,back+1);\\n    }\\n  \\n   return  min(min(n - min(front,back), max(front+1,back+1)), n - back + front + 1);\\n   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033745,
                "title": "easy-using-3-cases-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust use the hint section and get the three cases forthe answers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. firstly get the indexes of the maximum and minimum element for the vector. once you get it you are half done.\\n2. Now we have the values of indices and we can easily compute the three cases .\\n3. for the first case to get from the starting only we have n which is pointing to minimum element now we can have its value as n-1\\n4. For the second case starting from the last we can compute its value as nums.size()-x,here x is the index of maximum element.\\n5. For the third case we can easily compute the values as [(n+1) + nums.size()-x] .\\n6. By counting the three integers as minimum we can easily return the minimum number.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) \\n    {\\n        int y=nums.size();\\n        //we are storing the indexes of the numbers maximum and minimum from the array in n and x.\\n          int n=min_element(nums.begin(),nums.end())-nums.begin();\\n          int x=max_element(nums.begin(),nums.end())-nums.begin();\\n            //Now we check if the larger number index points to the larger number\\n          if(x<n)swap(n,x);\\n\\n            return min({x+1,y-n,n+1+y-x});\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(vector<int>& nums) \\n    {\\n        int y=nums.size();\\n        //we are storing the indexes of the numbers maximum and minimum from the array in n and x.\\n          int n=min_element(nums.begin(),nums.end())-nums.begin();\\n          int x=max_element(nums.begin(),nums.end())-nums.begin();\\n            //Now we check if the larger number index points to the larger number\\n          if(x<n)swap(n,x);\\n\\n            return min({x+1,y-n,n+1+y-x});\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033695,
                "title": "java-gready-approch-optimize-solution-98-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n\\n        int maxI=0;\\n        int minI=0;\\n        int x=0;\\n        for(int i : nums){\\n            if(i>max){\\n                max = i;\\n                maxI= x;\\n            }\\n            if(i<min){\\n                min = i;\\n                minI= x;\\n            }\\n            x++;\\n        }\\n\\n        return Math.min(Math.max(maxI+1,minI+1),Math.min(Math.max(nums.length - maxI, nums.length - minI),Math.min(minI+1 + nums.length - maxI, maxI+1 +nums.length - minI)));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n\\n        int maxI=0;\\n        int minI=0;\\n        int x=0;\\n        for(int i : nums){\\n            if(i>max){\\n                max = i;\\n                maxI= x;\\n            }\\n            if(i<min){\\n                min = i;\\n                minI= x;\\n            }\\n            x++;\\n        }\\n\\n        return Math.min(Math.max(maxI+1,minI+1),Math.min(Math.max(nums.length - maxI, nums.length - minI),Math.min(minI+1 + nums.length - maxI, maxI+1 +nums.length - minI)));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033664,
                "title": "ez-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimumDeletions(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(nums)\\n        mini = min(nums)\\n        maxi = max(nums)\\n        l1 = nums.index(mini)\\n        r1 = n - l1\\n        l2 = nums.index(maxi)\\n        r2 = n - l2\\n        return min(max(r1, r2), r1 + l2+1, l1 + r2+1, max(l1,l2)+1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumDeletions(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(nums)\\n        mini = min(nums)\\n        maxi = max(nums)\\n        l1 = nums.index(mini)\\n        r1 = n - l1\\n        l2 = nums.index(maxi)\\n        r2 = n - l2\\n        return min(max(r1, r2), r1 + l2+1, l1 + r2+1, max(l1,l2)+1)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1757777,
                "content": [
                    {
                        "username": "RayanYI",
                        "content": "Gently easy am I wrong ?"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I think this can be easiest medium problem encountered so far!\\nJust think of 3 ways to delete.\\n- both deletions from front \\n- both deletions from back\\n- one from front and other from back.\\ntake minimum of 3 ways"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "its long....!"
                    },
                    {
                        "username": "withrvr",
                        "content": "# As given in Example only \\u2705\\n### If seen properly\\n### Try to Solve using this Logic .... ez \\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\n\\n# 3 Cases are Posssible\\n- both delete from left ( then rightmost index )\\n- both delete from right ( then leftmost index )\\n- right and left together ( like edges )\\n\\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "its helps"
                    },
                    {
                        "username": "Shubham0111",
                        "content": "I have a solution in go in O(n). It passed 57/62 testcases. can anyone please help me why this solution failing few edge cases.\\nfunc minimumDeletions(nums []int) int {\\n   var maximum, minimum, result int = nums[0], nums[0], 0\\n\\tvar maximumIndex, minimumIndex int\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif maximum < nums[i] {\\n\\t\\t\\tmaximum = nums[i]\\n\\t\\t\\tmaximumIndex = i\\n\\t\\t}\\n\\t\\tif minimum > nums[i] {\\n\\t\\t\\tminimum = nums[i]\\n\\t\\t\\tminimumIndex = i\\n\\t\\t}\\n\\t}\\n\\thalfIndex := len(nums) / 2\\n\\n\\tif halfIndex >= maximumIndex && halfIndex >= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t}\\n\\t\\tresult += temp + 1\\n\\t} else if halfIndex <= maximumIndex && halfIndex <= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t}\\n\\t\\tresult += len(nums) - temp\\n\\t} else {\\n\\t\\tif halfIndex > minimumIndex {\\n\\t\\t\\tresult += minimumIndex + 1\\n\\t\\t} else if halfIndex < minimumIndex {\\n\\t\\t\\tresult += len(nums) - minimumIndex\\n\\t\\t}\\n\\t\\tif halfIndex > maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t} else if halfIndex < maximumIndex {\\n\\t\\t\\tresult += len(nums) - maximumIndex\\n\\t\\t}\\n\\t\\tif halfIndex == minimumIndex || halfIndex == maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t}\\n\\t}\\n    return result;\\n}\\n"
                    },
                    {
                        "username": "abhishek562",
                        "content": "Does anyone else facing problem in [1,0,1] case ?"
                    },
                    {
                        "username": "rashmirashmitha32",
                        "content": "felt easy first, then felt required deep thinking, once caught the logic felt easy again"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Purely a logic-based problem"
                    },
                    {
                        "username": "Shreyans30",
                        "content": "It should be marked as easy."
                    }
                ]
            },
            {
                "id": 1837900,
                "content": [
                    {
                        "username": "RayanYI",
                        "content": "Gently easy am I wrong ?"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I think this can be easiest medium problem encountered so far!\\nJust think of 3 ways to delete.\\n- both deletions from front \\n- both deletions from back\\n- one from front and other from back.\\ntake minimum of 3 ways"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "its long....!"
                    },
                    {
                        "username": "withrvr",
                        "content": "# As given in Example only \\u2705\\n### If seen properly\\n### Try to Solve using this Logic .... ez \\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\n\\n# 3 Cases are Posssible\\n- both delete from left ( then rightmost index )\\n- both delete from right ( then leftmost index )\\n- right and left together ( like edges )\\n\\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "its helps"
                    },
                    {
                        "username": "Shubham0111",
                        "content": "I have a solution in go in O(n). It passed 57/62 testcases. can anyone please help me why this solution failing few edge cases.\\nfunc minimumDeletions(nums []int) int {\\n   var maximum, minimum, result int = nums[0], nums[0], 0\\n\\tvar maximumIndex, minimumIndex int\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif maximum < nums[i] {\\n\\t\\t\\tmaximum = nums[i]\\n\\t\\t\\tmaximumIndex = i\\n\\t\\t}\\n\\t\\tif minimum > nums[i] {\\n\\t\\t\\tminimum = nums[i]\\n\\t\\t\\tminimumIndex = i\\n\\t\\t}\\n\\t}\\n\\thalfIndex := len(nums) / 2\\n\\n\\tif halfIndex >= maximumIndex && halfIndex >= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t}\\n\\t\\tresult += temp + 1\\n\\t} else if halfIndex <= maximumIndex && halfIndex <= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t}\\n\\t\\tresult += len(nums) - temp\\n\\t} else {\\n\\t\\tif halfIndex > minimumIndex {\\n\\t\\t\\tresult += minimumIndex + 1\\n\\t\\t} else if halfIndex < minimumIndex {\\n\\t\\t\\tresult += len(nums) - minimumIndex\\n\\t\\t}\\n\\t\\tif halfIndex > maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t} else if halfIndex < maximumIndex {\\n\\t\\t\\tresult += len(nums) - maximumIndex\\n\\t\\t}\\n\\t\\tif halfIndex == minimumIndex || halfIndex == maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t}\\n\\t}\\n    return result;\\n}\\n"
                    },
                    {
                        "username": "abhishek562",
                        "content": "Does anyone else facing problem in [1,0,1] case ?"
                    },
                    {
                        "username": "rashmirashmitha32",
                        "content": "felt easy first, then felt required deep thinking, once caught the logic felt easy again"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Purely a logic-based problem"
                    },
                    {
                        "username": "Shreyans30",
                        "content": "It should be marked as easy."
                    }
                ]
            },
            {
                "id": 1792899,
                "content": [
                    {
                        "username": "RayanYI",
                        "content": "Gently easy am I wrong ?"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I think this can be easiest medium problem encountered so far!\\nJust think of 3 ways to delete.\\n- both deletions from front \\n- both deletions from back\\n- one from front and other from back.\\ntake minimum of 3 ways"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "its long....!"
                    },
                    {
                        "username": "withrvr",
                        "content": "# As given in Example only \\u2705\\n### If seen properly\\n### Try to Solve using this Logic .... ez \\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\n\\n# 3 Cases are Posssible\\n- both delete from left ( then rightmost index )\\n- both delete from right ( then leftmost index )\\n- right and left together ( like edges )\\n\\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "its helps"
                    },
                    {
                        "username": "Shubham0111",
                        "content": "I have a solution in go in O(n). It passed 57/62 testcases. can anyone please help me why this solution failing few edge cases.\\nfunc minimumDeletions(nums []int) int {\\n   var maximum, minimum, result int = nums[0], nums[0], 0\\n\\tvar maximumIndex, minimumIndex int\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif maximum < nums[i] {\\n\\t\\t\\tmaximum = nums[i]\\n\\t\\t\\tmaximumIndex = i\\n\\t\\t}\\n\\t\\tif minimum > nums[i] {\\n\\t\\t\\tminimum = nums[i]\\n\\t\\t\\tminimumIndex = i\\n\\t\\t}\\n\\t}\\n\\thalfIndex := len(nums) / 2\\n\\n\\tif halfIndex >= maximumIndex && halfIndex >= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t}\\n\\t\\tresult += temp + 1\\n\\t} else if halfIndex <= maximumIndex && halfIndex <= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t}\\n\\t\\tresult += len(nums) - temp\\n\\t} else {\\n\\t\\tif halfIndex > minimumIndex {\\n\\t\\t\\tresult += minimumIndex + 1\\n\\t\\t} else if halfIndex < minimumIndex {\\n\\t\\t\\tresult += len(nums) - minimumIndex\\n\\t\\t}\\n\\t\\tif halfIndex > maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t} else if halfIndex < maximumIndex {\\n\\t\\t\\tresult += len(nums) - maximumIndex\\n\\t\\t}\\n\\t\\tif halfIndex == minimumIndex || halfIndex == maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t}\\n\\t}\\n    return result;\\n}\\n"
                    },
                    {
                        "username": "abhishek562",
                        "content": "Does anyone else facing problem in [1,0,1] case ?"
                    },
                    {
                        "username": "rashmirashmitha32",
                        "content": "felt easy first, then felt required deep thinking, once caught the logic felt easy again"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Purely a logic-based problem"
                    },
                    {
                        "username": "Shreyans30",
                        "content": "It should be marked as easy."
                    }
                ]
            },
            {
                "id": 1706274,
                "content": [
                    {
                        "username": "RayanYI",
                        "content": "Gently easy am I wrong ?"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I think this can be easiest medium problem encountered so far!\\nJust think of 3 ways to delete.\\n- both deletions from front \\n- both deletions from back\\n- one from front and other from back.\\ntake minimum of 3 ways"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "its long....!"
                    },
                    {
                        "username": "withrvr",
                        "content": "# As given in Example only \\u2705\\n### If seen properly\\n### Try to Solve using this Logic .... ez \\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\n\\n# 3 Cases are Posssible\\n- both delete from left ( then rightmost index )\\n- both delete from right ( then leftmost index )\\n- right and left together ( like edges )\\n\\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "its helps"
                    },
                    {
                        "username": "Shubham0111",
                        "content": "I have a solution in go in O(n). It passed 57/62 testcases. can anyone please help me why this solution failing few edge cases.\\nfunc minimumDeletions(nums []int) int {\\n   var maximum, minimum, result int = nums[0], nums[0], 0\\n\\tvar maximumIndex, minimumIndex int\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif maximum < nums[i] {\\n\\t\\t\\tmaximum = nums[i]\\n\\t\\t\\tmaximumIndex = i\\n\\t\\t}\\n\\t\\tif minimum > nums[i] {\\n\\t\\t\\tminimum = nums[i]\\n\\t\\t\\tminimumIndex = i\\n\\t\\t}\\n\\t}\\n\\thalfIndex := len(nums) / 2\\n\\n\\tif halfIndex >= maximumIndex && halfIndex >= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t}\\n\\t\\tresult += temp + 1\\n\\t} else if halfIndex <= maximumIndex && halfIndex <= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t}\\n\\t\\tresult += len(nums) - temp\\n\\t} else {\\n\\t\\tif halfIndex > minimumIndex {\\n\\t\\t\\tresult += minimumIndex + 1\\n\\t\\t} else if halfIndex < minimumIndex {\\n\\t\\t\\tresult += len(nums) - minimumIndex\\n\\t\\t}\\n\\t\\tif halfIndex > maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t} else if halfIndex < maximumIndex {\\n\\t\\t\\tresult += len(nums) - maximumIndex\\n\\t\\t}\\n\\t\\tif halfIndex == minimumIndex || halfIndex == maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t}\\n\\t}\\n    return result;\\n}\\n"
                    },
                    {
                        "username": "abhishek562",
                        "content": "Does anyone else facing problem in [1,0,1] case ?"
                    },
                    {
                        "username": "rashmirashmitha32",
                        "content": "felt easy first, then felt required deep thinking, once caught the logic felt easy again"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Purely a logic-based problem"
                    },
                    {
                        "username": "Shreyans30",
                        "content": "It should be marked as easy."
                    }
                ]
            },
            {
                "id": 2061447,
                "content": [
                    {
                        "username": "RayanYI",
                        "content": "Gently easy am I wrong ?"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I think this can be easiest medium problem encountered so far!\\nJust think of 3 ways to delete.\\n- both deletions from front \\n- both deletions from back\\n- one from front and other from back.\\ntake minimum of 3 ways"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "its long....!"
                    },
                    {
                        "username": "withrvr",
                        "content": "# As given in Example only \\u2705\\n### If seen properly\\n### Try to Solve using this Logic .... ez \\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\n\\n# 3 Cases are Posssible\\n- both delete from left ( then rightmost index )\\n- both delete from right ( then leftmost index )\\n- right and left together ( like edges )\\n\\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "its helps"
                    },
                    {
                        "username": "Shubham0111",
                        "content": "I have a solution in go in O(n). It passed 57/62 testcases. can anyone please help me why this solution failing few edge cases.\\nfunc minimumDeletions(nums []int) int {\\n   var maximum, minimum, result int = nums[0], nums[0], 0\\n\\tvar maximumIndex, minimumIndex int\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif maximum < nums[i] {\\n\\t\\t\\tmaximum = nums[i]\\n\\t\\t\\tmaximumIndex = i\\n\\t\\t}\\n\\t\\tif minimum > nums[i] {\\n\\t\\t\\tminimum = nums[i]\\n\\t\\t\\tminimumIndex = i\\n\\t\\t}\\n\\t}\\n\\thalfIndex := len(nums) / 2\\n\\n\\tif halfIndex >= maximumIndex && halfIndex >= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t}\\n\\t\\tresult += temp + 1\\n\\t} else if halfIndex <= maximumIndex && halfIndex <= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t}\\n\\t\\tresult += len(nums) - temp\\n\\t} else {\\n\\t\\tif halfIndex > minimumIndex {\\n\\t\\t\\tresult += minimumIndex + 1\\n\\t\\t} else if halfIndex < minimumIndex {\\n\\t\\t\\tresult += len(nums) - minimumIndex\\n\\t\\t}\\n\\t\\tif halfIndex > maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t} else if halfIndex < maximumIndex {\\n\\t\\t\\tresult += len(nums) - maximumIndex\\n\\t\\t}\\n\\t\\tif halfIndex == minimumIndex || halfIndex == maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t}\\n\\t}\\n    return result;\\n}\\n"
                    },
                    {
                        "username": "abhishek562",
                        "content": "Does anyone else facing problem in [1,0,1] case ?"
                    },
                    {
                        "username": "rashmirashmitha32",
                        "content": "felt easy first, then felt required deep thinking, once caught the logic felt easy again"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Purely a logic-based problem"
                    },
                    {
                        "username": "Shreyans30",
                        "content": "It should be marked as easy."
                    }
                ]
            },
            {
                "id": 2048005,
                "content": [
                    {
                        "username": "RayanYI",
                        "content": "Gently easy am I wrong ?"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I think this can be easiest medium problem encountered so far!\\nJust think of 3 ways to delete.\\n- both deletions from front \\n- both deletions from back\\n- one from front and other from back.\\ntake minimum of 3 ways"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "its long....!"
                    },
                    {
                        "username": "withrvr",
                        "content": "# As given in Example only \\u2705\\n### If seen properly\\n### Try to Solve using this Logic .... ez \\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\n\\n# 3 Cases are Posssible\\n- both delete from left ( then rightmost index )\\n- both delete from right ( then leftmost index )\\n- right and left together ( like edges )\\n\\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "its helps"
                    },
                    {
                        "username": "Shubham0111",
                        "content": "I have a solution in go in O(n). It passed 57/62 testcases. can anyone please help me why this solution failing few edge cases.\\nfunc minimumDeletions(nums []int) int {\\n   var maximum, minimum, result int = nums[0], nums[0], 0\\n\\tvar maximumIndex, minimumIndex int\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif maximum < nums[i] {\\n\\t\\t\\tmaximum = nums[i]\\n\\t\\t\\tmaximumIndex = i\\n\\t\\t}\\n\\t\\tif minimum > nums[i] {\\n\\t\\t\\tminimum = nums[i]\\n\\t\\t\\tminimumIndex = i\\n\\t\\t}\\n\\t}\\n\\thalfIndex := len(nums) / 2\\n\\n\\tif halfIndex >= maximumIndex && halfIndex >= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t}\\n\\t\\tresult += temp + 1\\n\\t} else if halfIndex <= maximumIndex && halfIndex <= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t}\\n\\t\\tresult += len(nums) - temp\\n\\t} else {\\n\\t\\tif halfIndex > minimumIndex {\\n\\t\\t\\tresult += minimumIndex + 1\\n\\t\\t} else if halfIndex < minimumIndex {\\n\\t\\t\\tresult += len(nums) - minimumIndex\\n\\t\\t}\\n\\t\\tif halfIndex > maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t} else if halfIndex < maximumIndex {\\n\\t\\t\\tresult += len(nums) - maximumIndex\\n\\t\\t}\\n\\t\\tif halfIndex == minimumIndex || halfIndex == maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t}\\n\\t}\\n    return result;\\n}\\n"
                    },
                    {
                        "username": "abhishek562",
                        "content": "Does anyone else facing problem in [1,0,1] case ?"
                    },
                    {
                        "username": "rashmirashmitha32",
                        "content": "felt easy first, then felt required deep thinking, once caught the logic felt easy again"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Purely a logic-based problem"
                    },
                    {
                        "username": "Shreyans30",
                        "content": "It should be marked as easy."
                    }
                ]
            },
            {
                "id": 2045097,
                "content": [
                    {
                        "username": "RayanYI",
                        "content": "Gently easy am I wrong ?"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I think this can be easiest medium problem encountered so far!\\nJust think of 3 ways to delete.\\n- both deletions from front \\n- both deletions from back\\n- one from front and other from back.\\ntake minimum of 3 ways"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "its long....!"
                    },
                    {
                        "username": "withrvr",
                        "content": "# As given in Example only \\u2705\\n### If seen properly\\n### Try to Solve using this Logic .... ez \\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\n\\n# 3 Cases are Posssible\\n- both delete from left ( then rightmost index )\\n- both delete from right ( then leftmost index )\\n- right and left together ( like edges )\\n\\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "its helps"
                    },
                    {
                        "username": "Shubham0111",
                        "content": "I have a solution in go in O(n). It passed 57/62 testcases. can anyone please help me why this solution failing few edge cases.\\nfunc minimumDeletions(nums []int) int {\\n   var maximum, minimum, result int = nums[0], nums[0], 0\\n\\tvar maximumIndex, minimumIndex int\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif maximum < nums[i] {\\n\\t\\t\\tmaximum = nums[i]\\n\\t\\t\\tmaximumIndex = i\\n\\t\\t}\\n\\t\\tif minimum > nums[i] {\\n\\t\\t\\tminimum = nums[i]\\n\\t\\t\\tminimumIndex = i\\n\\t\\t}\\n\\t}\\n\\thalfIndex := len(nums) / 2\\n\\n\\tif halfIndex >= maximumIndex && halfIndex >= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t}\\n\\t\\tresult += temp + 1\\n\\t} else if halfIndex <= maximumIndex && halfIndex <= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t}\\n\\t\\tresult += len(nums) - temp\\n\\t} else {\\n\\t\\tif halfIndex > minimumIndex {\\n\\t\\t\\tresult += minimumIndex + 1\\n\\t\\t} else if halfIndex < minimumIndex {\\n\\t\\t\\tresult += len(nums) - minimumIndex\\n\\t\\t}\\n\\t\\tif halfIndex > maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t} else if halfIndex < maximumIndex {\\n\\t\\t\\tresult += len(nums) - maximumIndex\\n\\t\\t}\\n\\t\\tif halfIndex == minimumIndex || halfIndex == maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t}\\n\\t}\\n    return result;\\n}\\n"
                    },
                    {
                        "username": "abhishek562",
                        "content": "Does anyone else facing problem in [1,0,1] case ?"
                    },
                    {
                        "username": "rashmirashmitha32",
                        "content": "felt easy first, then felt required deep thinking, once caught the logic felt easy again"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Purely a logic-based problem"
                    },
                    {
                        "username": "Shreyans30",
                        "content": "It should be marked as easy."
                    }
                ]
            },
            {
                "id": 2013083,
                "content": [
                    {
                        "username": "RayanYI",
                        "content": "Gently easy am I wrong ?"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I think this can be easiest medium problem encountered so far!\\nJust think of 3 ways to delete.\\n- both deletions from front \\n- both deletions from back\\n- one from front and other from back.\\ntake minimum of 3 ways"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "its long....!"
                    },
                    {
                        "username": "withrvr",
                        "content": "# As given in Example only \\u2705\\n### If seen properly\\n### Try to Solve using this Logic .... ez \\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\n\\n# 3 Cases are Posssible\\n- both delete from left ( then rightmost index )\\n- both delete from right ( then leftmost index )\\n- right and left together ( like edges )\\n\\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "its helps"
                    },
                    {
                        "username": "Shubham0111",
                        "content": "I have a solution in go in O(n). It passed 57/62 testcases. can anyone please help me why this solution failing few edge cases.\\nfunc minimumDeletions(nums []int) int {\\n   var maximum, minimum, result int = nums[0], nums[0], 0\\n\\tvar maximumIndex, minimumIndex int\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif maximum < nums[i] {\\n\\t\\t\\tmaximum = nums[i]\\n\\t\\t\\tmaximumIndex = i\\n\\t\\t}\\n\\t\\tif minimum > nums[i] {\\n\\t\\t\\tminimum = nums[i]\\n\\t\\t\\tminimumIndex = i\\n\\t\\t}\\n\\t}\\n\\thalfIndex := len(nums) / 2\\n\\n\\tif halfIndex >= maximumIndex && halfIndex >= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t}\\n\\t\\tresult += temp + 1\\n\\t} else if halfIndex <= maximumIndex && halfIndex <= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t}\\n\\t\\tresult += len(nums) - temp\\n\\t} else {\\n\\t\\tif halfIndex > minimumIndex {\\n\\t\\t\\tresult += minimumIndex + 1\\n\\t\\t} else if halfIndex < minimumIndex {\\n\\t\\t\\tresult += len(nums) - minimumIndex\\n\\t\\t}\\n\\t\\tif halfIndex > maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t} else if halfIndex < maximumIndex {\\n\\t\\t\\tresult += len(nums) - maximumIndex\\n\\t\\t}\\n\\t\\tif halfIndex == minimumIndex || halfIndex == maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t}\\n\\t}\\n    return result;\\n}\\n"
                    },
                    {
                        "username": "abhishek562",
                        "content": "Does anyone else facing problem in [1,0,1] case ?"
                    },
                    {
                        "username": "rashmirashmitha32",
                        "content": "felt easy first, then felt required deep thinking, once caught the logic felt easy again"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Purely a logic-based problem"
                    },
                    {
                        "username": "Shreyans30",
                        "content": "It should be marked as easy."
                    }
                ]
            },
            {
                "id": 1985499,
                "content": [
                    {
                        "username": "RayanYI",
                        "content": "Gently easy am I wrong ?"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "I think this can be easiest medium problem encountered so far!\\nJust think of 3 ways to delete.\\n- both deletions from front \\n- both deletions from back\\n- one from front and other from back.\\ntake minimum of 3 ways"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "its long....!"
                    },
                    {
                        "username": "withrvr",
                        "content": "# As given in Example only \\u2705\\n### If seen properly\\n### Try to Solve using this Logic .... ez \\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\n\\n# 3 Cases are Posssible\\n- both delete from left ( then rightmost index )\\n- both delete from right ( then leftmost index )\\n- right and left together ( like edges )\\n\\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "its helps"
                    },
                    {
                        "username": "Shubham0111",
                        "content": "I have a solution in go in O(n). It passed 57/62 testcases. can anyone please help me why this solution failing few edge cases.\\nfunc minimumDeletions(nums []int) int {\\n   var maximum, minimum, result int = nums[0], nums[0], 0\\n\\tvar maximumIndex, minimumIndex int\\n\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tif maximum < nums[i] {\\n\\t\\t\\tmaximum = nums[i]\\n\\t\\t\\tmaximumIndex = i\\n\\t\\t}\\n\\t\\tif minimum > nums[i] {\\n\\t\\t\\tminimum = nums[i]\\n\\t\\t\\tminimumIndex = i\\n\\t\\t}\\n\\t}\\n\\thalfIndex := len(nums) / 2\\n\\n\\tif halfIndex >= maximumIndex && halfIndex >= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t}\\n\\t\\tresult += temp + 1\\n\\t} else if halfIndex <= maximumIndex && halfIndex <= minimumIndex {\\n\\t\\tvar temp int\\n\\t\\tif minimumIndex > maximumIndex {\\n\\t\\t\\ttemp = maximumIndex\\n\\t\\t} else {\\n\\t\\t\\ttemp = minimumIndex\\n\\t\\t}\\n\\t\\tresult += len(nums) - temp\\n\\t} else {\\n\\t\\tif halfIndex > minimumIndex {\\n\\t\\t\\tresult += minimumIndex + 1\\n\\t\\t} else if halfIndex < minimumIndex {\\n\\t\\t\\tresult += len(nums) - minimumIndex\\n\\t\\t}\\n\\t\\tif halfIndex > maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t} else if halfIndex < maximumIndex {\\n\\t\\t\\tresult += len(nums) - maximumIndex\\n\\t\\t}\\n\\t\\tif halfIndex == minimumIndex || halfIndex == maximumIndex {\\n\\t\\t\\tresult += maximumIndex + 1\\n\\t\\t}\\n\\t}\\n    return result;\\n}\\n"
                    },
                    {
                        "username": "abhishek562",
                        "content": "Does anyone else facing problem in [1,0,1] case ?"
                    },
                    {
                        "username": "rashmirashmitha32",
                        "content": "felt easy first, then felt required deep thinking, once caught the logic felt easy again"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Purely a logic-based problem"
                    },
                    {
                        "username": "Shreyans30",
                        "content": "It should be marked as easy."
                    }
                ]
            }
        ]
    }
]