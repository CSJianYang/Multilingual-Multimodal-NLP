[
    {
        "title": "Long Pressed Name",
        "question_content": "Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.\nYou examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.\n&nbsp;\nExample 1:\n\nInput: name = \"alex\", typed = \"aaleex\"\nOutput: true\nExplanation: 'a' and 'e' in 'alex' were long pressed.\n\nExample 2:\n\nInput: name = \"saeed\", typed = \"ssaaedd\"\nOutput: false\nExplanation: 'e' must have been pressed twice, but it was not in the typed output.\n\n&nbsp;\nConstraints:\n\n\t1 <= name.length, typed.length <= 1000\n\tname and typed consist of only lowercase English letters.",
        "solutions": [
            {
                "id": 183994,
                "title": "c-java-python-two-pointers",
                "content": "**C++:**\\n```\\n    bool isLongPressedName(string name, string typed) {\\n        int i = 0, m = name.length(), n = typed.length();\\n        for (int j = 0; j < n; ++j)\\n            if (i < m && name[i] == typed[j])\\n                ++i;\\n            else if (!j || typed[j] != typed[j - 1])\\n                return false;\\n        return i == m;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i = 0, m = name.length(), n = typed.length();\\n        for (int j = 0; j < n; ++j)\\n            if (i < m && name.charAt(i) == typed.charAt(j))\\n                ++i;\\n            else if (j == 0 || typed.charAt(j) != typed.charAt(j - 1))\\n                return false;\\n        return i == m;\\n    }\\n```\\n**Python:**\\n```\\n    def isLongPressedName(self, name, typed):\\n        i = 0\\n        for j in range(len(typed)):\\n            if i < len(name) and name[i] == typed[j]:\\n                i += 1\\n            elif j == 0 or typed[j] != typed[j - 1]:\\n                return False\\n        return i == len(name)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    bool isLongPressedName(string name, string typed) {\\n        int i = 0, m = name.length(), n = typed.length();\\n        for (int j = 0; j < n; ++j)\\n            if (i < m && name[i] == typed[j])\\n                ++i;\\n            else if (!j || typed[j] != typed[j - 1])\\n                return false;\\n        return i == m;\\n    }\\n```\n```\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i = 0, m = name.length(), n = typed.length();\\n        for (int j = 0; j < n; ++j)\\n            if (i < m && name.charAt(i) == typed.charAt(j))\\n                ++i;\\n            else if (j == 0 || typed.charAt(j) != typed.charAt(j - 1))\\n                return false;\\n        return i == m;\\n    }\\n```\n```\\n    def isLongPressedName(self, name, typed):\\n        i = 0\\n        for j in range(len(typed)):\\n            if i < len(name) and name[i] == typed[j]:\\n                i += 1\\n            elif j == 0 or typed[j] != typed[j - 1]:\\n                return False\\n        return i == len(name)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 184488,
                "title": "java-one-pass-solution-4ms-with-o-1-extra-space",
                "content": "The idea evert letter in **typed** should be the same as **name**, but \"shifted\" (or spreaded to be more exact) to some number of positions.\\nThat\\'s why, we go through **typed** and trying to identify if we have a corrponding letter in **name**. At the same time, we calculate the difference in positions of these corresponding letters in **typed** and **name**. In other words, difference identicates how many \"additional\" letters contains **typed**. For example:\\nname: **AABCD**\\ntyped: **AAAABBCDDDDDD**\\n\\nAt the beginning difference is 0.\\nWe go through **AAAABBCDDDDDD**:\\nCompare first letter of **typed** and **name**:\\n![image](https://assets.leetcode.com/users/olsh/image_1540209344.png)\\n\\n\\nThe are equal -> all is ok, go further, difference remains unchanged\\n![image](https://assets.leetcode.com/users/olsh/image_1540209466.png)\\n\\n\\nAgain equal -> go next:\\n![image](https://assets.leetcode.com/users/olsh/image_1540210445.png)\\n\\n\\nNot equal, but we can link **A** (**typed**)  to  **A** (**name**) from the previous step. As a result, our difference was incremented:\\n![image](https://assets.leetcode.com/users/olsh/image_1540210721.png)\\n\\n\\nThe same will do next: **A** (**typed**) != **B** (**name**), but we can link **A** (**typed**) to **A** (**name**) from the previous step -> the difference was incremented again:\\n![image](https://assets.leetcode.com/users/olsh/image_1540210926.png)\\n\\n\\n\\nAt the end of all these manipulations, we see the following:\\n![image](https://assets.leetcode.com/users/olsh/image_1540208693.png)\\nThe whole implementation:\\n```\\nclass Solution {\\n public boolean isLongPressedName(String name, String typed) {\\n  int difference = 0;\\n  for (int i = 0; i < typed.length();) {\\n\\t//letters are equal -> go next\\n   if (difference <= i && i - difference < name.length() && typed.charAt(i) == name.charAt(i - difference)) {\\n    i++;\\n   } \\n\\t // letters are not equal,  but we can link typed letter to name letter from the previous iteration\\n\\t else if (difference < i && i - difference - 1 < name.length() && typed.charAt(i) == name.charAt(i - difference - 1)) {\\n    difference++;\\n   } else return false;\\n  }\\n\\t// check that at the end of name there\\'s no odd symbols\\n    return typed.length() - difference == name.length();\\n }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public boolean isLongPressedName(String name, String typed) {\\n  int difference = 0;\\n  for (int i = 0; i < typed.length();) {\\n\\t//letters are equal -> go next\\n   if (difference <= i && i - difference < name.length() && typed.charAt(i) == name.charAt(i - difference)) {\\n    i++;\\n   } \\n\\t // letters are not equal,  but we can link typed letter to name letter from the previous iteration\\n\\t else if (difference < i && i - difference - 1 < name.length() && typed.charAt(i) == name.charAt(i - difference - 1)) {\\n    difference++;\\n   } else return false;\\n  }\\n\\t// check that at the end of name there\\'s no odd symbols\\n    return typed.length() - difference == name.length();\\n }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238723,
                "title": "java-2-pointers-natural-general-easiest-to-understand-code",
                "content": "Don\\'t have much time, but the keys are:\\n1. 2 pointers `i` and `j` are handling the same characters at the same time(let\\'s say `c`)\\n2. The count of consecutive `c` in `typed` >= the count of  consecutive  `c` in `name`\\n\\n```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int m = name.length(), n = typed.length();\\n        int i = 0, j = 0;\\n        \\n        while(i < m && j < n){\\n            char c1 = name.charAt(i), c2 = typed.charAt(j);\\n            if(c1 != c2) return false; // we are handling different chars, no!\\n            \\n\\t\\t\\t// count of consecutive c1/c2\\n            int count1 = 0; \\n            while(i < m && name.charAt(i) == c1){\\n                count1++;\\n                i++;\\n            }\\n            \\n\\t\\t\\t// count of consecutive c1/c2\\n            int count2 = 0; \\n            while(j < n && typed.charAt(j) == c2){\\n                count2++;\\n                j++;\\n            }\\n            \\n            if(count2 < count1) return false;\\n        }\\n        \\n\\t\\t// they both reach the end\\n        return i == m && j == n;\\n    }\\n}\\n```\\n\\ntime complexity: `O(m + n)`\\nspace complexity: `O(1)`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int m = name.length(), n = typed.length();\\n        int i = 0, j = 0;\\n        \\n        while(i < m && j < n){\\n            char c1 = name.charAt(i), c2 = typed.charAt(j);\\n            if(c1 != c2) return false; // we are handling different chars, no!\\n            \\n\\t\\t\\t// count of consecutive c1/c2\\n            int count1 = 0; \\n            while(i < m && name.charAt(i) == c1){\\n                count1++;\\n                i++;\\n            }\\n            \\n\\t\\t\\t// count of consecutive c1/c2\\n            int count2 = 0; \\n            while(j < n && typed.charAt(j) == c2){\\n                count2++;\\n                j++;\\n            }\\n            \\n            if(count2 < count1) return false;\\n        }\\n        \\n\\t\\t// they both reach the end\\n        return i == m && j == n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 183929,
                "title": "c-2-lines-accepted-and-5-lines-accurate",
                "content": "This very naive solution got accepted. It fails of course for any test case where ```typed``` contains extra letters.\\n```\\nbool isLongPressedName(string name, string typed, int i = 0) {\\n    for (auto c : typed) i += name[i] == c;\\n    return i == name.size();\\n}\\n```\\nHere is a bit more lengthy but accurate solution:\\n```\\nbool isLongPressedName(string name, string typed, int i = 0, int j = 0) {\\n    while (j < typed.size()) {\\n        if (i < name.size() && name[i] == typed[j]) ++i, ++j;\\n        else if (i > 0 && name[i - 1] == typed[j]) ++j;\\n        else return false;\\n    }\\n    return i == name.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```typed```\n```\\nbool isLongPressedName(string name, string typed, int i = 0) {\\n    for (auto c : typed) i += name[i] == c;\\n    return i == name.size();\\n}\\n```\n```\\nbool isLongPressedName(string name, string typed, int i = 0, int j = 0) {\\n    while (j < typed.size()) {\\n        if (i < name.size() && name[i] == typed[j]) ++i, ++j;\\n        else if (i > 0 && name[i - 1] == typed[j]) ++j;\\n        else return false;\\n    }\\n    return i == name.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1312505,
                "title": "java-two-pointer-1ms-solution-faster-than-100-solutions",
                "content": "Two Pointer Easy Approach with added comments to understand. Please do up-vote if you do find this solution helpful.\\n\\n\\n\\'\\'\\'\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        \\n        int i=1 , j=1;\\n        \\n        //Checking the first character\\n        if(name.charAt(0) != typed.charAt(0))\\n            return false;\\n        \\n        \\n        //Traversing the Strings using two pointer\\n        while(i<name.length() && j<typed.length()){\\n            if(name.charAt(i) == typed.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            \\n            else {  \\n                if(typed.charAt(j) == typed.charAt(j-1))\\n                    j++;\\n                \\n                else\\n                    return false;    \\n            }\\n        }\\n        \\n        \\n        //Case 1 : i and j both reached end of the String\\n        if(i == name.length() && j == typed.length())\\n            return true;\\n        \\n        //Case 2 : First word is not yet complete traversed. The second word is complete\\n        else if(i != name.length() && j == typed.length())\\n            return false;\\n        \\n        //Case 3: First word complete. The second word still has some characters left.\\n        else{\\n            while(j != typed.length()){\\n                if(typed.charAt(j) == typed.charAt(j-1))\\n                    j++;\\n                \\n                else\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        \\n        int i=1 , j=1;\\n        \\n        //Checking the first character\\n        if(name.charAt(0) != typed.charAt(0))\\n            return false;\\n        \\n        \\n        //Traversing the Strings using two pointer\\n        while(i<name.length() && j<typed.length()){\\n            if(name.charAt(i) == typed.charAt(j)){\\n                i++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 698368,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution(object):\\n    def isLongPressedName(self, name, typed):\\n        \"\"\"\\n        :type name: str\\n        :type typed: str\\n        :rtype: bool\\n        \"\"\"\\n        j = 0\\n        i = 0\\n        n = len(name)\\n        t = len(typed)\\n        \\n        while j < t:\\n            if i < n and name[i] == typed[j]:\\n                i +=1\\n            elif j == 0 or typed[j] != typed[j-1]:\\n                return False\\n            j +=1\\n        return i == n\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isLongPressedName(self, name, typed):\\n        \"\"\"\\n        :type name: str\\n        :type typed: str\\n        :rtype: bool\\n        \"\"\"\\n        j = 0\\n        i = 0\\n        n = len(name)\\n        t = len(typed)\\n        \\n        while j < t:\\n            if i < n and name[i] == typed[j]:\\n                i +=1\\n            elif j == 0 or typed[j] != typed[j-1]:\\n                return False\\n            j +=1\\n        return i == n\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 220554,
                "title": "c-4ms-simple-answer",
                "content": "\\n    bool isLongPressedName(string name, string typed) {\\n        int i =0; int j =0;\\n        while(i<name.size() || j <typed.size()) {\\n            char current = name[i];\\n            if(name[i] != typed[j]) return false;\\n            i++;\\n            j++;\\n            if(name[i] != typed[j]) {\\n                while(current == typed[j]) j++;\\n            } \\n        }\\n        return true;\\n    };",
                "solutionTags": [],
                "code": "\\n    bool isLongPressedName(string name, string typed) {\\n        int i =0; int j =0;\\n        while(i<name.size() || j <typed.size()) {\\n            char current = name[i];\\n            if(name[i] != typed[j]) return false;\\n            i++;\\n            j++;\\n            if(name[i] != typed[j]) {\\n                while(current == typed[j]) j++;\\n            } \\n        }\\n        return true;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 183965,
                "title": "short-java-solution",
                "content": "```java\\npublic boolean isLongPressedName(String nameStr, String typeStr) {\\n        char[] name = nameStr.toCharArray(), typed = typeStr.toCharArray();\\n        int n = 0, t = 0;\\n        while (n < name.length && t < typed.length) {\\n            int need = 1;\\n            char c = name[n++];\\n            while (n < name.length && c == name[n]) {\\n                n++;\\n                need++;\\n            }\\n            while (t < typed.length && typed[t] == c) {\\n                need--;\\n                t++;\\n            }\\n            if (need > 0)\\n                return false;\\n        }\\n        return n == name.length && t == typed.length;\\n    }",
                "solutionTags": [],
                "code": "```java\\npublic boolean isLongPressedName(String nameStr, String typeStr) {\\n        char[] name = nameStr.toCharArray(), typed = typeStr.toCharArray();\\n        int n = 0, t = 0;\\n        while (n < name.length && t < typed.length) {\\n            int need = 1;\\n            char c = name[n++];\\n            while (n < name.length && c == name[n]) {\\n                n++;\\n                need++;\\n            }\\n            while (t < typed.length && typed[t] == c) {\\n                need--;\\n                t++;\\n            }\\n            if (need > 0)\\n                return false;\\n        }\\n        return n == name.length && t == typed.length;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1343001,
                "title": "python3-2-pointers",
                "content": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        ni = 0       # index of name\\n        ti = 0       # index of typed\\n        while ni <= len(name) and ti < len(typed):\\n            if ni < len(name) and typed[ti] == name[ni]:\\n                ti += 1\\n                ni += 1\\n            elif typed[ti] == name[ni-1] and ni != 0:\\n                ti += 1\\n            else:\\n                return False\\n            \\n        return ni == len(name) and ti == len(typed)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        ni = 0       # index of name\\n        ti = 0       # index of typed\\n        while ni <= len(name) and ti < len(typed):\\n            if ni < len(name) and typed[ti] == name[ni]:\\n                ti += 1\\n                ni += 1\\n            elif typed[ti] == name[ni-1] and ni != 0:\\n                ti += 1\\n            else:\\n                return False\\n            \\n        return ni == len(name) and ti == len(typed)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896406,
                "title": "0-ms-100-faster-c-clean-easy-two-pointers",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isLongPressedName(string name, string typed) {\\n\\t\\t\\tif(name.size()>typed.size())\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tint i=0,j=0;\\n\\t\\t\\twhile(i<name.size() && j<typed.size()){\\n\\t\\t\\t\\tif(name[i]==typed[j]){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(j!=0 && typed[j]==typed[j-1]){\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\twhile(j<typed.size()){\\n\\t\\t\\t\\tif(typed[j]==typed[j-1])\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\treturn i==name.size();\\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isLongPressedName(string name, string typed) {\\n\\t\\t\\tif(name.size()>typed.size())\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tint i=0,j=0;\\n\\t\\t\\twhile(i<name.size() && j<typed.size()){\\n\\t\\t\\t\\tif(name[i]==typed[j]){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 843049,
                "title": "easy-understanding-3-ways-c",
                "content": "```\\n//1.[ faster than 100.00%][Runtime: 0 ms]\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        if(name[0]!=typed[0]) return false;\\n        int i=0,j=0;\\n        while(i<typed.size() || j<name.size()){\\n            if(typed[i]==name[j]) j++;\\n            else if(typed[i]!=typed[i-1]) return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n//2.[ faster than 100.00%][Runtime: 0ms]\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n    if(name.size()>typed.size()) return false;\\n    \\n    if(name[0]!=typed[0]) return false;\\n    \\n    int i=1,j=1;\\n    while(i<name.size() && j<typed.size()){\\n        if(name[i]==typed[j])\\n            i++,j++;\\n        else if(typed[j]==typed[j-1])\\n            j++;\\n        else\\n            return false;\\n    }\\n    \\n    while(j<typed.size()){\\n        if(typed[j]!=typed[j-1]) return false;\\n        j++;\\n    }\\n    \\n    if(i==name.size())\\n        return true;\\n    else\\n        return false;\\n    }\\n};\\n//3.[Runtime: 4 ms]\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) \\n    {\\n        for(int i=0; i<typed.size(); i++){\\n            while((i+1 < typed.size()) && (typed[i] == typed[i+1]) && (name[i+1] != typed[i+1]))\\n                 typed.erase(i+1, 1);\\n        }\\n        \\n        if(name == typed)\\n            return true;\\n        return false;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//1.[ faster than 100.00%][Runtime: 0 ms]\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        if(name[0]!=typed[0]) return false;\\n        int i=0,j=0;\\n        while(i<typed.size() || j<name.size()){\\n            if(typed[i]==name[j]) j++;\\n            else if(typed[i]!=typed[i-1]) return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n//2.[ faster than 100.00%][Runtime: 0ms]\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n    if(name.size()>typed.size()) return false;\\n    \\n    if(name[0]!=typed[0]) return false;\\n    \\n    int i=1,j=1;\\n    while(i<name.size() && j<typed.size()){\\n        if(name[i]==typed[j])\\n            i++,j++;\\n        else if(typed[j]==typed[j-1])\\n            j++;\\n        else\\n            return false;\\n    }\\n    \\n    while(j<typed.size()){\\n        if(typed[j]!=typed[j-1]) return false;\\n        j++;\\n    }\\n    \\n    if(i==name.size())\\n        return true;\\n    else\\n        return false;\\n    }\\n};\\n//3.[Runtime: 4 ms]\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) \\n    {\\n        for(int i=0; i<typed.size(); i++){\\n            while((i+1 < typed.size()) && (typed[i] == typed[i+1]) && (name[i+1] != typed[i+1]))\\n                 typed.erase(i+1, 1);\\n        }\\n        \\n        if(name == typed)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214637,
                "title": "java-100ms-two-pointer-solution",
                "content": "class Solution {\\n\\n    public boolean isLongPressedName(String name, String typed) {\\n        \\n\\t\\tint n = name.length();\\n        int m = typed.length();\\n        int j = 0;\\n        char last = \\'@\\';\\n                \\n        for(int i = 0; i < m; i++){\\n            \\n            if(j < n && name.charAt(j) == typed.charAt(i)){\\n            \\n                last = typed.charAt(i);\\n                j++;\\n            }\\n            else if(typed.charAt(i) != last) {\\n                return false;\\n            }\\n        }\\n        \\n        \\n        return j == n;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\n    public boolean isLongPressedName(String name, String typed) {\\n        \\n\\t\\tint n = name.length();\\n        int m = typed.length();\\n        int j = 0;\\n        char last = \\'@\\';\\n                \\n        for(int i = 0; i < m; i++){\\n            \\n            if(j < n && name.charAt(j) == typed.charAt(i)){\\n            \\n                last = typed.charAt(i);\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 199144,
                "title": "7-line-python-beats-100",
                "content": "The idea is to iterate through the `typed` string, because it\\'s longer, checking against a particular location in `name` as you go. There are only a couple of possibilities:\\n\\n1. There is a match (`name[i] == typed[j]`). In this case you want to increment both pointers.\\n2. There isn\\'t a match `and` (given by `else` condition to case 1) there also isn\\'t a match to the *previous* character in `name` (`not name[i-1] == typed[j]`), in which case it\\'s clear the strings don\\'t meet the condition.\\n\\nNote you also have to be careful with the pointer `i` in to `name`, because it starts off not large enough to index `name` at `i-1`, and it can keep growing so long as there are matches. So ensure it\\'s greater than zero before entering the second condition, and cap it at `len(name)` for the cases like `[\\'vtkgn\\', \\'vttkgnn\\']`: `i` ends up being 5 at the end there while `j` keeps running along the extra `\\'n\\'`s, so we fall in to the second condition and check `name[i-1]` against `typed[j]`.\\n\\nIf we violate both conditions, we know the things don\\'t match, so we can return `False` immediately. If we meet both conditions for the duration of `typed`, then we only have to make sure we\\'ve also gotten entirely through the `name` so we catch cases like `[\\'pyplrz\\', \\'ppyypllr\\']`.\\n\\n        i = 0\\n        for j in range(len(typed)):\\n            if i < len(name) and name[i] == typed[j]:\\n                i += 1\\n            elif not i > 0 and name[i-1] == typed[j]:\\n                return False\\n        return i == len(name)",
                "solutionTags": [],
                "code": "The idea is to iterate through the `typed` string, because it\\'s longer, checking against a particular location in `name` as you go. There are only a couple of possibilities:\\n\\n1. There is a match (`name[i] == typed[j]`). In this case you want to increment both pointers.\\n2. There isn\\'t a match `and` (given by `else` condition to case 1) there also isn\\'t a match to the *previous* character in `name` (`not name[i-1] == typed[j]`), in which case it\\'s clear the strings don\\'t meet the condition.\\n\\nNote you also have to be careful with the pointer `i` in to `name`, because it starts off not large enough to index `name` at `i-1`, and it can keep growing so long as there are matches. So ensure it\\'s greater than zero before entering the second condition, and cap it at `len(name)` for the cases like `[\\'vtkgn\\', \\'vttkgnn\\']`: `i` ends up being 5 at the end there while `j` keeps running along the extra `\\'n\\'`s, so we fall in to the second condition and check `name[i-1]` against `typed[j]`.\\n\\nIf we violate both conditions, we know the things don\\'t match, so we can return `False` immediately. If we meet both conditions for the duration of `typed`, then we only have to make sure we\\'ve also gotten entirely through the `name` so we catch cases like `[\\'pyplrz\\', \\'ppyypllr\\']`.\\n\\n        i = 0\\n        for j in range(len(typed)):\\n            if i < len(name) and name[i] == typed[j]:\\n                i += 1\\n            elif not i > 0 and name[i-1] == typed[j]:\\n                return False\\n        return i == len(name)",
                "codeTag": "Unknown"
            },
            {
                "id": 2967326,
                "title": "java-two-pointer-explaination-100-faster",
                "content": "# Intuition\\nMaintain two pointer i and j to traverse both the string. We have to check 4 edge cases in this question.\\n# Approach\\ni=0 pointing to \"name\" string and j=0 pointing to \"typed\" string.\\n1. If char at index 0 in both name and typed is not equal:\\n   return false; Example: name: \"rick\" | typed: \"kric\"\\n\\n2. if length of name is greater than typed:\\n   return false;\\n\\n3. main logic goes in step 3:\\n   Run a loop while i<n && j<m:\\n    if char at i and char at j is equal increment both i++ and j++\\n\\nelse{\\ncheck if char at j is equal to the char at i-1: if \"yes\": j++;\\nBy doing this we are checking that whether the char at j index is long pressed of previous char of \"name\" string.\\n}\\nelse{\\nreturn false;\\n}\\n\\n4. suppose you completely traversed string name and there are still characters remaing in string \"typed\" to traverse.\\n5. check if char at last index of \"name\" is getting repeated in string \"typed\".\\nExample: name: \"alex\" | types: \"aaleexa\"\\n\\n6. if j is completely traversed but i is still have some char to check: return false\\nif(i<n){\\nreturn false;\\n}\\nExample: name: \"pyplrz\" | typed: \"ppyypllr\"\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int n = name.length();\\n        int m = typed.length();\\n        int i=0;\\n        int j=0;\\n        if(name.charAt(0) != typed.charAt(0)) //step 1\\n            return false;\\n        if(n>m){            // step 2\\n            return false;\\n        }\\n        while(i<n && j<m){    //step 3\\n            if(name.charAt(i) == typed.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            else if(name.charAt(i-1) == typed.charAt(j)){\\n                j++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        while(j<m){       //Step 4 & 5\\n            if(name.charAt(i-1) == typed.charAt(j)){\\n                j++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(i<n){      // step 6\\n            return false;\\n        }\\n        return true;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int n = name.length();\\n        int m = typed.length();\\n        int i=0;\\n        int j=0;\\n        if(name.charAt(0) != typed.charAt(0)) //step 1\\n            return false;\\n        if(n>m){            // step 2\\n            return false;\\n        }\\n        while(i<n && j<m){    //step 3\\n            if(name.charAt(i) == typed.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            else if(name.charAt(i-1) == typed.charAt(j)){\\n                j++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        while(j<m){       //Step 4 & 5\\n            if(name.charAt(i-1) == typed.charAt(j)){\\n                j++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(i<n){      // step 6\\n            return false;\\n        }\\n        return true;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521026,
                "title": "c-looping-over-typed-and-use-pointer-into-name-easy-to-understand",
                "content": "This is basically two pointers, but since we loop over all of ```typed``` we can just use a range-based loop.\\n\\n```\\n    bool isLongPressedName(const string& name, const string& typed) {\\n        int i = 0;\\n        for (char t : typed) {\\n            if (i < size(name) && name[i] == t) {\\n                // We have not reached the end of |name| and the\\n                // chararters match.\\n                ++i;\\n            } else if (!(i > 0 && name[i - 1] == t)) {\\n                // |typed| has a character that\\'s not equal to the\\n                // current and previous character in |name|.\\n                return false;\\n            }\\n        }\\n        // Have we matched all characters?\\n        return i == size(name);\\n    }\\n```\\n\\n**Complexity Analysis**\\n\\n* Time Complexity: ```O(size(typed))```, we loop over all of |typed| and look at most as many characters in |name|.\\n* Space Complexity: ```O(1)```, only loop variables\\n\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```typed```\n```\\n    bool isLongPressedName(const string& name, const string& typed) {\\n        int i = 0;\\n        for (char t : typed) {\\n            if (i < size(name) && name[i] == t) {\\n                // We have not reached the end of |name| and the\\n                // chararters match.\\n                ++i;\\n            } else if (!(i > 0 && name[i - 1] == t)) {\\n                // |typed| has a character that\\'s not equal to the\\n                // current and previous character in |name|.\\n                return false;\\n            }\\n        }\\n        // Have we matched all characters?\\n        return i == size(name);\\n    }\\n```\n```O(size(typed))```\n```O(1)```",
                "codeTag": "Unknown"
            },
            {
                "id": 512597,
                "title": "javascript-two-pointers",
                "content": "```javascript\\n/**\\n * @param {string} name\\n * @param {string} typed\\n * @return {boolean}\\n */\\nvar isLongPressedName = function(name, typed) {\\n  let j = 0;\\n  for (let i = 0; i < typed.length; i++) {\\n    if (typed[i] === name[j]) {\\n      j++;\\n    } else if (typed[i] === name[j - 1]) {\\n      continue;\\n    } else {\\n      return false;\\n    }\\n  }\\n  return j === name.length;\\n};\\n```\\n\\n* 71/71 cases passed (48 ms)\\n* Your runtime beats 98.18 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (35.6 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string} name\\n * @param {string} typed\\n * @return {boolean}\\n */\\nvar isLongPressedName = function(name, typed) {\\n  let j = 0;\\n  for (let i = 0; i < typed.length; i++) {\\n    if (typed[i] === name[j]) {\\n      j++;\\n    } else if (typed[i] === name[j - 1]) {\\n      continue;\\n    } else {\\n      return false;\\n    }\\n  }\\n  return j === name.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 183969,
                "title": "c-quick-and-easy-just-learned-after-the-contest",
                "content": "Oct. 20, 2018\\nIt is an easy level algorithm. I have to learn how to write an elegant solution after the contest, now it is 9:40 PM Oct. 20, 2018. Now there are only 30 discuss, I can easily figure out which one is most easy to follow. \\n\\nI wrote one and added some comment in the code to make it more readable. \\n\\n```\\npublic class Solution {\\n    /// <summary>\\n        /// learn to write very elegant code based on the discuss:\\n        /// https://leetcode.com/problems/long-pressed-name/discuss/183929/C%2B%2B-2-lines-accepted-and-5-lines-accurate\\n        /// </summary>\\n        /// <param name=\"name\"></param>\\n        /// <param name=\"typed\"></param>\\n        /// <param name=\"index\"></param>\\n        /// <param name=\"indexTyped\"></param>\\n        /// <returns></returns>\\n        public  bool IsLongPressedName(string name, string typed, int index = 0, int indexTyped = 0) {\\n            while (indexTyped < typed.Length) {\\n                //  match current\\n                if (index < name.Length && name[index] == typed[indexTyped])\\n                {\\n                    index++;\\n                    indexTyped++;\\n                }\\n                // match previous one\\n                else if (index > 0 && name[index - 1] == typed[indexTyped])\\n                {\\n                    ++indexTyped;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            // make sure that original string is iterated completely. \\n            return index == name.Length;\\n        }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /// <summary>\\n        /// learn to write very elegant code based on the discuss:\\n        /// https://leetcode.com/problems/long-pressed-name/discuss/183929/C%2B%2B-2-lines-accepted-and-5-lines-accurate\\n        /// </summary>\\n        /// <param name=\"name\"></param>\\n        /// <param name=\"typed\"></param>\\n        /// <param name=\"index\"></param>\\n        /// <param name=\"indexTyped\"></param>\\n        /// <returns></returns>\\n        public  bool IsLongPressedName(string name, string typed, int index = 0, int indexTyped = 0) {\\n            while (indexTyped < typed.Length) {\\n                //  match current\\n                if (index < name.Length && name[index] == typed[indexTyped])\\n                {\\n                    index++;\\n                    indexTyped++;\\n                }\\n                // match previous one\\n                else if (index > 0 && name[index - 1] == typed[indexTyped])\\n                {\\n                    ++indexTyped;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            // make sure that original string is iterated completely. \\n            return index == name.Length;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 183920,
                "title": "python-one-liner",
                "content": "itertools.groupby() and itertools.zip_longest() are used\\n```\\nfrom itertools import zip_longest, groupby\\nclass Solution:\\n    def isLongPressedName(self, name, typed):\\n        \"\"\"\\n        :type name: str\\n        :type typed: str\\n        :rtype: bool\\n        \"\"\"\\n        return all(ch1 == ch2 and len(list(g1)) <= len(list(g2)) for ((ch1, g1), (ch2, g2)) in zip_longest(groupby(name), groupby(typed), fillvalue=(None, None)))\\n```\\nCheck the below example for groupby() and zip_longest()\\n![image](https://assets.leetcode.com/users/yaqizhang/image_1540097319.png)\\n",
                "solutionTags": [],
                "code": "```\\nfrom itertools import zip_longest, groupby\\nclass Solution:\\n    def isLongPressedName(self, name, typed):\\n        \"\"\"\\n        :type name: str\\n        :type typed: str\\n        :rtype: bool\\n        \"\"\"\\n        return all(ch1 == ch2 and len(list(g1)) <= len(list(g2)) for ((ch1, g1), (ch2, g2)) in zip_longest(groupby(name), groupby(typed), fillvalue=(None, None)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671243,
                "title": "beginner-friendly-approach-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {    \\n        int i =0;\\n        if(name[0]!=typed[0]){\\n            return false;\\n        }\\n        \\n       for(int j =0; j<typed.length();j++){\\n           if(name[i]==typed[j]){\\n               i++;\\n           }\\n           if(name[i] != typed[j]  && name[i-1] != typed[j]){\\n               return false;\\n           }\\n       }\\n     \\n\\n    if(i==name.length()){\\n        return true;\\n    }\\n    return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {    \\n        int i =0;\\n        if(name[0]!=typed[0]){\\n            return false;\\n        }\\n        \\n       for(int j =0; j<typed.length();j++){\\n           if(name[i]==typed[j]){\\n               i++;\\n           }\\n           if(name[i] != typed[j]  && name[i-1] != typed[j]){\\n               return false;\\n           }\\n       }\\n     \\n\\n    if(i==name.length()){\\n        return true;\\n    }\\n    return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956961,
                "title": "java-0ms-100-faster-linear-solution",
                "content": "# Please Upvote If You Find This Helpful\\n![image](https://assets.leetcode.com/users/images/f02f68dd-dd45-4303-8fc7-27c163511e71_1650192077.1112297.png)\\n```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if (name.charAt(0) != typed.charAt(0)) return false;\\n        int i = 1;\\n        int j = 1;\\n        while (i < typed.length()) {\\n            if (j < name.length() && typed.charAt(i) == name.charAt(j)) {\\n                i++;\\n                j++;\\n            }\\n            else if (typed.charAt(i) == name.charAt(j - 1)) i++;\\n            else return false;\\n        }\\n        return j == name.length();\\n    }\\n}\\n```\\n# Please Upvote If You Find This Helpful",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if (name.charAt(0) != typed.charAt(0)) return false;\\n        int i = 1;\\n        int j = 1;\\n        while (i < typed.length()) {\\n            if (j < name.length() && typed.charAt(i) == name.charAt(j)) {\\n                i++;\\n                j++;\\n            }\\n            else if (typed.charAt(i) == name.charAt(j - 1)) i++;\\n            else return false;\\n        }\\n        return j == name.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886760,
                "title": "java-simple-solution-o-n",
                "content": "Two pointers. One pointer *i* counts how many times char appears in name, the other pointer *j* finds the same char in typed and offsets the count. At the end check if ponter *j* has reached the end of typed.\\n```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if (name == null || name.length() == 0) return false;\\n        if (typed.length() < name.length()) return false;\\n        if (typed.length() == name.length()) return name.equals(typed);\\n        int i = 0;\\n        int j = 0;\\n        while (i < name.length()) {\\n            char nameChar = name.charAt(i);\\n            int count = 1;\\n            i++;\\n            while (i < name.length() && name.charAt(i) == nameChar) {\\n                i++;\\n                count++;\\n            }\\n            while (j < typed.length() && typed.charAt(j) == nameChar) {\\n                j++;\\n                count--;\\n            }\\n            if (count > 0) {\\n                return false;\\n            }         \\n        }\\n        if (j != typed.length()) {\\n            return false;\\n        }\\n        return true;\\n    }\\n} \\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if (name == null || name.length() == 0) return false;\\n        if (typed.length() < name.length()) return false;\\n        if (typed.length() == name.length()) return name.equals(typed);\\n        int i = 0;\\n        int j = 0;\\n        while (i < name.length()) {\\n            char nameChar = name.charAt(i);\\n            int count = 1;\\n            i++;\\n            while (i < name.length() && name.charAt(i) == nameChar) {\\n                i++;\\n                count++;\\n            }\\n            while (j < typed.length() && typed.charAt(j) == nameChar) {\\n                j++;\\n                count--;\\n            }\\n            if (count > 0) {\\n                return false;\\n            }         \\n        }\\n        if (j != typed.length()) {\\n            return false;\\n        }\\n        return true;\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679795,
                "title": "java-0-ms-explained",
                "content": "**Idea:**\\n* Base cases: \\n\\t* If the strings are the same, then they qualify, so return true\\n\\t* If `name` is longer than `typed`, then typed can\\'t be long pressed, so return false\\n* Use 2 pointers, 1 for each string\\n* Keep both moving till chars are same\\n* When chars are different, ensure typed\\'s previous char is the same as current char (long pressed). If not return false\\n* At the end check if the pointer for the `name` string has reached the end of `name`. If yes, then all the chars (even if long) have matched. Else they haven\\'t matched because `typed` is missing some letters towards the end\\n>**T/S:** O(n)/O(1)\\n```\\npublic boolean isLongPressedName(String name, String typed) {\\n\\tif (name.equals(typed))\\n\\t\\treturn true;\\n\\tif (name.length() > typed.length())\\n\\t\\treturn false;\\n\\t\\t\\n\\tvar i = 0;\\n\\tfor (var j = 0; j < typed.length(); j++)\\n\\t\\tif (i < name.length() && name.charAt(i) == typed.charAt(j))\\n\\t\\t\\ti++;\\n\\t\\telse if (j == 0 || typed.charAt(j - 1) != typed.charAt(j))\\n\\t\\t\\treturn false;\\n\\n\\treturn i == name.length();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic boolean isLongPressedName(String name, String typed) {\\n\\tif (name.equals(typed))\\n\\t\\treturn true;\\n\\tif (name.length() > typed.length())\\n\\t\\treturn false;\\n\\t\\t\\n\\tvar i = 0;\\n\\tfor (var j = 0; j < typed.length(); j++)\\n\\t\\tif (i < name.length() && name.charAt(i) == typed.charAt(j))\\n\\t\\t\\ti++;\\n\\t\\telse if (j == 0 || typed.charAt(j - 1) != typed.charAt(j))\\n\\t\\t\\treturn false;\\n\\n\\treturn i == name.length();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081300,
                "title": "java-solution-with-two-pointers",
                "content": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int m = name.length(), n = typed.length();\\n        int i = 0, j = 0;\\n        \\n        while (i < m && j < n){\\n            char c1 = name.charAt(i);\\n            char c2 = typed.charAt(j);\\n            //exit if the character do not match\\n\\t\\t\\tif (c1 != c2) return false;\\n            \\n            int l1 = 0, l2 = 0;\\n            // count duplicate character length for both strings\\n\\t\\t\\twhile (i < m && name.charAt(i) == c1){ \\n                i++;\\n                l1++;  \\n            } \\n            while (j < n && typed.charAt(j) == c1){\\n                j++;\\n                l2++;  \\n            } \\n            \\n\\t\\t\\t//l2 should be always greater than l1\\n            if (l2 < l1) return false;\\n        }\\n        return i == m && j == n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int m = name.length(), n = typed.length();\\n        int i = 0, j = 0;\\n        \\n        while (i < m && j < n){\\n            char c1 = name.charAt(i);\\n            char c2 = typed.charAt(j);\\n            //exit if the character do not match\\n\\t\\t\\tif (c1 != c2) return false;\\n            \\n            int l1 = 0, l2 = 0;\\n            // count duplicate character length for both strings\\n\\t\\t\\twhile (i < m && name.charAt(i) == c1){ \\n                i++;\\n                l1++;  \\n            } \\n            while (j < n && typed.charAt(j) == c1){\\n                j++;\\n                l2++;  \\n            } \\n            \\n\\t\\t\\t//l2 should be always greater than l1\\n            if (l2 < l1) return false;\\n        }\\n        return i == m && j == n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803246,
                "title": "faster-than-100-of-online-submission",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isLongPressedName(string name, string typed) {\\n\\t\\t\\tint i = 0, m = name.length(), n = typed.length();\\n\\t\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t\\t\\tif (i < m && name[i] == typed[j])\\n\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\telse if (!j || typed[j] != typed[j - 1])\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\treturn i == m;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isLongPressedName(string name, string typed) {\\n\\t\\t\\tint i = 0, m = name.length(), n = typed.length();\\n\\t\\t\\tfor (int j = 0; j < n; ++j)\\n\\t\\t\\t\\tif (i < m && name[i] == typed[j])\\n\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\telse if (!j || typed[j] != typed[j - 1])\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\treturn i == m;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 183903,
                "title": "java-2-pointer-solution",
                "content": "```\\nclass Solution {\\n    public static boolean isLongPressedName(String name, String typed) {\\n        int slow = 0;\\n        int fast = 0;\\n\\n        while (slow < name.length() && fast < typed.length()) {\\n            if (name.charAt(slow) == typed.charAt(fast)) {\\n                slow++;\\n                fast++;\\n            }\\n            else if (fast > 0 && typed.charAt(fast) == typed.charAt(fast-1)) {\\n                fast++;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n\\n        while (fast < typed.length()) {\\n            if (typed.charAt(fast) != typed.charAt(fast-1)) {\\n                return false;\\n            }\\n\\n            fast++;\\n        }\\n\\n        return slow == name.length();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static boolean isLongPressedName(String name, String typed) {\\n        int slow = 0;\\n        int fast = 0;\\n\\n        while (slow < name.length() && fast < typed.length()) {\\n            if (name.charAt(slow) == typed.charAt(fast)) {\\n                slow++;\\n                fast++;\\n            }\\n            else if (fast > 0 && typed.charAt(fast) == typed.charAt(fast-1)) {\\n                fast++;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n\\n        while (fast < typed.length()) {\\n            if (typed.charAt(fast) != typed.charAt(fast-1)) {\\n                return false;\\n            }\\n\\n            fast++;\\n        }\\n\\n        return slow == name.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254985,
                "title": "easy-c-two-pointer-solution-t-o-n-s-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is little tricky. We have keep in mind the different possibilities of \"typed\" string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSet both the pointers to the starting \\'char\\' and run a while loop about the length of \"typed\" string.  \\n\\n- Make a base case ,i.e., if the starting \\'char\\' doesn\\'t match then return false to avoid the runtime error.\\n\\n- If both the \\'char\\' of string mathces, increment both the pointers and if it doesn\\'t matches then it should match the previous \\'char\\', otherwise return false.\\n\\n- the true condition will only be when the first pointer reaches to size of \"name\" string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(typed.length())\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int i = 0 , j = 0 ;\\n        if(name[0] != typed[0]){\\n            return false;\\n        }\\n        while( j < typed.length() ){\\n            if(name[i] == typed[j]){\\n                i++;\\n                j++;\\n            }else if (name[i-1] == typed[j] ){\\n                j++;\\n            }else{\\n                return false;\\n            }\\n        } \\n        if( i == name.length()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int i = 0 , j = 0 ;\\n        if(name[0] != typed[0]){\\n            return false;\\n        }\\n        while( j < typed.length() ){\\n            if(name[i] == typed[j]){\\n                i++;\\n                j++;\\n            }else if (name[i-1] == typed[j] ){\\n                j++;\\n            }else{\\n                return false;\\n            }\\n        } \\n        if( i == name.length()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606084,
                "title": "python-elegant-short-one-line-itertools-groupby",
                "content": "```\\t\\nfrom itertools import groupby, zip_longest\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(max(n, m))\\n\\tMemory: O(1)\\n\\t\"\"\"\\n\\n\\tdef isLongPressedName(self, name: str, typed: str) -> bool:\\n\\t\\tfor (a, a_gr), (b, b_gr) in zip_longest(groupby(name), groupby(typed), fillvalue=(None, None)):\\n\\t\\t\\tif a != b or sum(1 for _ in a_gr) > sum(1 for _ in b_gr):\\n\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(max(n, m))\\n\\tMemory: O(1)\\n\\t\"\"\"\\n\\n\\tdef isLongPressedName(self, name: str, typed: str) -> bool:\\n\\t\\treturn all(\\n\\t\\t\\ta == b and sum(1 for _ in a_gr) <= sum(1 for _ in b_gr)\\n\\t\\t\\tfor (a, a_gr), (b, b_gr) in zip_longest(groupby(name), groupby(typed), fillvalue=(None, None))\\n\\t\\t)\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\t\\nfrom itertools import groupby, zip_longest\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(max(n, m))\\n\\tMemory: O(1)\\n\\t\"\"\"\\n\\n\\tdef isLongPressedName(self, name: str, typed: str) -> bool:\\n\\t\\tfor (a, a_gr), (b, b_gr) in zip_longest(groupby(name), groupby(typed), fillvalue=(None, None)):\\n\\t\\t\\tif a != b or sum(1 for _ in a_gr) > sum(1 for _ in b_gr):\\n\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(max(n, m))\\n\\tMemory: O(1)\\n\\t\"\"\"\\n\\n\\tdef isLongPressedName(self, name: str, typed: str) -> bool:\\n\\t\\treturn all(\\n\\t\\t\\ta == b and sum(1 for _ in a_gr) <= sum(1 for _ in b_gr)\\n\\t\\t\\tfor (a, a_gr), (b, b_gr) in zip_longest(groupby(name), groupby(typed), fillvalue=(None, None))\\n\\t\\t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508705,
                "title": "java-2-pointer-faster-than-100",
                "content": "You can find my solutions to other leetcode problems on my Github: https://linktr.ee/rohitdhatrak\\n\\n```\\npublic boolean isLongPressedName(String name, String typed) {\\n\\tif (typed.length() < name.length()) return false;\\n\\tint namePtr = 0;\\n\\tint typedPtr = 0;\\n\\n\\twhile (typedPtr < typed.length() || namePtr < name.length()) {\\n\\t\\tif(typedPtr >= typed.length()) return false;\\n\\t\\tif (namePtr < name.length() && name.charAt(namePtr) == typed.charAt(typedPtr)) {\\n\\t\\t\\tnamePtr++;\\n\\t\\t\\ttypedPtr++;\\n\\t\\t} else if (namePtr != 0 && name.charAt(namePtr - 1) == typed.charAt(typedPtr)) {\\n\\t\\t\\ttypedPtr++;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic boolean isLongPressedName(String name, String typed) {\\n\\tif (typed.length() < name.length()) return false;\\n\\tint namePtr = 0;\\n\\tint typedPtr = 0;\\n\\n\\twhile (typedPtr < typed.length() || namePtr < name.length()) {\\n\\t\\tif(typedPtr >= typed.length()) return false;\\n\\t\\tif (namePtr < name.length() && name.charAt(namePtr) == typed.charAt(typedPtr)) {\\n\\t\\t\\tnamePtr++;\\n\\t\\t\\ttypedPtr++;\\n\\t\\t} else if (namePtr != 0 && name.charAt(namePtr - 1) == typed.charAt(typedPtr)) {\\n\\t\\t\\ttypedPtr++;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1380410,
                "title": "28-ms-faster-than-87-66-of-python3-online-submissions",
                "content": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        n=len(name)\\n        m=len(typed)\\n        \\n        if m<n:\\n            return False\\n        i=j=0\\n        while(True):\\n            print(i,j)\\n            if i==n and j==m:\\n                return True\\n            \\n            if i<n and j<m and name[i]==typed[j]:\\n                i+=1\\n                j+=1\\n            elif j>0 and j<m and typed[j-1]==typed[j]:\\n\\n                j+=1\\n            else:\\n                return False\\n        ```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        n=len(name)\\n        m=len(typed)\\n        \\n        if m<n:\\n            return False\\n        i=j=0\\n        while(True):\\n            print(i,j)\\n            if i==n and j==m:\\n                return True\\n            \\n            if i<n and j<m and name[i]==typed[j]:\\n                i+=1\\n                j+=1\\n            elif j>0 and j<m and typed[j-1]==typed[j]:\\n\\n                j+=1\\n            else:\\n                return False\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 930314,
                "title": "python-3-explained-memorization-24-ms",
                "content": "A couple of facts or corner cases. First if both strings are equal, then it was your friends name. Second, if both ending strings are different, then it was NOT your friends name.\\nThe main idea is to iterate the string name, and at the same time to iterate the string typed to compare.\\nExample: \"alex\", \"aaleelx\"\\nIterate \"alex\", char = \"a\", prev = \"a\", indice = 0, typed becomes \"aleelx\", the first \"a\" is deleted from typed.\\nMove on to char = \"l\", indice = 1, so in the (updated) typed before \"l\" there is one char. We want to see this char is a long pressed char meaning it should equal to the prev (\"a\"). Otherwise, the typed is not your friends name. So we iterate the typed (0 to 1) to make sure. Then typed becomes \"eelx\", the \"al\" are deleted from typed. Update prev = \"l\".\\nMove on to char = \"e\", indice = zero, so we are good. Update typed to \"elx\", and prev = \"e\".\\nMove on to char = \"x\", indice = 2, so in typed before \"x\" there are two chars, We want to see these chars are equal to prev \"e\". When we iterate the typed (0 to 2), we find a char \"l\" which is not equal to \"e\". So it was not your friends name.\\n\\n~~~\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        # cover the case: that the name and typed are equal, e.g., \"laiden\", \"laiden\"\\n\\t\\tif name == typed:\\n            return True\\n\\t\\t\\n\\t\\t# Note that it is necessary to have both strings ending the same. E.g., \"alex\", \"alexxr\"\\n        if typed[-1] != name[-1]:\\n            return False\\n        \\n\\t\\t# Index of the name char in string typed, the very first time iteratation it\\'s always zero\\n\\t\\tindice = -1\\n\\t\\t\\n\\t\\t# Memorize the previous char in string name, starting from the first char in string name\\n        prev = name[0]\\n\\t\\t\\n\\t\\t# Iterate the string name. Make the decision on the fly.\\n        for char in name:\\n            if (char in typed):\\n                indice = typed.index(char)\\n                if indice > 0:\\n                    for i in range(0, indice):\\n                        if typed[i] != prev:\\n                            return False\\n                typed = typed[(indice+1):]\\n                prev = char\\n            else:\\n                return False\\n        return True\\n~~~",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "A couple of facts or corner cases. First if both strings are equal, then it was your friends name. Second, if both ending strings are different, then it was NOT your friends name.\\nThe main idea is to iterate the string name, and at the same time to iterate the string typed to compare.\\nExample: \"alex\", \"aaleelx\"\\nIterate \"alex\", char = \"a\", prev = \"a\", indice = 0, typed becomes \"aleelx\", the first \"a\" is deleted from typed.\\nMove on to char = \"l\", indice = 1, so in the (updated) typed before \"l\" there is one char. We want to see this char is a long pressed char meaning it should equal to the prev (\"a\"). Otherwise, the typed is not your friends name. So we iterate the typed (0 to 1) to make sure. Then typed becomes \"eelx\", the \"al\" are deleted from typed. Update prev = \"l\".\\nMove on to char = \"e\", indice = zero, so we are good. Update typed to \"elx\", and prev = \"e\".\\nMove on to char = \"x\", indice = 2, so in typed before \"x\" there are two chars, We want to see these chars are equal to prev \"e\". When we iterate the typed (0 to 2), we find a char \"l\" which is not equal to \"e\". So it was not your friends name.\\n\\n~~~\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        # cover the case: that the name and typed are equal, e.g., \"laiden\", \"laiden\"\\n\\t\\tif name == typed:\\n            return True\\n\\t\\t\\n\\t\\t# Note that it is necessary to have both strings ending the same. E.g., \"alex\", \"alexxr\"\\n        if typed[-1] != name[-1]:\\n            return False\\n        \\n\\t\\t# Index of the name char in string typed, the very first time iteratation it\\'s always zero\\n\\t\\tindice = -1\\n\\t\\t\\n\\t\\t# Memorize the previous char in string name, starting from the first char in string name\\n        prev = name[0]\\n\\t\\t\\n\\t\\t# Iterate the string name. Make the decision on the fly.\\n        for char in name:\\n            if (char in typed):\\n                indice = typed.index(char)\\n                if indice > 0:\\n                    for i in range(0, indice):\\n                        if typed[i] != prev:\\n                            return False\\n                typed = typed[(indice+1):]\\n                prev = char\\n            else:\\n                return False\\n        return True\\n~~~",
                "codeTag": "Java"
            },
            {
                "id": 216697,
                "title": "python-two-pointer-slightly-different-from-existing-solutions",
                "content": "```python\\nclass Solution:\\n    def isLongPressedName(self, name, typed):\\n        \"\"\"\\n        :type name: str\\n        :type typed: str\\n        :rtype: bool\\n        \"\"\"\\n        i, j = 0, 0\\n        while i < len(name) and j < len(typed):\\n            if name[i] == typed[j]:\\n                i += 1\\n                j += 1\\n            else:\\n                j += 1\\n        if i == len(name):\\n            return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isLongPressedName(self, name, typed):\\n        \"\"\"\\n        :type name: str\\n        :type typed: str\\n        :rtype: bool\\n        \"\"\"\\n        i, j = 0, 0\\n        while i < len(name) and j < len(typed):\\n            if name[i] == typed[j]:\\n                i += 1\\n                j += 1\\n            else:\\n                j += 1\\n        if i == len(name):\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200415,
                "title": "clean-java-code",
                "content": "```\\n   public boolean isLongPressedName(String name, String typed) {\\n        int i = 0, j = 0; \\n        for(;i < name.length() && j < typed.length(); j++) \\n            if(typed.charAt(j) == name.charAt(i)) \\n                i++;\\n        return i == name.length();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public boolean isLongPressedName(String name, String typed) {\\n        int i = 0, j = 0; \\n        for(;i < name.length() && j < typed.length(); j++) \\n            if(typed.charAt(j) == name.charAt(i)) \\n                i++;\\n        return i == name.length();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 183854,
                "title": "a-few-solutions",
                "content": "**Synopsis:**\\n\\nThere are 3 use cases to consider for each i<sup>th</sup> char of `A` and each j<sup>th</sup> char of `B`:\\n1. if `A[i] == B[j]`, then advance both `i` and `j` forward and track the last `A[i]` value\\n2. if `A[i] != B[j]`, but `B[j]` is equal to the last i<sup>th</sup> value, then advance `j` forward\\n3. if `A[i] != B[j]`, and `B[j]` is *not* equal to the last i<sup>th</sup> value, then return false immediately\\n\\n**Note:** the C++ solution assumes it is OK to deference end() as the NULL char.\\n\\n---\\n\\n*Javascript*\\n```\\nlet isLongPressedName = (A, B) => {\\n    let M = A.length,\\n        N = B.length,\\n        i = 0,\\n        j = 0,\\n\\t\\tlast = \\'\\\\0\\';\\n    while (!(i == M && j == N)) {\\n        if (i < M && j < N && A[i] == B[j])\\n            last = A[i], ++i, ++j;\\n        else if (j < N && last == B[j])\\n            ++j;\\n        else\\n            return false\\n    }\\n    return true;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def isLongPressedName(self, A: str, B: str) -> bool:\\n        M = len(A)\\n        N = len(B)\\n        i = 0\\n        j = 0\\n        last = \\'\\\\0\\'\\n        while not (i == M and j == N):\\n            if i < M and j < N and A[i] == B[j]:\\n                last = A[i]\\n                i += 1\\n                j += 1\\n            elif j < N and last == B[j]:\\n                j += 1\\n            else:\\n                return False\\n        return True\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string A, string B) {\\n        auto i = A.begin(),\\n             j = B.begin(),\\n             last{ i };\\n        while (!(i == A.end() && j == B.end())) {\\n            if (*i == *j)\\n                i = next(last = i),\\n                j = next(j);\\n            else if (*last == *j)\\n                j = next(j);\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet isLongPressedName = (A, B) => {\\n    let M = A.length,\\n        N = B.length,\\n        i = 0,\\n        j = 0,\\n\\t\\tlast = \\'\\\\0\\';\\n    while (!(i == M && j == N)) {\\n        if (i < M && j < N && A[i] == B[j])\\n            last = A[i], ++i, ++j;\\n        else if (j < N && last == B[j])\\n            ++j;\\n        else\\n            return false\\n    }\\n    return true;\\n};\\n```\n```\\nclass Solution:\\n    def isLongPressedName(self, A: str, B: str) -> bool:\\n        M = len(A)\\n        N = len(B)\\n        i = 0\\n        j = 0\\n        last = \\'\\\\0\\'\\n        while not (i == M and j == N):\\n            if i < M and j < N and A[i] == B[j]:\\n                last = A[i]\\n                i += 1\\n                j += 1\\n            elif j < N and last == B[j]:\\n                j += 1\\n            else:\\n                return False\\n        return True\\n```\n```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string A, string B) {\\n        auto i = A.begin(),\\n             j = B.begin(),\\n             last{ i };\\n        while (!(i == A.end() && j == B.end())) {\\n            if (*i == *j)\\n                i = next(last = i),\\n                j = next(j);\\n            else if (*last == *j)\\n                j = next(j);\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519608,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n      int i=0,j=0;\\n      while(i< name.length() && j< typed.length()){\\n          if(name[i]==typed[j]){\\n              i++;\\n              j++;\\n          }\\n          else{\\n              if(i>0 &&name[i-1]==typed[j])\\n                j++;\\n                else{\\n                    return false;\\n                }\\n          }\\n      }\\n      while(j< typed.length()){\\n          if(name[i-1]!=typed[j])\\n          return false;\\n          j++;\\n      }\\n      while(i< name.length()){\\n          if(name[i]!=typed[j])\\n          return false;\\n          i++;\\n      }\\n      return true;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        \\n        name = list(name)\\n        typed = list(typed)\\n        if name[0] != typed[0]:\\n            return False\\n        i = 1\\n        j = 1\\n        while i < len(name) and j < len(typed):\\n            if name[i] == typed[j]:\\n                i += 1\\n                j += 1\\n            elif name[i-1] == typed[j]:\\n                j += 1\\n            else:\\n                return False\\n        while j < len(typed):\\n            if name[i-1] == typed[j]:\\n                j += 1\\n            else:\\n                return False\\n        return i == len(name)\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int n = name.length();\\n        int m = typed.length();\\n        int i=0;\\n        int j=0;\\n        if(name.charAt(0) != typed.charAt(0))\\n            return false;\\n        if(n>m){\\n            return false;\\n        }\\n        while(i<n && j<m){\\n            if(name.charAt(i) == typed.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            else if(name.charAt(i-1) == typed.charAt(j)){\\n                j++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        while(j<m){\\n            if(name.charAt(i-1) == typed.charAt(j)){\\n                j++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(i<n){\\n            return false;\\n        }\\n        return true;       \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n      int i=0,j=0;\\n      while(i< name.length() && j< typed.length()){\\n          if(name[i]==typed[j]){\\n              i++;\\n              j++;\\n          }\\n          else{\\n              if(i>0 &&name[i-1]==typed[j])\\n                j++;\\n                else{\\n                    return false;\\n                }\\n          }\\n      }\\n      while(j< typed.length()){\\n          if(name[i-1]!=typed[j])\\n          return false;\\n          j++;\\n      }\\n      while(i< name.length()){\\n          if(name[i]!=typed[j])\\n          return false;\\n          i++;\\n      }\\n      return true;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        \\n        name = list(name)\\n        typed = list(typed)\\n        if name[0] != typed[0]:\\n            return False\\n        i = 1\\n        j = 1\\n        while i < len(name) and j < len(typed):\\n            if name[i] == typed[j]:\\n                i += 1\\n                j += 1\\n            elif name[i-1] == typed[j]:\\n                j += 1\\n            else:\\n                return False\\n        while j < len(typed):\\n            if name[i-1] == typed[j]:\\n                j += 1\\n            else:\\n                return False\\n        return i == len(name)\\n```\n```Java []\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int n = name.length();\\n        int m = typed.length();\\n        int i=0;\\n        int j=0;\\n        if(name.charAt(0) != typed.charAt(0))\\n            return false;\\n        if(n>m){\\n            return false;\\n        }\\n        while(i<n && j<m){\\n            if(name.charAt(i) == typed.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            else if(name.charAt(i-1) == typed.charAt(j)){\\n                j++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        while(j<m){\\n            if(name.charAt(i-1) == typed.charAt(j)){\\n                j++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(i<n){\\n            return false;\\n        }\\n        return true;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335371,
                "title": "trying-to-store-the-name-and-typed-with-thier-frequecy-and-then-compare-the-frequecy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n Easy Solution  using stack\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexityo(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n\\n        stack<pair<char,int>> q;\\n\\n        for(int i=0;i<typed.size();i++){\\n            if(q.size()==0)\\n            q.push({typed[i],1});\\n\\n\\n           else if(q.top().first==typed[i]){\\n               int k=q.top().second;\\n               q.pop();\\n               k++;\\n               q.push({typed[i],k});\\n\\n           }\\n\\n           else{\\n               q.push({typed[i],1});\\n           }\\n\\n        }\\n    stack<pair<char,int>> q1;\\n\\n        for(int i=0;i<name.size();i++){\\n            if(q1.size()==0)\\n            q1.push({name[i],1});\\n\\n\\n           else if(q1.top().first==name[i]){\\n               int k=q1.top().second;\\n               q1.pop();\\n               k++;\\n               q1.push({name[i],k});\\n\\n           }\\n\\n           else{\\n               q1.push({name[i],1});\\n           }\\n\\n        }\\n   \\n  if(q.size()!=q1.size()) return false;\\n  while(q.size()>0 && q1.size()>0){\\n            if(q.top().first==q1.top().first){\\n                       \\n                        if(q.top().second<q1.top().second){\\n                            return false;\\n                        }\\n            }\\n            else if(q.top().first!=q1.top().second){\\n                return false;\\n            }\\n        q.pop();\\n        q1.pop();\\n\\n  }\\n\\n\\n\\n   return true;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n\\n        stack<pair<char,int>> q;\\n\\n        for(int i=0;i<typed.size();i++){\\n            if(q.size()==0)\\n            q.push({typed[i],1});\\n\\n\\n           else if(q.top().first==typed[i]){\\n               int k=q.top().second;\\n               q.pop();\\n               k++;\\n               q.push({typed[i],k});\\n\\n           }\\n\\n           else{\\n               q.push({typed[i],1});\\n           }\\n\\n        }\\n    stack<pair<char,int>> q1;\\n\\n        for(int i=0;i<name.size();i++){\\n            if(q1.size()==0)\\n            q1.push({name[i],1});\\n\\n\\n           else if(q1.top().first==name[i]){\\n               int k=q1.top().second;\\n               q1.pop();\\n               k++;\\n               q1.push({name[i],k});\\n\\n           }\\n\\n           else{\\n               q1.push({name[i],1});\\n           }\\n\\n        }\\n   \\n  if(q.size()!=q1.size()) return false;\\n  while(q.size()>0 && q1.size()>0){\\n            if(q.top().first==q1.top().first){\\n                       \\n                        if(q.top().second<q1.top().second){\\n                            return false;\\n                        }\\n            }\\n            else if(q.top().first!=q1.top().second){\\n                return false;\\n            }\\n        q.pop();\\n        q1.pop();\\n\\n  }\\n\\n\\n\\n   return true;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2405461,
                "title": "java-solution-92-faster-than-others-easily-understandable",
                "content": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i=0, j=0;\\n        boolean ans = true;\\n        while(i < name.length() && j < typed.length()){\\n            char chari = name.charAt(i);\\n            char charj = typed.charAt(j);\\n            if(chari == charj){\\n                i++; j++;\\n            } \\n            else {\\n                if (j != 0 && typed.charAt(j-1) == charj){\\n                    j++;\\n                }\\n                else{  \\n                    ans = false;\\n                    break;\\n                }\\n            }\\n        }\\n        while(j > 0 && j < typed.length()){\\n            if(typed.charAt(j-1) != typed.charAt(j)){\\n                ans = false;\\n                break;\\n            }\\n            j++;\\n        }\\n        if(i != name.length()){\\n            ans =false;\\n        }\\n        \\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i=0, j=0;\\n        boolean ans = true;\\n        while(i < name.length() && j < typed.length()){\\n            char chari = name.charAt(i);\\n            char charj = typed.charAt(j);\\n            if(chari == charj){\\n                i++; j++;\\n            } \\n            else {\\n                if (j != 0 && typed.charAt(j-1) == charj){\\n                    j++;\\n                }\\n                else{  \\n                    ans = false;\\n                    break;\\n                }\\n            }\\n        }\\n        while(j > 0 && j < typed.length()){\\n            if(typed.charAt(j-1) != typed.charAt(j)){\\n                ans = false;\\n                break;\\n            }\\n            j++;\\n        }\\n        if(i != name.length()){\\n            ans =false;\\n        }\\n        \\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2129245,
                "title": "so-nice-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        if(name[0]!=typed[0])   return false;\\n        int n=name.size(), m=typed.size();\\n        int i=0, j=0;\\n        while(i<n || j<m) {\\n            if(name[i]==typed[j])   i++;\\n            else if(typed[j]!=typed[j-1])   return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        if(name[0]!=typed[0])   return false;\\n        int n=name.size(), m=typed.size();\\n        int i=0, j=0;\\n        while(i<n || j<m) {\\n            if(name[i]==typed[j])   i++;\\n            else if(typed[j]!=typed[j-1])   return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849733,
                "title": "java-fast-2-pointers-solution",
                "content": "```\\npublic boolean isLongPressedName(String name, String typed) {\\n        if (typed.length() < name.length()) {\\n            return false;\\n        }\\n        int i = 0;\\n        int j = 0;\\n\\n        while (j < typed.length()) {\\n            if (i < name.length() && (name.charAt(i) == typed.charAt(j))) {\\n                i++;\\n                j++;\\n            }\\n\\n            else if (j > 0 && typed.charAt(j) == typed.charAt(j - 1)) {\\n                j++;\\n            }\\n\\n            else {\\n                return false;\\n            }\\n\\n        }\\n        return i == name.length();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic boolean isLongPressedName(String name, String typed) {\\n        if (typed.length() < name.length()) {\\n            return false;\\n        }\\n        int i = 0;\\n        int j = 0;\\n\\n        while (j < typed.length()) {\\n            if (i < name.length() && (name.charAt(i) == typed.charAt(j))) {\\n                i++;\\n                j++;\\n            }\\n\\n            else if (j > 0 && typed.charAt(j) == typed.charAt(j - 1)) {\\n                j++;\\n            }\\n\\n            else {\\n                return false;\\n            }\\n\\n        }\\n        return i == name.length();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1739037,
                "title": "beginner-friendly-java-solution",
                "content": "**Time Complexity : O(n)**\\nWhere n is length of typed\\n```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int c = 0;\\n        for(int i=0; i<typed.length(); i++){\\n            if(c < name.length() && name.charAt(c) == typed.charAt(i))   c++;\\n            else if(i == 0 || typed.charAt(i) != typed.charAt(i-1))  return false;\\n        }\\n        return c == name.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int c = 0;\\n        for(int i=0; i<typed.length(); i++){\\n            if(c < name.length() && name.charAt(c) == typed.charAt(i))   c++;\\n            else if(i == 0 || typed.charAt(i) != typed.charAt(i-1))  return false;\\n        }\\n        return c == name.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331646,
                "title": "python-easy",
                "content": "Our special technique here is this line: `f = lambda x: [list(group) for c, group in itertools.groupby(x)]`, specifically, the `groupby` function!\\n\\n```python\\ndef isLongPressedName(self, name, typed):\\n\\n\\tf = lambda x: [list(group) for c, group in itertools.groupby(x)]\\n\\t\\n\\tname, typed = f(name), f(typed)\\n\\t\\n\\tif len(name) != len(typed): return False\\n\\t\\n\\tfor i in range(len(name)):\\n\\t\\tif not (name[i][0] == typed[i][0] and len(name[i]) <= len(typed[i])):\\n\\t\\t\\treturn False\\n\\t\\t\\t\\n\\treturn True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef isLongPressedName(self, name, typed):\\n\\n\\tf = lambda x: [list(group) for c, group in itertools.groupby(x)]\\n\\t\\n\\tname, typed = f(name), f(typed)\\n\\t\\n\\tif len(name) != len(typed): return False\\n\\t\\n\\tfor i in range(len(name)):\\n\\t\\tif not (name[i][0] == typed[i][0] and len(name[i]) <= len(typed[i])):\\n\\t\\t\\treturn False\\n\\t\\t\\t\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1003777,
                "title": "clean-o-n-javascript-solution-with-two-pointers",
                "content": "```\\nvar isLongPressedName = function(name, typed) {\\n  for (var i = 0,j=0; i < typed.length && j<=name.length; i++) {\\n      if (typed[i] == name[j]) j++;\\n      else if (typed[i]!=name[j-1]) return false\\n    } \\n    return i==typed.length && j==name.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar isLongPressedName = function(name, typed) {\\n  for (var i = 0,j=0; i < typed.length && j<=name.length; i++) {\\n      if (typed[i] == name[j]) j++;\\n      else if (typed[i]!=name[j-1]) return false\\n    } \\n    return i==typed.length && j==name.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 884853,
                "title": "c-brute-force-solution-0ms-100-runtime-53-less-space-explained",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool isLongPressedName(string name, string typed)\\n    {\\n        if (name[0] != typed[0])\\n            return 0;\\n        bool res = 0;\\n        int k = 0, count = 0; // count is track no. of char found\\n        // k is used to traverse typed char\\'s\\n        char prev = \\'a\\'; // next element either should be prev char or required char,\\n                         // if we found any other char, then return false\\n        for (int i = 0; i < name.length(); i++)\\n        {\\n            while (k < typed.length())\\n            {\\n                if (name[i] == typed[k])\\n                {\\n                    res = 1;\\n                    prev = typed[k];\\n                    k++;\\n                    count++;\\n                    break;\\n                }\\n                else if (prev != typed[k])\\n                    return 0;\\n                k++;\\n            }\\n        }\\n\\n        if (count != name.length()) // this is to check wheither we found all char in name or not\\n            res = 0;\\n\\n        if (k != typed.length()) // this is to check wheither typed has any other char after we found all name char\\n        {\\n            while (k < typed.length())\\n            {\\n                if (name[name.length() - 1] != typed[k])\\n                    return 0;\\n                k++;\\n            }\\n            res = 1; // this is for last char of name is repeating in typed\\n        }\\n        /* Example Test case:\\n               \"alex\"\\n               \"alexxe\"\\n        */\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool isLongPressedName(string name, string typed)\\n    {\\n        if (name[0] != typed[0])\\n            return 0;\\n        bool res = 0;\\n        int k = 0, count = 0; // count is track no. of char found\\n        // k is used to traverse typed char\\'s\\n        char prev = \\'a\\'; // next element either should be prev char or required char,\\n                         // if we found any other char, then return false\\n        for (int i = 0; i < name.length(); i++)\\n        {\\n            while (k < typed.length())\\n            {\\n                if (name[i] == typed[k])\\n                {\\n                    res = 1;\\n                    prev = typed[k];\\n                    k++;\\n                    count++;\\n                    break;\\n                }\\n                else if (prev != typed[k])\\n                    return 0;\\n                k++;\\n            }\\n        }\\n\\n        if (count != name.length()) // this is to check wheither we found all char in name or not\\n            res = 0;\\n\\n        if (k != typed.length()) // this is to check wheither typed has any other char after we found all name char\\n        {\\n            while (k < typed.length())\\n            {\\n                if (name[name.length() - 1] != typed[k])\\n                    return 0;\\n                k++;\\n            }\\n            res = 1; // this is for last char of name is repeating in typed\\n        }\\n        /* Example Test case:\\n               \"alex\"\\n               \"alexxe\"\\n        */\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826004,
                "title": "c-one-pass-solution-using-two-pointers-o-n-m-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int i = 0; // i indexes into name\\n        int j = 0; // j indexes into typed\\n        \\n        if (name[i] != typed[j]) return false;\\n        \\n        while(i < name.length()) {\\n            // comparing letter by letter until mismatched\\n            while(i < name.length() && name[i] == typed[j]) {\\n                i++;\\n                j++;\\n            }\\n            // stop here at first mismatch between name[i] and typed[j]\\n            // here the mismatch could be the result of long pressed key, thus \\n            // we keep checking typed[j] against previous character name[i-1] \\n            // until we run into another mismatch.\\n            while(typed[j] == name[i-1]) {\\n                j++;\\n            }\\n            // if the pairing after long-pressed key has been accounted    \\n            // is still a mismatch, return false\\n            if (name[i] != typed[j]) {\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int i = 0; // i indexes into name\\n        int j = 0; // j indexes into typed\\n        \\n        if (name[i] != typed[j]) return false;\\n        \\n        while(i < name.length()) {\\n            // comparing letter by letter until mismatched\\n            while(i < name.length() && name[i] == typed[j]) {\\n                i++;\\n                j++;\\n            }\\n            // stop here at first mismatch between name[i] and typed[j]\\n            // here the mismatch could be the result of long pressed key, thus \\n            // we keep checking typed[j] against previous character name[i-1] \\n            // until we run into another mismatch.\\n            while(typed[j] == name[i-1]) {\\n                j++;\\n            }\\n            // if the pairing after long-pressed key has been accounted    \\n            // is still a mismatch, return false\\n            if (name[i] != typed[j]) {\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642164,
                "title": "short-simple-and-self-explanatory-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        \\n        int j=0;\\n        \\n        for(int i=0;i<typed.size();i++)\\n        {\\n            if(name[j]==typed[i]) j++;\\n            else\\n            {\\n                if(i==0) return false;\\n                else if(typed[i]!=name[j-1]) return false;\\n            }\\n        }\\n        \\n        return j==name.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        \\n        int j=0;\\n        \\n        for(int i=0;i<typed.size();i++)\\n        {\\n            if(name[j]==typed[i]) j++;\\n            else\\n            {\\n                if(i==0) return false;\\n                else if(typed[i]!=name[j-1]) return false;\\n            }\\n        }\\n        \\n        return j==name.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441783,
                "title": "easy-to-follow-python-solution",
                "content": "The question seems to have loose test cases. This solution should cover all of cases not accounted for. \\n\\nThe idea is to make sure the next seen typed character is either the Next name character we\\'re expecting OR part of a long-press sequence of the Last name character.\\n\\n```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n\\t\\t# First confirm the typed string at least starts with the first character of the name\\n        if typed[0] != name[0]:\\n            return False\\n\\t\\t# Start your traversal expecting to see the next name character.\\n        last_name_char, next_name_char = 0, 1\\n        for typed_char in range(1, len(typed)):\\n\\t\\t\\t# if next name character was seen, update the next and last name character\\n            if next_name_char < len(name) and typed[typed_char] == name[next_name_char]:\\n                last_name_char = next_name_char\\n                next_name_char += 1\\n\\t\\t\\t# if next character was not seen, then the current character must be part of a long-press sequence of the last seen name character\\n            elif typed[typed_char] != name[last_name_char]:\\n                return False\\n        return next_name_char == len(name)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n\\t\\t# First confirm the typed string at least starts with the first character of the name\\n        if typed[0] != name[0]:\\n            return False\\n\\t\\t# Start your traversal expecting to see the next name character.\\n        last_name_char, next_name_char = 0, 1\\n        for typed_char in range(1, len(typed)):\\n\\t\\t\\t# if next name character was seen, update the next and last name character\\n            if next_name_char < len(name) and typed[typed_char] == name[next_name_char]:\\n                last_name_char = next_name_char\\n                next_name_char += 1\\n\\t\\t\\t# if next character was not seen, then the current character must be part of a long-press sequence of the last seen name character\\n            elif typed[typed_char] != name[last_name_char]:\\n                return False\\n        return next_name_char == len(name)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208759,
                "title": "c-4-lines",
                "content": "```\\npublic class Solution {\\n    public bool IsLongPressedName(string name, string typed) {\\n        for(int i=0,j=0;i<typed.Length;i++){\\n            if(name[j]==typed[i]) j++;\\n            if(j==name.Length) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsLongPressedName(string name, string typed) {\\n        for(int i=0,j=0;i<typed.Length;i++){\\n            if(name[j]==typed[i]) j++;\\n            if(j==name.Length) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775146,
                "title": "beats-100-using-java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int n=name.length();\\n        int m=typed.length();\\n        if(n>m)return false;\\n        if(name.charAt(0)!=typed.charAt(0))return false;\\n        int i=0,j=0;\\n        while(i<n && j<m)\\n        {\\n            if(name.charAt(i)==typed.charAt(j))\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(name.charAt(i-1)==typed.charAt(j))\\n            {\\n                j++;\\n            }\\n            else \\n            return false;\\n\\n        }\\n        while(j<m)\\n        {\\n            if(name.charAt(i-1)==typed.charAt(j))j++;\\n            else \\n            return false;\\n\\n        }\\n        if(i<n)\\n            return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int n=name.length();\\n        int m=typed.length();\\n        if(n>m)return false;\\n        if(name.charAt(0)!=typed.charAt(0))return false;\\n        int i=0,j=0;\\n        while(i<n && j<m)\\n        {\\n            if(name.charAt(i)==typed.charAt(j))\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(name.charAt(i-1)==typed.charAt(j))\\n            {\\n                j++;\\n            }\\n            else \\n            return false;\\n\\n        }\\n        while(j<m)\\n        {\\n            if(name.charAt(i-1)==typed.charAt(j))j++;\\n            else \\n            return false;\\n\\n        }\\n        if(i<n)\\n            return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215353,
                "title": "python3-wasy-peasy-solution",
                "content": "# Intuition\\ntwo pointers\\n\\n# Approach\\nIn this implementation, we are using two pointers i and j to traverse the name and typed strings respectively. We compare the characters at these pointers and move the pointers accordingly.\\n\\nIf the characters at the current positions are equal, we increment both i and j, and move on to the next character. If the characters are not equal, we check if the previous character in the typed string is the same as the current character, and if it is, we increment j and move on to the next character. If the previous character in the typed string is not the same as the current character, we can immediately return False as this means that the current character in typed is not part of the name.\\n\\nWe continue this process until we have traversed the entire typed string. Finally, we check if we have traversed the entire name string by comparing the value of i with n, the length of name.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the typed string. This is already an optimal time complexity as we need to examine each character of the typed string at least once to compare it with the corresponding character in the name string.\\n\\n- Space complexity:\\nThis implementation has a space complexity of O(1), as we are not using any additional data structures to store the counts of characters.\\n\\n# Code\\n```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n\\n\\n        i, j = 0, 0\\n        while j < len(typed):\\n\\n            if i < len(name) and name[i] == typed[j]:\\n                i += 1\\n                j += 1\\n            elif j > 0 and typed[j-1] == typed[j]:\\n                j += 1\\n            else:\\n                return False\\n\\n        return i == len(name)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n\\n\\n        i, j = 0, 0\\n        while j < len(typed):\\n\\n            if i < len(name) and name[i] == typed[j]:\\n                i += 1\\n                j += 1\\n            elif j > 0 and typed[j-1] == typed[j]:\\n                j += 1\\n            else:\\n                return False\\n\\n        return i == len(name)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054798,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        vector<pair<char,int>>v,v1;\\n        char x,y;\\n        x=typed[0];\\n        y=name[0];\\n        int count=1;\\n        for(int i=1;i<typed.length();i++)\\n        {\\n            if(x==typed[i])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                v.push_back({x,count});\\n                count=1;\\n                x=typed[i];\\n            }\\n            \\n        }\\n        v.push_back({x,count});\\n        count=1;\\n        for(int i=1;i<name.length();i++)\\n        {\\n            if(y==name[i])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                v1.push_back({y,count});\\n                count=1;\\n                y=name[i];\\n            }\\n            \\n        }\\n       v1.push_back({y,count});\\n        if(v.size()!=v1.size())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<v.size();i++)\\n        { \\n            if(v[i].first==v1[i].first)\\n            {\\n                if(v[i].second<v1[i].second)\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        vector<pair<char,int>>v,v1;\\n        char x,y;\\n        x=typed[0];\\n        y=name[0];\\n        int count=1;\\n        for(int i=1;i<typed.length();i++)\\n        {\\n            if(x==typed[i])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                v.push_back({x,count});\\n                count=1;\\n                x=typed[i];\\n            }\\n            \\n        }\\n        v.push_back({x,count});\\n        count=1;\\n        for(int i=1;i<name.length();i++)\\n        {\\n            if(y==name[i])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                v1.push_back({y,count});\\n                count=1;\\n                y=name[i];\\n            }\\n            \\n        }\\n       v1.push_back({y,count});\\n        if(v.size()!=v1.size())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<v.size();i++)\\n        { \\n            if(v[i].first==v1[i].first)\\n            {\\n                if(v[i].second<v1[i].second)\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919033,
                "title": "easy-c-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     bool isLongPressedName(string name, string typed) {\\n        int i = 0, m = name.length(), n = typed.length();\\n        for (int j = 0; j < n; ++j)\\n            if (i < m && name[i] == typed[j])\\n                ++i;\\n            else if (!j || typed[j] != typed[j - 1])\\n                return false;\\n        return i == m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool isLongPressedName(string name, string typed) {\\n        int i = 0, m = name.length(), n = typed.length();\\n        for (int j = 0; j < n; ++j)\\n            if (i < m && name[i] == typed[j])\\n                ++i;\\n            else if (!j || typed[j] != typed[j - 1])\\n                return false;\\n        return i == m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882875,
                "title": "cpp-easy-to-understand-two-pointers",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) \\n\\t{\\n         int idx1=0;  //pointer on name\\n\\t\\t int idx2=0;  //pointer on typed\\n\\t\\t \\n\\t\\t while(idx1<name.length() and idx2<typed.length())\\n\\t\\t {\\n              if(name[idx1] != typed[idx2])\\n              return false;\\n\\n\\t\\t      int count1=1;\\n  \\t          while(idx1<(name.length()-1) and name[idx1] == name[idx1+1])\\n  \\t          {\\n  \\t               count1++;\\n\\t\\t\\t\\t   idx1++;\\t\\n\\t\\t\\t  }\\n\\t\\t\\t  int count2=1;\\n\\t\\t\\t  while(idx2<(typed.length()-1) and typed[idx2] == typed[idx2+1])\\n\\t\\t\\t  {\\n\\t\\t\\t      count2++;\\n\\t\\t\\t\\t  idx2++;\\t\\n\\t\\t\\t  }\\n\\t\\t\\t  if(count1 > count2)\\n\\t\\t\\t  return false;\\n\\n              idx1++;\\n              idx2++;\\n\\t     }    \\n         if(idx2 < typed.length() or idx1 < name.length()) \\n         return false;\\n\\n\\t     return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) \\n\\t{\\n         int idx1=0;  //pointer on name\\n\\t\\t int idx2=0;  //pointer on typed\\n\\t\\t \\n\\t\\t while(idx1<name.length() and idx2<typed.length())\\n\\t\\t {\\n              if(name[idx1] != typed[idx2])\\n              return false;\\n\\n\\t\\t      int count1=1;\\n  \\t          while(idx1<(name.length()-1) and name[idx1] == name[idx1+1])\\n  \\t          {\\n  \\t               count1++;\\n\\t\\t\\t\\t   idx1++;\\t\\n\\t\\t\\t  }\\n\\t\\t\\t  int count2=1;\\n\\t\\t\\t  while(idx2<(typed.length()-1) and typed[idx2] == typed[idx2+1])\\n\\t\\t\\t  {\\n\\t\\t\\t      count2++;\\n\\t\\t\\t\\t  idx2++;\\t\\n\\t\\t\\t  }\\n\\t\\t\\t  if(count1 > count2)\\n\\t\\t\\t  return false;\\n\\n              idx1++;\\n              idx2++;\\n\\t     }    \\n         if(idx2 < typed.length() or idx1 < name.length()) \\n         return false;\\n\\n\\t     return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685094,
                "title": "python-1-iteration-solution",
                "content": "```\\nclass Solution:\\n\\t def isLongPressedName(self, name: str, typed: str) -> bool:\\n        if name != typed:\\n            for i in name:\\n                if typed.count(i) < name.count(i):\\n                    result = False\\n                    break\\n                else:\\n                    result = True\\n                \\n            return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\t def isLongPressedName(self, name: str, typed: str) -> bool:\\n        if name != typed:\\n            for i in name:\\n                if typed.count(i) < name.count(i):\\n                    result = False\\n                    break\\n                else:\\n                    result = True\\n                \\n            return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641335,
                "title": "100-fast-cpp-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int i = 0, m = name.length(), n = typed.length();\\n        for (int j = 0; j < n; ++j)\\n            if (i < m && name[i] == typed[j])\\n                ++i;\\n            else if (!j || typed[j] != typed[j - 1])\\n                return false;\\n        return i == m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int i = 0, m = name.length(), n = typed.length();\\n        for (int j = 0; j < n; ++j)\\n            if (i < m && name[i] == typed[j])\\n                ++i;\\n            else if (!j || typed[j] != typed[j - 1])\\n                return false;\\n        return i == m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589413,
                "title": "c-compact-100-o-n-6-lines-only",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string n, string t) {\\n        int index = 0, i = 0;\\n        for (i = 0; i < t.size(); i++) {\\n            if (n[index] == t[i]) index++;\\n            else if (index && n[index - 1] == t[i]) {}\\n            else return false;\\n        }\\n        return i == t.size() && index == n.size();\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string n, string t) {\\n        int index = 0, i = 0;\\n        for (i = 0; i < t.size(); i++) {\\n            if (n[index] == t[i]) index++;\\n            else if (index && n[index - 1] == t[i]) {}\\n            else return false;\\n        }\\n        return i == t.size() && index == n.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542269,
                "title": "java-regular-expression-solution",
                "content": "```java\\nimport java.util.regex.*;\\n\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        \\n        if (name.equals(typed)) return true;\\n        \\n        StringBuilder allowed = new StringBuilder();\\n        \\n\\t\\t// start of string character\\n        allowed.append(\"^\");\\n        \\n\\t\\t// add groups for each letter\\n        for (Character c : name.toCharArray()) {\\n            allowed.append(\"(\");\\n            allowed.append(c);\\n\\t\\t\\t// allow for long-typed\\n            allowed.append(\")+\");\\n        }\\n        \\n\\t\\t// end of string character\\n        allowed.append(\"$\");\\n        \\n\\t\\t// create pattern\\n        Pattern pattern = Pattern.compile(allowed.toString());\\n        \\n\\t\\t// create pattern matcher\\n\\t\\tMatcher matcher = pattern.matcher(typed);\\n        \\n\\t\\t// return if match found\\n        return matcher.find();\\n        \\n    }\\n}\\n```\\n\\nTo better understand regular expression syntax, visit my [Interview Cheat Sheet](https://github.com/joshuajerome/Leetcode/wiki/Interview-Cheat-Sheet/)!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nimport java.util.regex.*;\\n\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        \\n        if (name.equals(typed)) return true;\\n        \\n        StringBuilder allowed = new StringBuilder();\\n        \\n\\t\\t// start of string character\\n        allowed.append(\"^\");\\n        \\n\\t\\t// add groups for each letter\\n        for (Character c : name.toCharArray()) {\\n            allowed.append(\"(\");\\n            allowed.append(c);\\n\\t\\t\\t// allow for long-typed\\n            allowed.append(\")+\");\\n        }\\n        \\n\\t\\t// end of string character\\n        allowed.append(\"$\");\\n        \\n\\t\\t// create pattern\\n        Pattern pattern = Pattern.compile(allowed.toString());\\n        \\n\\t\\t// create pattern matcher\\n\\t\\tMatcher matcher = pattern.matcher(typed);\\n        \\n\\t\\t// return if match found\\n        return matcher.find();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434170,
                "title": "javascript-one-line-solution",
                "content": "```\\n/**\\n * @param {string} name\\n * @param {string} typed\\n * @return {boolean}\\n */\\nvar isLongPressedName = function(name, typed) {\\n    return new RegExp(\"^\" + name.match(/(.)\\\\1*/g).join(\"+\") + \"+$\").test(typed)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} name\\n * @param {string} typed\\n * @return {boolean}\\n */\\nvar isLongPressedName = function(name, typed) {\\n    return new RegExp(\"^\" + name.match(/(.)\\\\1*/g).join(\"+\") + \"+$\").test(typed)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2394268,
                "title": "c-0ms-solution-two-pointer-approach-fundamental-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        \\n        int j = 0, i = 0;\\n        for( ; i<name.length() && j<typed.length() ; i++)\\n        {\\n            if(name[i]!=typed[j++])\\n                return false;\\n            \\n            \\n            if(i<name.length() && name[i]!= name[i+1])\\n            {\\n                while(j<typed.length() && typed[j] == name[i])\\n                j++;\\n            }\\n        }\\n        \\n         return (i == name.length() && j == typed.length());\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/28fa170a-71bd-4459-bab2-fb737c5b8383_1659891804.5864234.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        \\n        int j = 0, i = 0;\\n        for( ; i<name.length() && j<typed.length() ; i++)\\n        {\\n            if(name[i]!=typed[j++])\\n                return false;\\n            \\n            \\n            if(i<name.length() && name[i]!= name[i+1])\\n            {\\n                while(j<typed.length() && typed[j] == name[i])\\n                j++;\\n            }\\n        }\\n        \\n         return (i == name.length() && j == typed.length());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2388808,
                "title": "one-more-easy-to-understand-solution-xd",
                "content": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i = 0;\\n        int j = 0;\\n        int m = name.length();\\n        int n = typed.length();\\n        \\n        while(j < n)\\n        {\\n            if(i < m && name.charAt(i) == typed.charAt(j))\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(j > 0 && typed.charAt(j) == typed.charAt(j-1))\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return i == m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i = 0;\\n        int j = 0;\\n        int m = name.length();\\n        int n = typed.length();\\n        \\n        while(j < n)\\n        {\\n            if(i < m && name.charAt(i) == typed.charAt(j))\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(j > 0 && typed.charAt(j) == typed.charAt(j-1))\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return i == m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324127,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n       \\n int i =0; int j =0;\\n    while(i<name.size() || j <typed.size()) {\\n        char current = name[i];\\n        if(name[i] != typed[j]) return false;\\n        i++;\\n        j++;\\n        if(name[i] != typed[j]) {\\n            while(current == typed[j]) j++;\\n        } \\n    }\\n    return true;\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n       \\n int i =0; int j =0;\\n    while(i<name.size() || j <typed.size()) {\\n        char current = name[i];\\n        if(name[i] != typed[j]) return false;\\n        i++;\\n        j++;\\n        if(name[i] != typed[j]) {\\n            while(current == typed[j]) j++;\\n        } \\n    }\\n    return true;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210947,
                "title": "0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int j(1);\\n        if(name[0] != typed[0]) return false;\\n        \\n        for(int i = 1; i < typed.size(); i++){\\n            if(typed[i] != name[j] and typed[i] != name[j - 1])\\n                return false;\\n            j += typed[i] == name[j];\\n        }\\n                    \\n        return j == name.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int j(1);\\n        if(name[0] != typed[0]) return false;\\n        \\n        for(int i = 1; i < typed.size(); i++){\\n            if(typed[i] != name[j] and typed[i] != name[j - 1])\\n                return false;\\n            j += typed[i] == name[j];\\n        }\\n                    \\n        return j == name.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082388,
                "title": "python-o-n-by-two-pointer-easy-and-intuitive-approach",
                "content": "Simple approach and efficient solution using two pointer for each strings. \\n##### If order isn\\'t matter then we can use Counter in python to simply.\\n\\n```\\n def isLongPressedName(self, name: str, typed: str) -> bool:\\n        i,j = 0,0\\n        a,b = len(name),len(typed)\\n        \\n        while (i<a and j<b):\\n            if name[i] == typed[j]:\\n                i += 1\\n                j += 1\\n                continue\\n            elif (i!=0) and (name[i-1] == typed[j]):\\n                j += 1\\n            else:\\n                return False\\n\\t\\t\\t\\n\\t\\t# Check the edge cases\\n        if i<a:\\n            return False\\n        if j<b:\\n            while j<b:\\n                if name[a-1] != typed[j]:\\n                    return False\\n                j += 1\\n        \\n\\t\\t# If not returned False then it\\'s right.. return True\\n        return True\\n\\t```\\n\\t\\t\\nIf you find this helpful, then give UpVote, much appriciated.\\n### Thanks",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n def isLongPressedName(self, name: str, typed: str) -> bool:\\n        i,j = 0,0\\n        a,b = len(name),len(typed)\\n        \\n        while (i<a and j<b):\\n            if name[i] == typed[j]:\\n                i += 1\\n                j += 1\\n                continue\\n            elif (i!=0) and (name[i-1] == typed[j]):\\n                j += 1\\n            else:\\n                return False\\n\\t\\t\\t\\n\\t\\t# Check the edge cases\\n        if i<a:\\n            return False\\n        if j<b:\\n            while j<b:\\n                if name[a-1] != typed[j]:\\n                    return False\\n                j += 1\\n        \\n\\t\\t# If not returned False then it\\'s right.. return True\\n        return True\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1944902,
                "title": "python3-10-line-code-using-2-pointers",
                "content": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        i, j, m, n = 0, 0, len(name), len(typed)\\n        if n < m: return False\\n        while i < m and j < n:\\n            if name[i] == typed[j]:\\n                i += 1\\n                j += 1\\n            elif j == 0 or typed[j] != typed[j - 1]: return False\\n            else:\\n                j += 1\\n        return i == m and typed[j:] == typed[j - 1] * (n - j)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        i, j, m, n = 0, 0, len(name), len(typed)\\n        if n < m: return False\\n        while i < m and j < n:\\n            if name[i] == typed[j]:\\n                i += 1\\n                j += 1\\n            elif j == 0 or typed[j] != typed[j - 1]: return False\\n            else:\\n                j += 1\\n        return i == m and typed[j:] == typed[j - 1] * (n - j)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739039,
                "title": "beginner-friendly-javascript-solution",
                "content": "**Time Complexity : O(n)**\\nWhere n is length of typed\\n```\\n/**\\n * @param {string} name\\n * @param {string} typed\\n * @return {boolean}\\n */\\nvar isLongPressedName = function(name, typed) {\\n    let c = 0;\\n    for(let i=0; i<typed.length; i++){\\n        if(c < name.length && name[c] == typed[i])   c++;\\n        else if(i == 0 || typed[i] != typed[i-1])  return false;\\n    }\\n    return c == name.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} name\\n * @param {string} typed\\n * @return {boolean}\\n */\\nvar isLongPressedName = function(name, typed) {\\n    let c = 0;\\n    for(let i=0; i<typed.length; i++){\\n        if(c < name.length && name[c] == typed[i])   c++;\\n        else if(i == 0 || typed[i] != typed[i-1])  return false;\\n    }\\n    return c == name.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1491537,
                "title": "java-simple-solution-faster-than-100-submissions",
                "content": "Steps:\\n1. If `typed.length() < name.length()`, it means the name is not typed so `return false`.\\n2. Take two pointers-\\n\\t1. `i` -> For traversing the typed string\\n\\t2. `j` -> For traversing the name string\\n3. Iterate through the typed string\\n\\t1. if `j < name.length()` i.e. all the characters in name string is not yet traversed\\n\\t\\ti.  if `name.charAt(j) == typed.charAt(i)` i.e. a character of name is matched then increment the `j` pointer to check for the next\\n\\t\\tii. if the chars don\\'t match, check if it matches with the previous character, if not return false. This case will occur when we have same consecutive chars in typed string, in the first occurence we have moved the j pointer forward but it is same as the previous char at j.\\n\\t2. if name has been matched completely i.e. `j >=  name.length()`, then all the chars in typed string has to be same to the last character in name string, if not then `return false`\\n4. Finally return true if name is completely matched else return false, thus return `j == name.length()`\\n```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if (typed.length() < name.length())\\n            return false;\\n        int i = 0, j = 0;\\n        for (; i < typed.length(); i++) {\\n            if (j < name.length()) {\\n                if (name.charAt(j) == typed.charAt(i))\\n                    j++;\\n                else if (name.charAt(j) != typed.charAt(i)) {\\n                    if (j == 0 || typed.charAt(i) != name.charAt(j - 1))\\n                        return false;\\n                }\\n            }\\n            else if (typed.charAt(i) != name.charAt(j - 1))\\n                return false;\\n        }\\n        return j == name.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if (typed.length() < name.length())\\n            return false;\\n        int i = 0, j = 0;\\n        for (; i < typed.length(); i++) {\\n            if (j < name.length()) {\\n                if (name.charAt(j) == typed.charAt(i))\\n                    j++;\\n                else if (name.charAt(j) != typed.charAt(i)) {\\n                    if (j == 0 || typed.charAt(i) != name.charAt(j - 1))\\n                        return false;\\n                }\\n            }\\n            else if (typed.charAt(i) != name.charAt(j - 1))\\n                return false;\\n        }\\n        return j == name.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455806,
                "title": "0ms-and-100-faster-java-solution-using-two-pointers-algo",
                "content": "# **Upvote if you like it\\n\\n\\tpublic boolean isLongPressedName(String name, String typed) {\\n\\t\\t\\tif(name.length() > typed.length()) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Using two pointers algo.\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint j = 0;\\n\\t\\t\\twhile((i < name.length()) && (j < typed.length())) {\\n\\t\\t\\t\\tif(name.charAt(i) == typed.charAt(j)) {\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t} else if((i > 0) && (name.charAt(i - 1) == typed.charAt(j))) {\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile(j < typed.length()) {\\n\\t\\t\\t\\tif(typed.charAt(j) == name.charAt(i - 1)) {\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn i < name.length() ? false : true;\\n\\t\\t}",
                "solutionTags": [],
                "code": "# **Upvote if you like it\\n\\n\\tpublic boolean isLongPressedName(String name, String typed) {\\n\\t\\t\\tif(name.length() > typed.length()) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Using two pointers algo.\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint j = 0;\\n\\t\\t\\twhile((i < name.length()) && (j < typed.length())) {\\n\\t\\t\\t\\tif(name.charAt(i) == typed.charAt(j)) {\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t} else if((i > 0) && (name.charAt(i - 1) == typed.charAt(j))) {\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile(j < typed.length()) {\\n\\t\\t\\t\\tif(typed.charAt(j) == name.charAt(i - 1)) {\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn i < name.length() ? false : true;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1389528,
                "title": "c-runtime-0-ms-faster-than-100-00-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        \\n        int i=0, j=0;\\n        while(i<name.size())\\n        {\\n            if(name[i]==typed[j])\\n            {\\n                j++;\\n                i++;\\n            }\\n            else\\n            {\\n                if((j-1>=0&&typed[j]!=typed[j-1])||j==0)\\n                {\\n                    return 0;\\n                }\\n                j++;\\n            }\\n        }\\n        \\n        /*\\n\\t\\tFor the Test cases like:\\n\\t\\t\"alex\"\\n        \"alexxp\"\\n\\t\\t*/\\n        \\n        while(j<typed.size())\\n        {\\n            if(typed[j]!=typed[j-1])\\n                return 0;\\n            j++;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        \\n        int i=0, j=0;\\n        while(i<name.size())\\n        {\\n            if(name[i]==typed[j])\\n            {\\n                j++;\\n                i++;\\n            }\\n            else\\n            {\\n                if((j-1>=0&&typed[j]!=typed[j-1])||j==0)\\n                {\\n                    return 0;\\n                }\\n                j++;\\n            }\\n        }\\n        \\n        /*\\n\\t\\tFor the Test cases like:\\n\\t\\t\"alex\"\\n        \"alexxp\"\\n\\t\\t*/\\n        \\n        while(j<typed.size())\\n        {\\n            if(typed[j]!=typed[j-1])\\n                return 0;\\n            j++;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305306,
                "title": "c-easy-and-fast-solution-100-fast",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int i=0,j=0;\\n        if(name[i]!=typed[j])return false;\\n        while(i<name.size())\\n        {\\n            if(name[i]==typed[j]){\\n                i++;j++;\\n            }\\n            else{\\n                if(typed[j]==typed[j-1])\\n                    j++;\\n                else\\n                    return false;\\n            }\\n        }\\n        if(j!=typed.size())\\n        {\\n            for(int i=j;i<typed.size();i++)\\n                if(typed[i]!=typed[i-1])\\n                    return false;\\n        }\\n        return true;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int i=0,j=0;\\n        if(name[i]!=typed[j])return false;\\n        while(i<name.size())\\n        {\\n            if(name[i]==typed[j]){\\n                i++;j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1103637,
                "title": "5-lines-in-c-0ms",
                "content": "```\\n    char prev = name[0];\\n    for (; *typed; ++typed)\\n        if (*typed == *name) prev = *name++;\\n        else if (*typed != prev) return false;\\n    return !*name;\\n```",
                "solutionTags": [],
                "code": "```\\n    char prev = name[0];\\n    for (; *typed; ++typed)\\n        if (*typed == *name) prev = *name++;\\n        else if (*typed != prev) return false;\\n    return !*name;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1043121,
                "title": "java-two-pointer-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean isLongPressedName(String name, String typed) {\\n\\n\\t\\t\\tint i = 0, j = 0;\\n\\n\\t\\t\\twhile(j < typed.length()){\\n\\n\\t\\t\\t\\tif(i < name.length() && name.charAt(i) == typed.charAt(j)){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(j > 0 && typed.charAt(j) == typed.charAt(j - 1)){\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn i == name.length();\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean isLongPressedName(String name, String typed) {\\n\\n\\t\\t\\tint i = 0, j = 0;\\n\\n\\t\\t\\twhile(j < typed.length()){\\n\\n\\t\\t\\t\\tif(i < name.length() && name.charAt(i) == typed.charAt(j)){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 983967,
                "title": "java-100-faster",
                "content": "class Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i = 0, j= 0;\\n        while(j<typed.length()){\\n            if(i<name.length() && (name.charAt(i) == typed.charAt(j)))\\n            { \\n\\t\\t\\ti++ ;\\n            j++;\\n            }\\n            else if( j>0 && (typed.charAt(j) == typed.charAt(j-1))) j++;\\n            else return false;\\n        }\\n        return (i==name.length());\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i = 0, j= 0;\\n        while(j<typed.length()){\\n            if(i<name.length() && (name.charAt(i) == typed.charAt(j)))\\n            { \\n\\t\\t\\ti++ ;\\n            j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 744272,
                "title": "cpp-solution-0ms-extremely-simple",
                "content": "```\\n bool isLongPressedName(string name, string typed) {\\n        int i{0},j{0};\\n        while(i<name.length()){\\n            if(name[i]==typed[j]) i++,j++;\\n            else if(name[i]!=typed[j] && j>0 && typed[j]==typed[j-1]) j++;\\n            else return 0;\\n        }\\n\\t\\t/*\\n\\t\\tFor the Test cases like:\\n\\t\\t\"alex\"\\n        \"alexxr\"\\n\\t\\t*/\\n\\n        while(j<typed.length())\\n            if(typed[j++]!=name[name.length()-1]) return 0;\\n        return 1;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n bool isLongPressedName(string name, string typed) {\\n        int i{0},j{0};\\n        while(i<name.length()){\\n            if(name[i]==typed[j]) i++,j++;\\n            else if(name[i]!=typed[j] && j>0 && typed[j]==typed[j-1]) j++;\\n            else return 0;\\n        }\\n\\t\\t/*\\n\\t\\tFor the Test cases like:\\n\\t\\t\"alex\"\\n        \"alexxr\"\\n\\t\\t*/\\n\\n        while(j<typed.length())\\n            if(typed[j++]!=name[name.length()-1]) return 0;\\n        return 1;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 722749,
                "title": "c-2-pointer-fastest-memory-efficient",
                "content": "```\\nbool isLongPressedName(string& name, string& typed) {\\n\\tint ptr1 = 0, ptr2 = 0, N = name.length(), M = typed.length();\\n\\twhile (ptr1 != N && ptr2 != M) {\\n\\t\\tif (name[ptr1] == typed[ptr2]) {\\n\\t\\t\\tptr1++;\\n\\t\\t\\tptr2++;\\n\\t\\t} else {\\n\\t\\t\\tif (!ptr2 || typed[ptr2] != typed[ptr2 - 1]) return false;\\n\\t\\t\\tptr2++;\\n\\t\\t}\\n\\t}\\n\\n\\twhile (ptr2 != M) {\\n\\t\\tif (typed[ptr2] != typed[ptr2 - 1]) return false;\\n\\t\\tptr2++;\\n\\t}\\n\\treturn ptr1 == N;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nbool isLongPressedName(string& name, string& typed) {\\n\\tint ptr1 = 0, ptr2 = 0, N = name.length(), M = typed.length();\\n\\twhile (ptr1 != N && ptr2 != M) {\\n\\t\\tif (name[ptr1] == typed[ptr2]) {\\n\\t\\t\\tptr1++;\\n\\t\\t\\tptr2++;\\n\\t\\t} else {\\n\\t\\t\\tif (!ptr2 || typed[ptr2] != typed[ptr2 - 1]) return false;\\n\\t\\t\\tptr2++;\\n\\t\\t}\\n\\t}\\n\\n\\twhile (ptr2 != M) {\\n\\t\\tif (typed[ptr2] != typed[ptr2 - 1]) return false;\\n\\t\\tptr2++;\\n\\t}\\n\\treturn ptr1 == N;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 672530,
                "title": "java-two-pointer-0ms-100-99-28",
                "content": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int n=name.length(), m = typed.length(), i=0, j=0;\\n        while(i<n && j<m){\\n\\t\\t\\t// same character, move both i and j\\n            if(name.charAt(i)==typed.charAt(j)){\\n                i++;j++;\\n            } \\n\\t\\t\\t// different one, check if j keep move along same character\\n            else if(j>0&&typed.charAt(j)==typed.charAt(j-1)){\\n                 j++;\\n            }\\n\\t\\t\\t// if meet a different character in j but not in i\\n            else return false;\\n        }\\n\\t\\t// keep move j until end\\n        while(j<m && typed.charAt(j)==typed.charAt(j-1)) j++;\\n        return i==n && j==m;\\n      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int n=name.length(), m = typed.length(), i=0, j=0;\\n        while(i<n && j<m){\\n\\t\\t\\t// same character, move both i and j\\n            if(name.charAt(i)==typed.charAt(j)){\\n                i++;j++;\\n            } \\n\\t\\t\\t// different one, check if j keep move along same character\\n            else if(j>0&&typed.charAt(j)==typed.charAt(j-1)){\\n                 j++;\\n            }\\n\\t\\t\\t// if meet a different character in j but not in i\\n            else return false;\\n        }\\n\\t\\t// keep move j until end\\n        while(j<m && typed.charAt(j)==typed.charAt(j-1)) j++;\\n        return i==n && j==m;\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656534,
                "title": "c-beats-100-two-pointer",
                "content": "Easy to Understand C++ Solution\\n\\n\\tbool isLongPressedName(string name, string typed)\\n\\t{\\n\\t\\tint n = name.size(), m = typed.size(), i = 0, j = 0;\\n\\n\\t\\twhile(i < n && j < m)\\n\\t\\t{\\n\\t\\t\\tint start1 = i;\\n\\t\\t\\twhile(i < n && name[i] == name[start1])\\n\\t\\t\\t\\ti = i + 1;\\n\\n\\t\\t\\tint count1 = i - start1;\\n\\n\\t\\t\\tint start2 = j;\\n\\n\\t\\t\\twhile(j < m && typed[j] == name[start1])\\n\\t\\t\\t\\tj =  j + 1;\\n\\n\\t\\t\\tint count2 = j - start2;\\n\\n\\t\\t\\tif(count2 < count1)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn i == n && j == m ? true: false;\\n\\t}",
                "solutionTags": [],
                "code": "Easy to Understand C++ Solution\\n\\n\\tbool isLongPressedName(string name, string typed)\\n\\t{\\n\\t\\tint n = name.size(), m = typed.size(), i = 0, j = 0;\\n\\n\\t\\twhile(i < n && j < m)\\n\\t\\t{\\n\\t\\t\\tint start1 = i;\\n\\t\\t\\twhile(i < n && name[i] == name[start1])\\n\\t\\t\\t\\ti = i + 1;\\n\\n\\t\\t\\tint count1 = i - start1;\\n\\n\\t\\t\\tint start2 = j;\\n\\n\\t\\t\\twhile(j < m && typed[j] == name[start1])\\n\\t\\t\\t\\tj =  j + 1;\\n\\n\\t\\t\\tint count2 = j - start2;\\n\\n\\t\\t\\tif(count2 < count1)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn i == n && j == m ? true: false;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 649208,
                "title": "0-ms-c-easy-solution",
                "content": "```\\nbool isLongPressedName(string name, string typed) {\\n\\tint i=0, j=0;\\n\\twhile(i<name.size() && j<typed.size()){\\n\\t\\tint ct=0, cn=0;\\n\\t\\twhile(typed[j+1]==typed[j]){\\n\\t\\t\\tct++;\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\twhile(name[i+1]==name[i]){\\n\\t\\t\\tcn++;\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tif(typed[j]!=name[i] || cn>ct) return false;\\n\\t\\ti++;\\n\\t\\tj++;\\n\\t}\\n\\tif(i==name.size() && j==typed.size() && name[i]==typed[j]) return true;\\n\\treturn false;\\n}",
                "solutionTags": [],
                "code": "```\\nbool isLongPressedName(string name, string typed) {\\n\\tint i=0, j=0;\\n\\twhile(i<name.size() && j<typed.size()){\\n\\t\\tint ct=0, cn=0;\\n\\t\\twhile(typed[j+1]==typed[j]){\\n\\t\\t\\tct++;\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\twhile(name[i+1]==name[i]){\\n\\t\\t\\tcn++;\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tif(typed[j]!=name[i] || cn>ct) return false;\\n\\t\\ti++;\\n\\t\\tj++;\\n\\t}\\n\\tif(i==name.size() && j==typed.size() && name[i]==typed[j]) return true;\\n\\treturn false;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 442779,
                "title": "python-two-pointer",
                "content": "```\\nclass Solution(object):\\n    def isLongPressedName(self, name, typed):\\n        #to determine if name is contained in typed.(equal by reduce some duplicate letters without reduce all)\\n        #two pointer,when not match,check if j is same as last letter.\\n        i=j=0\\n        m,n=len(name),len(typed)\\n        while j<n:\\n            if i<m and name[i]==typed[j]:\\n                i+=1\\n                j+=1\\n            elif typed[j]==name[i-1]:\\n                j+=1\\n            else:\\n                return False \\n        return i==m",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isLongPressedName(self, name, typed):\\n        #to determine if name is contained in typed.(equal by reduce some duplicate letters without reduce all)\\n        #two pointer,when not match,check if j is same as last letter.\\n        i=j=0\\n        m,n=len(name),len(typed)\\n        while j<n:\\n            if i<m and name[i]==typed[j]:\\n                i+=1\\n                j+=1\\n            elif typed[j]==name[i-1]:\\n                j+=1\\n            else:\\n                return False \\n        return i==m",
                "codeTag": "Java"
            },
            {
                "id": 374722,
                "title": "c-100-time-100-space-optimized-0ms-soln",
                "content": "just take two pointers one on the name string and other typed string and count the number of characters matched \\nFinally return if your count matches the original length of name string\\n```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int p1=0,p2=0;   // p1 for name string and p2 for typed\\n        int c=0;                           // counts number of matched char\\n        while(p2<typed.length()){                 //loop until typed string gets over\\n            if(name[p1]==typed[p2]){               // if charachter matches move pointers ahead\\n                p1++;                                               //and increment the char count\\n                p2++;\\n                c++;\\n                continue;\\n            } \\n            p2++;                                           //else continue traversal\\n        }\\n        \\n        return c==name.length();                 //finally if count matches the name length\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int p1=0,p2=0;   // p1 for name string and p2 for typed\\n        int c=0;                           // counts number of matched char\\n        while(p2<typed.length()){                 //loop until typed string gets over\\n            if(name[p1]==typed[p2]){               // if charachter matches move pointers ahead\\n                p1++;                                               //and increment the char count\\n                p2++;\\n                c++;\\n                continue;\\n            } \\n            p2++;                                           //else continue traversal\\n        }\\n        \\n        return c==name.length();                 //finally if count matches the name length\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346232,
                "title": "javascript-1-2-line-solution",
                "content": "```\\nvar isLongPressedName = function(name, typed) {\\n    let i = 0; return typed.split(\"\").filter(s => s == name[i] ? ++i : false).length == name.length;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isLongPressedName = function(name, typed) {\\n    let i = 0; return typed.split(\"\").filter(s => s == name[i] ? ++i : false).length == name.length;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 309750,
                "title": "javascript-regex-based-solution-3-line",
                "content": "```\\n/**\\n * @param {string} name\\n * @param {string} typed\\n * @return {boolean}\\n */\\nvar isLongPressedName = function(name, typed) {\\n    if(name==typed)\\n        return true;\\n    let reg=name.split(\\'\\').join(\\'+\\');\\n    return (new RegExp(reg)).test(typed);    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} name\\n * @param {string} typed\\n * @return {boolean}\\n */\\nvar isLongPressedName = function(name, typed) {\\n    if(name==typed)\\n        return true;\\n    let reg=name.split(\\'\\').join(\\'+\\');\\n    return (new RegExp(reg)).test(typed);    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 304666,
                "title": "java-one-pass-solution",
                "content": "Java one pass solution\\n\\n```\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(typed.length() < name.length()) return false;\\n        char[] n = name.toCharArray();\\n        char[] t = typed.toCharArray();\\n        int j = 0;\\n        for (int i = 0; i < t.length; i++) {\\n            if(j < n.length && t[i] == n[j]) {\\n                j++; \\n            } else if( j == 0 || n[j-1] != t[i]) {\\n                return false;\\n            }\\n        }\\n        return j == n.length;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(typed.length() < name.length()) return false;\\n        char[] n = name.toCharArray();\\n        char[] t = typed.toCharArray();\\n        int j = 0;\\n        for (int i = 0; i < t.length; i++) {\\n            if(j < n.length && t[i] == n[j]) {\\n                j++; \\n            } else if( j == 0 || n[j-1] != t[i]) {\\n                return false;\\n            }\\n        }\\n        return j == n.length;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270602,
                "title": "easy-python-20-ms",
                "content": "```\\n    def isLongPressedName(self, name, typed):\\n        \"\"\"\\n        :type name: str\\n        :type typed: str\\n        :rtype: bool\\n        \"\"\"\\n        if name==typed:return True\\n        j = 0\\n        for x in typed:\\n            if j< len(name) and name[j]==x:\\n                j += 1\\n        return len(name) == j \\n```",
                "solutionTags": [],
                "code": "```\\n    def isLongPressedName(self, name, typed):\\n        \"\"\"\\n        :type name: str\\n        :type typed: str\\n        :rtype: bool\\n        \"\"\"\\n        if name==typed:return True\\n        j = 0\\n        for x in typed:\\n            if j< len(name) and name[j]==x:\\n                j += 1\\n        return len(name) == j \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 256052,
                "title": "easy-understand-javascript-solution",
                "content": "```\\nvar isLongPressedName = function(name, typed) {\\n   typed = typed.split(\\'\\');\\n    for(var i=0;i<typed.length;i++){\\n        if(typed[i]===name[i]){\\n            continue\\n        }\\n        if(typed[i-1]&&typed[i]===typed[i-1]){\\n            typed.splice(i,1);\\n            i--;\\n        }\\n    }\\n    return name === typed.join(\\'\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isLongPressedName = function(name, typed) {\\n   typed = typed.split(\\'\\');\\n    for(var i=0;i<typed.length;i++){\\n        if(typed[i]===name[i]){\\n            continue\\n        }\\n        if(typed[i-1]&&typed[i]===typed[i-1]){\\n            typed.splice(i,1);\\n            i--;\\n        }\\n    }\\n    return name === typed.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 194718,
                "title": "5-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int a = 0, b = 0, n = name.size(), m = typed.size();\\n        while (a < n && b < m) {\\n            if (name[a++] != typed[b++]) return false;\\n            while (b > 0 && name[a] != typed[b] && typed[b] == typed[b - 1]) ++b;\\n        }\\n        return a == n && b == m;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int a = 0, b = 0, n = name.size(), m = typed.size();\\n        while (a < n && b < m) {\\n            if (name[a++] != typed[b++]) return false;\\n            while (b > 0 && name[a] != typed[b] && typed[b] == typed[b - 1]) ++b;\\n        }\\n        return a == n && b == m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186023,
                "title": "100-python",
                "content": "        i,j=0,0\\n        L1,L2=len(name),len(typed)\\n        while i<L1 and j<L2:\\n            if name[i]==typed[j]:\\n                i,j=i+1,j+1\\n            elif typed[j]==typed[j-1]:\\n                j=j+1\\n            else:\\n                return False\\n        return True if i==L1 else False",
                "solutionTags": [],
                "code": "        i,j=0,0\\n        L1,L2=len(name),len(typed)\\n        while i<L1 and j<L2:\\n            if name[i]==typed[j]:\\n                i,j=i+1,j+1\\n            elif typed[j]==typed[j-1]:\\n                j=j+1\\n            else:\\n                return False\\n        return True if i==L1 else False",
                "codeTag": "Unknown"
            },
            {
                "id": 183893,
                "title": "python-solution-with-groupby",
                "content": "```\ndef isLongPressedName(self, name, typed):\n    from itertools import groupby\n    name_groups = [(ch, len(list(g))) for ch, g in groupby(name)]\n    typed_groups = [(ch, len(list(g))) for ch, g in groupby(typed)]\n    if len(typed_groups) < len(name_groups):\n        return False\n    for i in range(len(name_groups)):\n        if typed_groups[i][0] != name_groups[i][0] or \\\n            typed_groups[i][1] < name_groups[i][1]:\n            return False\n    return True\n```",
                "solutionTags": [],
                "code": "```\ndef isLongPressedName(self, name, typed):\n    from itertools import groupby\n    name_groups = [(ch, len(list(g))) for ch, g in groupby(name)]\n    typed_groups = [(ch, len(list(g))) for ch, g in groupby(typed)]\n    if len(typed_groups) < len(name_groups):\n        return False\n    for i in range(len(name_groups)):\n        if typed_groups[i][0] != name_groups[i][0] or \\\n            typed_groups[i][1] < name_groups[i][1]:\n            return False\n    return True\n```",
                "codeTag": "Python3"
            },
            {
                "id": 183845,
                "title": "easiest-o-n-time-and-o-1-space-c",
                "content": "    bool isLongPressedName(string name, string typed) {\n        int len1 = name.length(), len2 = typed.length();\n        int i = 0, j = 0;\n        while(i < len1 && j < len2) {\n            if(name[i] == typed[j]) {\n                i++;j++;\n            } else {\n                if(j == 0 || typed[j] != typed[j -1])\n                    return false;\n                j++;\n            }\n        }\n        return i == len1;\n    }",
                "solutionTags": [],
                "code": "    bool isLongPressedName(string name, string typed) {\n        int len1 = name.length(), len2 = typed.length();\n        int i = 0, j = 0;\n        while(i < len1 && j < len2) {\n            if(name[i] == typed[j]) {\n                i++;j++;\n            } else {\n                if(j == 0 || typed[j] != typed[j -1])\n                    return false;\n                j++;\n            }\n        }\n        return i == len1;\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3947927,
                "title": "solution-in-dart-with-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n bool isLongPressedName(String name, String typed) {\\n  if (typed.length < name.length) {\\n    return false;\\n  }\\n  \\n  int i = 0;\\n  int j = 0;\\n  \\n  while (j < typed.length) {\\n    if (i < name.length && (name[i] == typed[j])) {\\n      i++;\\n      j++;\\n    } else if (j > 0 && typed[j] == typed[j - 1]) {\\n      j++;\\n    } else {\\n      return false;\\n    }\\n  }\\n  \\n  return i == name.length;\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n bool isLongPressedName(String name, String typed) {\\n  if (typed.length < name.length) {\\n    return false;\\n  }\\n  \\n  int i = 0;\\n  int j = 0;\\n  \\n  while (j < typed.length) {\\n    if (i < name.length && (name[i] == typed[j])) {\\n      i++;\\n      j++;\\n    } else if (j > 0 && typed[j] == typed[j - 1]) {\\n      j++;\\n    } else {\\n      return false;\\n    }\\n  }\\n  \\n  return i == name.length;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909464,
                "title": "java-solution-long-pressed-name-two-pointer-approach",
                "content": "**Please Upvote!!**\\n\\n# Approach\\nThis solution uses two pointers (i for the \\'typed\\' string and j for the \\'name\\' string) to compare characters and handle the long-press scenario. It iterates through the \\'typed\\' string, ensuring that each character in \\'name\\' matches the corresponding character in \\'typed\\' and handles long-press cases.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int j = 0;  // Initialize a pointer for the \\'name\\' string\\n        if (typed.length() < name.length()) return false;  // If \\'typed\\' is shorter, it can\\'t match \\'name\\'\\n        for (int i = 0; i < typed.length(); i++) {\\n            // If the current characters in \\'name\\' and \\'typed\\' match, move the \\'name\\' pointer\\n            if (j < name.length() && name.charAt(j) == typed.charAt(i)) {\\n                j++;\\n            } else if (i > 0 && typed.charAt(i) == typed.charAt(i - 1)) {\\n                // If the current character in \\'typed\\' is the same as the previous one, it\\'s allowed (long press)\\n                continue;\\n            } else {\\n                // If none of the conditions match, it means the characters don\\'t match\\n                return false;\\n            }\\n        }\\n        // If we reached the end of the \\'name\\' string, it means all characters were found in \\'typed\\'\\n        return j == name.length();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int j = 0;  // Initialize a pointer for the \\'name\\' string\\n        if (typed.length() < name.length()) return false;  // If \\'typed\\' is shorter, it can\\'t match \\'name\\'\\n        for (int i = 0; i < typed.length(); i++) {\\n            // If the current characters in \\'name\\' and \\'typed\\' match, move the \\'name\\' pointer\\n            if (j < name.length() && name.charAt(j) == typed.charAt(i)) {\\n                j++;\\n            } else if (i > 0 && typed.charAt(i) == typed.charAt(i - 1)) {\\n                // If the current character in \\'typed\\' is the same as the previous one, it\\'s allowed (long press)\\n                continue;\\n            } else {\\n                // If none of the conditions match, it means the characters don\\'t match\\n                return false;\\n            }\\n        }\\n        // If we reached the end of the \\'name\\' string, it means all characters were found in \\'typed\\'\\n        return j == name.length();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878610,
                "title": "java-0-ms-100-faster-time-complexity-o-n-space-complexity-o-1-easy-approach",
                "content": "# Intuition\\nHere we have to Compare the both string and see can we create the typed word by pressing the key long. \\n\\n# Approach\\nWe will use the two variable to store the index for each string and then we compare values at that index and based on that we will move the indexs forward. if character at both index match then move both pointer forward otherwise check it matchs prev value of the named String is equals to value at the index in typed String if yes then move only typed pointer and if not then return false. \\nAlso we have to check that both of pointer of string reach the end of the string. \\n\\n# Complexity\\n- Time complexity:\\nAs only one traverse required. Time Complexity : O(N)\\n\\n- Space complexity:\\nAs only constant Space for variables required. Space Complexity : O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int len1 = name.length();\\n        int len2 = typed.length();\\n        int idx1 = 0;\\n        int idx2 = 0;\\n        char prev = name.charAt(0);\\n        char c2 = typed.charAt(0);\\n        char c1 = prev;\\n        while(idx1 < len1 && idx2 < len2 ){\\n            c1 = name.charAt(idx1);\\n            c2 = typed.charAt(idx2);\\n            if(c1 == c2){\\n                idx1++;\\n                idx2++;\\n                prev = c1;\\n            }\\n            else if(c2 == prev){\\n                idx2++;\\n            }\\n            else{\\n                return false;\\n            }   \\n        } \\n        while(idx2<len2){\\n            c2 = typed.charAt(idx2);\\n            if(c2 != c1){\\n                return false;\\n            }\\n            idx2++;\\n        }\\n        return idx1==len1 && idx2==len2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int len1 = name.length();\\n        int len2 = typed.length();\\n        int idx1 = 0;\\n        int idx2 = 0;\\n        char prev = name.charAt(0);\\n        char c2 = typed.charAt(0);\\n        char c1 = prev;\\n        while(idx1 < len1 && idx2 < len2 ){\\n            c1 = name.charAt(idx1);\\n            c2 = typed.charAt(idx2);\\n            if(c1 == c2){\\n                idx1++;\\n                idx2++;\\n                prev = c1;\\n            }\\n            else if(c2 == prev){\\n                idx2++;\\n            }\\n            else{\\n                return false;\\n            }   \\n        } \\n        while(idx2<len2){\\n            c2 = typed.charAt(idx2);\\n            if(c2 != c1){\\n                return false;\\n            }\\n            idx2++;\\n        }\\n        return idx1==len1 && idx2==len2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872920,
                "title": "python-compress-strings-then-compare",
                "content": "First I wrote a solution based on various conditions and it produced a good result. But I didn\\'t like the way it looked. You can skip it, because the second solution is below and I like it much better.\\n# My first solution (Beats 98.86% - skip it):\\n```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        if name[-1] != typed[-1] or len(set(name)) > len(set(typed)):\\n            return False\\n        name_pointer = 0\\n        typed_pointer = 0\\n        while name_pointer <= len(name) - 1:\\n            if (typed_pointer == len(typed) - 1 and name_pointer != len(name) - 1) or name[name_pointer] != typed[typed_pointer]:\\n                return False\\n            if name_pointer != len(name) - 1 and name[name_pointer] != name[name_pointer + 1]:\\n                while typed_pointer <= len(typed) - 1 and name[name_pointer] == typed[typed_pointer]:\\n                    typed_pointer += 1\\n                name_pointer += 1\\n            elif name_pointer == len(name) - 1:\\n                if \\'\\'.join(set(typed[typed_pointer:])) == name[name_pointer]:\\n                    return True\\n                else:\\n                    return False\\n            else:\\n                typed_pointer += 1\\n                name_pointer += 1\\n```\\n# My second solution (Beats 92.68%)\\nThen I remembered the string compression problem and decided to implement a solution based on it. I wrote a function that compresses, then splits the original strings, and then compares them.\\nFor example:\\n```\\n>>>compress_split_string(\"saeed\") \\n[\\'s1\\',\\'a1\\',\\'e2\\',\\'d1\\']\\n>>>compress_split_string(\"ssaaedd\")\\n[\\'s2\\',\\'a2\\',\\'e1\\',\\'d2\\']\\n```\\n```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        if set(name) != set(typed):\\n            return False\\n        def compress_split_string(str_):\\n            char_counter = 1\\n            str_ += \\' \\'\\n            list_compress = []\\n            for idx, t_char in enumerate(str_):\\n                if idx == 0:\\n                    continue\\n                if t_char != str_[idx - 1]:\\n                    list_compress.append(str_[idx - 1] + str(char_counter))\\n                    char_counter = 1\\n                else:\\n                    char_counter += 1\\n            return list_compress\\n        name_compress = compress_split_string(name)\\n        typed_compress = compress_split_string(typed)\\n        if len(name_compress) != len(typed_compress):\\n            return False\\n        for n_num, t_num in zip(name_compress, typed_compress):\\n            if t_num < n_num:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        if name[-1] != typed[-1] or len(set(name)) > len(set(typed)):\\n            return False\\n        name_pointer = 0\\n        typed_pointer = 0\\n        while name_pointer <= len(name) - 1:\\n            if (typed_pointer == len(typed) - 1 and name_pointer != len(name) - 1) or name[name_pointer] != typed[typed_pointer]:\\n                return False\\n            if name_pointer != len(name) - 1 and name[name_pointer] != name[name_pointer + 1]:\\n                while typed_pointer <= len(typed) - 1 and name[name_pointer] == typed[typed_pointer]:\\n                    typed_pointer += 1\\n                name_pointer += 1\\n            elif name_pointer == len(name) - 1:\\n                if \\'\\'.join(set(typed[typed_pointer:])) == name[name_pointer]:\\n                    return True\\n                else:\\n                    return False\\n            else:\\n                typed_pointer += 1\\n                name_pointer += 1\\n```\n```\\n>>>compress_split_string(\"saeed\") \\n[\\'s1\\',\\'a1\\',\\'e2\\',\\'d1\\']\\n>>>compress_split_string(\"ssaaedd\")\\n[\\'s2\\',\\'a2\\',\\'e1\\',\\'d2\\']\\n```\n```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        if set(name) != set(typed):\\n            return False\\n        def compress_split_string(str_):\\n            char_counter = 1\\n            str_ += \\' \\'\\n            list_compress = []\\n            for idx, t_char in enumerate(str_):\\n                if idx == 0:\\n                    continue\\n                if t_char != str_[idx - 1]:\\n                    list_compress.append(str_[idx - 1] + str(char_counter))\\n                    char_counter = 1\\n                else:\\n                    char_counter += 1\\n            return list_compress\\n        name_compress = compress_split_string(name)\\n        typed_compress = compress_split_string(typed)\\n        if len(name_compress) != len(typed_compress):\\n            return False\\n        for n_num, t_num in zip(name_compress, typed_compress):\\n            if t_num < n_num:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619680,
                "title": "100-fastest-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        if(typed.size()<name.size())\\n        return false;\\n        if(typed == name)\\n        return true;\\n        int i,j;\\n        for(i = 0,j=0; i<name.size() && j<typed.size(); )\\n        {\\n            if(name[i] == typed[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else\\n            if(j>0 && typed[j] == typed[j-1])\\n            j++;\\n            else\\n            return false;\\n        }\\n        while(j<typed.size())\\n        {\\n            if(typed[j]!=typed[j-1])\\n            return false;\\n            j++;\\n        }\\n\\n        if(i>=name.size() && j>=typed.size())\\n        return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        if(typed.size()<name.size())\\n        return false;\\n        if(typed == name)\\n        return true;\\n        int i,j;\\n        for(i = 0,j=0; i<name.size() && j<typed.size(); )\\n        {\\n            if(name[i] == typed[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else\\n            if(j>0 && typed[j] == typed[j-1])\\n            j++;\\n            else\\n            return false;\\n        }\\n        while(j<typed.size())\\n        {\\n            if(typed[j]!=typed[j-1])\\n            return false;\\n            j++;\\n        }\\n\\n        if(i>=name.size() && j>=typed.size())\\n        return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556560,
                "title": "kotlin-simple-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun isLongPressedName(name: String, typed: String): Boolean {\\n\\n        var index = 0\\n        var lastChar : Char? = null\\n        for(ch in typed){\\n            if(index< name.length && ch == name[index]) {\\n                lastChar = ch\\n                index++\\n            }else if(ch == lastChar){\\n                continue\\n            }else{\\n                return false\\n            }\\n        }\\n\\n        return index == name.length\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun isLongPressedName(name: String, typed: String): Boolean {\\n\\n        var index = 0\\n        var lastChar : Char? = null\\n        for(ch in typed){\\n            if(index< name.length && ch == name[index]) {\\n                lastChar = ch\\n                index++\\n            }else if(ch == lastChar){\\n                continue\\n            }else{\\n                return false\\n            }\\n        }\\n\\n        return index == name.length\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005558,
                "title": "925-java-2-approach",
                "content": "# Complexity\\n- Runtime : 0 ms\\n- Beats : 100%\\n- Memory : 40.5 MB\\n- Beats : 69.85%\\n# Code 1\\n```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(name.equals(typed)) return true;\\n        int i = 0;\\n        char n = name.charAt(0) , prev = name.charAt(0);\\n        for(char c : typed.toCharArray()){\\n            if(n == c){\\n                if(i < name.length()-1) {\\n                    i++;\\n                    prev = n;\\n                    n = name.charAt(i);\\n                }else prev = n;\\n            }\\n            else if(c == prev);\\n            else return false;\\n        }\\n        if(i < name.length()-1 || n != prev ) return false;\\n        return true;\\n    }\\n}\\n```\\n# Complexity\\n- Runtime : 1 ms\\n- Beats : 82.59%\\n- Memory : 42.1 MB\\n- Beats : 36.72%\\n# Code 2\\n```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i = 0;\\n        char n = name.charAt(0) , prev = name.charAt(0);\\n        for(char c : typed.toCharArray()){\\n            if(n == c){\\n                if(i < name.length()-1) {\\n                    i++;\\n                    prev = n;\\n                    n = name.charAt(i);\\n                }else prev = n;\\n            }\\n            else if(c == prev);\\n            else return false;\\n        }\\n        if(i < name.length()-1 || n != prev ) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(name.equals(typed)) return true;\\n        int i = 0;\\n        char n = name.charAt(0) , prev = name.charAt(0);\\n        for(char c : typed.toCharArray()){\\n            if(n == c){\\n                if(i < name.length()-1) {\\n                    i++;\\n                    prev = n;\\n                    n = name.charAt(i);\\n                }else prev = n;\\n            }\\n            else if(c == prev);\\n            else return false;\\n        }\\n        if(i < name.length()-1 || n != prev ) return false;\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i = 0;\\n        char n = name.charAt(0) , prev = name.charAt(0);\\n        for(char c : typed.toCharArray()){\\n            if(n == c){\\n                if(i < name.length()-1) {\\n                    i++;\\n                    prev = n;\\n                    n = name.charAt(i);\\n                }else prev = n;\\n            }\\n            else if(c == prev);\\n            else return false;\\n        }\\n        if(i < name.length()-1 || n != prev ) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830105,
                "title": "python-solution-two-pointers-approach-explained-100",
                "content": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool: \\n        \\n        n=len(name) #length of name\\n        m=len(typed) #length of typed \\n\\t\\t\\n        #if name is shorter than typed means keys arent enough pressed in typed to become equal to name\\n        if m<n: \\n            return False\\n        \\n        #if first elements are differnt means that first element in name is never be \\n        #pressed at first position of typed\\n        if name[0]!=typed[0]:  \\n            return False \\n        \\n        #remaining code \\n        \\n        i=0 #index for name\\n        j=0 #index for typed\\n        \\n        #need to check if all chracters of name are present in typed\\n        #that\\'s why only running loop till the name\\'s length\\n        while i<n:  \\n            if name[i]==typed[j]: #if characters found same\\n                i+=1 #move forward in name\\n                j+=1 #and move forward in typed\\n                \\n            else: #if characters not found same at those positions\\n                \\n                #check if name\\'s previous element is long pressing in typed (i.e, \\n                #current element of typed equal to previous name\\'s element)\\n                if typed[j]==name[i-1]: \\n                    j+=1 #if above condition goes true, now move further in typed\\n                \\n                #otherwise it means the current charcter of typed is different \\n                #or not available in whole name string\\n                else: \\n                    return False\\n                \\n            #if on moving the indeces of j , somehow reached to typed\\'s end but names indeces are\\n            # still not fully traversed means name string is not present in typed in any condition\\n            if j==m and i!=n:  \\n                return False\\n            \\n        #AFTER WHILE LOOP CHECK-\\n            \\n        #if name string completely traversed but typed isnt means we need to check remaining characters of typed\\n        if j!=m: \\n            while j<m: #traversing remainings\\n                \\n                #if last character of name is long pressed then all the remainings of typed \\n                #would be equal to names last character, but in case they arent equal (differnt \\n                # charcters found in typed) then return false\\n                if typed[j]!=name[n-1]:   \\n                    return False\\n                \\n                j+=1 #moving indeces of typed\\n                \\n        return True #if nothing goes wrong , return true\\n            \\n        \\n```\\n**PLEASE UPVOTE IF YOU FOUND THE SOLUTION HELPFUL**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool: \\n        \\n        n=len(name) #length of name\\n        m=len(typed) #length of typed \\n\\t\\t\\n        #if name is shorter than typed means keys arent enough pressed in typed to become equal to name\\n        if m<n: \\n            return False\\n        \\n        #if first elements are differnt means that first element in name is never be \\n        #pressed at first position of typed\\n        if name[0]!=typed[0]:  \\n            return False \\n        \\n        #remaining code \\n        \\n        i=0 #index for name\\n        j=0 #index for typed\\n        \\n        #need to check if all chracters of name are present in typed\\n        #that\\'s why only running loop till the name\\'s length\\n        while i<n:  \\n            if name[i]==typed[j]: #if characters found same\\n                i+=1 #move forward in name\\n                j+=1 #and move forward in typed\\n                \\n            else: #if characters not found same at those positions\\n                \\n                #check if name\\'s previous element is long pressing in typed (i.e, \\n                #current element of typed equal to previous name\\'s element)\\n                if typed[j]==name[i-1]: \\n                    j+=1 #if above condition goes true, now move further in typed\\n                \\n                #otherwise it means the current charcter of typed is different \\n                #or not available in whole name string\\n                else: \\n                    return False\\n                \\n            #if on moving the indeces of j , somehow reached to typed\\'s end but names indeces are\\n            # still not fully traversed means name string is not present in typed in any condition\\n            if j==m and i!=n:  \\n                return False\\n            \\n        #AFTER WHILE LOOP CHECK-\\n            \\n        #if name string completely traversed but typed isnt means we need to check remaining characters of typed\\n        if j!=m: \\n            while j<m: #traversing remainings\\n                \\n                #if last character of name is long pressed then all the remainings of typed \\n                #would be equal to names last character, but in case they arent equal (differnt \\n                # charcters found in typed) then return false\\n                if typed[j]!=name[n-1]:   \\n                    return False\\n                \\n                j+=1 #moving indeces of typed\\n                \\n        return True #if nothing goes wrong , return true\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828740,
                "title": "c-with-explanation-100-runtime-97-memory",
                "content": "# General idea\\nIterate through *typed* and compare with n. If the two compared characters are not equal, check if it is a mistype.\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int n=0;\\n        for (int t=0;t<typed.size();t++) // Iterate through typed\\n        {\\n            if (name[n]==typed[t]) {n++;continue;} // If the typed character equals the correct name character, we can continue, incrementing n to look at the next character in name.\\n            if (t==0) {return false;} // Special case: If the first typed character is incorrect, return false.\\n            if (typed[t] == typed[t-1]) {continue;} // If the typed character is a possible mistype (equal to the previous typed character), we can continue.\\n            return false; // We find a discrepancy that is not a possible mistype.\\n        }\\n        return n==name.size(); // Check that all characters of the name and no more have been typed.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int n=0;\\n        for (int t=0;t<typed.size();t++) // Iterate through typed\\n        {\\n            if (name[n]==typed[t]) {n++;continue;} // If the typed character equals the correct name character, we can continue, incrementing n to look at the next character in name.\\n            if (t==0) {return false;} // Special case: If the first typed character is incorrect, return false.\\n            if (typed[t] == typed[t-1]) {continue;} // If the typed character is a possible mistype (equal to the previous typed character), we can continue.\\n            return false; // We find a discrepancy that is not a possible mistype.\\n        }\\n        return n==name.size(); // Check that all characters of the name and no more have been typed.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2582561,
                "title": "js-simple-solution-with-hashmap",
                "content": "```\\nvar isLongPressedName = function(name, typed) {\\n    if (typed.length < name.length || typed[typed.length - 1] !== name[name.length - 1]) return false;\\n    const hashmap = new Map();\\n    let cursorName = 0;\\n    \\n    for (let i = 0; i < name.length; i++) {\\n        hashmap.set(i, name[i]);\\n    }\\n    for (let i = 0; i < typed.length; i++) {\\n        const character = typed[i];\\n        if (character === hashmap.get(cursorName)) {\\n            cursorName++;\\n        } else if (character !== hashmap.get(cursorName - 1)) {\\n            return false;\\n        }\\n    }\\n    \\n    if (cursorName < name.length - 1) return false;\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isLongPressedName = function(name, typed) {\\n    if (typed.length < name.length || typed[typed.length - 1] !== name[name.length - 1]) return false;\\n    const hashmap = new Map();\\n    let cursorName = 0;\\n    \\n    for (let i = 0; i < name.length; i++) {\\n        hashmap.set(i, name[i]);\\n    }\\n    for (let i = 0; i < typed.length; i++) {\\n        const character = typed[i];\\n        if (character === hashmap.get(cursorName)) {\\n            cursorName++;\\n        } else if (character !== hashmap.get(cursorName - 1)) {\\n            return false;\\n        }\\n    }\\n    \\n    if (cursorName < name.length - 1) return false;\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2393570,
                "title": "java-solution",
                "content": "```\\n\\n```class Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i=0,j=0;\\n        while(j<typed.length()){\\n        if(i<name.length() && name.charAt(i)==typed.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        else if(j>0 && typed.charAt(j)==typed.charAt(j-1))\\n            j++;\\n        else\\n            return false;\\n           // System.out.println(i+\" \"+j);\\n        }\\n        return i==name.length();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2330519,
                "title": "runtime-1-ms-faster-than-91-83-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i = 0;\\n        int j = 0;\\n        \\n        while(j < typed.length()){\\n            if(i < name.length() && name.charAt(i) == typed.charAt(j)){\\n                i++;\\n                j++;\\n            }else if(j != 0 && typed.charAt(j) == name.charAt(i-1)){\\n                j++;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return i == name.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i = 0;\\n        int j = 0;\\n        \\n        while(j < typed.length()){\\n            if(i < name.length() && name.charAt(i) == typed.charAt(j)){\\n                i++;\\n                j++;\\n            }else if(j != 0 && typed.charAt(j) == name.charAt(i-1)){\\n                j++;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return i == name.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293896,
                "title": "python-o-n-using-simple-string-operators",
                "content": "Use string strip option with groupby function, simple O(N) method\\n\\n```class Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        for char,group in itertools.groupby(name):\\n            c = str(char) * len(list(group))\\n            if not typed.startswith(c):\\n                return False\\n            typed = typed.lstrip(c)\\n        return typed == \"\"",
                "solutionTags": [],
                "code": "Use string strip option with groupby function, simple O(N) method\\n\\n```class Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        for char,group in itertools.groupby(name):\\n            c = str(char) * len(list(group))\\n            if not typed.startswith(c):\\n                return False\\n            typed = typed.lstrip(c)\\n        return typed == \"\"",
                "codeTag": "Java"
            },
            {
                "id": 2249249,
                "title": "python-easy-and-fast-o-n",
                "content": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        i = 0\\n        for c in typed:\\n            if i < len(name) and name[i] == c: i += 1\\n            else:\\n                if i == 0 or name[i-1] != c: return False\\n        return i == len(name)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        i = 0\\n        for c in typed:\\n            if i < len(name) and name[i] == c: i += 1\\n            else:\\n                if i == 0 or name[i-1] != c: return False\\n        return i == len(name)",
                "codeTag": "Java"
            },
            {
                "id": 2238236,
                "title": "two-pointer-solution",
                "content": "**Two pointer solution readable code self explanatory comments**\\n```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string a,string b){\\n    int i = 0 , j = 0;\\n    int n = a.size() , m = b.size();\\n    \\n    //if typed is smaller than original\\n    if(m < n) return false;\\n        \\n    while(i < n and j < m){\\n        if(a[i] == b[j]){\\n            i++,j++;\\n        }\\n        else{\\n            if(j == 0) return false;\\n            if(j > 0 && b[j - 1] != b[j]) return false;\\n            else if(b[j - 1] == b[j]){\\n                j++;\\n            }\\n        }\\n    }\\n        \\n    //if original string has not completed traversal\\n    if(i != n) return false;\\n    \\n    //if i has ended but j has more characters check if there are any character that is different\\n    while(j < m){\\n        if(j > 0 and b[j] != b[j - 1]) return false;\\n        j++;\\n    }\\n    return true;\\n}\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string a,string b){\\n    int i = 0 , j = 0;\\n    int n = a.size() , m = b.size();\\n    \\n    //if typed is smaller than original\\n    if(m < n) return false;\\n        \\n    while(i < n and j < m){\\n        if(a[i] == b[j]){\\n            i++,j++;\\n        }\\n        else{\\n            if(j == 0) return false;\\n            if(j > 0 && b[j - 1] != b[j]) return false;\\n            else if(b[j - 1] == b[j]){\\n                j++;\\n            }\\n        }\\n    }\\n        \\n    //if original string has not completed traversal\\n    if(i != n) return false;\\n    \\n    //if i has ended but j has more characters check if there are any character that is different\\n    while(j < m){\\n        if(j > 0 and b[j] != b[j - 1]) return false;\\n        j++;\\n    }\\n    return true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191234,
                "title": "java-o-n-solution-1ms-runtime-beats-91-intuition",
                "content": "**Approach:**\\nThe approach is to count the number of similar characters for each string. \\n\\n1. Taken a character **typed** should have more or equal count than **name**.\\n2. Total length of typed string should be more than name string.\\n\\n```\\npublic boolean isLongPressedName(String name, String typed) {\\n\\tif (name.charAt(0) != typed.charAt(0) || name.length() > typed.length() ) return false;\\n\\tint c1 = 1, c2 = 1, i = 1, j = 1;\\n\\twhile ( i < name.length() && j < typed.length() ) {\\n\\t\\tboolean b = false;\\n\\t\\tif ( name.charAt(i) == name.charAt(i - 1) ) {\\n\\t\\t\\tc1++;\\n\\t\\t\\ti++;\\n\\t\\t\\tb = true;\\n\\t\\t}\\n\\t\\tif ( typed.charAt(j) == typed.charAt(j - 1) ) {\\n\\t\\t\\tc2++;\\n\\t\\t\\tj++;\\n\\t\\t\\tb = true;\\n\\t\\t}\\n\\t\\tif ( !b ) {\\n\\t\\t\\tif ( name.charAt(i) != typed.charAt(j) || c2 < c1 ) return false;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t\\tc1 = c2 = 1;\\n\\t\\t}\\n\\t}\\n\\tif ( i < name.length() ) return false;\\n\\twhile ( j < typed.length() ) {\\n\\t\\tif (typed.charAt(j) != typed.charAt(j - 1)) return false;\\n\\t\\tj++;\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\npublic boolean isLongPressedName(String name, String typed) {\\n\\tif (name.charAt(0) != typed.charAt(0) || name.length() > typed.length() ) return false;\\n\\tint c1 = 1, c2 = 1, i = 1, j = 1;\\n\\twhile ( i < name.length() && j < typed.length() ) {\\n\\t\\tboolean b = false;\\n\\t\\tif ( name.charAt(i) == name.charAt(i - 1) ) {\\n\\t\\t\\tc1++;\\n\\t\\t\\ti++;\\n\\t\\t\\tb = true;\\n\\t\\t}\\n\\t\\tif ( typed.charAt(j) == typed.charAt(j - 1) ) {\\n\\t\\t\\tc2++;\\n\\t\\t\\tj++;\\n\\t\\t\\tb = true;\\n\\t\\t}\\n\\t\\tif ( !b ) {\\n\\t\\t\\tif ( name.charAt(i) != typed.charAt(j) || c2 < c1 ) return false;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t\\tc1 = c2 = 1;\\n\\t\\t}\\n\\t}\\n\\tif ( i < name.length() ) return false;\\n\\twhile ( j < typed.length() ) {\\n\\t\\tif (typed.charAt(j) != typed.charAt(j - 1)) return false;\\n\\t\\tj++;\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2158084,
                "title": "c-two-pointers",
                "content": "class Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        \\n        int i = 0, j = 0, n1 = name.size(), n2 = typed.size();\\n        \\n        while(i < n1 && j < n2)\\n        {\\n            if(name[i] != typed[j])\\n                return false;\\n            \\n            int cnt1 = 1, cnt2 = 1;\\n            i++, j++;\\n            while(i < n1 && name[i] == name[i - 1])\\n                cnt1++, i++;\\n            \\n            while(j < n2 && typed[j] == typed[j - 1])\\n                cnt2++, j++;\\n            \\n            if(cnt2 < cnt1)\\n                return false;\\n        }\\n        \\n        return i == n1 && j == n2;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        \\n        int i = 0, j = 0, n1 = name.size(), n2 = typed.size();\\n        \\n        while(i < n1 && j < n2)\\n        {\\n            if(name[i] != typed[j])\\n                return false;\\n            \\n            int cnt1 = 1, cnt2 = 1;\\n            i++, j++;\\n            while(i < n1 && name[i] == name[i - 1])\\n                cnt1++, i++;\\n            \\n            while(j < n2 && typed[j] == typed[j - 1])\\n                cnt2++, j++;\\n            \\n            if(cnt2 < cnt1)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2099093,
                "title": "go-two-pointer",
                "content": "Runtime:\\xA00 ms, faster than\\xA0100.00%\\xA0of\\xA0Go\\xA0online submissions for\\xA0Long Pressed Name.\\nMemory Usage:\\xA01.9 MB, less than\\xA068.57%\\xA0of\\xA0Go\\xA0online submissions for\\xA0Long Pressed Name.\\n```\\nfunc isLongPressedName(name string, typed string) bool {\\n    if len(name) > len(typed) {\\n        return false\\n    }\\n    nameChars := []byte(name)\\n    typedChars := []byte(typed)\\n    \\n    i, j := 0, 0\\n    \\n    for j < len(typedChars) && i < len(nameChars) {\\n        if nameChars[i] == typedChars[j] {\\n            i++\\n            j++\\n        } else if isLongPressed(typedChars, j) {\\n            j++\\n        } else {\\n            return false\\n        }\\n    }\\n    \\n    // increment j until longpressed chars found\\n    for j < len(typedChars) {\\n        if isLongPressed(typedChars, j) {\\n            j++\\n        } else {\\n            return false\\n        }\\n    }\\n    \\n    return i == len(name) && j == len(typed)\\n\\n}\\n\\nfunc isLongPressed(typed []byte, i int) bool {\\n    return i > 0 && typed[i] == typed[i - 1]\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isLongPressedName(name string, typed string) bool {\\n    if len(name) > len(typed) {\\n        return false\\n    }\\n    nameChars := []byte(name)\\n    typedChars := []byte(typed)\\n    \\n    i, j := 0, 0\\n    \\n    for j < len(typedChars) && i < len(nameChars) {\\n        if nameChars[i] == typedChars[j] {\\n            i++\\n            j++\\n        } else if isLongPressed(typedChars, j) {\\n            j++\\n        } else {\\n            return false\\n        }\\n    }\\n    \\n    // increment j until longpressed chars found\\n    for j < len(typedChars) {\\n        if isLongPressed(typedChars, j) {\\n            j++\\n        } else {\\n            return false\\n        }\\n    }\\n    \\n    return i == len(name) && j == len(typed)\\n\\n}\\n\\nfunc isLongPressed(typed []byte, i int) bool {\\n    return i > 0 && typed[i] == typed[i - 1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2093768,
                "title": "easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int i=0, j=0;\\n        int n=name.length(), t = typed.length();\\n        \\n        if(name[0]!=typed[0]) return false;\\n        \\n        while(i<n || j<t){\\n            if(name[i] == typed[j]){\\n                i++,j++;\\n            }\\n            else{\\n                if(typed[j] == typed[j-1]){ //check for repeated characters\\n                    j++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int i=0, j=0;\\n        int n=name.length(), t = typed.length();\\n        \\n        if(name[0]!=typed[0]) return false;\\n        \\n        while(i<n || j<t){\\n            if(name[i] == typed[j]){\\n                i++,j++;\\n            }\\n            else{\\n                if(typed[j] == typed[j-1]){ //check for repeated characters\\n                    j++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066375,
                "title": "java-two-pointer",
                "content": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i=1;\\n        int n=name.length(), m=typed.length();\\n        if(name.charAt(0)!=typed.charAt(0)) return false; \\n        for(int j=1;j<m;j++){\\n            if(i<n && name.charAt(i)==typed.charAt(j)) i++;\\n            else if(name.charAt(i-1)!=typed.charAt(j)) return false;\\n        }\\n        return i==n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i=1;\\n        int n=name.length(), m=typed.length();\\n        if(name.charAt(0)!=typed.charAt(0)) return false; \\n        for(int j=1;j<m;j++){\\n            if(i<n && name.charAt(i)==typed.charAt(j)) i++;\\n            else if(name.charAt(i-1)!=typed.charAt(j)) return false;\\n        }\\n        return i==n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061680,
                "title": "javascript-2-pointers",
                "content": "```\\nvar isLongPressedName = function(name, typed) {\\n    let i=0, j=0, prev=name[i];\\n    while(j<typed.length) {\\n        if(name[i] === typed[j]) {\\n            prev = name[i];\\n            i+=1;\\n            j+=1;\\n        } else if(prev === typed[j]) {\\n            j+=1;\\n        } else {\\n            return false;\\n        }\\n    }\\n    return i === name.length;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isLongPressedName = function(name, typed) {\\n    let i=0, j=0, prev=name[i];\\n    while(j<typed.length) {\\n        if(name[i] === typed[j]) {\\n            prev = name[i];\\n            i+=1;\\n            j+=1;\\n        } else if(prev === typed[j]) {\\n            j+=1;\\n        } else {\\n            return false;\\n        }\\n    }\\n    return i === name.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2031497,
                "title": "java-easy-understand",
                "content": "class Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n\\t\\n\\t\\n\\t\\n        if(name.length()>typed.length()){\\n            return false;\\n        }\\n        int i=0;\\n        int j=0;\\n        while(name.length()>i&&typed.length()>j){\\n            if(name.charAt(i)==typed.charAt(j)){\\n                i++;\\n                j++;\\n            }else if(i>0&&name.charAt(i-1)==typed.charAt(j)){\\n                j++;\\n            }else{\\n                return false;\\n            }\\n            \\n        }\\n        //if j is remainig\\n        while(j<typed.length()){\\n            if(name.charAt(name.length()-1)!=typed.charAt(j)){\\n                return false;\\n            }\\n            j++;\\n        }\\n        \\n        //if i is remaining\\n        if(i<name.length()){\\n            return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n\\t\\n\\t\\n\\t\\n        if(name.length()>typed.length()){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2020502,
                "title": "simplest-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(typed.length() < name.length()) return false;\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        while(i< name.length() && j < typed.length()){\\n            if(name.charAt(i) == typed.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            else if(i > 0 && name.charAt(i-1) == typed.charAt(j)){\\n                j++;\\n            }\\n            else {\\n                return false;\\n            }\\n            \\n        }\\n        \\n        while(j <typed.length()){\\n            if(name.charAt(i-1) != typed.charAt(j)) return false;\\n            j++;\\n        }\\n        return i<name.length() ?false : true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(typed.length() < name.length()) return false;\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        while(i< name.length() && j < typed.length()){\\n            if(name.charAt(i) == typed.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            else if(i > 0 && name.charAt(i-1) == typed.charAt(j)){\\n                j++;\\n            }\\n            else {\\n                return false;\\n            }\\n            \\n        }\\n        \\n        while(j <typed.length()){\\n            if(name.charAt(i-1) != typed.charAt(j)) return false;\\n            j++;\\n        }\\n        return i<name.length() ?false : true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993716,
                "title": "easy-java-100-faster-basic",
                "content": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n         int i = 0, j = 0;\\n         int n = name.length(), m = typed.length();\\n         while(i<n && j<m){\\n             if(name.charAt(i) == typed.charAt(j))\\n             {\\n                 i++; \\n                 j++;\\n             }\\n             else{\\n                 if(i>0 && name.charAt(i-1) == typed.charAt(j)){\\n                     j++;\\n                 }\\n                 else\\n                     return false;\\n             }\\n         }\\n             \\n             if(i!=n)\\n                 return false;\\n             \\n             while(j < m){\\n                 if(name.charAt(i-1) == typed.charAt(j))\\n                     j++;\\n                 else\\n                     return false;\\n             }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n         int i = 0, j = 0;\\n         int n = name.length(), m = typed.length();\\n         while(i<n && j<m){\\n             if(name.charAt(i) == typed.charAt(j))\\n             {\\n                 i++; \\n                 j++;\\n             }\\n             else{\\n                 if(i>0 && name.charAt(i-1) == typed.charAt(j)){\\n                     j++;\\n                 }\\n                 else\\n                     return false;\\n             }\\n         }\\n             \\n             if(i!=n)\\n                 return false;\\n             \\n             while(j < m){\\n                 if(name.charAt(i-1) == typed.charAt(j))\\n                     j++;\\n                 else\\n                     return false;\\n             }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978723,
                "title": "python-two-pointers-easy-to-understand-code-with-comments",
                "content": "```\\n# Algo:\\n# 1. iterate both name and typed strings together with different index \\n# 2. keep count of current character contiguous occuring for both strings in different variables\\n# 3. check if current character in name and typed is not same then return False \\n# 4. check if name current character contiguous occuring is more than typed current character occuring then False\\n# 5. when outer loop exits then check if we have checked both strings completely then True else False\\nname_idx = 0\\ntyped_idx = 0\\n# in starting first character occurs at least once\\nname_curr_char_contiguous_freq = 1\\ntyped_curr_char_contiguous_freq = 1\\n\\nwhile name_idx < len(name) and typed_idx < len(typed):\\n\\n\\twhile name_idx + 1 < len(name) and name[name_idx] == name[name_idx+1]:\\n\\t\\tname_curr_char_contiguous_freq += 1\\n\\t\\tname_idx += 1\\n\\n\\twhile typed_idx + 1 < len(typed) and typed[typed_idx] == typed[typed_idx+1]:\\n\\t\\ttyped_curr_char_contiguous_freq += 1    \\n\\t\\ttyped_idx += 1\\n\\n\\t# check current character is not same or name current character occuring more than typed current character\\n\\tif name[name_idx] != typed[typed_idx] or name_curr_char_contiguous_freq > typed_curr_char_contiguous_freq:\\n\\t\\treturn False\\n\\n\\t# next character will occurs at least once\\n\\tname_curr_char_contiguous_freq = 1\\n\\ttyped_curr_char_contiguous_freq = 1\\n\\tname_idx += 1\\n\\ttyped_idx += 1\\nreturn True if name_idx >= len(name) and typed_idx >= len(typed) else False\\n```",
                "solutionTags": [],
                "code": "```\\n# Algo:\\n# 1. iterate both name and typed strings together with different index \\n# 2. keep count of current character contiguous occuring for both strings in different variables\\n# 3. check if current character in name and typed is not same then return False \\n# 4. check if name current character contiguous occuring is more than typed current character occuring then False\\n# 5. when outer loop exits then check if we have checked both strings completely then True else False\\nname_idx = 0\\ntyped_idx = 0\\n# in starting first character occurs at least once\\nname_curr_char_contiguous_freq = 1\\ntyped_curr_char_contiguous_freq = 1\\n\\nwhile name_idx < len(name) and typed_idx < len(typed):\\n\\n\\twhile name_idx + 1 < len(name) and name[name_idx] == name[name_idx+1]:\\n\\t\\tname_curr_char_contiguous_freq += 1\\n\\t\\tname_idx += 1\\n\\n\\twhile typed_idx + 1 < len(typed) and typed[typed_idx] == typed[typed_idx+1]:\\n\\t\\ttyped_curr_char_contiguous_freq += 1    \\n\\t\\ttyped_idx += 1\\n\\n\\t# check current character is not same or name current character occuring more than typed current character\\n\\tif name[name_idx] != typed[typed_idx] or name_curr_char_contiguous_freq > typed_curr_char_contiguous_freq:\\n\\t\\treturn False\\n\\n\\t# next character will occurs at least once\\n\\tname_curr_char_contiguous_freq = 1\\n\\ttyped_curr_char_contiguous_freq = 1\\n\\tname_idx += 1\\n\\ttyped_idx += 1\\nreturn True if name_idx >= len(name) and typed_idx >= len(typed) else False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1973603,
                "title": "c-easy-solution",
                "content": "use two pointers\\n```\\nbool isLongPressedName(string name, string typed) {\\n    //two pointers\\n    int i = 0;\\n    int j = 0;\\n\\n    while (j < typed.size()) {\\n        if (i < name.size() && name[i] == typed[j]) {\\n            i++;\\n            j++;\\n        } else if (j > 0 && typed[j] == typed[j - 1]) {\\n            j++;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    return i == name.size();\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nbool isLongPressedName(string name, string typed) {\\n    //two pointers\\n    int i = 0;\\n    int j = 0;\\n\\n    while (j < typed.size()) {\\n        if (i < name.size() && name[i] == typed[j]) {\\n            i++;\\n            j++;\\n        } else if (j > 0 && typed[j] == typed[j - 1]) {\\n            j++;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    return i == name.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1930189,
                "title": "simple-handle-4-cases-java-solution",
                "content": "class Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n       \\n\\t   //case - 1\\n\\t   //eg.name = abc & typed = ab\\n        if(name.length() > typed.length())  \\n            return false;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        //case - 2\\n        //eg. name = alex & saeed \\n        //eg. typed = aaleex & ssaaedd\\n        //This below case handle above eg.\\n        while(i < name.length() && j < typed.length()){ \\n            \\n            if(name.charAt(i) == typed.charAt(j)){\\n                i++;\\n                j++;\\n            } else if(i > 0 && name.charAt(i-1) == typed.charAt(j)){\\n                j++;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        //case - 3\\n        //eg. name = aabbc  && aabbc\\n        //eg. typed = aabbcc && aabbcd\\n        //This below case handle above eg.\\n        while(j < typed.length()){\\n            if(name.charAt(i-1) != typed.charAt(j))  return false;\\n            j++;\\n        }\\n        \\n        //case - 4\\n        //eg. name = aabbcd\\n        //eg. typed = aabbb\\n        //This below case handle above eg.\\n        if(i < name.length())\\n            return false;\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n       \\n\\t   //case - 1\\n\\t   //eg.name = abc & typed = ab\\n        if(name.length() > typed.length())  \\n            return false;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        //case - 2\\n        //eg. name = alex & saeed \\n        //eg. typed = aaleex & ssaaedd\\n        //This below case handle above eg.\\n        while(i < name.length() && j < typed.length()){ \\n            \\n            if(name.charAt(i) == typed.charAt(j)){\\n                i++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1820479,
                "title": "easy-c-solution-linear",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int curr=0;\\n        for(int i=0;i<typed.size();i++){\\n            if(typed[i]==name[curr]){\\n                curr++;\\n            }else{\\n                if(i>0){\\n                    if(typed[i]!=typed[i-1]){\\n                        return false;\\n                    }\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return curr == name.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int curr=0;\\n        for(int i=0;i<typed.size();i++){\\n            if(typed[i]==name[curr]){\\n                curr++;\\n            }else{\\n                if(i>0){\\n                    if(typed[i]!=typed[i-1]){\\n                        return false;\\n                    }\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return curr == name.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811322,
                "title": "easy-solution-100-faster-iteration-java",
                "content": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i = 0;\\n        int j = 0;\\n        int n = name.length();\\n        int m = typed.length();\\n        while(i<n && j<m)\\n        {\\n            if(name.charAt(i) == typed.charAt(j))\\n            {\\n                i++; j++;\\n            }\\n            else if(i>0 && name.charAt(i-1)==typed.charAt(j))\\n                j++;\\n            else\\n                return false;\\n        }\\n        if(i != n)\\n            return false;\\n        while(j<m){\\n            if(i>0 && name.charAt(i-1)!=typed.charAt(j))\\n                return false;\\n            j++;\\n            }\\n        return true; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i = 0;\\n        int j = 0;\\n        int n = name.length();\\n        int m = typed.length();\\n        while(i<n && j<m)\\n        {\\n            if(name.charAt(i) == typed.charAt(j))\\n            {\\n                i++; j++;\\n            }\\n            else if(i>0 && name.charAt(i-1)==typed.charAt(j))\\n                j++;\\n            else\\n                return false;\\n        }\\n        if(i != n)\\n            return false;\\n        while(j<m){\\n            if(i>0 && name.charAt(i-1)!=typed.charAt(j))\\n                return false;\\n            j++;\\n            }\\n        return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787290,
                "title": "python-solution-using-2-pointers",
                "content": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        i = 0\\n        j = 0\\n        \\n\\t\\t# Run the loop until the end of one of the strings\\n        while i < len(name) and j < len(typed):\\n            \\n\\t\\t\\t# Check the character\\n            if name[i] != typed[j]:\\n                return False\\n            \\n\\t\\t\\t#  If the next character in name is different then skip all long pressed characters in typed.\\n\\t\\t\\t#  For example:  name = \"ab\" and typed = \"aaaaab\"\\n\\t\\t\\t# But there is a tricky case here: name: \"aab\" and typed: \"aaaab\". \\n\\t\\t\\t# In this case we need to first match as many characters required \\n\\t\\t\\t# and only then consider the later ones as long pressed. \\n\\t\\t\\t# So match the 2 first 2 a\\'s and then skip the other a\\'s.\\n            if i != len(name) - 1 and name[i] != name[i+1]:\\n                while j != len(typed) - 1 and typed[j] == typed[j+1] :\\n                    j += 1\\n            \\n\\t\\t\\t# After all long pressed characters have been skipped increment pointer and repeat the process\\n            i += 1\\n            j += 1\\n        \\n\\t\\t# This is required for cases where the strings were matched but there were repating characters at the last.\\n\\t\\t# For example name: \"abc\" typed: \"abcccccccc\".  \\n\\t\\t# We need to skip the c\\'s present towards the end\\n        while j < len(typed) and typed[j] == typed[j-1]:\\n            j += 1\\n\\t\\t\\n\\t\\t# If everything went well then both the pointers were at the end, so return True\\n        if i == len(name) and j == len(typed):\\n            return True\\n        \\n\\t\\t# One of the pointers  was not at the end\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        i = 0\\n        j = 0\\n        \\n\\t\\t# Run the loop until the end of one of the strings\\n        while i < len(name) and j < len(typed):\\n            \\n\\t\\t\\t# Check the character\\n            if name[i] != typed[j]:\\n                return False\\n            \\n\\t\\t\\t#  If the next character in name is different then skip all long pressed characters in typed.\\n\\t\\t\\t#  For example:  name = \"ab\" and typed = \"aaaaab\"\\n\\t\\t\\t# But there is a tricky case here: name: \"aab\" and typed: \"aaaab\". \\n\\t\\t\\t# In this case we need to first match as many characters required \\n\\t\\t\\t# and only then consider the later ones as long pressed. \\n\\t\\t\\t# So match the 2 first 2 a\\'s and then skip the other a\\'s.\\n            if i != len(name) - 1 and name[i] != name[i+1]:\\n                while j != len(typed) - 1 and typed[j] == typed[j+1] :\\n                    j += 1\\n            \\n\\t\\t\\t# After all long pressed characters have been skipped increment pointer and repeat the process\\n            i += 1\\n            j += 1\\n        \\n\\t\\t# This is required for cases where the strings were matched but there were repating characters at the last.\\n\\t\\t# For example name: \"abc\" typed: \"abcccccccc\".  \\n\\t\\t# We need to skip the c\\'s present towards the end\\n        while j < len(typed) and typed[j] == typed[j-1]:\\n            j += 1\\n\\t\\t\\n\\t\\t# If everything went well then both the pointers were at the end, so return True\\n        if i == len(name) and j == len(typed):\\n            return True\\n        \\n\\t\\t# One of the pointers  was not at the end\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783743,
                "title": "two-pointers-approach-faster-than-100-of-solution",
                "content": "So the basic idea behind the code is to use two vectors who are suppose two store the continuous occurance of each element. if element of name element is not equal to element of typed array we will instantly return false, but if they are equal then the only chance we can return false is when the count of continuous occurence of an element is greater than the count of continuous occurence of the same element. If typed string element count is greater we will jump to next element and repeat the same process.\\n\\n\\n\"\"\"class Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int n1 = name.length(), n2=typed.length(), i=n1-2, j=n2-2;\\n        if(n1>n2) return false;\\n        vector<int> one(n1,1), second(n2,1);\\n        while(i>=0) {\\n            if(name[i]==name[i+1]) one[i]+=one[i+1];\\n            i--;\\n        }\\n            \\n        while(j>=0) {\\n            if(typed[j]==typed[j+1]) second[j]+=second[j+1];\\n            j--;\\n        }\\n            \\n        i=0,j=0;\\n        while(i<n1) {\\n            if(name[i]!=typed[j] || one[i]>second[j]) return false;\\n            i+=one[i];\\n            j+=second[j];\\n        }\\n        if(j>=n2) return true;\\n        return false;\\n    }\\n};\"\"\"",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int n1 = name.length(), n2=typed.length(), i=n1-2, j=n2-2;\\n        if(n1>n2) return false;\\n        vector<int> one(n1,1), second(n2,1);\\n        while(i>=0) {\\n            if(name[i]==name[i+1]) one[i]+=one[i+1];\\n            i--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1707486,
                "title": "c-solution-fastest-clear-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        vector<pair<char,int>>v;\\n        v.push_back(make_pair(name[0],1));\\n        for(int i=1;i<name.size();i++){\\n           if(name[i]==name[i-1]){\\n               v[v.size()-1].second++;\\n           }else{\\n               v.push_back(make_pair(name[i],1));\\n           }\\n        }\\n        vector<pair<char,int>>v1;\\n        v1.push_back(make_pair(typed[0],1));\\n        for(int i=1;i<typed.size();i++){\\n           if(typed[i]==typed[i-1]){\\n               v1[v1.size()-1].second++;\\n           }else{\\n               v1.push_back(make_pair(typed[i],1));\\n           }\\n        }\\n        \\n        if(v.size()!=v1.size()){\\n            return false;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i].first!=v1[i].first){\\n                return false;\\n            }\\n            if(v[i].second>v1[i].second){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        vector<pair<char,int>>v;\\n        v.push_back(make_pair(name[0],1));\\n        for(int i=1;i<name.size();i++){\\n           if(name[i]==name[i-1]){\\n               v[v.size()-1].second++;\\n           }else{\\n               v.push_back(make_pair(name[i],1));\\n           }\\n        }\\n        vector<pair<char,int>>v1;\\n        v1.push_back(make_pair(typed[0],1));\\n        for(int i=1;i<typed.size();i++){\\n           if(typed[i]==typed[i-1]){\\n               v1[v1.size()-1].second++;\\n           }else{\\n               v1.push_back(make_pair(typed[i],1));\\n           }\\n        }\\n        \\n        if(v.size()!=v1.size()){\\n            return false;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i].first!=v1[i].first){\\n                return false;\\n            }\\n            if(v[i].second>v1[i].second){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661537,
                "title": "java-solution-time-o-n-space-o-1-two-pointers-approach",
                "content": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(typed.length() < name.length()){\\n            return false;\\n        }\\n        \\n        int i = 0; // pointer 1\\n        int j = 0; // pointer 2\\n        \\n        while(j < typed.length()){\\n            if(i < name.length() && name.charAt(i) == typed.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            else if(j > 0 && typed.charAt(j) == typed.charAt(j - 1)){\\n                j++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return i == name.length();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(typed.length() < name.length()){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1652517,
                "title": "easiest-c-solution-925-long-pressed-name",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string s1, string s2) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        int i=0; \\n        int j = 0;\\n        while(j<m)\\n        {\\n            if(i<n && s1[i] == s2[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(j>0 && s1[i-1] == s2[j])\\n            {\\n                j++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        return i == s1.length();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string s1, string s2) {\\n        int n = s1.length();\\n        int m = s2.length();\\n        int i=0; \\n        int j = 0;\\n        while(j<m)\\n        {\\n            if(i<n && s1[i] == s2[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(j>0 && s1[i-1] == s2[j])\\n            {\\n                j++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        return i == s1.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644410,
                "title": "c-faster-than-100-o-n-time-and-o-1-space",
                "content": "**Intuition Behind**\\nImagine that we are trying to compress the string `typed` into string `name`.\\nWe take 2 pointers, and then count the characters ahead of it that are same to the curr_char.\\nSay in some iteration similar char count for `name` is `n1` and for `typed` is `n2`\\nThen only way the string is valid if `n1<= n2` (since in `typed` there can\\'t be any `char` loss (it can be either equal or more than that).\\nFinally, if the string is valid we point `pointer1 -> pointer1 + n1 and pointer2 -> pointer2 + n2`\\n```\\n\\nbool isLongPressedName(string name, string typed) {\\n\\tint pointer1 = 0;\\n\\tint pointer2 = 0;\\n\\n\\twhile(pointer2 < typed.size() && pointer1 < name.size()){\\n\\n\\t\\tif(name[pointer1] != typed[pointer2]) return false;\\n\\n\\t\\tchar prev_char_typed = typed[pointer2];\\n\\t\\tint count_char_typed = 0;\\n\\t\\twhile(pointer2 < typed.size() && typed[pointer2] == prev_char_typed){\\n\\t\\t\\tcount_char_typed++;\\n\\t\\t\\tpointer2++;\\n\\t\\t}\\n\\n\\t\\tint count_char_name = 0;\\n\\t\\tchar prev_char_name = name[pointer1];\\n\\t\\twhile(pointer1 < name.size() && name[pointer1] == prev_char_name){\\n\\t\\t\\tcount_char_name++;\\n\\t\\t\\tpointer1++;\\n\\t\\t}\\n\\n\\t\\tif(count_char_typed < count_char_name){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif(pointer1 == name.size() && pointer2 < typed.size() || (pointer2 == typed.size() && pointer1 < name.size())){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\treturn true;\\n}\\n\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n\\nbool isLongPressedName(string name, string typed) {\\n\\tint pointer1 = 0;\\n\\tint pointer2 = 0;\\n\\n\\twhile(pointer2 < typed.size() && pointer1 < name.size()){\\n\\n\\t\\tif(name[pointer1] != typed[pointer2]) return false;\\n\\n\\t\\tchar prev_char_typed = typed[pointer2];\\n\\t\\tint count_char_typed = 0;\\n\\t\\twhile(pointer2 < typed.size() && typed[pointer2] == prev_char_typed){\\n\\t\\t\\tcount_char_typed++;\\n\\t\\t\\tpointer2++;\\n\\t\\t}\\n\\n\\t\\tint count_char_name = 0;\\n\\t\\tchar prev_char_name = name[pointer1];\\n\\t\\twhile(pointer1 < name.size() && name[pointer1] == prev_char_name){\\n\\t\\t\\tcount_char_name++;\\n\\t\\t\\tpointer1++;\\n\\t\\t}\\n\\n\\t\\tif(count_char_typed < count_char_name){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif(pointer1 == name.size() && pointer2 < typed.size() || (pointer2 == typed.size() && pointer1 < name.size())){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\treturn true;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1637515,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(name.charAt(0)!=typed.charAt(0)||name.length()>typed.length()) return false;\\n        int i=0,j=0;\\n        for(i=0,j=0;i<name.length()&&j<typed.length();){\\n            if(name.charAt(i)==typed.charAt(j))\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(name.charAt(i-1)==typed.charAt(j)) j++;\\n            else\\n                return false;\\n        }\\n        if(i<name.length()) return false;\\n        for(int k=j;k<typed.length();k++) if(typed.charAt(j-1)!=typed.charAt(k)) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(name.charAt(0)!=typed.charAt(0)||name.length()>typed.length()) return false;\\n        int i=0,j=0;\\n        for(i=0,j=0;i<name.length()&&j<typed.length();){\\n            if(name.charAt(i)==typed.charAt(j))\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(name.charAt(i-1)==typed.charAt(j)) j++;\\n            else\\n                return false;\\n        }\\n        if(i<name.length()) return false;\\n        for(int k=j;k<typed.length();k++) if(typed.charAt(j-1)!=typed.charAt(k)) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609785,
                "title": "java",
                "content": "```\\npublic boolean isLongPressedName(String name, String typed) {\\n        int n1 = name.length(); \\n        int n2 = typed.length(); \\n        \\n        if(n1 > n2) return false; // typed should be equal or greater than name\\n        int j = 0; \\n        \\n        for(int i=0; i<n2; i++){\\n           if(j<n1 && typed.charAt(i) == name.charAt(j)){ // if char match\\n               j++; \\n           }\\n           else{\\n               if(i>0 && typed.charAt(i) != typed.charAt(i-1) || i==0) return false; // if typed[0] is mismatched or typed[i] != typed[i-1] \\n           }\\n        }\\n        return j == n1; // if all char in name have found a match j == n2\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isLongPressedName(String name, String typed) {\\n        int n1 = name.length(); \\n        int n2 = typed.length(); \\n        \\n        if(n1 > n2) return false; // typed should be equal or greater than name\\n        int j = 0; \\n        \\n        for(int i=0; i<n2; i++){\\n           if(j<n1 && typed.charAt(i) == name.charAt(j)){ // if char match\\n               j++; \\n           }\\n           else{\\n               if(i>0 && typed.charAt(i) != typed.charAt(i-1) || i==0) return false; // if typed[0] is mismatched or typed[i] != typed[i-1] \\n           }\\n        }\\n        return j == n1; // if all char in name have found a match j == n2\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1604860,
                "title": "python-o-n-simple",
                "content": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:   \\n        i, N = 0, len(name)\\n        for index, c in enumerate(typed):    \\n            if i < N: \\n                if c == name[i]: i += 1\\n                elif i == 0 or c != name[i - 1]: return False            \\n            if i == N: \\n                if c != name[-1]: return False\\n        return i >= N\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:   \\n        i, N = 0, len(name)\\n        for index, c in enumerate(typed):    \\n            if i < N: \\n                if c == name[i]: i += 1\\n                elif i == 0 or c != name[i - 1]: return False            \\n            if i == N: \\n                if c != name[-1]: return False\\n        return i >= N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599096,
                "title": "python-easy-to-understand",
                "content": "I hope that this method helps you :3 \\n\\n```\\nclass Solution(object):\\n    def isLongPressedName(self, name, typed):\\n        \"\"\"\\n        :type name: str\\n        :type typed: str\\n        :rtype: bool\\n        \"\"\"\\n        elementOfTypedName = 0\\n        charactersOfNamePresents = 0\\n        numberOfCharactersInName = len(name)\\n        numerOfCharacthersInTyped = len(typed)\\n        ###if the first letter of the name and typed don\\'t match ::: case :::\\n        if name[0] != typed[0]:\\n            return False\\n            \\n        ### if  elementOfTypedName is equal to  numberOfElementsInTyped then len(typed) == 0\\n\\t\\t##since name starts to count from  0 then we don\\'t need the last element \\n        while elementOfTypedName < numerOfCharacthersInTyped:\\n            \\n            \\n            if charactersOfNamePresents < numberOfCharactersInName and name[charactersOfNamePresents] == typed[elementOfTypedName]:\\n                charactersOfNamePresents +=1\\n                ### with the next line I\\'m wondering if is a repeated character\\n\\t\\t\\t\\t## if not then is an additional letter and then is a false case\\n            elif typed[elementOfTypedName] != typed[elementOfTypedName-1]:\\n                return False\\n            elementOfTypedName +=1\\n        return charactersOfNamePresents == numberOfCharactersInName\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isLongPressedName(self, name, typed):\\n        \"\"\"\\n        :type name: str\\n        :type typed: str\\n        :rtype: bool\\n        \"\"\"\\n        elementOfTypedName = 0\\n        charactersOfNamePresents = 0\\n        numberOfCharactersInName = len(name)\\n        numerOfCharacthersInTyped = len(typed)\\n        ###if the first letter of the name and typed don\\'t match ::: case :::\\n        if name[0] != typed[0]:\\n            return False\\n            \\n        ### if  elementOfTypedName is equal to  numberOfElementsInTyped then len(typed) == 0\\n\\t\\t##since name starts to count from  0 then we don\\'t need the last element \\n        while elementOfTypedName < numerOfCharacthersInTyped:\\n            \\n            \\n            if charactersOfNamePresents < numberOfCharactersInName and name[charactersOfNamePresents] == typed[elementOfTypedName]:\\n                charactersOfNamePresents +=1\\n                ### with the next line I\\'m wondering if is a repeated character\\n\\t\\t\\t\\t## if not then is an additional letter and then is a false case\\n            elif typed[elementOfTypedName] != typed[elementOfTypedName-1]:\\n                return False\\n            elementOfTypedName +=1\\n        return charactersOfNamePresents == numberOfCharactersInName\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1592749,
                "title": "java-o-t-time-t-length-of-typed-o-1-space",
                "content": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if (name.length() == typed.length() && name.equals(typed)) {\\n            return true;\\n        }\\n\\n        int i = 0, j = 0;\\n        while (j < typed.length()) {\\n            if (i < name.length() && name.charAt(i) == typed.charAt(j)) {\\n                i++;\\n                j++;\\n            } else if (i > 0 && typed.charAt(j) == name.charAt(i - 1)) {\\n                j++;\\n            } else {\\n                return false;\\n            }\\n        }\\n\\n        return i >= name.length();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if (name.length() == typed.length() && name.equals(typed)) {\\n            return true;\\n        }\\n\\n        int i = 0, j = 0;\\n        while (j < typed.length()) {\\n            if (i < name.length() && name.charAt(i) == typed.charAt(j)) {\\n                i++;\\n                j++;\\n            } else if (i > 0 && typed.charAt(j) == name.charAt(i - 1)) {\\n                j++;\\n            } else {\\n                return false;\\n            }\\n        }\\n\\n        return i >= name.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567084,
                "title": "simple-java-solution-using-two-pointer-technique",
                "content": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(typed.length()<name.length()){\\n            return false;\\n        }\\n        int i=0;\\n        int j=0;\\n        while(j<typed.length()){\\n            if(i<name.length() && name.charAt(i)==typed.charAt(j)){\\n                i++;\\n                j++;\\n            }else if(j>0 && typed.charAt(j)==typed.charAt(j-1)){\\n                j++;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return i==name.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(typed.length()<name.length()){\\n            return false;\\n        }\\n        int i=0;\\n        int j=0;\\n        while(j<typed.length()){\\n            if(i<name.length() && name.charAt(i)==typed.charAt(j)){\\n                i++;\\n                j++;\\n            }else if(j>0 && typed.charAt(j)==typed.charAt(j-1)){\\n                j++;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return i==name.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563281,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn is_long_pressed_name(name: String, typed: String) -> bool {\\n        let nb = name.as_bytes();\\n        let mut i = 0;\\n        for &b in typed.as_bytes() {\\n            if i < name.len() && b == nb[i] {\\n                i += 1;\\n            } else if b != nb[i.saturating_sub(1)] {\\n                return false;\\n            }\\n        }\\n        i == name.len()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_long_pressed_name(name: String, typed: String) -> bool {\\n        let nb = name.as_bytes();\\n        let mut i = 0;\\n        for &b in typed.as_bytes() {\\n            if i < name.len() && b == nb[i] {\\n                i += 1;\\n            } else if b != nb[i.saturating_sub(1)] {\\n                return false;\\n            }\\n        }\\n        i == name.len()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1556917,
                "title": "c-easy-to-understand-2-pointers-approach",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n      int i=0,j=0;\\n      while(j<typed.length())\\n      {\\n          if(i!=name.length()&&name[i]==typed[j])\\n          {\\n              i++;\\n              j++;\\n          }\\n          else if(name[i]!=typed[j]&&j!=0&&j<typed.length()&&typed[j]==typed[j-1])\\n          {\\n              j++;\\n          }\\n          else\\n          break;\\n      }\\n    return (i==name.length()&&j==typed.length());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n      int i=0,j=0;\\n      while(j<typed.length())\\n      {\\n          if(i!=name.length()&&name[i]==typed[j])\\n          {\\n              i++;\\n              j++;\\n          }\\n          else if(name[i]!=typed[j]&&j!=0&&j<typed.length()&&typed[j]==typed[j-1])\\n          {\\n              j++;\\n          }\\n          else\\n          break;\\n      }\\n    return (i==name.length()&&j==typed.length());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554666,
                "title": "python-intuitive-o-n-solution",
                "content": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        \\n        name_pointer , typed_pointer = 0 ,0 \\n        while name_pointer < len(name) and typed_pointer < len(typed):\\n            \\n            name_cnt , typed_cnt = 1 , 1 \\n            \\n            # count number of same char\\'s in name \\n            while name_pointer+1 < len(name) and name[name_pointer] == name[name_pointer+1]:\\n                name_cnt += 1 \\n                name_pointer +=1\\n            \\n            # count number of same char\\'s in typed  \\n            while typed_pointer+1 < len(typed) and typed[typed_pointer] == typed[typed_pointer+1]:\\n                typed_cnt += 1 \\n                typed_pointer += 1 \\n                            \\n            # char\\'s should be same and count in type should be greater or equal to cnt \\n            if name_cnt >  typed_cnt or name[name_pointer] != typed[typed_pointer] :\\n                return False \\n            \\n            name_pointer+= 1 \\n            typed_pointer += 1 \\n        \\n        # pointers should be at the end of named and typed \\n        if name_pointer == len(name) and typed_pointer == len(typed) : \\n            return True\\n        else : \\n            return False \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        \\n        name_pointer , typed_pointer = 0 ,0 \\n        while name_pointer < len(name) and typed_pointer < len(typed):\\n            \\n            name_cnt , typed_cnt = 1 , 1 \\n            \\n            # count number of same char\\'s in name \\n            while name_pointer+1 < len(name) and name[name_pointer] == name[name_pointer+1]:\\n                name_cnt += 1 \\n                name_pointer +=1\\n            \\n            # count number of same char\\'s in typed  \\n            while typed_pointer+1 < len(typed) and typed[typed_pointer] == typed[typed_pointer+1]:\\n                typed_cnt += 1 \\n                typed_pointer += 1 \\n                            \\n            # char\\'s should be same and count in type should be greater or equal to cnt \\n            if name_cnt >  typed_cnt or name[name_pointer] != typed[typed_pointer] :\\n                return False \\n            \\n            name_pointer+= 1 \\n            typed_pointer += 1 \\n        \\n        # pointers should be at the end of named and typed \\n        if name_pointer == len(name) and typed_pointer == len(typed) : \\n            return True\\n        else : \\n            return False \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508653,
                "title": "javascript-2-pointers-approach",
                "content": "You can find my solutions to other leetcode problems on my Github: https://linktr.ee/rohitdhatrak\\n\\n```\\nvar isLongPressedName = function (name, typed) {\\n    if (typed.length < name.length) return false;\\n    let namePtr = 0;\\n    let typedPtr = 0;\\n\\n    while (typedPtr < typed.length || namePtr < name.length) {\\n        if (name[namePtr] === typed[typedPtr]) {\\n            namePtr++;\\n            typedPtr++;\\n        } else if (name[namePtr - 1] === typed[typedPtr]) {\\n            typedPtr++;\\n        } else {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar isLongPressedName = function (name, typed) {\\n    if (typed.length < name.length) return false;\\n    let namePtr = 0;\\n    let typedPtr = 0;\\n\\n    while (typedPtr < typed.length || namePtr < name.length) {\\n        if (name[namePtr] === typed[typedPtr]) {\\n            namePtr++;\\n            typedPtr++;\\n        } else if (name[namePtr - 1] === typed[typedPtr]) {\\n            typedPtr++;\\n        } else {\\n            return false;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1480327,
                "title": "simple-short-java-explanation",
                "content": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(name.length() > typed.length()) return false;\\n        //typed length will be greater or equal to name, hence iterating on typed\\n        \\n        if(name.charAt(0) != typed.charAt(0)) return false;\\n       \\n        int j=0, i=0;\\n        \\n        while(j < typed.length()){\\n            // check index bound for i and increment i when i==j\\n            if(i < name.length() && name.charAt(i) == typed.charAt(j)){\\n                i++;\\n            } else if(typed.charAt(j) != typed.charAt(j-1)){\\n                //characters not matched means long press, so check previously typed\\n                return false;\\n            }\\n            j++;\\n        }\\n        \\n        // i must reach end\\n        return i == name.length();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(name.length() > typed.length()) return false;\\n        //typed length will be greater or equal to name, hence iterating on typed\\n        \\n        if(name.charAt(0) != typed.charAt(0)) return false;\\n       \\n        int j=0, i=0;\\n        \\n        while(j < typed.length()){\\n            // check index bound for i and increment i when i==j\\n            if(i < name.length() && name.charAt(i) == typed.charAt(j)){\\n                i++;\\n            } else if(typed.charAt(j) != typed.charAt(j-1)){\\n                //characters not matched means long press, so check previously typed\\n                return false;\\n            }\\n            j++;\\n        }\\n        \\n        // i must reach end\\n        return i == name.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436993,
                "title": "two-pointer-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int n = name.size();\\n        int m = typed.size();\\n        \\n        if(n>m) return false;\\n        int i =0,j=0;\\n        while(i<n){\\n            if(name[i] == typed[j]){\\n                i++;\\n                j++;\\n            }else if(j!=0 && typed[j] == typed[j-1]){\\n                j++;\\n            }else{\\n                return false;\\n            }\\n        }\\n        while(j<m){\\n            if(typed[j] != name[n-1]){\\n                return false;\\n            }\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int n = name.size();\\n        int m = typed.size();\\n        \\n        if(n>m) return false;\\n        int i =0,j=0;\\n        while(i<n){\\n            if(name[i] == typed[j]){\\n                i++;\\n                j++;\\n            }else if(j!=0 && typed[j] == typed[j-1]){\\n                j++;\\n            }else{\\n                return false;\\n            }\\n        }\\n        while(j<m){\\n            if(typed[j] != name[n-1]){\\n                return false;\\n            }\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396905,
                "title": "java-detailed-explanation-tc-o-n-faster-than-100",
                "content": "**Do vote up if you like it :)**\\n\\nThe idea is to check if the current ith and jth charcacter is equal then move to check for the next ith and jth character, if characters are different then check if it is mistyped due to faulty keyboard, to check for mistyped characters you need to check if the jth character is equal to the i - 1 th  character, if it is equal then just increase j (beacause i is already pointing to the next valid character of the name).\\n\\nSpace Complexity : O(1)\\nTime Complexity : O(N), where N is typed string\\'s length\\n\\n```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(name.charAt(0) != typed.charAt(0)) return false; //Check for the 0th i and j characters,\\n                                                            //if both are different then the name cannot be achieved\\n        int i = 1;\\n        int j = 1;\\n        \\n        while(i < name.length() && j < typed.length()) {\\n            if(name.charAt(i) != typed.charAt(j)) {         // Current i and current j is not equal then\\n                if(name.charAt(i - 1) != typed.charAt(j)){  // Check for the previous i and current j\\n                    return false;                           // If not equal return false \\n                }\\n                else {\\n                    j++;           // If equal simply increase j, \\n                    continue;      //because i is already pointing to the valid name character\\n                    \\n                }\\n            }\\n\\t\\t\\ti++;    //Both ith and jth character was equal\\n            j++;    //hence you need to check for the next character  \\n        }\\n        \\n        while(j < typed.length()) {     //If j < typed.length, then there\\'s still the possibility to achieve the name     \\n            if(typed.charAt(j) != name.charAt(i - 1)) {     // Last character of name != to the current jth character\\n                return false;\\n            }\\n            j++;         //If equal check for the next jth character\\n        }\\n        \\n        return i < name.length() ? false : true; \\n        //If i < name.length means typed String\\'s length was less the name String\\'s length\\n        //in that case name can never be achieved, so return accordingly\\n    }\\n}\\n```\\n-----------------------------------------------------------------------",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(name.charAt(0) != typed.charAt(0)) return false; //Check for the 0th i and j characters,\\n                                                            //if both are different then the name cannot be achieved\\n        int i = 1;\\n        int j = 1;\\n        \\n        while(i < name.length() && j < typed.length()) {\\n            if(name.charAt(i) != typed.charAt(j)) {         // Current i and current j is not equal then\\n                if(name.charAt(i - 1) != typed.charAt(j)){  // Check for the previous i and current j\\n                    return false;                           // If not equal return false \\n                }\\n                else {\\n                    j++;           // If equal simply increase j, \\n                    continue;      //because i is already pointing to the valid name character\\n                    \\n                }\\n            }\\n\\t\\t\\ti++;    //Both ith and jth character was equal\\n            j++;    //hence you need to check for the next character  \\n        }\\n        \\n        while(j < typed.length()) {     //If j < typed.length, then there\\'s still the possibility to achieve the name     \\n            if(typed.charAt(j) != name.charAt(i - 1)) {     // Last character of name != to the current jth character\\n                return false;\\n            }\\n            j++;         //If equal check for the next jth character\\n        }\\n        \\n        return i < name.length() ? false : true; \\n        //If i < name.length means typed String\\'s length was less the name String\\'s length\\n        //in that case name can never be achieved, so return accordingly\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386915,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def isLongPressedName(self, name, typed):\\n        \"\"\"\\n        :type name: str\\n        :type typed: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if typed[0]!=name[0]:return False\\n        i=0\\n        j=0\\n        while i<len(name) and j<len(typed):\\n            \\n            if name[i]==typed[j]:\\n                i+=1\\n                j+=1\\n            elif i>0 and name[i-1]==typed[j]:\\n                j+=1\\n            else:\\n                return False\\n#         not possible to form all name char    \\n        if i<len(name):\\n            return False\\n#         when form all char of name but some char left in type then check char is match with last char of name or not\\n        while j<len(typed):\\n            if name[i-1]!=typed[j]:return False\\n            j+=1\\n        \\n           \\n        return True",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isLongPressedName(self, name, typed):\\n        \"\"\"\\n        :type name: str\\n        :type typed: str\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if typed[0]!=name[0]:return False\\n        i=0\\n        j=0\\n        while i<len(name) and j<len(typed):\\n            \\n            if name[i]==typed[j]:\\n                i+=1\\n                j+=1\\n            elif i>0 and name[i-1]==typed[j]:\\n                j+=1\\n            else:\\n                return False\\n#         not possible to form all name char    \\n        if i<len(name):\\n            return False\\n#         when form all char of name but some char left in type then check char is match with last char of name or not\\n        while j<len(typed):\\n            if name[i-1]!=typed[j]:return False\\n            j+=1\\n        \\n           \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1378832,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n         int i=0;\\n         int j=0;\\n        int n=name.length();\\n        int m=typed.length();\\n        if(n>m){\\n            return false;\\n        }\\n        while(1){\\n            if(i==n && j==m){\\n                return true; \\n            }\\n            if(i<n && j<m && name[i]==typed[j]){\\n                i++;\\n                j++;\\n            }\\n            \\n            else if(j>0 && j<m && typed[j-1]==typed[j]){\\n                j++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n    }\\n};\\n  \\n        ```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n         int i=0;\\n         int j=0;\\n        int n=name.length();\\n        int m=typed.length();\\n        if(n>m){\\n            return false;\\n        }\\n        while(1){\\n            if(i==n && j==m){\\n                return true; \\n            }\\n            if(i<n && j<m && name[i]==typed[j]){\\n                i++;\\n                j++;\\n            }\\n            \\n            else if(j>0 && j<m && typed[j-1]==typed[j]){\\n                j++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n    }\\n};\\n  \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 1376839,
                "title": "c-2-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int n = name.size();\\n        int t = typed.size();\\n        if(t < n) return false;\\n        int i, j;\\n        for(i = 0, j = 0; i < n; ) {\\n            if(name[i] == typed[j]) {\\n                ++i;\\n                ++j;\\n            } else if(j!=0 && (typed[j] == typed[j-1])) {\\n                ++j;\\n            } else {\\n                return false;\\n            }\\n        }\\n        if(j <= t-1) {\\n            for(; j < t; ++j) {\\n            if(typed[j] != name[n-1])  return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int n = name.size();\\n        int t = typed.size();\\n        if(t < n) return false;\\n        int i, j;\\n        for(i = 0, j = 0; i < n; ) {\\n            if(name[i] == typed[j]) {\\n                ++i;\\n                ++j;\\n            } else if(j!=0 && (typed[j] == typed[j-1])) {\\n                ++j;\\n            } else {\\n                return false;\\n            }\\n        }\\n        if(j <= t-1) {\\n            for(; j < t; ++j) {\\n            if(typed[j] != name[n-1])  return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355084,
                "title": "4-lines-of-c-faster-than-100-of-c-submissions",
                "content": "Didn\\'t see many solutions in C so I want to share mine - upvote if you like it!\\n\\nRuntime: 0 ms, faster than 100.00% of C online submissions for Long Pressed Name.\\nMemory Usage: 5.6 MB, less than 95.83% of C online submissions for Long Pressed Name.\\n```\\nbool isLongPressedName(char * name, char * typed){\\n    if (*name != *typed) return false;\\n    else if (!*name) return true;           // condition could also be (*name == \\'\\\\0\\' || *typed == \\'\\\\0\\')\\n    else if (*(name+1) == *(typed+1)) return isLongPressedName(++name, ++typed);\\n    return isLongPressedName(name, ++typed);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nbool isLongPressedName(char * name, char * typed){\\n    if (*name != *typed) return false;\\n    else if (!*name) return true;           // condition could also be (*name == \\'\\\\0\\' || *typed == \\'\\\\0\\')\\n    else if (*(name+1) == *(typed+1)) return isLongPressedName(++name, ++typed);\\n    return isLongPressedName(name, ++typed);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345055,
                "title": "c-clean-2-pointer-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int m = name.length(), n = typed.length();\\n                \\n        int i = 0, j = 0;\\n        while(j < n) {         \\n            if(i < m && name[i] == typed[j]) {\\n                i++;\\n            } else if( j == 0 || typed[j] != typed[j-1]) {\\n                return false;\\n            }\\n            j++;\\n        }\\n        return i == m;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int m = name.length(), n = typed.length();\\n                \\n        int i = 0, j = 0;\\n        while(j < n) {         \\n            if(i < m && name[i] == typed[j]) {\\n                i++;\\n            } else if( j == 0 || typed[j] != typed[j-1]) {\\n                return false;\\n            }\\n            j++;\\n        }\\n        return i == m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317444,
                "title": "java-solution-using-two-pointers",
                "content": "Wrote this code although I Know there is some room for improvement\\n\\n```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i = 0;\\n        int j = 0;\\n        \\n        while(j < typed.length()){\\n            if(i < name.length() && name.charAt(i) == typed.charAt(j)){\\n                i++;\\n                j++;\\n            }else{\\n                if(j != 0 && typed.charAt(j) == name.charAt(i-1)){\\n                    j++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return i == name.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i = 0;\\n        int j = 0;\\n        \\n        while(j < typed.length()){\\n            if(i < name.length() && name.charAt(i) == typed.charAt(j)){\\n                i++;\\n                j++;\\n            }else{\\n                if(j != 0 && typed.charAt(j) == name.charAt(i-1)){\\n                    j++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return i == name.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308682,
                "title": "easy-c-solution-100-fast-with-proper-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n       \\n        if(name.size() > typed.size()) return false;// no possibility \\n        int i =0; // initialize two pointers to 0\\n        int j =0;\\n        while(i< name.size() && j <typed.size()){ // while loop till the size of name and typed string is greater than i and j respectively\\n            if(name.at(i) == typed.at(j)){ // check if the character at i and j are same if yes than  \\n            //increment i & j pointer\\n                i++;\\n                j++;\\n            }else if( i> 0 && name.at(i-1) == typed.at(j)){// if the charcters are not same check for the i-1 character & j if they are same than increment j only\\n                j++;\\n            }else{//if all the above cases are not satisfied return false \\n                return false;\\n            }\\n        }\\n         while(typed.size() > j ){ \\n              if(name.at(i-1) != typed.at(j))return false;\\n               j++;\\n        }\\n        \\n        return i< name.size() ? false : true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n       \\n        if(name.size() > typed.size()) return false;// no possibility \\n        int i =0; // initialize two pointers to 0\\n        int j =0;\\n        while(i< name.size() && j <typed.size()){ // while loop till the size of name and typed string is greater than i and j respectively\\n            if(name.at(i) == typed.at(j)){ // check if the character at i and j are same if yes than  \\n            //increment i & j pointer\\n                i++;\\n                j++;\\n            }else if( i> 0 && name.at(i-1) == typed.at(j)){// if the charcters are not same check for the i-1 character & j if they are same than increment j only\\n                j++;\\n            }else{//if all the above cases are not satisfied return false \\n                return false;\\n            }\\n        }\\n         while(typed.size() > j ){ \\n              if(name.at(i-1) != typed.at(j))return false;\\n               j++;\\n        }\\n        \\n        return i< name.size() ? false : true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284861,
                "title": "python-stack-solution-alternative",
                "content": "```\\n\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        \\n        t = collections.deque(typed)\\n        n = collections.deque(name)\\n        while t and n:\\n            c = n.popleft()\\n            tmp = [c]\\n            \\n            while n and n[0] == c:\\n                tmp += [n.popleft()]\\n                \\n            while tmp and t and t[0] == c:\\n                tmp.pop()\\n                t.popleft()\\n                \\n            while t and t[0] == c:\\n                t.popleft()\\n                    \\n            if len(tmp) > 0:\\n                return False\\n\\n        return len(n) == 0 and len(t) == 0\\n``` \\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def isLongPressedName(self, name: str, typed: str) -> bool:\\n        \\n        t = collections.deque(typed)\\n        n = collections.deque(name)\\n        while t and n:\\n            c = n.popleft()\\n            tmp = [c]\\n            \\n            while n and n[0] == c:\\n                tmp += [n.popleft()]\\n                \\n            while tmp and t and t[0] == c:\\n                tmp.pop()\\n                t.popleft()\\n                \\n            while t and t[0] == c:\\n                t.popleft()\\n                    \\n            if len(tmp) > 0:\\n                return False\\n\\n        return len(n) == 0 and len(t) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283314,
                "title": "c-2-pointers-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int i=0,j=0;\\n        while(j<typed.length()){\\n            if(name[i]!=typed[j]){\\n                return false;\\n            }\\n            char ch = name[i];\\n            char chh = typed[j];\\n            int cnt = 1;\\n            while(name[i+1]==ch){\\n                cnt++;\\n                i++;\\n            }\\n            int ct = 0;\\n            while(typed[j]==ch){\\n                ct++;\\n                j++;\\n            }\\n            if(cnt>ct){\\n                return false;\\n            }\\n            i++;\\n        }\\n        if(j!=typed.length() || i!=name.length()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int i=0,j=0;\\n        while(j<typed.length()){\\n            if(name[i]!=typed[j]){\\n                return false;\\n            }\\n            char ch = name[i];\\n            char chh = typed[j];\\n            int cnt = 1;\\n            while(name[i+1]==ch){\\n                cnt++;\\n                i++;\\n            }\\n            int ct = 0;\\n            while(typed[j]==ch){\\n                ct++;\\n                j++;\\n            }\\n            if(cnt>ct){\\n                return false;\\n            }\\n            i++;\\n        }\\n        if(j!=typed.length() || i!=name.length()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282263,
                "title": "cpp-0ms-easy-o-n-time-o-1-space",
                "content": "```\\nbool isLongPressedName(string name, string typed) {\\n        if(name.size()>typed.size()) return false;\\n        if(name.size()==typed.size()) return name==typed;\\n        int count(0), pos(0), i(0);\\n        char prev;\\n        while( i < name.size())\\n        {\\n             int j=i;\\n             prev = name[i];\\n             while(name[j]==prev && j < name.size())\\n             {\\n                 count++;\\n                 j++;\\n             }\\n            while( pos<typed.size() && typed[pos] == prev )\\n            {\\n                count--;\\n                pos++;\\n            }\\n            if( count > 0) return false;\\n            else count = 0;  \\n            i = j;\\n        }\\n        return pos == typed.size();\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool isLongPressedName(string name, string typed) {\\n        if(name.size()>typed.size()) return false;\\n        if(name.size()==typed.size()) return name==typed;\\n        int count(0), pos(0), i(0);\\n        char prev;\\n        while( i < name.size())\\n        {\\n             int j=i;\\n             prev = name[i];\\n             while(name[j]==prev && j < name.size())\\n             {\\n                 count++;\\n                 j++;\\n             }\\n            while( pos<typed.size() && typed[pos] == prev )\\n            {\\n                count--;\\n                pos++;\\n            }\\n            if( count > 0) return false;\\n            else count = 0;  \\n            i = j;\\n        }\\n        return pos == typed.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261647,
                "title": "long-pressed-name-simple-two-pointer-solution",
                "content": "hint : Maintain two pointer i, j where i -> name and j-> typed no increment there value as\\n1) when both eqaul inc both i++ j++;\\n2) when i-1 == j then inc only j;\\n3) else return false\\n4) coming out of the loop if  i < name.length then return false else return true;\\nSolution :\\n\\n```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i=0; int j=0;\\n        if(name.length()>typed.length()) return false;\\n        while(i!=name.length() && j!=typed.length()){\\n            if(name.charAt(i)==typed.charAt(j)){\\n                i++;\\n                j++;\\n            }else if(i>0 && name.charAt(i-1)==typed.charAt(j)){\\n                j++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        while(j<typed.length()){\\n            if(typed.charAt(j)!=name.charAt(i-1)) return false;\\n            j++;\\n        }\\n        \\n        if(i<name.length()){\\n            return false;\\n        }else{\\n            return true;\\n        } \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int i=0; int j=0;\\n        if(name.length()>typed.length()) return false;\\n        while(i!=name.length() && j!=typed.length()){\\n            if(name.charAt(i)==typed.charAt(j)){\\n                i++;\\n                j++;\\n            }else if(i>0 && name.charAt(i-1)==typed.charAt(j)){\\n                j++;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        while(j<typed.length()){\\n            if(typed.charAt(j)!=name.charAt(i-1)) return false;\\n            j++;\\n        }\\n        \\n        if(i<name.length()){\\n            return false;\\n        }else{\\n            return true;\\n        } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261171,
                "title": "java-with-examples",
                "content": "```\\nclass Solution {\\npublic boolean isLongPressedName(String name, String typed) {\\n\\n int m=name.length();\\n int n=typed.length();\\n     \\n     if(m>n)                //case 1 ale and al\\n     return false;\\nint i=0;\\nfor(int j=0;j<n;j++){\\nif(i<=m-1 && name.charAt(i)==typed.charAt(j))\\ni++;\\n\\nelse if(j==0 || typed.charAt(j)!=typed.charAt(j-1)) //\"aabbc\" \"aabbccd\" fails for j=6 c!=d\\nreturn false;                                      // \"a\" \"b\" j==0 =?false\\n}\\n\\nreturn i<m?false:true; //if i<m and j==n => false\\n                      //\"aabbcc\" \"aabbbb\" i=4<5\\n\\n}\\n}\\n\\ndry run these examples\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic boolean isLongPressedName(String name, String typed) {\\n\\n int m=name.length();\\n int n=typed.length();\\n     \\n     if(m>n)                //case 1 ale and al\\n     return false;\\nint i=0;\\nfor(int j=0;j<n;j++){\\nif(i<=m-1 && name.charAt(i)==typed.charAt(j))\\ni++;\\n\\nelse if(j==0 || typed.charAt(j)!=typed.charAt(j-1)) //\"aabbc\" \"aabbccd\" fails for j=6 c!=d\\nreturn false;                                      // \"a\" \"b\" j==0 =?false\\n}\\n\\nreturn i<m?false:true; //if i<m and j==n => false\\n                      //\"aabbcc\" \"aabbbb\" i=4<5\\n\\n}\\n}\\n\\ndry run these examples\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260642,
                "title": "java-1ms",
                "content": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        char[] n=name.toCharArray();\\n        char[] type=typed.toCharArray();\\n        int i=0;\\n        int j=0;\\n        while(i<n.length && j<type.length && n[i]==type[j])\\n        {\\n           int count=0;\\n           int count1=0;\\n            while(i<n.length-1 && n[i]==n[i+1])\\n            {\\n                count++;\\n                i++;\\n            }\\n            while(j<type.length && n[i]==type[j] )\\n            {\\n              count1++; \\n              j++;\\n            }\\n            if(count1<=count)\\n                return false;\\n             i++;\\n        }   \\n        if(i==n.length && j==type.length)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        char[] n=name.toCharArray();\\n        char[] type=typed.toCharArray();\\n        int i=0;\\n        int j=0;\\n        while(i<n.length && j<type.length && n[i]==type[j])\\n        {\\n           int count=0;\\n           int count1=0;\\n            while(i<n.length-1 && n[i]==n[i+1])\\n            {\\n                count++;\\n                i++;\\n            }\\n            while(j<type.length && n[i]==type[j] )\\n            {\\n              count1++; \\n              j++;\\n            }\\n            if(count1<=count)\\n                return false;\\n             i++;\\n        }   \\n        if(i==n.length && j==type.length)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244443,
                "title": "java-1ms-solution",
                "content": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(name.equals(typed))\\n            return true;\\n        int i=name.length()-1,j=typed.length()-1;\\n        while(i>=0 && j>=0)\\n        {\\n            int count=0;\\n            char ch = name.charAt(i);\\n            while(i>=0 && name.charAt(i) == ch)\\n            {\\n                i--;\\n                count++;\\n            }\\n            while(j>=0 && typed.charAt(j) == ch)\\n            {\\n                j--;\\n                count--;\\n            }\\n            if(count > 0 ||(i>=0 && j<0)||(i<0 && j>=0))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        if(name.equals(typed))\\n            return true;\\n        int i=name.length()-1,j=typed.length()-1;\\n        while(i>=0 && j>=0)\\n        {\\n            int count=0;\\n            char ch = name.charAt(i);\\n            while(i>=0 && name.charAt(i) == ch)\\n            {\\n                i--;\\n                count++;\\n            }\\n            while(j>=0 && typed.charAt(j) == ch)\\n            {\\n                j--;\\n                count--;\\n            }\\n            if(count > 0 ||(i>=0 && j<0)||(i<0 && j>=0))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240329,
                "title": "java-solution-0ms-runtime",
                "content": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int j=0;\\n        if(name.equals(typed))\\n        {\\n            return true;\\n        }\\nif(typed.length()<name.length()||typed.charAt(0)!=name.charAt(0))\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<typed.length();i++)\\n        {\\n            if(j<name.length()&&name.charAt(j)==typed.charAt(i))\\n            {\\n                j++;\\n            }\\n            else if(typed.charAt(i)!=typed.charAt(i-1))\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        \\n        return j==name.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isLongPressedName(String name, String typed) {\\n        int j=0;\\n        if(name.equals(typed))\\n        {\\n            return true;\\n        }\\nif(typed.length()<name.length()||typed.charAt(0)!=name.charAt(0))\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<typed.length();i++)\\n        {\\n            if(j<name.length()&&name.charAt(j)==typed.charAt(i))\\n            {\\n                j++;\\n            }\\n            else if(typed.charAt(i)!=typed.charAt(i-1))\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        \\n        return j==name.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237536,
                "title": "c-two-pointers-solution-100-faster-with-comments-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n```\\n        \\n        /* typed should atleast be of same length as name in the best case where there are no duplicates \\n           in typed */\\n        if(typed.length() < name.length())\\n            return false;\\n        \\n        int i=0, j=0;\\n        while(i<name.length() || j<typed.length())\\n        {   \\n            /* If current we are looking at the same caharacter in both the strings,\\n               move both the pointers forward \\n            */\\n            if(i< name.length() && name[i] == typed[j])  i++, j++;\\n            \\n            /*  If not, typed[j] should be a duplicated character which means it should be same as \\n                name[i-1]. Increment onlt j forward as we might have more duplicate characters in typed\\n                that we need to process.\\n                Note: This will also handle the case where we have reached the end of \\n                name, but still have some characters left in typed to process.\\n                Example: name=\"abc\" and typed=\"abccc\" \\n            */\\n            else if(i>0 && j<typed.length() && name[i-1] == typed[j]) j++;\\n            \\n            /* If typed[j] is not the same as name[i] or name[i-1], we can return here as \\n               typed has a character that is not a duplicate of a character in name\\n               eg: name=\"abccdd\", typed=\"abbbccced\"\\n               name : abcc    | dd\\n               typed: abbbccc | ed   ->typed[7]->\"e\" is not equal to name[4]->\"d\" or name[3]->\"c\"\\n\\t\\t\\t   so \"e\" is not a duplicate character here\\n            */\\n            else return false;  \\n        }\\n        \\n        /*We have successfully reached the end of both the strings, so return true*/\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570171,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 1835360,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 1572319,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 2025468,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 1999974,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 1569851,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 1917078,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 1779244,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 2073628,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 2070071,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 1570171,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 1835360,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 1572319,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 2025468,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 1999974,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 1569851,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 1917078,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 1779244,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 2073628,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 2070071,
                "content": [
                    {
                        "username": "nareshvishram",
                        "content": "Shouldn\\'t be in Easy Section !!\\nShould be in medium at least !!"
                    },
                    {
                        "username": "mutasim77",
                        "content": "hate u alexx"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Poor Alex... \\uD83D\\uDE14"
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "My solution didn\\'t work because of alex."
                    },
                    {
                        "username": "cabbagehao",
                        "content": "From the describtion\\uFF0C I think the follow testcase should be Failed, but it\\'s not:  \\n\\nname = \"alex\"\\ntyped = \"alexs\"\\n\\nHow do you think?"
                    },
                    {
                        "username": "ZANGO_27",
                        "content": "it fails"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would rather tell this fellow to go buy a new keyboard than look at the mistyped word."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Explanation in Example 2 is poorly worded. "
                    },
                    {
                        "username": "archieny",
                        "content": "Others may disagree, and that\\'s fine but I think at least one testcase misrepresents the problem as described. \\n\\nMy current solution (which I acknowledge as a wrong solution for this question obviously, it failed), but the solution it fails on is misrepresentative of the problem as described. \\n\\nThe problem description guarantees that the typed characters will clearly be typed **1 or more times** with **some characters (possibly one) being long pressed.** That, effectively guarantees against characters being **not typed** where they are expected. But this test case, \"kikcxmvzi\" \"kiikcxxmmvvzz\", removes a letter from the end of the typed string.\\n\\nI understand that he **could forget to type a letter**, but this question seems to imply the that all letters are typed, with maybe some typed more than once - not never.\\n\\nMany answer title suggest a two pointer solution, which I intend to begin implementing to see if I can suceed against all given test cases, but I thought this confusion may be worth noting."
                    },
                    {
                        "username": "madpoly",
                        "content": "stupid problem, gave me ptsd. Should be medium!"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Entry level medium problem. \\n\"F\" for all those trying to solve it using hashmap \\nlike all of you, i too am stuck at test cases 77/94 lmao"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Why you overcomplicate your life?\nIt's tagged 'Two Pointers', not 'Hashmap'. Easy and classical case for two pointers..."
                    },
                    {
                        "username": "Django3",
                        "content": "A question with incomplete explanations is not a difficult or easy question, it is a wrong question. I can\\'t understand what they are trying to do with such a question.\\n"
                    },
                    {
                        "username": "arnabroy10121998",
                        "content": "My solution passed 91/94 test cases...still somewhat fell short just because of alex.....hate u "
                    }
                ]
            },
            {
                "id": 2067643,
                "content": [
                    {
                        "username": "rtrain",
                        "content": "Why is case two false im confused"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "name =\\n\"alex\"\\ntyped =\\n\"aaleexa\"\\n\\nwhy the expected output is false?"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "this had too many edge cases man!"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Hey Leetcode this is not at all an EASY question it should be a MEDIUM one."
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "why it is failing on the  following test case ?\\nname=\"pyplrz\"\\ntyped=\"ppyypllr\"\\n\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int m=name.size();\\n        int n=typed.size();\\n        if(name.length()>typed.length()) return false;\\n        \\n        int i=0,j=0;\\n        while(i<m && j<n)\\n        {\\n            if(name[i]==typed[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(i>0 && name[i-1]==typed[j])\\n            {\\n                j++;\\n            }\\n            else\\n\\n            return false;\\n        }\\n        \\n        while(j<n)\\n        {\\n            if(name[i-1]!=typed[j])\\n            return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n   @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "kasukurthibhargav",
                        "content": "while(j<n)\\n    {\\n        if(name[i-1]!=typed[j])\\n        return false;\\n        j++;\\n    }\\n    return true;\\n}\\n\\n\\nreplace this snippet to \\nif( i == name.length()){\\n            return true;\\n        }\\n        return true;"
                    },
                    {
                        "username": "shashank_maikhuri",
                        "content": "You could just add a check if(i<m) after the while loop is exited and if that\\'s the case this means that there are still some characters in name which were not in typed hence it should return false.\\n\\nif(i<m){return false;}"
                    },
                    {
                        "username": "kishor_123",
                        "content": "put in 2nd while(j<n || i<n) because \"pyplrz\" \"i\" is on z and \"i\" still not completed just trace it you know"
                    },
                    {
                        "username": "IOseph",
                        "content": "One of the more simple questions in the category easy... As a hint, if you store the previous state (i.e. character) you can 'skip' it when you traverse `typed` and only increase the index for `typed` (and not `name`). Thanks for the interesting problem, especially the care (housekeeping) for the extra check for any tailing characters that could match the stored previous state."
                    },
                    {
                        "username": "ddvuser",
                        "content": "name = \"alex\" and typed = \"aaleexa\", why testcase expecting it to be False?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Simply because of the last 'a' in ``typed`` which is not a duplicate of the last 'x' in ``name``."
                    },
                    {
                        "username": "c0rt3s",
                        "content": "Even if you are stuck after applying two pointers, then you see my submission."
                    },
                    {
                        "username": "Msey",
                        "content": "this soulution is really pain in the.. head\\none of the most difficult I met at easy category"
                    },
                    {
                        "username": "arrowmaster1252",
                        "content": "All hail Regex"
                    }
                ]
            },
            {
                "id": 2067308,
                "content": [
                    {
                        "username": "rtrain",
                        "content": "Why is case two false im confused"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "name =\\n\"alex\"\\ntyped =\\n\"aaleexa\"\\n\\nwhy the expected output is false?"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "this had too many edge cases man!"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Hey Leetcode this is not at all an EASY question it should be a MEDIUM one."
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "why it is failing on the  following test case ?\\nname=\"pyplrz\"\\ntyped=\"ppyypllr\"\\n\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int m=name.size();\\n        int n=typed.size();\\n        if(name.length()>typed.length()) return false;\\n        \\n        int i=0,j=0;\\n        while(i<m && j<n)\\n        {\\n            if(name[i]==typed[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(i>0 && name[i-1]==typed[j])\\n            {\\n                j++;\\n            }\\n            else\\n\\n            return false;\\n        }\\n        \\n        while(j<n)\\n        {\\n            if(name[i-1]!=typed[j])\\n            return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n   @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "kasukurthibhargav",
                        "content": "while(j<n)\\n    {\\n        if(name[i-1]!=typed[j])\\n        return false;\\n        j++;\\n    }\\n    return true;\\n}\\n\\n\\nreplace this snippet to \\nif( i == name.length()){\\n            return true;\\n        }\\n        return true;"
                    },
                    {
                        "username": "shashank_maikhuri",
                        "content": "You could just add a check if(i<m) after the while loop is exited and if that\\'s the case this means that there are still some characters in name which were not in typed hence it should return false.\\n\\nif(i<m){return false;}"
                    },
                    {
                        "username": "kishor_123",
                        "content": "put in 2nd while(j<n || i<n) because \"pyplrz\" \"i\" is on z and \"i\" still not completed just trace it you know"
                    },
                    {
                        "username": "IOseph",
                        "content": "One of the more simple questions in the category easy... As a hint, if you store the previous state (i.e. character) you can 'skip' it when you traverse `typed` and only increase the index for `typed` (and not `name`). Thanks for the interesting problem, especially the care (housekeeping) for the extra check for any tailing characters that could match the stored previous state."
                    },
                    {
                        "username": "ddvuser",
                        "content": "name = \"alex\" and typed = \"aaleexa\", why testcase expecting it to be False?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Simply because of the last 'a' in ``typed`` which is not a duplicate of the last 'x' in ``name``."
                    },
                    {
                        "username": "c0rt3s",
                        "content": "Even if you are stuck after applying two pointers, then you see my submission."
                    },
                    {
                        "username": "Msey",
                        "content": "this soulution is really pain in the.. head\\none of the most difficult I met at easy category"
                    },
                    {
                        "username": "arrowmaster1252",
                        "content": "All hail Regex"
                    }
                ]
            },
            {
                "id": 1989950,
                "content": [
                    {
                        "username": "rtrain",
                        "content": "Why is case two false im confused"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "name =\\n\"alex\"\\ntyped =\\n\"aaleexa\"\\n\\nwhy the expected output is false?"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "this had too many edge cases man!"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Hey Leetcode this is not at all an EASY question it should be a MEDIUM one."
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "why it is failing on the  following test case ?\\nname=\"pyplrz\"\\ntyped=\"ppyypllr\"\\n\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int m=name.size();\\n        int n=typed.size();\\n        if(name.length()>typed.length()) return false;\\n        \\n        int i=0,j=0;\\n        while(i<m && j<n)\\n        {\\n            if(name[i]==typed[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(i>0 && name[i-1]==typed[j])\\n            {\\n                j++;\\n            }\\n            else\\n\\n            return false;\\n        }\\n        \\n        while(j<n)\\n        {\\n            if(name[i-1]!=typed[j])\\n            return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n   @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "kasukurthibhargav",
                        "content": "while(j<n)\\n    {\\n        if(name[i-1]!=typed[j])\\n        return false;\\n        j++;\\n    }\\n    return true;\\n}\\n\\n\\nreplace this snippet to \\nif( i == name.length()){\\n            return true;\\n        }\\n        return true;"
                    },
                    {
                        "username": "shashank_maikhuri",
                        "content": "You could just add a check if(i<m) after the while loop is exited and if that\\'s the case this means that there are still some characters in name which were not in typed hence it should return false.\\n\\nif(i<m){return false;}"
                    },
                    {
                        "username": "kishor_123",
                        "content": "put in 2nd while(j<n || i<n) because \"pyplrz\" \"i\" is on z and \"i\" still not completed just trace it you know"
                    },
                    {
                        "username": "IOseph",
                        "content": "One of the more simple questions in the category easy... As a hint, if you store the previous state (i.e. character) you can 'skip' it when you traverse `typed` and only increase the index for `typed` (and not `name`). Thanks for the interesting problem, especially the care (housekeeping) for the extra check for any tailing characters that could match the stored previous state."
                    },
                    {
                        "username": "ddvuser",
                        "content": "name = \"alex\" and typed = \"aaleexa\", why testcase expecting it to be False?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Simply because of the last 'a' in ``typed`` which is not a duplicate of the last 'x' in ``name``."
                    },
                    {
                        "username": "c0rt3s",
                        "content": "Even if you are stuck after applying two pointers, then you see my submission."
                    },
                    {
                        "username": "Msey",
                        "content": "this soulution is really pain in the.. head\\none of the most difficult I met at easy category"
                    },
                    {
                        "username": "arrowmaster1252",
                        "content": "All hail Regex"
                    }
                ]
            },
            {
                "id": 1857370,
                "content": [
                    {
                        "username": "rtrain",
                        "content": "Why is case two false im confused"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "name =\\n\"alex\"\\ntyped =\\n\"aaleexa\"\\n\\nwhy the expected output is false?"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "this had too many edge cases man!"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Hey Leetcode this is not at all an EASY question it should be a MEDIUM one."
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "why it is failing on the  following test case ?\\nname=\"pyplrz\"\\ntyped=\"ppyypllr\"\\n\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int m=name.size();\\n        int n=typed.size();\\n        if(name.length()>typed.length()) return false;\\n        \\n        int i=0,j=0;\\n        while(i<m && j<n)\\n        {\\n            if(name[i]==typed[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(i>0 && name[i-1]==typed[j])\\n            {\\n                j++;\\n            }\\n            else\\n\\n            return false;\\n        }\\n        \\n        while(j<n)\\n        {\\n            if(name[i-1]!=typed[j])\\n            return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n   @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "kasukurthibhargav",
                        "content": "while(j<n)\\n    {\\n        if(name[i-1]!=typed[j])\\n        return false;\\n        j++;\\n    }\\n    return true;\\n}\\n\\n\\nreplace this snippet to \\nif( i == name.length()){\\n            return true;\\n        }\\n        return true;"
                    },
                    {
                        "username": "shashank_maikhuri",
                        "content": "You could just add a check if(i<m) after the while loop is exited and if that\\'s the case this means that there are still some characters in name which were not in typed hence it should return false.\\n\\nif(i<m){return false;}"
                    },
                    {
                        "username": "kishor_123",
                        "content": "put in 2nd while(j<n || i<n) because \"pyplrz\" \"i\" is on z and \"i\" still not completed just trace it you know"
                    },
                    {
                        "username": "IOseph",
                        "content": "One of the more simple questions in the category easy... As a hint, if you store the previous state (i.e. character) you can 'skip' it when you traverse `typed` and only increase the index for `typed` (and not `name`). Thanks for the interesting problem, especially the care (housekeeping) for the extra check for any tailing characters that could match the stored previous state."
                    },
                    {
                        "username": "ddvuser",
                        "content": "name = \"alex\" and typed = \"aaleexa\", why testcase expecting it to be False?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Simply because of the last 'a' in ``typed`` which is not a duplicate of the last 'x' in ``name``."
                    },
                    {
                        "username": "c0rt3s",
                        "content": "Even if you are stuck after applying two pointers, then you see my submission."
                    },
                    {
                        "username": "Msey",
                        "content": "this soulution is really pain in the.. head\\none of the most difficult I met at easy category"
                    },
                    {
                        "username": "arrowmaster1252",
                        "content": "All hail Regex"
                    }
                ]
            },
            {
                "id": 1832951,
                "content": [
                    {
                        "username": "rtrain",
                        "content": "Why is case two false im confused"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "name =\\n\"alex\"\\ntyped =\\n\"aaleexa\"\\n\\nwhy the expected output is false?"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "this had too many edge cases man!"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Hey Leetcode this is not at all an EASY question it should be a MEDIUM one."
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "why it is failing on the  following test case ?\\nname=\"pyplrz\"\\ntyped=\"ppyypllr\"\\n\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int m=name.size();\\n        int n=typed.size();\\n        if(name.length()>typed.length()) return false;\\n        \\n        int i=0,j=0;\\n        while(i<m && j<n)\\n        {\\n            if(name[i]==typed[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(i>0 && name[i-1]==typed[j])\\n            {\\n                j++;\\n            }\\n            else\\n\\n            return false;\\n        }\\n        \\n        while(j<n)\\n        {\\n            if(name[i-1]!=typed[j])\\n            return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n   @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "kasukurthibhargav",
                        "content": "while(j<n)\\n    {\\n        if(name[i-1]!=typed[j])\\n        return false;\\n        j++;\\n    }\\n    return true;\\n}\\n\\n\\nreplace this snippet to \\nif( i == name.length()){\\n            return true;\\n        }\\n        return true;"
                    },
                    {
                        "username": "shashank_maikhuri",
                        "content": "You could just add a check if(i<m) after the while loop is exited and if that\\'s the case this means that there are still some characters in name which were not in typed hence it should return false.\\n\\nif(i<m){return false;}"
                    },
                    {
                        "username": "kishor_123",
                        "content": "put in 2nd while(j<n || i<n) because \"pyplrz\" \"i\" is on z and \"i\" still not completed just trace it you know"
                    },
                    {
                        "username": "IOseph",
                        "content": "One of the more simple questions in the category easy... As a hint, if you store the previous state (i.e. character) you can 'skip' it when you traverse `typed` and only increase the index for `typed` (and not `name`). Thanks for the interesting problem, especially the care (housekeeping) for the extra check for any tailing characters that could match the stored previous state."
                    },
                    {
                        "username": "ddvuser",
                        "content": "name = \"alex\" and typed = \"aaleexa\", why testcase expecting it to be False?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Simply because of the last 'a' in ``typed`` which is not a duplicate of the last 'x' in ``name``."
                    },
                    {
                        "username": "c0rt3s",
                        "content": "Even if you are stuck after applying two pointers, then you see my submission."
                    },
                    {
                        "username": "Msey",
                        "content": "this soulution is really pain in the.. head\\none of the most difficult I met at easy category"
                    },
                    {
                        "username": "arrowmaster1252",
                        "content": "All hail Regex"
                    }
                ]
            },
            {
                "id": 1810042,
                "content": [
                    {
                        "username": "rtrain",
                        "content": "Why is case two false im confused"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "name =\\n\"alex\"\\ntyped =\\n\"aaleexa\"\\n\\nwhy the expected output is false?"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "this had too many edge cases man!"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Hey Leetcode this is not at all an EASY question it should be a MEDIUM one."
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "why it is failing on the  following test case ?\\nname=\"pyplrz\"\\ntyped=\"ppyypllr\"\\n\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int m=name.size();\\n        int n=typed.size();\\n        if(name.length()>typed.length()) return false;\\n        \\n        int i=0,j=0;\\n        while(i<m && j<n)\\n        {\\n            if(name[i]==typed[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(i>0 && name[i-1]==typed[j])\\n            {\\n                j++;\\n            }\\n            else\\n\\n            return false;\\n        }\\n        \\n        while(j<n)\\n        {\\n            if(name[i-1]!=typed[j])\\n            return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n   @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "kasukurthibhargav",
                        "content": "while(j<n)\\n    {\\n        if(name[i-1]!=typed[j])\\n        return false;\\n        j++;\\n    }\\n    return true;\\n}\\n\\n\\nreplace this snippet to \\nif( i == name.length()){\\n            return true;\\n        }\\n        return true;"
                    },
                    {
                        "username": "shashank_maikhuri",
                        "content": "You could just add a check if(i<m) after the while loop is exited and if that\\'s the case this means that there are still some characters in name which were not in typed hence it should return false.\\n\\nif(i<m){return false;}"
                    },
                    {
                        "username": "kishor_123",
                        "content": "put in 2nd while(j<n || i<n) because \"pyplrz\" \"i\" is on z and \"i\" still not completed just trace it you know"
                    },
                    {
                        "username": "IOseph",
                        "content": "One of the more simple questions in the category easy... As a hint, if you store the previous state (i.e. character) you can 'skip' it when you traverse `typed` and only increase the index for `typed` (and not `name`). Thanks for the interesting problem, especially the care (housekeeping) for the extra check for any tailing characters that could match the stored previous state."
                    },
                    {
                        "username": "ddvuser",
                        "content": "name = \"alex\" and typed = \"aaleexa\", why testcase expecting it to be False?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Simply because of the last 'a' in ``typed`` which is not a duplicate of the last 'x' in ``name``."
                    },
                    {
                        "username": "c0rt3s",
                        "content": "Even if you are stuck after applying two pointers, then you see my submission."
                    },
                    {
                        "username": "Msey",
                        "content": "this soulution is really pain in the.. head\\none of the most difficult I met at easy category"
                    },
                    {
                        "username": "arrowmaster1252",
                        "content": "All hail Regex"
                    }
                ]
            },
            {
                "id": 1769635,
                "content": [
                    {
                        "username": "rtrain",
                        "content": "Why is case two false im confused"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "name =\\n\"alex\"\\ntyped =\\n\"aaleexa\"\\n\\nwhy the expected output is false?"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "this had too many edge cases man!"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Hey Leetcode this is not at all an EASY question it should be a MEDIUM one."
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "why it is failing on the  following test case ?\\nname=\"pyplrz\"\\ntyped=\"ppyypllr\"\\n\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int m=name.size();\\n        int n=typed.size();\\n        if(name.length()>typed.length()) return false;\\n        \\n        int i=0,j=0;\\n        while(i<m && j<n)\\n        {\\n            if(name[i]==typed[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(i>0 && name[i-1]==typed[j])\\n            {\\n                j++;\\n            }\\n            else\\n\\n            return false;\\n        }\\n        \\n        while(j<n)\\n        {\\n            if(name[i-1]!=typed[j])\\n            return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n   @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "kasukurthibhargav",
                        "content": "while(j<n)\\n    {\\n        if(name[i-1]!=typed[j])\\n        return false;\\n        j++;\\n    }\\n    return true;\\n}\\n\\n\\nreplace this snippet to \\nif( i == name.length()){\\n            return true;\\n        }\\n        return true;"
                    },
                    {
                        "username": "shashank_maikhuri",
                        "content": "You could just add a check if(i<m) after the while loop is exited and if that\\'s the case this means that there are still some characters in name which were not in typed hence it should return false.\\n\\nif(i<m){return false;}"
                    },
                    {
                        "username": "kishor_123",
                        "content": "put in 2nd while(j<n || i<n) because \"pyplrz\" \"i\" is on z and \"i\" still not completed just trace it you know"
                    },
                    {
                        "username": "IOseph",
                        "content": "One of the more simple questions in the category easy... As a hint, if you store the previous state (i.e. character) you can 'skip' it when you traverse `typed` and only increase the index for `typed` (and not `name`). Thanks for the interesting problem, especially the care (housekeeping) for the extra check for any tailing characters that could match the stored previous state."
                    },
                    {
                        "username": "ddvuser",
                        "content": "name = \"alex\" and typed = \"aaleexa\", why testcase expecting it to be False?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Simply because of the last 'a' in ``typed`` which is not a duplicate of the last 'x' in ``name``."
                    },
                    {
                        "username": "c0rt3s",
                        "content": "Even if you are stuck after applying two pointers, then you see my submission."
                    },
                    {
                        "username": "Msey",
                        "content": "this soulution is really pain in the.. head\\none of the most difficult I met at easy category"
                    },
                    {
                        "username": "arrowmaster1252",
                        "content": "All hail Regex"
                    }
                ]
            },
            {
                "id": 1709483,
                "content": [
                    {
                        "username": "rtrain",
                        "content": "Why is case two false im confused"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "name =\\n\"alex\"\\ntyped =\\n\"aaleexa\"\\n\\nwhy the expected output is false?"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "this had too many edge cases man!"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Hey Leetcode this is not at all an EASY question it should be a MEDIUM one."
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "why it is failing on the  following test case ?\\nname=\"pyplrz\"\\ntyped=\"ppyypllr\"\\n\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int m=name.size();\\n        int n=typed.size();\\n        if(name.length()>typed.length()) return false;\\n        \\n        int i=0,j=0;\\n        while(i<m && j<n)\\n        {\\n            if(name[i]==typed[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(i>0 && name[i-1]==typed[j])\\n            {\\n                j++;\\n            }\\n            else\\n\\n            return false;\\n        }\\n        \\n        while(j<n)\\n        {\\n            if(name[i-1]!=typed[j])\\n            return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n   @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "kasukurthibhargav",
                        "content": "while(j<n)\\n    {\\n        if(name[i-1]!=typed[j])\\n        return false;\\n        j++;\\n    }\\n    return true;\\n}\\n\\n\\nreplace this snippet to \\nif( i == name.length()){\\n            return true;\\n        }\\n        return true;"
                    },
                    {
                        "username": "shashank_maikhuri",
                        "content": "You could just add a check if(i<m) after the while loop is exited and if that\\'s the case this means that there are still some characters in name which were not in typed hence it should return false.\\n\\nif(i<m){return false;}"
                    },
                    {
                        "username": "kishor_123",
                        "content": "put in 2nd while(j<n || i<n) because \"pyplrz\" \"i\" is on z and \"i\" still not completed just trace it you know"
                    },
                    {
                        "username": "IOseph",
                        "content": "One of the more simple questions in the category easy... As a hint, if you store the previous state (i.e. character) you can 'skip' it when you traverse `typed` and only increase the index for `typed` (and not `name`). Thanks for the interesting problem, especially the care (housekeeping) for the extra check for any tailing characters that could match the stored previous state."
                    },
                    {
                        "username": "ddvuser",
                        "content": "name = \"alex\" and typed = \"aaleexa\", why testcase expecting it to be False?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Simply because of the last 'a' in ``typed`` which is not a duplicate of the last 'x' in ``name``."
                    },
                    {
                        "username": "c0rt3s",
                        "content": "Even if you are stuck after applying two pointers, then you see my submission."
                    },
                    {
                        "username": "Msey",
                        "content": "this soulution is really pain in the.. head\\none of the most difficult I met at easy category"
                    },
                    {
                        "username": "arrowmaster1252",
                        "content": "All hail Regex"
                    }
                ]
            },
            {
                "id": 1692603,
                "content": [
                    {
                        "username": "rtrain",
                        "content": "Why is case two false im confused"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "name =\\n\"alex\"\\ntyped =\\n\"aaleexa\"\\n\\nwhy the expected output is false?"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "this had too many edge cases man!"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Hey Leetcode this is not at all an EASY question it should be a MEDIUM one."
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "why it is failing on the  following test case ?\\nname=\"pyplrz\"\\ntyped=\"ppyypllr\"\\n\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int m=name.size();\\n        int n=typed.size();\\n        if(name.length()>typed.length()) return false;\\n        \\n        int i=0,j=0;\\n        while(i<m && j<n)\\n        {\\n            if(name[i]==typed[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(i>0 && name[i-1]==typed[j])\\n            {\\n                j++;\\n            }\\n            else\\n\\n            return false;\\n        }\\n        \\n        while(j<n)\\n        {\\n            if(name[i-1]!=typed[j])\\n            return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n   @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "kasukurthibhargav",
                        "content": "while(j<n)\\n    {\\n        if(name[i-1]!=typed[j])\\n        return false;\\n        j++;\\n    }\\n    return true;\\n}\\n\\n\\nreplace this snippet to \\nif( i == name.length()){\\n            return true;\\n        }\\n        return true;"
                    },
                    {
                        "username": "shashank_maikhuri",
                        "content": "You could just add a check if(i<m) after the while loop is exited and if that\\'s the case this means that there are still some characters in name which were not in typed hence it should return false.\\n\\nif(i<m){return false;}"
                    },
                    {
                        "username": "kishor_123",
                        "content": "put in 2nd while(j<n || i<n) because \"pyplrz\" \"i\" is on z and \"i\" still not completed just trace it you know"
                    },
                    {
                        "username": "IOseph",
                        "content": "One of the more simple questions in the category easy... As a hint, if you store the previous state (i.e. character) you can 'skip' it when you traverse `typed` and only increase the index for `typed` (and not `name`). Thanks for the interesting problem, especially the care (housekeeping) for the extra check for any tailing characters that could match the stored previous state."
                    },
                    {
                        "username": "ddvuser",
                        "content": "name = \"alex\" and typed = \"aaleexa\", why testcase expecting it to be False?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Simply because of the last 'a' in ``typed`` which is not a duplicate of the last 'x' in ``name``."
                    },
                    {
                        "username": "c0rt3s",
                        "content": "Even if you are stuck after applying two pointers, then you see my submission."
                    },
                    {
                        "username": "Msey",
                        "content": "this soulution is really pain in the.. head\\none of the most difficult I met at easy category"
                    },
                    {
                        "username": "arrowmaster1252",
                        "content": "All hail Regex"
                    }
                ]
            },
            {
                "id": 1671035,
                "content": [
                    {
                        "username": "rtrain",
                        "content": "Why is case two false im confused"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "name =\\n\"alex\"\\ntyped =\\n\"aaleexa\"\\n\\nwhy the expected output is false?"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "this had too many edge cases man!"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Hey Leetcode this is not at all an EASY question it should be a MEDIUM one."
                    },
                    {
                        "username": "nitishrawat2002",
                        "content": "why it is failing on the  following test case ?\\nname=\"pyplrz\"\\ntyped=\"ppyypllr\"\\n\\nclass Solution {\\npublic:\\n    bool isLongPressedName(string name, string typed) {\\n        int m=name.size();\\n        int n=typed.size();\\n        if(name.length()>typed.length()) return false;\\n        \\n        int i=0,j=0;\\n        while(i<m && j<n)\\n        {\\n            if(name[i]==typed[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if(i>0 && name[i-1]==typed[j])\\n            {\\n                j++;\\n            }\\n            else\\n\\n            return false;\\n        }\\n        \\n        while(j<n)\\n        {\\n            if(name[i-1]!=typed[j])\\n            return false;\\n            j++;\\n        }\\n        return true;\\n    }\\n};\\n   @[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "kasukurthibhargav",
                        "content": "while(j<n)\\n    {\\n        if(name[i-1]!=typed[j])\\n        return false;\\n        j++;\\n    }\\n    return true;\\n}\\n\\n\\nreplace this snippet to \\nif( i == name.length()){\\n            return true;\\n        }\\n        return true;"
                    },
                    {
                        "username": "shashank_maikhuri",
                        "content": "You could just add a check if(i<m) after the while loop is exited and if that\\'s the case this means that there are still some characters in name which were not in typed hence it should return false.\\n\\nif(i<m){return false;}"
                    },
                    {
                        "username": "kishor_123",
                        "content": "put in 2nd while(j<n || i<n) because \"pyplrz\" \"i\" is on z and \"i\" still not completed just trace it you know"
                    },
                    {
                        "username": "IOseph",
                        "content": "One of the more simple questions in the category easy... As a hint, if you store the previous state (i.e. character) you can 'skip' it when you traverse `typed` and only increase the index for `typed` (and not `name`). Thanks for the interesting problem, especially the care (housekeeping) for the extra check for any tailing characters that could match the stored previous state."
                    },
                    {
                        "username": "ddvuser",
                        "content": "name = \"alex\" and typed = \"aaleexa\", why testcase expecting it to be False?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Simply because of the last 'a' in ``typed`` which is not a duplicate of the last 'x' in ``name``."
                    },
                    {
                        "username": "c0rt3s",
                        "content": "Even if you are stuck after applying two pointers, then you see my submission."
                    },
                    {
                        "username": "Msey",
                        "content": "this soulution is really pain in the.. head\\none of the most difficult I met at easy category"
                    },
                    {
                        "username": "arrowmaster1252",
                        "content": "All hail Regex"
                    }
                ]
            }
        ]
    }
]