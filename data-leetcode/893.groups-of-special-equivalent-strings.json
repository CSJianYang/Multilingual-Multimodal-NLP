[
    {
        "title": "Groups of Special-Equivalent Strings",
        "question_content": "You are given an array of strings of the same length words.\nIn one move, you can swap any two even indexed characters or any two odd indexed characters of a string words[i].\nTwo strings words[i] and words[j] are special-equivalent if after any number of moves, words[i] == words[j].\n\n\tFor example, words[i] = \"zzxy\" and words[j] = \"xyzz\" are special-equivalent because we may make the moves \"zzxy\" -> \"xzzy\" -> \"xyzz\".\n\nA group of special-equivalent strings from words is a non-empty subset of words such that:\n\n\tEvery pair of strings in the group are special equivalent, and\n\tThe group is the largest size possible (i.e., there is not a string words[i] not in the group such that words[i] is special-equivalent to every string in the group).\n\nReturn the number of groups of special-equivalent strings from words.\n&nbsp;\nExample 1:\n\nInput: words = [\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]\nOutput: 3\nExplanation: \nOne group is [\"abcd\", \"cdab\", \"cbad\"], since they are all pairwise special equivalent, and none of the other strings is all pairwise special equivalent to these.\nThe other two groups are [\"xyzz\", \"zzxy\"] and [\"zzyx\"].\nNote that in particular, \"zzxy\" is not special equivalent to \"zzyx\".\n\nExample 2:\n\nInput: words = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\nOutput: 3\n\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 1000\n\t1 <= words[i].length <= 20\n\twords[i] consist of lowercase English letters.\n\tAll the strings are of the same length.",
        "solutions": [
            {
                "id": 163413,
                "title": "java-concise-set-solution",
                "content": "For each String, we generate it\\'s corresponding signature, and add it to the set.\\nIn the end, we return the size of the set.\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set= new HashSet<>();\\n        for (String s: A){\\n            int[] odd= new int[26];\\n            int[] even= new int[26];\\n            for (int i=0; i<s.length(); i++){\\n                if (i%2==1) odd[s.charAt(i)-\\'a\\']++;\\n                else even[s.charAt(i)-\\'a\\']++;\\n            }\\n            String sig= Arrays.toString(odd)+Arrays.toString(even);\\n            set.add(sig);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set= new HashSet<>();\\n        for (String s: A){\\n            int[] odd= new int[26];\\n            int[] even= new int[26];\\n            for (int i=0; i<s.length(); i++){\\n                if (i%2==1) odd[s.charAt(i)-\\'a\\']++;\\n                else even[s.charAt(i)-\\'a\\']++;\\n            }\\n            String sig= Arrays.toString(odd)+Arrays.toString(even);\\n            set.add(sig);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163547,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A):\\n        return len(set(\"\".join(sorted(s[0::2])) + \"\".join(sorted(s[1::2])) for s in A))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A):\\n        return len(set(\"\".join(sorted(s[0::2])) + \"\".join(sorted(s[1::2])) for s in A))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163412,
                "title": "c-simple-solution",
                "content": "**General Idea:**\\n\\n1. Split strings in two to substrings, 1 with even indexed characters, and 1 with odd\\n2. Sort the two substrings (We do this because if you can swap on string with another, when sorted they will equal each other because they must have the same characters)\\n3. Insert your pair of strings into set, this will keep track of the unique \"groups\"\\n4. Rerturn the size of your set\\n\\nCheck out the video solution and explanation (for C++, Java, Python and BASH) here: https://youtu.be/WJ4NtyrakT0\\n```\\nint numSpecialEquivGroups(vector<string>& A) {\\n    set<pair<string,string>> s;\\n    for (const auto& w : A) {\\n        pair<string,string> p;\\n        for (int i = 0; i < w.size (); ++i) {\\n            if (i % 2) p.first  += w[i];\\n            else       p.second += w[i];\\n        }\\n        sort (p.first.begin  (), p.first.end ());\\n        sort (p.second.begin (), p.second.end ());\\n        s.insert (p);\\n    }\\n    return s.size ();\\n}",
                "solutionTags": [],
                "code": "**General Idea:**\\n\\n1. Split strings in two to substrings, 1 with even indexed characters, and 1 with odd\\n2. Sort the two substrings (We do this because if you can swap on string with another, when sorted they will equal each other because they must have the same characters)\\n3. Insert your pair of strings into set, this will keep track of the unique \"groups\"\\n4. Rerturn the size of your set\\n\\nCheck out the video solution and explanation (for C++, Java, Python and BASH) here: https://youtu.be/WJ4NtyrakT0\\n```\\nint numSpecialEquivGroups(vector<string>& A) {\\n    set<pair<string,string>> s;\\n    for (const auto& w : A) {\\n        pair<string,string> p;\\n        for (int i = 0; i < w.size (); ++i) {\\n            if (i % 2) p.first  += w[i];\\n            else       p.second += w[i];\\n        }\\n        sort (p.first.begin  (), p.first.end ());\\n        sort (p.second.begin (), p.second.end ());\\n        s.insert (p);\\n    }\\n    return s.size ();\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 358795,
                "title": "python3-detail-explanation-of-special-equivalent",
                "content": "* The point here is to understand the following requirement:\\nA move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j].\\nDon\\'t trap your thoughts by the word \\'swap\\'.\\nYour goal is how to identify the equivalent strings. \\n* There are two possible outcomes of i%2: 1 or 0. i is the index of the input string.\\n\\tif i % 2 ==1: i = 1,3,5,7 ... in other words, i is odd number. In other words, the order of the odd index\\'s value doesn\\'t matter here. You can swap them.\\n\\tif i % 2 ==0: i = 0,2,4,6 ... in other words, i is even number. In other words, the order of the even index\\'s value doesn\\'t matter here. You can swap them.\\n*  So sort the string\\'s odd index elements, and sort the string\\'s even index elements and combine them to create a new string called \"sort_string.\" If two string has the same \"sort_string,\" they are the special-equivalent strings.\\n```\\nA = [\"abcd\",\"cdab\",\"adcb\",\"cbad\"]\\n      ### sort odd index element      | sort even index element\\n\"abcd\" :              bd              |               ac\\n\"cbad\" :              bd              |               ac\\n\"adcb\" :              bd              |               ac\\n\"cdab\" :              bd              |               ac\\n# so they are equivalent strings\\n```\\n\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        res = set()\\n        for s in A:\\n            sort_odd_even = \\'\\'.join(sorted(s[1::2]) + sorted(s[::2]))\\n            res.add(sort_odd_even)\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nA = [\"abcd\",\"cdab\",\"adcb\",\"cbad\"]\\n      ### sort odd index element      | sort even index element\\n\"abcd\" :              bd              |               ac\\n\"cbad\" :              bd              |               ac\\n\"adcb\" :              bd              |               ac\\n\"cdab\" :              bd              |               ac\\n# so they are equivalent strings\\n```\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        res = set()\\n        for s in A:\\n            sort_odd_even = \\'\\'.join(sorted(s[1::2]) + sorted(s[::2]))\\n            res.add(sort_odd_even)\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163471,
                "title": "python-extremely-simple-solution",
                "content": "```\\nclass Solution:\\n\\tdef numSpecialEquivGroups(self, A):\\n\\t\\td = collections.defaultdict(int)\\n\\t\\tfor w in A:\\n\\t\\t\\teven = \\'\\'.join(sorted(w[0::2]))\\n\\t\\t\\todd = \\'\\'.join(sorted(w[1::2]))\\n\\t\\t\\td[(even, odd)] += 1\\n\\t\\t\\n\\t\\treturn len(d)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef numSpecialEquivGroups(self, A):\\n\\t\\td = collections.defaultdict(int)\\n\\t\\tfor w in A:\\n\\t\\t\\teven = \\'\\'.join(sorted(w[0::2]))\\n\\t\\t\\todd = \\'\\'.join(sorted(w[1::2]))\\n\\t\\t\\td[(even, odd)] += 1\\n\\t\\t\\n\\t\\treturn len(d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163767,
                "title": "straightforward-java-solution",
                "content": "map1 - the distribution of counts of the characters at even positions\\nmap2 - the distribution of counts of the characters at odd positions\\nset - how many unique distributions\\n\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : A) {\\n            int[] map1 = new int[256];\\n            int[] map2 = new int[256];\\n            for (int i = 0; i < s.length(); i++) {\\n                if (i % 2 == 0) {\\n                    map1[s.charAt(i)]++;\\n                } else {\\n                    map2[s.charAt(i)]++;\\n                }\\n            }\\n            set.add(Arrays.toString(map1) + \" \" + Arrays.toString(map2));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : A) {\\n            int[] map1 = new int[256];\\n            int[] map2 = new int[256];\\n            for (int i = 0; i < s.length(); i++) {\\n                if (i % 2 == 0) {\\n                    map1[s.charAt(i)]++;\\n                } else {\\n                    map2[s.charAt(i)]++;\\n                }\\n            }\\n            set.add(Arrays.toString(map1) + \" \" + Arrays.toString(map2));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536199,
                "title": "python-o-n-k-lg-k-sol-by-signature-90-w-hint",
                "content": "Python sol. by signature. \\n\\n---\\n\\n**Hint**:\\n\\nThink of the concept for  **anagram** judgement.\\n\\nWhat we need in this challenge is to verify the so-called \"**special equivalent**\", \\nwhich means even-indexed substring of input is anagram and odd-indexed substring of input is another anagram.\\n\\nWe can verify by signature checking.\\n\\nDefine **signature** as the **sorted even-indexed substring and odd-indexed substring** in alphabetic order.\\n\\nIf signature( s1 ) == signature( s2 ),\\nthen s1 and s2 are special equivalent.\\n\\n---\\n\\nFor example:\\ns1 = \\'**a**b**c**d\\', and s2 = \\'**c**d**a**b\\'\\n\\nThen, signature( s1 ) is \\'acbd\\', and signature( s2 ) is the same.\\nTherefore, s1 and s2 are special equivalent.\\n\\n---\\n\\n**Algorithm**:\\n\\nRearrange each input string into the form of signature.\\n\\nThe **number of unique signature** is the **number of grouping** for special equivalent.\\n\\n---\\n\\n**Implementation**:\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        \\n        signature = set()\\n        \\n        # Use pair of sorted even substring and odd substring as unique key\\n        \\n        for idx, s in enumerate(A):\\n            signature.add( \\'\\'.join( sorted( s[::2] ) ) + \\'\\'.join( sorted( s[1::2] ) )  )\\n        \\n        return len( signature )\\n```\\n\\n---\\n\\nRelated challenge:\\n\\n[Leetcode #49 Group Anagrms](https://leetcode.com/problems/group-anagrams/)\\n\\n[Leetcode #242 Valid Anagram](https://leetcode.com/problems/valid-anagram/)\\n\\n[Leetcode #438 Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about hash-set: set()](https://docs.python.org/3/tutorial/datastructures.html#sets)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        \\n        signature = set()\\n        \\n        # Use pair of sorted even substring and odd substring as unique key\\n        \\n        for idx, s in enumerate(A):\\n            signature.add( \\'\\'.join( sorted( s[::2] ) ) + \\'\\'.join( sorted( s[1::2] ) )  )\\n        \\n        return len( signature )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164481,
                "title": "python-1-liner-beats-100-of-other-submissions",
                "content": "The idea is to convert all strings to some sort of canonical representation. Since all characters at even and odd position can be shuffled in any way, sorting them will produce the desired result - strings like `cba` will be converted to `abc` and `dcba` to `badc`. Having all strings converted to their canonical form, a set can be used to remove the duplicates and its length will produce the desired result.\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        return len({tuple(sorted(s[0::2]) + sorted(s[1::2])) for s in A})\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        return len({tuple(sorted(s[0::2]) + sorted(s[1::2])) for s in A})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163891,
                "title": "c-create-a-signature-for-each-string",
                "content": "We can quickly notice that by grouping odd and even position, sorting them and concatenating them, all the special - equivalent string will have the same signature. We can then use a hash set to capture the signature (which automatically de-duplicates) and we can return the hashset size.\\nThe constraints of the problem easily allow this.\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> st;\\n        for(auto &w : A) {\\n            string odd, even;\\n            for(int i=0;i<w.size();i+=2) even.push_back(w[i]);\\n            for(int i=1;i<w.size();i+=2) odd.push_back(w[i]);\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> st;\\n        for(auto &w : A) {\\n            string odd, even;\\n            for(int i=0;i<w.size();i+=2) even.push_back(w[i]);\\n            for(int i=1;i<w.size();i+=2) odd.push_back(w[i]);\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431332,
                "title": "c-set-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words)\\n    {    \\n        set<pair<string,string>> s;\\n        for(auto &w:words)\\n        {\\n            string p,q;\\n            for(int i=0;i<w.size();i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    p+=w[i];\\n                }\\n                else\\n                {\\n                    q+=w[i];\\n                }\\n            }\\n            sort(p.begin(),p.end());\\n            sort(q.begin(),q.end());\\n            s.insert({p,q});\\n        }\\n        return s.size();\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words)\\n    {    \\n        set<pair<string,string>> s;\\n        for(auto &w:words)\\n        {\\n            string p,q;\\n            for(int i=0;i<w.size();i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    p+=w[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 512294,
                "title": "javascript-easy-solution",
                "content": "```javascript\\n/**\\n * @param {string[]} A\\n * @return {number}\\n */\\nvar numSpecialEquivGroups = function(A) {\\n  const groupSet = new Set();\\n  A.forEach(a => groupSet.add(transform(a)));\\n  return groupSet.size;\\n};\\n\\nconst transform = S => {\\n  const even = S.split(\\'\\').filter((_, i) => i % 2 === 0);\\n  const odd = S.split(\\'\\').filter((_, i) => i % 2 === 1);\\n  even.sort();\\n  odd.sort();\\n  return `${even.join(\\'\\')}${odd.join(\\'\\')}`;\\n};\\n```\\n\\n* 36/36 cases passed (64 ms)\\n* Your runtime beats 100 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (37.5 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string[]} A\\n * @return {number}\\n */\\nvar numSpecialEquivGroups = function(A) {\\n  const groupSet = new Set();\\n  A.forEach(a => groupSet.add(transform(a)));\\n  return groupSet.size;\\n};\\n\\nconst transform = S => {\\n  const even = S.split(\\'\\').filter((_, i) => i % 2 === 0);\\n  const odd = S.split(\\'\\').filter((_, i) => i % 2 === 1);\\n  even.sort();\\n  odd.sort();\\n  return `${even.join(\\'\\')}${odd.join(\\'\\')}`;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359733,
                "title": "bug-in-leetcode-itself-check-it-out-lol",
                "content": "![image](https://assets.leetcode.com/users/ssemichev/image_1565936717.png)\\n![image](https://assets.leetcode.com/users/ssemichev/image_1565936718.png)\\nSubmission tab gives wrong answer and output 5. But Debug tab (and my IDE) has correct answer 1. \\n\\nSolution:\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] input) {\\n        int[] inx = new int[input.length];\\n        int group = 1;\\n        for(int i = 0; i < input.length; i++){\\n          if(inx[i] != 0) continue;\\n          inx[i] = group++;\\n          for(int j = i + 1; j < input.length; j++ ) {\\n            if (j != 0 && eq(input[i], input[j])) {\\n              inx[i] = group;\\n              inx[j] = group;\\n            }\\n          }\\n        }\\n        return group - 1;\\n    }\\n    \\n    private boolean eq(String a, String b){\\n        if(a.equals(b)) return true;\\n        \\n        char[] buff = b.toCharArray();\\n        for(int i = 0; i < buff.length; i++){\\n          int j = i + 2;\\n          while(j < buff.length && (i % 2 != j % 2)) j++;\\n          if(j < buff.length){\\n            if(buff[i] == a.charAt(i) && buff[j] == a.charAt(j)) continue;\\n            char t = buff[i];\\n            buff[i] = buff[j];\\n            buff[j] = t;\\n            if(a.equals(new String(buff)))\\n              return true;\\n          }\\n        }\\n        return false;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] input) {\\n        int[] inx = new int[input.length];\\n        int group = 1;\\n        for(int i = 0; i < input.length; i++){\\n          if(inx[i] != 0) continue;\\n          inx[i] = group++;\\n          for(int j = i + 1; j < input.length; j++ ) {\\n            if (j != 0 && eq(input[i], input[j])) {\\n              inx[i] = group;\\n              inx[j] = group;\\n            }\\n          }\\n        }\\n        return group - 1;\\n    }\\n    \\n    private boolean eq(String a, String b){\\n        if(a.equals(b)) return true;\\n        \\n        char[] buff = b.toCharArray();\\n        for(int i = 0; i < buff.length; i++){\\n          int j = i + 2;\\n          while(j < buff.length && (i % 2 != j % 2)) j++;\\n          if(j < buff.length){\\n            if(buff[i] == a.charAt(i) && buff[j] == a.charAt(j)) continue;\\n            char t = buff[i];\\n            buff[i] = buff[j];\\n            buff[j] = t;\\n            if(a.equals(new String(buff)))\\n              return true;\\n          }\\n        }\\n        return false;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173803,
                "title": "c-using-counting-sort-since-string-contains-english-letters",
                "content": "Sept. 23, 2018\\nIt is an easy level string algorithm. The swap of letters should be restricted to odd index or even index two groups. All letters in odd index can be swapped, likewise as even index. \\n\\n```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] A)\\n        {\\n            if (A == null)\\n                return 0;\\n\\n            var keys = new HashSet<string>(); \\n\\n            foreach(var item in A)\\n            {\\n                var countLetterEven = new int[26];\\n                var countLetterOdd  = new int[26];\\n\\n                for (int i = 0; i < item.Length; i++ )\\n                {\\n                    var current = item[i];\\n                    var isEven = i % 2 == 0;\\n                    if (isEven)\\n                    {\\n                        countLetterEven[current - \\'a\\']++;\\n                    }\\n                    else\\n                        countLetterOdd[current - \\'a\\']++;                    \\n                }\\n\\n                var key = createKey(countLetterEven, countLetterOdd);\\n                if (!keys.Contains(key))\\n                    keys.Add(key);\\n            }\\n\\n            return keys.Count; \\n        }\\n\\n        private static string createKey(int[] even, int[] odd)\\n        {\\n            var key = \"\";\\n            for(int i = 0; i < 26; i++)\\n            {\\n                key += even[i] + \" \" + odd[i] +\";\";\\n            }\\n\\n            return key; \\n        }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] A)\\n        {\\n            if (A == null)\\n                return 0;\\n\\n            var keys = new HashSet<string>(); \\n\\n            foreach(var item in A)\\n            {\\n                var countLetterEven = new int[26];\\n                var countLetterOdd  = new int[26];\\n\\n                for (int i = 0; i < item.Length; i++ )\\n                {\\n                    var current = item[i];\\n                    var isEven = i % 2 == 0;\\n                    if (isEven)\\n                    {\\n                        countLetterEven[current - \\'a\\']++;\\n                    }\\n                    else\\n                        countLetterOdd[current - \\'a\\']++;                    \\n                }\\n\\n                var key = createKey(countLetterEven, countLetterOdd);\\n                if (!keys.Contains(key))\\n                    keys.Add(key);\\n            }\\n\\n            return keys.Count; \\n        }\\n\\n        private static string createKey(int[] even, int[] odd)\\n        {\\n            var key = \"\";\\n            for(int i = 0; i < 26; i++)\\n            {\\n                key += even[i] + \" \" + odd[i] +\";\";\\n            }\\n\\n            return key; \\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162198,
                "title": "c-893-groups-of-special-equivalent-strings",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> seen; \\n        for (auto word : A) {\\n            string even, odd; \\n            for (int i = 0; i < word.size(); ++i) {\\n                if (i&1) odd.push_back(word[i]); \\n                else even.push_back(word[i]); \\n            }\\n            sort(even.begin(), even.end()); \\n            sort(odd.begin(), odd.end()); \\n            seen.insert(even+odd); \\n        }\\n        return seen.size(); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> seen; \\n        for (auto word : A) {\\n            string even, odd; \\n            for (int i = 0; i < word.size(); ++i) {\\n                if (i&1) odd.push_back(word[i]); \\n                else even.push_back(word[i]); \\n            }\\n            sort(even.begin(), even.end()); \\n            sort(odd.begin(), odd.end()); \\n            seen.insert(even+odd); \\n        }\\n        return seen.size(); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860173,
                "title": "typescript-javascript-o-n-solution-w-detailed-comments-explanation",
                "content": "Forget what the problem is asking for a second. I\\'ll dumb it down. It took me too long and I overthought way too hard.\\n*Shout out to Fisher Coder (on youtube) for explaining the problem statement. He\\'s a legendary beast.*\\n\\nThe problem is **simply** asking how many strings are distinct, given you can swap any even-indexed characters, and swap any odd-indexed characters.\\n\\nExample: if you have **\"axbycz\"** and **\"czbyax\"**, these ARE specially EQUIVALENT. here is the reasoning: for odd index, we have counts {a: 1, b: 1, c:1} in both of them, and for even index we have {x: 1, y: 1, z: 1} for both of them.\\n\\n**solution:**\\n```\\nfunction numSpecialEquivGroups(A: string[]): number {\\n    // set to keep track of unique special equivalents\\n    const set: Set<string> = new Set();\\n    // iterate thru A\\n    for (let i = 0; i < A.length; i++) {\\n        // even and odd char counts\\n        const counts = [new Uint8Array(26), new Uint8Array(26)];\\n        // iterate thru this string, and fill counts\\n        for (let j = 0; j < A[i].length; j++) {\\n            // fill count on whether even or odd (0 index is even 1 is odd)\\n            counts[j % 2][A[i].charCodeAt(j) - 97]++;\\n        }\\n        // add to set as concatenation of both counts arrays\\n        set.add(counts[0].join(\\'\\') + counts[1].join(\\'\\'));\\n    }\\n\\n    // result is just size of set (number of unique special equivalents)\\n    return set.size;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction numSpecialEquivGroups(A: string[]): number {\\n    // set to keep track of unique special equivalents\\n    const set: Set<string> = new Set();\\n    // iterate thru A\\n    for (let i = 0; i < A.length; i++) {\\n        // even and odd char counts\\n        const counts = [new Uint8Array(26), new Uint8Array(26)];\\n        // iterate thru this string, and fill counts\\n        for (let j = 0; j < A[i].length; j++) {\\n            // fill count on whether even or odd (0 index is even 1 is odd)\\n            counts[j % 2][A[i].charCodeAt(j) - 97]++;\\n        }\\n        // add to set as concatenation of both counts arrays\\n        set.add(counts[0].join(\\'\\') + counts[1].join(\\'\\'));\\n    }\\n\\n    // result is just size of set (number of unique special equivalents)\\n    return set.size;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 425999,
                "title": "java-easy-to-understand-solution",
                "content": "```\\npublic int numSpecialEquivGroups(String[] A) {\\n\\tHashSet<String> s = new HashSet<>();\\n\\tfor(String a : A) {\\n\\t\\tint[] odd = new int[26], even = new int[26];\\n\\t\\tfor(int i=0; i<a.length(); i++) {\\n\\t\\t\\tif(i%2==0)\\n\\t\\t\\t\\teven[a.charAt(i)-\\'a\\']++;\\n\\t\\t\\telse\\n\\t\\t\\t\\todd[a.charAt(i)-\\'a\\']++;\\n\\t\\t}\\n\\t\\ts.add(Arrays.toString(odd)+Arrays.toString(even));\\n\\t}\\n\\treturn s.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numSpecialEquivGroups(String[] A) {\\n\\tHashSet<String> s = new HashSet<>();\\n\\tfor(String a : A) {\\n\\t\\tint[] odd = new int[26], even = new int[26];\\n\\t\\tfor(int i=0; i<a.length(); i++) {\\n\\t\\t\\tif(i%2==0)\\n\\t\\t\\t\\teven[a.charAt(i)-\\'a\\']++;\\n\\t\\t\\telse\\n\\t\\t\\t\\todd[a.charAt(i)-\\'a\\']++;\\n\\t\\t}\\n\\t\\ts.add(Arrays.toString(odd)+Arrays.toString(even));\\n\\t}\\n\\treturn s.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2937150,
                "title": "python-3-5-lines-w-example-t-m-88-27",
                "content": "\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n                                                            #  Example: \\n        wSet = set()                                        #   words = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\n\\n        for word in words:                                  #           sorted((enu-   \\n            word = tuple(sorted((enumerate(word)),          #  word     merate word)         wSet\\n                           key = lambda x: (x[0]%2,x[1])))  #  \\u2013\\u2013\\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013         \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n            print(wSet)                                     #   abc     ((0,a),(2,c),(1,b))  {(a,c,b)}\\n            wSet.add(list(zip(*word))[1])                   #   acb     ((0,a),(2,b),(1,c))  {(a,c,b), (a,b,c)}\\n                                                            #   bac     ((0,b),(2,c),(1,a))  {(a,c,b), (a,b,c), (b,c,a)}\\n        return len(wSet)                                    #   bca     ((2,a),(0,b),(1,c))  {(a,c,b), (a,b,c), (b,c,a)}\\n                                                            #   cab     ((2,b),(0,c),(1,a))  {(a,c,b), (a,b,c), (b,c,a)}\\n                                                            #   cba     ((2,a),(0,c),(1,b))  {(a,c,b), (a,b,c), (b,c,a)}\\n```\\n[https://leetcode.com/problems/groups-of-special-equivalent-strings/submissions/863479817/](http://)\\n\\n\\nI could be wrong, but I think that time is *O*(*NlogN*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n                                                            #  Example: \\n        wSet = set()                                        #   words = [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\n\\n        for word in words:                                  #           sorted((enu-   \\n            word = tuple(sorted((enumerate(word)),          #  word     merate word)         wSet\\n                           key = lambda x: (x[0]%2,x[1])))  #  \\u2013\\u2013\\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013         \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n            print(wSet)                                     #   abc     ((0,a),(2,c),(1,b))  {(a,c,b)}\\n            wSet.add(list(zip(*word))[1])                   #   acb     ((0,a),(2,b),(1,c))  {(a,c,b), (a,b,c)}\\n                                                            #   bac     ((0,b),(2,c),(1,a))  {(a,c,b), (a,b,c), (b,c,a)}\\n        return len(wSet)                                    #   bca     ((2,a),(0,b),(1,c))  {(a,c,b), (a,b,c), (b,c,a)}\\n                                                            #   cab     ((2,b),(0,c),(1,a))  {(a,c,b), (a,b,c), (b,c,a)}\\n                                                            #   cba     ((2,a),(0,c),(1,b))  {(a,c,b), (a,b,c), (b,c,a)}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791670,
                "title": "c-easy-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int numSpecialEquivGroups(vector<string>& A) {\\n    set<pair<string,string>> s;\\n    for (const auto& w : A) {\\n        pair<string,string> p;\\n        for (int i = 0; i < w.size (); ++i) {\\n            if (i % 2) p.first  += w[i];\\n            else       p.second += w[i];\\n        }\\n        sort (p.first.begin  (), p.first.end ());\\n        sort (p.second.begin (), p.second.end ());\\n        s.insert (p);\\n    }\\n    return s.size ();\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int numSpecialEquivGroups(vector<string>& A) {\\n    set<pair<string,string>> s;\\n    for (const auto& w : A) {\\n        pair<string,string> p;\\n        for (int i = 0; i < w.size (); ++i) {\\n            if (i % 2) p.first  += w[i];\\n            else       p.second += w[i];\\n        }\\n        sort (p.first.begin  (), p.first.end ());\\n        sort (p.second.begin (), p.second.end ());\\n        s.insert (p);\\n    }\\n    return s.size ();\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176722,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n = words.size();\\n        unordered_map<string, int> um;\\n        for(string &word : words)\\n        {\\n            vector<int> even(26,0);\\n            vector<int> odd(26,0);\\n            for(int i = 0; i < word.size(); i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    even[word[i]-\\'a\\']++;\\n                }\\n                else\\n                {\\n                    odd[word[i]-\\'a\\']++;\\n                }\\n            }\\n            string str = \"\";\\n            for(int i = 0; i < 26; i++)\\n            {\\n                str += to_string(even[i]);\\n            }\\n            for(int i = 0; i < 26; i++)\\n            {\\n                str += to_string(odd[i]);\\n            }\\n            um[str]++;\\n        }\\n        return um.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n = words.size();\\n        unordered_map<string, int> um;\\n        for(string &word : words)\\n        {\\n            vector<int> even(26,0);\\n            vector<int> odd(26,0);\\n            for(int i = 0; i < word.size(); i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    even[word[i]-\\'a\\']++;\\n                }\\n                else\\n                {\\n                    odd[word[i]-\\'a\\']++;\\n                }\\n            }\\n            string str = \"\";\\n            for(int i = 0; i < 26; i++)\\n            {\\n                str += to_string(even[i]);\\n            }\\n            for(int i = 0; i < 26; i++)\\n            {\\n                str += to_string(odd[i]);\\n            }\\n            um[str]++;\\n        }\\n        return um.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074463,
                "title": "easy-fast-python-solution",
                "content": "```class Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        dic={}\\n        for i in range(len(A)):\\n            x = \\'\\'.join(sorted(A[i][0::2]))\\n            y = \\'\\'.join(sorted(A[i][1::2]))     \\n            if (x+y) not in dic:\\n                dic[x+y]=1\\n            else:\\n                dic[x+y]+=1\\n        return len(dic)\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        dic={}",
                "codeTag": "Java"
            },
            {
                "id": 962274,
                "title": "python-3-use-defaultdict-40ms-88-5",
                "content": "\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        #\\n        helper = defaultdict(int)\\n        for string in A:\\n            key = \"\".join(sorted(string[0::2])+sorted(string[1::2]))\\n            helper[key] += 1\\n        return len(helper)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        #\\n        helper = defaultdict(int)\\n        for string in A:\\n            key = \"\".join(sorted(string[0::2])+sorted(string[1::2]))\\n            helper[key] += 1\\n        return len(helper)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765248,
                "title": "simple-cpp-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\\n        unordered_set<string>mp;\\n        for(int i=0;i<A.size();i++)\\n        {\\n        string o=\"\";\\n        string e=\"\";\\n            for(int j=0;j<A[i].size();j++)\\n            {\\n                if(j%2==0)\\n                    e+=A[i][j];\\n                else\\n                    o+=A[i][j];\\n            }\\n            sort(o.begin(),o.end());\\n            sort(e.begin(),e.end());\\n            mp.insert(e+o);\\n        }\\n        return mp.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\\n        unordered_set<string>mp;\\n        for(int i=0;i<A.size();i++)\\n        {\\n        string o=\"\";\\n        string e=\"\";\\n            for(int j=0;j<A[i].size();j++)\\n            {\\n                if(j%2==0)\\n                    e+=A[i][j];\\n                else\\n                    o+=A[i][j];\\n            }\\n            sort(o.begin(),o.end());\\n            sort(e.begin(),e.end());\\n            mp.insert(e+o);\\n        }\\n        return mp.size();\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 641006,
                "title": "python-1-liner-and-5-liner-for-readability-explained",
                "content": "Since any even index can be switched with any other even index, and the same is true for any odd index pair, as long as two words share the same multiset of even-indexed letters and the same multiset of odd-indexed letters, then they are special-equivalent.  \\n\\nThat said, we can represent any multiset by the sorted even indexed letters concatenated with the sorted odd indexed letters:\\n\\n    \\'adcb\\' and \\'cdab\\'  represented by \\'bd\\' + \\'ac\\'  = \\'bdac\\'\\n\\t\\'abdc\\' respresented by \\'bc\\' + \\'ad\\' = \\'bcad\\'\\n\\nEncode each word (using the method above) and add it to a set.  The length of the set will then be equal the number of special equivalent families in A.\\n\\n### 5 Liner (for readability)\\n\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        codes = set()\\n        for word in A:\\n            code = \\'\\'.join(sorted(word[::2])) + \\'\\'.join(sorted(word[1::2]))\\n            codes.add(code)\\n        return len(codes)\\n```\\n\\n### One Liner\\n\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set([\\'\\'.join(sorted(word[::2])) + \\'\\'.join(sorted(word[1::2])) for word in A]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        codes = set()\\n        for word in A:\\n            code = \\'\\'.join(sorted(word[::2])) + \\'\\'.join(sorted(word[1::2]))\\n            codes.add(code)\\n        return len(codes)\\n```\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set([\\'\\'.join(sorted(word[::2])) + \\'\\'.join(sorted(word[1::2])) for word in A]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474747,
                "title": "runtime-8-ms-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_map<string, int> count;\\n        for(auto s : A)\\n        {\\n            string even = \"\", odd = \"\";\\n            for(int i = 0; i < s.size(); i++)\\n            {\\n                if(i % 2 == 0)\\n                    even += s[i];\\n                else odd += s[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            string key = even + odd;\\n            count[key]++;\\n        }\\n        return count.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_map<string, int> count;\\n        for(auto s : A)\\n        {\\n            string even = \"\", odd = \"\";\\n            for(int i = 0; i < s.size(); i++)\\n            {\\n                if(i % 2 == 0)\\n                    even += s[i];\\n                else odd += s[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            string key = even + odd;\\n            count[key]++;\\n        }\\n        return count.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377831,
                "title": "java-2ms-solution-with-hashset-with-explanation",
                "content": "/*\\nJava Solution Beat 100% runtime and 100% memory\\n\\nit is kind of anagram problem.\\ntwo strings can only be Special-Equivalent when BOTH their odd letters  AND even letters are anagrams.\\n\\nso based on above logic, \\n1. we build hash value for each string, we sort odd position letters, even position letters of each string , since string is short, here only use simple O(n^2) compare logic to sort them.\\n2. the odd and even sorted string will be the hash of the string.\\n3. we add the hash into HashSet.  (HashSet.add(value) will return true if it is added, and return falsle is already has the value  in HashSet ), count how many values we added.\\n4. return the count.\\n*/\\n\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        HashSet<String> set = new HashSet<>();\\n        int result = 0;\\n        for(String str: A){            \\n            if(set.add(getHashBySwap(str.toCharArray()))) {\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private String getHashBySwap(char[] chars){\\n        for(int i=0; i<chars.length;i++){            \\n            for(int j=i+2;j<chars.length;){\\n                if(chars[i] > chars[j]) {\\n                    char temp = chars[j];\\n                    chars[j] = chars[i];  \\n                    chars[i] = temp;\\n                }\\n                j+=2;\\n            }\\n        }\\n        \\n        return String.valueOf(chars);        \\n    }   \\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        HashSet<String> set = new HashSet<>();\\n        int result = 0;\\n        for(String str: A){            \\n            if(set.add(getHashBySwap(str.toCharArray()))) {\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private String getHashBySwap(char[] chars){\\n        for(int i=0; i<chars.length;i++){            \\n            for(int j=i+2;j<chars.length;){\\n                if(chars[i] > chars[j]) {\\n                    char temp = chars[j];\\n                    chars[j] = chars[i];  \\n                    chars[i] = temp;\\n                }\\n                j+=2;\\n            }\\n        }\\n        \\n        return String.valueOf(chars);        \\n    }   \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345036,
                "title": "python-solution",
                "content": "\\n```\\ndef numSpecialEquivGroups(self, A):\\n\\t\"\"\"\\n\\t:type A: List[str]\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tres = set()\\n\\tfor s in A:\\n\\t\\ts = \\'\\'.join(sorted(s[::2]) + sorted(s[1::2]))\\n\\t\\tres.add(s)\\n\\treturn len(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef numSpecialEquivGroups(self, A):\\n\\t\"\"\"\\n\\t:type A: List[str]\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tres = set()\\n\\tfor s in A:\\n\\t\\ts = \\'\\'.join(sorted(s[::2]) + sorted(s[1::2]))\\n\\t\\tres.add(s)\\n\\treturn len(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 271486,
                "title": "java-6ms-solution-easy-to-understand-with-explanation",
                "content": "The basic idea is putting the signature of each string to a set, then the size of set is the number of groups.\\nSince each string only contains lowercase letters, we can use two arrays ```odd[26]``` and ```even[26]``` to represents the frequency of 26 lowercase letters on odd place and even place of a string repectively. \\nThe signature of a string is apparently ```Arrays.toString(odd) + Arrays.toString(even)```.\\nThe code is as following:\\n```\\npublic int numSpecialEquivGroups(String[] A) {\\n\\tSet<String> group = new HashSet<String>();\\n\\tfor(int i = 0; i < A.length; i++) \\n\\t\\tgroup.add(getSignature(A[i]));\\n\\treturn group.size();\\n}\\n\\npublic String getSignature(String s) {\\n\\tint odd[] = new int[26];\\n\\tint even[] = new int[26];\\n\\tfor(int i = 0; i < s.length(); i += 2) \\n\\t\\teven[s.charAt(i) - \\'a\\']++;\\n\\tfor(int i = 1; i < s.length(); i += 2)\\n\\t\\todd[s.charAt(i) - \\'a\\']++;\\n\\tStringBuilder sb = new StringBuilder(\"\");\\n\\tfor(int i = 0; i < 26; i++)\\n\\t\\tsb.append(odd[i]);\\n\\tfor(int i = 0; i < 26; i++)\\n\\t\\tsb.append(even[i]);\\n\\treturn sb.toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```odd[26]```\n```even[26]```\n```Arrays.toString(odd) + Arrays.toString(even)```\n```\\npublic int numSpecialEquivGroups(String[] A) {\\n\\tSet<String> group = new HashSet<String>();\\n\\tfor(int i = 0; i < A.length; i++) \\n\\t\\tgroup.add(getSignature(A[i]));\\n\\treturn group.size();\\n}\\n\\npublic String getSignature(String s) {\\n\\tint odd[] = new int[26];\\n\\tint even[] = new int[26];\\n\\tfor(int i = 0; i < s.length(); i += 2) \\n\\t\\teven[s.charAt(i) - \\'a\\']++;\\n\\tfor(int i = 1; i < s.length(); i += 2)\\n\\t\\todd[s.charAt(i) - \\'a\\']++;\\n\\tStringBuilder sb = new StringBuilder(\"\");\\n\\tfor(int i = 0; i < 26; i++)\\n\\t\\tsb.append(odd[i]);\\n\\tfor(int i = 0; i < 26; i++)\\n\\t\\tsb.append(even[i]);\\n\\treturn sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 192733,
                "title": "my-c-solution",
                "content": "s1 is the substring containing only characters on odd position\\ns2 is the substring containing only characters on even position\\nsort s1 and s2, use s1 + s2 as the key of that string\\ncompare the key of each string\\n```\\n#include <unordered_set>\\n#include <algorithm>\\nusing std::unordered_set;\\nclass Solution {\\npublic:\\n    string key(string s)\\n    {\\n        string s1 = \"\";\\n        string s2 = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(i % 2)\\n                s1 += s[i];\\n            else\\n                s2 += s[i];\\n        }\\n        std::sort(s1.begin(),s1.end());\\n        std::sort(s2.begin(),s2.end());\\n        return s1 + s2;\\n    }\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> sset;\\n        for(string s : A)\\n            sset.insert(key(s));\\n        return sset.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <unordered_set>\\n#include <algorithm>\\nusing std::unordered_set;\\nclass Solution {\\npublic:\\n    string key(string s)\\n    {\\n        string s1 = \"\";\\n        string s2 = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(i % 2)\\n                s1 += s[i];\\n            else\\n                s2 += s[i];\\n        }\\n        std::sort(s1.begin(),s1.end());\\n        std::sort(s2.begin(),s2.end());\\n        return s1 + s2;\\n    }\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> sset;\\n        for(string s : A)\\n            sset.insert(key(s));\\n        return sset.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3227290,
                "title": "python-solution-run-time-77",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        lst=[]\\n        for i in words:\\n            evn=\\'\\'\\n            odd=\\'\\'\\n            for j in range(len(i)):\\n                if j%2==0:\\n                    evn+=i[j]\\n                else:\\n                    odd+=i[j]\\n            str=sorted(evn)+sorted(odd)\\n            lst.append(\"\".join(str))\\n        return len(Counter(lst))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n        lst=[]\\n        for i in words:\\n            evn=\\'\\'\\n            odd=\\'\\'\\n            for j in range(len(i)):\\n                if j%2==0:\\n                    evn+=i[j]\\n                else:\\n                    odd+=i[j]\\n            str=sorted(evn)+sorted(odd)\\n            lst.append(\"\".join(str))\\n        return len(Counter(lst))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141695,
                "title": "c-solution-using-set-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string>s;    // declare set of strings\\n        for(auto i:words){   \\n            string q=\"\";\\n            string w=\"\";\\n            for(int j=0;j<i.size();j++){\\n                if(j%2==0){\\n                    q+=i[j]; // form a string of even indices \\n                }\\n                else {\\n                    w+=i[j]; //form a string of odd indices \\n                }\\n            }\\n            sort(q.begin(),q.end()); // sort both strings separately\\n            sort(w.begin(),w.end());\\n            q+=w; // add them to form single string\\n            s.insert(q); // insert the added string to set \\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string>s;    // declare set of strings\\n        for(auto i:words){   \\n            string q=\"\";\\n            string w=\"\";\\n            for(int j=0;j<i.size();j++){\\n                if(j%2==0){\\n                    q+=i[j]; // form a string of even indices \\n                }\\n                else {\\n                    w+=i[j]; //form a string of odd indices \\n                }\\n            }\\n            sort(q.begin(),q.end()); // sort both strings separately\\n            sort(w.begin(),w.end());\\n            q+=w; // add them to form single string\\n            s.insert(q); // insert the added string to set \\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249225,
                "title": "c-sol-using-set",
                "content": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> s;\\n        for(const auto& w : words){\\n            string odd, even;\\n            for(int i=0;i<w.length();i++){\\n                \\n                if(i%2!=0) odd += w[i];\\n                even += w[i];}\\n                sort(even.begin(), even.end());\\n                sort(odd.begin(), odd.end());\\n                s.insert(even+odd);\\n            \\n        }\\n        return s.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> s;\\n        for(const auto& w : words){\\n            string odd, even;\\n            for(int i=0;i<w.length();i++){\\n                \\n                if(i%2!=0) odd += w[i];\\n                even += w[i];}",
                "codeTag": "Java"
            },
            {
                "id": 1072832,
                "title": "easy-fast-understandable-c-solution",
                "content": "UPVOTE IF THE SOLUTION MAKES SENSE TO YOU\\n-> Solution to this problem as per this approach points to simple principle of dividing the string in to two parts - \\n - One string with characters from odd indexes.\\n - One string with characters from even indexes.\\n \\n Once we have these two individual parts, sort specific parts, combine them in to one and check for its existence in the hash map. If found increase frequency in hashmap else insert in hashmap.\\n\\n- Size of hashmap gives us the result to the problem.\\n- -> Alternatively we can just use a set since we just need number of unique strings.\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        int l = A.size();\\n\\t\\tunordered_map<string, int> map;               //  initialize hashmap\\n        for(int i=0;i<l;i++){\\n\\t\\t\\tstring cur = A[i];                                        // take current string from array\\n            int slen = cur.length();\\n            string os = \"\";\\n            string es = \"\";\\n            for(int j=0;j<slen;j++){\\n                if(j%2==0){                                         // check index is even or odd\\n                    os+=cur[j];\\n                }else{\\n                    es+=cur[j];\\n                }\\n            }\\n            sort(os.begin(),os.end());                       // sort by parts\\n            sort(es.begin(),es.end());\\n            cur = os+es;\\n            if(map.count(cur)>0){\\n                map[cur]+=1;\\n            }else{\\n                map[cur]=1;\\n            }\\n        }\\n        return map.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        int l = A.size();\\n\\t\\tunordered_map<string, int> map;               //  initialize hashmap\\n        for(int i=0;i<l;i++){\\n\\t\\t\\tstring cur = A[i];                                        // take current string from array\\n            int slen = cur.length();\\n            string os = \"\";\\n            string es = \"\";\\n            for(int j=0;j<slen;j++){\\n                if(j%2==0){                                         // check index is even or odd\\n                    os+=cur[j];\\n                }else{\\n                    es+=cur[j];\\n                }\\n            }\\n            sort(os.begin(),os.end());                       // sort by parts\\n            sort(es.begin(),es.end());\\n            cur = os+es;\\n            if(map.count(cur)>0){\\n                map[cur]+=1;\\n            }else{\\n                map[cur]=1;\\n            }\\n        }\\n        return map.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069262,
                "title": "python3-one-liner-solution-faster-than-69",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len({\\'\\'.join(sorted(a[::2]) + sorted(a[1::2])) for a in A})\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len({\\'\\'.join(sorted(a[::2]) + sorted(a[1::2])) for a in A})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717549,
                "title": "c-4-ms-without-sorting-beats-100-time-99-space",
                "content": "In this problem, it is understood that for a string if we maintain 2 hashsets for count of characters in odd and even places, and if both these hashsets match (corresponding) for 2 given strings, then both the strings can be grouped together i.e. are equivalent.\\n\\nBut to maintain a set of hashsets is a tedious job.\\n\\nSo to overcome that we maintain a unique identifier for these strings.( Example - we could have taken the sum of character values)\\n\\nBut then a simple sum wouldn\\'t give us a unique identifier. Eg -  \\'abad\\' and \\'acac\\' would map to same values i.e (0+0,1+3) = (0+0,2+2) i.e. (0,4)\\n\\nSo we look for a solution where sum of any 2 characters should not be equal to any other 2 characters.\\n\\nHence instead of labelling the characters from 0 to 25, we label them from 1 to 2^25.\\n```\\nint numSpecialEquivGroups(vector<string>& A) {\\n        set<pair<long long, long long>> s;\\n        int arr[26];\\n        arr[0] = 1;\\n        for(int i=1;i<26;i++)\\n            arr[i] = 2*arr[i-1];\\n        for(int i=0;i<A.size();i++)\\n        {\\n            long long a = 0;\\n            long long b = 0;\\n            for(int j=0;j<A[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    a += arr[A[i][j]-\\'a\\'];\\n                else\\n                    b += arr[A[i][j]-\\'a\\'];\\n            }\\n            s.insert(make_pair(a,b));\\n        }\\n        return s.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numSpecialEquivGroups(vector<string>& A) {\\n        set<pair<long long, long long>> s;\\n        int arr[26];\\n        arr[0] = 1;\\n        for(int i=1;i<26;i++)\\n            arr[i] = 2*arr[i-1];\\n        for(int i=0;i<A.size();i++)\\n        {\\n            long long a = 0;\\n            long long b = 0;\\n            for(int j=0;j<A[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    a += arr[A[i][j]-\\'a\\'];\\n                else\\n                    b += arr[A[i][j]-\\'a\\'];\\n            }\\n            s.insert(make_pair(a,b));\\n        }\\n        return s.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 702121,
                "title": "ruby-solution-represent-word-as-array-of-52-elements-with-2-histograms-in-it",
                "content": "#### Leetcode: 893. Groups of Special-Equivalent Strings.\\n\\n\\n\\n##### Simplified approach.\\n\\n`thnx @quantumlexa`  \\n\\nTwo strings are special equivalent if their histograms for even and odd indices are equal. Histogram for a word can be represented as 52 elments array, 26 for even 26 for odd symbols. Array mapped from array of words to array of histograms. Then make array contain only uniq values and return it\\'s size.\\n\\nRuby code: \\n```Ruby\\n# Leetcode: 893. Groups of Special-Equivalent Strings.\\n# https://leetcode.com/problems/groups-of-special-equivalent-strings/\\n# thnx @quantumlexa\\n# Runtime: 92 ms, faster than 10.00% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# Memory Usage: 10.3 MB, less than 66.67% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# @param {String[]} a\\n# @return {Integer}\\ndef num_special_equiv_groups(arr)\\n    arr.map!{|x|\\n        h = Array.new(52,0)\\n        (0...x.size).each do |i|\\n            h[26*(i%2) + x[i].ord - ?a.ord] += 1\\n        end\\n        h\\n    }.uniq.size\\nend\\n```\\n\\n##### Initial accepted approach.\\n\\nTwo strings are special equivalent if their histograms for even indexed chars and odd indexed chars are equal. Because there are only 26 different chars in this task, the both histograms could be represented as array of 52 elements. First map array of strings to array of histograms. Than create array name used to mark words that already in groups, and compare all words with each other by two loops external and internal one. External one iterates over all indexes, and internal start iteration from index after external one. Skip indexes already in groups for both arrays. When pointing on new index in external array if it is not used new group is started, during internal loop mark all words in this group as used. So on next iteration of external loop indices of this group will be skipped.\\n\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 893. Groups of Special-Equivalent Strings.\\n# https://leetcode.com/problems/groups-of-special-equivalent-strings/\\n# Runtime: 260 ms, faster than 10.00% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# Memory Usage: 10.1 MB, less than 66.67% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# @param {String[]} a\\n# @return {Integer}\\ndef num_special_equiv_groups(arr)\\n    arr.map!{|x|\\n        h = Array.new(52,0)\\n        (0...x.size).each do |i|\\n            h[26*(i%2) + x[i].ord - ?a.ord] += 1\\n        end\\n        h\\n    }\\n    groups = 0\\n    used = Array.new(arr.size,false)\\n    (0...arr.size).each do |i|\\n        next if used[i]\\n        used[i] = true\\n        groups += 1\\n        (i+1...arr.size).each do |j|\\n            next if used[j]\\n            used[j] = true if arr[i] == arr[j] \\n        end\\n    end\\n    groups\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 893. Groups of Special-Equivalent Strings.\\n# https://leetcode.com/problems/groups-of-special-equivalent-strings/\\n# thnx @quantumlexa\\n# Runtime: 92 ms, faster than 10.00% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# Memory Usage: 10.3 MB, less than 66.67% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# @param {String[]} a\\n# @return {Integer}\\ndef num_special_equiv_groups(arr)\\n    arr.map!{|x|\\n        h = Array.new(52,0)\\n        (0...x.size).each do |i|\\n            h[26*(i%2) + x[i].ord - ?a.ord] += 1\\n        end\\n        h\\n    }.uniq.size\\nend\\n```\n```Ruby\\n# Leetcode: 893. Groups of Special-Equivalent Strings.\\n# https://leetcode.com/problems/groups-of-special-equivalent-strings/\\n# Runtime: 260 ms, faster than 10.00% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# Memory Usage: 10.1 MB, less than 66.67% of Ruby online submissions for Groups of Special-Equivalent Strings.\\n# @param {String[]} a\\n# @return {Integer}\\ndef num_special_equiv_groups(arr)\\n    arr.map!{|x|\\n        h = Array.new(52,0)\\n        (0...x.size).each do |i|\\n            h[26*(i%2) + x[i].ord - ?a.ord] += 1\\n        end\\n        h\\n    }\\n    groups = 0\\n    used = Array.new(arr.size,false)\\n    (0...arr.size).each do |i|\\n        next if used[i]\\n        used[i] = true\\n        groups += 1\\n        (i+1...arr.size).each do |j|\\n            next if used[j]\\n            used[j] = true if arr[i] == arr[j] \\n        end\\n    end\\n    groups\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 574377,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        l=[]\\n        for s in A:\\n            even=\"\"\\n            odd=\"\"\\n            for i in range(len(s)):\\n                if i%2!=0:\\n                    odd+=s[i]\\n                    \\n                else:\\n                    even+=s[i]\\n                    \\n            odd = \\'\\'.join(sorted(odd))\\n            even = \\'\\'.join(sorted(even)) \\n            # odd=sorted(odd)\\n            # even=sorted(even)\\n            \\n            l.append(str(odd)+str(even))\\n            \\n        # print(l)    \\n            \\n        return len(set(l))     \\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        l=[]\\n        for s in A:\\n            even=\"\"\\n            odd=\"\"\\n            for i in range(len(s)):\\n                if i%2!=0:\\n                    odd+=s[i]\\n                    \\n                else:\\n                    even+=s[i]\\n                    \\n            odd = \\'\\'.join(sorted(odd))\\n            even = \\'\\'.join(sorted(even)) \\n            # odd=sorted(odd)\\n            # even=sorted(even)\\n            \\n            l.append(str(odd)+str(even))\\n            \\n        # print(l)    \\n            \\n        return len(set(l))     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 512298,
                "title": "python3-group-strings-by-sorting-characters-at-even-odd-indices",
                "content": "Algorithm:\\nHere, we need a way to group strings so that each group is a special-equivalent group. Counting is one way as suggested by the Solution. Here, I\\'ve used sorting-based approach. For a given string, sort the characters at even and odd indices respectively and join them. \\n\\n(36ms, 96.54%): \\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        fn = lambda s: \"\".join(sorted(s[::2]) + sorted(s[1::2]))\\n        return len(set(fn(s) for s in A))\\n```\\n\\nAnalysis:\\nTime complexity `O(NlogN)`\\nSpace complexity `O(N)`\\n\\nComment: Even though the time complexity is `O(NlogN)` in this approach, given `1 <= A[i].length <= 20`, it is still competative in terms of performance.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        fn = lambda s: \"\".join(sorted(s[::2]) + sorted(s[1::2]))\\n        return len(set(fn(s) for s in A))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508798,
                "title": "go-0ms-map-solution",
                "content": "```go\\nfunc numSpecialEquivGroups(A []string) int {\\n    m := map[[52]int]interface{}{}\\n    for _, s := range A {\\n        array := [52]int{}\\n        for i, c := range s {\\n            if i % 2 == 0 {\\n                array[c-\\'a\\']++\\n            } else {\\n                array[c-\\'a\\'+26]++\\n            }\\n        }\\n        m[array] = nil\\n    }\\n    return len(m)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc numSpecialEquivGroups(A []string) int {\\n    m := map[[52]int]interface{}{}\\n    for _, s := range A {\\n        array := [52]int{}\\n        for i, c := range s {\\n            if i % 2 == 0 {\\n                array[c-\\'a\\']++\\n            } else {\\n                array[c-\\'a\\'+26]++\\n            }\\n        }\\n        m[array] = nil\\n    }\\n    return len(m)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 289642,
                "title": "java-4ms-customized-hashing-algorithm-easy-to-understand",
                "content": "customized a hashing algorithm that:\\n1.split the string into 2 parts by index , the odd part and the even part\\n2.count each char (a ~ z) in each part\\n3.combine the count result into a hashing string\\n4.just add hashing string into a set\\n5.return the size of this set\\n```\\nclass Solution {\\n    \\n    private String hash(String a){\\n        char[][] count = new char[2][26];\\n        \\n        Arrays.fill(count[0],\\'a\\');\\n        Arrays.fill(count[1],\\'a\\');  \\n        \\n        int index =0;\\n        \\n        for(char c : a.toCharArray()){\\n            count[index%2][c-\\'a\\']++;\\n            index++;\\n        }\\n       return (new String(count[0]))+\"_\"+(new String(count[1]));\\n    }\\n    \\n    public int numSpecialEquivGroups(String[] A) {\\n        HashSet<String> set = new HashSet<>();\\n        for(String aString: A){\\n            set.add(hash(aString));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private String hash(String a){\\n        char[][] count = new char[2][26];\\n        \\n        Arrays.fill(count[0],\\'a\\');\\n        Arrays.fill(count[1],\\'a\\');  \\n        \\n        int index =0;\\n        \\n        for(char c : a.toCharArray()){\\n            count[index%2][c-\\'a\\']++;\\n            index++;\\n        }\\n       return (new String(count[0]))+\"_\"+(new String(count[1]));\\n    }\\n    \\n    public int numSpecialEquivGroups(String[] A) {\\n        HashSet<String> set = new HashSet<>();\\n        for(String aString: A){\\n            set.add(hash(aString));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287734,
                "title": "python-easy-to-understand-1-liner-other-faster-solution",
                "content": "In the one liner, you just return the length of the set of tuples. Each tuple contain (sorted letters of even indexed letters, sorted letters of odd indexed letters). This should be O(N*klogk), with k being the length of each word.\\n\\n`return len(set(tuple(sorted(word[::2])+sorted(word[1::2])) for word in A))`\\n\\nThis is the second solution, which is technically O(N*k), because each tup can only be length of 52, no matter how long k or N is. \\n\\nThey both run in 36 ms though, so a great example of when big O is not super helpful. \\n\\n```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        uniqueSet = set()\\n        for word in A:\\n            tup = [0]*52\\n            for i in range(len(word)):\\n                tup[(ord(word[i])-ord(\\'a\\')) + 26*(i %2)] += 1 \\n            uniqueSet.add(tuple(tup))\\n        return len(uniqueSet)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        uniqueSet = set()\\n        for word in A:\\n            tup = [0]*52\\n            for i in range(len(word)):\\n                tup[(ord(word[i])-ord(\\'a\\')) + 26*(i %2)] += 1 \\n            uniqueSet.add(tuple(tup))\\n        return len(uniqueSet)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190844,
                "title": "python3-one-liner",
                "content": "```\\n    def numSpecialEquivGroups(self, A):\\n        return len({\\'\\'.join(sorted(word[::2]))+\\'\\'.join(sorted(word[1::2])) for word in A})\\n```\\nuses letters at even positions, sorted, and letters at odd positions, also sorted, and combines them into a single string used as they key for a set, then returns the length of that set, e.g. the number of different unique keys. Each keys is a group.",
                "solutionTags": [],
                "code": "```\\n    def numSpecialEquivGroups(self, A):\\n        return len({\\'\\'.join(sorted(word[::2]))+\\'\\'.join(sorted(word[1::2])) for word in A})\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 169447,
                "title": "possible-javascript-solution-with-map-and-sort",
                "content": "```\\nvar numSpecialEquivGroups = function(A) {\\n    var odd;\\n    var even;\\n    var key;\\n    var count = 0;\\n    var map = Object.create(null);\\n    for (var i = 0; i < A.length; i++) {\\n        odd = [];\\n        even = [];\\n        for (var j = 0; j < A[i].length; j++) {\\n            if (j % 2 === 0) {\\n                even.push(A[i][j]);\\n            } else {\\n                odd.push(A[i][j]);\\n            }\\n        }\\n        \\n        even.sort();\\n        odd.sort();\\n        \\n        key = even.join(\"\") + odd.join(\"\");\\n        if (!map[key]) {\\n            map[key] = true;\\n            count++;\\n        }\\n    }\\n        \\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numSpecialEquivGroups = function(A) {\\n    var odd;\\n    var even;\\n    var key;\\n    var count = 0;\\n    var map = Object.create(null);\\n    for (var i = 0; i < A.length; i++) {\\n        odd = [];\\n        even = [];\\n        for (var j = 0; j < A[i].length; j++) {\\n            if (j % 2 === 0) {\\n                even.push(A[i][j]);\\n            } else {\\n                odd.push(A[i][j]);\\n            }\\n        }\\n        \\n        even.sort();\\n        odd.sort();\\n        \\n        key = even.join(\"\") + odd.join(\"\");\\n        if (!map[key]) {\\n            map[key] = true;\\n            count++;\\n        }\\n    }\\n        \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164161,
                "title": "c-solution-beats-100",
                "content": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        set<string> s;\\n        \\n        for (auto &a : A) {\\n            string s1;\\n            string s2;\\n            for (int i = 0; i < a.size(); i++) {\\n                if (i % 2 == 0)\\n                    s1 += a[i];\\n                else\\n                    s2 += a[i];\\n            }\\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            s.insert(s1 + s2);\\n        }\\n            \\n        return s.size();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        set<string> s;\\n        \\n        for (auto &a : A) {\\n            string s1;\\n            string s2;\\n            for (int i = 0; i < a.size(); i++) {\\n                if (i % 2 == 0)\\n                    s1 += a[i];\\n                else\\n                    s2 += a[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3888784,
                "title": "set-easy-c-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter **sorting** the **even and odd Position characters** of a string put it into a **unordered set** and finally return the **size** of the set.\\n\\n# Complexity\\n- Time complexity:O(N * 20 * 10 * Log(10))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        unordered_set<string> st;\\n        for(int i = 0;i<w.size();i++)\\n        {\\n            string even = \"\",odd = \"\";\\n            for(int j = 0;j<w[i].size();j++)\\n            {\\n                if(j%2) odd+=w[i][j];\\n                else even+=w[i][j];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            st.insert(even+odd);\\n        }\\n        return st.size();\\n        \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/a09140aa-537b-4890-9c3c-1f7ab2a60bab_1691642025.638834.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        unordered_set<string> st;\\n        for(int i = 0;i<w.size();i++)\\n        {\\n            string even = \"\",odd = \"\";\\n            for(int j = 0;j<w[i].size();j++)\\n            {\\n                if(j%2) odd+=w[i][j];\\n                else even+=w[i][j];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            st.insert(even+odd);\\n        }\\n        return st.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511728,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> st;\\n        for (auto& w : words) {\\n            string odd, even;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i % 2) even += w[i];\\n                else odd += w[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        res = set()\\n        for s in A:\\n            sort_odd_even = \\'\\'.join(sorted(s[1::2]) + sorted(s[::2]))\\n            res.add(sort_odd_even)\\n        return len(res)\\n```\\n\\n```Java []\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<Integer> uniques = new HashSet<>();\\n        for (String word : words) uniques.add(customHash(word));\\n        return uniques.size();\\n    }\\n    private int customHash(String word) {\\n        int[] evenFreqs = new int[26], oddFreqs = new int[26];\\n        byte[] chars = word.getBytes();\\n\\n        int n = chars.length;\\n        for (int i = 0, limit = n / 2 * 2; i < limit; i += 2) {\\n            ++evenFreqs[chars[i] - \\'a\\'];\\n            ++oddFreqs[chars[i + 1] - \\'a\\'];\\n        }\\n        if (n % 2 == 1) ++evenFreqs[chars[n - 1] - \\'a\\'];\\n        int acc = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            acc = 31 * acc + evenFreqs[i];\\n            acc = 31 * acc + oddFreqs[i];\\n        }\\n        return acc;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> st;\\n        for (auto& w : words) {\\n            string odd, even;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i % 2) even += w[i];\\n                else odd += w[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        res = set()\\n        for s in A:\\n            sort_odd_even = \\'\\'.join(sorted(s[1::2]) + sorted(s[::2]))\\n            res.add(sort_odd_even)\\n        return len(res)\\n```\n```Java []\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<Integer> uniques = new HashSet<>();\\n        for (String word : words) uniques.add(customHash(word));\\n        return uniques.size();\\n    }\\n    private int customHash(String word) {\\n        int[] evenFreqs = new int[26], oddFreqs = new int[26];\\n        byte[] chars = word.getBytes();\\n\\n        int n = chars.length;\\n        for (int i = 0, limit = n / 2 * 2; i < limit; i += 2) {\\n            ++evenFreqs[chars[i] - \\'a\\'];\\n            ++oddFreqs[chars[i + 1] - \\'a\\'];\\n        }\\n        if (n % 2 == 1) ++evenFreqs[chars[n - 1] - \\'a\\'];\\n        int acc = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            acc = 31 * acc + evenFreqs[i];\\n            acc = 31 * acc + oddFreqs[i];\\n        }\\n        return acc;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183359,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n       HashSet<String> h=new HashSet<>();\\n       for(String str:words){\\n           int[] odd=new int[26];\\n           int [] even=new int[26];\\n           for(int i=0;i<str.length();i++){\\n               if(i%2==0){\\n                   even[str.charAt(i)-\\'a\\']++;\\n               }else{\\n                   odd[str.charAt(i)-\\'a\\']++;\\n               }}\\n               String key=Arrays.toString(odd)+Arrays.toString(even);\\n               h.add(key);\\n           \\n       }\\n       return h.size(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n       HashSet<String> h=new HashSet<>();\\n       for(String str:words){\\n           int[] odd=new int[26];\\n           int [] even=new int[26];\\n           for(int i=0;i<str.length();i++){\\n               if(i%2==0){\\n                   even[str.charAt(i)-\\'a\\']++;\\n               }else{\\n                   odd[str.charAt(i)-\\'a\\']++;\\n               }}\\n               String key=Arrays.toString(odd)+Arrays.toString(even);\\n               h.add(key);\\n           \\n       }\\n       return h.size(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117083,
                "title": "pyton3-easy-to-understand-solution",
                "content": "# Approach\\nSort the odd indices and even indices of the word seperately. Then combine those 2 to get the key value which is the same for special equivalent strings.\\n\\n\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = defaultdict(list)\\n        for word in words:\\n            odd , even = \"\",\\'\\'\\n            for idx,char in enumerate(word):\\n                if idx%2 == 0:\\n                    even += char\\n                else:\\n                    odd+= char\\n\\n            odd = sorted(odd)\\n            even = sorted(even)\\n            final = \"\".join(odd+even)\\n            \\n            d[final].append(word)\\n\\n        \\n        return len(d.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = defaultdict(list)\\n        for word in words:\\n            odd , even = \"\",\\'\\'\\n            for idx,char in enumerate(word):\\n                if idx%2 == 0:\\n                    even += char\\n                else:\\n                    odd+= char\\n\\n            odd = sorted(odd)\\n            even = sorted(even)\\n            final = \"\".join(odd+even)\\n            \\n            d[final].append(word)\\n\\n        \\n        return len(d.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008213,
                "title": "general-approach",
                "content": "# Intuition\\nOdd index characters should be same and even index characters should be same for 2 different strings\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2*(20+20log20)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        int n=a.size();\\n        vector<bool>check(n,false);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(check[i]) continue;\\n            string odda=\"\";\\n            string evena=\"\";\\n            for(int k=0;k<a[i].size();k++){\\n                if(k%2) odda+=a[i][k];\\n                else evena+=a[i][k];\\n            }\\n            sort(begin(odda),end(odda));\\n            sort(begin(evena),end(evena));\\n            ans++;\\n            check[i]=true;\\n            for(int j=i+1;j<n;j++){\\n                if(check[j]) continue;\\n                string oddb=\"\";\\n                string evenb=\"\";\\n                for(int k=0;k<a[i].size();k++){\\n                    if(k%2) oddb+=a[j][k];\\n                    else evenb+=a[j][k];\\n                }\\n                sort(begin(oddb),end(oddb));\\n                sort(begin(evenb),end(evenb));\\n                if(odda==oddb&&evena==evenb){\\n                    check[j]=true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        int n=a.size();\\n        vector<bool>check(n,false);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(check[i]) continue;\\n            string odda=\"\";\\n            string evena=\"\";\\n            for(int k=0;k<a[i].size();k++){\\n                if(k%2) odda+=a[i][k];\\n                else evena+=a[i][k];\\n            }\\n            sort(begin(odda),end(odda));\\n            sort(begin(evena),end(evena));\\n            ans++;\\n            check[i]=true;\\n            for(int j=i+1;j<n;j++){\\n                if(check[j]) continue;\\n                string oddb=\"\";\\n                string evenb=\"\";\\n                for(int k=0;k<a[i].size();k++){\\n                    if(k%2) oddb+=a[j][k];\\n                    else evenb+=a[j][k];\\n                }\\n                sort(begin(oddb),end(oddb));\\n                sort(begin(evenb),end(evenb));\\n                if(odda==oddb&&evena==evenb){\\n                    check[j]=true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931040,
                "title": "java-92-time-94-memory-solution",
                "content": "# Approach\\n1. To define groups I need to find smth common between strings, which belong to one group. So, I create 2 arrays with size of 26 (alph -> alphabet). Inside findAlphabet() I go through evenly indexed letters and increment the relevant index in the first alph array. The same applied to letters with odd indices.\\n2. Then I will use String as a key. For that I concatenate all numbers from both alph arrays. Then I use these strings to define uniqueness and put into the set.\\n3. Finally, just return the size of that set.\\n\\nCheers! \\n\\n# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        if (words.length == 1) return 1;\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < words.length; i++) {\\n            set.add(findAlphabet(words[i]));\\n        }\\n        return set.size();\\n    }\\n\\n    private static String findAlphabet(String word) {\\n        byte[][] alph = new byte[2][26];\\n        for (int i = 0; i < word.length(); i+=2) {\\n            alph[0][word.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 1; i < word.length(); i+=2) {\\n            alph[1][word.charAt(i) - \\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            sb.append(alph[0][i]);\\n            sb.append(alph[1][i]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        if (words.length == 1) return 1;\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < words.length; i++) {\\n            set.add(findAlphabet(words[i]));\\n        }\\n        return set.size();\\n    }\\n\\n    private static String findAlphabet(String word) {\\n        byte[][] alph = new byte[2][26];\\n        for (int i = 0; i < word.length(); i+=2) {\\n            alph[0][word.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 1; i < word.length(); i+=2) {\\n            alph[1][word.charAt(i) - \\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 26; i++) {\\n            sb.append(alph[0][i]);\\n            sb.append(alph[1][i]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760511,
                "title": "solution-runtime-16-ms-faster-than-63-18-and-memory-8-8-mb-less-than-68-16-of-c-submissions",
                "content": "The idea is really very naive \\uD83D\\uDE05\\uD83D\\uDE05 .....the thought was if i create a unique key for a single group of equivalent strings\\n\\n-> Take even poisitioned characters and add them to form a string, then take odd poisitioned characters and add them to form a string.\\n-> Now, sort both the strings as the question mentioned only odd poisitioned characters can be swapped with odd poistioned characters (same for even ones) if we sort them they must be equal\\n->Append both the strings to form a key and put it into a map\\n->Size of the map is our anwser\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        map<string,int> mp;\\n        for(int i=0;i<w.size();i++)\\n            {\\n                string e=\"\",o=\"\",s=w[i];\\n                for(int j=0;j<s.size();j++)\\n                {\\n                    if(j%2==0)\\n                        e+=s[j];\\n                    else\\n                        o+=s[j];\\n                }\\n                sort(e.begin(),e.end());\\n                sort(o.begin(),o.end());\\n                mp[e+o]++;\\n            }\\n   return mp.size(); }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        map<string,int> mp;\\n        for(int i=0;i<w.size();i++)\\n            {\\n                string e=\"\",o=\"\",s=w[i];\\n                for(int j=0;j<s.size();j++)\\n                {\\n                    if(j%2==0)\\n                        e+=s[j];\\n                    else\\n                        o+=s[j];\\n                }\\n                sort(e.begin(),e.end());\\n                sort(o.begin(),o.end());\\n                mp[e+o]++;\\n            }\\n   return mp.size(); }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491195,
                "title": "c-easy-solution-using-sets-and-hashmaps",
                "content": "\\n\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n=words.size();\\n        vector<pair<string,string>>v;\\n        \\n        for(auto it:words)\\n        {\\n            string even=\"\";\\n            string odd=\"\";\\n            for(int i=0;i<it.size();i+=2)even+=it[i];\\n            for(int i=1;i<it.size();i+=2)odd+=it[i];\\n             sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            \\n            even+=odd;\\n            v.push_back({it,even});\\n        }\\n        \\n        map<string,int>m;\\n        for(auto it:v)\\n            m[it.second]++;\\n        \\n        for(auto it: m)\\n            cout<<it.first<<\" \";\\n        \\n        return m.size();\\n    }\\n    \\n};",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n=words.size();\\n        vector<pair<string,string>>v;\\n        \\n        for(auto it:words)\\n        {\\n            string even=\"\";\\n            string odd=\"\";\\n            for(int i=0;i<it.size();i+=2)even+=it[i];\\n            for(int i=1;i<it.size();i+=2)odd+=it[i];\\n             sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            \\n            even+=odd;\\n            v.push_back({it,even}",
                "codeTag": "Java"
            },
            {
                "id": 2488710,
                "title": "python-o-n-m-hashmap-83-04",
                "content": "```\\ndef numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = {}\\n        for word in words:\\n            even = [0] * 26\\n            odd = [0] * 26\\n            for i, c in enumerate(word):\\n                if i % 2 == 0:\\n                    even[ord(c) - ord(\\'a\\')] += 1\\n                else:\\n                    odd[ord(c) - ord(\\'a\\')] += 1\\n            hsh = tuple(even) + tuple(odd)\\n            if hsh not in d:\\n                d[hsh] = set()\\n            d[hsh].add(word)\\n        return len(d)\\n```",
                "solutionTags": [
                    "Python",
                    "Counting Sort"
                ],
                "code": "```\\ndef numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = {}\\n        for word in words:\\n            even = [0] * 26\\n            odd = [0] * 26\\n            for i, c in enumerate(word):\\n                if i % 2 == 0:\\n                    even[ord(c) - ord(\\'a\\')] += 1\\n                else:\\n                    odd[ord(c) - ord(\\'a\\')] += 1\\n            hsh = tuple(even) + tuple(odd)\\n            if hsh not in d:\\n                d[hsh] = set()\\n            d[hsh].add(word)\\n        return len(d)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2434743,
                "title": "python-1-line",
                "content": "```\\nreturn len(Counter(\\'\\'.join(sorted(w[::2])+sorted(w[1::2])) for w in words))\\n```",
                "solutionTags": [],
                "code": "```\\nreturn len(Counter(\\'\\'.join(sorted(w[::2])+sorted(w[1::2])) for w in words))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1927968,
                "title": "a-sort-and-simple-solution-in-c",
                "content": "```\\n\\t\\t\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        \\n        set<string> s;\\n        \\n        for(int i=0;i<words.size();i++){\\n            \\n            string st = words[i];\\n            string odd = \"\";\\n            string even = \"\";\\n            \\n            for(int j=0;j<st.size();j++){\\n                if(j%2==0)\\n                    even=even+st[j];\\n                else\\n                    odd=odd+st[j];\\n            }\\n            \\n            sort(odd.begin(),odd.end());\\n            sort(even.begin(),even.end());\\n            string t=even+odd;\\n            s.insert(t);\\n        }\\n        return s.size();\\n    }",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        \\n        set<string> s;\\n        \\n        for(int i=0;i<words.size();i++){\\n            \\n            string st = words[i];\\n            string odd = \"\";\\n            string even = \"\";\\n            \\n            for(int j=0;j<st.size();j++){\\n                if(j%2==0)\\n                    even=even+st[j];\\n                else\\n                    odd=odd+st[j];\\n            }\\n            \\n            sort(odd.begin(),odd.end());\\n            sort(even.begin(),even.end());\\n            string t=even+odd;\\n            s.insert(t);\\n        }\\n        return s.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1615905,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // This function stores the character frequency of the odd and even positions of a string\\n    void filler(string &str,vector<int>&odd,vector<int>&even) {\\n        for(int i=0;i<str.length();i++) {\\n            if(i%2==0) {\\n                even[str[i]-\\'a\\']++;\\n            }\\n            else {\\n                odd[str[i]-\\'a\\']++;\\n            }\\n        }\\n    }\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n=words.size();\\n        \\n        // set is for grouping the strings.\\n        // The first element of pair is odd frequency\\n        // The second element of pair is even frequency\\n        set<pair<vector<int>,vector<int>>>dict;\\n        \\n        // odd vector stores the frequency at the odd positions of all the strings \\n        vector<vector<int>>odd(n,vector<int>(26,0));\\n        \\n        // even vector stores the frequency at the even positions of all the strings \\n        vector<vector<int>>even(n,vector<int>(26,0));\\n        for(int i=0;i<words.size();i++) {\\n            // calculate the frequency\\n            filler(words[i],odd[i],even[i]);\\n            \\n            // group the string \\n            dict.insert({odd[i],even[i]});\\n        }\\n        \\n        // finally set size will the group size\\n        return dict.size();\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // This function stores the character frequency of the odd and even positions of a string\\n    void filler(string &str,vector<int>&odd,vector<int>&even) {\\n        for(int i=0;i<str.length();i++) {\\n            if(i%2==0) {\\n                even[str[i]-\\'a\\']++;\\n            }\\n            else {\\n                odd[str[i]-\\'a\\']++;\\n            }\\n        }\\n    }\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int n=words.size();\\n        \\n        // set is for grouping the strings.\\n        // The first element of pair is odd frequency\\n        // The second element of pair is even frequency\\n        set<pair<vector<int>,vector<int>>>dict;\\n        \\n        // odd vector stores the frequency at the odd positions of all the strings \\n        vector<vector<int>>odd(n,vector<int>(26,0));\\n        \\n        // even vector stores the frequency at the even positions of all the strings \\n        vector<vector<int>>even(n,vector<int>(26,0));\\n        for(int i=0;i<words.size();i++) {\\n            // calculate the frequency\\n            filler(words[i],odd[i],even[i]);\\n            \\n            // group the string \\n            dict.insert({odd[i],even[i]});\\n        }\\n        \\n        // finally set size will the group size\\n        return dict.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413780,
                "title": "java-hashset-very-easy",
                "content": "```\\n public int numSpecialEquivGroups(String[] words) {\\n         HashSet<String> record = new HashSet<>();\\n        for (String str: words) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n            for (int i = 0; i < str.length(); i++) {\\n                if (i % 2 == 0) {\\n                    even[str.charAt(i) - \\'a\\']++;\\n                } else {\\n                    odd[str.charAt(i) - \\'a\\']++;\\n                }\\n            }\\n            record.add(Arrays.toString(even) + Arrays.toString(odd));\\n        }\\n        \\n        return record.size();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int numSpecialEquivGroups(String[] words) {\\n         HashSet<String> record = new HashSet<>();\\n        for (String str: words) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n            for (int i = 0; i < str.length(); i++) {\\n                if (i % 2 == 0) {\\n                    even[str.charAt(i) - \\'a\\']++;\\n                } else {\\n                    odd[str.charAt(i) - \\'a\\']++;\\n                }\\n            }\\n            record.add(Arrays.toString(even) + Arrays.toString(odd));\\n        }\\n        \\n        return record.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1387210,
                "title": "python3-hashset",
                "content": "TIME COMPLEXITY - O ( n * len ( word[ i ] ) )\\nSPACE COMPLEXITY - O(N) in worst case\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        hset=set()\\n        for i in range(len(words)):\\n            even=[0]*26\\n            odd=[0]*26\\n            for j in range(len(words[i])):\\n                if j%2==0:\\n                    even[ord(words[i][j])-ord(\\'a\\')]+=1\\n                else:\\n                    odd[ord(words[i][j])-ord(\\'a\\')]+=1\\n            hset.add(\"\".join([str(even[i]) for i in range(len(even))])+\"\".join([str(odd[i]) for i in range(len(odd))]))\\n        return len(hset)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        hset=set()\\n        for i in range(len(words)):\\n            even=[0]*26\\n            odd=[0]*26\\n            for j in range(len(words[i])):\\n                if j%2==0:\\n                    even[ord(words[i][j])-ord(\\'a\\')]+=1\\n                else:\\n                    odd[ord(words[i][j])-ord(\\'a\\')]+=1\\n            hset.add(\"\".join([str(even[i]) for i in range(len(even))])+\"\".join([str(odd[i]) for i in range(len(odd))]))\\n        return len(hset)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369289,
                "title": "java-straight-forward-with-explanation-and-example",
                "content": "\\nQuestion is super convoluted. You just want the max number of string pair where if you can switch any even index char and/or odd index char, they match.\\n\\nUsing the given example, this is the mental mapping you want: \\n```\\n[\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]\\nabcd -> ac | bd\\ncbad -> ac | bd\\nxyzz -> xz | yz\\nzzxy -> xz | yz\\nzzyz -> yz | xz\\n```\\n\\nApproach:\\n1. for each string, group the characters in the even index\\n2. group the characters in the odd index\\n3. sort the group from step 1 and 2\\n4. combine the sorted values from 3 `(e.g. (sorted chars from 1) | (sorted chars from 2)`\\n5. use a map to count the groups you encountered, and increment by 1\\n\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            \\n            StringBuilder odd = new StringBuilder();\\n            StringBuilder even = new StringBuilder();\\n            \\n            String word = words[i];\\n            for (int j = 0; j < word.length(); j++) {\\n                if (j % 2 == 0) even.append(word.charAt(j));\\n                else odd.append(word.charAt(j));\\n            }\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(sortString(odd.toString()));\\n            sb.append(sortString(even.toString()));\\n            map.put(sb.toString(), map.getOrDefault(sb.toString(), 0));\\n        }\\n        \\n        return map.size();\\n    }\\n    \\n    private String sortString(String str) {\\n        char[] chars = str.toCharArray();\\n        Arrays.sort(chars);\\n        return new String(chars);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n[\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]\\nabcd -> ac | bd\\ncbad -> ac | bd\\nxyzz -> xz | yz\\nzzxy -> xz | yz\\nzzyz -> yz | xz\\n```\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            \\n            StringBuilder odd = new StringBuilder();\\n            StringBuilder even = new StringBuilder();\\n            \\n            String word = words[i];\\n            for (int j = 0; j < word.length(); j++) {\\n                if (j % 2 == 0) even.append(word.charAt(j));\\n                else odd.append(word.charAt(j));\\n            }\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(sortString(odd.toString()));\\n            sb.append(sortString(even.toString()));\\n            map.put(sb.toString(), map.getOrDefault(sb.toString(), 0));\\n        }\\n        \\n        return map.size();\\n    }\\n    \\n    private String sortString(String str) {\\n        char[] chars = str.toCharArray();\\n        Arrays.sort(chars);\\n        return new String(chars);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366209,
                "title": "c-very-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, bool> umap;\\n        int ans = 0;\\n        for(int i=0; i<words.size(); i++){\\n            string odd = \"\";\\n            string even = \"\";\\n            for(int j=0; j<words[i].length(); j++){\\n                if(j%2) odd += words[i][j];\\n                else even += words[i][j];\\n            }\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            string s = odd + even;\\n            if(umap[s] == 0){\\n                umap[s] = 1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, bool> umap;\\n        int ans = 0;\\n        for(int i=0; i<words.size(); i++){\\n            string odd = \"\";\\n            string even = \"\";\\n            for(int j=0; j<words[i].length(); j++){\\n                if(j%2) odd += words[i][j];\\n                else even += words[i][j];\\n            }\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            string s = odd + even;\\n            if(umap[s] == 0){\\n                umap[s] = 1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315604,
                "title": "java-90-faster",
                "content": "```\\nclass Solution {\\n    String sortString(String str) {\\n        char []arr = str.toCharArray();\\n        Arrays.sort(arr);\\n        return (String.valueOf(arr));\\n    }\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        for(String s:words){\\n            StringBuilder curr = new StringBuilder();\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0;i<s.length();i+=2){\\n                sb.append(s.charAt(i));\\n            }\\n            curr.append(sortString(sb.toString()));\\n            sb = new StringBuilder();\\n            for(int i=1;i<s.length();i+=2){\\n                sb.append(s.charAt(i));\\n            }\\n            curr.append(sortString(sb.toString()));\\n            set.add(curr.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    String sortString(String str) {\\n        char []arr = str.toCharArray();\\n        Arrays.sort(arr);\\n        return (String.valueOf(arr));\\n    }\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        for(String s:words){\\n            StringBuilder curr = new StringBuilder();\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0;i<s.length();i+=2){\\n                sb.append(s.charAt(i));\\n            }\\n            curr.append(sortString(sb.toString()));\\n            sb = new StringBuilder();\\n            for(int i=1;i<s.length();i+=2){\\n                sb.append(s.charAt(i));\\n            }\\n            curr.append(sortString(sb.toString()));\\n            set.add(curr.toString());\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312111,
                "title": "poor-description",
                "content": "This question has a simple solution. but it took alot of time to just understand the question\\n\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n            int len=words[0].length();\\n            int max=0;\\n            Map<String, Integer> map=new HashMap();\\n            for(String s:words)\\n            {\\n                 StringBuilder sb=new StringBuilder();\\n                 for(int i=0;i<len;i+=2)\\n                 {\\n                    sb.append(s.charAt(i));\\n                 }\\n                 char[] c=sb.toString().toCharArray();\\n                 StringBuilder sb1=new StringBuilder();\\n                 for(int i=1;i<len;i+=2)\\n                 {\\n                    sb1.append(s.charAt(i));\\n                    \\n                 }\\n                 char[] b=sb1.toString().toCharArray();\\n                 Arrays.sort(c);\\n                 Arrays.sort(b);\\n                 String temp=new String(b)+\"#\"+new String(c);\\n                 map.put(temp,map.getOrDefault(temp,0)+1);\\n                 max=Math.max(max,map.get(temp));\\n            }\\n            return map.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n            int len=words[0].length();\\n            int max=0;\\n            Map<String, Integer> map=new HashMap();\\n            for(String s:words)\\n            {\\n                 StringBuilder sb=new StringBuilder();\\n                 for(int i=0;i<len;i+=2)\\n                 {\\n                    sb.append(s.charAt(i));\\n                 }\\n                 char[] c=sb.toString().toCharArray();\\n                 StringBuilder sb1=new StringBuilder();\\n                 for(int i=1;i<len;i+=2)\\n                 {\\n                    sb1.append(s.charAt(i));\\n                    \\n                 }\\n                 char[] b=sb1.toString().toCharArray();\\n                 Arrays.sort(c);\\n                 Arrays.sort(b);\\n                 String temp=new String(b)+\"#\"+new String(c);\\n                 map.put(temp,map.getOrDefault(temp,0)+1);\\n                 max=Math.max(max,map.get(temp));\\n            }\\n            return map.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285114,
                "title": "c-simple-aesy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n    int i=0,n=words.size();\\n    vector<vector<string>> res;\\n\\n    while(i<n){\\n        int j=0,m=words[i].length();\\n        string strt=words[i],t1=\"\",t2=\"\";\\n        while(j<m){\\n\\n            if(j%2==0){\\n                t1+=strt[j];\\n            }else{\\n                t2+=strt[j];\\n            }\\n            j++;\\n        }\\n        sort(t1.begin(),t1.end());\\n        sort(t2.begin(),t2.end());\\n        vector<string> temp;\\n        temp.push_back(t1);\\n        temp.push_back(t2);\\n        res.push_back(temp);\\n        temp.clear();\\n        i++;\\n    }\\n   \\n    i=0;\\n    sort(res.begin(),res.end());\\n    \\n    i=0;\\n    int r=0;\\n    while(i<n){\\n        vector<string> t=res[i];\\n        i++;\\n        while(i<n && res[i]==t){\\n            i++;\\n        }\\n        cout<<\" yes \"<<i;\\n        r++;\\n\\n    }\\n    return r;\\n\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n    int i=0,n=words.size();\\n    vector<vector<string>> res;\\n\\n    while(i<n){\\n        int j=0,m=words[i].length();\\n        string strt=words[i],t1=\"\",t2=\"\";\\n        while(j<m){\\n\\n            if(j%2==0){\\n                t1+=strt[j];\\n            }else{\\n                t2+=strt[j];\\n            }\\n            j++;\\n        }\\n        sort(t1.begin(),t1.end());\\n        sort(t2.begin(),t2.end());\\n        vector<string> temp;\\n        temp.push_back(t1);\\n        temp.push_back(t2);\\n        res.push_back(temp);\\n        temp.clear();\\n        i++;\\n    }\\n   \\n    i=0;\\n    sort(res.begin(),res.end());\\n    \\n    i=0;\\n    int r=0;\\n    while(i<n){\\n        vector<string> t=res[i];\\n        i++;\\n        while(i<n && res[i]==t){\\n            i++;\\n        }\\n        cout<<\" yes \"<<i;\\n        r++;\\n\\n    }\\n    return r;\\n\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1274117,
                "title": "c-4ms-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n  int numSpecialEquivGroups(std::vector<std::string>& words) {\\n    std::set<std::string> normed;\\n    for (auto && word : words) {\\n      sortStr(word);\\n      normed.insert(word);\\n    }\\n    return normed.size();\\n  }\\n\\n  void sortStr(std::string& word) {\\n    using std::swap;\\n    for (int i = 0; i < word.size(); i += 2) {\\n      for (int j = i + 2; j < word.size(); j += 2) {\\n        if (!(word[i] < word[j])) {\\n          swap(word[i], word[j]);\\n        }\\n      }\\n    }\\n    for (int i = 1; i < word.size(); i += 2) {\\n      for (int j = i + 2; j < word.size(); j += 2) {\\n        if (word[i] < word[j]) {\\n          swap(word[i], word[j]);\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int numSpecialEquivGroups(std::vector<std::string>& words) {\\n    std::set<std::string> normed;\\n    for (auto && word : words) {\\n      sortStr(word);\\n      normed.insert(word);\\n    }\\n    return normed.size();\\n  }\\n\\n  void sortStr(std::string& word) {\\n    using std::swap;\\n    for (int i = 0; i < word.size(); i += 2) {\\n      for (int j = i + 2; j < word.size(); j += 2) {\\n        if (!(word[i] < word[j])) {\\n          swap(word[i], word[j]);\\n        }\\n      }\\n    }\\n    for (int i = 1; i < word.size(); i += 2) {\\n      for (int j = i + 2; j < word.size(); j += 2) {\\n        if (word[i] < word[j]) {\\n          swap(word[i], word[j]);\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266077,
                "title": "with-explanation-python-40-ms-faster-than-80-and-easy-solution-and-one-liner-as-well",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        result = set()\\n        for i in words:\\n            i = \\'\\'.join(sorted(i[::2]) + sorted(i[1::2]))\\n            result.add(i)\\n        return (len(result))\\n\\n```\\n\\'\\'\\'\\t\\t\\nThe list indices which we have used ([::2]) and ([1::2]) ,\\nthis will give us odd and even elements respectively . \\nAnd as we have declared result = set() when we add result.add(i), \\nthe same elements won\\'t repeat and we will get the len. \\n\\n you can also use set at the return statement, however you are comfortable with. \\n Thank you please upvote if it helped :) \\n \\'\\'\\'\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        return len(set(\\'\\'.join(sorted(s[0::2]))+\\'\\'.join(sorted(s[1::2])) for s in words))\\n\\t\\t\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        result = set()\\n        for i in words:\\n            i = \\'\\'.join(sorted(i[::2]) + sorted(i[1::2]))\\n            result.add(i)\\n        return (len(result))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216068,
                "title": "share-two-java-solutions",
                "content": "```java\\n// \\u65B9\\u6CD5\\u4E8C\\uFF1A\\u5F97\\u5230\\u6BCF\\u4E2A\\u5B57\\u7B26\\u4E32\\u7684\\u5947\\u6570\\u4F4D\\u548C\\u5076\\u6570\\u4F4D\\u7EDF\\u8BA1\\u60C5\\u51B5\\u4EE5\\u540E\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u7279\\u5F81\\u5B57\\u7B26\\u4E32\\u5B58\\u5165 set\\uFF0C\\u7528 set \\u53BB\\u91CD\\n// AC: Runtime: 13 ms, faster than 55.72% of Java online submissions for Groups of Special-Equivalent Strings.\\n// Memory Usage: 38.7 MB, less than 80.98% of Java online submissions for Groups of Special-Equivalent Strings.\\n// \\u7565\\n// T:O(words.length * len(words[i])), S:O(words.length * len(words[i]))\\n//\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> record = new HashSet<>();\\n        for (String str: words) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n            for (int i = 0; i < str.length(); i++) {\\n                if (i % 2 == 0) {\\n                    even[str.charAt(i) - \\'a\\']++;\\n                } else {\\n                    odd[str.charAt(i) - \\'a\\']++;\\n                }\\n            }\\n            record.add(Arrays.toString(even) + Arrays.toString(odd));\\n        }\\n        \\n        return record.size();\\n    }\\n}\\n\\n// \\u65B9\\u6CD5\\u4E00\\uFF1A\\u76F4\\u63A5\\u904D\\u5386\\uFF0C\\u9010\\u4E2A\\u5224\\u65AD\\u4E24\\u4E24\\u5B57\\u7B26\\u4E32\\u662F\\u5426\\u5947\\u6570\\u4F4D\\u548C\\u5076\\u6570\\u4F4D\\u7EC4\\u6210\\u76F8\\u540C\\u3002\\n// AC: Runtime: 672 ms, faster than 5.05% of Java online submissions for Groups of Special-Equivalent Strings.\\n// Memory Usage: 39.8 MB, less than 6.57% of Java online submissions for Groups of Special-Equivalent Strings.\\n// T:O(words.length ^ 2 * len(words[i])), S:O(words.length * len(words[i]))\\n// \\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        int size = words.length;\\n        List<HashSet<String>> record = new LinkedList<>();\\n        HashSet<Integer> used = new HashSet<>();\\n        for (int i = 0; i < size; i++) {\\n            if (used.contains(i)) {\\n                continue;\\n            }\\n            HashSet<String> temp = new HashSet<>();\\n            temp.add(words[i]);\\n            for (int j = i + 1; j < size; j++) {\\n                if (check(words[i], words[j])) {\\n                    temp.add(words[j]);\\n                    used.add(j);\\n                }\\n            }\\n            record.add(temp);\\n        }\\n\\n        return record.size();\\n    }\\n\\n    private boolean check(String s1, String s2) {\\n        HashMap<Character, Integer> even1 = new HashMap<>();\\n        HashMap<Character, Integer> even2 = new HashMap<>();\\n        HashMap<Character, Integer> odd1 = new HashMap<>();\\n        HashMap<Character, Integer> odd2 = new HashMap<>();\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (i % 2 == 0) {\\n                even1.merge(s1.charAt(i), 1, Integer::sum);\\n                even2.merge(s2.charAt(i), 1, Integer::sum);\\n            } else {\\n                odd1.merge(s1.charAt(i), 1, Integer::sum);\\n                odd2.merge(s2.charAt(i), 1, Integer::sum);\\n            }\\n        }\\n        for (char c: even1.keySet()) {\\n            if (even2.get(c) == null || even1.get(c).intValue() != even2.get(c).intValue()) {\\n                return false;\\n            }\\n        }\\n        for (char c: odd1.keySet()) {\\n            if (odd2.get(c) == null || odd1.get(c).intValue() != odd2.get(c).intValue()) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n// \\u65B9\\u6CD5\\u4E8C\\uFF1A\\u5F97\\u5230\\u6BCF\\u4E2A\\u5B57\\u7B26\\u4E32\\u7684\\u5947\\u6570\\u4F4D\\u548C\\u5076\\u6570\\u4F4D\\u7EDF\\u8BA1\\u60C5\\u51B5\\u4EE5\\u540E\\uFF0C\\u7EC4\\u6210\\u4E00\\u4E2A\\u7279\\u5F81\\u5B57\\u7B26\\u4E32\\u5B58\\u5165 set\\uFF0C\\u7528 set \\u53BB\\u91CD\\n// AC: Runtime: 13 ms, faster than 55.72% of Java online submissions for Groups of Special-Equivalent Strings.\\n// Memory Usage: 38.7 MB, less than 80.98% of Java online submissions for Groups of Special-Equivalent Strings.\\n// \\u7565\\n// T:O(words.length * len(words[i])), S:O(words.length * len(words[i]))\\n//\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> record = new HashSet<>();\\n        for (String str: words) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n            for (int i = 0; i < str.length(); i++) {\\n                if (i % 2 == 0) {\\n                    even[str.charAt(i) - \\'a\\']++;\\n                } else {\\n                    odd[str.charAt(i) - \\'a\\']++;\\n                }\\n            }\\n            record.add(Arrays.toString(even) + Arrays.toString(odd));\\n        }\\n        \\n        return record.size();\\n    }\\n}\\n\\n// \\u65B9\\u6CD5\\u4E00\\uFF1A\\u76F4\\u63A5\\u904D\\u5386\\uFF0C\\u9010\\u4E2A\\u5224\\u65AD\\u4E24\\u4E24\\u5B57\\u7B26\\u4E32\\u662F\\u5426\\u5947\\u6570\\u4F4D\\u548C\\u5076\\u6570\\u4F4D\\u7EC4\\u6210\\u76F8\\u540C\\u3002\\n// AC: Runtime: 672 ms, faster than 5.05% of Java online submissions for Groups of Special-Equivalent Strings.\\n// Memory Usage: 39.8 MB, less than 6.57% of Java online submissions for Groups of Special-Equivalent Strings.\\n// T:O(words.length ^ 2 * len(words[i])), S:O(words.length * len(words[i]))\\n// \\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        int size = words.length;\\n        List<HashSet<String>> record = new LinkedList<>();\\n        HashSet<Integer> used = new HashSet<>();\\n        for (int i = 0; i < size; i++) {\\n            if (used.contains(i)) {\\n                continue;\\n            }\\n            HashSet<String> temp = new HashSet<>();\\n            temp.add(words[i]);\\n            for (int j = i + 1; j < size; j++) {\\n                if (check(words[i], words[j])) {\\n                    temp.add(words[j]);\\n                    used.add(j);\\n                }\\n            }\\n            record.add(temp);\\n        }\\n\\n        return record.size();\\n    }\\n\\n    private boolean check(String s1, String s2) {\\n        HashMap<Character, Integer> even1 = new HashMap<>();\\n        HashMap<Character, Integer> even2 = new HashMap<>();\\n        HashMap<Character, Integer> odd1 = new HashMap<>();\\n        HashMap<Character, Integer> odd2 = new HashMap<>();\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (i % 2 == 0) {\\n                even1.merge(s1.charAt(i), 1, Integer::sum);\\n                even2.merge(s2.charAt(i), 1, Integer::sum);\\n            } else {\\n                odd1.merge(s1.charAt(i), 1, Integer::sum);\\n                odd2.merge(s2.charAt(i), 1, Integer::sum);\\n            }\\n        }\\n        for (char c: even1.keySet()) {\\n            if (even2.get(c) == null || even1.get(c).intValue() != even2.get(c).intValue()) {\\n                return false;\\n            }\\n        }\\n        for (char c: odd1.keySet()) {\\n            if (odd2.get(c) == null || odd1.get(c).intValue() != odd2.get(c).intValue()) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115008,
                "title": "java",
                "content": "class Solution {\\n    public static int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n\\n        for (String s : A) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n\\n            for (int i=0; i<s.length(); i++) {\\n                if (i%2 == 0) {\\n                    even[s.charAt(i) - \\'a\\']++;\\n                }\\n                else {\\n                    odd[s.charAt(i) - \\'a\\']++;\\n                }\\n            }\\n\\n            set.add(Arrays.toString(even) + \"|\" + Arrays.toString(odd));\\n        }\\n\\n        return set.size();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n\\n        for (String s : A) {\\n            int[] even = new int[26];\\n            int[] odd = new int[26];\\n\\n            for (int i=0; i<s.length(); i++) {\\n                if (i%2 == 0) {\\n                    even[s.charAt(i) - \\'a\\']++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1041031,
                "title": "c-solution",
                "content": "```\\nint numSpecialEquivGroups(vector<string>& A) {\\n\\tset<string> sWords;\\n\\tfor (string w : A) {\\n\\t\\tstring even = \"\", odd = \"\";\\n\\t\\tfor (int i = 0; i < w.size(); i += 2) {\\n\\t\\t\\teven += w[i];\\n\\t\\t\\todd += w[i + 1];\\n\\t\\t}\\n\\t\\tsort(begin(even), end(even));\\n\\t\\tsort(begin(odd), end(odd));\\n\\t\\tw = even + odd;\\n\\t\\tsWords.insert(w);\\n\\t}\\n\\treturn sWords.size();\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint numSpecialEquivGroups(vector<string>& A) {\\n\\tset<string> sWords;\\n\\tfor (string w : A) {\\n\\t\\tstring even = \"\", odd = \"\";\\n\\t\\tfor (int i = 0; i < w.size(); i += 2) {\\n\\t\\t\\teven += w[i];\\n\\t\\t\\todd += w[i + 1];\\n\\t\\t}\\n\\t\\tsort(begin(even), end(even));\\n\\t\\tsort(begin(odd), end(odd));\\n\\t\\tw = even + odd;\\n\\t\\tsWords.insert(w);\\n\\t}\\n\\treturn sWords.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 992322,
                "title": "c-100-fast-simple-solution",
                "content": "```\\nclass Solution{\\n    public:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        //00 sort the letter in strings in A:\\n        for(auto& word : A) {\\n            string s1, s2;\\n            for(int i = 0; i < word.size(); i += 2) {\\n                s1 += word[i];\\n                s2 += word[i + 1];\\n            }\\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            word = s1 + s2;\\n        }\\n        //01 sort the strings in A:\\n        sort(A.begin(), A.end());\\n        //02 count the group of strings:\\n        int cnt = 1;\\n        string temp = A[0];\\n        for(int i = 1; i < A.size(); ++i) {\\n            if(temp != A[i]) {\\n                ++cnt;\\n                temp = A[i];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        //00 sort the letter in strings in A:\\n        for(auto& word : A) {\\n            string s1, s2;\\n            for(int i = 0; i < word.size(); i += 2) {\\n                s1 += word[i];\\n                s2 += word[i + 1];\\n            }\\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            word = s1 + s2;\\n        }\\n        //01 sort the strings in A:\\n        sort(A.begin(), A.end());\\n        //02 count the group of strings:\\n        int cnt = 1;\\n        string temp = A[0];\\n        for(int i = 1; i < A.size(); ++i) {\\n            if(temp != A[i]) {\\n                ++cnt;\\n                temp = A[i];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971744,
                "title": "c-straightforward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> groups;\\n        \\n        for (auto& s: A) {\\n            string odd, even;\\n            for (int i = 0; i < s.size(); ++i)\\n                if (i%2)\\n                    odd.push_back(s[i]);\\n                else\\n                    even.push_back(s[i]);\\n            \\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            groups.insert(odd + even);\\n        }\\n        \\n        return groups.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string> groups;\\n        \\n        for (auto& s: A) {\\n            string odd, even;\\n            for (int i = 0; i < s.size(); ++i)\\n                if (i%2)\\n                    odd.push_back(s[i]);\\n                else\\n                    even.push_back(s[i]);\\n            \\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            groups.insert(odd + even);\\n        }\\n        \\n        return groups.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 949096,
                "title": "c-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(const vector<string>& A) {\\n        unordered_set<string> us;\\n        for(const auto& s:A) {\\n            string s1,s2;\\n            for(int i=0; i<s.size(); ++++i) s1+=s[i];\\n            sort(s1.begin(),s1.end());\\n            for(int i=1; i<s.size(); ++++i) s2+=s[i];\\n            sort(s2.begin(),s2.end());\\n            us.insert(s1+s2);\\n        }\\n        return us.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(const vector<string>& A) {\\n        unordered_set<string> us;\\n        for(const auto& s:A) {\\n            string s1,s2;\\n            for(int i=0; i<s.size(); ++++i) s1+=s[i];\\n            sort(s1.begin(),s1.end());\\n            for(int i=1; i<s.size(); ++++i) s2+=s[i];\\n            sort(s2.begin(),s2.end());\\n            us.insert(s1+s2);\\n        }\\n        return us.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948159,
                "title": "easy-clean-javascript",
                "content": "```\\nconst numSpecialEquivGroups = A => {\\n   \\n  const sortChars = str => {\\n    const odd = [...str].filter((_,i) => i%2);\\n    const even = [...str].filter((_,i) => !(i%2));\\n    return `${odd.sort().join(\\'\\')}${even.sort().join(\\'\\')}`\\n  };\\n  \\n  const set = new Set();\\n  A.forEach(str => set.add(sortChars(str)));\\n  return set.size;\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nconst numSpecialEquivGroups = A => {\\n   \\n  const sortChars = str => {\\n    const odd = [...str].filter((_,i) => i%2);\\n    const even = [...str].filter((_,i) => !(i%2));\\n    return `${odd.sort().join(\\'\\')}${even.sort().join(\\'\\')}`\\n  };\\n  \\n  const set = new Set();\\n  A.forEach(str => set.add(sortChars(str)));\\n  return set.size;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947018,
                "title": "java-1-line",
                "content": "```\\npublic int numSpecialEquivGroups(String[] array) {\\n\\treturn Arrays.stream(array).map(s -> IntStream.range(0, s.length()).boxed().collect(Collectors.toMap(i -> s.charAt(i) + 26 * (i & 1), i -> 1, Integer::sum)).entrySet().stream().sorted(Map.Entry.comparingByKey()).map(Object::toString).collect(Collectors.joining())).collect(Collectors.toSet()).size();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numSpecialEquivGroups(String[] array) {\\n\\treturn Arrays.stream(array).map(s -> IntStream.range(0, s.length()).boxed().collect(Collectors.toMap(i -> s.charAt(i) + 26 * (i & 1), i -> 1, Integer::sum)).entrySet().stream().sorted(Map.Entry.comparingByKey()).map(Object::toString).collect(Collectors.joining())).collect(Collectors.toSet()).size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 915840,
                "title": "easy-python-3",
                "content": "\\tclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        ls=[]\\n        for i in A:\\n            odd=i[0::2]\\n            even=i[1::2]\\n            ls.append(tuple(sorted(odd)+sorted(even)))\\n\\n        return len(set(ls))",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        ls=[]\\n        for i in A:\\n            odd=i[0::2]\\n            even=i[1::2]\\n            ls.append(tuple(sorted(odd)+sorted(even)))\\n\\n        return len(set(ls))",
                "codeTag": "Java"
            },
            {
                "id": 904284,
                "title": "easiest-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        unordered_set<string>s1;\\n        for(int i=0;i<a.size();i++){\\n            string s=a[i];\\n            string odd=\"\",even=\"\";\\n            for(int i=0;i<s.length();i++){\\n                if(i%2==0)\\n                    even+=s[i];\\n                else\\n                    odd+=s[i];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            s1.insert(even+odd);\\n            \\n        }\\n        return s1.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        unordered_set<string>s1;\\n        for(int i=0;i<a.size();i++){\\n            string s=a[i];\\n            string odd=\"\",even=\"\";\\n            for(int i=0;i<s.length();i++){\\n                if(i%2==0)\\n                    even+=s[i];\\n                else\\n                    odd+=s[i];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            s1.insert(even+odd);\\n            \\n        }\\n        return s1.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868195,
                "title": "well-prime-numbers-helped",
                "content": "```\\npublic int numSpecialEquivGroups(String[] A) {\\n        int len = A.length;\\n        int[] firstTwentySixPrimes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\\n        Set<String> result = new HashSet<>();\\n        for(int i=0;i<len;i++) {\\n            int strLen = A[i].length();\\n            int oddIndicesNum = 1;\\n            int evenIndicesNum = 1;\\n            for(int j=0;j<strLen;j++) {\\n                char ch = A[i].charAt(j);\\n                if (j%2 != 0) oddIndicesNum *= firstTwentySixPrimes[ch-\\'a\\'];\\n                else evenIndicesNum *= firstTwentySixPrimes[ch-\\'a\\'];\\n            }\\n            result.add(\"\"+oddIndicesNum+\"-\"+evenIndicesNum);\\n        }\\n        return result.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numSpecialEquivGroups(String[] A) {\\n        int len = A.length;\\n        int[] firstTwentySixPrimes = new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\\n        Set<String> result = new HashSet<>();\\n        for(int i=0;i<len;i++) {\\n            int strLen = A[i].length();\\n            int oddIndicesNum = 1;\\n            int evenIndicesNum = 1;\\n            for(int j=0;j<strLen;j++) {\\n                char ch = A[i].charAt(j);\\n                if (j%2 != 0) oddIndicesNum *= firstTwentySixPrimes[ch-\\'a\\'];\\n                else evenIndicesNum *= firstTwentySixPrimes[ch-\\'a\\'];\\n            }\\n            result.add(\"\"+oddIndicesNum+\"-\"+evenIndicesNum);\\n        }\\n        return result.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 815059,
                "title": "java-o-26-n",
                "content": "```\\nclass Solution {\\n    private String evenOdd(String str){\\n        int n = str.length();\\n        int [] even = new int[26];\\n        int [] odd = new int[26];\\n        for(int i=0;i<n;i++){\\n            char c = str.charAt(i);\\n            if(i%2==0){\\n                even[c-\\'a\\']++;\\n            }else{\\n                odd[c-\\'a\\']++;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int x:even)sb.append(x);\\n        for(int x:odd)sb.append(x);\\n        return sb.toString();\\n    }\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<String>();\\n        for(String str : A){\\n            String key = evenOdd(str);\\n            set.add(key);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private String evenOdd(String str){\\n        int n = str.length();\\n        int [] even = new int[26];\\n        int [] odd = new int[26];\\n        for(int i=0;i<n;i++){\\n            char c = str.charAt(i);\\n            if(i%2==0){\\n                even[c-\\'a\\']++;\\n            }else{\\n                odd[c-\\'a\\']++;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int x:even)sb.append(x);\\n        for(int x:odd)sb.append(x);\\n        return sb.toString();\\n    }\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<String>();\\n        for(String str : A){\\n            String key = evenOdd(str);\\n            set.add(key);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 675000,
                "title": "easy-understanding-c-using-set-and-count-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string>s;\\n        for(int i=0;i<A.size();i++)\\n            s.insert(createhash(A[i]));\\n        return s.size();\\n    }\\n    static string createhash(string a)\\n    {\\n        string res=\"\";\\n        vector<int>even(26,0);\\n        vector<int>odd(26,0);\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(i%2==0)\\n            {\\n                even[a[i]-\\'a\\']++;\\n            }\\n            else\\n            {\\n                odd[a[i]-\\'a\\']++;\\n            }\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            while(even[i])\\n            {\\n                res+=to_string(i+\\'a\\');\\n                even[i]--;\\n            }\\n        }\\n        res+=\\'.\\';\\n         for(int i=0;i<26;i++)\\n        {\\n            while(odd[i])\\n            {\\n                res+=to_string(i+\\'a\\');\\n                odd[i]--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        unordered_set<string>s;\\n        for(int i=0;i<A.size();i++)\\n            s.insert(createhash(A[i]));\\n        return s.size();\\n    }\\n    static string createhash(string a)\\n    {\\n        string res=\"\";\\n        vector<int>even(26,0);\\n        vector<int>odd(26,0);\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(i%2==0)\\n            {\\n                even[a[i]-\\'a\\']++;\\n            }\\n            else\\n            {\\n                odd[a[i]-\\'a\\']++;\\n            }\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            while(even[i])\\n            {\\n                res+=to_string(i+\\'a\\');\\n                even[i]--;\\n            }\\n        }\\n        res+=\\'.\\';\\n         for(int i=0;i<26;i++)\\n        {\\n            while(odd[i])\\n            {\\n                res+=to_string(i+\\'a\\');\\n                odd[i]--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633433,
                "title": "python-soln",
                "content": "```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        #https://leetcode.com/problems/groups-of-special-equivalent-strings/discuss/358795/python3-detail-explanation-of-special-equivalent\\n        \\n        if len(A) == 1:\\n            return 1\\n        \\n        res = set()\\n        for string in A:\\n            even_indexed_string = string[0::2]\\n            sorted_even_indexed_string = \"\".join(sorted(even_indexed_string))\\n            \\n            odd_indexed_string = string[1::2]\\n            sorted_odd_indexed_string = \"\".join(sorted(odd_indexed_string))\\n            \\n            sorted_odd_even = sorted_even_indexed_string + sorted_odd_indexed_string\\n            res.add(sorted_odd_even)\\n\\n        return len(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        #https://leetcode.com/problems/groups-of-special-equivalent-strings/discuss/358795/python3-detail-explanation-of-special-equivalent\\n        \\n        if len(A) == 1:\\n            return 1\\n        \\n        res = set()\\n        for string in A:\\n            even_indexed_string = string[0::2]\\n            sorted_even_indexed_string = \"\".join(sorted(even_indexed_string))\\n            \\n            odd_indexed_string = string[1::2]\\n            sorted_odd_indexed_string = \"\".join(sorted(odd_indexed_string))\\n            \\n            sorted_odd_even = sorted_even_indexed_string + sorted_odd_indexed_string\\n            res.add(sorted_odd_even)\\n\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633140,
                "title": "groups-of-special-equivalent-strings",
                "content": "```\\n    // Runtime: 6 ms, faster than 82.18% of Java online submissions for Groups of Special-Equivalent Strings.\\n    // Memory Usage: 39.3 MB, less than 7.69% of Java online submissions for Groups of Special-Equivalent Strings.\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> uniqueSet = new HashSet<>();\\n\\n        for (String str : A) {\\n            StringBuilder evenIndStr = new StringBuilder();\\n            StringBuilder oddIndStr = new StringBuilder();\\n\\n            for (int i = 0; i < str.length(); ++i) {\\n                if (i % 2 == 0) \\n                    evenIndStr.append(str.charAt(i));\\n                else \\n                    oddIndStr.append(str.charAt(i));\\n            }\\n            char[] evenStr = evenIndStr.toString().toCharArray();\\n            char[] oddStr = oddIndStr.toString().toCharArray();\\n            Arrays.sort(evenStr);\\n            Arrays.sort(oddStr);\\n\\n            uniqueSet.add(new String(evenStr) + new String(oddStr));\\n        }\\n\\n        return uniqueSet.size(); \\n    }",
                "solutionTags": [],
                "code": "```\\n    // Runtime: 6 ms, faster than 82.18% of Java online submissions for Groups of Special-Equivalent Strings.\\n    // Memory Usage: 39.3 MB, less than 7.69% of Java online submissions for Groups of Special-Equivalent Strings.\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> uniqueSet = new HashSet<>();\\n\\n        for (String str : A) {\\n            StringBuilder evenIndStr = new StringBuilder();\\n            StringBuilder oddIndStr = new StringBuilder();\\n\\n            for (int i = 0; i < str.length(); ++i) {\\n                if (i % 2 == 0) \\n                    evenIndStr.append(str.charAt(i));\\n                else \\n                    oddIndStr.append(str.charAt(i));\\n            }\\n            char[] evenStr = evenIndStr.toString().toCharArray();\\n            char[] oddStr = oddIndStr.toString().toCharArray();\\n            Arrays.sort(evenStr);\\n            Arrays.sort(oddStr);\\n\\n            uniqueSet.add(new String(evenStr) + new String(oddStr));\\n        }\\n\\n        return uniqueSet.size(); \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 568323,
                "title": "python3-solution-sort",
                "content": "class Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n\\n        # sort string by index  \\n        def F(s):\\n            odd, even = \"\", \"\"\\n            for i in range(len(s)):\\n                if i % 2 == 0: even += s[i]\\n                else: odd += s[i]\\n            return \"\".join(sorted(even) + sorted(odd))\\n        \\n        return len(set([F(s) for s in A]))",
                "solutionTags": [],
                "code": "class Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n\\n        # sort string by index  \\n        def F(s):\\n            odd, even = \"\", \"\"\\n            for i in range(len(s)):\\n                if i % 2 == 0: even += s[i]\\n                else: odd += s[i]\\n            return \"\".join(sorted(even) + sorted(odd))\\n        \\n        return len(set([F(s) for s in A]))",
                "codeTag": "Java"
            },
            {
                "id": 541107,
                "title": "swift-character-counting",
                "content": "```\\nclass Solution {\\n    func numSpecialEquivGroups(_ A: [String]) -> Int {\\n        var set:Set<String> = Set()\\n        for item in A{\\n            let chars = Array(item)\\n            var arr:[Character] = Array(repeating: \"0\", count: 52)\\n            for i in 0..<chars.count{\\n                if i % 2 == 0{\\n                    let val = Int(String(arr[Int(chars[i].asciiValue!) - 97]))! + 1\\n                    arr[Int(chars[i].asciiValue!) - 97] = Character(val.description)\\n                }else{\\n                    let val = Int(String(arr[Int(chars[i].asciiValue!) - 97 + 26]))! + 1\\n                    arr[Int(chars[i].asciiValue!) - 97 + 26] = Character(val.description)                \\n                }\\n            }\\n            set.insert(String(arr))\\n        }\\n        return set.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numSpecialEquivGroups(_ A: [String]) -> Int {\\n        var set:Set<String> = Set()\\n        for item in A{\\n            let chars = Array(item)\\n            var arr:[Character] = Array(repeating: \"0\", count: 52)\\n            for i in 0..<chars.count{\\n                if i % 2 == 0{\\n                    let val = Int(String(arr[Int(chars[i].asciiValue!) - 97]))! + 1\\n                    arr[Int(chars[i].asciiValue!) - 97] = Character(val.description)\\n                }else{\\n                    let val = Int(String(arr[Int(chars[i].asciiValue!) - 97 + 26]))! + 1\\n                    arr[Int(chars[i].asciiValue!) - 97 + 26] = Character(val.description)                \\n                }\\n            }\\n            set.insert(String(arr))\\n        }\\n        return set.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486870,
                "title": "python3-simple-solution",
                "content": "If two strings are special-equivalent,\\nthey share the following tuple:\\n\\n(sorted string made of characters of the original strings of even indices,\\nsorted str. made of chars. of the orig. strs. of odd indices)\\n\\nTherefore, if we make such tuples from each string and put into a set,\\nthe length of the set is the answer. \\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        ans = set()\\n        ln = len(A[0])\\n        ceven, codd = [], []\\n        \\n        for i in A:\\n            for j in range(ln):\\n                if j % 2 == 0:\\n                    ceven.append(i[j])\\n                \\n                else:\\n                    codd.append(i[j])\\n                    \\n            ceven.sort()\\n            codd.sort()\\n            ans.add((\\'\\'.join(ceven), \\'\\'.join(codd)))\\n            ceven.clear()\\n            codd.clear()\\n            \\n        return len(ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        ans = set()\\n        ln = len(A[0])\\n        ceven, codd = [], []\\n        \\n        for i in A:\\n            for j in range(ln):\\n                if j % 2 == 0:\\n                    ceven.append(i[j])\\n                \\n                else:\\n                    codd.append(i[j])\\n                    \\n            ceven.sort()\\n            codd.sort()\\n            ans.add((\\'\\'.join(ceven), \\'\\'.join(codd)))\\n            ceven.clear()\\n            codd.clear()\\n            \\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465857,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set=new HashSet();\\n        for(String s:A){\\n            int[] evenChars=new int[26];\\n            int[] oddChars=new int[26];\\n            for(int i=0;i<s.length();i++){\\n                if(i%2==0){\\n                    evenChars[s.charAt(i)-\\'a\\']++;\\n                }\\n                else{\\n                    oddChars[s.charAt(i)-\\'a\\']++;\\n                }\\n            }\\n            set.add(Arrays.toString(evenChars)+Arrays.toString(oddChars));\\n        }\\n        return set.size();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set=new HashSet();\\n        for(String s:A){\\n            int[] evenChars=new int[26];\\n            int[] oddChars=new int[26];\\n            for(int i=0;i<s.length();i++){\\n                if(i%2==0){\\n                    evenChars[s.charAt(i)-\\'a\\']++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 458813,
                "title": "c-solution-with-linq",
                "content": "```\\npublic int NumSpecialEquivGroups(string[] A) {\\n\\treturn A.Select(Order).Distinct().Count();\\n\\n\\tstring Order(string s) {\\n\\t\\tvar chars = s.Select((c, i) => (i, c)).ToArray();\\n\\t\\tvar evens = chars.Where(t => t.i % 2 == 0).Select(t => t.c).OrderBy(c => c);\\n\\t\\tvar odds = chars.Where(t => t.i % 2 == 1).Select(t => t.c).OrderBy(c => c);\\n\\n\\t\\treturn new string(evens.Concat(odds).ToArray());\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumSpecialEquivGroups(string[] A) {\\n\\treturn A.Select(Order).Distinct().Count();\\n\\n\\tstring Order(string s) {\\n\\t\\tvar chars = s.Select((c, i) => (i, c)).ToArray();\\n\\t\\tvar evens = chars.Where(t => t.i % 2 == 0).Select(t => t.c).OrderBy(c => c);\\n\\t\\tvar odds = chars.Where(t => t.i % 2 == 1).Select(t => t.c).OrderBy(c => c);\\n\\n\\t\\treturn new string(evens.Concat(odds).ToArray());\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 433339,
                "title": "count-the-characters-at-even-and-odd-positions",
                "content": "```csharp\\npublic int NumSpecialEquivGroups(string[] A)\\n{\\n\\tHashSet<string> groupCount = new HashSet<string>();\\n\\n\\tforeach (var a in A)\\n\\t{\\n\\t\\tint[] frequency = new int[26 * 2];\\n\\t\\tfor (int i = 0; i < a.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (i % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfrequency[a[i] - \\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfrequency[26 + a[i] - \\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring key = string.Join(\",\", frequency);\\n\\t\\tgroupCount.Add(key);\\n\\t}\\n\\n\\treturn groupCount.Count;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int NumSpecialEquivGroups(string[] A)\\n{\\n\\tHashSet<string> groupCount = new HashSet<string>();\\n\\n\\tforeach (var a in A)\\n\\t{\\n\\t\\tint[] frequency = new int[26 * 2];\\n\\t\\tfor (int i = 0; i < a.Length; i++)\\n\\t\\t{\\n\\t\\t\\tif (i % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfrequency[a[i] - \\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tfrequency[26 + a[i] - \\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring key = string.Join(\",\", frequency);\\n\\t\\tgroupCount.Add(key);\\n\\t}\\n\\n\\treturn groupCount.Count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410934,
                "title": "brute-force-and-optimized-solution-in-cpp",
                "content": "Here we have to sort substrings so nlogn!\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        map<string,vector<string>>m;\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string odd=\"\";\\n            string even=\"\";\\n            for(int j=0;j<a[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    even=even+a[i][j];\\n                else\\n                    odd=odd+a[i][j];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            string res=even+odd;\\n            m[res].push_back(a[i]);\\n        }\\n        return m.size();\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        set<vector<int>>s;\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>count(52,0);\\n            for(int j=0;j<a[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    count[a[i][j]-\\'a\\']++;\\n                else\\n                    count[a[i][j]-\\'a\\'+26]++;\\n            }\\n          s.insert(count);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        map<string,vector<string>>m;\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string odd=\"\";\\n            string even=\"\";\\n            for(int j=0;j<a[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    even=even+a[i][j];\\n                else\\n                    odd=odd+a[i][j];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n            string res=even+odd;\\n            m[res].push_back(a[i]);\\n        }\\n        return m.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& a) {\\n        set<vector<int>>s;\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>count(52,0);\\n            for(int j=0;j<a[i].length();j++)\\n            {\\n                if(j%2==0)\\n                    count[a[i][j]-\\'a\\']++;\\n                else\\n                    count[a[i][j]-\\'a\\'+26]++;\\n            }\\n          s.insert(count);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353519,
                "title": "go-golang-clean-solution",
                "content": "Runtime: 4 ms, faster than 71.43% of Go online submissions for Groups of Special-Equivalent Strings.\\nMemory Usage: 4.3 MB, less than 100.00% of Go online submissions for Groups of Special-Equivalent Strings.\\n\\n```go\\nfunc numSpecialEquivGroups(A []string) int {\\n\\n\\ttmp := make(map[string]int)\\n    \\n\\tfor _, v := range A {\\n\\n\\t\\todd, even := []rune{}, []rune{}\\n\\n\\t\\tfor I, V := range v {\\n\\n\\t\\t\\tif I%2 == 0 {\\n\\t\\t\\t\\teven = append(even, V)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\todd = append(odd, V)\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tsort.Slice(even, func(i int, j int) bool { return even[i] < even[j] })\\n\\t\\tsort.Slice(odd, func(i int, j int) bool { return odd[i] < odd[j] })\\n\\t\\ttemp := append(even, odd...)\\n\\t\\ttmp[string(temp)]++\\n\\t}\\n\\n\\treturn len(tmp)\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc numSpecialEquivGroups(A []string) int {\\n\\n\\ttmp := make(map[string]int)\\n    \\n\\tfor _, v := range A {\\n\\n\\t\\todd, even := []rune{}, []rune{}\\n\\n\\t\\tfor I, V := range v {\\n\\n\\t\\t\\tif I%2 == 0 {\\n\\t\\t\\t\\teven = append(even, V)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\todd = append(odd, V)\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tsort.Slice(even, func(i int, j int) bool { return even[i] < even[j] })\\n\\t\\tsort.Slice(odd, func(i int, j int) bool { return odd[i] < odd[j] })\\n\\t\\ttemp := append(even, odd...)\\n\\t\\ttmp[string(temp)]++\\n\\t}\\n\\n\\treturn len(tmp)\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 346580,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set(\\'\\'.join(sorted(w[::2]) + sorted(w[1::2])) for w in A))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set(\\'\\'.join(sorted(w[::2]) + sorted(w[1::2])) for w in A))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336981,
                "title": "js-simple-solution-with-explanation",
                "content": "We can calculate the *signature* of each word in the word array, and see how many distinct *word signature* there are, which would be the result. The *signature* is defined as:\\n* extract all even-indexed chars and sort them\\n* extract all odd-indexed chars and sort them\\n* combine the above two\\n\\nTake the word \"abccba\" as example:\\n```\\noriginal word: abccba\\neven-indexed chars: a c b   --sort--> a b c --combine--> abc\\nodd-indexed chars: b c a --sort--> a b c --combine--> abc\\ncombine: abcabc\\n```\\n\"abcabc\" would be the signature for \"abccba\".\\n```\\n\\nvar numSpecialEquivGroups = function(A) {\\n    let s = new Set()\\n    for (let w of A) {\\n        let tmp = helper(w)\\n        s.add(tmp)\\n    }\\n    return s.size\\n};\\n\\nconst helper = function(s) {\\n    if (s.length <= 1)\\n        return s\\n    let fst = \\'\\', sec = \\'\\'\\n    for (let i = 0; i < s.length; i += 2)\\n        fst += s[i]\\n    fst = fst.split(\\'\\').sort().join(\\'\\')\\n    for (let i = 1; i < s.length; i += 2)\\n        sec += s[i]\\n    sec = sec.split(\\'\\').sort().join(\\'\\')\\n    return fst + sec\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\noriginal word: abccba\\neven-indexed chars: a c b   --sort--> a b c --combine--> abc\\nodd-indexed chars: b c a --sort--> a b c --combine--> abc\\ncombine: abcabc\\n```\n```\\n\\nvar numSpecialEquivGroups = function(A) {\\n    let s = new Set()\\n    for (let w of A) {\\n        let tmp = helper(w)\\n        s.add(tmp)\\n    }\\n    return s.size\\n};\\n\\nconst helper = function(s) {\\n    if (s.length <= 1)\\n        return s\\n    let fst = \\'\\', sec = \\'\\'\\n    for (let i = 0; i < s.length; i += 2)\\n        fst += s[i]\\n    fst = fst.split(\\'\\').sort().join(\\'\\')\\n    for (let i = 1; i < s.length; i += 2)\\n        sec += s[i]\\n    sec = sec.split(\\'\\').sort().join(\\'\\')\\n    return fst + sec\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 311765,
                "title": "python-sol-for-starters-extremely-easy",
                "content": "```python\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        length = len(A)\\n        res = set()\\n        for item in A:\\n            odds = item[::2]\\n            evens = item[1::2]\\n            res.add((str(sorted(odds)),str(sorted(evens))))\\n        return len(res)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        length = len(A)\\n        res = set()\\n        for item in A:\\n            odds = item[::2]\\n            evens = item[1::2]\\n            res.add((str(sorted(odds)),str(sorted(evens))))\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300132,
                "title": "c-beat-99-with-explanation",
                "content": "\\tafter realizing the question, all we have to do is the check if odd/even position pattern is the same between two string.\\n\\tfor instance : \"abcdefggyy\"\\n\\todd pattern : \"acegy\"\\n\\teven pattern : \"bdfgy\"\\n\\twe can simply check those pattern after sorting.\\n\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        map<std::pair<string,string>,int> mymap; // key:pattern pair\\n        for(int i = 0 ; i < A.size() ; i++){\\n            string s[2];\\n            for(int j = 0 ; j < A[i].length() ; j++)\\n                s[j%2]+= A[i][j];\\n            sort(s[0].begin(),s[0].end()),sort(s[1].begin(),s[1].end());\\n            mymap[{s[0],s[1]}]++;\\n        }\\n        return mymap.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        map<std::pair<string,string>,int> mymap; // key:pattern pair\\n        for(int i = 0 ; i < A.size() ; i++){\\n            string s[2];\\n            for(int j = 0 ; j < A[i].length() ; j++)\\n                s[j%2]+= A[i][j];\\n            sort(s[0].begin(),s[0].end()),sort(s[1].begin(),s[1].end());\\n            mymap[{s[0],s[1]}]++;\\n        }\\n        return mymap.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285486,
                "title": "python3-one-line-solution",
                "content": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set([(\\'\\'.join(sorted(i[::2])),\\'\\'.join(sorted(i[1::2]))) for i in A]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        return len(set([(\\'\\'.join(sorted(i[::2])),\\'\\'.join(sorted(i[1::2]))) for i in A]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283634,
                "title": "why-the-answer-of-abcd-cdab-adcb-cbad-last-test-case-35-is-2-not-1-in-example-4",
                "content": "Below is my code. It passed the example 4 when testing but failed it after I submitted (the last test case). \\nI\\'ve checked many times and, if I am correct, found the 35-th test case should be the same as example 4. \\nIs there anyone who knows why it has two different answers? Thanks.\\n```\\n    def numSpecialEquivGroups(self, A):\\n        table = set()\\n        for string in A:\\n            set0 = frozenset(string[::2]) # mod 2 = 0\\n            set1 = frozenset(string[1::2]) # mod 2 = 1\\n            table.add((set0, set1))\\n        return len(table)\\n```\\n![image](https://assets.leetcode.com/users/victorchen1028/image_1556525968.png)\\n",
                "solutionTags": [],
                "code": "```\\n    def numSpecialEquivGroups(self, A):\\n        table = set()\\n        for string in A:\\n            set0 = frozenset(string[::2]) # mod 2 = 0\\n            set1 = frozenset(string[1::2]) # mod 2 = 1\\n            table.add((set0, set1))\\n        return len(table)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 261975,
                "title": "two-lines-python-solution",
                "content": "\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        # re-order string based on special equvilant\\n        lists = [ \\'\\'.join([\\'\\'.join(sorted(a[0::2])),\\'\\'.join(sorted(a[1::2]))]) for a in A ]\\n        return len(Counter(lists).keys())\\n```\\n\\nexplanation:\\n`a[0::2]` will give all the letters on the even number positions.\\n`a[1::2]` will give all the letters on the odd number positions.\\n`sorted` them to fix an order since we could achieve it with certain number of moves.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\\n        # re-order string based on special equvilant\\n        lists = [ \\'\\'.join([\\'\\'.join(sorted(a[0::2])),\\'\\'.join(sorted(a[1::2]))]) for a in A ]\\n        return len(Counter(lists).keys())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254323,
                "title": "javascript-easy-solution",
                "content": "``` JavaScript\\nvar numSpecialEquivGroups = function(A) {\\n    const map = A.reduce((res, str) => {\\n    \\tconst key = transString(str);\\n    \\tif (key in res) {\\n    \\t\\tres[key] += 1;\\n    \\t} else {\\n    \\t\\tres[key] = 1;\\n    \\t}\\n    \\treturn res;\\n    }, {});\\n    return Object.keys(map).length;\\n};\\n\\nfunction transString(str) {\\n\\tconst odd = [], even = [];\\n\\tfor (let i = 0; i < str.length; i++) {\\n\\t\\tif (i % 2 === 0) {\\n\\t\\t\\teven.push(str[i]);\\n\\t\\t} else {\\n\\t\\t\\todd.push(str[i]);\\n\\t\\t}\\n\\t}\\n\\treturn odd.sort().join(\\'\\') + \\';\\' + even.sort().join(\\'\\');\\n}\\n```",
                "solutionTags": [],
                "code": "``` JavaScript\\nvar numSpecialEquivGroups = function(A) {\\n    const map = A.reduce((res, str) => {\\n    \\tconst key = transString(str);\\n    \\tif (key in res) {\\n    \\t\\tres[key] += 1;\\n    \\t} else {\\n    \\t\\tres[key] = 1;\\n    \\t}\\n    \\treturn res;\\n    }, {});\\n    return Object.keys(map).length;\\n};\\n\\nfunction transString(str) {\\n\\tconst odd = [], even = [];\\n\\tfor (let i = 0; i < str.length; i++) {\\n\\t\\tif (i % 2 === 0) {\\n\\t\\t\\teven.push(str[i]);\\n\\t\\t} else {\\n\\t\\t\\todd.push(str[i]);\\n\\t\\t}\\n\\t}\\n\\treturn odd.sort().join(\\'\\') + \\';\\' + even.sort().join(\\'\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 191573,
                "title": "java-solution-using-set",
                "content": "The feature of Set is that there will be no duplicate elements, so as long as the size of the Set is counted, you can know how many different ones are. Plus, sort even and odd positions separately and save them into set.\\n```\\npublic int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for(String a : A){\\n            int n = a.length();\\n            char[] odd = new char[(n + 1)/2];\\n            char[] even = new char[(n + 1)/2];\\n            int to = 0, te = 0;\\n            for(int i = 0; i < a.length(); i++){\\n                if(i % 2 == 0) even[te++] = a.charAt(i);\\n                else odd[to++] = a.charAt(i);\\n            }\\n            Arrays.sort(odd);\\n            Arrays.sort(even);\\n            set.add(String.valueOf(odd)+String.valueOf(even));\\n        }\\n        return set.size();\\n    }```",
                "solutionTags": [],
                "code": "```\\npublic int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for(String a : A){\\n            int n = a.length();\\n            char[] odd = new char[(n + 1)/2];\\n            char[] even = new char[(n + 1)/2];\\n            int to = 0, te = 0;\\n            for(int i = 0; i < a.length(); i++){\\n                if(i % 2 == 0) even[te++] = a.charAt(i);\\n                else odd[to++] = a.charAt(i);\\n            }\\n            Arrays.sort(odd);\\n            Arrays.sort(even);\\n            set.add(String.valueOf(odd)+String.valueOf(even));\\n        }\\n        return set.size();\\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 187031,
                "title": "c-solution-based-on-sequential-multiplication-of-ascii-codes",
                "content": "the solution is based on multiplication of characters\\' ASCII codes, which don\\'t intersect in sense of  the following property: \\n```\\nascii(x) * ascii(y) != ascii(p) * ascii(q), where pairs of symbols (x, y) and (p, q) are different\\n```\\n\\ngiven the property, we can multiply over all the ascii codes of even- and odd-indexed (independently) characters in the string and then store them as unique pairs of result products in an _ordered_ set. Then, we count unique pairs\\nThe solution goes with O(n) time complexity and O(n) space complexity\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        std::set<std::pair<uint64_t, uint64_t>> s;\\n        for (auto &str : A) {\\n            std::pair<uint64_t, uint64_t> res{1, 1};\\n            for (int i = 0; i < str.size(); ++i) {\\n                if (0 == i % 2) res.first *= str[i];\\n                else res.second *= str[i];\\n            }\\n            s.insert(res);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nascii(x) * ascii(y) != ascii(p) * ascii(q), where pairs of symbols (x, y) and (p, q) are different\\n```\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& A) {\\n        std::set<std::pair<uint64_t, uint64_t>> s;\\n        for (auto &str : A) {\\n            std::pair<uint64_t, uint64_t> res{1, 1};\\n            for (int i = 0; i < str.size(); ++i) {\\n                if (0 == i % 2) res.first *= str[i];\\n                else res.second *= str[i];\\n            }\\n            s.insert(res);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 178368,
                "title": "python-very-simple-easy-to-read-using-dictionary",
                "content": "This implementation can also return no.of elements in each group by changing the `return` statement\n```\nclass Solution:\n    def numSpecialEquivGroups(self, A):\n        d = dict()\n        for i in A:\n            if len(i) >= 2:\n                key = (tuple(sorted(i[::2])), tuple(sorted(i[1::2])))\n                d[key] = d.get(key,0) + 1\n            else:\n                d[i] = d.get(i,0) + 1     \n        return len(d) \n```",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def numSpecialEquivGroups(self, A):\n        d = dict()\n        for i in A:\n            if len(i) >= 2:\n                key = (tuple(sorted(i[::2])), tuple(sorted(i[1::2])))\n                d[key] = d.get(key,0) + 1\n            else:\n                d[i] = d.get(i,0) + 1     \n        return len(d) \n```",
                "codeTag": "Java"
            },
            {
                "id": 169632,
                "title": "c-beat-100-use-both-unordered-map-and-unordered-set",
                "content": "```\\nint numSpecialEquivGroups(vector<string>& A) {\\n        int res = 0;\\n        unordered_map<string,unordered_set<string>> table;// odd | evens\\n        for(int i = 0; i < A.size(); i++){\\n            int j = 0;\\n            string odds = \"\";\\n            string evens = \"\";\\n            while(j < A[i].size()){\\n                if(j%2 == 0)\\n                    evens = evens+A[i][j];\\n                if(j%2 == 1)\\n                    odds = odds+A[i][j];\\n                j++;\\n            }\\n            sort(evens.begin(),evens.end());\\n            sort(odds.begin(),odds.end());\\n            if(table[odds].find(evens) == table[odds].end()){\\n                res++;\\n                table[odds].insert(evens);\\n            }    \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numSpecialEquivGroups(vector<string>& A) {\\n        int res = 0;\\n        unordered_map<string,unordered_set<string>> table;// odd | evens\\n        for(int i = 0; i < A.size(); i++){\\n            int j = 0;\\n            string odds = \"\";\\n            string evens = \"\";\\n            while(j < A[i].size()){\\n                if(j%2 == 0)\\n                    evens = evens+A[i][j];\\n                if(j%2 == 1)\\n                    odds = odds+A[i][j];\\n                j++;\\n            }\\n            sort(evens.begin(),evens.end());\\n            sort(odds.begin(),odds.end());\\n            if(table[odds].find(evens) == table[odds].end()){\\n                res++;\\n                table[odds].insert(evens);\\n            }    \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165769,
                "title": "concise-java-solution-using-char",
                "content": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> groups = new HashSet<>();\\n        for (String str : A) {\\n            char[] chars = str.toCharArray();\\n            char[] odd = new char[20];\\n            char[] even = new char[20];\\n            for (int i = 0; i < chars.length; i++) {\\n                if (i % 2 == 0) {\\n                    odd[i] = chars[i];\\n                } else {\\n                    even[i] = chars[i];\\n                }\\n            }\\n            Arrays.sort(odd);\\n            Arrays.sort(even);\\n            String unique = String.valueOf(odd) + String.valueOf(even);\\n            groups.add(unique);\\n        }\\n        return groups.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> groups = new HashSet<>();\\n        for (String str : A) {\\n            char[] chars = str.toCharArray();\\n            char[] odd = new char[20];\\n            char[] even = new char[20];\\n            for (int i = 0; i < chars.length; i++) {\\n                if (i % 2 == 0) {\\n                    odd[i] = chars[i];\\n                } else {\\n                    even[i] = chars[i];\\n                }\\n            }\\n            Arrays.sort(odd);\\n            Arrays.sort(even);\\n            String unique = String.valueOf(odd) + String.valueOf(even);\\n            groups.add(unique);\\n        }\\n        return groups.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164241,
                "title": "javascript-not-the-fastest-but-i-like-it",
                "content": "```\\nvar numSpecialEquivGroups = function(A) {\\n    return A.reduce((prev, curr) => {\\n        let left = \"\"\\n        let right = \"\"\\n        for(let i=0; i<curr.length; i++){\\n            i%2===0 ? left += curr[i] : right += curr[i] \\n        }\\n        left = [...left].sort().join(\"\")\\n        right = [...right].sort().join(\"\")\\n        for(let i=0; i<prev.length; i++){\\n            if(prev[i][0] === left && prev[i][1] === right){\\n                return prev\\n            }\\n        }\\n        prev.push([left,right])\\n        return prev\\n    }, []).length\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numSpecialEquivGroups = function(A) {\\n    return A.reduce((prev, curr) => {\\n        let left = \"\"\\n        let right = \"\"\\n        for(let i=0; i<curr.length; i++){\\n            i%2===0 ? left += curr[i] : right += curr[i] \\n        }\\n        left = [...left].sort().join(\"\")\\n        right = [...right].sort().join(\"\")\\n        for(let i=0; i<prev.length; i++){\\n            if(prev[i][0] === left && prev[i][1] === right){\\n                return prev\\n            }\\n        }\\n        prev.push([left,right])\\n        return prev\\n    }, []).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 163535,
                "title": "python-straightforward-solution",
                "content": "```\\nclass Solution(object):\\n\\tdef numSpecialEquivGroups(self, A):\\n\\t\\t\"\"\"\\n\\t\\t:type A: List[str]\\n\\t\\t:rtype: int\\n\\t\\t\"\"\"\\n\\t\\tB = set()\\n\\t\\tfor string in A:\\n\\t\\t\\tC = list(string)\\n\\t\\t\\ta, b = C[::2], C[1::2]\\n\\t\\t\\tB.add((\\'\\'.join(sorted(a)), \\'\\'.join(sorted(b))))\\n\\t\\t\\t\\n\\t\\treturn len(B)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\tdef numSpecialEquivGroups(self, A):\\n\\t\\t\"\"\"\\n\\t\\t:type A: List[str]\\n\\t\\t:rtype: int\\n\\t\\t\"\"\"\\n\\t\\tB = set()\\n\\t\\tfor string in A:\\n\\t\\t\\tC = list(string)\\n\\t\\t\\ta, b = C[::2], C[1::2]\\n\\t\\t\\tB.add((\\'\\'.join(sorted(a)), \\'\\'.join(sorted(b))))\\n\\t\\t\\t\\n\\t\\treturn len(B)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163442,
                "title": "java-sorting-solution",
                "content": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : A) {\\n            String key = sort(s);\\n            set.add(key);\\n        }\\n        return set.size();\\n    }\\n    private String sort(String s) {\\n        List<Character> l1 = new ArrayList<>();\\n        List<Character> l2 = new ArrayList<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i % 2 == 0) {\\n                l1.add(s.charAt(i));\\n            } else {\\n                l2.add(s.charAt(i));\\n            }\\n        }\\n        Collections.sort(l1);\\n        Collections.sort(l2);\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : l1) {\\n            sb.append(c);\\n        }\\n        for (char c : l2) {\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] A) {\\n        Set<String> set = new HashSet<>();\\n        for (String s : A) {\\n            String key = sort(s);\\n            set.add(key);\\n        }\\n        return set.size();\\n    }\\n    private String sort(String s) {\\n        List<Character> l1 = new ArrayList<>();\\n        List<Character> l2 = new ArrayList<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i % 2 == 0) {\\n                l1.add(s.charAt(i));\\n            } else {\\n                l2.add(s.charAt(i));\\n            }\\n        }\\n        Collections.sort(l1);\\n        Collections.sort(l2);\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : l1) {\\n            sb.append(c);\\n        }\\n        for (char c : l2) {\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102505,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = {}\\n\\n        for i,word in enumerate(words):\\n            even, odd = \"\", \"\"\\n            for j in range(len(word)):\\n                if j % 2 == 0:\\n                    even += word[j]\\n                else:\\n                    odd += word[j]\\n            \\n            even = list(even)\\n            even.sort()\\n            even = \"\".join(even)\\n            odd = list(odd)\\n            odd.sort()\\n            odd = \"\".join(odd)\\n\\n            if even+odd in d:\\n                d[even+odd] += 1\\n            else:\\n                d[even+odd] = 1\\n\\n        return len(d)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        d = {}\\n\\n        for i,word in enumerate(words):\\n            even, odd = \"\", \"\"\\n            for j in range(len(word)):\\n                if j % 2 == 0:\\n                    even += word[j]\\n                else:\\n                    odd += word[j]\\n            \\n            even = list(even)\\n            even.sort()\\n            even = \"\".join(even)\\n            odd = list(odd)\\n            odd.sort()\\n            odd = \"\".join(odd)\\n\\n            if even+odd in d:\\n                d[even+odd] += 1\\n            else:\\n                d[even+odd] = 1\\n\\n        return len(d)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081089,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            String evens = \"\";\\n            String odds = \"\";\\n            for (int i = 0; i < word.length(); i++) {\\n                if (i % 2 == 0) {\\n                    evens += String.valueOf(word.charAt(i));\\n                } else {\\n                    odds += String.valueOf(word.charAt(i));\\n                }\\n            }\\n            char[] evensChar = evens.toCharArray();\\n            Arrays.sort(evensChar);\\n            char[] oddsChar = odds.toCharArray();\\n            Arrays.sort(oddsChar);\\n            set.add(String.valueOf(evensChar) + String.valueOf(oddsChar));\\n        }\\n        return set.size();\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int sz=words.size(),ct=0;\\n       // map<int,vector<int>>mp;\\n        vector<bool>vis(sz,false);\\n          for(int i=0;i<words.size();i++)\\n            {\\n              if(vis[i]==true)\\n                  continue;\\n              vector<char>even1,odd1;\\n              //seperate even and odd indices in differnent vectors\\n              for(int j=0;j<words[i].size();j++)\\n                  {\\n                    if(j%2==0)\\n                      even1.push_back(words[i][j]);\\n                    else\\n                      odd1.push_back(words[i][j]);\\n                  }\\n                 \\n                  //sort even and odd indices \\n                  sort(even1.begin(),even1.end());\\n                  sort(odd1.begin(),odd1.end());\\n              for(int j=i+1;j<sz;j++)\\n                 {\\n                    vector<char>even2,odd2;\\n                      \\n                        for(int i=0;i<words[j].size();i++)\\n                         {\\n                        if(i%2==0)\\n                           even2.push_back(words[j][i]);\\n                        else\\n                           odd2.push_back(words[j][i]);\\n                         }\\n                    sort(even2.begin(),even2.end());\\n                    sort(odd2.begin(),odd2.end());\\n                    //compare all even postion char and odd char are same if same then push it into the vector and mark is as visited\\n                if(even1==even2 and odd1==odd2)\\n                   {\\n                     \\n                         \\n                       vis[j]=true;\\n                           // mp[i].push_back(j);                    \\n                   }\\n                 }\\n              //if no match found then push empty index in vector\\n                ct++;\\n            }\\n            return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            String evens = \"\";\\n            String odds = \"\";\\n            for (int i = 0; i < word.length(); i++) {\\n                if (i % 2 == 0) {\\n                    evens += String.valueOf(word.charAt(i));\\n                } else {\\n                    odds += String.valueOf(word.charAt(i));\\n                }\\n            }\\n            char[] evensChar = evens.toCharArray();\\n            Arrays.sort(evensChar);\\n            char[] oddsChar = odds.toCharArray();\\n            Arrays.sort(oddsChar);\\n            set.add(String.valueOf(evensChar) + String.valueOf(oddsChar));\\n        }\\n        return set.size();\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int sz=words.size(),ct=0;\\n       // map<int,vector<int>>mp;\\n        vector<bool>vis(sz,false);\\n          for(int i=0;i<words.size();i++)\\n            {\\n              if(vis[i]==true)\\n                  continue;\\n              vector<char>even1,odd1;\\n              //seperate even and odd indices in differnent vectors\\n              for(int j=0;j<words[i].size();j++)\\n                  {\\n                    if(j%2==0)\\n                      even1.push_back(words[i][j]);\\n                    else\\n                      odd1.push_back(words[i][j]);\\n                  }\\n                 \\n                  //sort even and odd indices \\n                  sort(even1.begin(),even1.end());\\n                  sort(odd1.begin(),odd1.end());\\n              for(int j=i+1;j<sz;j++)\\n                 {\\n                    vector<char>even2,odd2;\\n                      \\n                        for(int i=0;i<words[j].size();i++)\\n                         {\\n                        if(i%2==0)\\n                           even2.push_back(words[j][i]);\\n                        else\\n                           odd2.push_back(words[j][i]);\\n                         }\\n                    sort(even2.begin(),even2.end());\\n                    sort(odd2.begin(),odd2.end());\\n                    //compare all even postion char and odd char are same if same then push it into the vector and mark is as visited\\n                if(even1==even2 and odd1==odd2)\\n                   {\\n                     \\n                         \\n                       vis[j]=true;\\n                           // mp[i].push_back(j);                    \\n                   }\\n                 }\\n              //if no match found then push empty index in vector\\n                ct++;\\n            }\\n            return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023782,
                "title": "rust-solution",
                "content": "# Code\\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn num_special_equiv_groups(words: Vec<String>) -> i32 {\\n       let mut hashset:HashSet::<String> = HashSet::new(); \\n\\n        for word in words{\\n            let mut even:Vec<char> = Vec::new();\\n            let mut odd:Vec<char> = Vec::new();\\n            for (idx,w) in word.chars().enumerate(){\\n                if idx % 2 == 0{\\n                    even.push(w);\\n                }else{\\n                    odd.push(w);\\n                }\\n            }\\n            even.sort();\\n            odd.sort();\\n            let my_str  = format!(\"{}{}\",\\n            even.iter().collect::<String>(),\\n            odd.iter().collect::<String>());\\n            hashset.insert(my_str);\\n        }\\n        let out = hashset.len() as i32;\\n        out\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn num_special_equiv_groups(words: Vec<String>) -> i32 {\\n       let mut hashset:HashSet::<String> = HashSet::new(); \\n\\n        for word in words{\\n            let mut even:Vec<char> = Vec::new();\\n            let mut odd:Vec<char> = Vec::new();\\n            for (idx,w) in word.chars().enumerate(){\\n                if idx % 2 == 0{\\n                    even.push(w);\\n                }else{\\n                    odd.push(w);\\n                }\\n            }\\n            even.sort();\\n            odd.sort();\\n            let my_str  = format!(\"{}{}\",\\n            even.iter().collect::<String>(),\\n            odd.iter().collect::<String>());\\n            hashset.insert(my_str);\\n        }\\n        let out = hashset.len() as i32;\\n        out\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009402,
                "title": "naive-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>&w){\\n        unordered_set<string>st;\\n        vector<int>v;\\n        for(int i=0; i<w.size(); i++){\\n            if(st.find(w[i])!=st.end()){\\n                continue;\\n            }\\n            else{\\n                st.insert(w[i]);\\n                string s1,s2;\\n                for(int j=0; j<w[i].size(); j+=2){\\n                    s1+=w[i][j];\\n                }\\n                for(int j=1; j<w[i].size(); j+=2){\\n                    s2+=w[i][j];\\n                }\\n                sort(s1.begin(),s1.end());\\n                sort(s2.begin(),s2.end());\\n                int c=0;\\n                for(int j=i+1; j<w.size(); j++){\\n                    string t1 , t2;\\n                    for(int k=0; k<w[j].size(); k+=2){\\n                        t1+=w[j][k];\\n                    }\\n                    for(int k=1; k<w[j].size(); k+=2){\\n                        t2+=w[j][k];\\n                    }\\n                    sort(t1.begin(),t1.end());\\n                    sort(t2.begin(),t2.end());\\n                    if(t1==s1 && t2==s2){\\n                        c++;\\n                        st.insert(w[j]);\\n                    }\\n                }\\n                v.push_back(c);\\n            }\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>&w){\\n        unordered_set<string>st;\\n        vector<int>v;\\n        for(int i=0; i<w.size(); i++){\\n            if(st.find(w[i])!=st.end()){\\n                continue;\\n            }\\n            else{\\n                st.insert(w[i]);\\n                string s1,s2;\\n                for(int j=0; j<w[i].size(); j+=2){\\n                    s1+=w[i][j];\\n                }\\n                for(int j=1; j<w[i].size(); j+=2){\\n                    s2+=w[i][j];\\n                }\\n                sort(s1.begin(),s1.end());\\n                sort(s2.begin(),s2.end());\\n                int c=0;\\n                for(int j=i+1; j<w.size(); j++){\\n                    string t1 , t2;\\n                    for(int k=0; k<w[j].size(); k+=2){\\n                        t1+=w[j][k];\\n                    }\\n                    for(int k=1; k<w[j].size(); k+=2){\\n                        t2+=w[j][k];\\n                    }\\n                    sort(t1.begin(),t1.end());\\n                    sort(t2.begin(),t2.end());\\n                    if(t1==s1 && t2==s2){\\n                        c++;\\n                        st.insert(w[j]);\\n                    }\\n                }\\n                v.push_back(c);\\n            }\\n        }\\n        return v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006307,
                "title": "python-solution-using-hashmap-and-helper-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        #an array \\'words\\' of strings of the same length\\n        #in one move i can swap any two even indexed chars or any two odd indexed\\n        #chars in word in words\\n        #two words in array words are special equivalent if after any number of moves\\n        #they can be the same\\n        #return the number of groups of special equivalent strings from words\\n        #to group them i think i have to use a hashmap\\n        #i should also define a helper function that can help me compare two strings\\n        #based on whether if they are special equivalent\\n\\n\\n        def specialEquivalence(s1):\\n            odd_1 = \"\"\\n            even_1 = \"\"\\n            for i in range(len(s1)):\\n                if i % 2 == 0:\\n                    even_1 += s1[i]\\n                else:\\n                    odd_1 += s1[i]\\n            return \"\".join((sorted(even_1) + sorted(odd_1)))\\n        \\n        lookup = {}\\n\\n        for word in words:\\n            lookup[specialEquivalence(word)] = 1 + lookup.get(specialEquivalence(word), 0)\\n        \\n        return len(lookup.keys())\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numSpecialEquivGroups(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\n\\n        #an array \\'words\\' of strings of the same length\\n        #in one move i can swap any two even indexed chars or any two odd indexed\\n        #chars in word in words\\n        #two words in array words are special equivalent if after any number of moves\\n        #they can be the same\\n        #return the number of groups of special equivalent strings from words\\n        #to group them i think i have to use a hashmap\\n        #i should also define a helper function that can help me compare two strings\\n        #based on whether if they are special equivalent\\n\\n\\n        def specialEquivalence(s1):\\n            odd_1 = \"\"\\n            even_1 = \"\"\\n            for i in range(len(s1)):\\n                if i % 2 == 0:\\n                    even_1 += s1[i]\\n                else:\\n                    odd_1 += s1[i]\\n            return \"\".join((sorted(even_1) + sorted(odd_1)))\\n        \\n        lookup = {}\\n\\n        for word in words:\\n            lookup[specialEquivalence(word)] = 1 + lookup.get(specialEquivalence(word), 0)\\n        \\n        return len(lookup.keys())\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998269,
                "title": "easy-c-solution-using-set-5-ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) \\n    {\\n        set<string>S ;\\n        for(auto& it : words)\\n        {\\n            string even , odd ;\\n            for(int i = 0 ; i < it.size() ; i++)\\n            {\\n                if(i%2 == 0)\\n                    even += it[i];\\n                else\\n                    odd+= it[i];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n\\n            even += odd ;\\n            if(S.find(even) == S.end())\\n                S.insert(even);\\n        }\\n        return S.size();    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) \\n    {\\n        set<string>S ;\\n        for(auto& it : words)\\n        {\\n            string even , odd ;\\n            for(int i = 0 ; i < it.size() ; i++)\\n            {\\n                if(i%2 == 0)\\n                    even += it[i];\\n                else\\n                    odd+= it[i];\\n            }\\n            sort(even.begin(),even.end());\\n            sort(odd.begin(),odd.end());\\n\\n            even += odd ;\\n            if(S.find(even) == S.end())\\n                S.insert(even);\\n        }\\n        return S.size();    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985024,
                "title": "python3-convert-characters-at-odd-and-even-indices-into-a-hash-count-unique-hashes",
                "content": "# Code\\n```\\nclass Solution:\\n    # Approach: Form a dictionary (h1, h2) -> [s1,s2...sn]\\n    # where h1 and h2 are two hashes -  sorted characters\\n    # at the odd and even indices respectively in the word.\\n    # So (h1,h2) will be the same for all special-equivalent strings.\\n    # Then count the number of unique hashes.\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n\\n        def build_hash(s:str) -> Tuple[str, str]:\\n            odd_chars = []\\n            even_chars = []\\n            for idx, c in enumerate(s):\\n                if idx % 2:\\n                    odd_chars.append(c)\\n                else:\\n                    even_chars.append(c)\\n            odd_chars.sort()\\n            even_chars.sort()\\n            return (\\'\\'.join(odd_chars), \\'\\'.join(even_chars))\\n\\n        word_hash_set = set()\\n        for w in words:\\n            word_hash_set.add(build_hash(w))\\n        return len(word_hash_set)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # Approach: Form a dictionary (h1, h2) -> [s1,s2...sn]\\n    # where h1 and h2 are two hashes -  sorted characters\\n    # at the odd and even indices respectively in the word.\\n    # So (h1,h2) will be the same for all special-equivalent strings.\\n    # Then count the number of unique hashes.\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n\\n        def build_hash(s:str) -> Tuple[str, str]:\\n            odd_chars = []\\n            even_chars = []\\n            for idx, c in enumerate(s):\\n                if idx % 2:\\n                    odd_chars.append(c)\\n                else:\\n                    even_chars.append(c)\\n            odd_chars.sort()\\n            even_chars.sort()\\n            return (\\'\\'.join(odd_chars), \\'\\'.join(even_chars))\\n\\n        word_hash_set = set()\\n        for w in words:\\n            word_hash_set.add(build_hash(w))\\n        return len(word_hash_set)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980595,
                "title": "c-simple-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int sz=words.size(),ct=0;\\n       // map<int,vector<int>>mp;\\n        vector<bool>vis(sz,false);\\n          for(int i=0;i<words.size();i++)\\n            {\\n              if(vis[i]==true)\\n                  continue;\\n              vector<char>even1,odd1;\\n              //seperate even and odd indices in differnent vectors\\n              for(int j=0;j<words[i].size();j++)\\n                  {\\n                    if(j%2==0)\\n                      even1.push_back(words[i][j]);\\n                    else\\n                      odd1.push_back(words[i][j]);\\n                  }\\n                 \\n                  //sort even and odd indices \\n                  sort(even1.begin(),even1.end());\\n                  sort(odd1.begin(),odd1.end());\\n              for(int j=i+1;j<sz;j++)\\n                 {\\n                    vector<char>even2,odd2;\\n                      \\n                        for(int i=0;i<words[j].size();i++)\\n                         {\\n                        if(i%2==0)\\n                           even2.push_back(words[j][i]);\\n                        else\\n                           odd2.push_back(words[j][i]);\\n                         }\\n                    sort(even2.begin(),even2.end());\\n                    sort(odd2.begin(),odd2.end());\\n                    //compare all even postion char and odd char are same if same then push it into the vector and mark is as visited\\n                if(even1==even2 and odd1==odd2)\\n                   {\\n                     \\n                         \\n                       vis[j]=true;\\n                           // mp[i].push_back(j);                    \\n                   }\\n                 }\\n              //if no match found then push empty index in vector\\n                ct++;\\n            }\\n            return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        int sz=words.size(),ct=0;\\n       // map<int,vector<int>>mp;\\n        vector<bool>vis(sz,false);\\n          for(int i=0;i<words.size();i++)\\n            {\\n              if(vis[i]==true)\\n                  continue;\\n              vector<char>even1,odd1;\\n              //seperate even and odd indices in differnent vectors\\n              for(int j=0;j<words[i].size();j++)\\n                  {\\n                    if(j%2==0)\\n                      even1.push_back(words[i][j]);\\n                    else\\n                      odd1.push_back(words[i][j]);\\n                  }\\n                 \\n                  //sort even and odd indices \\n                  sort(even1.begin(),even1.end());\\n                  sort(odd1.begin(),odd1.end());\\n              for(int j=i+1;j<sz;j++)\\n                 {\\n                    vector<char>even2,odd2;\\n                      \\n                        for(int i=0;i<words[j].size();i++)\\n                         {\\n                        if(i%2==0)\\n                           even2.push_back(words[j][i]);\\n                        else\\n                           odd2.push_back(words[j][i]);\\n                         }\\n                    sort(even2.begin(),even2.end());\\n                    sort(odd2.begin(),odd2.end());\\n                    //compare all even postion char and odd char are same if same then push it into the vector and mark is as visited\\n                if(even1==even2 and odd1==odd2)\\n                   {\\n                     \\n                         \\n                       vis[j]=true;\\n                           // mp[i].push_back(j);                    \\n                   }\\n                 }\\n              //if no match found then push empty index in vector\\n                ct++;\\n            }\\n            return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966726,
                "title": "best-optimal-solution-linear",
                "content": "# Intuition\\nTricky Observation, if two strings have same characters then we can equate them using some swaps. No matter how many swaps we are going to use, but we can always equate them. Hence we are going to check characters present in odd and even places of two strings.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> mp ;\\n        for(auto x : words){\\n            string odd = \"\" , even = \"\" ;\\n            for(int i = 0; i <x.size() ; i++){\\n                if(i%2 == 0) even += x[i] ;\\n                else odd += x[i] ;\\n            }\\n            sort(odd.begin() , odd.end()) ;\\n            sort(even.begin(), even.end()) ;\\n            if(mp.find(odd+even) == mp.end()) mp.insert(odd+even) ;\\n        }\\n        return mp.size() ;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> mp ;\\n        for(auto x : words){\\n            string odd = \"\" , even = \"\" ;\\n            for(int i = 0; i <x.size() ; i++){\\n                if(i%2 == 0) even += x[i] ;\\n                else odd += x[i] ;\\n            }\\n            sort(odd.begin() , odd.end()) ;\\n            sort(even.begin(), even.end()) ;\\n            if(mp.find(odd+even) == mp.end()) mp.insert(odd+even) ;\\n        }\\n        return mp.size() ;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958495,
                "title": "best-easiest-solution-on-web-roght-now-i-am-a-genius",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        odd,even=\"\",\"\"\\n        final={}\\n        for i in words:\\n            for j in range(0,len(i)):\\n                if j%2==0:\\n                    even = even+i[j]\\n                else:\\n                    odd=odd+i[j]\\n            a = \"\".join(sorted(even)+sorted(odd))\\n            if a in final:\\n                final[a] = final[a]+1\\n            else:\\n                final[a]=1\\n            odd,even=\"\",\"\"\\n        return len(final)\\n                \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        odd,even=\"\",\"\"\\n        final={}\\n        for i in words:\\n            for j in range(0,len(i)):\\n                if j%2==0:\\n                    even = even+i[j]\\n                else:\\n                    odd=odd+i[j]\\n            a = \"\".join(sorted(even)+sorted(odd))\\n            if a in final:\\n                final[a] = final[a]+1\\n            else:\\n                final[a]=1\\n            odd,even=\"\",\"\"\\n        return len(final)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932744,
                "title": "straight-forward-solution-begineer-friendly-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String>st=new HashSet<>();\\n        for(String word:words){\\n            StringBuilder odd=new StringBuilder();\\n            StringBuilder even=new StringBuilder();\\n\\n\\n            for(int i=0;i<word.length();i++){\\n                if(i%2==0){\\n                    even.append(word.charAt(i));\\n                }\\n                else{\\n                    odd.append(word.charAt(i));\\n                }\\n            }\\n            String oddstr=odd.toString();\\n            String evenstr=even.toString();\\n\\n            char oddarr[]=oddstr.toCharArray();\\n            char evenarr[]=evenstr.toCharArray();\\n            Arrays.sort(oddarr);\\n            Arrays.sort(evenarr);\\n\\n\\n            StringBuilder oddsorted=new StringBuilder(new String(oddarr));\\n            StringBuilder evensorted=new StringBuilder(new String(evenarr));\\n\\n            StringBuilder str=new StringBuilder();\\n            str.append(oddsorted);\\n            str.append(evensorted);\\n\\n            st.add(str.toString());\\n\\n\\n\\n\\n\\n        }\\n\\n\\n        return st.size();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String>st=new HashSet<>();\\n        for(String word:words){\\n            StringBuilder odd=new StringBuilder();\\n            StringBuilder even=new StringBuilder();\\n\\n\\n            for(int i=0;i<word.length();i++){\\n                if(i%2==0){\\n                    even.append(word.charAt(i));\\n                }\\n                else{\\n                    odd.append(word.charAt(i));\\n                }\\n            }\\n            String oddstr=odd.toString();\\n            String evenstr=even.toString();\\n\\n            char oddarr[]=oddstr.toCharArray();\\n            char evenarr[]=evenstr.toCharArray();\\n            Arrays.sort(oddarr);\\n            Arrays.sort(evenarr);\\n\\n\\n            StringBuilder oddsorted=new StringBuilder(new String(oddarr));\\n            StringBuilder evensorted=new StringBuilder(new String(evenarr));\\n\\n            StringBuilder str=new StringBuilder();\\n            str.append(oddsorted);\\n            str.append(evensorted);\\n\\n            st.add(str.toString());\\n\\n\\n\\n\\n\\n        }\\n\\n\\n        return st.size();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882303,
                "title": "hashmap-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        gloss = {}\\n        answer = 0\\n        for w in words:\\n            ev = []\\n            od = []\\n            for i, ch in enumerate(w):\\n                if i%2==0:\\n                    ev.append(ch)\\n                else:\\n                    od.append(ch)\\n            k_ev = tuple(sorted(ev))\\n            v_ev = tuple(sorted(od))\\n            if k_ev in gloss:\\n                if v_ev not in gloss[k_ev]:\\n                    gloss[k_ev].append(v_ev)\\n                    answer += 1\\n            else:\\n                answer += 1\\n                gloss[k_ev] = [v_ev]\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        gloss = {}\\n        answer = 0\\n        for w in words:\\n            ev = []\\n            od = []\\n            for i, ch in enumerate(w):\\n                if i%2==0:\\n                    ev.append(ch)\\n                else:\\n                    od.append(ch)\\n            k_ev = tuple(sorted(ev))\\n            v_ev = tuple(sorted(od))\\n            if k_ev in gloss:\\n                if v_ev not in gloss[k_ev]:\\n                    gloss[k_ev].append(v_ev)\\n                    answer += 1\\n            else:\\n                answer += 1\\n                gloss[k_ev] = [v_ev]\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848562,
                "title": "c-hash-table",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, int> Map;\\n        for(string word: words) {\\n            string odd = \"\";\\n            string even = \"\";\\n            for(int i = 0; i < word.length(); i++) {\\n                if(i % 2 == 0) even += word[i];\\n                else odd += word[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            ++Map[odd + even];\\n        }\\n        return Map.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, int> Map;\\n        for(string word: words) {\\n            string odd = \"\";\\n            string even = \"\";\\n            for(int i = 0; i < word.length(); i++) {\\n                if(i % 2 == 0) even += word[i];\\n                else odd += word[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            ++Map[odd + even];\\n        }\\n        return Map.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796458,
                "title": "python-simple-set",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        res = set()\\n        for w in words: res.add(\\'\\'.join(sorted(w[::2]) + sorted(w[1::2])))\\n        return len(res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        res = set()\\n        for w in words: res.add(\\'\\'.join(sorted(w[::2]) + sorted(w[1::2])))\\n        return len(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780585,
                "title": "java-beats-56",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            String evens = \"\";\\n            String odds = \"\";\\n            for (int i = 0; i < word.length(); i++) {\\n                if (i % 2 == 0) {\\n                    evens += String.valueOf(word.charAt(i));\\n                } else {\\n                    odds += String.valueOf(word.charAt(i));\\n                }\\n            }\\n            char[] evensChar = evens.toCharArray();\\n            Arrays.sort(evensChar);\\n            char[] oddsChar = odds.toCharArray();\\n            Arrays.sort(oddsChar);\\n            set.add(String.valueOf(evensChar) + String.valueOf(oddsChar));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        Set<String> set = new HashSet<>();\\n        for (String word : words) {\\n            String evens = \"\";\\n            String odds = \"\";\\n            for (int i = 0; i < word.length(); i++) {\\n                if (i % 2 == 0) {\\n                    evens += String.valueOf(word.charAt(i));\\n                } else {\\n                    odds += String.valueOf(word.charAt(i));\\n                }\\n            }\\n            char[] evensChar = evens.toCharArray();\\n            Arrays.sort(evensChar);\\n            char[] oddsChar = odds.toCharArray();\\n            Arrays.sort(oddsChar);\\n            set.add(String.valueOf(evensChar) + String.valueOf(oddsChar));\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736872,
                "title": "c-easy-solution-sorting-unordered-set-explanation",
                "content": "# EXPLANATION\\nCreated unordered set to store answer and deal with duplicates.\\nTraversed through words vector.\\nPushed the string in even position in **a** and odd positions in **b**.\\nSort string **a** and **b** and insert the combination of **a and b** in set.\\nFinally returned the size of set.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> s;\\n        for(auto x:words){\\n            string a,b;\\n            for(int i=0;i<x.size();i++){\\n                if(i%2==0)\\n                    a.push_back(x[i]);\\n                else\\n                    b.push_back(x[i]);\\n            }\\n            sort(a.begin(),a.end());\\n            sort(b.begin(),b.end());\\n            s.insert(a+b);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> s;\\n        for(auto x:words){\\n            string a,b;\\n            for(int i=0;i<x.size();i++){\\n                if(i%2==0)\\n                    a.push_back(x[i]);\\n                else\\n                    b.push_back(x[i]);\\n            }\\n            sort(a.begin(),a.end());\\n            sort(b.begin(),b.end());\\n            s.insert(a+b);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717598,
                "title": "groups-of-special-equivalent-strings-js-easy-solution",
                "content": "\\n\\n# JS Easy\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar numSpecialEquivGroups = function(words) {\\n    let set = new Set();\\n  let data = [];\\n  for (let i of words) {\\n    let temp = [...i];\\n    let even = [];\\n    let odd = [];\\n    temp.forEach((w, index) => {\\n      if (index % 2 == 0) {\\n        even.push(w);\\n      } else {\\n        odd.push(w);\\n      }\\n    });\\n    even.sort();\\n    odd.sort();\\n    let demo = [...even, ...odd];\\n    data.push(demo.join(\"\"));\\n  }\\n  data.forEach((a) => {\\n    set.add(a);\\n  });\\n  return set.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar numSpecialEquivGroups = function(words) {\\n    let set = new Set();\\n  let data = [];\\n  for (let i of words) {\\n    let temp = [...i];\\n    let even = [];\\n    let odd = [];\\n    temp.forEach((w, index) => {\\n      if (index % 2 == 0) {\\n        even.push(w);\\n      } else {\\n        odd.push(w);\\n      }\\n    });\\n    even.sort();\\n    odd.sort();\\n    let demo = [...even, ...odd];\\n    data.push(demo.join(\"\"));\\n  }\\n  data.forEach((a) => {\\n    set.add(a);\\n  });\\n  return set.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3704853,
                "title": "quite-ordinary-approach",
                "content": "# Approach\\nSpecial-Equivalent strings have the same elements in even positions, as well as the same elements in odd positions.\\n\\n# Complexity\\n- Time complexity: $$O(n*wordlen*log(wordlen))$$.\\n\\n- Space complexity: $$O(n*wordlen)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        W = len(words[0])\\n        groups = set()\\n        for word in words:\\n            even, odd = [], []\\n            for i in range(0, W, 2):\\n                even.append(word[i])\\n            for i in range(1, W, 2):\\n                odd.append(word[i])\\n\\n            groups.add(\\'\\'.join(chain(sorted(even), sorted(odd))))\\n\\n        return len(groups)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        W = len(words[0])\\n        groups = set()\\n        for word in words:\\n            even, odd = [], []\\n            for i in range(0, W, 2):\\n                even.append(word[i])\\n            for i in range(1, W, 2):\\n                odd.append(word[i])\\n\\n            groups.add(\\'\\'.join(chain(sorted(even), sorted(odd))))\\n\\n        return len(groups)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701491,
                "title": "c-easy-solution-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nw - words count\\nl - letters count\\n$$O(w * l)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        var set = new HashSet<string>();\\n        foreach(var word in words)\\n        {\\n            var odd = new int[26];\\n            var even = new int[26];\\n            for (int i = 0; i < word.Length; i++)\\n            {\\n                if (i % 2 == 0)\\n                    even[word[i] - \\'a\\']++;\\n                else\\n                    odd[word[i] - \\'a\\']++;\\n            }\\n            set.Add(string.Concat(odd) + string.Concat(even));\\n        }\\n        return set.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        var set = new HashSet<string>();\\n        foreach(var word in words)\\n        {\\n            var odd = new int[26];\\n            var even = new int[26];\\n            for (int i = 0; i < word.Length; i++)\\n            {\\n                if (i % 2 == 0)\\n                    even[word[i] - \\'a\\']++;\\n                else\\n                    odd[word[i] - \\'a\\']++;\\n            }\\n            set.Add(string.Concat(odd) + string.Concat(even));\\n        }\\n        return set.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646751,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groups = set()\\n\\n        for x in words:\\n            counts = [0]*52\\n\\n            for i,x in enumerate(x):\\n                counts[ord(x)-ord(\\'a\\')+(26 if i%2 else 0)] += 1\\n            \\n            groups.add(tuple(counts))\\n        \\n        return len(groups)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groups = set()\\n\\n        for x in words:\\n            counts = [0]*52\\n\\n            for i,x in enumerate(x):\\n                counts[ord(x)-ord(\\'a\\')+(26 if i%2 else 0)] += 1\\n            \\n            groups.add(tuple(counts))\\n        \\n        return len(groups)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620807,
                "title": "java-simple-solution-using-stringbuilder-and-lists",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        for(String word: words){\\n            StringBuilder sortedString = new StringBuilder();\\n            StringBuilder evenList = new StringBuilder();\\n            StringBuilder oddList = new StringBuilder();\\n            for(int i =0;i<word.length(); i++){\\n                if(i%2 == 0){\\n                    evenList.append(word.charAt(i));\\n                }\\n                else{\\n                    oddList.append(word.charAt(i));\\n                }\\n            }\\n            char evenArray[] = evenList.toString().toCharArray();\\n            Arrays.sort(evenArray);\\n            sortedString.append(evenArray);\\n            char oddArray[] = oddList.toString().toCharArray();\\n            Arrays.sort(oddArray);\\n            sortedString.append(oddArray);\\n            list.add(sortedString.toString());\\n        }\\n        return (int)list.stream().distinct().count();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        for(String word: words){\\n            StringBuilder sortedString = new StringBuilder();\\n            StringBuilder evenList = new StringBuilder();\\n            StringBuilder oddList = new StringBuilder();\\n            for(int i =0;i<word.length(); i++){\\n                if(i%2 == 0){\\n                    evenList.append(word.charAt(i));\\n                }\\n                else{\\n                    oddList.append(word.charAt(i));\\n                }\\n            }\\n            char evenArray[] = evenList.toString().toCharArray();\\n            Arrays.sort(evenArray);\\n            sortedString.append(evenArray);\\n            char oddArray[] = oddList.toString().toCharArray();\\n            Arrays.sort(oddArray);\\n            sortedString.append(oddArray);\\n            list.add(sortedString.toString());\\n        }\\n        return (int)list.stream().distinct().count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611903,
                "title": "c-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set <string> st;\\n        for (auto w : words) {\\n            string odd, ev;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i%2==1)\\n                { ev += w[i];}\\n                else {\\n                odd += w[i];}\\n            }\\n            sort(odd.begin(),odd.end());\\n            sort(ev.begin(),ev.end());\\n            st.insert(odd+ev);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set <string> st;\\n        for (auto w : words) {\\n            string odd, ev;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i%2==1)\\n                { ev += w[i];}\\n                else {\\n                odd += w[i];}\\n            }\\n            sort(odd.begin(),odd.end());\\n            sort(ev.begin(),ev.end());\\n            st.insert(odd+ev);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574430,
                "title": "typescript-solution-using-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction numSpecialEquivGroups(words: string[]): number {\\n    const groups = {};\\n\\n    for (let word of words) {\\n        const map: Record<string, number> = {};\\n\\n        for (let i = 0; i < word.length; i++) {\\n            const hash = decode(word[i], i);\\n            map[hash] = map[hash] ?? 0;\\n            map[hash]++;\\n        }\\n\\n        const hash = decodeMappedWord(map)\\n\\n        groups[hash] = groups[hash] ?? true;\\n    }\\n\\n    return Object.keys(groups).length;\\n};\\n\\nfunction decode(letter: string, index: number): string {\\n    return `${letter}-${index % 2}`;\\n}\\n\\nfunction decodeMappedWord(map: Record<string,number>): string {\\n    return Object.keys(map).sort().reduce((acc, key) => acc + `${key}:${map[key]}`, \\'\\') \\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction numSpecialEquivGroups(words: string[]): number {\\n    const groups = {};\\n\\n    for (let word of words) {\\n        const map: Record<string, number> = {};\\n\\n        for (let i = 0; i < word.length; i++) {\\n            const hash = decode(word[i], i);\\n            map[hash] = map[hash] ?? 0;\\n            map[hash]++;\\n        }\\n\\n        const hash = decodeMappedWord(map)\\n\\n        groups[hash] = groups[hash] ?? true;\\n    }\\n\\n    return Object.keys(groups).length;\\n};\\n\\nfunction decode(letter: string, index: number): string {\\n    return `${letter}-${index % 2}`;\\n}\\n\\nfunction decodeMappedWord(map: Record<string,number>): string {\\n    return Object.keys(map).sort().reduce((acc, key) => acc + `${key}:${map[key]}`, \\'\\') \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567739,
                "title": "clean-easy-solution-explained-only-set-no-sort",
                "content": "If 2 strings are eqiv, then thier respective freq at even and odd indices must be same for the swap condition to be held true\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<pair<vector<int>,vector<int>>> s;\\n        for(auto &w:words)\\n        {\\n            vector<int> odd(26),even(26);\\n            for(int i=0;i<w.size();i++)\\n            {\\n                if(i%2) even[w[i]-\\'a\\']++;\\n                else odd[w[i]-\\'a\\']++;\\n            }\\n            s.insert({odd,even});\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<pair<vector<int>,vector<int>>> s;\\n        for(auto &w:words)\\n        {\\n            vector<int> odd(26),even(26);\\n            for(int i=0;i<w.size();i++)\\n            {\\n                if(i%2) even[w[i]-\\'a\\']++;\\n                else odd[w[i]-\\'a\\']++;\\n            }\\n            s.insert({odd,even});\\n        }\\n        return s.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497603,
                "title": "hashset-string-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        int n = words.length;\\n        for(int i=0;i<n;i++){\\n            String t1=\"\",t2=\"\";\\n            List<Character> even = new ArrayList<>();\\n            List<Character> odd = new ArrayList<>();\\n            for(int j=0;j<words[i].length();j++){\\n               if(j%2==0) even.add(words[i].charAt(j));\\n               else odd.add(words[i].charAt(j));}\\n               Collections.sort(even);\\n               Collections.sort(odd);\\n               for(int k=0;k<even.size();k++){\\n                  t1 += even.get(k);\\n               }\\n               for(int k=0;k<odd.size();k++){\\n                  t2 += odd.get(k);\\n               }\\n           set.add(t1+t2);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashSet<String> set = new HashSet<>();\\n        int n = words.length;\\n        for(int i=0;i<n;i++){\\n            String t1=\"\",t2=\"\";\\n            List<Character> even = new ArrayList<>();\\n            List<Character> odd = new ArrayList<>();\\n            for(int j=0;j<words[i].length();j++){\\n               if(j%2==0) even.add(words[i].charAt(j));\\n               else odd.add(words[i].charAt(j));}\\n               Collections.sort(even);\\n               Collections.sort(odd);\\n               for(int k=0;k<even.size();k++){\\n                  t1 += even.get(k);\\n               }\\n               for(int k=0;k<odd.size();k++){\\n                  t2 += odd.get(k);\\n               }\\n           set.add(t1+t2);\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466282,
                "title": "faster-than-100-hashset",
                "content": "# Intuition\\nadd every word charracters in different strings odd and even, then sort them and add to the hashset, if they\\'ve not been already added\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nn - words count \\nw - letters count (max 20 due to description)\\nO(n * w^2 * log(w))\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        HashSet<string> result = new HashSet<string>();\\n        foreach(string word in words)\\n        {\\n            string odd = \"\";\\n            string even = \"\";\\n            for (int i = 0; i < word.Length; i++)\\n            {\\n                if (i % 2 == 0) even += word[i];\\n                else odd+=word[i];\\n            }\\n            char[] odds = odd.ToCharArray();\\n            Array.Sort(odds);\\n            char[] evends = even.ToCharArray();\\n            Array.Sort(evends);\\n            string s = new string(odds) + new string(evends);\\n            result.Add(s);\\n        }\\n        return result.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        HashSet<string> result = new HashSet<string>();\\n        foreach(string word in words)\\n        {\\n            string odd = \"\";\\n            string even = \"\";\\n            for (int i = 0; i < word.Length; i++)\\n            {\\n                if (i % 2 == 0) even += word[i];\\n                else odd+=word[i];\\n            }\\n            char[] odds = odd.ToCharArray();\\n            Array.Sort(odds);\\n            char[] evends = even.ToCharArray();\\n            Array.Sort(evends);\\n            string s = new string(odds) + new string(evends);\\n            result.Add(s);\\n        }\\n        return result.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433479,
                "title": "java-simple-and-clear-solution-with-hash-table-implementation",
                "content": "# Complexity\\n- Time complexity: O(n + m)\\n  - n is number of words\\n  - m is total length of all words \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int[] odds = new int[26];\\n    private int[] evens = new int[26];\\n    private  StringBuilder sb = new StringBuilder();\\n\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();   \\n  \\n        for(String s : words){\\n            String key = generateKey(s);\\n            map.put(key, map.getOrDefault(key, 0) + 1);\\n        }\\n\\n        return map.keySet().size();\\n    }\\n\\n    private String generateKey(String s){\\n        boolean isOdd = true;\\n        sb.setLength(0);\\n        \\n        for(int i = 0; i < 26; i++){\\n            odds[i]=0;\\n            evens[i]=0;\\n        }\\n\\n        for(char c : s.toCharArray()){\\n            if(isOdd)\\n                odds[c-\\'a\\']++;\\n            else\\n                evens[c -\\'a\\']++;\\n            isOdd = !isOdd;\\n        }\\n\\n        for(int i = 0; i < 26; i++){\\n            sb.append(odds[i]);\\n            sb.append(evens[i]);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    private int[] odds = new int[26];\\n    private int[] evens = new int[26];\\n    private  StringBuilder sb = new StringBuilder();\\n\\n    public int numSpecialEquivGroups(String[] words) {\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();   \\n  \\n        for(String s : words){\\n            String key = generateKey(s);\\n            map.put(key, map.getOrDefault(key, 0) + 1);\\n        }\\n\\n        return map.keySet().size();\\n    }\\n\\n    private String generateKey(String s){\\n        boolean isOdd = true;\\n        sb.setLength(0);\\n        \\n        for(int i = 0; i < 26; i++){\\n            odds[i]=0;\\n            evens[i]=0;\\n        }\\n\\n        for(char c : s.toCharArray()){\\n            if(isOdd)\\n                odds[c-\\'a\\']++;\\n            else\\n                evens[c -\\'a\\']++;\\n            isOdd = !isOdd;\\n        }\\n\\n        for(int i = 0; i < 26; i++){\\n            sb.append(odds[i]);\\n            sb.append(evens[i]);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427024,
                "title": "not-very-good-solution-but-i-hope-it-ll-help-you",
                "content": "![Screenshot 2023-04-17 162629.png](https://assets.leetcode.com/users/images/d2ff9101-1e00-4fe8-be8f-1a1e83aeaa31_1681737995.5241587.png)\\n\\nAs there is no solution in c# yet I hope this will help you to understand the question better.\\n# Code\\n```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        int res = 0;\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            if (words[i] != \"\")\\n            {\\n                res++;\\n                List<char> evenCh = new();\\n                List<char> oddCh = new();\\n                for (int j = 0; j < words[i].Length; j++)\\n                {\\n                    if(j % 2 == 0)\\n                        evenCh.Add(words[i][j]);\\n                    else\\n                        oddCh.Add(words[i][j]);\\n                }\\n                for (int j = i + 1; j < words.Length; j++)\\n                {\\n                    List<char> tmp_evenCh = new List<char>(evenCh);\\n                    List<char> tmp_oddCh = new List<char>(oddCh);\\n                    bool add = true;\\n                    for (int k = 0; k < words[j].Length; k++)\\n                    {\\n                        if (k % 2 == 0 && tmp_evenCh.Contains(words[j][k]))\\n                        {\\n                            tmp_evenCh.Remove(words[j][k]);\\n                        }\\n                        else if(k % 2 == 0)\\n                        {\\n                            add = false;\\n                            break;\\n                        }\\n                        if(k % 2 == 1 && tmp_oddCh.Contains(words[j][k]))\\n                        {\\n                            tmp_oddCh.Remove(words[j][k]);\\n                        }\\n                        else if(k % 2 == 1)\\n                        {\\n                            add = false;\\n                            break;\\n                        }\\n                    }\\n                    if (add)\\n                    {\\n                        words[j] = \"\";\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumSpecialEquivGroups(string[] words) {\\n        int res = 0;\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            if (words[i] != \"\")\\n            {\\n                res++;\\n                List<char> evenCh = new();\\n                List<char> oddCh = new();\\n                for (int j = 0; j < words[i].Length; j++)\\n                {\\n                    if(j % 2 == 0)\\n                        evenCh.Add(words[i][j]);\\n                    else\\n                        oddCh.Add(words[i][j]);\\n                }\\n                for (int j = i + 1; j < words.Length; j++)\\n                {\\n                    List<char> tmp_evenCh = new List<char>(evenCh);\\n                    List<char> tmp_oddCh = new List<char>(oddCh);\\n                    bool add = true;\\n                    for (int k = 0; k < words[j].Length; k++)\\n                    {\\n                        if (k % 2 == 0 && tmp_evenCh.Contains(words[j][k]))\\n                        {\\n                            tmp_evenCh.Remove(words[j][k]);\\n                        }\\n                        else if(k % 2 == 0)\\n                        {\\n                            add = false;\\n                            break;\\n                        }\\n                        if(k % 2 == 1 && tmp_oddCh.Contains(words[j][k]))\\n                        {\\n                            tmp_oddCh.Remove(words[j][k]);\\n                        }\\n                        else if(k % 2 == 1)\\n                        {\\n                            add = false;\\n                            break;\\n                        }\\n                    }\\n                    if (add)\\n                    {\\n                        words[j] = \"\";\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386764,
                "title": "better-than-my-previous-version",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst, I noticed that two words are special equivalent iff their even characters are \"count equivalent\" and odd characters are \"count equivalent\", where two strings are \"count equivalent\" iff they have the same multiset of characters.  Two strings are \"count equivalent\" iff they are identical when their characters are sorted.  Second, when you want to count a number of objects subject to equivalence,\\nyou can use a ```set```. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first step is for each \"word\", to separate the even and the odd characters.  Then, for each of the two resulting strings, sort the characters in each, since two strings are \"count equivalent\" if their character-sorted versions are identical.  Then, count the number of pairs of the split, sorted words using a Set.  The function ```canon``` converts a word into a *canonical form* by splitting, sorting, and pairing.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time is at least proportional to the number of words.  Further, the sort inside ```canon``` is proportional to $$O(c log c)$$ where $$c$$ is the number of characters in each word.  The comparison used to maintain the set is $$O(c)$$.  The overall time complexity is $$O(n * c * log c)$$.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe only storage that grows is the set of canonicalized representations, which is proportional in the worst case to $$O(n * c)$$.\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groupCanons = set()\\n        for word in words:\\n            wordCanon = self.canon( word )\\n            groupCanons.add( wordCanon )\\n        return len( groupCanons )\\n    \\n    # Convert \"word\" into canonical form, which is the sorted\\n    # even characters and the sorted odd characters in \"word\":\\n    def canon( self, word ):\\n        result = ( \\'\\'.join( sorted( word[ 0::2] ) ), \\'\\'.join( sorted( word[1::2] ) ) )\\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```set```\n```canon```\n```canon```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groupCanons = set()\\n        for word in words:\\n            wordCanon = self.canon( word )\\n            groupCanons.add( wordCanon )\\n        return len( groupCanons )\\n    \\n    # Convert \"word\" into canonical form, which is the sorted\\n    # even characters and the sorted odd characters in \"word\":\\n    def canon( self, word ):\\n        result = ( \\'\\'.join( sorted( word[ 0::2] ) ), \\'\\'.join( sorted( word[1::2] ) ) )\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386492,
                "title": "simple-code-but-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thing I looked at was the even<->even and odd<->odd aspect of the definition of special equivalence.  I realized that two words w1 and w2 were special equivalent iff their even characters were special equivalent *and* their odd characters were special equivalent, since even and odd characters could never be swapped.  Next, I realized that two strings are special equivalent iff their character frequencies are the same.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI defined a function ```canon``` that maps an original \"word\" into a 2-tuple consisting of the character frequencies of even characters and character frequencies of odd characters.  Two words were then special equivalent iff their canonical representations are equal (thanks! to Python for making it so easy to compare 2-tuples of Counters).  Then it was a matter of counting how many distinct canonical representations were found; this was a little painful, since it involved an $$O(n)$$ loop that results in quadratic time complexity.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs noted above, the time complexity is proportional to $$O(n^2)$$.  There is an additional factor:  the canonicalization and comparisons in the counting loop are $$O(c)$$ where $$c$$ is the number of characters in each word.  Thus the overall time complexity is $$O(n^2*c)$$.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe storage cost for one canonical representation is $$O(c)$$, and we may have to store up to $$O(n)$$ canonical representations if none of the words are special-equivalent, making the overall space complexity $$O(n*c)$$.\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groupCanons = []\\n        for word in words:\\n            wordCanon = self.canon( word )\\n            found = False\\n            for groupCanon in groupCanons:\\n                if groupCanon == wordCanon:\\n                    found = True\\n                    break\\n            if not found:\\n                groupCanons.append( wordCanon )\\n        return len( groupCanons )\\n    \\n    # Convert \"word\" into canonical form, which is the letter\\n    # frequency of even characters and letter frequency of\\n    # odd characters in \"word\":\\n    def canon( self, word ):\\n        result = ( Counter( word[ 0::2] ), Counter( word[1::2] ) )\\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```canon```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        groupCanons = []\\n        for word in words:\\n            wordCanon = self.canon( word )\\n            found = False\\n            for groupCanon in groupCanons:\\n                if groupCanon == wordCanon:\\n                    found = True\\n                    break\\n            if not found:\\n                groupCanons.append( wordCanon )\\n        return len( groupCanons )\\n    \\n    # Convert \"word\" into canonical form, which is the letter\\n    # frequency of even characters and letter frequency of\\n    # odd characters in \"word\":\\n    def canon( self, word ):\\n        result = ( Counter( word[ 0::2] ), Counter( word[1::2] ) )\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384648,
                "title": "c-unordered-set-hash-table-sort-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can group words that are special equivalent by sorting their even-indexed and odd-indexed characters separately and then concatenating them back together. We can use an unordered set to keep track of the unique groups of special equivalent words.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each word in the input vector, we can extract the even-indexed characters and odd-indexed characters separately using a for loop with a step of 2. We can then sort both substrings and concatenate them back together to form a unique key. We can insert this key into an unordered set to keep track of the unique groups of special equivalent words. Finally, we can return the size of the unordered set as the number of special equivalent groups.\\n\\n# Complexity\\n- Time complexity: $$O(n * k * log(k))$$\\nwhere n is the number of words in the input vector, and k is the maximum length of a word in the input vector. We iterate through the input vector once, and for each word, we sort the even-indexed characters and odd-indexed characters separately, which takes O(k*log(k)) time.\\n\\n- Space complexity: $$O(n * k)$$\\nwhere n is the number of words in the input vector, and k is the maximum length of a word in the input vector. We store each sorted key in the unordered set, which takes O(k) space, and we may have up to n unique keys in the unordered set.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> st;\\n        for (auto& w : words) {\\n            string odd, even;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i % 2) even += w[i];\\n                else odd += w[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string> st;\\n        for (auto& w : words) {\\n            string odd, even;\\n            for (int i = 0; i < w.size(); i++) {\\n                if (i % 2) even += w[i];\\n                else odd += w[i];\\n            }\\n            sort(even.begin(), even.end());\\n            sort(odd.begin(), odd.end());\\n            st.insert(even + odd);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373279,
                "title": "i-dare-you-to-read-this-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        map<map<char,pair<int,int>>,string> mp;\\n\\n        for(int i = 0; i<words.size(); i++){\\n            map<char,pair<int,int>> m1;\\n            for(int j = 0; j<words[0].size(); j++){\\n                if(j%2 == 0) m1[words[i][j]].first++;\\n                else m1[words[i][j]].second++;\\n            }\\n            mp[m1] = words[i];\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        map<map<char,pair<int,int>>,string> mp;\\n\\n        for(int i = 0; i<words.size(); i++){\\n            map<char,pair<int,int>> m1;\\n            for(int j = 0; j<words[0].size(); j++){\\n                if(j%2 == 0) m1[words[i][j]].first++;\\n                else m1[words[i][j]].second++;\\n            }\\n            mp[m1] = words[i];\\n        }\\n\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364646,
                "title": "c-set-with-explanation",
                "content": "# **Please upvote and give feedback into comment**\\n\\n---\\n\\n\\n# Approach\\n\\n---\\n\\n\\nwe take set for uniqueness and store the one element from the pair(\"abcd\", \"cdba\") and return the length of set \\n\\n1. we add all the even string even=a+c , even =c+a  and odd string odd=b+d,odd=d+b \\n2. sort even and odd string \\n3. total=even +odd and store total into set and return the length of set\\n\\n---\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string>res;\\n       \\n        for(auto i:words)\\n        {\\n                string even=\"\",odd=\"\",tot=\"\";\\n                for (int j=0;j<i.size();j++)\\n                {\\n                    if(j%2==0)\\n                    {\\n                        even+=i[j];\\n                    }\\n                    else\\n                    {\\n                        odd+=i[j];\\n                    }\\n                }\\n                sort(even.begin(),even.end());\\n                sort(odd.begin(),odd.end());\\n            tot=even+odd;\\n            res.insert(tot);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string>res;\\n       \\n        for(auto i:words)\\n        {\\n                string even=\"\",odd=\"\",tot=\"\";\\n                for (int j=0;j<i.size();j++)\\n                {\\n                    if(j%2==0)\\n                    {\\n                        even+=i[j];\\n                    }\\n                    else\\n                    {\\n                        odd+=i[j];\\n                    }\\n                }\\n                sort(even.begin(),even.end());\\n                sort(odd.begin(),odd.end());\\n            tot=even+odd;\\n            res.insert(tot);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326597,
                "title": "python-hashmap-set-tuple",
                "content": "The trick here is that we create an array of size 52 to count occurances the first half being our characters that are even and the second half characters that are odd.\\n\\nOnce we have this we need to convert it into a tuple so it can be used as a key and we add it to our map/set.\\n\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        \\n        #solved using a tuple of size 52 to hold all of the alpha characters * 2 \\n        #the second half being used to hold odd and the first half to hold even\\n        mp = defaultdict(int)\\n        #tuple the size of 52\\n        for i in range(len(words)):\\n            a = [0] * 52\\n            for j in range(len(words[i])):\\n                char = words[i][j]\\n                if j % 2 == 0:\\n                    v = ord(char) - ord(\\'a\\')\\n                    a[v] += 1\\n                else:\\n                    v = ord(char) - ord(\\'a\\')\\n                    v += 26\\n                    a[v] +=1\\n            \\n            mp[tuple(a)] += 1\\n            \\n        \\n        \\n        return len(mp)\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "The trick here is that we create an array of size 52 to count occurances the first half being our characters that are even and the second half characters that are odd.\\n\\nOnce we have this we need to convert it into a tuple so it can be used as a key and we add it to our map/set.\\n\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        \\n        #solved using a tuple of size 52 to hold all of the alpha characters * 2 \\n        #the second half being used to hold odd and the first half to hold even\\n        mp = defaultdict(int)\\n        #tuple the size of 52\\n        for i in range(len(words)):\\n            a = [0] * 52\\n            for j in range(len(words[i])):\\n                char = words[i][j]\\n                if j % 2 == 0:\\n                    v = ord(char) - ord(\\'a\\')\\n                    a[v] += 1\\n                else:\\n                    v = ord(char) - ord(\\'a\\')\\n                    v += 26\\n                    a[v] +=1\\n            \\n            mp[tuple(a)] += 1\\n            \\n        \\n        \\n        return len(mp)\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 3302555,
                "title": "simple-java-solution-runtime-11ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n     Set<String>set=new HashSet<>();\\n     \\n     for(String word:words)\\n     {\\n         String even=\"\",odd=\"\";\\n         for(int i=0;i<word.length();i++)\\n         {\\n             if(i%2==0)\\n             {\\n                 even+=word.charAt(i);\\n             }\\n             else{\\n                 odd+=word.charAt(i);\\n             }\\n\\n         }\\n\\n         odd=sorted(odd);\\n         even=sorted(even);\\n         set.add(odd+even);\\n     } \\n     return set.size();  \\n    }\\n\\n    public String sorted(String s )\\n    {\\n        char[] c=s.toCharArray();\\n        Arrays.sort(c);\\n        return String.valueOf(c);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numSpecialEquivGroups(String[] words) {\\n     Set<String>set=new HashSet<>();\\n     \\n     for(String word:words)\\n     {\\n         String even=\"\",odd=\"\";\\n         for(int i=0;i<word.length();i++)\\n         {\\n             if(i%2==0)\\n             {\\n                 even+=word.charAt(i);\\n             }\\n             else{\\n                 odd+=word.charAt(i);\\n             }\\n\\n         }\\n\\n         odd=sorted(odd);\\n         even=sorted(even);\\n         set.add(odd+even);\\n     } \\n     return set.size();  \\n    }\\n\\n    public String sorted(String s )\\n    {\\n        char[] c=s.toCharArray();\\n        Arrays.sort(c);\\n        return String.valueOf(c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275835,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) \\n    {\\n        unordered_map<string ,int>u;\\n       for(int i=0;i<w.size();++i)\\n       {\\n           string s1=\"\",s2=\"\";\\n           for(int j=0;j<w[i].length();++j)\\n           {\\n               if(j%2!=0)\\n                   s2.push_back(w[i][j]);\\n               else\\n                   s1.push_back(w[i][j]);\\n           }\\n           sort(s1.begin(),s1.end());\\n           sort(s2.begin(),s2.end());\\n           int k=0;\\n           for(int j=0;j<w[i].length();++j)\\n           {\\n               if(j%2!=0)\\n                   w[i][j]=s2[k++];\\n               else\\n                 w[i][j]=s1[k];\\n           }\\n           ++u[w[i]];\\n       }\\n        int c=0;\\n        for(auto a:u)\\n        {\\n            ++c;\\n            \\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) \\n    {\\n        unordered_map<string ,int>u;\\n       for(int i=0;i<w.size();++i)\\n       {\\n           string s1=\"\",s2=\"\";\\n           for(int j=0;j<w[i].length();++j)\\n           {\\n               if(j%2!=0)\\n                   s2.push_back(w[i][j]);\\n               else\\n                   s1.push_back(w[i][j]);\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 3255268,
                "title": "python3-one-liner-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        return len(Counter([\"\".join(sorted(w[1::2]) + sorted(w[::2])) for w in words]))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numSpecialEquivGroups(self, words: List[str]) -> int:\\n        return len(Counter([\"\".join(sorted(w[1::2]) + sorted(w[::2])) for w in words]))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238916,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string>Set ;\\n        for(auto& word : words)\\n        {\\n            string even, odd ;\\n            for(int i = 0; i < word.size(); i++)\\n            {\\n                if(i % 2)\\n                    odd.push_back(word[i]) ;\\n                else\\n                    even.push_back(word[i]) ;\\n            }\\n            sort(even.begin(), even.end()) ;\\n            sort(odd.begin(), odd.end()) ;\\n            Set.insert(even + odd) ;\\n        }\\n        return Set.size() ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_set<string>Set ;\\n        for(auto& word : words)\\n        {\\n            string even, odd ;\\n            for(int i = 0; i < word.size(); i++)\\n            {\\n                if(i % 2)\\n                    odd.push_back(word[i]) ;\\n                else\\n                    even.push_back(word[i]) ;\\n            }\\n            sort(even.begin(), even.end()) ;\\n            sort(odd.begin(), odd.end()) ;\\n            Set.insert(even + odd) ;\\n        }\\n        return Set.size() ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205327,
                "title": "rust-0ms",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn num_special_equiv_groups(words: Vec<String>) -> i32 {\\n        use std::collections::HashSet;\\n        words\\n            .into_iter()\\n            .map(|w| {\\n                let (mut even, mut odd) = (vec![0; 26], vec![0; 26]);\\n                for (i, ch) in w.chars().enumerate() {\\n                    let idx = ch as usize - \\'a\\' as usize;\\n                    if i % 2 == 0 {\\n                        even[idx] += 1;\\n                    } else {\\n                        odd[idx] += 1;\\n                    }\\n                }\\n                (even, odd)\\n            })\\n            .fold(HashSet::new(), |mut acc, k| {\\n                acc.insert(k);\\n                acc\\n            })\\n            .len() as i32   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_special_equiv_groups(words: Vec<String>) -> i32 {\\n        use std::collections::HashSet;\\n        words\\n            .into_iter()\\n            .map(|w| {\\n                let (mut even, mut odd) = (vec![0; 26], vec![0; 26]);\\n                for (i, ch) in w.chars().enumerate() {\\n                    let idx = ch as usize - \\'a\\' as usize;\\n                    if i % 2 == 0 {\\n                        even[idx] += 1;\\n                    } else {\\n                        odd[idx] += 1;\\n                    }\\n                }\\n                (even, odd)\\n            })\\n            .fold(HashSet::new(), |mut acc, k| {\\n                acc.insert(k);\\n                acc\\n            })\\n            .len() as i32   \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3192615,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func numSpecialEquivGroups(_ words: [String]) -> Int {\\n        Set(\\n            words\\n                .map { w -> String in\\n                    let cs = w.map { $0 }\\n                    let es = cs.indices.filter({ $0 % 2 == 0 }).map({ cs[$0] })\\n                    let os = cs.indices.filter({ $0 % 2 == 1 }).map({ cs[$0] })\\n                    return String(es.sorted() + os.sorted())\\n                }\\n        ).count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numSpecialEquivGroups(_ words: [String]) -> Int {\\n        Set(\\n            words\\n                .map { w -> String in\\n                    let cs = w.map { $0 }\\n                    let es = cs.indices.filter({ $0 % 2 == 0 }).map({ cs[$0] })\\n                    let os = cs.indices.filter({ $0 % 2 == 1 }).map({ cs[$0] })\\n                    return String(es.sorted() + os.sorted())\\n                }\\n        ).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169209,
                "title": "c-solution-using-map-and-set",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        set<pair<map<char,int>,map<char,int>>>s;\\n        for(int i=0;i<w.size();++i){\\n            map<char,int>odd;\\n            map<char,int>even;\\n            for(int j=0;j<w[i].size();++j){\\n                if(j%2==0)\\n                   even[w[i][j]]++;\\n                else\\n                   odd[w[i][j]]++;\\n            }\\n            s.insert({even,odd});\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        set<pair<map<char,int>,map<char,int>>>s;\\n        for(int i=0;i<w.size();++i){\\n            map<char,int>odd;\\n            map<char,int>even;\\n            for(int j=0;j<w[i].size();++j){\\n                if(j%2==0)\\n                   even[w[i][j]]++;\\n                else\\n                   odd[w[i][j]]++;\\n            }\\n            s.insert({even,odd});\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142211,
                "title": "simple-and-concise-beats-98-c-set-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string> res;\\n        for(auto s:words)\\n        {\\n            string ev = \"\";\\n            string od = \"\";\\n            for(int i = 0;i<s.size();i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ev = ev+s[i];\\n                }\\n                else\\n                    od = od+s[i];\\n            }\\n            sort(ev.begin(), ev.end());\\n            sort(od.begin(), od.end());\\n            string final_str = ev+od;\\n            if(res.count(final_str)==0)\\n                res.insert(final_str);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<string> res;\\n        for(auto s:words)\\n        {\\n            string ev = \"\";\\n            string od = \"\";\\n            for(int i = 0;i<s.size();i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ev = ev+s[i];\\n                }\\n                else\\n                    od = od+s[i];\\n            }\\n            sort(ev.begin(), ev.end());\\n            sort(od.begin(), od.end());\\n            string final_str = ev+od;\\n            if(res.count(final_str)==0)\\n                res.insert(final_str);\\n        }\\n        return res.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140656,
                "title": "easy-direct-approach",
                "content": "# Approach\\nuse the brute force approach as the parameters are comfortable in doing that.\\nStore the map of even and odd words count of each words and compare them using a brute force method.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        vector<unordered_map<char,int>> a(words.size()),b(words.size());\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j = 0;j<words[i].size();j=j+2)\\n            {\\n                a[i][words[i][j]]++;\\n            }\\n            for(int j = 1;j<words[i].size();j=j+2)\\n            {\\n                b[i][words[i][j]]++;\\n            }\\n        }\\n        int ans = 0 ;\\n        for(int k = 0 ; k<words.size()-1;k++)\\n        {\\n            if(words[k]!=\" \")\\n            {\\n                for(int j=k+1;j<words.size();j++)\\n                {\\n                    if(words[j]!=\" \")\\n                    {\\n                        \\n                        if(a[k]==a[j] and b[k]==b[j])\\n                        {\\n                            ans++;\\n                            words[j] = \" \";\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return words.size() - ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        vector<unordered_map<char,int>> a(words.size()),b(words.size());\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j = 0;j<words[i].size();j=j+2)\\n            {\\n                a[i][words[i][j]]++;\\n            }\\n            for(int j = 1;j<words[i].size();j=j+2)\\n            {\\n                b[i][words[i][j]]++;\\n            }\\n        }\\n        int ans = 0 ;\\n        for(int k = 0 ; k<words.size()-1;k++)\\n        {\\n            if(words[k]!=\" \")\\n            {\\n                for(int j=k+1;j<words.size();j++)\\n                {\\n                    if(words[j]!=\" \")\\n                    {\\n                        \\n                        if(a[k]==a[j] and b[k]==b[j])\\n                        {\\n                            ans++;\\n                            words[j] = \" \";\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return words.size() - ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133726,
                "title": "c-map-and-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, int> m;\\n        for (auto& s : words){\\n            string odd = \"\";\\n            string even = \"\";\\n            for (int i = 0; i < s.size(); ++i){\\n                if (i % 2 == 0) even += s[i];\\n                else odd += s[i];\\n            }\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            ++m[odd + even];\\n        }\\n        return m.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        unordered_map<string, int> m;\\n        for (auto& s : words){\\n            string odd = \"\";\\n            string even = \"\";\\n            for (int i = 0; i < s.size(); ++i){\\n                if (i % 2 == 0) even += s[i];\\n                else odd += s[i];\\n            }\\n            sort(odd.begin(), odd.end());\\n            sort(even.begin(), even.end());\\n            ++m[odd + even];\\n        }\\n        return m.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131918,
                "title": "easiest-solution-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        map<pair<string,string>,int> mp;\\n        for(auto &i:words){\\n            string t = \"\",s=\"\";\\n            for(int j=0;j<i.length();j++){\\n                if(j%2) s+=i[j];\\n                else t+=i[j];\\n            }\\n            sort(t.begin(),t.end()),sort(s.begin(),s.end());\\n            pair<string,string> pr = {t,s};\\n            mp[pr]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        map<pair<string,string>,int> mp;\\n        for(auto &i:words){\\n            string t = \"\",s=\"\";\\n            for(int j=0;j<i.length();j++){\\n                if(j%2) s+=i[j];\\n                else t+=i[j];\\n            }\\n            sort(t.begin(),t.end()),sort(s.begin(),s.end());\\n            pair<string,string> pr = {t,s};\\n            mp[pr]++;\\n        }\\n        return mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122297,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<pair<string,string>>st;\\n        for(int i=0;i<words.size();i++){\\n            string emp=\"\",omp=\"\";\\n            for(int j=0;j<words[i].size();j+=2)\\n            emp+=words[i][j];\\n            for(int j=1;j<words[i].size();j+=2)\\n            omp+=words[i][j];\\n            sort(emp.begin(),emp.end());\\n            sort(omp.begin(),omp.end());\\n            st.insert({emp,omp});\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& words) {\\n        set<pair<string,string>>st;\\n        for(int i=0;i<words.size();i++){\\n            string emp=\"\",omp=\"\";\\n            for(int j=0;j<words[i].size();j+=2)\\n            emp+=words[i][j];\\n            for(int j=1;j<words[i].size();j+=2)\\n            omp+=words[i][j];\\n            sort(emp.begin(),emp.end());\\n            sort(omp.begin(),omp.end());\\n            st.insert({emp,omp});\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106915,
                "title": "c-short-easy-solution",
                "content": "Approach:-\\n\\nwe first keep odd and even indexes character seperate and the sort it and then put in set\\nso we get only unique words that is answer\\n\\n\\n\\nclass Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        set<string>s;\\n        for(int i=0;i<w.size();i++){\\n            string e=\"\",o=\"\";\\n            for(int j=0;j<w[i].size();j++){\\n                if(j%2==0)\\n                    e+=w[i][j];\\n                else\\n                    o+=w[i][j];\\n            }\\n            sort(e.begin(),e.end());\\n            sort(o.begin(),o.end());\\n            s.insert(o+e);\\n        }\\n        return s.size();\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int numSpecialEquivGroups(vector<string>& w) {\\n        set<string>s;\\n        for(int i=0;i<w.size();i++){\\n            string e=\"\",o=\"\";\\n            for(int j=0;j<w[i].size();j++){\\n                if(j%2==0)\\n                    e+=w[i][j];\\n                else\\n                    o+=w[i][j];\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564644,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1565190,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1573918,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1568182,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1567392,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1569321,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1568050,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572660,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572130,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572110,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1564644,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1565190,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1573918,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1568182,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1567392,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1569321,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1568050,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572660,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572130,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            },
            {
                "id": 1572110,
                "content": [
                    {
                        "username": "sjw214",
                        "content": "I\\'m sure this question is probably easy once you know what the hell is being asked, but after reading the description several times, I\\'m giving up on trying to make sense of what is even being accomplished here."
                    },
                    {
                        "username": "ihainan72",
                        "content": "...A really simple problem, but costed me a lot of time to understand the description during the contest...\\n\\n`A` and A are different...\\n\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ihainan72/image_1535252579.png)\\n\\n"
                    },
                    {
                        "username": "cphung1997",
                        "content": "Can someone explain to me why this test case get the output of 3?\\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\\nOutput: 3"
                    },
                    {
                        "username": "nupur_singhal",
                        "content": "[@Saiteja6](/Saiteja6) thanks, that saved my time :)"
                    },
                    {
                        "username": "shahan989",
                        "content": "[@Saiteja6](/Saiteja6)  hahhaha thank you, I was returning the max, instead of the number of groups lol"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "just see the question.just see what we have to return i did the same mistake if you are getting the answer as 2. just see the last line of question"
                    },
                    {
                        "username": "kirlevon",
                        "content": "[\"abcd\",\"cdab\",\"adcb\",\"cbad\"] gives 2 even though it should be 1\\nEven positions have letters a,c\\nOdd positions have letters b,d"
                    },
                    {
                        "username": "JustYouHx",
                        "content": "![image](https://assets.leetcode.com/users/justyouhx/image_1560412146.png)\\n"
                    },
                    {
                        "username": "Vulfgang",
                        "content": "I do not really understand the question, can anyone explain this in simpler terms than what is provided?"
                    },
                    {
                        "username": "wanglu",
                        "content": "A group of special-equivalent strings from A is a non-empty subset S of A such that any string *not* in S is *not* special-equivalent with any string in S. \\n\\nWhy cannot state as \"A group of special-equivalent strings from A is (the biggest) non-empty subset S of A such that any string in S is special-equivalent with other strings in S\"? \\n\\nThis two *not* makes the definition harder to understand. Is there any difference? "
                    },
                    {
                        "username": "hou546714396",
                        "content": "\\u2460Who can tell me the reason why the result of the testcase in the picture1 is 3 \\uFF1F\\n\\u2461 As shown in the picture 2\\uFF0CWhy is the test result different from the submission result in this testcase?\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030464.png)\\n![image](https://assets.leetcode.com/users/hou546714396/image_1557030474.png)"
                    },
                    {
                        "username": "shengchaohua",
                        "content": "The description is a little difficult to understand. \\nCould someone tell me whether \\'abca\\' is special-equivalent with \\'caab\\'?\\nAnd whether the letters of different strings in A are different each other?"
                    },
                    {
                        "username": "lance6716",
                        "content": "\\'...such that any string not in S...\\' should be \\'...such that any string in A but not in S...\\'"
                    }
                ]
            }
        ]
    }
]